[
  {
    "function_name": "memcached_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
    "lines": "789-834",
    "snippet": "memcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}",
    "includes": [
      "#include \"libmemcached/string.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_read_one_response",
          "args": [
            "instance",
            "buffer",
            "buffer_length",
            "result"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "_read_one_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
          "lines": "745-769",
          "snippet": "static memcached_return_t _read_one_response(memcached_instance_st *instance, char *buffer,\n                                             const size_t buffer_length,\n                                             memcached_result_st *result) {\n  memcached_server_response_decrement(instance);\n\n  if (result == NULL) {\n    Memcached *root = (Memcached *) instance->root;\n    result = &root->result;\n  }\n\n  memcached_return_t rc;\n  if (memcached_is_binary(instance->root)) {\n    do {\n      rc = binary_read_one_response(instance, buffer, buffer_length, result);\n    } while (rc == MEMCACHED_FETCH_NOTFINISHED);\n  } else {\n    rc = textual_read_one_response(instance, buffer, buffer_length, result);\n  }\n\n  if (memcached_fatal(rc) && rc != MEMCACHED_TIMEOUT) {\n    memcached_io_reset(instance);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t _read_one_response(memcached_instance_st *instance, char *buffer,\n                                             const size_t buffer_length,\n                                             memcached_result_st *result) {\n  memcached_server_response_decrement(instance);\n\n  if (result == NULL) {\n    Memcached *root = (Memcached *) instance->root;\n    result = &root->result;\n  }\n\n  memcached_return_t rc;\n  if (memcached_is_binary(instance->root)) {\n    do {\n      rc = binary_read_one_response(instance, buffer, buffer_length, result);\n    } while (rc == MEMCACHED_FETCH_NOTFINISHED);\n  } else {\n    rc = textual_read_one_response(instance, buffer, buffer_length, result);\n  }\n\n  if (memcached_fatal(rc) && rc != MEMCACHED_TIMEOUT) {\n    memcached_io_reset(instance);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_result_free",
          "args": [
            "junked_result_ptr"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_result_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/result.cc",
          "lines": "66-82",
          "snippet": "void memcached_result_free(memcached_result_st *ptr) {\n  if (ptr == NULL) {\n    return;\n  }\n\n  memcached_string_free(&ptr->value);\n  ptr->numeric_value = UINT64_MAX;\n\n  if (memcached_is_allocated(ptr)) {\n    WATCHPOINT_ASSERT(\n        ptr->root); // Without a root, that means that result was not properly initialized.\n    libmemcached_free(ptr->root, ptr);\n  } else {\n    ptr->count = 0;\n    ptr->options.is_initialized = false;\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_result_free(memcached_result_st *ptr) {\n  if (ptr == NULL) {\n    return;\n  }\n\n  memcached_string_free(&ptr->value);\n  ptr->numeric_value = UINT64_MAX;\n\n  if (memcached_is_allocated(ptr)) {\n    WATCHPOINT_ASSERT(\n        ptr->root); // Without a root, that means that result was not properly initialized.\n    libmemcached_free(ptr->root, ptr);\n  } else {\n    ptr->count = 0;\n    ptr->options.is_initialized = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_fatal",
          "args": [
            "rc"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_response_count",
          "args": [
            "instance"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_response_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "179-186",
          "snippet": "uint32_t memcached_server_response_count(const memcached_instance_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL) {\n    return 0;\n  }\n\n  return self->cursor_active_;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_response_count(const memcached_instance_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL) {\n    return 0;\n  }\n\n  return self->cursor_active_;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "junked_result_ptr"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_result_create",
          "args": [
            "instance->root",
            "&junked_result"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_binary",
          "args": [
            "instance->root"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s:%d: %s\\n\"",
            "__FILE__",
            "__LINE__",
            "memcached_strerror(NULL, read_rc)"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_strerror",
          "args": [
            "NULL",
            "read_rc"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_io_wait_for_read",
          "args": [
            "instance"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_wait_for_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "368-370",
          "snippet": "memcached_return_t memcached_io_wait_for_read(memcached_instance_st *instance) {\n  return io_wait(instance, POLLIN);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_io_wait_for_read(memcached_instance_st *instance) {\n  return io_wait(instance, POLLIN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_io_write",
          "args": [
            "instance"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "592-595",
          "snippet": "bool memcached_io_write(memcached_instance_st *instance) {\n  size_t written;\n  return _io_write(instance, NULL, 0, true, written);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_io_write(memcached_instance_st *instance) {\n  size_t written;\n  return _io_write(instance, NULL, 0, true, written);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_processing_input",
          "args": [
            "instance->root"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*instance",
            "MEMCACHED_NOT_SUPPORTED",
            "MEMCACHED_AT"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_udp",
          "args": [
            "instance->root"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}"
  },
  {
    "function_name": "memcached_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
    "lines": "782-787",
    "snippet": "memcached_return_t memcached_response(memcached_instance_st *instance,\n                                      memcached_result_st *result) {\n  char buffer[1024];\n\n  return memcached_response(instance, buffer, sizeof(buffer), result);\n}",
    "includes": [
      "#include \"libmemcached/string.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_response",
          "args": [
            "instance",
            "buffer",
            "sizeof(buffer)",
            "result"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
          "lines": "789-834",
          "snippet": "memcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_response(memcached_instance_st *instance,\n                                      memcached_result_st *result) {\n  char buffer[1024];\n\n  return memcached_response(instance, buffer, sizeof(buffer), result);\n}"
  },
  {
    "function_name": "memcached_read_one_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
    "lines": "771-780",
    "snippet": "memcached_return_t memcached_read_one_response(memcached_instance_st *instance,\n                                               memcached_result_st *result) {\n  char buffer[SMALL_STRING_LEN];\n\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  return _read_one_response(instance, buffer, sizeof(buffer), result);\n}",
    "includes": [
      "#include \"libmemcached/string.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_read_one_response",
          "args": [
            "instance",
            "buffer",
            "sizeof(buffer)",
            "result"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "_read_one_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
          "lines": "745-769",
          "snippet": "static memcached_return_t _read_one_response(memcached_instance_st *instance, char *buffer,\n                                             const size_t buffer_length,\n                                             memcached_result_st *result) {\n  memcached_server_response_decrement(instance);\n\n  if (result == NULL) {\n    Memcached *root = (Memcached *) instance->root;\n    result = &root->result;\n  }\n\n  memcached_return_t rc;\n  if (memcached_is_binary(instance->root)) {\n    do {\n      rc = binary_read_one_response(instance, buffer, buffer_length, result);\n    } while (rc == MEMCACHED_FETCH_NOTFINISHED);\n  } else {\n    rc = textual_read_one_response(instance, buffer, buffer_length, result);\n  }\n\n  if (memcached_fatal(rc) && rc != MEMCACHED_TIMEOUT) {\n    memcached_io_reset(instance);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t _read_one_response(memcached_instance_st *instance, char *buffer,\n                                             const size_t buffer_length,\n                                             memcached_result_st *result) {\n  memcached_server_response_decrement(instance);\n\n  if (result == NULL) {\n    Memcached *root = (Memcached *) instance->root;\n    result = &root->result;\n  }\n\n  memcached_return_t rc;\n  if (memcached_is_binary(instance->root)) {\n    do {\n      rc = binary_read_one_response(instance, buffer, buffer_length, result);\n    } while (rc == MEMCACHED_FETCH_NOTFINISHED);\n  } else {\n    rc = textual_read_one_response(instance, buffer, buffer_length, result);\n  }\n\n  if (memcached_fatal(rc) && rc != MEMCACHED_TIMEOUT) {\n    memcached_io_reset(instance);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*instance",
            "MEMCACHED_NOT_SUPPORTED",
            "MEMCACHED_AT"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_udp",
          "args": [
            "instance->root"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_read_one_response(memcached_instance_st *instance,\n                                               memcached_result_st *result) {\n  char buffer[SMALL_STRING_LEN];\n\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  return _read_one_response(instance, buffer, sizeof(buffer), result);\n}"
  },
  {
    "function_name": "_read_one_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
    "lines": "745-769",
    "snippet": "static memcached_return_t _read_one_response(memcached_instance_st *instance, char *buffer,\n                                             const size_t buffer_length,\n                                             memcached_result_st *result) {\n  memcached_server_response_decrement(instance);\n\n  if (result == NULL) {\n    Memcached *root = (Memcached *) instance->root;\n    result = &root->result;\n  }\n\n  memcached_return_t rc;\n  if (memcached_is_binary(instance->root)) {\n    do {\n      rc = binary_read_one_response(instance, buffer, buffer_length, result);\n    } while (rc == MEMCACHED_FETCH_NOTFINISHED);\n  } else {\n    rc = textual_read_one_response(instance, buffer, buffer_length, result);\n  }\n\n  if (memcached_fatal(rc) && rc != MEMCACHED_TIMEOUT) {\n    memcached_io_reset(instance);\n  }\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/string.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_io_reset",
          "args": [
            "instance"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "740-742",
          "snippet": "void memcached_io_reset(memcached_instance_st *instance) {\n  memcached_quit_server(instance, true);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_io_reset(memcached_instance_st *instance) {\n  memcached_quit_server(instance, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_fatal",
          "args": [
            "rc"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "textual_read_one_response",
          "args": [
            "instance",
            "buffer",
            "buffer_length",
            "result"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "textual_read_one_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
          "lines": "175-439",
          "snippet": "static memcached_return_t textual_read_one_response(memcached_instance_st *instance, char *buffer,\n                                                    const size_t buffer_length,\n                                                    memcached_result_st *result) {\n  size_t total_read;\n  memcached_return_t rc = memcached_io_readline(instance, buffer, buffer_length, total_read);\n\n  if (memcached_failed(rc)) {\n    return rc;\n  }\n  assert(total_read);\n\n  switch (buffer[0]) {\n  case 'V': {\n    // VALUE\n    if (buffer[1] == 'A' and buffer[2] == 'L' and buffer[3] == 'U' and buffer[4] == 'E') /* VALUE */\n    {\n      /* We add back in one because we will need to search for END */\n      memcached_server_response_increment(instance);\n      return textual_value_fetch(instance, buffer, result);\n    }\n    // VERSION\n    else if (buffer[1] == 'E' and buffer[2] == 'R' and buffer[3] == 'S' and buffer[4] == 'I'\n             and buffer[5] == 'O' and buffer[6] == 'N') /* VERSION */\n    {\n      /* Find the space, and then move one past it to copy version */\n      char *response_ptr = strchr(buffer, ' ');\n\n      char *endptr;\n      errno = 0;\n      long int version = strtol(response_ptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX\n          or version == 0) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse major version\"));\n      }\n      instance->major_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse minor version\"));\n      }\n      instance->minor_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse micro version\"));\n      }\n      instance->micro_version = uint8_t(version);\n\n      return MEMCACHED_SUCCESS;\n    }\n  } break;\n\n  case 'O': {\n    // OK\n    if (buffer[1] == 'K') {\n      return MEMCACHED_SUCCESS;\n    }\n  } break;\n\n  case 'S': {\n    // STAT\n    if (buffer[1] == 'T' and buffer[2] == 'A' and buffer[3] == 'T') /* STORED STATS */ {\n      memcached_server_response_increment(instance);\n      return MEMCACHED_STAT;\n    }\n    // SERVER_ERROR\n    else if (buffer[1] == 'E' and buffer[2] == 'R' and buffer[3] == 'V' and buffer[4] == 'E'\n             and buffer[5] == 'R' and buffer[6] == '_' and buffer[7] == 'E' and buffer[8] == 'R'\n             and buffer[9] == 'R' and buffer[10] == 'O' and buffer[11] == 'R')\n    {\n      if (total_read == memcached_literal_param_size(\"SERVER_ERROR\")) {\n        return MEMCACHED_SERVER_ERROR;\n      }\n\n      if (total_read >= memcached_literal_param_size(\"SERVER_ERROR object too large for cache\")\n          and (memcmp(buffer, memcached_literal_param(\"SERVER_ERROR object too large for cache\"))\n               == 0))\n      {\n        return MEMCACHED_E2BIG;\n      }\n\n      if (total_read >= memcached_literal_param_size(\"SERVER_ERROR out of memory\")\n          and ((memcmp(buffer, memcached_literal_param(\"SERVER_ERROR out of memory\")) == 0)\n               or (memcmp(buffer, memcached_literal_param(\"SERVER_ERROR Out of memory\")) == 0)))\n      {\n        return MEMCACHED_SERVER_MEMORY_ALLOCATION_FAILURE;\n      }\n\n      // Move past the basic error message and whitespace\n      char *startptr = buffer + memcached_literal_param_size(\"SERVER_ERROR\");\n      if (startptr[0] == ' ') {\n        startptr++;\n      }\n\n      char *endptr = startptr;\n      while (*endptr != '\\r' && *endptr != '\\n') endptr++;\n\n      return memcached_set_error(*instance, MEMCACHED_SERVER_ERROR, MEMCACHED_AT, startptr,\n                                 size_t(endptr - startptr));\n    }\n    // STORED\n    else if (buffer[1] == 'T' and buffer[2] == 'O'\n             and buffer[3] == 'R') //  and buffer[4] == 'E' and buffer[5] == 'D')\n    {\n      return MEMCACHED_STORED;\n    }\n  } break;\n\n  case 'D': {\n    // DELETED\n    if (buffer[1] == 'E' and buffer[2] == 'L' and buffer[3] == 'E' and buffer[4] == 'T'\n        and buffer[5] == 'E' and buffer[6] == 'D')\n    {\n      return MEMCACHED_DELETED;\n    }\n  } break;\n\n  case 'N': {\n    // NOT_FOUND\n    if (buffer[1] == 'O' and buffer[2] == 'T' and buffer[3] == '_' and buffer[4] == 'F'\n        and buffer[5] == 'O' and buffer[6] == 'U' and buffer[7] == 'N' and buffer[8] == 'D')\n    {\n      return MEMCACHED_NOTFOUND;\n    }\n    // NOT_STORED\n    else if (buffer[1] == 'O' and buffer[2] == 'T' and buffer[3] == '_' and buffer[4] == 'S'\n             and buffer[5] == 'T' and buffer[6] == 'O' and buffer[7] == 'R' and buffer[8] == 'E'\n             and buffer[9] == 'D')\n    {\n      return MEMCACHED_NOTSTORED;\n    }\n  } break;\n\n  case 'E': /* PROTOCOL ERROR or END */\n  {\n    // END\n    if (buffer[1] == 'N' and buffer[2] == 'D') {\n      return MEMCACHED_END;\n    }\n#if 0\n      // PROTOCOL_ERROR\n      else if (buffer[1] == 'R' and buffer[2] == 'O' and buffer[3] == 'T' and buffer[4] == 'O' and buffer[5] == 'C' and buffer[6] == 'O' and buffer[7] == 'L'\n               and buffer[8] == '_'\n               and buffer[9] == 'E' and buffer[10] == 'R' and buffer[11] == 'R' and buffer[12] == 'O' and buffer[13] == 'R')\n      {\n        return MEMCACHED_PROTOCOL_ERROR;\n      }\n#endif\n    // ERROR\n    else if (buffer[1] == 'R' and buffer[2] == 'R' and buffer[3] == 'O' and buffer[4] == 'R')\n    {\n      return MEMCACHED_ERROR;\n    }\n    // EXISTS\n    else if (buffer[1] == 'X' and buffer[2] == 'I' and buffer[3] == 'S' and buffer[4] == 'T'\n             and buffer[5] == 'S')\n    {\n      return MEMCACHED_DATA_EXISTS;\n    }\n  } break;\n\n  case 'T': /* TOUCHED */\n  {\n    // TOUCHED\n    if (buffer[1] == 'O' and buffer[2] == 'U' and buffer[3] == 'C' and buffer[4] == 'H'\n        and buffer[5] == 'E' and buffer[6] == 'D')\n    {\n      return MEMCACHED_SUCCESS;\n    }\n  } break;\n\n  case 'I': /* ITEM */\n  {\n    // ITEM\n    if (buffer[1] == 'T' and buffer[2] == 'E' and buffer[3] == 'M') {\n      /* We add back in one because we will need to search for END */\n      memcached_server_response_increment(instance);\n      return MEMCACHED_ITEM;\n    }\n  } break;\n\n  case 'C': /* CLIENT ERROR */\n  {\n    // CLIENT_ERROR\n    if (buffer[1] == 'L' and buffer[2] == 'I' and buffer[3] == 'E' and buffer[4] == 'N'\n        and buffer[5] == 'T' and buffer[6] == '_' and buffer[7] == 'E' and buffer[8] == 'R'\n        and buffer[9] == 'R' and buffer[10] == 'O' and buffer[11] == 'R')\n    {\n      // Move past the basic error message and whitespace\n      char *startptr = buffer + memcached_literal_param_size(\"CLIENT_ERROR\");\n      if (startptr[0] == ' ') {\n        startptr++;\n      }\n\n      char *endptr = startptr;\n      while (*endptr != '\\r' && *endptr != '\\n') endptr++;\n\n      return memcached_set_error(*instance, MEMCACHED_CLIENT_ERROR, MEMCACHED_AT, startptr,\n                                 size_t(endptr - startptr));\n    }\n  } break;\n\n  case '0': /* INCR/DECR response */\n  case '1': /* INCR/DECR response */\n  case '2': /* INCR/DECR response */\n  case '3': /* INCR/DECR response */\n  case '4': /* INCR/DECR response */\n  case '5': /* INCR/DECR response */\n  case '6': /* INCR/DECR response */\n  case '7': /* INCR/DECR response */\n  case '8': /* INCR/DECR response */\n  case '9': /* INCR/DECR response */\n  {\n    errno = 0;\n    unsigned long long int auto_return_value = strtoull(buffer, (char **) NULL, 10);\n\n    if (auto_return_value == ULLONG_MAX and errno == ERANGE) {\n      result->numeric_value = UINT64_MAX;\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"Numeric response was out of range\"));\n    } else if (errno == EINVAL) {\n      result->numeric_value = UINT64_MAX;\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"Numeric response was out of range\"));\n    } else if (errno) {\n      result->numeric_value = UINT64_MAX;\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"Numeric response was out of range\"));\n    }\n\n    result->numeric_value = uint64_t(auto_return_value);\n\n    WATCHPOINT_STRING(buffer);\n    return MEMCACHED_SUCCESS;\n  }\n\n  default:\n    break;\n  }\n\n  buffer[total_read] = 0;\n#if 0\n  if (total_read >= sizeof(\"STORSTORED\") -1)\n  {\n    fprintf(stderr, \"%s:%d '%s', %.*s\\n\", __FILE__, __LINE__,\n            buffer, MEMCACHED_MAX_BUFFER, instance->read_buffer);\n    assert(memcmp(buffer,\"STORSTORED\", sizeof(\"STORSTORED\") -1));\n  }\n#endif\n  return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT, buffer,\n                             total_read);\n}",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t textual_read_one_response(memcached_instance_st *instance, char *buffer,\n                                                    const size_t buffer_length,\n                                                    memcached_result_st *result) {\n  size_t total_read;\n  memcached_return_t rc = memcached_io_readline(instance, buffer, buffer_length, total_read);\n\n  if (memcached_failed(rc)) {\n    return rc;\n  }\n  assert(total_read);\n\n  switch (buffer[0]) {\n  case 'V': {\n    // VALUE\n    if (buffer[1] == 'A' and buffer[2] == 'L' and buffer[3] == 'U' and buffer[4] == 'E') /* VALUE */\n    {\n      /* We add back in one because we will need to search for END */\n      memcached_server_response_increment(instance);\n      return textual_value_fetch(instance, buffer, result);\n    }\n    // VERSION\n    else if (buffer[1] == 'E' and buffer[2] == 'R' and buffer[3] == 'S' and buffer[4] == 'I'\n             and buffer[5] == 'O' and buffer[6] == 'N') /* VERSION */\n    {\n      /* Find the space, and then move one past it to copy version */\n      char *response_ptr = strchr(buffer, ' ');\n\n      char *endptr;\n      errno = 0;\n      long int version = strtol(response_ptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX\n          or version == 0) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse major version\"));\n      }\n      instance->major_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse minor version\"));\n      }\n      instance->minor_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse micro version\"));\n      }\n      instance->micro_version = uint8_t(version);\n\n      return MEMCACHED_SUCCESS;\n    }\n  } break;\n\n  case 'O': {\n    // OK\n    if (buffer[1] == 'K') {\n      return MEMCACHED_SUCCESS;\n    }\n  } break;\n\n  case 'S': {\n    // STAT\n    if (buffer[1] == 'T' and buffer[2] == 'A' and buffer[3] == 'T') /* STORED STATS */ {\n      memcached_server_response_increment(instance);\n      return MEMCACHED_STAT;\n    }\n    // SERVER_ERROR\n    else if (buffer[1] == 'E' and buffer[2] == 'R' and buffer[3] == 'V' and buffer[4] == 'E'\n             and buffer[5] == 'R' and buffer[6] == '_' and buffer[7] == 'E' and buffer[8] == 'R'\n             and buffer[9] == 'R' and buffer[10] == 'O' and buffer[11] == 'R')\n    {\n      if (total_read == memcached_literal_param_size(\"SERVER_ERROR\")) {\n        return MEMCACHED_SERVER_ERROR;\n      }\n\n      if (total_read >= memcached_literal_param_size(\"SERVER_ERROR object too large for cache\")\n          and (memcmp(buffer, memcached_literal_param(\"SERVER_ERROR object too large for cache\"))\n               == 0))\n      {\n        return MEMCACHED_E2BIG;\n      }\n\n      if (total_read >= memcached_literal_param_size(\"SERVER_ERROR out of memory\")\n          and ((memcmp(buffer, memcached_literal_param(\"SERVER_ERROR out of memory\")) == 0)\n               or (memcmp(buffer, memcached_literal_param(\"SERVER_ERROR Out of memory\")) == 0)))\n      {\n        return MEMCACHED_SERVER_MEMORY_ALLOCATION_FAILURE;\n      }\n\n      // Move past the basic error message and whitespace\n      char *startptr = buffer + memcached_literal_param_size(\"SERVER_ERROR\");\n      if (startptr[0] == ' ') {\n        startptr++;\n      }\n\n      char *endptr = startptr;\n      while (*endptr != '\\r' && *endptr != '\\n') endptr++;\n\n      return memcached_set_error(*instance, MEMCACHED_SERVER_ERROR, MEMCACHED_AT, startptr,\n                                 size_t(endptr - startptr));\n    }\n    // STORED\n    else if (buffer[1] == 'T' and buffer[2] == 'O'\n             and buffer[3] == 'R') //  and buffer[4] == 'E' and buffer[5] == 'D')\n    {\n      return MEMCACHED_STORED;\n    }\n  } break;\n\n  case 'D': {\n    // DELETED\n    if (buffer[1] == 'E' and buffer[2] == 'L' and buffer[3] == 'E' and buffer[4] == 'T'\n        and buffer[5] == 'E' and buffer[6] == 'D')\n    {\n      return MEMCACHED_DELETED;\n    }\n  } break;\n\n  case 'N': {\n    // NOT_FOUND\n    if (buffer[1] == 'O' and buffer[2] == 'T' and buffer[3] == '_' and buffer[4] == 'F'\n        and buffer[5] == 'O' and buffer[6] == 'U' and buffer[7] == 'N' and buffer[8] == 'D')\n    {\n      return MEMCACHED_NOTFOUND;\n    }\n    // NOT_STORED\n    else if (buffer[1] == 'O' and buffer[2] == 'T' and buffer[3] == '_' and buffer[4] == 'S'\n             and buffer[5] == 'T' and buffer[6] == 'O' and buffer[7] == 'R' and buffer[8] == 'E'\n             and buffer[9] == 'D')\n    {\n      return MEMCACHED_NOTSTORED;\n    }\n  } break;\n\n  case 'E': /* PROTOCOL ERROR or END */\n  {\n    // END\n    if (buffer[1] == 'N' and buffer[2] == 'D') {\n      return MEMCACHED_END;\n    }\n#if 0\n      // PROTOCOL_ERROR\n      else if (buffer[1] == 'R' and buffer[2] == 'O' and buffer[3] == 'T' and buffer[4] == 'O' and buffer[5] == 'C' and buffer[6] == 'O' and buffer[7] == 'L'\n               and buffer[8] == '_'\n               and buffer[9] == 'E' and buffer[10] == 'R' and buffer[11] == 'R' and buffer[12] == 'O' and buffer[13] == 'R')\n      {\n        return MEMCACHED_PROTOCOL_ERROR;\n      }\n#endif\n    // ERROR\n    else if (buffer[1] == 'R' and buffer[2] == 'R' and buffer[3] == 'O' and buffer[4] == 'R')\n    {\n      return MEMCACHED_ERROR;\n    }\n    // EXISTS\n    else if (buffer[1] == 'X' and buffer[2] == 'I' and buffer[3] == 'S' and buffer[4] == 'T'\n             and buffer[5] == 'S')\n    {\n      return MEMCACHED_DATA_EXISTS;\n    }\n  } break;\n\n  case 'T': /* TOUCHED */\n  {\n    // TOUCHED\n    if (buffer[1] == 'O' and buffer[2] == 'U' and buffer[3] == 'C' and buffer[4] == 'H'\n        and buffer[5] == 'E' and buffer[6] == 'D')\n    {\n      return MEMCACHED_SUCCESS;\n    }\n  } break;\n\n  case 'I': /* ITEM */\n  {\n    // ITEM\n    if (buffer[1] == 'T' and buffer[2] == 'E' and buffer[3] == 'M') {\n      /* We add back in one because we will need to search for END */\n      memcached_server_response_increment(instance);\n      return MEMCACHED_ITEM;\n    }\n  } break;\n\n  case 'C': /* CLIENT ERROR */\n  {\n    // CLIENT_ERROR\n    if (buffer[1] == 'L' and buffer[2] == 'I' and buffer[3] == 'E' and buffer[4] == 'N'\n        and buffer[5] == 'T' and buffer[6] == '_' and buffer[7] == 'E' and buffer[8] == 'R'\n        and buffer[9] == 'R' and buffer[10] == 'O' and buffer[11] == 'R')\n    {\n      // Move past the basic error message and whitespace\n      char *startptr = buffer + memcached_literal_param_size(\"CLIENT_ERROR\");\n      if (startptr[0] == ' ') {\n        startptr++;\n      }\n\n      char *endptr = startptr;\n      while (*endptr != '\\r' && *endptr != '\\n') endptr++;\n\n      return memcached_set_error(*instance, MEMCACHED_CLIENT_ERROR, MEMCACHED_AT, startptr,\n                                 size_t(endptr - startptr));\n    }\n  } break;\n\n  case '0': /* INCR/DECR response */\n  case '1': /* INCR/DECR response */\n  case '2': /* INCR/DECR response */\n  case '3': /* INCR/DECR response */\n  case '4': /* INCR/DECR response */\n  case '5': /* INCR/DECR response */\n  case '6': /* INCR/DECR response */\n  case '7': /* INCR/DECR response */\n  case '8': /* INCR/DECR response */\n  case '9': /* INCR/DECR response */\n  {\n    errno = 0;\n    unsigned long long int auto_return_value = strtoull(buffer, (char **) NULL, 10);\n\n    if (auto_return_value == ULLONG_MAX and errno == ERANGE) {\n      result->numeric_value = UINT64_MAX;\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"Numeric response was out of range\"));\n    } else if (errno == EINVAL) {\n      result->numeric_value = UINT64_MAX;\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"Numeric response was out of range\"));\n    } else if (errno) {\n      result->numeric_value = UINT64_MAX;\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"Numeric response was out of range\"));\n    }\n\n    result->numeric_value = uint64_t(auto_return_value);\n\n    WATCHPOINT_STRING(buffer);\n    return MEMCACHED_SUCCESS;\n  }\n\n  default:\n    break;\n  }\n\n  buffer[total_read] = 0;\n#if 0\n  if (total_read >= sizeof(\"STORSTORED\") -1)\n  {\n    fprintf(stderr, \"%s:%d '%s', %.*s\\n\", __FILE__, __LINE__,\n            buffer, MEMCACHED_MAX_BUFFER, instance->read_buffer);\n    assert(memcmp(buffer,\"STORSTORED\", sizeof(\"STORSTORED\") -1));\n  }\n#endif\n  return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT, buffer,\n                             total_read);\n}"
        }
      },
      {
        "call_info": {
          "callee": "binary_read_one_response",
          "args": [
            "instance",
            "buffer",
            "buffer_length",
            "result"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "binary_read_one_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
          "lines": "441-743",
          "snippet": "static memcached_return_t binary_read_one_response(memcached_instance_st *instance, char *buffer,\n                                                   const size_t buffer_length,\n                                                   memcached_result_st *result) {\n  memcached_return_t rc;\n  protocol_binary_response_header header;\n\n  assert(memcached_is_binary(instance->root));\n\n  if ((rc = memcached_safe_read(instance, &header.bytes, sizeof(header.bytes)))\n      != MEMCACHED_SUCCESS) {\n    WATCHPOINT_ERROR(rc);\n    return rc;\n  }\n\n  if (header.response.magic != PROTOCOL_BINARY_RES) {\n    return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n  }\n\n  /*\n   ** Convert the header to host local endian!\n   */\n  header.response.keylen = ntohs(header.response.keylen);\n  header.response.status = ntohs(header.response.status);\n  header.response.bodylen = ntohl(header.response.bodylen);\n  header.response.cas = memcached_ntohll(header.response.cas);\n  uint32_t bodylen = header.response.bodylen;\n\n  if (header.response.status == PROTOCOL_BINARY_RESPONSE_SUCCESS\n      or header.response.status == PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE)\n  {\n    switch (header.response.opcode) {\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      /*\n       * We didn't increment the response counter for the GETKQ packet\n       * (only the final NOOP), so we need to increment the counter again.\n       */\n      memcached_server_response_increment(instance);\n      /* fall through */\n    case PROTOCOL_BINARY_CMD_GETK: {\n      uint16_t keylen = header.response.keylen;\n      memcached_result_reset(result);\n      result->item_cas = header.response.cas;\n\n      if ((rc = memcached_safe_read(instance, &result->item_flags, sizeof(result->item_flags)))\n          != MEMCACHED_SUCCESS)\n      {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      result->item_flags = ntohl(result->item_flags);\n      bodylen -= header.response.extlen;\n\n      result->key_length = keylen;\n      if (memcached_failed(rc = memcached_safe_read(instance, result->item_key, keylen))) {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      // Only bother with doing this if key_length > 0\n      if (result->key_length) {\n        if (memcached_array_size(instance->root->_namespace)\n            and memcached_array_size(instance->root->_namespace) >= result->key_length)\n        {\n          return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n        }\n\n        if (memcached_array_size(instance->root->_namespace)) {\n          result->key_length -= memcached_array_size(instance->root->_namespace);\n          memmove(result->item_key,\n                  result->item_key + memcached_array_size(instance->root->_namespace),\n                  result->key_length);\n        }\n      }\n\n      bodylen -= keylen;\n      if (memcached_failed(memcached_string_check(&result->value, bodylen))) {\n        return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n      }\n\n      char *vptr = memcached_string_value_mutable(&result->value);\n      if (memcached_failed(rc = memcached_safe_read(instance, vptr, bodylen))) {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      memcached_string_set_length(&result->value, bodylen);\n    } break;\n\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n    case PROTOCOL_BINARY_CMD_DECREMENT: {\n      if (bodylen != sizeof(uint64_t)) {\n        result->numeric_value = UINT64_MAX;\n        return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n      }\n\n      uint64_t val;\n      if ((rc = memcached_safe_read(instance, &val, sizeof(val))) != MEMCACHED_SUCCESS) {\n        result->numeric_value = UINT64_MAX;\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      result->numeric_value = memcached_ntohll(val);\n    } break;\n\n    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: {\n      if (header.response.keylen || bodylen + 1 > buffer_length) {\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      } else {\n        if ((rc = memcached_safe_read(instance, buffer, bodylen)) != MEMCACHED_SUCCESS) {\n          return MEMCACHED_UNKNOWN_READ_FAILURE;\n        }\n      }\n    } break;\n\n    case PROTOCOL_BINARY_CMD_VERSION: {\n      char version_buffer[32]; // @todo document this number\n      memset(version_buffer, 0, sizeof(version_buffer));\n\n      if (memcached_safe_read(instance, version_buffer, bodylen) != MEMCACHED_SUCCESS) {\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      char *endptr;\n      errno = 0;\n      long int version = strtol(version_buffer, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX\n          or version == 0) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse major version\"));\n      }\n      instance->major_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse minor version\"));\n      }\n      instance->minor_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse micro version\"));\n      }\n      instance->micro_version = uint8_t(version);\n    } break;\n\n    case PROTOCOL_BINARY_CMD_TOUCH: {\n      rc = MEMCACHED_SUCCESS;\n      if (bodylen == 4) // The four byte read is a bug?\n      {\n        char touch_buffer[4]; // @todo document this number\n        rc = memcached_safe_read(instance, touch_buffer, sizeof(touch_buffer));\n#if 0\n          fprintf(stderr, \"%s:%d %d %d %d %d %.*s(%d)\\n\", __FILE__, __LINE__,\n                  int(touch_buffer[0]),\n                  int(touch_buffer[1]),\n                  int(touch_buffer[2]),\n                  int(touch_buffer[3]),\n                  int(bodylen), touch_buffer, int(bodylen));\n#endif\n      }\n      return memcached_set_error(*instance, rc, MEMCACHED_AT);\n    }\n\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n    case PROTOCOL_BINARY_CMD_DELETE: {\n      WATCHPOINT_ASSERT(bodylen == 0);\n      return MEMCACHED_SUCCESS;\n    }\n\n    case PROTOCOL_BINARY_CMD_NOOP: {\n      WATCHPOINT_ASSERT(bodylen == 0);\n      return MEMCACHED_END;\n    }\n\n    case PROTOCOL_BINARY_CMD_STAT: {\n      if (bodylen == 0) {\n        return MEMCACHED_END;\n      } else if (bodylen + 1 > buffer_length) {\n        /* not enough space in buffer.. should not happen... */\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      } else {\n        size_t keylen = header.response.keylen;\n        memset(buffer, 0, buffer_length);\n        if ((rc = memcached_safe_read(instance, buffer, keylen)) != MEMCACHED_SUCCESS\n            || (rc = memcached_safe_read(instance, buffer + keylen + 1, bodylen - keylen))\n                != MEMCACHED_SUCCESS)\n        {\n          WATCHPOINT_ERROR(rc);\n          return MEMCACHED_UNKNOWN_READ_FAILURE;\n        }\n      }\n    } break;\n\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:\n    case PROTOCOL_BINARY_CMD_SASL_STEP: {\n      memcached_result_reset(result);\n      result->item_cas = header.response.cas;\n\n      if (memcached_string_check(&result->value, bodylen) != MEMCACHED_SUCCESS)\n        return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n\n      char *vptr = memcached_string_value_mutable(&result->value);\n      if ((rc = memcached_safe_read(instance, vptr, bodylen)) != MEMCACHED_SUCCESS) {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      memcached_string_set_length(&result->value, bodylen);\n    } break;\n    default: {\n      /* Command not implemented yet! */\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n    }\n    }\n  } else if (header.response.bodylen) {\n    /* What should I do with the error message??? just discard it for now */\n    char hole[SMALL_STRING_LEN];\n    while (bodylen > 0) {\n      size_t nr = (bodylen > SMALL_STRING_LEN) ? SMALL_STRING_LEN : bodylen;\n      if ((rc = memcached_safe_read(instance, hole, nr)) != MEMCACHED_SUCCESS) {\n        WATCHPOINT_ERROR(rc);\n        return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n      }\n      bodylen -= (uint32_t) nr;\n    }\n\n    /* This might be an error from one of the quiet commands.. if\n     * so, just throw it away and get the next one. What about creating\n     * a callback to the user with the error information?\n     */\n    switch (header.response.opcode) {\n    case PROTOCOL_BINARY_CMD_SETQ:\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n      return MEMCACHED_FETCH_NOTFINISHED;\n\n    default:\n      break;\n    }\n  }\n\n  rc = MEMCACHED_SUCCESS;\n  if (header.response.status) {\n    switch (header.response.status) {\n    case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n      rc = MEMCACHED_NOTFOUND;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:\n      rc = MEMCACHED_DATA_EXISTS;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_NOT_STORED:\n      rc = MEMCACHED_NOTSTORED;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_E2BIG:\n      rc = MEMCACHED_E2BIG;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_ENOMEM:\n      rc = MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE:\n      rc = MEMCACHED_AUTH_CONTINUE;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:\n      rc = MEMCACHED_AUTH_FAILURE;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_EINVAL:\n    case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:\n    default:\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n      break;\n    }\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t binary_read_one_response(memcached_instance_st *instance, char *buffer,\n                                                   const size_t buffer_length,\n                                                   memcached_result_st *result) {\n  memcached_return_t rc;\n  protocol_binary_response_header header;\n\n  assert(memcached_is_binary(instance->root));\n\n  if ((rc = memcached_safe_read(instance, &header.bytes, sizeof(header.bytes)))\n      != MEMCACHED_SUCCESS) {\n    WATCHPOINT_ERROR(rc);\n    return rc;\n  }\n\n  if (header.response.magic != PROTOCOL_BINARY_RES) {\n    return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n  }\n\n  /*\n   ** Convert the header to host local endian!\n   */\n  header.response.keylen = ntohs(header.response.keylen);\n  header.response.status = ntohs(header.response.status);\n  header.response.bodylen = ntohl(header.response.bodylen);\n  header.response.cas = memcached_ntohll(header.response.cas);\n  uint32_t bodylen = header.response.bodylen;\n\n  if (header.response.status == PROTOCOL_BINARY_RESPONSE_SUCCESS\n      or header.response.status == PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE)\n  {\n    switch (header.response.opcode) {\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      /*\n       * We didn't increment the response counter for the GETKQ packet\n       * (only the final NOOP), so we need to increment the counter again.\n       */\n      memcached_server_response_increment(instance);\n      /* fall through */\n    case PROTOCOL_BINARY_CMD_GETK: {\n      uint16_t keylen = header.response.keylen;\n      memcached_result_reset(result);\n      result->item_cas = header.response.cas;\n\n      if ((rc = memcached_safe_read(instance, &result->item_flags, sizeof(result->item_flags)))\n          != MEMCACHED_SUCCESS)\n      {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      result->item_flags = ntohl(result->item_flags);\n      bodylen -= header.response.extlen;\n\n      result->key_length = keylen;\n      if (memcached_failed(rc = memcached_safe_read(instance, result->item_key, keylen))) {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      // Only bother with doing this if key_length > 0\n      if (result->key_length) {\n        if (memcached_array_size(instance->root->_namespace)\n            and memcached_array_size(instance->root->_namespace) >= result->key_length)\n        {\n          return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n        }\n\n        if (memcached_array_size(instance->root->_namespace)) {\n          result->key_length -= memcached_array_size(instance->root->_namespace);\n          memmove(result->item_key,\n                  result->item_key + memcached_array_size(instance->root->_namespace),\n                  result->key_length);\n        }\n      }\n\n      bodylen -= keylen;\n      if (memcached_failed(memcached_string_check(&result->value, bodylen))) {\n        return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n      }\n\n      char *vptr = memcached_string_value_mutable(&result->value);\n      if (memcached_failed(rc = memcached_safe_read(instance, vptr, bodylen))) {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      memcached_string_set_length(&result->value, bodylen);\n    } break;\n\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n    case PROTOCOL_BINARY_CMD_DECREMENT: {\n      if (bodylen != sizeof(uint64_t)) {\n        result->numeric_value = UINT64_MAX;\n        return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n      }\n\n      uint64_t val;\n      if ((rc = memcached_safe_read(instance, &val, sizeof(val))) != MEMCACHED_SUCCESS) {\n        result->numeric_value = UINT64_MAX;\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      result->numeric_value = memcached_ntohll(val);\n    } break;\n\n    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: {\n      if (header.response.keylen || bodylen + 1 > buffer_length) {\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      } else {\n        if ((rc = memcached_safe_read(instance, buffer, bodylen)) != MEMCACHED_SUCCESS) {\n          return MEMCACHED_UNKNOWN_READ_FAILURE;\n        }\n      }\n    } break;\n\n    case PROTOCOL_BINARY_CMD_VERSION: {\n      char version_buffer[32]; // @todo document this number\n      memset(version_buffer, 0, sizeof(version_buffer));\n\n      if (memcached_safe_read(instance, version_buffer, bodylen) != MEMCACHED_SUCCESS) {\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      char *endptr;\n      errno = 0;\n      long int version = strtol(version_buffer, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX\n          or version == 0) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse major version\"));\n      }\n      instance->major_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse minor version\"));\n      }\n      instance->minor_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse micro version\"));\n      }\n      instance->micro_version = uint8_t(version);\n    } break;\n\n    case PROTOCOL_BINARY_CMD_TOUCH: {\n      rc = MEMCACHED_SUCCESS;\n      if (bodylen == 4) // The four byte read is a bug?\n      {\n        char touch_buffer[4]; // @todo document this number\n        rc = memcached_safe_read(instance, touch_buffer, sizeof(touch_buffer));\n#if 0\n          fprintf(stderr, \"%s:%d %d %d %d %d %.*s(%d)\\n\", __FILE__, __LINE__,\n                  int(touch_buffer[0]),\n                  int(touch_buffer[1]),\n                  int(touch_buffer[2]),\n                  int(touch_buffer[3]),\n                  int(bodylen), touch_buffer, int(bodylen));\n#endif\n      }\n      return memcached_set_error(*instance, rc, MEMCACHED_AT);\n    }\n\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n    case PROTOCOL_BINARY_CMD_DELETE: {\n      WATCHPOINT_ASSERT(bodylen == 0);\n      return MEMCACHED_SUCCESS;\n    }\n\n    case PROTOCOL_BINARY_CMD_NOOP: {\n      WATCHPOINT_ASSERT(bodylen == 0);\n      return MEMCACHED_END;\n    }\n\n    case PROTOCOL_BINARY_CMD_STAT: {\n      if (bodylen == 0) {\n        return MEMCACHED_END;\n      } else if (bodylen + 1 > buffer_length) {\n        /* not enough space in buffer.. should not happen... */\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      } else {\n        size_t keylen = header.response.keylen;\n        memset(buffer, 0, buffer_length);\n        if ((rc = memcached_safe_read(instance, buffer, keylen)) != MEMCACHED_SUCCESS\n            || (rc = memcached_safe_read(instance, buffer + keylen + 1, bodylen - keylen))\n                != MEMCACHED_SUCCESS)\n        {\n          WATCHPOINT_ERROR(rc);\n          return MEMCACHED_UNKNOWN_READ_FAILURE;\n        }\n      }\n    } break;\n\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:\n    case PROTOCOL_BINARY_CMD_SASL_STEP: {\n      memcached_result_reset(result);\n      result->item_cas = header.response.cas;\n\n      if (memcached_string_check(&result->value, bodylen) != MEMCACHED_SUCCESS)\n        return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n\n      char *vptr = memcached_string_value_mutable(&result->value);\n      if ((rc = memcached_safe_read(instance, vptr, bodylen)) != MEMCACHED_SUCCESS) {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      memcached_string_set_length(&result->value, bodylen);\n    } break;\n    default: {\n      /* Command not implemented yet! */\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n    }\n    }\n  } else if (header.response.bodylen) {\n    /* What should I do with the error message??? just discard it for now */\n    char hole[SMALL_STRING_LEN];\n    while (bodylen > 0) {\n      size_t nr = (bodylen > SMALL_STRING_LEN) ? SMALL_STRING_LEN : bodylen;\n      if ((rc = memcached_safe_read(instance, hole, nr)) != MEMCACHED_SUCCESS) {\n        WATCHPOINT_ERROR(rc);\n        return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n      }\n      bodylen -= (uint32_t) nr;\n    }\n\n    /* This might be an error from one of the quiet commands.. if\n     * so, just throw it away and get the next one. What about creating\n     * a callback to the user with the error information?\n     */\n    switch (header.response.opcode) {\n    case PROTOCOL_BINARY_CMD_SETQ:\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n      return MEMCACHED_FETCH_NOTFINISHED;\n\n    default:\n      break;\n    }\n  }\n\n  rc = MEMCACHED_SUCCESS;\n  if (header.response.status) {\n    switch (header.response.status) {\n    case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n      rc = MEMCACHED_NOTFOUND;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:\n      rc = MEMCACHED_DATA_EXISTS;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_NOT_STORED:\n      rc = MEMCACHED_NOTSTORED;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_E2BIG:\n      rc = MEMCACHED_E2BIG;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_ENOMEM:\n      rc = MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE:\n      rc = MEMCACHED_AUTH_CONTINUE;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:\n      rc = MEMCACHED_AUTH_FAILURE;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_EINVAL:\n    case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:\n    default:\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n      break;\n    }\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_binary",
          "args": [
            "instance->root"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_response_decrement",
          "args": [
            "instance"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t _read_one_response(memcached_instance_st *instance, char *buffer,\n                                             const size_t buffer_length,\n                                             memcached_result_st *result) {\n  memcached_server_response_decrement(instance);\n\n  if (result == NULL) {\n    Memcached *root = (Memcached *) instance->root;\n    result = &root->result;\n  }\n\n  memcached_return_t rc;\n  if (memcached_is_binary(instance->root)) {\n    do {\n      rc = binary_read_one_response(instance, buffer, buffer_length, result);\n    } while (rc == MEMCACHED_FETCH_NOTFINISHED);\n  } else {\n    rc = textual_read_one_response(instance, buffer, buffer_length, result);\n  }\n\n  if (memcached_fatal(rc) && rc != MEMCACHED_TIMEOUT) {\n    memcached_io_reset(instance);\n  }\n\n  return rc;\n}"
  },
  {
    "function_name": "binary_read_one_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
    "lines": "441-743",
    "snippet": "static memcached_return_t binary_read_one_response(memcached_instance_st *instance, char *buffer,\n                                                   const size_t buffer_length,\n                                                   memcached_result_st *result) {\n  memcached_return_t rc;\n  protocol_binary_response_header header;\n\n  assert(memcached_is_binary(instance->root));\n\n  if ((rc = memcached_safe_read(instance, &header.bytes, sizeof(header.bytes)))\n      != MEMCACHED_SUCCESS) {\n    WATCHPOINT_ERROR(rc);\n    return rc;\n  }\n\n  if (header.response.magic != PROTOCOL_BINARY_RES) {\n    return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n  }\n\n  /*\n   ** Convert the header to host local endian!\n   */\n  header.response.keylen = ntohs(header.response.keylen);\n  header.response.status = ntohs(header.response.status);\n  header.response.bodylen = ntohl(header.response.bodylen);\n  header.response.cas = memcached_ntohll(header.response.cas);\n  uint32_t bodylen = header.response.bodylen;\n\n  if (header.response.status == PROTOCOL_BINARY_RESPONSE_SUCCESS\n      or header.response.status == PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE)\n  {\n    switch (header.response.opcode) {\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      /*\n       * We didn't increment the response counter for the GETKQ packet\n       * (only the final NOOP), so we need to increment the counter again.\n       */\n      memcached_server_response_increment(instance);\n      /* fall through */\n    case PROTOCOL_BINARY_CMD_GETK: {\n      uint16_t keylen = header.response.keylen;\n      memcached_result_reset(result);\n      result->item_cas = header.response.cas;\n\n      if ((rc = memcached_safe_read(instance, &result->item_flags, sizeof(result->item_flags)))\n          != MEMCACHED_SUCCESS)\n      {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      result->item_flags = ntohl(result->item_flags);\n      bodylen -= header.response.extlen;\n\n      result->key_length = keylen;\n      if (memcached_failed(rc = memcached_safe_read(instance, result->item_key, keylen))) {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      // Only bother with doing this if key_length > 0\n      if (result->key_length) {\n        if (memcached_array_size(instance->root->_namespace)\n            and memcached_array_size(instance->root->_namespace) >= result->key_length)\n        {\n          return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n        }\n\n        if (memcached_array_size(instance->root->_namespace)) {\n          result->key_length -= memcached_array_size(instance->root->_namespace);\n          memmove(result->item_key,\n                  result->item_key + memcached_array_size(instance->root->_namespace),\n                  result->key_length);\n        }\n      }\n\n      bodylen -= keylen;\n      if (memcached_failed(memcached_string_check(&result->value, bodylen))) {\n        return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n      }\n\n      char *vptr = memcached_string_value_mutable(&result->value);\n      if (memcached_failed(rc = memcached_safe_read(instance, vptr, bodylen))) {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      memcached_string_set_length(&result->value, bodylen);\n    } break;\n\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n    case PROTOCOL_BINARY_CMD_DECREMENT: {\n      if (bodylen != sizeof(uint64_t)) {\n        result->numeric_value = UINT64_MAX;\n        return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n      }\n\n      uint64_t val;\n      if ((rc = memcached_safe_read(instance, &val, sizeof(val))) != MEMCACHED_SUCCESS) {\n        result->numeric_value = UINT64_MAX;\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      result->numeric_value = memcached_ntohll(val);\n    } break;\n\n    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: {\n      if (header.response.keylen || bodylen + 1 > buffer_length) {\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      } else {\n        if ((rc = memcached_safe_read(instance, buffer, bodylen)) != MEMCACHED_SUCCESS) {\n          return MEMCACHED_UNKNOWN_READ_FAILURE;\n        }\n      }\n    } break;\n\n    case PROTOCOL_BINARY_CMD_VERSION: {\n      char version_buffer[32]; // @todo document this number\n      memset(version_buffer, 0, sizeof(version_buffer));\n\n      if (memcached_safe_read(instance, version_buffer, bodylen) != MEMCACHED_SUCCESS) {\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      char *endptr;\n      errno = 0;\n      long int version = strtol(version_buffer, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX\n          or version == 0) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse major version\"));\n      }\n      instance->major_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse minor version\"));\n      }\n      instance->minor_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse micro version\"));\n      }\n      instance->micro_version = uint8_t(version);\n    } break;\n\n    case PROTOCOL_BINARY_CMD_TOUCH: {\n      rc = MEMCACHED_SUCCESS;\n      if (bodylen == 4) // The four byte read is a bug?\n      {\n        char touch_buffer[4]; // @todo document this number\n        rc = memcached_safe_read(instance, touch_buffer, sizeof(touch_buffer));\n#if 0\n          fprintf(stderr, \"%s:%d %d %d %d %d %.*s(%d)\\n\", __FILE__, __LINE__,\n                  int(touch_buffer[0]),\n                  int(touch_buffer[1]),\n                  int(touch_buffer[2]),\n                  int(touch_buffer[3]),\n                  int(bodylen), touch_buffer, int(bodylen));\n#endif\n      }\n      return memcached_set_error(*instance, rc, MEMCACHED_AT);\n    }\n\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n    case PROTOCOL_BINARY_CMD_DELETE: {\n      WATCHPOINT_ASSERT(bodylen == 0);\n      return MEMCACHED_SUCCESS;\n    }\n\n    case PROTOCOL_BINARY_CMD_NOOP: {\n      WATCHPOINT_ASSERT(bodylen == 0);\n      return MEMCACHED_END;\n    }\n\n    case PROTOCOL_BINARY_CMD_STAT: {\n      if (bodylen == 0) {\n        return MEMCACHED_END;\n      } else if (bodylen + 1 > buffer_length) {\n        /* not enough space in buffer.. should not happen... */\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      } else {\n        size_t keylen = header.response.keylen;\n        memset(buffer, 0, buffer_length);\n        if ((rc = memcached_safe_read(instance, buffer, keylen)) != MEMCACHED_SUCCESS\n            || (rc = memcached_safe_read(instance, buffer + keylen + 1, bodylen - keylen))\n                != MEMCACHED_SUCCESS)\n        {\n          WATCHPOINT_ERROR(rc);\n          return MEMCACHED_UNKNOWN_READ_FAILURE;\n        }\n      }\n    } break;\n\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:\n    case PROTOCOL_BINARY_CMD_SASL_STEP: {\n      memcached_result_reset(result);\n      result->item_cas = header.response.cas;\n\n      if (memcached_string_check(&result->value, bodylen) != MEMCACHED_SUCCESS)\n        return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n\n      char *vptr = memcached_string_value_mutable(&result->value);\n      if ((rc = memcached_safe_read(instance, vptr, bodylen)) != MEMCACHED_SUCCESS) {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      memcached_string_set_length(&result->value, bodylen);\n    } break;\n    default: {\n      /* Command not implemented yet! */\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n    }\n    }\n  } else if (header.response.bodylen) {\n    /* What should I do with the error message??? just discard it for now */\n    char hole[SMALL_STRING_LEN];\n    while (bodylen > 0) {\n      size_t nr = (bodylen > SMALL_STRING_LEN) ? SMALL_STRING_LEN : bodylen;\n      if ((rc = memcached_safe_read(instance, hole, nr)) != MEMCACHED_SUCCESS) {\n        WATCHPOINT_ERROR(rc);\n        return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n      }\n      bodylen -= (uint32_t) nr;\n    }\n\n    /* This might be an error from one of the quiet commands.. if\n     * so, just throw it away and get the next one. What about creating\n     * a callback to the user with the error information?\n     */\n    switch (header.response.opcode) {\n    case PROTOCOL_BINARY_CMD_SETQ:\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n      return MEMCACHED_FETCH_NOTFINISHED;\n\n    default:\n      break;\n    }\n  }\n\n  rc = MEMCACHED_SUCCESS;\n  if (header.response.status) {\n    switch (header.response.status) {\n    case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n      rc = MEMCACHED_NOTFOUND;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:\n      rc = MEMCACHED_DATA_EXISTS;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_NOT_STORED:\n      rc = MEMCACHED_NOTSTORED;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_E2BIG:\n      rc = MEMCACHED_E2BIG;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_ENOMEM:\n      rc = MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE:\n      rc = MEMCACHED_AUTH_CONTINUE;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:\n      rc = MEMCACHED_AUTH_FAILURE;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_EINVAL:\n    case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:\n    default:\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n      break;\n    }\n  }\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/string.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*instance",
            "MEMCACHED_UNKNOWN_READ_FAILURE",
            "MEMCACHED_AT"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ERROR",
          "args": [
            "rc"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_safe_read",
          "args": [
            "instance",
            "hole",
            "nr"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_safe_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "748-769",
          "snippet": "memcached_return_t memcached_safe_read(memcached_instance_st *instance, void *dta,\n                                       const size_t size) {\n  size_t offset = 0;\n  char *data = static_cast<char *>(dta);\n\n  while (offset < size) {\n    ssize_t nread;\n    memcached_return_t rc;\n\n    while (\n        memcached_continue(rc = memcached_io_read(instance, data + offset, size - offset, nread))) {\n    };\n\n    if (memcached_failed(rc)) {\n      return rc;\n    }\n\n    offset += size_t(nread);\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_safe_read(memcached_instance_st *instance, void *dta,\n                                       const size_t size) {\n  size_t offset = 0;\n  char *data = static_cast<char *>(dta);\n\n  while (offset < size) {\n    ssize_t nread;\n    memcached_return_t rc;\n\n    while (\n        memcached_continue(rc = memcached_io_read(instance, data + offset, size - offset, nread))) {\n    };\n\n    if (memcached_failed(rc)) {\n      return rc;\n    }\n\n    offset += size_t(nread);\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_string_set_length",
          "args": [
            "&result->value",
            "bodylen"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_string_set_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/string.cc",
          "lines": "254-263",
          "snippet": "void memcached_string_set_length(memcached_string_st &self, const size_t length) {\n  assert(self.current_size >= length);\n  size_t set_length = length;\n  if (self.current_size > length) {\n    if (memcached_failed(_string_check(&self, length))) {\n      set_length = self.current_size;\n    }\n  }\n  self.end = self.string + set_length;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_string_set_length(memcached_string_st &self, const size_t length) {\n  assert(self.current_size >= length);\n  size_t set_length = length;\n  if (self.current_size > length) {\n    if (memcached_failed(_string_check(&self, length))) {\n      set_length = self.current_size;\n    }\n  }\n  self.end = self.string + set_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ERROR",
          "args": [
            "rc"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_string_value_mutable",
          "args": [
            "&result->value"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_string_check",
          "args": [
            "&result->value",
            "bodylen"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_string_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/string.cc",
          "lines": "195-197",
          "snippet": "memcached_return_t memcached_string_check(memcached_string_st *string, size_t need) {\n  return _string_check(string, need);\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_string_check(memcached_string_st *string, size_t need) {\n  return _string_check(string, need);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_result_reset",
          "args": [
            "result"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_result_reset_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/result.cc",
          "lines": "84-86",
          "snippet": "void memcached_result_reset_value(memcached_result_st *ptr) {\n  memcached_string_reset(&ptr->value);\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_result_reset_value(memcached_result_st *ptr) {\n  memcached_string_reset(&ptr->value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ERROR",
          "args": [
            "rc"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buffer",
            "0",
            "buffer_length"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "bodylen == 0"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "bodylen == 0"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s:%d %d %d %d %d %.*s(%d)\\n\"",
            "__FILE__",
            "__LINE__",
            "int(touch_buffer[0])",
            "int(touch_buffer[1])",
            "int(touch_buffer[2])",
            "int(touch_buffer[3])",
            "int(bodylen)",
            "touch_buffer",
            "int(bodylen)"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "bodylen"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "414-427",
          "snippet": "void memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uint8_t",
          "args": [
            "version"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"strtol() failed to parse micro version\""
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "endptr",
            "&endptr",
            "10"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint8_t",
          "args": [
            "version"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"strtol() failed to parse minor version\""
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "endptr",
            "&endptr",
            "10"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint8_t",
          "args": [
            "version"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"strtol() failed to parse major version\""
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "version_buffer",
            "&endptr",
            "10"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "version_buffer",
            "0",
            "sizeof(version_buffer)"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_ntohll",
          "args": [
            "val"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_ntohll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "47-53",
          "snippet": "uint64_t memcached_ntohll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return ntohll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_ntohll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return ntohll(value);\n#else\n  return swap64(value);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ERROR",
          "args": [
            "rc"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = memcached_safe_read(instance, vptr, bodylen)"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_string_value_mutable",
          "args": [
            "&result->value"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "memcached_string_check(&result->value, bodylen)"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "result->item_key",
            "result->item_key + memcached_array_size(instance->root->_namespace)",
            "result->key_length"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_array_size",
          "args": [
            "instance->root->_namespace"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_array_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/array.cc",
          "lines": "78-84",
          "snippet": "size_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"libmemcached/common.h\"\n\nsize_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ERROR",
          "args": [
            "rc"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = memcached_safe_read(instance, result->item_key, keylen)"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ERROR",
          "args": [
            "rc"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_response_increment",
          "args": [
            "instance"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_response_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/common.h",
          "lines": "137-140",
          "snippet": "static inline void memcached_server_response_increment(memcached_instance_st *instance) {\n  instance->events(POLLIN);\n  instance->cursor_active_++;\n}",
          "includes": [
            "#  include \"p9y/poll.hpp\"",
            "#include \"libmemcached/continuum.hpp\"",
            "#  include \"libmemcached/version.hpp\"",
            "#  include \"libmemcached/result.h\"",
            "#  include \"libmemcached/key.hpp\"",
            "#  include \"libmemcached/server.hpp\"",
            "#  include \"libmemcached/assert.hpp\"",
            "#  include \"libmemcached/backtrace.hpp\"",
            "#  include \"libmemcached/virtual_bucket.h\"",
            "#  include \"libmemcached/namespace.h\"",
            "#  include \"libmemcached/response.h\"",
            "#include \"libmemcached/initialize_query.h\"",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcached/libmemcached_probes.h\"",
            "#include \"libmemcached/array.h\"",
            "#include \"libmemcached/internal.h\"",
            "#  include \"libmemcached/server_list.hpp\"",
            "#  include \"libmemcached/sasl.hpp\"",
            "#  include \"libmemcached/behavior.hpp\"",
            "#  include \"libmemcached/flag.hpp\"",
            "#  include \"libmemcached/server.hpp\"",
            "#  include \"libmemcached/server_instance.h\"",
            "#  include \"libmemcached/instance.hpp\"",
            "#  include \"libmemcached/quit.hpp\"",
            "#  include \"libmemcached/hash.hpp\"",
            "#  include \"libmemcached/allocators.hpp\"",
            "#  include \"libmemcached/connect.hpp\"",
            "#  include \"libmemcached/do.hpp\"",
            "#  include \"libmemcached/udp.hpp\"",
            "#  include \"libmemcached/io.hpp\"",
            "#  include \"libmemcachedprotocol-0.0/binary.h\"",
            "#  include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/io.h\"",
            "#include \"libmemcached/memory.h\"",
            "#include \"libmemcached/error.hpp\"",
            "#include \"libmemcached/is.h\"",
            "#include \"libmemcached/watchpoint.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#  include <dlfcn.h>",
            "#  include <strings.h>",
            "#include <fcntl.h>",
            "#  include <sys/time.h>",
            "#include \"p9y/socket.hpp\"",
            "#  include <iso646.h>",
            "#  include <limits.h>",
            "#  include <errno.h>",
            "#  include <time.h>",
            "#  include <string.h>",
            "#  include <stdlib.h>",
            "#  include <stdio.h>",
            "#  include <stddef.h>",
            "#  include <ciso646>",
            "#  include <climits>",
            "#  include <cerrno>",
            "#  include <cctype>",
            "#  include <ctime>",
            "#  include <cstring>",
            "#  include <cstdlib>",
            "#  include <cstdio>",
            "#  include <cstddef>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"p9y/poll.hpp\"\n#include \"libmemcached/continuum.hpp\"\n#  include \"libmemcached/version.hpp\"\n#  include \"libmemcached/result.h\"\n#  include \"libmemcached/key.hpp\"\n#  include \"libmemcached/server.hpp\"\n#  include \"libmemcached/assert.hpp\"\n#  include \"libmemcached/backtrace.hpp\"\n#  include \"libmemcached/virtual_bucket.h\"\n#  include \"libmemcached/namespace.h\"\n#  include \"libmemcached/response.h\"\n#include \"libmemcached/initialize_query.h\"\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcached/libmemcached_probes.h\"\n#include \"libmemcached/array.h\"\n#include \"libmemcached/internal.h\"\n#  include \"libmemcached/server_list.hpp\"\n#  include \"libmemcached/sasl.hpp\"\n#  include \"libmemcached/behavior.hpp\"\n#  include \"libmemcached/flag.hpp\"\n#  include \"libmemcached/server.hpp\"\n#  include \"libmemcached/server_instance.h\"\n#  include \"libmemcached/instance.hpp\"\n#  include \"libmemcached/quit.hpp\"\n#  include \"libmemcached/hash.hpp\"\n#  include \"libmemcached/allocators.hpp\"\n#  include \"libmemcached/connect.hpp\"\n#  include \"libmemcached/do.hpp\"\n#  include \"libmemcached/udp.hpp\"\n#  include \"libmemcached/io.hpp\"\n#  include \"libmemcachedprotocol-0.0/binary.h\"\n#  include \"libmemcached/string.hpp\"\n#include \"libmemcached/io.h\"\n#include \"libmemcached/memory.h\"\n#include \"libmemcached/error.hpp\"\n#include \"libmemcached/is.h\"\n#include \"libmemcached/watchpoint.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#  include <dlfcn.h>\n#  include <strings.h>\n#include <fcntl.h>\n#  include <sys/time.h>\n#include \"p9y/socket.hpp\"\n#  include <iso646.h>\n#  include <limits.h>\n#  include <errno.h>\n#  include <time.h>\n#  include <string.h>\n#  include <stdlib.h>\n#  include <stdio.h>\n#  include <stddef.h>\n#  include <ciso646>\n#  include <climits>\n#  include <cerrno>\n#  include <cctype>\n#  include <ctime>\n#  include <cstring>\n#  include <cstdlib>\n#  include <cstdio>\n#  include <cstddef>\n#include \"mem_config.h\"\n\nstatic inline void memcached_server_response_increment(memcached_instance_st *instance) {\n  instance->events(POLLIN);\n  instance->cursor_active_++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "header.response.status"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "header.response.keylen"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ERROR",
          "args": [
            "rc"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "memcached_is_binary(instance->root)"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_binary",
          "args": [
            "instance->root"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t binary_read_one_response(memcached_instance_st *instance, char *buffer,\n                                                   const size_t buffer_length,\n                                                   memcached_result_st *result) {\n  memcached_return_t rc;\n  protocol_binary_response_header header;\n\n  assert(memcached_is_binary(instance->root));\n\n  if ((rc = memcached_safe_read(instance, &header.bytes, sizeof(header.bytes)))\n      != MEMCACHED_SUCCESS) {\n    WATCHPOINT_ERROR(rc);\n    return rc;\n  }\n\n  if (header.response.magic != PROTOCOL_BINARY_RES) {\n    return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n  }\n\n  /*\n   ** Convert the header to host local endian!\n   */\n  header.response.keylen = ntohs(header.response.keylen);\n  header.response.status = ntohs(header.response.status);\n  header.response.bodylen = ntohl(header.response.bodylen);\n  header.response.cas = memcached_ntohll(header.response.cas);\n  uint32_t bodylen = header.response.bodylen;\n\n  if (header.response.status == PROTOCOL_BINARY_RESPONSE_SUCCESS\n      or header.response.status == PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE)\n  {\n    switch (header.response.opcode) {\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      /*\n       * We didn't increment the response counter for the GETKQ packet\n       * (only the final NOOP), so we need to increment the counter again.\n       */\n      memcached_server_response_increment(instance);\n      /* fall through */\n    case PROTOCOL_BINARY_CMD_GETK: {\n      uint16_t keylen = header.response.keylen;\n      memcached_result_reset(result);\n      result->item_cas = header.response.cas;\n\n      if ((rc = memcached_safe_read(instance, &result->item_flags, sizeof(result->item_flags)))\n          != MEMCACHED_SUCCESS)\n      {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      result->item_flags = ntohl(result->item_flags);\n      bodylen -= header.response.extlen;\n\n      result->key_length = keylen;\n      if (memcached_failed(rc = memcached_safe_read(instance, result->item_key, keylen))) {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      // Only bother with doing this if key_length > 0\n      if (result->key_length) {\n        if (memcached_array_size(instance->root->_namespace)\n            and memcached_array_size(instance->root->_namespace) >= result->key_length)\n        {\n          return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n        }\n\n        if (memcached_array_size(instance->root->_namespace)) {\n          result->key_length -= memcached_array_size(instance->root->_namespace);\n          memmove(result->item_key,\n                  result->item_key + memcached_array_size(instance->root->_namespace),\n                  result->key_length);\n        }\n      }\n\n      bodylen -= keylen;\n      if (memcached_failed(memcached_string_check(&result->value, bodylen))) {\n        return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n      }\n\n      char *vptr = memcached_string_value_mutable(&result->value);\n      if (memcached_failed(rc = memcached_safe_read(instance, vptr, bodylen))) {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      memcached_string_set_length(&result->value, bodylen);\n    } break;\n\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n    case PROTOCOL_BINARY_CMD_DECREMENT: {\n      if (bodylen != sizeof(uint64_t)) {\n        result->numeric_value = UINT64_MAX;\n        return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n      }\n\n      uint64_t val;\n      if ((rc = memcached_safe_read(instance, &val, sizeof(val))) != MEMCACHED_SUCCESS) {\n        result->numeric_value = UINT64_MAX;\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      result->numeric_value = memcached_ntohll(val);\n    } break;\n\n    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: {\n      if (header.response.keylen || bodylen + 1 > buffer_length) {\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      } else {\n        if ((rc = memcached_safe_read(instance, buffer, bodylen)) != MEMCACHED_SUCCESS) {\n          return MEMCACHED_UNKNOWN_READ_FAILURE;\n        }\n      }\n    } break;\n\n    case PROTOCOL_BINARY_CMD_VERSION: {\n      char version_buffer[32]; // @todo document this number\n      memset(version_buffer, 0, sizeof(version_buffer));\n\n      if (memcached_safe_read(instance, version_buffer, bodylen) != MEMCACHED_SUCCESS) {\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      char *endptr;\n      errno = 0;\n      long int version = strtol(version_buffer, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX\n          or version == 0) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse major version\"));\n      }\n      instance->major_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse minor version\"));\n      }\n      instance->minor_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse micro version\"));\n      }\n      instance->micro_version = uint8_t(version);\n    } break;\n\n    case PROTOCOL_BINARY_CMD_TOUCH: {\n      rc = MEMCACHED_SUCCESS;\n      if (bodylen == 4) // The four byte read is a bug?\n      {\n        char touch_buffer[4]; // @todo document this number\n        rc = memcached_safe_read(instance, touch_buffer, sizeof(touch_buffer));\n#if 0\n          fprintf(stderr, \"%s:%d %d %d %d %d %.*s(%d)\\n\", __FILE__, __LINE__,\n                  int(touch_buffer[0]),\n                  int(touch_buffer[1]),\n                  int(touch_buffer[2]),\n                  int(touch_buffer[3]),\n                  int(bodylen), touch_buffer, int(bodylen));\n#endif\n      }\n      return memcached_set_error(*instance, rc, MEMCACHED_AT);\n    }\n\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n    case PROTOCOL_BINARY_CMD_DELETE: {\n      WATCHPOINT_ASSERT(bodylen == 0);\n      return MEMCACHED_SUCCESS;\n    }\n\n    case PROTOCOL_BINARY_CMD_NOOP: {\n      WATCHPOINT_ASSERT(bodylen == 0);\n      return MEMCACHED_END;\n    }\n\n    case PROTOCOL_BINARY_CMD_STAT: {\n      if (bodylen == 0) {\n        return MEMCACHED_END;\n      } else if (bodylen + 1 > buffer_length) {\n        /* not enough space in buffer.. should not happen... */\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      } else {\n        size_t keylen = header.response.keylen;\n        memset(buffer, 0, buffer_length);\n        if ((rc = memcached_safe_read(instance, buffer, keylen)) != MEMCACHED_SUCCESS\n            || (rc = memcached_safe_read(instance, buffer + keylen + 1, bodylen - keylen))\n                != MEMCACHED_SUCCESS)\n        {\n          WATCHPOINT_ERROR(rc);\n          return MEMCACHED_UNKNOWN_READ_FAILURE;\n        }\n      }\n    } break;\n\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:\n    case PROTOCOL_BINARY_CMD_SASL_STEP: {\n      memcached_result_reset(result);\n      result->item_cas = header.response.cas;\n\n      if (memcached_string_check(&result->value, bodylen) != MEMCACHED_SUCCESS)\n        return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n\n      char *vptr = memcached_string_value_mutable(&result->value);\n      if ((rc = memcached_safe_read(instance, vptr, bodylen)) != MEMCACHED_SUCCESS) {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      memcached_string_set_length(&result->value, bodylen);\n    } break;\n    default: {\n      /* Command not implemented yet! */\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n    }\n    }\n  } else if (header.response.bodylen) {\n    /* What should I do with the error message??? just discard it for now */\n    char hole[SMALL_STRING_LEN];\n    while (bodylen > 0) {\n      size_t nr = (bodylen > SMALL_STRING_LEN) ? SMALL_STRING_LEN : bodylen;\n      if ((rc = memcached_safe_read(instance, hole, nr)) != MEMCACHED_SUCCESS) {\n        WATCHPOINT_ERROR(rc);\n        return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n      }\n      bodylen -= (uint32_t) nr;\n    }\n\n    /* This might be an error from one of the quiet commands.. if\n     * so, just throw it away and get the next one. What about creating\n     * a callback to the user with the error information?\n     */\n    switch (header.response.opcode) {\n    case PROTOCOL_BINARY_CMD_SETQ:\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n      return MEMCACHED_FETCH_NOTFINISHED;\n\n    default:\n      break;\n    }\n  }\n\n  rc = MEMCACHED_SUCCESS;\n  if (header.response.status) {\n    switch (header.response.status) {\n    case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n      rc = MEMCACHED_NOTFOUND;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:\n      rc = MEMCACHED_DATA_EXISTS;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_NOT_STORED:\n      rc = MEMCACHED_NOTSTORED;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_E2BIG:\n      rc = MEMCACHED_E2BIG;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_ENOMEM:\n      rc = MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE:\n      rc = MEMCACHED_AUTH_CONTINUE;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:\n      rc = MEMCACHED_AUTH_FAILURE;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_EINVAL:\n    case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:\n    default:\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n      break;\n    }\n  }\n\n  return rc;\n}"
  },
  {
    "function_name": "textual_read_one_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
    "lines": "175-439",
    "snippet": "static memcached_return_t textual_read_one_response(memcached_instance_st *instance, char *buffer,\n                                                    const size_t buffer_length,\n                                                    memcached_result_st *result) {\n  size_t total_read;\n  memcached_return_t rc = memcached_io_readline(instance, buffer, buffer_length, total_read);\n\n  if (memcached_failed(rc)) {\n    return rc;\n  }\n  assert(total_read);\n\n  switch (buffer[0]) {\n  case 'V': {\n    // VALUE\n    if (buffer[1] == 'A' and buffer[2] == 'L' and buffer[3] == 'U' and buffer[4] == 'E') /* VALUE */\n    {\n      /* We add back in one because we will need to search for END */\n      memcached_server_response_increment(instance);\n      return textual_value_fetch(instance, buffer, result);\n    }\n    // VERSION\n    else if (buffer[1] == 'E' and buffer[2] == 'R' and buffer[3] == 'S' and buffer[4] == 'I'\n             and buffer[5] == 'O' and buffer[6] == 'N') /* VERSION */\n    {\n      /* Find the space, and then move one past it to copy version */\n      char *response_ptr = strchr(buffer, ' ');\n\n      char *endptr;\n      errno = 0;\n      long int version = strtol(response_ptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX\n          or version == 0) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse major version\"));\n      }\n      instance->major_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse minor version\"));\n      }\n      instance->minor_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse micro version\"));\n      }\n      instance->micro_version = uint8_t(version);\n\n      return MEMCACHED_SUCCESS;\n    }\n  } break;\n\n  case 'O': {\n    // OK\n    if (buffer[1] == 'K') {\n      return MEMCACHED_SUCCESS;\n    }\n  } break;\n\n  case 'S': {\n    // STAT\n    if (buffer[1] == 'T' and buffer[2] == 'A' and buffer[3] == 'T') /* STORED STATS */ {\n      memcached_server_response_increment(instance);\n      return MEMCACHED_STAT;\n    }\n    // SERVER_ERROR\n    else if (buffer[1] == 'E' and buffer[2] == 'R' and buffer[3] == 'V' and buffer[4] == 'E'\n             and buffer[5] == 'R' and buffer[6] == '_' and buffer[7] == 'E' and buffer[8] == 'R'\n             and buffer[9] == 'R' and buffer[10] == 'O' and buffer[11] == 'R')\n    {\n      if (total_read == memcached_literal_param_size(\"SERVER_ERROR\")) {\n        return MEMCACHED_SERVER_ERROR;\n      }\n\n      if (total_read >= memcached_literal_param_size(\"SERVER_ERROR object too large for cache\")\n          and (memcmp(buffer, memcached_literal_param(\"SERVER_ERROR object too large for cache\"))\n               == 0))\n      {\n        return MEMCACHED_E2BIG;\n      }\n\n      if (total_read >= memcached_literal_param_size(\"SERVER_ERROR out of memory\")\n          and ((memcmp(buffer, memcached_literal_param(\"SERVER_ERROR out of memory\")) == 0)\n               or (memcmp(buffer, memcached_literal_param(\"SERVER_ERROR Out of memory\")) == 0)))\n      {\n        return MEMCACHED_SERVER_MEMORY_ALLOCATION_FAILURE;\n      }\n\n      // Move past the basic error message and whitespace\n      char *startptr = buffer + memcached_literal_param_size(\"SERVER_ERROR\");\n      if (startptr[0] == ' ') {\n        startptr++;\n      }\n\n      char *endptr = startptr;\n      while (*endptr != '\\r' && *endptr != '\\n') endptr++;\n\n      return memcached_set_error(*instance, MEMCACHED_SERVER_ERROR, MEMCACHED_AT, startptr,\n                                 size_t(endptr - startptr));\n    }\n    // STORED\n    else if (buffer[1] == 'T' and buffer[2] == 'O'\n             and buffer[3] == 'R') //  and buffer[4] == 'E' and buffer[5] == 'D')\n    {\n      return MEMCACHED_STORED;\n    }\n  } break;\n\n  case 'D': {\n    // DELETED\n    if (buffer[1] == 'E' and buffer[2] == 'L' and buffer[3] == 'E' and buffer[4] == 'T'\n        and buffer[5] == 'E' and buffer[6] == 'D')\n    {\n      return MEMCACHED_DELETED;\n    }\n  } break;\n\n  case 'N': {\n    // NOT_FOUND\n    if (buffer[1] == 'O' and buffer[2] == 'T' and buffer[3] == '_' and buffer[4] == 'F'\n        and buffer[5] == 'O' and buffer[6] == 'U' and buffer[7] == 'N' and buffer[8] == 'D')\n    {\n      return MEMCACHED_NOTFOUND;\n    }\n    // NOT_STORED\n    else if (buffer[1] == 'O' and buffer[2] == 'T' and buffer[3] == '_' and buffer[4] == 'S'\n             and buffer[5] == 'T' and buffer[6] == 'O' and buffer[7] == 'R' and buffer[8] == 'E'\n             and buffer[9] == 'D')\n    {\n      return MEMCACHED_NOTSTORED;\n    }\n  } break;\n\n  case 'E': /* PROTOCOL ERROR or END */\n  {\n    // END\n    if (buffer[1] == 'N' and buffer[2] == 'D') {\n      return MEMCACHED_END;\n    }\n#if 0\n      // PROTOCOL_ERROR\n      else if (buffer[1] == 'R' and buffer[2] == 'O' and buffer[3] == 'T' and buffer[4] == 'O' and buffer[5] == 'C' and buffer[6] == 'O' and buffer[7] == 'L'\n               and buffer[8] == '_'\n               and buffer[9] == 'E' and buffer[10] == 'R' and buffer[11] == 'R' and buffer[12] == 'O' and buffer[13] == 'R')\n      {\n        return MEMCACHED_PROTOCOL_ERROR;\n      }\n#endif\n    // ERROR\n    else if (buffer[1] == 'R' and buffer[2] == 'R' and buffer[3] == 'O' and buffer[4] == 'R')\n    {\n      return MEMCACHED_ERROR;\n    }\n    // EXISTS\n    else if (buffer[1] == 'X' and buffer[2] == 'I' and buffer[3] == 'S' and buffer[4] == 'T'\n             and buffer[5] == 'S')\n    {\n      return MEMCACHED_DATA_EXISTS;\n    }\n  } break;\n\n  case 'T': /* TOUCHED */\n  {\n    // TOUCHED\n    if (buffer[1] == 'O' and buffer[2] == 'U' and buffer[3] == 'C' and buffer[4] == 'H'\n        and buffer[5] == 'E' and buffer[6] == 'D')\n    {\n      return MEMCACHED_SUCCESS;\n    }\n  } break;\n\n  case 'I': /* ITEM */\n  {\n    // ITEM\n    if (buffer[1] == 'T' and buffer[2] == 'E' and buffer[3] == 'M') {\n      /* We add back in one because we will need to search for END */\n      memcached_server_response_increment(instance);\n      return MEMCACHED_ITEM;\n    }\n  } break;\n\n  case 'C': /* CLIENT ERROR */\n  {\n    // CLIENT_ERROR\n    if (buffer[1] == 'L' and buffer[2] == 'I' and buffer[3] == 'E' and buffer[4] == 'N'\n        and buffer[5] == 'T' and buffer[6] == '_' and buffer[7] == 'E' and buffer[8] == 'R'\n        and buffer[9] == 'R' and buffer[10] == 'O' and buffer[11] == 'R')\n    {\n      // Move past the basic error message and whitespace\n      char *startptr = buffer + memcached_literal_param_size(\"CLIENT_ERROR\");\n      if (startptr[0] == ' ') {\n        startptr++;\n      }\n\n      char *endptr = startptr;\n      while (*endptr != '\\r' && *endptr != '\\n') endptr++;\n\n      return memcached_set_error(*instance, MEMCACHED_CLIENT_ERROR, MEMCACHED_AT, startptr,\n                                 size_t(endptr - startptr));\n    }\n  } break;\n\n  case '0': /* INCR/DECR response */\n  case '1': /* INCR/DECR response */\n  case '2': /* INCR/DECR response */\n  case '3': /* INCR/DECR response */\n  case '4': /* INCR/DECR response */\n  case '5': /* INCR/DECR response */\n  case '6': /* INCR/DECR response */\n  case '7': /* INCR/DECR response */\n  case '8': /* INCR/DECR response */\n  case '9': /* INCR/DECR response */\n  {\n    errno = 0;\n    unsigned long long int auto_return_value = strtoull(buffer, (char **) NULL, 10);\n\n    if (auto_return_value == ULLONG_MAX and errno == ERANGE) {\n      result->numeric_value = UINT64_MAX;\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"Numeric response was out of range\"));\n    } else if (errno == EINVAL) {\n      result->numeric_value = UINT64_MAX;\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"Numeric response was out of range\"));\n    } else if (errno) {\n      result->numeric_value = UINT64_MAX;\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"Numeric response was out of range\"));\n    }\n\n    result->numeric_value = uint64_t(auto_return_value);\n\n    WATCHPOINT_STRING(buffer);\n    return MEMCACHED_SUCCESS;\n  }\n\n  default:\n    break;\n  }\n\n  buffer[total_read] = 0;\n#if 0\n  if (total_read >= sizeof(\"STORSTORED\") -1)\n  {\n    fprintf(stderr, \"%s:%d '%s', %.*s\\n\", __FILE__, __LINE__,\n            buffer, MEMCACHED_MAX_BUFFER, instance->read_buffer);\n    assert(memcmp(buffer,\"STORSTORED\", sizeof(\"STORSTORED\") -1));\n  }\n#endif\n  return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT, buffer,\n                             total_read);\n}",
    "includes": [
      "#include \"libmemcached/string.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*instance",
            "MEMCACHED_UNKNOWN_READ_FAILURE",
            "MEMCACHED_AT",
            "buffer",
            "total_read"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "183-192",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, const char *str, size_t length) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(rc != MEMCACHED_SOME_ERRORS,\n             \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a Instance\");\n\n  memcached_string_t tmp = {str, length};\n  return memcached_set_error(self, rc, at, tmp);\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, const char *str, size_t length) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(rc != MEMCACHED_SOME_ERRORS,\n             \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a Instance\");\n\n  memcached_string_t tmp = {str, length};\n  return memcached_set_error(self, rc, at, tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "memcmp(buffer,\"STORSTORED\", sizeof(\"STORSTORED\") -1)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"STORSTORED\"",
            "sizeof(\"STORSTORED\") -1"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s:%d '%s', %.*s\\n\"",
            "__FILE__",
            "__LINE__",
            "buffer",
            "MEMCACHED_MAX_BUFFER",
            "instance->read_buffer"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_STRING",
          "args": [
            "buffer"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint64_t",
          "args": [
            "auto_return_value"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Numeric response was out of range\""
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Numeric response was out of range\""
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Numeric response was out of range\""
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "buffer",
            "(char **) NULL",
            "10"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "endptr - startptr"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param_size",
          "args": [
            "\"CLIENT_ERROR\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_response_increment",
          "args": [
            "instance"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_response_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/common.h",
          "lines": "137-140",
          "snippet": "static inline void memcached_server_response_increment(memcached_instance_st *instance) {\n  instance->events(POLLIN);\n  instance->cursor_active_++;\n}",
          "includes": [
            "#  include \"p9y/poll.hpp\"",
            "#include \"libmemcached/continuum.hpp\"",
            "#  include \"libmemcached/version.hpp\"",
            "#  include \"libmemcached/result.h\"",
            "#  include \"libmemcached/key.hpp\"",
            "#  include \"libmemcached/server.hpp\"",
            "#  include \"libmemcached/assert.hpp\"",
            "#  include \"libmemcached/backtrace.hpp\"",
            "#  include \"libmemcached/virtual_bucket.h\"",
            "#  include \"libmemcached/namespace.h\"",
            "#  include \"libmemcached/response.h\"",
            "#include \"libmemcached/initialize_query.h\"",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcached/libmemcached_probes.h\"",
            "#include \"libmemcached/array.h\"",
            "#include \"libmemcached/internal.h\"",
            "#  include \"libmemcached/server_list.hpp\"",
            "#  include \"libmemcached/sasl.hpp\"",
            "#  include \"libmemcached/behavior.hpp\"",
            "#  include \"libmemcached/flag.hpp\"",
            "#  include \"libmemcached/server.hpp\"",
            "#  include \"libmemcached/server_instance.h\"",
            "#  include \"libmemcached/instance.hpp\"",
            "#  include \"libmemcached/quit.hpp\"",
            "#  include \"libmemcached/hash.hpp\"",
            "#  include \"libmemcached/allocators.hpp\"",
            "#  include \"libmemcached/connect.hpp\"",
            "#  include \"libmemcached/do.hpp\"",
            "#  include \"libmemcached/udp.hpp\"",
            "#  include \"libmemcached/io.hpp\"",
            "#  include \"libmemcachedprotocol-0.0/binary.h\"",
            "#  include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/io.h\"",
            "#include \"libmemcached/memory.h\"",
            "#include \"libmemcached/error.hpp\"",
            "#include \"libmemcached/is.h\"",
            "#include \"libmemcached/watchpoint.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#  include <dlfcn.h>",
            "#  include <strings.h>",
            "#include <fcntl.h>",
            "#  include <sys/time.h>",
            "#include \"p9y/socket.hpp\"",
            "#  include <iso646.h>",
            "#  include <limits.h>",
            "#  include <errno.h>",
            "#  include <time.h>",
            "#  include <string.h>",
            "#  include <stdlib.h>",
            "#  include <stdio.h>",
            "#  include <stddef.h>",
            "#  include <ciso646>",
            "#  include <climits>",
            "#  include <cerrno>",
            "#  include <cctype>",
            "#  include <ctime>",
            "#  include <cstring>",
            "#  include <cstdlib>",
            "#  include <cstdio>",
            "#  include <cstddef>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"p9y/poll.hpp\"\n#include \"libmemcached/continuum.hpp\"\n#  include \"libmemcached/version.hpp\"\n#  include \"libmemcached/result.h\"\n#  include \"libmemcached/key.hpp\"\n#  include \"libmemcached/server.hpp\"\n#  include \"libmemcached/assert.hpp\"\n#  include \"libmemcached/backtrace.hpp\"\n#  include \"libmemcached/virtual_bucket.h\"\n#  include \"libmemcached/namespace.h\"\n#  include \"libmemcached/response.h\"\n#include \"libmemcached/initialize_query.h\"\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcached/libmemcached_probes.h\"\n#include \"libmemcached/array.h\"\n#include \"libmemcached/internal.h\"\n#  include \"libmemcached/server_list.hpp\"\n#  include \"libmemcached/sasl.hpp\"\n#  include \"libmemcached/behavior.hpp\"\n#  include \"libmemcached/flag.hpp\"\n#  include \"libmemcached/server.hpp\"\n#  include \"libmemcached/server_instance.h\"\n#  include \"libmemcached/instance.hpp\"\n#  include \"libmemcached/quit.hpp\"\n#  include \"libmemcached/hash.hpp\"\n#  include \"libmemcached/allocators.hpp\"\n#  include \"libmemcached/connect.hpp\"\n#  include \"libmemcached/do.hpp\"\n#  include \"libmemcached/udp.hpp\"\n#  include \"libmemcached/io.hpp\"\n#  include \"libmemcachedprotocol-0.0/binary.h\"\n#  include \"libmemcached/string.hpp\"\n#include \"libmemcached/io.h\"\n#include \"libmemcached/memory.h\"\n#include \"libmemcached/error.hpp\"\n#include \"libmemcached/is.h\"\n#include \"libmemcached/watchpoint.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#  include <dlfcn.h>\n#  include <strings.h>\n#include <fcntl.h>\n#  include <sys/time.h>\n#include \"p9y/socket.hpp\"\n#  include <iso646.h>\n#  include <limits.h>\n#  include <errno.h>\n#  include <time.h>\n#  include <string.h>\n#  include <stdlib.h>\n#  include <stdio.h>\n#  include <stddef.h>\n#  include <ciso646>\n#  include <climits>\n#  include <cerrno>\n#  include <cctype>\n#  include <ctime>\n#  include <cstring>\n#  include <cstdlib>\n#  include <cstdio>\n#  include <cstddef>\n#include \"mem_config.h\"\n\nstatic inline void memcached_server_response_increment(memcached_instance_st *instance) {\n  instance->events(POLLIN);\n  instance->cursor_active_++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "endptr - startptr"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param_size",
          "args": [
            "\"SERVER_ERROR\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "memcached_literal_param(\"SERVER_ERROR Out of memory\")"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"SERVER_ERROR Out of memory\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "memcached_literal_param(\"SERVER_ERROR out of memory\")"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"SERVER_ERROR out of memory\""
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param_size",
          "args": [
            "\"SERVER_ERROR out of memory\""
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "memcached_literal_param(\"SERVER_ERROR object too large for cache\")"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"SERVER_ERROR object too large for cache\""
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param_size",
          "args": [
            "\"SERVER_ERROR object too large for cache\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param_size",
          "args": [
            "\"SERVER_ERROR\""
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint8_t",
          "args": [
            "version"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"strtol() failed to parse micro version\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "endptr",
            "&endptr",
            "10"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint8_t",
          "args": [
            "version"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"strtol() failed to parse minor version\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "endptr",
            "&endptr",
            "10"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint8_t",
          "args": [
            "version"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"strtol() failed to parse major version\""
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "response_ptr",
            "&endptr",
            "10"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buffer",
            "' '"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "textual_value_fetch",
          "args": [
            "instance",
            "buffer",
            "result"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "textual_value_fetch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
          "lines": "19-173",
          "snippet": "static memcached_return_t textual_value_fetch(memcached_instance_st *instance, char *buffer,\n                                              memcached_result_st *result) {\n  char *next_ptr;\n  ssize_t read_length = 0;\n  size_t value_length;\n\n  WATCHPOINT_ASSERT(instance->root);\n  char *end_ptr = buffer + MEMCACHED_DEFAULT_COMMAND_SIZE;\n\n  memcached_result_reset(result);\n\n  char *string_ptr = buffer;\n  string_ptr += 6; /* \"VALUE \" */\n\n  // Just used for cases of AES decrypt currently\n  memcached_return_t rc = MEMCACHED_SUCCESS;\n\n  /* We load the key */\n  {\n    char *key = result->item_key;\n    result->key_length = 0;\n\n    for (ptrdiff_t prefix_length = memcached_array_size(instance->root->_namespace);\n         !(iscntrl(*string_ptr) || isspace(*string_ptr)); string_ptr++)\n    {\n      if (prefix_length == 0) {\n        *key = *string_ptr;\n        key++;\n        result->key_length++;\n      } else\n        prefix_length--;\n    }\n    result->item_key[result->key_length] = 0;\n  }\n\n  if (end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  /* Flags fetch move past space */\n  string_ptr++;\n  if (end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  for (next_ptr = string_ptr; isdigit(*string_ptr); string_ptr++) {\n  };\n  errno = 0;\n  result->item_flags = (uint32_t) strtoul(next_ptr, &string_ptr, 10);\n\n  if (errno or end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  /* Length fetch move past space*/\n  string_ptr++;\n  if (end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  for (next_ptr = string_ptr; isdigit(*string_ptr); string_ptr++) {\n  };\n  errno = 0;\n  value_length = (size_t) strtoull(next_ptr, &string_ptr, 10);\n\n  if (errno or end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  /* Skip spaces */\n  if (*string_ptr == '\\r') {\n    /* Skip past the \\r\\n */\n    string_ptr += 2;\n  } else {\n    string_ptr++;\n    for (next_ptr = string_ptr; isdigit(*string_ptr); string_ptr++) {\n    };\n    errno = 0;\n    result->item_cas = strtoull(next_ptr, &string_ptr, 10);\n  }\n\n  if (errno or end_ptr < string_ptr) {\n    goto read_error;\n  }\n\n  /* We add two bytes so that we can walk the \\r\\n */\n  if (memcached_failed(memcached_string_check(&result->value, value_length + 2))) {\n    return memcached_set_error(*instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n  }\n\n  {\n    char *value_ptr = memcached_string_value_mutable(&result->value);\n    /*\n      We read the \\r\\n into the string since not doing so is more\n      cycles then the waster of memory to do so.\n\n      We are null terminating through, which will most likely make\n      some people lazy about using the return length.\n    */\n    size_t to_read = (value_length) + 2;\n    memcached_return_t rrc = memcached_io_read(instance, value_ptr, to_read, read_length);\n    if (memcached_failed(rrc) and rrc == MEMCACHED_IN_PROGRESS) {\n      memcached_quit_server(instance, true);\n      return memcached_set_error(*instance, MEMCACHED_IN_PROGRESS, MEMCACHED_AT);\n    } else if (memcached_failed(rrc)) {\n      return rrc;\n    }\n  }\n\n  if (read_length != (ssize_t)(value_length + 2)) {\n    goto read_error;\n  }\n\n  /* This next bit blows the API, but this is internal....*/\n  {\n    char *char_ptr;\n    char_ptr = memcached_string_value_mutable(&result->value);\n    ;\n    char_ptr[value_length] = 0;\n    char_ptr[value_length + 1] = 0;\n    memcached_string_set_length(&result->value, value_length);\n  }\n\n  if (memcached_is_encrypted(instance->root) and memcached_result_length(result)) {\n    hashkit_string_st *destination;\n\n    if ((destination = hashkit_decrypt(&instance->root->hashkit, memcached_result_value(result),\n                                       memcached_result_length(result)))\n        == NULL)\n    {\n      rc = memcached_set_error(*instance->root, MEMCACHED_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"hashkit_decrypt() failed\"));\n    } else {\n      memcached_result_reset_value(result);\n      if (memcached_failed(memcached_result_set_value(result, hashkit_string_c_str(destination),\n                                                      hashkit_string_length(destination))))\n      {\n        rc = memcached_set_error(*instance->root, MEMCACHED_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"hashkit_decrypt() failed\"));\n      }\n    }\n\n    if (memcached_failed(rc)) {\n      memcached_result_reset(result);\n    }\n    hashkit_string_free(destination);\n  }\n\n  return rc;\n\nread_error:\n  memcached_io_reset(instance);\n\n  return MEMCACHED_PARTIAL_READ;\n}",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t textual_value_fetch(memcached_instance_st *instance, char *buffer,\n                                              memcached_result_st *result) {\n  char *next_ptr;\n  ssize_t read_length = 0;\n  size_t value_length;\n\n  WATCHPOINT_ASSERT(instance->root);\n  char *end_ptr = buffer + MEMCACHED_DEFAULT_COMMAND_SIZE;\n\n  memcached_result_reset(result);\n\n  char *string_ptr = buffer;\n  string_ptr += 6; /* \"VALUE \" */\n\n  // Just used for cases of AES decrypt currently\n  memcached_return_t rc = MEMCACHED_SUCCESS;\n\n  /* We load the key */\n  {\n    char *key = result->item_key;\n    result->key_length = 0;\n\n    for (ptrdiff_t prefix_length = memcached_array_size(instance->root->_namespace);\n         !(iscntrl(*string_ptr) || isspace(*string_ptr)); string_ptr++)\n    {\n      if (prefix_length == 0) {\n        *key = *string_ptr;\n        key++;\n        result->key_length++;\n      } else\n        prefix_length--;\n    }\n    result->item_key[result->key_length] = 0;\n  }\n\n  if (end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  /* Flags fetch move past space */\n  string_ptr++;\n  if (end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  for (next_ptr = string_ptr; isdigit(*string_ptr); string_ptr++) {\n  };\n  errno = 0;\n  result->item_flags = (uint32_t) strtoul(next_ptr, &string_ptr, 10);\n\n  if (errno or end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  /* Length fetch move past space*/\n  string_ptr++;\n  if (end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  for (next_ptr = string_ptr; isdigit(*string_ptr); string_ptr++) {\n  };\n  errno = 0;\n  value_length = (size_t) strtoull(next_ptr, &string_ptr, 10);\n\n  if (errno or end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  /* Skip spaces */\n  if (*string_ptr == '\\r') {\n    /* Skip past the \\r\\n */\n    string_ptr += 2;\n  } else {\n    string_ptr++;\n    for (next_ptr = string_ptr; isdigit(*string_ptr); string_ptr++) {\n    };\n    errno = 0;\n    result->item_cas = strtoull(next_ptr, &string_ptr, 10);\n  }\n\n  if (errno or end_ptr < string_ptr) {\n    goto read_error;\n  }\n\n  /* We add two bytes so that we can walk the \\r\\n */\n  if (memcached_failed(memcached_string_check(&result->value, value_length + 2))) {\n    return memcached_set_error(*instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n  }\n\n  {\n    char *value_ptr = memcached_string_value_mutable(&result->value);\n    /*\n      We read the \\r\\n into the string since not doing so is more\n      cycles then the waster of memory to do so.\n\n      We are null terminating through, which will most likely make\n      some people lazy about using the return length.\n    */\n    size_t to_read = (value_length) + 2;\n    memcached_return_t rrc = memcached_io_read(instance, value_ptr, to_read, read_length);\n    if (memcached_failed(rrc) and rrc == MEMCACHED_IN_PROGRESS) {\n      memcached_quit_server(instance, true);\n      return memcached_set_error(*instance, MEMCACHED_IN_PROGRESS, MEMCACHED_AT);\n    } else if (memcached_failed(rrc)) {\n      return rrc;\n    }\n  }\n\n  if (read_length != (ssize_t)(value_length + 2)) {\n    goto read_error;\n  }\n\n  /* This next bit blows the API, but this is internal....*/\n  {\n    char *char_ptr;\n    char_ptr = memcached_string_value_mutable(&result->value);\n    ;\n    char_ptr[value_length] = 0;\n    char_ptr[value_length + 1] = 0;\n    memcached_string_set_length(&result->value, value_length);\n  }\n\n  if (memcached_is_encrypted(instance->root) and memcached_result_length(result)) {\n    hashkit_string_st *destination;\n\n    if ((destination = hashkit_decrypt(&instance->root->hashkit, memcached_result_value(result),\n                                       memcached_result_length(result)))\n        == NULL)\n    {\n      rc = memcached_set_error(*instance->root, MEMCACHED_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"hashkit_decrypt() failed\"));\n    } else {\n      memcached_result_reset_value(result);\n      if (memcached_failed(memcached_result_set_value(result, hashkit_string_c_str(destination),\n                                                      hashkit_string_length(destination))))\n      {\n        rc = memcached_set_error(*instance->root, MEMCACHED_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"hashkit_decrypt() failed\"));\n      }\n    }\n\n    if (memcached_failed(rc)) {\n      memcached_result_reset(result);\n    }\n    hashkit_string_free(destination);\n  }\n\n  return rc;\n\nread_error:\n  memcached_io_reset(instance);\n\n  return MEMCACHED_PARTIAL_READ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "total_read"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_io_readline",
          "args": [
            "instance",
            "buffer",
            "buffer_length",
            "total_read"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_readline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "771-818",
          "snippet": "memcached_return_t memcached_io_readline(memcached_instance_st *instance, char *buffer_ptr,\n                                         size_t size, size_t &total_nr) {\n  total_nr = 0;\n  bool line_complete = false;\n\n  while (line_complete == false) {\n    if (instance->read_buffer_length == 0) {\n      /*\n       * We don't have any data in the buffer, so let's fill the read\n       * buffer. Call the standard read function to avoid duplicating\n       * the logic.\n       */\n      ssize_t nread;\n      memcached_return_t rc = memcached_io_read(instance, buffer_ptr, 1, nread);\n      if (memcached_failed(rc) and rc == MEMCACHED_IN_PROGRESS) {\n        memcached_quit_server(instance, true);\n        return memcached_set_error(*instance, rc, MEMCACHED_AT);\n      } else if (memcached_failed(rc)) {\n        return rc;\n      }\n\n      if (*buffer_ptr == '\\n') {\n        line_complete = true;\n      }\n\n      ++buffer_ptr;\n      ++total_nr;\n    }\n\n    /* Now let's look in the buffer and copy as we go! */\n    while (instance->read_buffer_length and total_nr < size and line_complete == false) {\n      *buffer_ptr = *instance->read_ptr;\n      if (*buffer_ptr == '\\n') {\n        line_complete = true;\n      }\n      --instance->read_buffer_length;\n      ++instance->read_ptr;\n      ++total_nr;\n      ++buffer_ptr;\n    }\n\n    if (total_nr == size) {\n      return MEMCACHED_PROTOCOL_ERROR;\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_io_readline(memcached_instance_st *instance, char *buffer_ptr,\n                                         size_t size, size_t &total_nr) {\n  total_nr = 0;\n  bool line_complete = false;\n\n  while (line_complete == false) {\n    if (instance->read_buffer_length == 0) {\n      /*\n       * We don't have any data in the buffer, so let's fill the read\n       * buffer. Call the standard read function to avoid duplicating\n       * the logic.\n       */\n      ssize_t nread;\n      memcached_return_t rc = memcached_io_read(instance, buffer_ptr, 1, nread);\n      if (memcached_failed(rc) and rc == MEMCACHED_IN_PROGRESS) {\n        memcached_quit_server(instance, true);\n        return memcached_set_error(*instance, rc, MEMCACHED_AT);\n      } else if (memcached_failed(rc)) {\n        return rc;\n      }\n\n      if (*buffer_ptr == '\\n') {\n        line_complete = true;\n      }\n\n      ++buffer_ptr;\n      ++total_nr;\n    }\n\n    /* Now let's look in the buffer and copy as we go! */\n    while (instance->read_buffer_length and total_nr < size and line_complete == false) {\n      *buffer_ptr = *instance->read_ptr;\n      if (*buffer_ptr == '\\n') {\n        line_complete = true;\n      }\n      --instance->read_buffer_length;\n      ++instance->read_ptr;\n      ++total_nr;\n      ++buffer_ptr;\n    }\n\n    if (total_nr == size) {\n      return MEMCACHED_PROTOCOL_ERROR;\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t textual_read_one_response(memcached_instance_st *instance, char *buffer,\n                                                    const size_t buffer_length,\n                                                    memcached_result_st *result) {\n  size_t total_read;\n  memcached_return_t rc = memcached_io_readline(instance, buffer, buffer_length, total_read);\n\n  if (memcached_failed(rc)) {\n    return rc;\n  }\n  assert(total_read);\n\n  switch (buffer[0]) {\n  case 'V': {\n    // VALUE\n    if (buffer[1] == 'A' and buffer[2] == 'L' and buffer[3] == 'U' and buffer[4] == 'E') /* VALUE */\n    {\n      /* We add back in one because we will need to search for END */\n      memcached_server_response_increment(instance);\n      return textual_value_fetch(instance, buffer, result);\n    }\n    // VERSION\n    else if (buffer[1] == 'E' and buffer[2] == 'R' and buffer[3] == 'S' and buffer[4] == 'I'\n             and buffer[5] == 'O' and buffer[6] == 'N') /* VERSION */\n    {\n      /* Find the space, and then move one past it to copy version */\n      char *response_ptr = strchr(buffer, ' ');\n\n      char *endptr;\n      errno = 0;\n      long int version = strtol(response_ptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX\n          or version == 0) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse major version\"));\n      }\n      instance->major_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse minor version\"));\n      }\n      instance->minor_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse micro version\"));\n      }\n      instance->micro_version = uint8_t(version);\n\n      return MEMCACHED_SUCCESS;\n    }\n  } break;\n\n  case 'O': {\n    // OK\n    if (buffer[1] == 'K') {\n      return MEMCACHED_SUCCESS;\n    }\n  } break;\n\n  case 'S': {\n    // STAT\n    if (buffer[1] == 'T' and buffer[2] == 'A' and buffer[3] == 'T') /* STORED STATS */ {\n      memcached_server_response_increment(instance);\n      return MEMCACHED_STAT;\n    }\n    // SERVER_ERROR\n    else if (buffer[1] == 'E' and buffer[2] == 'R' and buffer[3] == 'V' and buffer[4] == 'E'\n             and buffer[5] == 'R' and buffer[6] == '_' and buffer[7] == 'E' and buffer[8] == 'R'\n             and buffer[9] == 'R' and buffer[10] == 'O' and buffer[11] == 'R')\n    {\n      if (total_read == memcached_literal_param_size(\"SERVER_ERROR\")) {\n        return MEMCACHED_SERVER_ERROR;\n      }\n\n      if (total_read >= memcached_literal_param_size(\"SERVER_ERROR object too large for cache\")\n          and (memcmp(buffer, memcached_literal_param(\"SERVER_ERROR object too large for cache\"))\n               == 0))\n      {\n        return MEMCACHED_E2BIG;\n      }\n\n      if (total_read >= memcached_literal_param_size(\"SERVER_ERROR out of memory\")\n          and ((memcmp(buffer, memcached_literal_param(\"SERVER_ERROR out of memory\")) == 0)\n               or (memcmp(buffer, memcached_literal_param(\"SERVER_ERROR Out of memory\")) == 0)))\n      {\n        return MEMCACHED_SERVER_MEMORY_ALLOCATION_FAILURE;\n      }\n\n      // Move past the basic error message and whitespace\n      char *startptr = buffer + memcached_literal_param_size(\"SERVER_ERROR\");\n      if (startptr[0] == ' ') {\n        startptr++;\n      }\n\n      char *endptr = startptr;\n      while (*endptr != '\\r' && *endptr != '\\n') endptr++;\n\n      return memcached_set_error(*instance, MEMCACHED_SERVER_ERROR, MEMCACHED_AT, startptr,\n                                 size_t(endptr - startptr));\n    }\n    // STORED\n    else if (buffer[1] == 'T' and buffer[2] == 'O'\n             and buffer[3] == 'R') //  and buffer[4] == 'E' and buffer[5] == 'D')\n    {\n      return MEMCACHED_STORED;\n    }\n  } break;\n\n  case 'D': {\n    // DELETED\n    if (buffer[1] == 'E' and buffer[2] == 'L' and buffer[3] == 'E' and buffer[4] == 'T'\n        and buffer[5] == 'E' and buffer[6] == 'D')\n    {\n      return MEMCACHED_DELETED;\n    }\n  } break;\n\n  case 'N': {\n    // NOT_FOUND\n    if (buffer[1] == 'O' and buffer[2] == 'T' and buffer[3] == '_' and buffer[4] == 'F'\n        and buffer[5] == 'O' and buffer[6] == 'U' and buffer[7] == 'N' and buffer[8] == 'D')\n    {\n      return MEMCACHED_NOTFOUND;\n    }\n    // NOT_STORED\n    else if (buffer[1] == 'O' and buffer[2] == 'T' and buffer[3] == '_' and buffer[4] == 'S'\n             and buffer[5] == 'T' and buffer[6] == 'O' and buffer[7] == 'R' and buffer[8] == 'E'\n             and buffer[9] == 'D')\n    {\n      return MEMCACHED_NOTSTORED;\n    }\n  } break;\n\n  case 'E': /* PROTOCOL ERROR or END */\n  {\n    // END\n    if (buffer[1] == 'N' and buffer[2] == 'D') {\n      return MEMCACHED_END;\n    }\n#if 0\n      // PROTOCOL_ERROR\n      else if (buffer[1] == 'R' and buffer[2] == 'O' and buffer[3] == 'T' and buffer[4] == 'O' and buffer[5] == 'C' and buffer[6] == 'O' and buffer[7] == 'L'\n               and buffer[8] == '_'\n               and buffer[9] == 'E' and buffer[10] == 'R' and buffer[11] == 'R' and buffer[12] == 'O' and buffer[13] == 'R')\n      {\n        return MEMCACHED_PROTOCOL_ERROR;\n      }\n#endif\n    // ERROR\n    else if (buffer[1] == 'R' and buffer[2] == 'R' and buffer[3] == 'O' and buffer[4] == 'R')\n    {\n      return MEMCACHED_ERROR;\n    }\n    // EXISTS\n    else if (buffer[1] == 'X' and buffer[2] == 'I' and buffer[3] == 'S' and buffer[4] == 'T'\n             and buffer[5] == 'S')\n    {\n      return MEMCACHED_DATA_EXISTS;\n    }\n  } break;\n\n  case 'T': /* TOUCHED */\n  {\n    // TOUCHED\n    if (buffer[1] == 'O' and buffer[2] == 'U' and buffer[3] == 'C' and buffer[4] == 'H'\n        and buffer[5] == 'E' and buffer[6] == 'D')\n    {\n      return MEMCACHED_SUCCESS;\n    }\n  } break;\n\n  case 'I': /* ITEM */\n  {\n    // ITEM\n    if (buffer[1] == 'T' and buffer[2] == 'E' and buffer[3] == 'M') {\n      /* We add back in one because we will need to search for END */\n      memcached_server_response_increment(instance);\n      return MEMCACHED_ITEM;\n    }\n  } break;\n\n  case 'C': /* CLIENT ERROR */\n  {\n    // CLIENT_ERROR\n    if (buffer[1] == 'L' and buffer[2] == 'I' and buffer[3] == 'E' and buffer[4] == 'N'\n        and buffer[5] == 'T' and buffer[6] == '_' and buffer[7] == 'E' and buffer[8] == 'R'\n        and buffer[9] == 'R' and buffer[10] == 'O' and buffer[11] == 'R')\n    {\n      // Move past the basic error message and whitespace\n      char *startptr = buffer + memcached_literal_param_size(\"CLIENT_ERROR\");\n      if (startptr[0] == ' ') {\n        startptr++;\n      }\n\n      char *endptr = startptr;\n      while (*endptr != '\\r' && *endptr != '\\n') endptr++;\n\n      return memcached_set_error(*instance, MEMCACHED_CLIENT_ERROR, MEMCACHED_AT, startptr,\n                                 size_t(endptr - startptr));\n    }\n  } break;\n\n  case '0': /* INCR/DECR response */\n  case '1': /* INCR/DECR response */\n  case '2': /* INCR/DECR response */\n  case '3': /* INCR/DECR response */\n  case '4': /* INCR/DECR response */\n  case '5': /* INCR/DECR response */\n  case '6': /* INCR/DECR response */\n  case '7': /* INCR/DECR response */\n  case '8': /* INCR/DECR response */\n  case '9': /* INCR/DECR response */\n  {\n    errno = 0;\n    unsigned long long int auto_return_value = strtoull(buffer, (char **) NULL, 10);\n\n    if (auto_return_value == ULLONG_MAX and errno == ERANGE) {\n      result->numeric_value = UINT64_MAX;\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"Numeric response was out of range\"));\n    } else if (errno == EINVAL) {\n      result->numeric_value = UINT64_MAX;\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"Numeric response was out of range\"));\n    } else if (errno) {\n      result->numeric_value = UINT64_MAX;\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"Numeric response was out of range\"));\n    }\n\n    result->numeric_value = uint64_t(auto_return_value);\n\n    WATCHPOINT_STRING(buffer);\n    return MEMCACHED_SUCCESS;\n  }\n\n  default:\n    break;\n  }\n\n  buffer[total_read] = 0;\n#if 0\n  if (total_read >= sizeof(\"STORSTORED\") -1)\n  {\n    fprintf(stderr, \"%s:%d '%s', %.*s\\n\", __FILE__, __LINE__,\n            buffer, MEMCACHED_MAX_BUFFER, instance->read_buffer);\n    assert(memcmp(buffer,\"STORSTORED\", sizeof(\"STORSTORED\") -1));\n  }\n#endif\n  return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT, buffer,\n                             total_read);\n}"
  },
  {
    "function_name": "textual_value_fetch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
    "lines": "19-173",
    "snippet": "static memcached_return_t textual_value_fetch(memcached_instance_st *instance, char *buffer,\n                                              memcached_result_st *result) {\n  char *next_ptr;\n  ssize_t read_length = 0;\n  size_t value_length;\n\n  WATCHPOINT_ASSERT(instance->root);\n  char *end_ptr = buffer + MEMCACHED_DEFAULT_COMMAND_SIZE;\n\n  memcached_result_reset(result);\n\n  char *string_ptr = buffer;\n  string_ptr += 6; /* \"VALUE \" */\n\n  // Just used for cases of AES decrypt currently\n  memcached_return_t rc = MEMCACHED_SUCCESS;\n\n  /* We load the key */\n  {\n    char *key = result->item_key;\n    result->key_length = 0;\n\n    for (ptrdiff_t prefix_length = memcached_array_size(instance->root->_namespace);\n         !(iscntrl(*string_ptr) || isspace(*string_ptr)); string_ptr++)\n    {\n      if (prefix_length == 0) {\n        *key = *string_ptr;\n        key++;\n        result->key_length++;\n      } else\n        prefix_length--;\n    }\n    result->item_key[result->key_length] = 0;\n  }\n\n  if (end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  /* Flags fetch move past space */\n  string_ptr++;\n  if (end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  for (next_ptr = string_ptr; isdigit(*string_ptr); string_ptr++) {\n  };\n  errno = 0;\n  result->item_flags = (uint32_t) strtoul(next_ptr, &string_ptr, 10);\n\n  if (errno or end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  /* Length fetch move past space*/\n  string_ptr++;\n  if (end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  for (next_ptr = string_ptr; isdigit(*string_ptr); string_ptr++) {\n  };\n  errno = 0;\n  value_length = (size_t) strtoull(next_ptr, &string_ptr, 10);\n\n  if (errno or end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  /* Skip spaces */\n  if (*string_ptr == '\\r') {\n    /* Skip past the \\r\\n */\n    string_ptr += 2;\n  } else {\n    string_ptr++;\n    for (next_ptr = string_ptr; isdigit(*string_ptr); string_ptr++) {\n    };\n    errno = 0;\n    result->item_cas = strtoull(next_ptr, &string_ptr, 10);\n  }\n\n  if (errno or end_ptr < string_ptr) {\n    goto read_error;\n  }\n\n  /* We add two bytes so that we can walk the \\r\\n */\n  if (memcached_failed(memcached_string_check(&result->value, value_length + 2))) {\n    return memcached_set_error(*instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n  }\n\n  {\n    char *value_ptr = memcached_string_value_mutable(&result->value);\n    /*\n      We read the \\r\\n into the string since not doing so is more\n      cycles then the waster of memory to do so.\n\n      We are null terminating through, which will most likely make\n      some people lazy about using the return length.\n    */\n    size_t to_read = (value_length) + 2;\n    memcached_return_t rrc = memcached_io_read(instance, value_ptr, to_read, read_length);\n    if (memcached_failed(rrc) and rrc == MEMCACHED_IN_PROGRESS) {\n      memcached_quit_server(instance, true);\n      return memcached_set_error(*instance, MEMCACHED_IN_PROGRESS, MEMCACHED_AT);\n    } else if (memcached_failed(rrc)) {\n      return rrc;\n    }\n  }\n\n  if (read_length != (ssize_t)(value_length + 2)) {\n    goto read_error;\n  }\n\n  /* This next bit blows the API, but this is internal....*/\n  {\n    char *char_ptr;\n    char_ptr = memcached_string_value_mutable(&result->value);\n    ;\n    char_ptr[value_length] = 0;\n    char_ptr[value_length + 1] = 0;\n    memcached_string_set_length(&result->value, value_length);\n  }\n\n  if (memcached_is_encrypted(instance->root) and memcached_result_length(result)) {\n    hashkit_string_st *destination;\n\n    if ((destination = hashkit_decrypt(&instance->root->hashkit, memcached_result_value(result),\n                                       memcached_result_length(result)))\n        == NULL)\n    {\n      rc = memcached_set_error(*instance->root, MEMCACHED_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"hashkit_decrypt() failed\"));\n    } else {\n      memcached_result_reset_value(result);\n      if (memcached_failed(memcached_result_set_value(result, hashkit_string_c_str(destination),\n                                                      hashkit_string_length(destination))))\n      {\n        rc = memcached_set_error(*instance->root, MEMCACHED_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"hashkit_decrypt() failed\"));\n      }\n    }\n\n    if (memcached_failed(rc)) {\n      memcached_result_reset(result);\n    }\n    hashkit_string_free(destination);\n  }\n\n  return rc;\n\nread_error:\n  memcached_io_reset(instance);\n\n  return MEMCACHED_PARTIAL_READ;\n}",
    "includes": [
      "#include \"libmemcached/string.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_io_reset",
          "args": [
            "instance"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "740-742",
          "snippet": "void memcached_io_reset(memcached_instance_st *instance) {\n  memcached_quit_server(instance, true);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_io_reset(memcached_instance_st *instance) {\n  memcached_quit_server(instance, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashkit_string_free",
          "args": [
            "destination"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "hashkit_string_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/string.cc",
          "lines": "139-148",
          "snippet": "void hashkit_string_free(hashkit_string_st *ptr) {\n  if (ptr == NULL) {\n    return;\n  }\n\n  if (ptr->string) {\n    free(ptr->string);\n  }\n  free(ptr);\n}",
          "includes": [
            "#include <cstring>",
            "#include <cassert>",
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstring>\n#include <cassert>\n#include \"libhashkit/common.h\"\n\nvoid hashkit_string_free(hashkit_string_st *ptr) {\n  if (ptr == NULL) {\n    return;\n  }\n\n  if (ptr->string) {\n    free(ptr->string);\n  }\n  free(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_result_reset",
          "args": [
            "result"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_result_reset_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/result.cc",
          "lines": "84-86",
          "snippet": "void memcached_result_reset_value(memcached_result_st *ptr) {\n  memcached_string_reset(&ptr->value);\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_result_reset_value(memcached_result_st *ptr) {\n  memcached_string_reset(&ptr->value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*instance->root",
            "MEMCACHED_FAILURE",
            "MEMCACHED_AT",
            "memcached_literal_param(\"hashkit_decrypt() failed\")"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"hashkit_decrypt() failed\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "memcached_result_set_value(result, hashkit_string_c_str(destination),\n                                                      hashkit_string_length(destination))"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_result_set_value",
          "args": [
            "result",
            "hashkit_string_c_str(destination)",
            "hashkit_string_length(destination)"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_result_set_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/result.cc",
          "lines": "88-95",
          "snippet": "memcached_return_t memcached_result_set_value(memcached_result_st *ptr, const char *value,\n                                              size_t length) {\n  if (memcached_failed(memcached_string_append(&ptr->value, value, length))) {\n    return memcached_set_errno(*ptr->root, errno, MEMCACHED_AT);\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_result_set_value(memcached_result_st *ptr, const char *value,\n                                              size_t length) {\n  if (memcached_failed(memcached_string_append(&ptr->value, value, length))) {\n    return memcached_set_errno(*ptr->root, errno, MEMCACHED_AT);\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashkit_string_length",
          "args": [
            "destination"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "hashkit_string_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/string.cc",
          "lines": "154-156",
          "snippet": "size_t hashkit_string_length(const hashkit_string_st *self) {\n  return size_t(self->end - self->string);\n}",
          "includes": [
            "#include <cstring>",
            "#include <cassert>",
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstring>\n#include <cassert>\n#include \"libhashkit/common.h\"\n\nsize_t hashkit_string_length(const hashkit_string_st *self) {\n  return size_t(self->end - self->string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashkit_string_c_str",
          "args": [
            "destination"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"hashkit_decrypt() failed\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashkit_decrypt",
          "args": [
            "&instance->root->hashkit",
            "memcached_result_value(result)",
            "memcached_result_length(result)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_result_length",
          "args": [
            "result"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_result_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/result.cc",
          "lines": "110-113",
          "snippet": "size_t memcached_result_length(const memcached_result_st *self) {\n  const memcached_string_st *sptr = &self->value;\n  return memcached_string_length(sptr);\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nsize_t memcached_result_length(const memcached_result_st *self) {\n  const memcached_string_st *sptr = &self->value;\n  return memcached_string_length(sptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_result_value",
          "args": [
            "result"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_encrypted",
          "args": [
            "instance->root"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_string_set_length",
          "args": [
            "&result->value",
            "value_length"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_string_set_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/string.cc",
          "lines": "254-263",
          "snippet": "void memcached_string_set_length(memcached_string_st &self, const size_t length) {\n  assert(self.current_size >= length);\n  size_t set_length = length;\n  if (self.current_size > length) {\n    if (memcached_failed(_string_check(&self, length))) {\n      set_length = self.current_size;\n    }\n  }\n  self.end = self.string + set_length;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_string_set_length(memcached_string_st &self, const size_t length) {\n  assert(self.current_size >= length);\n  size_t set_length = length;\n  if (self.current_size > length) {\n    if (memcached_failed(_string_check(&self, length))) {\n      set_length = self.current_size;\n    }\n  }\n  self.end = self.string + set_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_string_value_mutable",
          "args": [
            "&result->value"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rrc"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_quit_server",
          "args": [
            "instance",
            "true"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_quit_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
          "lines": "75-99",
          "snippet": "void memcached_quit_server(memcached_instance_st *instance, bool io_death) {\n  if (instance->valid()) {\n    if (io_death == false and memcached_is_udp(instance->root) == false\n        and instance->is_shutting_down() == false)\n    {\n      send_quit_message(instance);\n\n      instance->start_close_socket();\n      drain_instance(instance);\n    }\n  }\n\n  instance->close_socket();\n\n  if (io_death and memcached_is_udp(instance->root)) {\n    /*\n       If using UDP, we should stop using the server briefly on every IO\n       failure. If using TCP, it may be that the connection went down a\n       short while ago (e.g. the server failed) and we've only just\n       noticed, so we should only set the retry timeout on a connect\n       failure (which doesn't call this method).\n       */\n    memcached_mark_server_for_timeout(instance);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_quit_server(memcached_instance_st *instance, bool io_death) {\n  if (instance->valid()) {\n    if (io_death == false and memcached_is_udp(instance->root) == false\n        and instance->is_shutting_down() == false)\n    {\n      send_quit_message(instance);\n\n      instance->start_close_socket();\n      drain_instance(instance);\n    }\n  }\n\n  instance->close_socket();\n\n  if (io_death and memcached_is_udp(instance->root)) {\n    /*\n       If using UDP, we should stop using the server briefly on every IO\n       failure. If using TCP, it may be that the connection went down a\n       short while ago (e.g. the server failed) and we've only just\n       noticed, so we should only set the retry timeout on a connect\n       failure (which doesn't call this method).\n       */\n    memcached_mark_server_for_timeout(instance);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rrc"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_io_read",
          "args": [
            "instance",
            "value_ptr",
            "to_read",
            "read_length"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_readline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "771-818",
          "snippet": "memcached_return_t memcached_io_readline(memcached_instance_st *instance, char *buffer_ptr,\n                                         size_t size, size_t &total_nr) {\n  total_nr = 0;\n  bool line_complete = false;\n\n  while (line_complete == false) {\n    if (instance->read_buffer_length == 0) {\n      /*\n       * We don't have any data in the buffer, so let's fill the read\n       * buffer. Call the standard read function to avoid duplicating\n       * the logic.\n       */\n      ssize_t nread;\n      memcached_return_t rc = memcached_io_read(instance, buffer_ptr, 1, nread);\n      if (memcached_failed(rc) and rc == MEMCACHED_IN_PROGRESS) {\n        memcached_quit_server(instance, true);\n        return memcached_set_error(*instance, rc, MEMCACHED_AT);\n      } else if (memcached_failed(rc)) {\n        return rc;\n      }\n\n      if (*buffer_ptr == '\\n') {\n        line_complete = true;\n      }\n\n      ++buffer_ptr;\n      ++total_nr;\n    }\n\n    /* Now let's look in the buffer and copy as we go! */\n    while (instance->read_buffer_length and total_nr < size and line_complete == false) {\n      *buffer_ptr = *instance->read_ptr;\n      if (*buffer_ptr == '\\n') {\n        line_complete = true;\n      }\n      --instance->read_buffer_length;\n      ++instance->read_ptr;\n      ++total_nr;\n      ++buffer_ptr;\n    }\n\n    if (total_nr == size) {\n      return MEMCACHED_PROTOCOL_ERROR;\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_io_readline(memcached_instance_st *instance, char *buffer_ptr,\n                                         size_t size, size_t &total_nr) {\n  total_nr = 0;\n  bool line_complete = false;\n\n  while (line_complete == false) {\n    if (instance->read_buffer_length == 0) {\n      /*\n       * We don't have any data in the buffer, so let's fill the read\n       * buffer. Call the standard read function to avoid duplicating\n       * the logic.\n       */\n      ssize_t nread;\n      memcached_return_t rc = memcached_io_read(instance, buffer_ptr, 1, nread);\n      if (memcached_failed(rc) and rc == MEMCACHED_IN_PROGRESS) {\n        memcached_quit_server(instance, true);\n        return memcached_set_error(*instance, rc, MEMCACHED_AT);\n      } else if (memcached_failed(rc)) {\n        return rc;\n      }\n\n      if (*buffer_ptr == '\\n') {\n        line_complete = true;\n      }\n\n      ++buffer_ptr;\n      ++total_nr;\n    }\n\n    /* Now let's look in the buffer and copy as we go! */\n    while (instance->read_buffer_length and total_nr < size and line_complete == false) {\n      *buffer_ptr = *instance->read_ptr;\n      if (*buffer_ptr == '\\n') {\n        line_complete = true;\n      }\n      --instance->read_buffer_length;\n      ++instance->read_ptr;\n      ++total_nr;\n      ++buffer_ptr;\n    }\n\n    if (total_nr == size) {\n      return MEMCACHED_PROTOCOL_ERROR;\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_string_value_mutable",
          "args": [
            "&result->value"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "memcached_string_check(&result->value, value_length + 2)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_string_check",
          "args": [
            "&result->value",
            "value_length + 2"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_string_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/string.cc",
          "lines": "195-197",
          "snippet": "memcached_return_t memcached_string_check(memcached_string_st *string, size_t need) {\n  return _string_check(string, need);\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_string_check(memcached_string_st *string, size_t need) {\n  return _string_check(string, need);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "next_ptr",
            "&string_ptr",
            "10"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*string_ptr"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "next_ptr",
            "&string_ptr",
            "10"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*string_ptr"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "next_ptr",
            "&string_ptr",
            "10"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*string_ptr"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*string_ptr"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscntrl",
          "args": [
            "*string_ptr"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_array_size",
          "args": [
            "instance->root->_namespace"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_array_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/array.cc",
          "lines": "78-84",
          "snippet": "size_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"libmemcached/common.h\"\n\nsize_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "instance->root"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t textual_value_fetch(memcached_instance_st *instance, char *buffer,\n                                              memcached_result_st *result) {\n  char *next_ptr;\n  ssize_t read_length = 0;\n  size_t value_length;\n\n  WATCHPOINT_ASSERT(instance->root);\n  char *end_ptr = buffer + MEMCACHED_DEFAULT_COMMAND_SIZE;\n\n  memcached_result_reset(result);\n\n  char *string_ptr = buffer;\n  string_ptr += 6; /* \"VALUE \" */\n\n  // Just used for cases of AES decrypt currently\n  memcached_return_t rc = MEMCACHED_SUCCESS;\n\n  /* We load the key */\n  {\n    char *key = result->item_key;\n    result->key_length = 0;\n\n    for (ptrdiff_t prefix_length = memcached_array_size(instance->root->_namespace);\n         !(iscntrl(*string_ptr) || isspace(*string_ptr)); string_ptr++)\n    {\n      if (prefix_length == 0) {\n        *key = *string_ptr;\n        key++;\n        result->key_length++;\n      } else\n        prefix_length--;\n    }\n    result->item_key[result->key_length] = 0;\n  }\n\n  if (end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  /* Flags fetch move past space */\n  string_ptr++;\n  if (end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  for (next_ptr = string_ptr; isdigit(*string_ptr); string_ptr++) {\n  };\n  errno = 0;\n  result->item_flags = (uint32_t) strtoul(next_ptr, &string_ptr, 10);\n\n  if (errno or end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  /* Length fetch move past space*/\n  string_ptr++;\n  if (end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  for (next_ptr = string_ptr; isdigit(*string_ptr); string_ptr++) {\n  };\n  errno = 0;\n  value_length = (size_t) strtoull(next_ptr, &string_ptr, 10);\n\n  if (errno or end_ptr == string_ptr) {\n    goto read_error;\n  }\n\n  /* Skip spaces */\n  if (*string_ptr == '\\r') {\n    /* Skip past the \\r\\n */\n    string_ptr += 2;\n  } else {\n    string_ptr++;\n    for (next_ptr = string_ptr; isdigit(*string_ptr); string_ptr++) {\n    };\n    errno = 0;\n    result->item_cas = strtoull(next_ptr, &string_ptr, 10);\n  }\n\n  if (errno or end_ptr < string_ptr) {\n    goto read_error;\n  }\n\n  /* We add two bytes so that we can walk the \\r\\n */\n  if (memcached_failed(memcached_string_check(&result->value, value_length + 2))) {\n    return memcached_set_error(*instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n  }\n\n  {\n    char *value_ptr = memcached_string_value_mutable(&result->value);\n    /*\n      We read the \\r\\n into the string since not doing so is more\n      cycles then the waster of memory to do so.\n\n      We are null terminating through, which will most likely make\n      some people lazy about using the return length.\n    */\n    size_t to_read = (value_length) + 2;\n    memcached_return_t rrc = memcached_io_read(instance, value_ptr, to_read, read_length);\n    if (memcached_failed(rrc) and rrc == MEMCACHED_IN_PROGRESS) {\n      memcached_quit_server(instance, true);\n      return memcached_set_error(*instance, MEMCACHED_IN_PROGRESS, MEMCACHED_AT);\n    } else if (memcached_failed(rrc)) {\n      return rrc;\n    }\n  }\n\n  if (read_length != (ssize_t)(value_length + 2)) {\n    goto read_error;\n  }\n\n  /* This next bit blows the API, but this is internal....*/\n  {\n    char *char_ptr;\n    char_ptr = memcached_string_value_mutable(&result->value);\n    ;\n    char_ptr[value_length] = 0;\n    char_ptr[value_length + 1] = 0;\n    memcached_string_set_length(&result->value, value_length);\n  }\n\n  if (memcached_is_encrypted(instance->root) and memcached_result_length(result)) {\n    hashkit_string_st *destination;\n\n    if ((destination = hashkit_decrypt(&instance->root->hashkit, memcached_result_value(result),\n                                       memcached_result_length(result)))\n        == NULL)\n    {\n      rc = memcached_set_error(*instance->root, MEMCACHED_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"hashkit_decrypt() failed\"));\n    } else {\n      memcached_result_reset_value(result);\n      if (memcached_failed(memcached_result_set_value(result, hashkit_string_c_str(destination),\n                                                      hashkit_string_length(destination))))\n      {\n        rc = memcached_set_error(*instance->root, MEMCACHED_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"hashkit_decrypt() failed\"));\n      }\n    }\n\n    if (memcached_failed(rc)) {\n      memcached_result_reset(result);\n    }\n    hashkit_string_free(destination);\n  }\n\n  return rc;\n\nread_error:\n  memcached_io_reset(instance);\n\n  return MEMCACHED_PARTIAL_READ;\n}"
  }
]