[
  {
    "function_name": "memcached_servers_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/parse.cc",
    "lines": "18-94",
    "snippet": "memcached_server_list_st memcached_servers_parse(const char *server_strings) {\n  char *string;\n  const char *begin_ptr;\n  const char *end_ptr;\n  memcached_server_st *servers = NULL;\n  memcached_return_t rc;\n\n  WATCHPOINT_ASSERT(server_strings);\n\n  end_ptr = server_strings + strlen(server_strings);\n\n  for (begin_ptr = server_strings, string = (char *) strchr(server_strings, ',');\n       begin_ptr != end_ptr; string = (char *) strchr(begin_ptr, ','))\n  {\n    char buffer[HUGE_STRING_LEN];\n    char *ptr, *ptr2 = NULL;\n    uint32_t weight = 0;\n\n    if (string) {\n      memcpy(buffer, begin_ptr, (size_t)(string - begin_ptr));\n      buffer[(unsigned int) (string - begin_ptr)] = 0;\n      begin_ptr = string + 1;\n    } else {\n      size_t length = strlen(begin_ptr);\n      memcpy(buffer, begin_ptr, length);\n      buffer[length] = 0;\n      begin_ptr = end_ptr;\n    }\n\n    ptr = strchr(buffer, '[');\n    if (ptr) {\n      ptr2 = strchr(ptr+1, ']');\n    }\n    if (ptr && ptr2) {\n      // [IPv6]:port\n      ptr = strchr(ptr2+1, ':');\n    } else {\n      // IPv4:port or name:port\n      ptr = strchr(buffer, ':');\n    }\n    in_port_t port = 0;\n    if (ptr) {\n      ptr[0] = 0;\n\n      ptr++;\n\n      errno = 0;\n      port = (in_port_t) strtoul(ptr, (char **) NULL, 10);\n      if (errno) {\n        memcached_server_free(servers);\n        return NULL;\n      }\n\n      ptr2 = strchr(ptr, ' ');\n      if (!ptr2)\n        ptr2 = strchr(ptr, ':');\n\n      if (ptr2) {\n        ptr2++;\n        errno = 0;\n        weight = uint32_t(strtoul(ptr2, (char **) NULL, 10));\n        if (errno) {\n          memcached_server_free(servers);\n          return NULL;\n        }\n      }\n    }\n\n    servers = memcached_server_list_append_with_weight(servers, buffer, port, weight, &rc);\n\n    if (isspace(*begin_ptr)) {\n      begin_ptr++;\n    }\n  }\n\n  return servers;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*begin_ptr"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_list_append_with_weight",
          "args": [
            "servers",
            "buffer",
            "port",
            "weight",
            "&rc"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_list_append_with_weight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "18-75",
          "snippet": "memcached_server_list_st memcached_server_list_append_with_weight(memcached_server_list_st ptr,\n                                                                  const char *hostname,\n                                                                  in_port_t port, uint32_t weight,\n                                                                  memcached_return_t *error) {\n  memcached_return_t unused;\n  if (error == NULL) {\n    error = &unused;\n  }\n\n  if (hostname == NULL) {\n    hostname = \"localhost\";\n  }\n\n  if (hostname[0] == '/') {\n    port = 0;\n  } else if (port == 0) {\n    port = MEMCACHED_DEFAULT_PORT;\n  }\n\n  /* Increment count for hosts */\n  uint32_t count = 1;\n  if (ptr) {\n    count += memcached_server_list_count(ptr);\n  }\n\n  memcached_server_list_st new_host_list =\n      (memcached_server_st *) realloc(ptr, sizeof(memcached_server_st) * count);\n  if (new_host_list == NULL) {\n#if 0\n    *error= memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n#endif\n    return NULL;\n  }\n\n  memcached_string_t _hostname = {memcached_string_make_from_cstr(hostname)};\n  /* @todo Check return type */\n  if (server_create_with(NULL, &new_host_list[count - 1], _hostname, port, weight,\n                         port ? MEMCACHED_CONNECTION_TCP : MEMCACHED_CONNECTION_UNIX_SOCKET)\n      == NULL)\n  {\n#if 0\n    *error= memcached_set_errno(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n#endif\n    free(new_host_list);\n    return NULL;\n  }\n\n#if 0\n  // Handset allocated since\n  new_host_list->options.is_allocated= true;\n#endif\n\n  /* Backwards compatibility hack */\n  memcached_servers_set_count(new_host_list, count);\n\n  *error = MEMCACHED_SUCCESS;\n  return new_host_list;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_server_list_st memcached_server_list_append_with_weight(memcached_server_list_st ptr,\n                                                                  const char *hostname,\n                                                                  in_port_t port, uint32_t weight,\n                                                                  memcached_return_t *error) {\n  memcached_return_t unused;\n  if (error == NULL) {\n    error = &unused;\n  }\n\n  if (hostname == NULL) {\n    hostname = \"localhost\";\n  }\n\n  if (hostname[0] == '/') {\n    port = 0;\n  } else if (port == 0) {\n    port = MEMCACHED_DEFAULT_PORT;\n  }\n\n  /* Increment count for hosts */\n  uint32_t count = 1;\n  if (ptr) {\n    count += memcached_server_list_count(ptr);\n  }\n\n  memcached_server_list_st new_host_list =\n      (memcached_server_st *) realloc(ptr, sizeof(memcached_server_st) * count);\n  if (new_host_list == NULL) {\n#if 0\n    *error= memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n#endif\n    return NULL;\n  }\n\n  memcached_string_t _hostname = {memcached_string_make_from_cstr(hostname)};\n  /* @todo Check return type */\n  if (server_create_with(NULL, &new_host_list[count - 1], _hostname, port, weight,\n                         port ? MEMCACHED_CONNECTION_TCP : MEMCACHED_CONNECTION_UNIX_SOCKET)\n      == NULL)\n  {\n#if 0\n    *error= memcached_set_errno(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n#endif\n    free(new_host_list);\n    return NULL;\n  }\n\n#if 0\n  // Handset allocated since\n  new_host_list->options.is_allocated= true;\n#endif\n\n  /* Backwards compatibility hack */\n  memcached_servers_set_count(new_host_list, count);\n\n  *error = MEMCACHED_SUCCESS;\n  return new_host_list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_free",
          "args": [
            "servers"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "105-116",
          "snippet": "void memcached_server_free(memcached_server_st *self) {\n  if (self == NULL) {\n    return;\n  }\n\n  if (memcached_server_list_count(self)) {\n    memcached_server_list_free(self);\n    return;\n  }\n\n  server_free(self);\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_server_free(memcached_server_st *self) {\n  if (self == NULL) {\n    return;\n  }\n\n  if (memcached_server_list_count(self)) {\n    memcached_server_list_free(self);\n    return;\n  }\n\n  server_free(self);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uint32_t",
          "args": [
            "strtoul(ptr2, (char **) NULL, 10)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "ptr2",
            "(char **) NULL",
            "10"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ptr",
            "':'"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ptr",
            "' '"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "ptr",
            "(char **) NULL",
            "10"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buffer",
            "':'"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ptr2+1",
            "':'"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ptr+1",
            "']'"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buffer",
            "'['"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "begin_ptr",
            "length"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "begin_ptr"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "begin_ptr",
            "(size_t)(string - begin_ptr)"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "begin_ptr",
            "','"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "server_strings",
            "','"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "server_strings"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "server_strings"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_server_list_st memcached_servers_parse(const char *server_strings) {\n  char *string;\n  const char *begin_ptr;\n  const char *end_ptr;\n  memcached_server_st *servers = NULL;\n  memcached_return_t rc;\n\n  WATCHPOINT_ASSERT(server_strings);\n\n  end_ptr = server_strings + strlen(server_strings);\n\n  for (begin_ptr = server_strings, string = (char *) strchr(server_strings, ',');\n       begin_ptr != end_ptr; string = (char *) strchr(begin_ptr, ','))\n  {\n    char buffer[HUGE_STRING_LEN];\n    char *ptr, *ptr2 = NULL;\n    uint32_t weight = 0;\n\n    if (string) {\n      memcpy(buffer, begin_ptr, (size_t)(string - begin_ptr));\n      buffer[(unsigned int) (string - begin_ptr)] = 0;\n      begin_ptr = string + 1;\n    } else {\n      size_t length = strlen(begin_ptr);\n      memcpy(buffer, begin_ptr, length);\n      buffer[length] = 0;\n      begin_ptr = end_ptr;\n    }\n\n    ptr = strchr(buffer, '[');\n    if (ptr) {\n      ptr2 = strchr(ptr+1, ']');\n    }\n    if (ptr && ptr2) {\n      // [IPv6]:port\n      ptr = strchr(ptr2+1, ':');\n    } else {\n      // IPv4:port or name:port\n      ptr = strchr(buffer, ':');\n    }\n    in_port_t port = 0;\n    if (ptr) {\n      ptr[0] = 0;\n\n      ptr++;\n\n      errno = 0;\n      port = (in_port_t) strtoul(ptr, (char **) NULL, 10);\n      if (errno) {\n        memcached_server_free(servers);\n        return NULL;\n      }\n\n      ptr2 = strchr(ptr, ' ');\n      if (!ptr2)\n        ptr2 = strchr(ptr, ':');\n\n      if (ptr2) {\n        ptr2++;\n        errno = 0;\n        weight = uint32_t(strtoul(ptr2, (char **) NULL, 10));\n        if (errno) {\n          memcached_server_free(servers);\n          return NULL;\n        }\n      }\n    }\n\n    servers = memcached_server_list_append_with_weight(servers, buffer, port, weight, &rc);\n\n    if (isspace(*begin_ptr)) {\n      begin_ptr++;\n    }\n  }\n\n  return servers;\n}"
  }
]