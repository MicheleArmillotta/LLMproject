[
  {
    "function_name": "memcached_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/flush.cc",
    "lines": "104-122",
    "snippet": "memcached_return_t memcached_flush(memcached_st *shell, time_t expiration) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  LIBMEMCACHED_MEMCACHED_FLUSH_START();\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_flush_binary(ptr, expiration, reply);\n  } else {\n    rc = memcached_flush_textual(ptr, expiration, reply);\n  }\n  LIBMEMCACHED_MEMCACHED_FLUSH_END();\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_FLUSH_END",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_flush_textual",
          "args": [
            "ptr",
            "expiration",
            "reply"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_flush_textual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/flush.cc",
          "lines": "62-102",
          "snippet": "static memcached_return_t memcached_flush_textual(Memcached *ptr, time_t expiration,\n                                                  const bool reply) {\n  char buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1 + 1];\n  int send_length = 0;\n  if (expiration) {\n    send_length = snprintf(buffer, sizeof(buffer), \"%lld\", (long long) expiration);\n  }\n\n  if (size_t(send_length) >= sizeof(buffer) or send_length < 0) {\n    return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"snprintf(MEMCACHED_DEFAULT_COMMAND_SIZE)\"));\n  }\n\n  memcached_return_t rc = MEMCACHED_SUCCESS;\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n    libmemcached_io_vector_st vector[] = {\n        {NULL, 0},\n        {memcached_literal_param(\"flush_all \")},\n        {buffer, size_t(send_length)},\n        {\" noreply\", reply ? 0 : memcached_literal_param_size(\" noreply\")},\n        {memcached_literal_param(\"\\r\\n\")}};\n\n    memcached_return_t rrc = memcached_vdo(instance, vector, 5, true);\n    if (memcached_success(rrc) and reply == true) {\n      char response_buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n      rrc = memcached_response(instance, response_buffer, sizeof(response_buffer), NULL);\n    }\n\n    if (memcached_failed(rrc)) {\n      // If an error has already been reported, then don't add to it\n      if (instance->error_messages == NULL or instance->root->error_messages == NULL) {\n        memcached_set_error(*instance, rrc, MEMCACHED_AT);\n      }\n      rc = MEMCACHED_SOME_ERRORS;\n    }\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t memcached_flush_textual(Memcached *ptr, time_t expiration,\n                                                  const bool reply) {\n  char buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1 + 1];\n  int send_length = 0;\n  if (expiration) {\n    send_length = snprintf(buffer, sizeof(buffer), \"%lld\", (long long) expiration);\n  }\n\n  if (size_t(send_length) >= sizeof(buffer) or send_length < 0) {\n    return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"snprintf(MEMCACHED_DEFAULT_COMMAND_SIZE)\"));\n  }\n\n  memcached_return_t rc = MEMCACHED_SUCCESS;\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n    libmemcached_io_vector_st vector[] = {\n        {NULL, 0},\n        {memcached_literal_param(\"flush_all \")},\n        {buffer, size_t(send_length)},\n        {\" noreply\", reply ? 0 : memcached_literal_param_size(\" noreply\")},\n        {memcached_literal_param(\"\\r\\n\")}};\n\n    memcached_return_t rrc = memcached_vdo(instance, vector, 5, true);\n    if (memcached_success(rrc) and reply == true) {\n      char response_buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n      rrc = memcached_response(instance, response_buffer, sizeof(response_buffer), NULL);\n    }\n\n    if (memcached_failed(rrc)) {\n      // If an error has already been reported, then don't add to it\n      if (instance->error_messages == NULL or instance->root->error_messages == NULL) {\n        memcached_set_error(*instance, rrc, MEMCACHED_AT);\n      }\n      rc = MEMCACHED_SOME_ERRORS;\n    }\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_flush_binary",
          "args": [
            "ptr",
            "expiration",
            "reply"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_flush_binary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/flush.cc",
          "lines": "18-60",
          "snippet": "static memcached_return_t memcached_flush_binary(Memcached *ptr, time_t expiration,\n                                                 const bool reply) {\n  protocol_binary_request_flush request = {};\n\n  request.message.header.request.opcode = PROTOCOL_BINARY_CMD_FLUSH;\n  request.message.header.request.extlen = 4;\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n  request.message.header.request.bodylen = htonl(request.message.header.request.extlen);\n  request.message.body.expiration = htonl((uint32_t) expiration);\n\n  memcached_return_t rc = MEMCACHED_SUCCESS;\n\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n    initialize_binary_request(instance, request.message.header);\n\n    if (reply) {\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_FLUSH;\n    } else {\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_FLUSHQ;\n    }\n\n    libmemcached_io_vector_st vector[] = {{NULL, 0}, {request.bytes, sizeof(request.bytes)}};\n\n    memcached_return_t rrc;\n    if (memcached_failed(rrc = memcached_vdo(instance, vector, 2, true))) {\n      if (instance->error_messages == NULL or instance->root->error_messages == NULL) {\n        memcached_set_error(*instance, rrc, MEMCACHED_AT);\n      }\n      rc = MEMCACHED_SOME_ERRORS;\n    }\n  }\n\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n    if (instance->response_count() > 0) {\n      (void) memcached_response(instance, NULL, 0, NULL);\n    }\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t memcached_flush_binary(Memcached *ptr, time_t expiration,\n                                                 const bool reply) {\n  protocol_binary_request_flush request = {};\n\n  request.message.header.request.opcode = PROTOCOL_BINARY_CMD_FLUSH;\n  request.message.header.request.extlen = 4;\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n  request.message.header.request.bodylen = htonl(request.message.header.request.extlen);\n  request.message.body.expiration = htonl((uint32_t) expiration);\n\n  memcached_return_t rc = MEMCACHED_SUCCESS;\n\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n    initialize_binary_request(instance, request.message.header);\n\n    if (reply) {\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_FLUSH;\n    } else {\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_FLUSHQ;\n    }\n\n    libmemcached_io_vector_st vector[] = {{NULL, 0}, {request.bytes, sizeof(request.bytes)}};\n\n    memcached_return_t rrc;\n    if (memcached_failed(rrc = memcached_vdo(instance, vector, 2, true))) {\n      if (instance->error_messages == NULL or instance->root->error_messages == NULL) {\n        memcached_set_error(*instance, rrc, MEMCACHED_AT);\n      }\n      rc = MEMCACHED_SOME_ERRORS;\n    }\n  }\n\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n    if (instance->response_count() > 0) {\n      (void) memcached_response(instance, NULL, 0, NULL);\n    }\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_binary",
          "args": [
            "ptr"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_FLUSH_START",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_replying",
          "args": [
            "ptr"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = initialize_query(ptr, true)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_query",
          "args": [
            "ptr",
            "true"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/initialize_query.cc",
          "lines": "18-39",
          "snippet": "memcached_return_t initialize_query(Memcached *self, bool increment_query_id) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (increment_query_id) {\n    self->query_id++;\n  }\n\n  if (self->state.is_time_for_rebuild) {\n    memcached_reset(self);\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return memcached_set_error(*self, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  memcached_error_free(*self);\n  memcached_result_reset(&self->result);\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t initialize_query(Memcached *self, bool increment_query_id) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (increment_query_id) {\n    self->query_id++;\n  }\n\n  if (self->state.is_time_for_rebuild) {\n    memcached_reset(self);\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return memcached_set_error(*self, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  memcached_error_free(*self);\n  memcached_result_reset(&self->result);\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_flush(memcached_st *shell, time_t expiration) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  LIBMEMCACHED_MEMCACHED_FLUSH_START();\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_flush_binary(ptr, expiration, reply);\n  } else {\n    rc = memcached_flush_textual(ptr, expiration, reply);\n  }\n  LIBMEMCACHED_MEMCACHED_FLUSH_END();\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_flush_textual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/flush.cc",
    "lines": "62-102",
    "snippet": "static memcached_return_t memcached_flush_textual(Memcached *ptr, time_t expiration,\n                                                  const bool reply) {\n  char buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1 + 1];\n  int send_length = 0;\n  if (expiration) {\n    send_length = snprintf(buffer, sizeof(buffer), \"%lld\", (long long) expiration);\n  }\n\n  if (size_t(send_length) >= sizeof(buffer) or send_length < 0) {\n    return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"snprintf(MEMCACHED_DEFAULT_COMMAND_SIZE)\"));\n  }\n\n  memcached_return_t rc = MEMCACHED_SUCCESS;\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n    libmemcached_io_vector_st vector[] = {\n        {NULL, 0},\n        {memcached_literal_param(\"flush_all \")},\n        {buffer, size_t(send_length)},\n        {\" noreply\", reply ? 0 : memcached_literal_param_size(\" noreply\")},\n        {memcached_literal_param(\"\\r\\n\")}};\n\n    memcached_return_t rrc = memcached_vdo(instance, vector, 5, true);\n    if (memcached_success(rrc) and reply == true) {\n      char response_buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n      rrc = memcached_response(instance, response_buffer, sizeof(response_buffer), NULL);\n    }\n\n    if (memcached_failed(rrc)) {\n      // If an error has already been reported, then don't add to it\n      if (instance->error_messages == NULL or instance->root->error_messages == NULL) {\n        memcached_set_error(*instance, rrc, MEMCACHED_AT);\n      }\n      rc = MEMCACHED_SOME_ERRORS;\n    }\n  }\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*instance",
            "rrc",
            "MEMCACHED_AT"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rrc"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_response",
          "args": [
            "instance",
            "response_buffer",
            "sizeof(response_buffer)",
            "NULL"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
          "lines": "789-834",
          "snippet": "memcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rrc"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_vdo",
          "args": [
            "instance",
            "vector",
            "5",
            "true"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_vdo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/do.cc",
          "lines": "64-100",
          "snippet": "memcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"\\r\\n\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param_size",
          "args": [
            "\" noreply\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "send_length"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"flush_all \""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "ptr",
            "x"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "ptr"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"snprintf(MEMCACHED_DEFAULT_COMMAND_SIZE)\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "send_length"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"%lld\"",
            "(long long) expiration"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t memcached_flush_textual(Memcached *ptr, time_t expiration,\n                                                  const bool reply) {\n  char buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1 + 1];\n  int send_length = 0;\n  if (expiration) {\n    send_length = snprintf(buffer, sizeof(buffer), \"%lld\", (long long) expiration);\n  }\n\n  if (size_t(send_length) >= sizeof(buffer) or send_length < 0) {\n    return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"snprintf(MEMCACHED_DEFAULT_COMMAND_SIZE)\"));\n  }\n\n  memcached_return_t rc = MEMCACHED_SUCCESS;\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n    libmemcached_io_vector_st vector[] = {\n        {NULL, 0},\n        {memcached_literal_param(\"flush_all \")},\n        {buffer, size_t(send_length)},\n        {\" noreply\", reply ? 0 : memcached_literal_param_size(\" noreply\")},\n        {memcached_literal_param(\"\\r\\n\")}};\n\n    memcached_return_t rrc = memcached_vdo(instance, vector, 5, true);\n    if (memcached_success(rrc) and reply == true) {\n      char response_buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n      rrc = memcached_response(instance, response_buffer, sizeof(response_buffer), NULL);\n    }\n\n    if (memcached_failed(rrc)) {\n      // If an error has already been reported, then don't add to it\n      if (instance->error_messages == NULL or instance->root->error_messages == NULL) {\n        memcached_set_error(*instance, rrc, MEMCACHED_AT);\n      }\n      rc = MEMCACHED_SOME_ERRORS;\n    }\n  }\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_flush_binary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/flush.cc",
    "lines": "18-60",
    "snippet": "static memcached_return_t memcached_flush_binary(Memcached *ptr, time_t expiration,\n                                                 const bool reply) {\n  protocol_binary_request_flush request = {};\n\n  request.message.header.request.opcode = PROTOCOL_BINARY_CMD_FLUSH;\n  request.message.header.request.extlen = 4;\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n  request.message.header.request.bodylen = htonl(request.message.header.request.extlen);\n  request.message.body.expiration = htonl((uint32_t) expiration);\n\n  memcached_return_t rc = MEMCACHED_SUCCESS;\n\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n    initialize_binary_request(instance, request.message.header);\n\n    if (reply) {\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_FLUSH;\n    } else {\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_FLUSHQ;\n    }\n\n    libmemcached_io_vector_st vector[] = {{NULL, 0}, {request.bytes, sizeof(request.bytes)}};\n\n    memcached_return_t rrc;\n    if (memcached_failed(rrc = memcached_vdo(instance, vector, 2, true))) {\n      if (instance->error_messages == NULL or instance->root->error_messages == NULL) {\n        memcached_set_error(*instance, rrc, MEMCACHED_AT);\n      }\n      rc = MEMCACHED_SOME_ERRORS;\n    }\n  }\n\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n    if (instance->response_count() > 0) {\n      (void) memcached_response(instance, NULL, 0, NULL);\n    }\n  }\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_response",
          "args": [
            "instance",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
          "lines": "789-834",
          "snippet": "memcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "instance->response_count",
          "args": [],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "response_count",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.hpp",
          "lines": "62-62",
          "snippet": "uint32_t response_count() const { return cursor_active_; }",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#    include <netdb.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "memcached_return_t memcached_instance_push(memcached_st *ptr, const memcached_instance_st *,\n                                           uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#    include <netdb.h>\n\nmemcached_return_t memcached_instance_push(memcached_st *ptr, const memcached_instance_st *,\n                                           uint32_t);\n\nmemcached_instance_st {\n  uint32_t response_count() const { return cursor_active_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "ptr",
            "x"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "ptr"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*instance",
            "rrc",
            "MEMCACHED_AT"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rrc = memcached_vdo(instance, vector, 2, true)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_vdo",
          "args": [
            "instance",
            "vector",
            "2",
            "true"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_vdo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/do.cc",
          "lines": "64-100",
          "snippet": "memcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_binary_request",
          "args": [
            "instance",
            "request.message.header"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_binary_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "20-25",
          "snippet": "void initialize_binary_request(memcached_instance_st *server,\n                               protocol_binary_request_header &header) {\n  server->request_id++;\n  header.request.magic = PROTOCOL_BINARY_REQ;\n  header.request.opaque = htons(server->request_id);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid initialize_binary_request(memcached_instance_st *server,\n                               protocol_binary_request_header &header) {\n  server->request_id++;\n  header.request.magic = PROTOCOL_BINARY_REQ;\n  header.request.opaque = htons(server->request_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "ptr",
            "x"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(uint32_t) expiration"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_htonll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "55-61",
          "snippet": "uint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t memcached_flush_binary(Memcached *ptr, time_t expiration,\n                                                 const bool reply) {\n  protocol_binary_request_flush request = {};\n\n  request.message.header.request.opcode = PROTOCOL_BINARY_CMD_FLUSH;\n  request.message.header.request.extlen = 4;\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n  request.message.header.request.bodylen = htonl(request.message.header.request.extlen);\n  request.message.body.expiration = htonl((uint32_t) expiration);\n\n  memcached_return_t rc = MEMCACHED_SUCCESS;\n\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n    initialize_binary_request(instance, request.message.header);\n\n    if (reply) {\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_FLUSH;\n    } else {\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_FLUSHQ;\n    }\n\n    libmemcached_io_vector_st vector[] = {{NULL, 0}, {request.bytes, sizeof(request.bytes)}};\n\n    memcached_return_t rrc;\n    if (memcached_failed(rrc = memcached_vdo(instance, vector, 2, true))) {\n      if (instance->error_messages == NULL or instance->root->error_messages == NULL) {\n        memcached_set_error(*instance, rrc, MEMCACHED_AT);\n      }\n      rc = MEMCACHED_SOME_ERRORS;\n    }\n  }\n\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n    if (instance->response_count() > 0) {\n      (void) memcached_response(instance, NULL, 0, NULL);\n    }\n  }\n\n  return rc;\n}"
  }
]