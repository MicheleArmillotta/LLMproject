[
  {
    "function_name": "hashkit_murmur",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/murmur.cc",
    "lines": "87-89",
    "snippet": "uint32_t hashkit_murmur(const char *, size_t, void *) {\n  return 0;\n}",
    "includes": [
      "#  include <cstring>",
      "#    include BYTESWAP_HEADER",
      "#include \"libhashkit/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#  include <cstring>\n#    include BYTESWAP_HEADER\n#include \"libhashkit/common.h\"\n\nuint32_t hashkit_murmur(const char *, size_t, void *) {\n  return 0;\n}"
  },
  {
    "function_name": "hashkit_murmur",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/murmur.cc",
    "lines": "26-84",
    "snippet": "uint32_t hashkit_murmur(const char *key, size_t length, void *context) {\n  /*\n    'm' and 'r' are mixing constants generated offline.  They're not\n    really 'magic', they just happen to work well.\n  */\n\n  const unsigned int m = 0x5bd1e995;\n  const uint32_t seed = (0xdeadbeef * (uint32_t) length);\n  const int r = 24;\n\n  // Initialize the hash to a 'random' value\n\n  uint32_t h = seed ^ (uint32_t) length;\n\n  // Mix 4 bytes at a time into the hash\n\n  const unsigned char *data = (const unsigned char *) key;\n  (void) context;\n\n  while (length >= 4) {\n    uint32_t k;\n    memcpy(&k, data, sizeof(k));\n#  if WORDS_BIGENDIAN\n    k = BYTESWAP_32(k);\n#  endif\n\n    k *= m;\n    k ^= k >> r;\n    k *= m;\n\n    h *= m;\n    h ^= k;\n\n    data += 4;\n    length -= 4;\n  }\n\n  // Handle the last few bytes of the input array\n  if (length) {\n    uint32_t k = 0;\n    memcpy(&k, data, length);\n#  if WORDS_BIGENDIAN\n    k = BYTESWAP_32(k);\n#  endif\n    h ^= k;\n    h *= m;\n  }\n\n  /*\n    Do a few final mixes of the hash to ensure the last few bytes are\n    well-incorporated.\n  */\n\n  h ^= h >> 13;\n  h *= m;\n  h ^= h >> 15;\n\n  return h;\n}",
    "includes": [
      "#  include <cstring>",
      "#    include BYTESWAP_HEADER",
      "#include \"libhashkit/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BYTESWAP_32",
          "args": [
            "k"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&k",
            "data",
            "length"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BYTESWAP_32",
          "args": [
            "k"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&k",
            "data",
            "sizeof(k)"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <cstring>\n#    include BYTESWAP_HEADER\n#include \"libhashkit/common.h\"\n\nuint32_t hashkit_murmur(const char *key, size_t length, void *context) {\n  /*\n    'm' and 'r' are mixing constants generated offline.  They're not\n    really 'magic', they just happen to work well.\n  */\n\n  const unsigned int m = 0x5bd1e995;\n  const uint32_t seed = (0xdeadbeef * (uint32_t) length);\n  const int r = 24;\n\n  // Initialize the hash to a 'random' value\n\n  uint32_t h = seed ^ (uint32_t) length;\n\n  // Mix 4 bytes at a time into the hash\n\n  const unsigned char *data = (const unsigned char *) key;\n  (void) context;\n\n  while (length >= 4) {\n    uint32_t k;\n    memcpy(&k, data, sizeof(k));\n#  if WORDS_BIGENDIAN\n    k = BYTESWAP_32(k);\n#  endif\n\n    k *= m;\n    k ^= k >> r;\n    k *= m;\n\n    h *= m;\n    h ^= k;\n\n    data += 4;\n    length -= 4;\n  }\n\n  // Handle the last few bytes of the input array\n  if (length) {\n    uint32_t k = 0;\n    memcpy(&k, data, length);\n#  if WORDS_BIGENDIAN\n    k = BYTESWAP_32(k);\n#  endif\n    h ^= k;\n    h *= m;\n  }\n\n  /*\n    Do a few final mixes of the hash to ensure the last few bytes are\n    well-incorporated.\n  */\n\n  h ^= h >> 13;\n  h *= m;\n  h ^= h >> 15;\n\n  return h;\n}"
  }
]