[
  {
    "function_name": "memcached_callback_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/callback.cc",
    "lines": "23-86",
    "snippet": "memcached_return_t memcached_callback_set(memcached_st *shell, const memcached_callback_t flag,\n                                          const void *data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    switch (flag) {\n    case MEMCACHED_CALLBACK_PREFIX_KEY: {\n      return memcached_set_namespace(*ptr, (char *) data, data ? strlen((char *) data) : 0);\n    }\n\n    case MEMCACHED_CALLBACK_USER_DATA: {\n      ptr->user_data = const_cast<void *>(data);\n      break;\n    }\n\n    case MEMCACHED_CALLBACK_CLEANUP_FUNCTION: {\n      memcached_cleanup_fn func = *(memcached_cleanup_fn *) &data;\n      ptr->on_cleanup = func;\n      break;\n    }\n\n    case MEMCACHED_CALLBACK_CLONE_FUNCTION: {\n      memcached_clone_fn func = *(memcached_clone_fn *) &data;\n      ptr->on_clone = func;\n      break;\n    }\n\n    case MEMCACHED_CALLBACK_GET_FAILURE: {\n      memcached_trigger_key_fn func = *(memcached_trigger_key_fn *) &data;\n      ptr->get_key_failure = func;\n      break;\n    }\n\n    case MEMCACHED_CALLBACK_DELETE_TRIGGER: {\n      if (data) // NULL would mean we are disabling.\n      {\n        if (memcached_behavior_get(ptr, MEMCACHED_BEHAVIOR_BUFFER_REQUESTS)) {\n          return memcached_set_error(\n              *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n              memcached_literal_param(\"Delete triggers cannot be used if buffering is enabled\"));\n        }\n\n        if (memcached_behavior_get(ptr, MEMCACHED_BEHAVIOR_NOREPLY)) {\n          return memcached_set_error(\n              *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n              memcached_literal_param(\n                  \"Delete triggers cannot be used if MEMCACHED_BEHAVIOR_NOREPLY is set\"));\n        }\n      }\n\n      memcached_trigger_delete_key_fn func = *(memcached_trigger_delete_key_fn *) &data;\n      ptr->delete_trigger = func;\n      break;\n    }\n\n    case MEMCACHED_CALLBACK_MAX:\n      return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                                 memcached_literal_param(\"Invalid callback supplied\"));\n    }\n\n    return MEMCACHED_SUCCESS;\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "MEMCACHED_INVALID_ARGUMENTS",
            "MEMCACHED_AT",
            "memcached_literal_param(\"Invalid callback supplied\")"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Invalid callback supplied\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Delete triggers cannot be used if MEMCACHED_BEHAVIOR_NOREPLY is set\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_behavior_get",
          "args": [
            "ptr",
            "MEMCACHED_BEHAVIOR_NOREPLY"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_behavior_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "288-482",
          "snippet": "uint64_t memcached_behavior_get(memcached_st *shell, const memcached_behavior_t flag) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    return ptr->number_of_replicas;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    return ptr->io_msg_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    return ptr->io_bytes_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    return ptr->io_key_prefetch;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    return ptr->flags.binary_protocol;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    return ptr->flags.support_cas;\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return true;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    return ptr->flags.no_block;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    return ptr->flags.buffer_requests;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    return memcached_is_udp(ptr);\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    return ptr->flags.tcp_nodelay;\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    return ptr->flags.verify_key;\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED:\n    if (memcached_is_consistent_distribution(ptr)) {\n      return memcached_is_weighted_ketama(ptr);\n    }\n    return false;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return ptr->distribution;\n\n  case MEMCACHED_BEHAVIOR_KETAMA:\n    return memcached_is_consistent_distribution(ptr);\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return hashkit_get_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return hashkit_get_distribution_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    return ptr->server_failure_limit;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    return ptr->server_timeout_limit;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS:\n    return ptr->flags.use_sort_hosts;\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    return (uint64_t) ptr->poll_timeout;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    return (uint64_t) ptr->connect_timeout;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    return (uint64_t) ptr->retry_timeout;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    return uint64_t(ptr->dead_timeout);\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    return (uint64_t) ptr->snd_timeout;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    return (uint64_t) ptr->rcv_timeout;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    return (uint64_t) ptr->tcp_keepidle;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->send_size != -1) // If value is -1 then we are using the default\n    {\n      return (uint64_t) ptr->send_size;\n    }\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    if (instance) // If we have an instance we test, otherwise we just set and pray\n    {\n      /* REFACTOR */\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_SNDBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->recv_size != -1) // If value is -1 then we are using the default\n      return (uint64_t) ptr->recv_size;\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    /**\n      @note REFACTOR\n    */\n    if (instance) {\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_RCVBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                        memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n    return 0;\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    return ptr->flags.hash_with_namespace;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    return ptr->flags.reply ? false : true;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    return ptr->flags.randomize_replica_read;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n#ifdef HAVE_MSG_MORE\n    return true;\n#else\n    return false;\n#endif\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    return ptr->flags.tcp_keepalive;\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return bool(memcached_parse_filename(ptr));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_get()\");\n    return 0;\n  }\n\n  /* NOTREACHED */\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nuint64_t memcached_behavior_get(memcached_st *shell, const memcached_behavior_t flag) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    return ptr->number_of_replicas;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    return ptr->io_msg_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    return ptr->io_bytes_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    return ptr->io_key_prefetch;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    return ptr->flags.binary_protocol;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    return ptr->flags.support_cas;\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return true;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    return ptr->flags.no_block;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    return ptr->flags.buffer_requests;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    return memcached_is_udp(ptr);\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    return ptr->flags.tcp_nodelay;\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    return ptr->flags.verify_key;\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED:\n    if (memcached_is_consistent_distribution(ptr)) {\n      return memcached_is_weighted_ketama(ptr);\n    }\n    return false;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return ptr->distribution;\n\n  case MEMCACHED_BEHAVIOR_KETAMA:\n    return memcached_is_consistent_distribution(ptr);\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return hashkit_get_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return hashkit_get_distribution_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    return ptr->server_failure_limit;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    return ptr->server_timeout_limit;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS:\n    return ptr->flags.use_sort_hosts;\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    return (uint64_t) ptr->poll_timeout;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    return (uint64_t) ptr->connect_timeout;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    return (uint64_t) ptr->retry_timeout;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    return uint64_t(ptr->dead_timeout);\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    return (uint64_t) ptr->snd_timeout;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    return (uint64_t) ptr->rcv_timeout;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    return (uint64_t) ptr->tcp_keepidle;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->send_size != -1) // If value is -1 then we are using the default\n    {\n      return (uint64_t) ptr->send_size;\n    }\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    if (instance) // If we have an instance we test, otherwise we just set and pray\n    {\n      /* REFACTOR */\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_SNDBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->recv_size != -1) // If value is -1 then we are using the default\n      return (uint64_t) ptr->recv_size;\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    /**\n      @note REFACTOR\n    */\n    if (instance) {\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_RCVBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                        memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n    return 0;\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    return ptr->flags.hash_with_namespace;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    return ptr->flags.reply ? false : true;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    return ptr->flags.randomize_replica_read;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n#ifdef HAVE_MSG_MORE\n    return true;\n#else\n    return false;\n#endif\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    return ptr->flags.tcp_keepalive;\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return bool(memcached_parse_filename(ptr));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_get()\");\n    return 0;\n  }\n\n  /* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Delete triggers cannot be used if buffering is enabled\""
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "const_cast<void *>",
          "args": [
            "data"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_namespace",
          "args": [
            "*ptr",
            "(char *) data",
            "data ? strlen((char *) data) : 0"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/namespace.cc",
          "lines": "19-56",
          "snippet": "memcached_return_t memcached_set_namespace(Memcached &memc, const char *key, size_t key_length) {\n  if (key and key_length == 0) {\n    WATCHPOINT_ASSERT(key_length);\n    return memcached_set_error(\n        memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid namespace, namespace string had value but length was 0\"));\n  } else if (key_length and key == NULL) {\n    WATCHPOINT_ASSERT(key);\n    return memcached_set_error(\n        memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"Invalid namespace, namespace string length was > 1 but namespace string was null \"));\n  } else if (key and key_length) {\n    bool orig = memc.flags.verify_key;\n    memc.flags.verify_key = true;\n    if (memcached_failed(memcached_key_test(memc, (const char **) &key, &key_length, 1))) {\n      memc.flags.verify_key = orig;\n      return memcached_last_error(&memc);\n    }\n    memc.flags.verify_key = orig;\n\n    if ((key_length > MEMCACHED_MAX_NAMESPACE - 1)) {\n      return memcached_set_error(memc, MEMCACHED_KEY_TOO_BIG, MEMCACHED_AT);\n    }\n\n    memcached_array_free(memc._namespace);\n    memc._namespace = memcached_strcpy(&memc, key, key_length);\n\n    if (memc._namespace == NULL) {\n      return memcached_set_error(memc, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n    }\n  } else {\n    memcached_array_free(memc._namespace);\n    memc._namespace = NULL;\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_namespace(Memcached &memc, const char *key, size_t key_length) {\n  if (key and key_length == 0) {\n    WATCHPOINT_ASSERT(key_length);\n    return memcached_set_error(\n        memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid namespace, namespace string had value but length was 0\"));\n  } else if (key_length and key == NULL) {\n    WATCHPOINT_ASSERT(key);\n    return memcached_set_error(\n        memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"Invalid namespace, namespace string length was > 1 but namespace string was null \"));\n  } else if (key and key_length) {\n    bool orig = memc.flags.verify_key;\n    memc.flags.verify_key = true;\n    if (memcached_failed(memcached_key_test(memc, (const char **) &key, &key_length, 1))) {\n      memc.flags.verify_key = orig;\n      return memcached_last_error(&memc);\n    }\n    memc.flags.verify_key = orig;\n\n    if ((key_length > MEMCACHED_MAX_NAMESPACE - 1)) {\n      return memcached_set_error(memc, MEMCACHED_KEY_TOO_BIG, MEMCACHED_AT);\n    }\n\n    memcached_array_free(memc._namespace);\n    memc._namespace = memcached_strcpy(&memc, key, key_length);\n\n    if (memc._namespace == NULL) {\n      return memcached_set_error(memc, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n    }\n  } else {\n    memcached_array_free(memc._namespace);\n    memc._namespace = NULL;\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "(char *) data"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_callback_set(memcached_st *shell, const memcached_callback_t flag,\n                                          const void *data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    switch (flag) {\n    case MEMCACHED_CALLBACK_PREFIX_KEY: {\n      return memcached_set_namespace(*ptr, (char *) data, data ? strlen((char *) data) : 0);\n    }\n\n    case MEMCACHED_CALLBACK_USER_DATA: {\n      ptr->user_data = const_cast<void *>(data);\n      break;\n    }\n\n    case MEMCACHED_CALLBACK_CLEANUP_FUNCTION: {\n      memcached_cleanup_fn func = *(memcached_cleanup_fn *) &data;\n      ptr->on_cleanup = func;\n      break;\n    }\n\n    case MEMCACHED_CALLBACK_CLONE_FUNCTION: {\n      memcached_clone_fn func = *(memcached_clone_fn *) &data;\n      ptr->on_clone = func;\n      break;\n    }\n\n    case MEMCACHED_CALLBACK_GET_FAILURE: {\n      memcached_trigger_key_fn func = *(memcached_trigger_key_fn *) &data;\n      ptr->get_key_failure = func;\n      break;\n    }\n\n    case MEMCACHED_CALLBACK_DELETE_TRIGGER: {\n      if (data) // NULL would mean we are disabling.\n      {\n        if (memcached_behavior_get(ptr, MEMCACHED_BEHAVIOR_BUFFER_REQUESTS)) {\n          return memcached_set_error(\n              *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n              memcached_literal_param(\"Delete triggers cannot be used if buffering is enabled\"));\n        }\n\n        if (memcached_behavior_get(ptr, MEMCACHED_BEHAVIOR_NOREPLY)) {\n          return memcached_set_error(\n              *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n              memcached_literal_param(\n                  \"Delete triggers cannot be used if MEMCACHED_BEHAVIOR_NOREPLY is set\"));\n        }\n      }\n\n      memcached_trigger_delete_key_fn func = *(memcached_trigger_delete_key_fn *) &data;\n      ptr->delete_trigger = func;\n      break;\n    }\n\n    case MEMCACHED_CALLBACK_MAX:\n      return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                                 memcached_literal_param(\"Invalid callback supplied\"));\n    }\n\n    return MEMCACHED_SUCCESS;\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
  }
]