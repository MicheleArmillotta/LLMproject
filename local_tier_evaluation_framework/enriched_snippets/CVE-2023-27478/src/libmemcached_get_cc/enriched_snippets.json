[
  {
    "function_name": "binary_mget_by_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/get.cc",
    "lines": "547-583",
    "snippet": "static memcached_return_t binary_mget_by_key(memcached_st *ptr, const uint32_t master_server_key,\n                                             bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode) {\n  if (ptr->number_of_replicas == 0) {\n    return simple_binary_mget(ptr, master_server_key, is_group_key_set, keys, key_length,\n                              number_of_keys, mget_mode);\n  }\n\n  uint32_t *hash = libmemcached_xvalloc(ptr, number_of_keys, uint32_t);\n  bool *dead_servers = libmemcached_xcalloc(ptr, memcached_server_count(ptr), bool);\n\n  if (hash == NULL or dead_servers == NULL) {\n    libmemcached_free(ptr, hash);\n    libmemcached_free(ptr, dead_servers);\n    return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n  }\n\n  if (is_group_key_set) {\n    for (size_t x = 0; x < number_of_keys; x++) {\n      hash[x] = master_server_key;\n    }\n  } else {\n    for (size_t x = 0; x < number_of_keys; x++) {\n      hash[x] = memcached_generate_hash_with_redistribution(ptr, keys[x], key_length[x]);\n    }\n  }\n\n  memcached_return_t rc =\n      replication_binary_mget(ptr, hash, dead_servers, keys, key_length, number_of_keys);\n\n  WATCHPOINT_IFERROR(rc);\n  libmemcached_free(ptr, hash);\n  libmemcached_free(ptr, dead_servers);\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_return_t mget_by_key_real(memcached_st *ptr, const char *group_key,\n                                             size_t group_key_length, const char *const *keys,\n                                             const size_t *key_length, size_t number_of_keys,\n                                             const bool mget_mode);",
      "static memcached_return_t binary_mget_by_key(memcached_st *ptr, const uint32_t master_server_key,\n                                             const bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "libmemcached_free",
          "args": [
            "ptr",
            "dead_servers"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "libmemcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memory.h",
          "lines": "30-40",
          "snippet": "static inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#  include <stddef.h>",
            "#  include <cstdlib>",
            "#  include <cstddef>",
            "#include \"libmemcached/common.h\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#  include <stddef.h>\n#  include <cstdlib>\n#  include <cstddef>\n#include \"libmemcached/common.h\"\n#include \"mem_config.h\"\n\nstatic inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_IFERROR",
          "args": [
            "rc"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replication_binary_mget",
          "args": [
            "ptr",
            "hash",
            "dead_servers",
            "keys",
            "key_length",
            "number_of_keys"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "replication_binary_mget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/get.cc",
          "lines": "455-545",
          "snippet": "static memcached_return_t replication_binary_mget(memcached_st *ptr, uint32_t *hash,\n                                                  bool *dead_servers, const char *const *keys,\n                                                  const size_t *key_length,\n                                                  const size_t number_of_keys) {\n  memcached_return_t rc = MEMCACHED_NOTFOUND;\n  uint32_t start = 0;\n  uint64_t randomize_read = memcached_behavior_get(ptr, MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ);\n\n  if (randomize_read) {\n    start = (uint32_t) random() % (uint32_t)(ptr->number_of_replicas + 1);\n  }\n\n  /* Loop for each replica */\n  for (uint32_t replica = 0; replica <= ptr->number_of_replicas; ++replica) {\n    bool success = true;\n\n    for (uint32_t x = 0; x < number_of_keys; ++x) {\n      if (hash[x] == memcached_server_count(ptr)) {\n        continue; /* Already successfully sent */\n      }\n\n      uint32_t server = hash[x] + replica;\n\n      /* In case of randomized reads */\n      if (randomize_read and ((server + start) <= (hash[x] + ptr->number_of_replicas))) {\n        server += start;\n      }\n\n      while (server >= memcached_server_count(ptr)) {\n        server -= memcached_server_count(ptr);\n      }\n\n      if (dead_servers[server]) {\n        continue;\n      }\n\n      memcached_instance_st *instance = memcached_instance_fetch(ptr, server);\n\n      if (instance->response_count() == 0) {\n        rc = memcached_connect(instance);\n\n        if (memcached_failed(rc)) {\n          memcached_io_reset(instance);\n          dead_servers[server] = true;\n          success = false;\n          continue;\n        }\n      }\n\n      protocol_binary_request_getk request = {};\n      initialize_binary_request(instance, request.message.header);\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_GETK;\n      request.message.header.request.keylen =\n          htons((uint16_t)(key_length[x] + memcached_array_size(ptr->_namespace)));\n      request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n      request.message.header.request.bodylen =\n          htonl((uint32_t)(key_length[x] + memcached_array_size(ptr->_namespace)));\n\n      /*\n       * We need to disable buffering to actually know that the request was\n       * successfully sent to the server (so that we should expect a result\n       * back). It would be nice to do this in buffered mode, but then it\n       * would be complex to handle all error situations if we got to send\n       * some of the messages, and then we failed on writing out some others\n       * and we used the callback interface from memcached_mget_execute so\n       * that we might have processed some of the responses etc. For now,\n       * just make sure we work _correctly_\n       */\n      libmemcached_io_vector_st vector[] = {\n          {request.bytes, sizeof(request.bytes)},\n          {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n          {keys[x], key_length[x]}};\n\n      if (memcached_io_writev(instance, vector, 3, true) == false) {\n        memcached_io_reset(instance);\n        dead_servers[server] = true;\n        success = false;\n        continue;\n      }\n\n      memcached_server_response_increment(instance);\n      hash[x] = memcached_server_count(ptr);\n    }\n\n    if (success) {\n      break;\n    }\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t replication_binary_mget(memcached_st *ptr, uint32_t *hash,\n                                                  bool *dead_servers, const char *const *keys,\n                                                  const size_t *key_length,\n                                                  const size_t number_of_keys) {\n  memcached_return_t rc = MEMCACHED_NOTFOUND;\n  uint32_t start = 0;\n  uint64_t randomize_read = memcached_behavior_get(ptr, MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ);\n\n  if (randomize_read) {\n    start = (uint32_t) random() % (uint32_t)(ptr->number_of_replicas + 1);\n  }\n\n  /* Loop for each replica */\n  for (uint32_t replica = 0; replica <= ptr->number_of_replicas; ++replica) {\n    bool success = true;\n\n    for (uint32_t x = 0; x < number_of_keys; ++x) {\n      if (hash[x] == memcached_server_count(ptr)) {\n        continue; /* Already successfully sent */\n      }\n\n      uint32_t server = hash[x] + replica;\n\n      /* In case of randomized reads */\n      if (randomize_read and ((server + start) <= (hash[x] + ptr->number_of_replicas))) {\n        server += start;\n      }\n\n      while (server >= memcached_server_count(ptr)) {\n        server -= memcached_server_count(ptr);\n      }\n\n      if (dead_servers[server]) {\n        continue;\n      }\n\n      memcached_instance_st *instance = memcached_instance_fetch(ptr, server);\n\n      if (instance->response_count() == 0) {\n        rc = memcached_connect(instance);\n\n        if (memcached_failed(rc)) {\n          memcached_io_reset(instance);\n          dead_servers[server] = true;\n          success = false;\n          continue;\n        }\n      }\n\n      protocol_binary_request_getk request = {};\n      initialize_binary_request(instance, request.message.header);\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_GETK;\n      request.message.header.request.keylen =\n          htons((uint16_t)(key_length[x] + memcached_array_size(ptr->_namespace)));\n      request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n      request.message.header.request.bodylen =\n          htonl((uint32_t)(key_length[x] + memcached_array_size(ptr->_namespace)));\n\n      /*\n       * We need to disable buffering to actually know that the request was\n       * successfully sent to the server (so that we should expect a result\n       * back). It would be nice to do this in buffered mode, but then it\n       * would be complex to handle all error situations if we got to send\n       * some of the messages, and then we failed on writing out some others\n       * and we used the callback interface from memcached_mget_execute so\n       * that we might have processed some of the responses etc. For now,\n       * just make sure we work _correctly_\n       */\n      libmemcached_io_vector_st vector[] = {\n          {request.bytes, sizeof(request.bytes)},\n          {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n          {keys[x], key_length[x]}};\n\n      if (memcached_io_writev(instance, vector, 3, true) == false) {\n        memcached_io_reset(instance);\n        dead_servers[server] = true;\n        success = false;\n        continue;\n      }\n\n      memcached_server_response_increment(instance);\n      hash[x] = memcached_server_count(ptr);\n    }\n\n    if (success) {\n      break;\n    }\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_generate_hash_with_redistribution",
          "args": [
            "ptr",
            "keys[x]",
            "key_length[x]"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_generate_hash_with_redistribution",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
          "lines": "109-116",
          "snippet": "uint32_t memcached_generate_hash_with_redistribution(memcached_st *ptr, const char *key,\n                                                     size_t key_length) {\n  uint32_t hash = _generate_hash_wrapper(ptr, key, key_length);\n\n  _regen_for_auto_eject(ptr);\n\n  return dispatch_host(ptr, hash);\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nuint32_t memcached_generate_hash_with_redistribution(memcached_st *ptr, const char *key,\n                                                     size_t key_length) {\n  uint32_t hash = _generate_hash_wrapper(ptr, key, key_length);\n\n  _regen_for_auto_eject(ptr);\n\n  return dispatch_host(ptr, hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libmemcached_xcalloc",
          "args": [
            "ptr",
            "memcached_server_count(ptr), bool"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "ptr"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libmemcached_xvalloc",
          "args": [
            "ptr",
            "number_of_keys, uint32_t"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_binary_mget",
          "args": [
            "ptr",
            "master_server_key",
            "is_group_key_set",
            "keys",
            "key_length",
            "number_of_keys",
            "mget_mode"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "simple_binary_mget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/get.cc",
          "lines": "343-453",
          "snippet": "static memcached_return_t simple_binary_mget(memcached_st *ptr, const uint32_t master_server_key,\n                                             bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode) {\n  memcached_return_t rc = MEMCACHED_NOTFOUND;\n\n  bool flush = (number_of_keys == 1);\n\n  if (memcached_failed(rc = memcached_key_test(*ptr, keys, key_length, number_of_keys))) {\n    return rc;\n  }\n\n  /*\n    If a server fails we warn about errors and start all over with sending keys\n    to the server.\n  */\n  for (uint32_t x = 0; x < number_of_keys; ++x) {\n    uint32_t server_key;\n\n    if (is_group_key_set) {\n      server_key = master_server_key;\n    } else {\n      server_key = memcached_generate_hash_with_redistribution(ptr, keys[x], key_length[x]);\n    }\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n    if (instance->response_count() == 0) {\n      rc = memcached_connect(instance);\n      if (memcached_failed(rc)) {\n        continue;\n      }\n    }\n\n    protocol_binary_request_getk request = {}; //= {.bytes= {0}};\n    initialize_binary_request(instance, request.message.header);\n    if (mget_mode) {\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_GETKQ;\n    } else {\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_GETK;\n    }\n\n#if 0\n    {\n      memcached_return_t vk= memcached_validate_key_length(key_length[x], ptr->flags.binary_protocol);\n      if (memcached_failed(rc= memcached_key_test(*memc, (const char **)&key, &key_length, 1)))\n      {\n        memcached_set_error(ptr, vk, MEMCACHED_AT, memcached_literal_param(\"Key was too long.\"));\n\n        if (x > 0)\n        {\n          memcached_io_reset(instance);\n        }\n\n        return vk;\n      }\n    }\n#endif\n\n    request.message.header.request.keylen =\n        htons((uint16_t)(key_length[x] + memcached_array_size(ptr->_namespace)));\n    request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n    request.message.header.request.bodylen =\n        htonl((uint32_t)(key_length[x] + memcached_array_size(ptr->_namespace)));\n\n    libmemcached_io_vector_st vector[] = {\n        {request.bytes, sizeof(request.bytes)},\n        {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n        {keys[x], key_length[x]}};\n\n    if (memcached_io_writev(instance, vector, 3, flush) == false) {\n      memcached_server_response_reset(instance);\n      rc = MEMCACHED_SOME_ERRORS;\n      continue;\n    }\n\n    /* We just want one pending response per server */\n    memcached_server_response_reset(instance);\n    memcached_server_response_increment(instance);\n    if ((x > 0 and x == ptr->io_key_prefetch) and memcached_flush_buffers(ptr) != MEMCACHED_SUCCESS)\n    {\n      rc = MEMCACHED_SOME_ERRORS;\n    }\n  }\n\n  if (mget_mode) {\n    /*\n      Send a noop command to flush the buffers\n    */\n    protocol_binary_request_noop request = {}; //= {.bytes= {0}};\n    request.message.header.request.opcode = PROTOCOL_BINARY_CMD_NOOP;\n    request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n\n    for (uint32_t x = 0; x < memcached_server_count(ptr); ++x) {\n      memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n      if (instance->response_count()) {\n        initialize_binary_request(instance, request.message.header);\n        if ((memcached_io_write(instance) == false)\n            or (memcached_io_write(instance, request.bytes, sizeof(request.bytes), true) == -1))\n        {\n          memcached_instance_response_reset(instance);\n          memcached_io_reset(instance);\n          rc = MEMCACHED_SOME_ERRORS;\n        }\n      }\n    }\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t mget_by_key_real(memcached_st *ptr, const char *group_key,\n                                             size_t group_key_length, const char *const *keys,\n                                             const size_t *key_length, size_t number_of_keys,\n                                             const bool mget_mode);",
            "static memcached_return_t binary_mget_by_key(memcached_st *ptr, const uint32_t master_server_key,\n                                             const bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t mget_by_key_real(memcached_st *ptr, const char *group_key,\n                                             size_t group_key_length, const char *const *keys,\n                                             const size_t *key_length, size_t number_of_keys,\n                                             const bool mget_mode);\nstatic memcached_return_t binary_mget_by_key(memcached_st *ptr, const uint32_t master_server_key,\n                                             const bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode);\n\nstatic memcached_return_t simple_binary_mget(memcached_st *ptr, const uint32_t master_server_key,\n                                             bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode) {\n  memcached_return_t rc = MEMCACHED_NOTFOUND;\n\n  bool flush = (number_of_keys == 1);\n\n  if (memcached_failed(rc = memcached_key_test(*ptr, keys, key_length, number_of_keys))) {\n    return rc;\n  }\n\n  /*\n    If a server fails we warn about errors and start all over with sending keys\n    to the server.\n  */\n  for (uint32_t x = 0; x < number_of_keys; ++x) {\n    uint32_t server_key;\n\n    if (is_group_key_set) {\n      server_key = master_server_key;\n    } else {\n      server_key = memcached_generate_hash_with_redistribution(ptr, keys[x], key_length[x]);\n    }\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n    if (instance->response_count() == 0) {\n      rc = memcached_connect(instance);\n      if (memcached_failed(rc)) {\n        continue;\n      }\n    }\n\n    protocol_binary_request_getk request = {}; //= {.bytes= {0}};\n    initialize_binary_request(instance, request.message.header);\n    if (mget_mode) {\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_GETKQ;\n    } else {\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_GETK;\n    }\n\n#if 0\n    {\n      memcached_return_t vk= memcached_validate_key_length(key_length[x], ptr->flags.binary_protocol);\n      if (memcached_failed(rc= memcached_key_test(*memc, (const char **)&key, &key_length, 1)))\n      {\n        memcached_set_error(ptr, vk, MEMCACHED_AT, memcached_literal_param(\"Key was too long.\"));\n\n        if (x > 0)\n        {\n          memcached_io_reset(instance);\n        }\n\n        return vk;\n      }\n    }\n#endif\n\n    request.message.header.request.keylen =\n        htons((uint16_t)(key_length[x] + memcached_array_size(ptr->_namespace)));\n    request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n    request.message.header.request.bodylen =\n        htonl((uint32_t)(key_length[x] + memcached_array_size(ptr->_namespace)));\n\n    libmemcached_io_vector_st vector[] = {\n        {request.bytes, sizeof(request.bytes)},\n        {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n        {keys[x], key_length[x]}};\n\n    if (memcached_io_writev(instance, vector, 3, flush) == false) {\n      memcached_server_response_reset(instance);\n      rc = MEMCACHED_SOME_ERRORS;\n      continue;\n    }\n\n    /* We just want one pending response per server */\n    memcached_server_response_reset(instance);\n    memcached_server_response_increment(instance);\n    if ((x > 0 and x == ptr->io_key_prefetch) and memcached_flush_buffers(ptr) != MEMCACHED_SUCCESS)\n    {\n      rc = MEMCACHED_SOME_ERRORS;\n    }\n  }\n\n  if (mget_mode) {\n    /*\n      Send a noop command to flush the buffers\n    */\n    protocol_binary_request_noop request = {}; //= {.bytes= {0}};\n    request.message.header.request.opcode = PROTOCOL_BINARY_CMD_NOOP;\n    request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n\n    for (uint32_t x = 0; x < memcached_server_count(ptr); ++x) {\n      memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n      if (instance->response_count()) {\n        initialize_binary_request(instance, request.message.header);\n        if ((memcached_io_write(instance) == false)\n            or (memcached_io_write(instance, request.bytes, sizeof(request.bytes), true) == -1))\n        {\n          memcached_instance_response_reset(instance);\n          memcached_io_reset(instance);\n          rc = MEMCACHED_SOME_ERRORS;\n        }\n      }\n    }\n  }\n\n  return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t mget_by_key_real(memcached_st *ptr, const char *group_key,\n                                             size_t group_key_length, const char *const *keys,\n                                             const size_t *key_length, size_t number_of_keys,\n                                             const bool mget_mode);\nstatic memcached_return_t binary_mget_by_key(memcached_st *ptr, const uint32_t master_server_key,\n                                             const bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode);\n\nstatic memcached_return_t binary_mget_by_key(memcached_st *ptr, const uint32_t master_server_key,\n                                             bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode) {\n  if (ptr->number_of_replicas == 0) {\n    return simple_binary_mget(ptr, master_server_key, is_group_key_set, keys, key_length,\n                              number_of_keys, mget_mode);\n  }\n\n  uint32_t *hash = libmemcached_xvalloc(ptr, number_of_keys, uint32_t);\n  bool *dead_servers = libmemcached_xcalloc(ptr, memcached_server_count(ptr), bool);\n\n  if (hash == NULL or dead_servers == NULL) {\n    libmemcached_free(ptr, hash);\n    libmemcached_free(ptr, dead_servers);\n    return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n  }\n\n  if (is_group_key_set) {\n    for (size_t x = 0; x < number_of_keys; x++) {\n      hash[x] = master_server_key;\n    }\n  } else {\n    for (size_t x = 0; x < number_of_keys; x++) {\n      hash[x] = memcached_generate_hash_with_redistribution(ptr, keys[x], key_length[x]);\n    }\n  }\n\n  memcached_return_t rc =\n      replication_binary_mget(ptr, hash, dead_servers, keys, key_length, number_of_keys);\n\n  WATCHPOINT_IFERROR(rc);\n  libmemcached_free(ptr, hash);\n  libmemcached_free(ptr, dead_servers);\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "replication_binary_mget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/get.cc",
    "lines": "455-545",
    "snippet": "static memcached_return_t replication_binary_mget(memcached_st *ptr, uint32_t *hash,\n                                                  bool *dead_servers, const char *const *keys,\n                                                  const size_t *key_length,\n                                                  const size_t number_of_keys) {\n  memcached_return_t rc = MEMCACHED_NOTFOUND;\n  uint32_t start = 0;\n  uint64_t randomize_read = memcached_behavior_get(ptr, MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ);\n\n  if (randomize_read) {\n    start = (uint32_t) random() % (uint32_t)(ptr->number_of_replicas + 1);\n  }\n\n  /* Loop for each replica */\n  for (uint32_t replica = 0; replica <= ptr->number_of_replicas; ++replica) {\n    bool success = true;\n\n    for (uint32_t x = 0; x < number_of_keys; ++x) {\n      if (hash[x] == memcached_server_count(ptr)) {\n        continue; /* Already successfully sent */\n      }\n\n      uint32_t server = hash[x] + replica;\n\n      /* In case of randomized reads */\n      if (randomize_read and ((server + start) <= (hash[x] + ptr->number_of_replicas))) {\n        server += start;\n      }\n\n      while (server >= memcached_server_count(ptr)) {\n        server -= memcached_server_count(ptr);\n      }\n\n      if (dead_servers[server]) {\n        continue;\n      }\n\n      memcached_instance_st *instance = memcached_instance_fetch(ptr, server);\n\n      if (instance->response_count() == 0) {\n        rc = memcached_connect(instance);\n\n        if (memcached_failed(rc)) {\n          memcached_io_reset(instance);\n          dead_servers[server] = true;\n          success = false;\n          continue;\n        }\n      }\n\n      protocol_binary_request_getk request = {};\n      initialize_binary_request(instance, request.message.header);\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_GETK;\n      request.message.header.request.keylen =\n          htons((uint16_t)(key_length[x] + memcached_array_size(ptr->_namespace)));\n      request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n      request.message.header.request.bodylen =\n          htonl((uint32_t)(key_length[x] + memcached_array_size(ptr->_namespace)));\n\n      /*\n       * We need to disable buffering to actually know that the request was\n       * successfully sent to the server (so that we should expect a result\n       * back). It would be nice to do this in buffered mode, but then it\n       * would be complex to handle all error situations if we got to send\n       * some of the messages, and then we failed on writing out some others\n       * and we used the callback interface from memcached_mget_execute so\n       * that we might have processed some of the responses etc. For now,\n       * just make sure we work _correctly_\n       */\n      libmemcached_io_vector_st vector[] = {\n          {request.bytes, sizeof(request.bytes)},\n          {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n          {keys[x], key_length[x]}};\n\n      if (memcached_io_writev(instance, vector, 3, true) == false) {\n        memcached_io_reset(instance);\n        dead_servers[server] = true;\n        success = false;\n        continue;\n      }\n\n      memcached_server_response_increment(instance);\n      hash[x] = memcached_server_count(ptr);\n    }\n\n    if (success) {\n      break;\n    }\n  }\n\n  return rc;\n}",
    "includes": [
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "ptr"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_response_increment",
          "args": [
            "instance"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_response_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/common.h",
          "lines": "137-140",
          "snippet": "static inline void memcached_server_response_increment(memcached_instance_st *instance) {\n  instance->events(POLLIN);\n  instance->cursor_active_++;\n}",
          "includes": [
            "#  include \"p9y/poll.hpp\"",
            "#include \"libmemcached/continuum.hpp\"",
            "#  include \"libmemcached/version.hpp\"",
            "#  include \"libmemcached/result.h\"",
            "#  include \"libmemcached/key.hpp\"",
            "#  include \"libmemcached/server.hpp\"",
            "#  include \"libmemcached/assert.hpp\"",
            "#  include \"libmemcached/backtrace.hpp\"",
            "#  include \"libmemcached/virtual_bucket.h\"",
            "#  include \"libmemcached/namespace.h\"",
            "#  include \"libmemcached/response.h\"",
            "#include \"libmemcached/initialize_query.h\"",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcached/libmemcached_probes.h\"",
            "#include \"libmemcached/array.h\"",
            "#include \"libmemcached/internal.h\"",
            "#  include \"libmemcached/server_list.hpp\"",
            "#  include \"libmemcached/sasl.hpp\"",
            "#  include \"libmemcached/behavior.hpp\"",
            "#  include \"libmemcached/flag.hpp\"",
            "#  include \"libmemcached/server.hpp\"",
            "#  include \"libmemcached/server_instance.h\"",
            "#  include \"libmemcached/instance.hpp\"",
            "#  include \"libmemcached/quit.hpp\"",
            "#  include \"libmemcached/hash.hpp\"",
            "#  include \"libmemcached/allocators.hpp\"",
            "#  include \"libmemcached/connect.hpp\"",
            "#  include \"libmemcached/do.hpp\"",
            "#  include \"libmemcached/udp.hpp\"",
            "#  include \"libmemcached/io.hpp\"",
            "#  include \"libmemcachedprotocol-0.0/binary.h\"",
            "#  include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/io.h\"",
            "#include \"libmemcached/memory.h\"",
            "#include \"libmemcached/error.hpp\"",
            "#include \"libmemcached/is.h\"",
            "#include \"libmemcached/watchpoint.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#  include <dlfcn.h>",
            "#  include <strings.h>",
            "#include <fcntl.h>",
            "#  include <sys/time.h>",
            "#include \"p9y/socket.hpp\"",
            "#  include <iso646.h>",
            "#  include <limits.h>",
            "#  include <errno.h>",
            "#  include <time.h>",
            "#  include <string.h>",
            "#  include <stdlib.h>",
            "#  include <stdio.h>",
            "#  include <stddef.h>",
            "#  include <ciso646>",
            "#  include <climits>",
            "#  include <cerrno>",
            "#  include <cctype>",
            "#  include <ctime>",
            "#  include <cstring>",
            "#  include <cstdlib>",
            "#  include <cstdio>",
            "#  include <cstddef>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"p9y/poll.hpp\"\n#include \"libmemcached/continuum.hpp\"\n#  include \"libmemcached/version.hpp\"\n#  include \"libmemcached/result.h\"\n#  include \"libmemcached/key.hpp\"\n#  include \"libmemcached/server.hpp\"\n#  include \"libmemcached/assert.hpp\"\n#  include \"libmemcached/backtrace.hpp\"\n#  include \"libmemcached/virtual_bucket.h\"\n#  include \"libmemcached/namespace.h\"\n#  include \"libmemcached/response.h\"\n#include \"libmemcached/initialize_query.h\"\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcached/libmemcached_probes.h\"\n#include \"libmemcached/array.h\"\n#include \"libmemcached/internal.h\"\n#  include \"libmemcached/server_list.hpp\"\n#  include \"libmemcached/sasl.hpp\"\n#  include \"libmemcached/behavior.hpp\"\n#  include \"libmemcached/flag.hpp\"\n#  include \"libmemcached/server.hpp\"\n#  include \"libmemcached/server_instance.h\"\n#  include \"libmemcached/instance.hpp\"\n#  include \"libmemcached/quit.hpp\"\n#  include \"libmemcached/hash.hpp\"\n#  include \"libmemcached/allocators.hpp\"\n#  include \"libmemcached/connect.hpp\"\n#  include \"libmemcached/do.hpp\"\n#  include \"libmemcached/udp.hpp\"\n#  include \"libmemcached/io.hpp\"\n#  include \"libmemcachedprotocol-0.0/binary.h\"\n#  include \"libmemcached/string.hpp\"\n#include \"libmemcached/io.h\"\n#include \"libmemcached/memory.h\"\n#include \"libmemcached/error.hpp\"\n#include \"libmemcached/is.h\"\n#include \"libmemcached/watchpoint.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#  include <dlfcn.h>\n#  include <strings.h>\n#include <fcntl.h>\n#  include <sys/time.h>\n#include \"p9y/socket.hpp\"\n#  include <iso646.h>\n#  include <limits.h>\n#  include <errno.h>\n#  include <time.h>\n#  include <string.h>\n#  include <stdlib.h>\n#  include <stdio.h>\n#  include <stddef.h>\n#  include <ciso646>\n#  include <climits>\n#  include <cerrno>\n#  include <cctype>\n#  include <ctime>\n#  include <cstring>\n#  include <cstdlib>\n#  include <cstdio>\n#  include <cstddef>\n#include \"mem_config.h\"\n\nstatic inline void memcached_server_response_increment(memcached_instance_st *instance) {\n  instance->events(POLLIN);\n  instance->cursor_active_++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_io_reset",
          "args": [
            "instance"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "740-742",
          "snippet": "void memcached_io_reset(memcached_instance_st *instance) {\n  memcached_quit_server(instance, true);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_io_reset(memcached_instance_st *instance) {\n  memcached_quit_server(instance, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_io_writev",
          "args": [
            "instance",
            "vector",
            "3",
            "true"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "608-631",
          "snippet": "bool memcached_io_writev(memcached_instance_st *instance, libmemcached_io_vector_st vector[],\n                         const size_t number_of, const bool with_flush) {\n  ssize_t complete_total = 0;\n  ssize_t total = 0;\n\n  for (size_t x = 0; x < number_of; x++, vector++) {\n    complete_total += vector->length;\n    if (vector->length) {\n      size_t written;\n      if ((_io_write(instance, vector->buffer, vector->length, false, written)) == false) {\n        return false;\n      }\n      total += written;\n    }\n  }\n\n  if (with_flush) {\n    if (memcached_io_write(instance) == false) {\n      return false;\n    }\n  }\n\n  return (complete_total == total);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_io_writev(memcached_instance_st *instance, libmemcached_io_vector_st vector[],\n                         const size_t number_of, const bool with_flush) {\n  ssize_t complete_total = 0;\n  ssize_t total = 0;\n\n  for (size_t x = 0; x < number_of; x++, vector++) {\n    complete_total += vector->length;\n    if (vector->length) {\n      size_t written;\n      if ((_io_write(instance, vector->buffer, vector->length, false, written)) == false) {\n        return false;\n      }\n      total += written;\n    }\n  }\n\n  if (with_flush) {\n    if (memcached_io_write(instance) == false) {\n      return false;\n    }\n  }\n\n  return (complete_total == total);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_array_size",
          "args": [
            "ptr->_namespace"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_array_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/array.cc",
          "lines": "78-84",
          "snippet": "size_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"libmemcached/common.h\"\n\nsize_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_array_string",
          "args": [
            "ptr->_namespace"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(uint32_t)(key_length[x] + memcached_array_size(ptr->_namespace))"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_htonll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "55-61",
          "snippet": "uint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "(uint16_t)(key_length[x] + memcached_array_size(ptr->_namespace))"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_binary_request",
          "args": [
            "instance",
            "request.message.header"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_binary_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "20-25",
          "snippet": "void initialize_binary_request(memcached_instance_st *server,\n                               protocol_binary_request_header &header) {\n  server->request_id++;\n  header.request.magic = PROTOCOL_BINARY_REQ;\n  header.request.opaque = htons(server->request_id);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid initialize_binary_request(memcached_instance_st *server,\n                               protocol_binary_request_header &header) {\n  server->request_id++;\n  header.request.magic = PROTOCOL_BINARY_REQ;\n  header.request.opaque = htons(server->request_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_connect",
          "args": [
            "instance"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
          "lines": "598-600",
          "snippet": "memcached_return_t memcached_connect(memcached_instance_st *server) {\n  return _memcached_connect(server, true);\n}",
          "includes": [
            "#include <cassert>",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_connect(memcached_instance_st *server) {\n  return _memcached_connect(server, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "instance->response_count",
          "args": [],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "response_count",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.hpp",
          "lines": "62-62",
          "snippet": "uint32_t response_count() const { return cursor_active_; }",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#    include <netdb.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "memcached_return_t memcached_instance_push(memcached_st *ptr, const memcached_instance_st *,\n                                           uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#    include <netdb.h>\n\nmemcached_return_t memcached_instance_push(memcached_st *ptr, const memcached_instance_st *,\n                                           uint32_t);\n\nmemcached_instance_st {\n  uint32_t response_count() const { return cursor_active_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "ptr",
            "server"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "random",
          "args": [],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "random64",
          "container": "random64",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/random.hpp",
          "lines": "26-29",
          "snippet": "random64()\n  : gen{static_cast<typ>(time_clock::now().time_since_epoch().count())}\n  , dst{}\n  {}",
          "includes": [
            "#include <random>",
            "#include \"time.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <random>\n#include \"time.hpp\"\n\nrandom64 {\n  random64()\n    : gen{static_cast<typ>(time_clock::now().time_since_epoch().count())}\n    , dst{}\n    {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_behavior_get",
          "args": [
            "ptr",
            "MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_behavior_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "288-482",
          "snippet": "uint64_t memcached_behavior_get(memcached_st *shell, const memcached_behavior_t flag) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    return ptr->number_of_replicas;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    return ptr->io_msg_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    return ptr->io_bytes_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    return ptr->io_key_prefetch;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    return ptr->flags.binary_protocol;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    return ptr->flags.support_cas;\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return true;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    return ptr->flags.no_block;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    return ptr->flags.buffer_requests;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    return memcached_is_udp(ptr);\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    return ptr->flags.tcp_nodelay;\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    return ptr->flags.verify_key;\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED:\n    if (memcached_is_consistent_distribution(ptr)) {\n      return memcached_is_weighted_ketama(ptr);\n    }\n    return false;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return ptr->distribution;\n\n  case MEMCACHED_BEHAVIOR_KETAMA:\n    return memcached_is_consistent_distribution(ptr);\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return hashkit_get_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return hashkit_get_distribution_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    return ptr->server_failure_limit;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    return ptr->server_timeout_limit;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS:\n    return ptr->flags.use_sort_hosts;\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    return (uint64_t) ptr->poll_timeout;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    return (uint64_t) ptr->connect_timeout;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    return (uint64_t) ptr->retry_timeout;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    return uint64_t(ptr->dead_timeout);\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    return (uint64_t) ptr->snd_timeout;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    return (uint64_t) ptr->rcv_timeout;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    return (uint64_t) ptr->tcp_keepidle;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->send_size != -1) // If value is -1 then we are using the default\n    {\n      return (uint64_t) ptr->send_size;\n    }\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    if (instance) // If we have an instance we test, otherwise we just set and pray\n    {\n      /* REFACTOR */\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_SNDBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->recv_size != -1) // If value is -1 then we are using the default\n      return (uint64_t) ptr->recv_size;\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    /**\n      @note REFACTOR\n    */\n    if (instance) {\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_RCVBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                        memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n    return 0;\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    return ptr->flags.hash_with_namespace;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    return ptr->flags.reply ? false : true;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    return ptr->flags.randomize_replica_read;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n#ifdef HAVE_MSG_MORE\n    return true;\n#else\n    return false;\n#endif\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    return ptr->flags.tcp_keepalive;\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return bool(memcached_parse_filename(ptr));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_get()\");\n    return 0;\n  }\n\n  /* NOTREACHED */\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nuint64_t memcached_behavior_get(memcached_st *shell, const memcached_behavior_t flag) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    return ptr->number_of_replicas;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    return ptr->io_msg_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    return ptr->io_bytes_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    return ptr->io_key_prefetch;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    return ptr->flags.binary_protocol;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    return ptr->flags.support_cas;\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return true;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    return ptr->flags.no_block;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    return ptr->flags.buffer_requests;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    return memcached_is_udp(ptr);\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    return ptr->flags.tcp_nodelay;\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    return ptr->flags.verify_key;\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED:\n    if (memcached_is_consistent_distribution(ptr)) {\n      return memcached_is_weighted_ketama(ptr);\n    }\n    return false;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return ptr->distribution;\n\n  case MEMCACHED_BEHAVIOR_KETAMA:\n    return memcached_is_consistent_distribution(ptr);\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return hashkit_get_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return hashkit_get_distribution_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    return ptr->server_failure_limit;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    return ptr->server_timeout_limit;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS:\n    return ptr->flags.use_sort_hosts;\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    return (uint64_t) ptr->poll_timeout;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    return (uint64_t) ptr->connect_timeout;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    return (uint64_t) ptr->retry_timeout;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    return uint64_t(ptr->dead_timeout);\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    return (uint64_t) ptr->snd_timeout;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    return (uint64_t) ptr->rcv_timeout;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    return (uint64_t) ptr->tcp_keepidle;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->send_size != -1) // If value is -1 then we are using the default\n    {\n      return (uint64_t) ptr->send_size;\n    }\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    if (instance) // If we have an instance we test, otherwise we just set and pray\n    {\n      /* REFACTOR */\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_SNDBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->recv_size != -1) // If value is -1 then we are using the default\n      return (uint64_t) ptr->recv_size;\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    /**\n      @note REFACTOR\n    */\n    if (instance) {\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_RCVBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                        memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n    return 0;\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    return ptr->flags.hash_with_namespace;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    return ptr->flags.reply ? false : true;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    return ptr->flags.randomize_replica_read;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n#ifdef HAVE_MSG_MORE\n    return true;\n#else\n    return false;\n#endif\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    return ptr->flags.tcp_keepalive;\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return bool(memcached_parse_filename(ptr));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_get()\");\n    return 0;\n  }\n\n  /* NOTREACHED */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t replication_binary_mget(memcached_st *ptr, uint32_t *hash,\n                                                  bool *dead_servers, const char *const *keys,\n                                                  const size_t *key_length,\n                                                  const size_t number_of_keys) {\n  memcached_return_t rc = MEMCACHED_NOTFOUND;\n  uint32_t start = 0;\n  uint64_t randomize_read = memcached_behavior_get(ptr, MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ);\n\n  if (randomize_read) {\n    start = (uint32_t) random() % (uint32_t)(ptr->number_of_replicas + 1);\n  }\n\n  /* Loop for each replica */\n  for (uint32_t replica = 0; replica <= ptr->number_of_replicas; ++replica) {\n    bool success = true;\n\n    for (uint32_t x = 0; x < number_of_keys; ++x) {\n      if (hash[x] == memcached_server_count(ptr)) {\n        continue; /* Already successfully sent */\n      }\n\n      uint32_t server = hash[x] + replica;\n\n      /* In case of randomized reads */\n      if (randomize_read and ((server + start) <= (hash[x] + ptr->number_of_replicas))) {\n        server += start;\n      }\n\n      while (server >= memcached_server_count(ptr)) {\n        server -= memcached_server_count(ptr);\n      }\n\n      if (dead_servers[server]) {\n        continue;\n      }\n\n      memcached_instance_st *instance = memcached_instance_fetch(ptr, server);\n\n      if (instance->response_count() == 0) {\n        rc = memcached_connect(instance);\n\n        if (memcached_failed(rc)) {\n          memcached_io_reset(instance);\n          dead_servers[server] = true;\n          success = false;\n          continue;\n        }\n      }\n\n      protocol_binary_request_getk request = {};\n      initialize_binary_request(instance, request.message.header);\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_GETK;\n      request.message.header.request.keylen =\n          htons((uint16_t)(key_length[x] + memcached_array_size(ptr->_namespace)));\n      request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n      request.message.header.request.bodylen =\n          htonl((uint32_t)(key_length[x] + memcached_array_size(ptr->_namespace)));\n\n      /*\n       * We need to disable buffering to actually know that the request was\n       * successfully sent to the server (so that we should expect a result\n       * back). It would be nice to do this in buffered mode, but then it\n       * would be complex to handle all error situations if we got to send\n       * some of the messages, and then we failed on writing out some others\n       * and we used the callback interface from memcached_mget_execute so\n       * that we might have processed some of the responses etc. For now,\n       * just make sure we work _correctly_\n       */\n      libmemcached_io_vector_st vector[] = {\n          {request.bytes, sizeof(request.bytes)},\n          {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n          {keys[x], key_length[x]}};\n\n      if (memcached_io_writev(instance, vector, 3, true) == false) {\n        memcached_io_reset(instance);\n        dead_servers[server] = true;\n        success = false;\n        continue;\n      }\n\n      memcached_server_response_increment(instance);\n      hash[x] = memcached_server_count(ptr);\n    }\n\n    if (success) {\n      break;\n    }\n  }\n\n  return rc;\n}"
  },
  {
    "function_name": "simple_binary_mget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/get.cc",
    "lines": "343-453",
    "snippet": "static memcached_return_t simple_binary_mget(memcached_st *ptr, const uint32_t master_server_key,\n                                             bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode) {\n  memcached_return_t rc = MEMCACHED_NOTFOUND;\n\n  bool flush = (number_of_keys == 1);\n\n  if (memcached_failed(rc = memcached_key_test(*ptr, keys, key_length, number_of_keys))) {\n    return rc;\n  }\n\n  /*\n    If a server fails we warn about errors and start all over with sending keys\n    to the server.\n  */\n  for (uint32_t x = 0; x < number_of_keys; ++x) {\n    uint32_t server_key;\n\n    if (is_group_key_set) {\n      server_key = master_server_key;\n    } else {\n      server_key = memcached_generate_hash_with_redistribution(ptr, keys[x], key_length[x]);\n    }\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n    if (instance->response_count() == 0) {\n      rc = memcached_connect(instance);\n      if (memcached_failed(rc)) {\n        continue;\n      }\n    }\n\n    protocol_binary_request_getk request = {}; //= {.bytes= {0}};\n    initialize_binary_request(instance, request.message.header);\n    if (mget_mode) {\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_GETKQ;\n    } else {\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_GETK;\n    }\n\n#if 0\n    {\n      memcached_return_t vk= memcached_validate_key_length(key_length[x], ptr->flags.binary_protocol);\n      if (memcached_failed(rc= memcached_key_test(*memc, (const char **)&key, &key_length, 1)))\n      {\n        memcached_set_error(ptr, vk, MEMCACHED_AT, memcached_literal_param(\"Key was too long.\"));\n\n        if (x > 0)\n        {\n          memcached_io_reset(instance);\n        }\n\n        return vk;\n      }\n    }\n#endif\n\n    request.message.header.request.keylen =\n        htons((uint16_t)(key_length[x] + memcached_array_size(ptr->_namespace)));\n    request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n    request.message.header.request.bodylen =\n        htonl((uint32_t)(key_length[x] + memcached_array_size(ptr->_namespace)));\n\n    libmemcached_io_vector_st vector[] = {\n        {request.bytes, sizeof(request.bytes)},\n        {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n        {keys[x], key_length[x]}};\n\n    if (memcached_io_writev(instance, vector, 3, flush) == false) {\n      memcached_server_response_reset(instance);\n      rc = MEMCACHED_SOME_ERRORS;\n      continue;\n    }\n\n    /* We just want one pending response per server */\n    memcached_server_response_reset(instance);\n    memcached_server_response_increment(instance);\n    if ((x > 0 and x == ptr->io_key_prefetch) and memcached_flush_buffers(ptr) != MEMCACHED_SUCCESS)\n    {\n      rc = MEMCACHED_SOME_ERRORS;\n    }\n  }\n\n  if (mget_mode) {\n    /*\n      Send a noop command to flush the buffers\n    */\n    protocol_binary_request_noop request = {}; //= {.bytes= {0}};\n    request.message.header.request.opcode = PROTOCOL_BINARY_CMD_NOOP;\n    request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n\n    for (uint32_t x = 0; x < memcached_server_count(ptr); ++x) {\n      memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n      if (instance->response_count()) {\n        initialize_binary_request(instance, request.message.header);\n        if ((memcached_io_write(instance) == false)\n            or (memcached_io_write(instance, request.bytes, sizeof(request.bytes), true) == -1))\n        {\n          memcached_instance_response_reset(instance);\n          memcached_io_reset(instance);\n          rc = MEMCACHED_SOME_ERRORS;\n        }\n      }\n    }\n  }\n\n  return rc;\n}",
    "includes": [
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_return_t mget_by_key_real(memcached_st *ptr, const char *group_key,\n                                             size_t group_key_length, const char *const *keys,\n                                             const size_t *key_length, size_t number_of_keys,\n                                             const bool mget_mode);",
      "static memcached_return_t binary_mget_by_key(memcached_st *ptr, const uint32_t master_server_key,\n                                             const bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_io_reset",
          "args": [
            "instance"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "740-742",
          "snippet": "void memcached_io_reset(memcached_instance_st *instance) {\n  memcached_quit_server(instance, true);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_io_reset(memcached_instance_st *instance) {\n  memcached_quit_server(instance, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_response_reset",
          "args": [
            "instance"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_io_write",
          "args": [
            "instance",
            "request.bytes",
            "sizeof(request.bytes)",
            "true"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "608-631",
          "snippet": "bool memcached_io_writev(memcached_instance_st *instance, libmemcached_io_vector_st vector[],\n                         const size_t number_of, const bool with_flush) {\n  ssize_t complete_total = 0;\n  ssize_t total = 0;\n\n  for (size_t x = 0; x < number_of; x++, vector++) {\n    complete_total += vector->length;\n    if (vector->length) {\n      size_t written;\n      if ((_io_write(instance, vector->buffer, vector->length, false, written)) == false) {\n        return false;\n      }\n      total += written;\n    }\n  }\n\n  if (with_flush) {\n    if (memcached_io_write(instance) == false) {\n      return false;\n    }\n  }\n\n  return (complete_total == total);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_io_writev(memcached_instance_st *instance, libmemcached_io_vector_st vector[],\n                         const size_t number_of, const bool with_flush) {\n  ssize_t complete_total = 0;\n  ssize_t total = 0;\n\n  for (size_t x = 0; x < number_of; x++, vector++) {\n    complete_total += vector->length;\n    if (vector->length) {\n      size_t written;\n      if ((_io_write(instance, vector->buffer, vector->length, false, written)) == false) {\n        return false;\n      }\n      total += written;\n    }\n  }\n\n  if (with_flush) {\n    if (memcached_io_write(instance) == false) {\n      return false;\n    }\n  }\n\n  return (complete_total == total);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_io_write",
          "args": [
            "instance"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "592-595",
          "snippet": "bool memcached_io_write(memcached_instance_st *instance) {\n  size_t written;\n  return _io_write(instance, NULL, 0, true, written);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_io_write(memcached_instance_st *instance) {\n  size_t written;\n  return _io_write(instance, NULL, 0, true, written);\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_binary_request",
          "args": [
            "instance",
            "request.message.header"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_binary_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "20-25",
          "snippet": "void initialize_binary_request(memcached_instance_st *server,\n                               protocol_binary_request_header &header) {\n  server->request_id++;\n  header.request.magic = PROTOCOL_BINARY_REQ;\n  header.request.opaque = htons(server->request_id);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid initialize_binary_request(memcached_instance_st *server,\n                               protocol_binary_request_header &header) {\n  server->request_id++;\n  header.request.magic = PROTOCOL_BINARY_REQ;\n  header.request.opaque = htons(server->request_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "instance->response_count",
          "args": [],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "response_count",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.hpp",
          "lines": "62-62",
          "snippet": "uint32_t response_count() const { return cursor_active_; }",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#    include <netdb.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "memcached_return_t memcached_instance_push(memcached_st *ptr, const memcached_instance_st *,\n                                           uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#    include <netdb.h>\n\nmemcached_return_t memcached_instance_push(memcached_st *ptr, const memcached_instance_st *,\n                                           uint32_t);\n\nmemcached_instance_st {\n  uint32_t response_count() const { return cursor_active_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "ptr",
            "x"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "ptr"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_flush_buffers",
          "args": [
            "ptr"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_flush_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/flush_buffers.cc",
          "lines": "18-43",
          "snippet": "memcached_return_t memcached_flush_buffers(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    memcached_return_t ret = MEMCACHED_SUCCESS;\n\n    for (uint32_t x = 0; x < memcached_server_count(memc); ++x) {\n      memcached_instance_st *instance = memcached_instance_fetch(memc, x);\n\n      if (instance->write_buffer_offset) {\n        if (instance->fd == INVALID_SOCKET\n            and (ret = memcached_connect(instance)) != MEMCACHED_SUCCESS) {\n          WATCHPOINT_ERROR(ret);\n          return ret;\n        }\n\n        if (memcached_io_write(instance) == false) {\n          ret = MEMCACHED_SOME_ERRORS;\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_flush_buffers(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    memcached_return_t ret = MEMCACHED_SUCCESS;\n\n    for (uint32_t x = 0; x < memcached_server_count(memc); ++x) {\n      memcached_instance_st *instance = memcached_instance_fetch(memc, x);\n\n      if (instance->write_buffer_offset) {\n        if (instance->fd == INVALID_SOCKET\n            and (ret = memcached_connect(instance)) != MEMCACHED_SUCCESS) {\n          WATCHPOINT_ERROR(ret);\n          return ret;\n        }\n\n        if (memcached_io_write(instance) == false) {\n          ret = MEMCACHED_SOME_ERRORS;\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_response_increment",
          "args": [
            "instance"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_response_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/common.h",
          "lines": "137-140",
          "snippet": "static inline void memcached_server_response_increment(memcached_instance_st *instance) {\n  instance->events(POLLIN);\n  instance->cursor_active_++;\n}",
          "includes": [
            "#  include \"p9y/poll.hpp\"",
            "#include \"libmemcached/continuum.hpp\"",
            "#  include \"libmemcached/version.hpp\"",
            "#  include \"libmemcached/result.h\"",
            "#  include \"libmemcached/key.hpp\"",
            "#  include \"libmemcached/server.hpp\"",
            "#  include \"libmemcached/assert.hpp\"",
            "#  include \"libmemcached/backtrace.hpp\"",
            "#  include \"libmemcached/virtual_bucket.h\"",
            "#  include \"libmemcached/namespace.h\"",
            "#  include \"libmemcached/response.h\"",
            "#include \"libmemcached/initialize_query.h\"",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcached/libmemcached_probes.h\"",
            "#include \"libmemcached/array.h\"",
            "#include \"libmemcached/internal.h\"",
            "#  include \"libmemcached/server_list.hpp\"",
            "#  include \"libmemcached/sasl.hpp\"",
            "#  include \"libmemcached/behavior.hpp\"",
            "#  include \"libmemcached/flag.hpp\"",
            "#  include \"libmemcached/server.hpp\"",
            "#  include \"libmemcached/server_instance.h\"",
            "#  include \"libmemcached/instance.hpp\"",
            "#  include \"libmemcached/quit.hpp\"",
            "#  include \"libmemcached/hash.hpp\"",
            "#  include \"libmemcached/allocators.hpp\"",
            "#  include \"libmemcached/connect.hpp\"",
            "#  include \"libmemcached/do.hpp\"",
            "#  include \"libmemcached/udp.hpp\"",
            "#  include \"libmemcached/io.hpp\"",
            "#  include \"libmemcachedprotocol-0.0/binary.h\"",
            "#  include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/io.h\"",
            "#include \"libmemcached/memory.h\"",
            "#include \"libmemcached/error.hpp\"",
            "#include \"libmemcached/is.h\"",
            "#include \"libmemcached/watchpoint.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#  include <dlfcn.h>",
            "#  include <strings.h>",
            "#include <fcntl.h>",
            "#  include <sys/time.h>",
            "#include \"p9y/socket.hpp\"",
            "#  include <iso646.h>",
            "#  include <limits.h>",
            "#  include <errno.h>",
            "#  include <time.h>",
            "#  include <string.h>",
            "#  include <stdlib.h>",
            "#  include <stdio.h>",
            "#  include <stddef.h>",
            "#  include <ciso646>",
            "#  include <climits>",
            "#  include <cerrno>",
            "#  include <cctype>",
            "#  include <ctime>",
            "#  include <cstring>",
            "#  include <cstdlib>",
            "#  include <cstdio>",
            "#  include <cstddef>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"p9y/poll.hpp\"\n#include \"libmemcached/continuum.hpp\"\n#  include \"libmemcached/version.hpp\"\n#  include \"libmemcached/result.h\"\n#  include \"libmemcached/key.hpp\"\n#  include \"libmemcached/server.hpp\"\n#  include \"libmemcached/assert.hpp\"\n#  include \"libmemcached/backtrace.hpp\"\n#  include \"libmemcached/virtual_bucket.h\"\n#  include \"libmemcached/namespace.h\"\n#  include \"libmemcached/response.h\"\n#include \"libmemcached/initialize_query.h\"\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcached/libmemcached_probes.h\"\n#include \"libmemcached/array.h\"\n#include \"libmemcached/internal.h\"\n#  include \"libmemcached/server_list.hpp\"\n#  include \"libmemcached/sasl.hpp\"\n#  include \"libmemcached/behavior.hpp\"\n#  include \"libmemcached/flag.hpp\"\n#  include \"libmemcached/server.hpp\"\n#  include \"libmemcached/server_instance.h\"\n#  include \"libmemcached/instance.hpp\"\n#  include \"libmemcached/quit.hpp\"\n#  include \"libmemcached/hash.hpp\"\n#  include \"libmemcached/allocators.hpp\"\n#  include \"libmemcached/connect.hpp\"\n#  include \"libmemcached/do.hpp\"\n#  include \"libmemcached/udp.hpp\"\n#  include \"libmemcached/io.hpp\"\n#  include \"libmemcachedprotocol-0.0/binary.h\"\n#  include \"libmemcached/string.hpp\"\n#include \"libmemcached/io.h\"\n#include \"libmemcached/memory.h\"\n#include \"libmemcached/error.hpp\"\n#include \"libmemcached/is.h\"\n#include \"libmemcached/watchpoint.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#  include <dlfcn.h>\n#  include <strings.h>\n#include <fcntl.h>\n#  include <sys/time.h>\n#include \"p9y/socket.hpp\"\n#  include <iso646.h>\n#  include <limits.h>\n#  include <errno.h>\n#  include <time.h>\n#  include <string.h>\n#  include <stdlib.h>\n#  include <stdio.h>\n#  include <stddef.h>\n#  include <ciso646>\n#  include <climits>\n#  include <cerrno>\n#  include <cctype>\n#  include <ctime>\n#  include <cstring>\n#  include <cstdlib>\n#  include <cstdio>\n#  include <cstddef>\n#include \"mem_config.h\"\n\nstatic inline void memcached_server_response_increment(memcached_instance_st *instance) {\n  instance->events(POLLIN);\n  instance->cursor_active_++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_response_reset",
          "args": [
            "instance"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_response_reset",
          "args": [
            "instance"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_array_size",
          "args": [
            "ptr->_namespace"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_array_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/array.cc",
          "lines": "78-84",
          "snippet": "size_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"libmemcached/common.h\"\n\nsize_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_array_string",
          "args": [
            "ptr->_namespace"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(uint32_t)(key_length[x] + memcached_array_size(ptr->_namespace))"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_htonll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "55-61",
          "snippet": "uint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "(uint16_t)(key_length[x] + memcached_array_size(ptr->_namespace))"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "ptr",
            "vk",
            "MEMCACHED_AT",
            "memcached_literal_param(\"Key was too long.\")"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Key was too long.\""
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc= memcached_key_test(*memc, (const char **)&key, &key_length, 1)"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_key_test",
          "args": [
            "*memc",
            "(const char **)&key",
            "&key_length",
            "1"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_key_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/key.cc",
          "lines": "43-81",
          "snippet": "memcached_return_t memcached_key_test(memcached_st &memc, const char *const *keys,\n                                      const size_t *key_length, size_t number_of_keys) {\n  if (number_of_keys == 0) {\n    return memcached_set_error(memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Numbers of keys provided was zero\"));\n  }\n\n  if (keys == NULL or key_length == NULL) {\n    return memcached_set_error(memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n                               memcached_literal_param(\"Key was NULL or length of key was zero.\"));\n  }\n\n  const bool is_binary = memcached_flag(memc, MEMCACHED_FLAG_BINARY_PROTOCOL);\n\n  // If we don't need to verify the key, or we are using the binary protoocol,\n  // we just check the size of the key\n  for (size_t x = 0; x < number_of_keys; ++x) {\n    // We should set binary key, but the memcached server is broken for\n    // longer keys at the moment.\n    memcached_return_t rc =\n        memcached_validate_key_length(*(key_length + x), false /* memc.flags.binary_protocol */);\n    if (memcached_failed(rc)) {\n      return memcached_set_error(memc, rc, MEMCACHED_AT,\n                                 memcached_literal_param(\"Key provided was too long.\"));\n    }\n\n    if (memc.flags.verify_key and is_binary == false) {\n      for (size_t y = 0; y < *(key_length + x); ++y) {\n        if ((isgraph(keys[x][y])) == 0) {\n          return memcached_set_error(\n              memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n              memcached_literal_param(\"Key provided had invalid character.\"));\n        }\n      }\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_key_test(memcached_st &memc, const char *const *keys,\n                                      const size_t *key_length, size_t number_of_keys) {\n  if (number_of_keys == 0) {\n    return memcached_set_error(memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Numbers of keys provided was zero\"));\n  }\n\n  if (keys == NULL or key_length == NULL) {\n    return memcached_set_error(memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n                               memcached_literal_param(\"Key was NULL or length of key was zero.\"));\n  }\n\n  const bool is_binary = memcached_flag(memc, MEMCACHED_FLAG_BINARY_PROTOCOL);\n\n  // If we don't need to verify the key, or we are using the binary protoocol,\n  // we just check the size of the key\n  for (size_t x = 0; x < number_of_keys; ++x) {\n    // We should set binary key, but the memcached server is broken for\n    // longer keys at the moment.\n    memcached_return_t rc =\n        memcached_validate_key_length(*(key_length + x), false /* memc.flags.binary_protocol */);\n    if (memcached_failed(rc)) {\n      return memcached_set_error(memc, rc, MEMCACHED_AT,\n                                 memcached_literal_param(\"Key provided was too long.\"));\n    }\n\n    if (memc.flags.verify_key and is_binary == false) {\n      for (size_t y = 0; y < *(key_length + x); ++y) {\n        if ((isgraph(keys[x][y])) == 0) {\n          return memcached_set_error(\n              memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n              memcached_literal_param(\"Key provided had invalid character.\"));\n        }\n      }\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_validate_key_length",
          "args": [
            "key_length[x]",
            "ptr->flags.binary_protocol"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_validate_key_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/key.cc",
          "lines": "18-41",
          "snippet": "static inline memcached_return_t memcached_validate_key_length(size_t key_length, bool) {\n  if (key_length == 0) {\n    return MEMCACHED_BAD_KEY_PROVIDED;\n  }\n\n  // No one ever reimplemented MEMCACHED to use keys longer then the original ascii length\n#if 0\n  if (binary)\n  {\n    if (key_length > 0xffff)\n    {\n      return MEMCACHED_BAD_KEY_PROVIDED;\n    }\n  }\n  else\n#endif\n  {\n    if (key_length >= MEMCACHED_MAX_KEY) {\n      return MEMCACHED_BAD_KEY_PROVIDED;\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline memcached_return_t memcached_validate_key_length(size_t key_length, bool) {\n  if (key_length == 0) {\n    return MEMCACHED_BAD_KEY_PROVIDED;\n  }\n\n  // No one ever reimplemented MEMCACHED to use keys longer then the original ascii length\n#if 0\n  if (binary)\n  {\n    if (key_length > 0xffff)\n    {\n      return MEMCACHED_BAD_KEY_PROVIDED;\n    }\n  }\n  else\n#endif\n  {\n    if (key_length >= MEMCACHED_MAX_KEY) {\n      return MEMCACHED_BAD_KEY_PROVIDED;\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_connect",
          "args": [
            "instance"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
          "lines": "598-600",
          "snippet": "memcached_return_t memcached_connect(memcached_instance_st *server) {\n  return _memcached_connect(server, true);\n}",
          "includes": [
            "#include <cassert>",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_connect(memcached_instance_st *server) {\n  return _memcached_connect(server, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "ptr",
            "server_key"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_generate_hash_with_redistribution",
          "args": [
            "ptr",
            "keys[x]",
            "key_length[x]"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_generate_hash_with_redistribution",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
          "lines": "109-116",
          "snippet": "uint32_t memcached_generate_hash_with_redistribution(memcached_st *ptr, const char *key,\n                                                     size_t key_length) {\n  uint32_t hash = _generate_hash_wrapper(ptr, key, key_length);\n\n  _regen_for_auto_eject(ptr);\n\n  return dispatch_host(ptr, hash);\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nuint32_t memcached_generate_hash_with_redistribution(memcached_st *ptr, const char *key,\n                                                     size_t key_length) {\n  uint32_t hash = _generate_hash_wrapper(ptr, key, key_length);\n\n  _regen_for_auto_eject(ptr);\n\n  return dispatch_host(ptr, hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = memcached_key_test(*ptr, keys, key_length, number_of_keys)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t mget_by_key_real(memcached_st *ptr, const char *group_key,\n                                             size_t group_key_length, const char *const *keys,\n                                             const size_t *key_length, size_t number_of_keys,\n                                             const bool mget_mode);\nstatic memcached_return_t binary_mget_by_key(memcached_st *ptr, const uint32_t master_server_key,\n                                             const bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode);\n\nstatic memcached_return_t simple_binary_mget(memcached_st *ptr, const uint32_t master_server_key,\n                                             bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode) {\n  memcached_return_t rc = MEMCACHED_NOTFOUND;\n\n  bool flush = (number_of_keys == 1);\n\n  if (memcached_failed(rc = memcached_key_test(*ptr, keys, key_length, number_of_keys))) {\n    return rc;\n  }\n\n  /*\n    If a server fails we warn about errors and start all over with sending keys\n    to the server.\n  */\n  for (uint32_t x = 0; x < number_of_keys; ++x) {\n    uint32_t server_key;\n\n    if (is_group_key_set) {\n      server_key = master_server_key;\n    } else {\n      server_key = memcached_generate_hash_with_redistribution(ptr, keys[x], key_length[x]);\n    }\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n    if (instance->response_count() == 0) {\n      rc = memcached_connect(instance);\n      if (memcached_failed(rc)) {\n        continue;\n      }\n    }\n\n    protocol_binary_request_getk request = {}; //= {.bytes= {0}};\n    initialize_binary_request(instance, request.message.header);\n    if (mget_mode) {\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_GETKQ;\n    } else {\n      request.message.header.request.opcode = PROTOCOL_BINARY_CMD_GETK;\n    }\n\n#if 0\n    {\n      memcached_return_t vk= memcached_validate_key_length(key_length[x], ptr->flags.binary_protocol);\n      if (memcached_failed(rc= memcached_key_test(*memc, (const char **)&key, &key_length, 1)))\n      {\n        memcached_set_error(ptr, vk, MEMCACHED_AT, memcached_literal_param(\"Key was too long.\"));\n\n        if (x > 0)\n        {\n          memcached_io_reset(instance);\n        }\n\n        return vk;\n      }\n    }\n#endif\n\n    request.message.header.request.keylen =\n        htons((uint16_t)(key_length[x] + memcached_array_size(ptr->_namespace)));\n    request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n    request.message.header.request.bodylen =\n        htonl((uint32_t)(key_length[x] + memcached_array_size(ptr->_namespace)));\n\n    libmemcached_io_vector_st vector[] = {\n        {request.bytes, sizeof(request.bytes)},\n        {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n        {keys[x], key_length[x]}};\n\n    if (memcached_io_writev(instance, vector, 3, flush) == false) {\n      memcached_server_response_reset(instance);\n      rc = MEMCACHED_SOME_ERRORS;\n      continue;\n    }\n\n    /* We just want one pending response per server */\n    memcached_server_response_reset(instance);\n    memcached_server_response_increment(instance);\n    if ((x > 0 and x == ptr->io_key_prefetch) and memcached_flush_buffers(ptr) != MEMCACHED_SUCCESS)\n    {\n      rc = MEMCACHED_SOME_ERRORS;\n    }\n  }\n\n  if (mget_mode) {\n    /*\n      Send a noop command to flush the buffers\n    */\n    protocol_binary_request_noop request = {}; //= {.bytes= {0}};\n    request.message.header.request.opcode = PROTOCOL_BINARY_CMD_NOOP;\n    request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n\n    for (uint32_t x = 0; x < memcached_server_count(ptr); ++x) {\n      memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n      if (instance->response_count()) {\n        initialize_binary_request(instance, request.message.header);\n        if ((memcached_io_write(instance) == false)\n            or (memcached_io_write(instance, request.bytes, sizeof(request.bytes), true) == -1))\n        {\n          memcached_instance_response_reset(instance);\n          memcached_io_reset(instance);\n          rc = MEMCACHED_SOME_ERRORS;\n        }\n      }\n    }\n  }\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_mget_execute_by_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/get.cc",
    "lines": "311-341",
    "snippet": "memcached_return_t memcached_mget_execute_by_key(memcached_st *shell, const char *group_key,\n                                                 size_t group_key_length, const char *const *keys,\n                                                 const size_t *key_length, size_t number_of_keys,\n                                                 memcached_execute_fn *callback, void *context,\n                                                 unsigned int number_of_callbacks) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, false))) {\n    return rc;\n  }\n\n  if (memcached_is_udp(ptr)) {\n    return memcached_set_error(*ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  if (memcached_is_binary(ptr) == false) {\n    return memcached_set_error(\n        *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"ASCII protocol is not supported for memcached_mget_execute_by_key()\"));\n  }\n\n  memcached_callback_st *original_callbacks = ptr->callbacks;\n  memcached_callback_st cb = {callback, context, number_of_callbacks};\n\n  ptr->callbacks = &cb;\n  rc = memcached_mget_by_key(ptr, group_key, group_key_length, keys, key_length, number_of_keys);\n  ptr->callbacks = original_callbacks;\n\n  return rc;\n}",
    "includes": [
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_mget_by_key",
          "args": [
            "ptr",
            "group_key",
            "group_key_length",
            "keys",
            "key_length",
            "number_of_keys"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_mget_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/get.cc",
          "lines": "296-301",
          "snippet": "memcached_return_t memcached_mget_by_key(memcached_st *shell, const char *group_key,\n                                         size_t group_key_length, const char *const *keys,\n                                         const size_t *key_length, size_t number_of_keys) {\n  Memcached *ptr = memcached2Memcached(shell);\n  return mget_by_key_real(ptr, group_key, group_key_length, keys, key_length, number_of_keys, true);\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_mget_by_key(memcached_st *shell, const char *group_key,\n                                         size_t group_key_length, const char *const *keys,\n                                         const size_t *key_length, size_t number_of_keys) {\n  Memcached *ptr = memcached2Memcached(shell);\n  return mget_by_key_real(ptr, group_key, group_key_length, keys, key_length, number_of_keys, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "MEMCACHED_NOT_SUPPORTED",
            "MEMCACHED_AT",
            "memcached_literal_param(\n            \"ASCII protocol is not supported for memcached_mget_execute_by_key()\")"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"ASCII protocol is not supported for memcached_mget_execute_by_key()\""
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_binary",
          "args": [
            "ptr"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_udp",
          "args": [
            "ptr"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = initialize_query(ptr, false)"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_query",
          "args": [
            "ptr",
            "false"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/initialize_query.cc",
          "lines": "18-39",
          "snippet": "memcached_return_t initialize_query(Memcached *self, bool increment_query_id) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (increment_query_id) {\n    self->query_id++;\n  }\n\n  if (self->state.is_time_for_rebuild) {\n    memcached_reset(self);\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return memcached_set_error(*self, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  memcached_error_free(*self);\n  memcached_result_reset(&self->result);\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t initialize_query(Memcached *self, bool increment_query_id) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (increment_query_id) {\n    self->query_id++;\n  }\n\n  if (self->state.is_time_for_rebuild) {\n    memcached_reset(self);\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return memcached_set_error(*self, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  memcached_error_free(*self);\n  memcached_result_reset(&self->result);\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_mget_execute_by_key(memcached_st *shell, const char *group_key,\n                                                 size_t group_key_length, const char *const *keys,\n                                                 const size_t *key_length, size_t number_of_keys,\n                                                 memcached_execute_fn *callback, void *context,\n                                                 unsigned int number_of_callbacks) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, false))) {\n    return rc;\n  }\n\n  if (memcached_is_udp(ptr)) {\n    return memcached_set_error(*ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  if (memcached_is_binary(ptr) == false) {\n    return memcached_set_error(\n        *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"ASCII protocol is not supported for memcached_mget_execute_by_key()\"));\n  }\n\n  memcached_callback_st *original_callbacks = ptr->callbacks;\n  memcached_callback_st cb = {callback, context, number_of_callbacks};\n\n  ptr->callbacks = &cb;\n  rc = memcached_mget_by_key(ptr, group_key, group_key_length, keys, key_length, number_of_keys);\n  ptr->callbacks = original_callbacks;\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_mget_execute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/get.cc",
    "lines": "303-309",
    "snippet": "memcached_return_t memcached_mget_execute(memcached_st *ptr, const char *const *keys,\n                                          const size_t *key_length, size_t number_of_keys,\n                                          memcached_execute_fn *callback, void *context,\n                                          unsigned int number_of_callbacks) {\n  return memcached_mget_execute_by_key(ptr, NULL, 0, keys, key_length, number_of_keys, callback,\n                                       context, number_of_callbacks);\n}",
    "includes": [
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_mget_execute_by_key",
          "args": [
            "ptr",
            "NULL",
            "0",
            "keys",
            "key_length",
            "number_of_keys",
            "callback",
            "context",
            "number_of_callbacks"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_mget_execute_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/get.cc",
          "lines": "311-341",
          "snippet": "memcached_return_t memcached_mget_execute_by_key(memcached_st *shell, const char *group_key,\n                                                 size_t group_key_length, const char *const *keys,\n                                                 const size_t *key_length, size_t number_of_keys,\n                                                 memcached_execute_fn *callback, void *context,\n                                                 unsigned int number_of_callbacks) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, false))) {\n    return rc;\n  }\n\n  if (memcached_is_udp(ptr)) {\n    return memcached_set_error(*ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  if (memcached_is_binary(ptr) == false) {\n    return memcached_set_error(\n        *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"ASCII protocol is not supported for memcached_mget_execute_by_key()\"));\n  }\n\n  memcached_callback_st *original_callbacks = ptr->callbacks;\n  memcached_callback_st cb = {callback, context, number_of_callbacks};\n\n  ptr->callbacks = &cb;\n  rc = memcached_mget_by_key(ptr, group_key, group_key_length, keys, key_length, number_of_keys);\n  ptr->callbacks = original_callbacks;\n\n  return rc;\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_mget_execute_by_key(memcached_st *shell, const char *group_key,\n                                                 size_t group_key_length, const char *const *keys,\n                                                 const size_t *key_length, size_t number_of_keys,\n                                                 memcached_execute_fn *callback, void *context,\n                                                 unsigned int number_of_callbacks) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, false))) {\n    return rc;\n  }\n\n  if (memcached_is_udp(ptr)) {\n    return memcached_set_error(*ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  if (memcached_is_binary(ptr) == false) {\n    return memcached_set_error(\n        *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"ASCII protocol is not supported for memcached_mget_execute_by_key()\"));\n  }\n\n  memcached_callback_st *original_callbacks = ptr->callbacks;\n  memcached_callback_st cb = {callback, context, number_of_callbacks};\n\n  ptr->callbacks = &cb;\n  rc = memcached_mget_by_key(ptr, group_key, group_key_length, keys, key_length, number_of_keys);\n  ptr->callbacks = original_callbacks;\n\n  return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_mget_execute(memcached_st *ptr, const char *const *keys,\n                                          const size_t *key_length, size_t number_of_keys,\n                                          memcached_execute_fn *callback, void *context,\n                                          unsigned int number_of_callbacks) {\n  return memcached_mget_execute_by_key(ptr, NULL, 0, keys, key_length, number_of_keys, callback,\n                                       context, number_of_callbacks);\n}"
  },
  {
    "function_name": "memcached_mget_by_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/get.cc",
    "lines": "296-301",
    "snippet": "memcached_return_t memcached_mget_by_key(memcached_st *shell, const char *group_key,\n                                         size_t group_key_length, const char *const *keys,\n                                         const size_t *key_length, size_t number_of_keys) {\n  Memcached *ptr = memcached2Memcached(shell);\n  return mget_by_key_real(ptr, group_key, group_key_length, keys, key_length, number_of_keys, true);\n}",
    "includes": [
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mget_by_key_real",
          "args": [
            "ptr",
            "group_key",
            "group_key_length",
            "keys",
            "key_length",
            "number_of_keys",
            "true"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "mget_by_key_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/get.cc",
          "lines": "136-294",
          "snippet": "static memcached_return_t mget_by_key_real(memcached_st *ptr, const char *group_key,\n                                           size_t group_key_length, const char *const *keys,\n                                             const size_t *key_length, size_t number_of_keys,\n                                             const bool mget_mode) {\n  bool failures_occured_in_sending = false;\n  const char *get_command = \"get\";\n  uint8_t get_command_length = 3;\n  unsigned int master_server_key = (unsigned int) -1; /* 0 is a valid server id! */\n\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_is_udp(ptr)) {\n    return memcached_set_error(*ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  LIBMEMCACHED_MEMCACHED_MGET_START();\n\n  if (number_of_keys == 0) {\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Numbers of keys provided was zero\"));\n  }\n\n  if (memcached_failed((rc = memcached_key_test(*ptr, keys, key_length, number_of_keys)))) {\n    assert(memcached_last_error(ptr) == rc);\n\n    return rc;\n  }\n\n  bool is_group_key_set = false;\n  if (group_key and group_key_length) {\n    master_server_key =\n        memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n    is_group_key_set = true;\n  }\n\n  /*\n    Here is where we pay for the non-block API. We need to remove any data sitting\n    in the queue before we start our get.\n\n    It might be optimum to bounce the connection if count > some number.\n  */\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n    if (instance->response_count()) {\n      char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n\n      if (ptr->flags.no_block || ptr->flags.buffer_requests) {\n        memcached_io_write(instance);\n      }\n\n      while (instance->response_count()) {\n        (void) memcached_response(instance, buffer, MEMCACHED_DEFAULT_COMMAND_SIZE, &ptr->result);\n      }\n    }\n  }\n\n  if (memcached_is_binary(ptr)) {\n    return binary_mget_by_key(ptr, master_server_key, is_group_key_set, keys, key_length,\n                              number_of_keys, mget_mode);\n  }\n\n  if (ptr->flags.support_cas) {\n    get_command = \"gets\";\n    get_command_length = 4;\n  }\n\n  /*\n    If a server fails we warn about errors and start all over with sending keys\n    to the server.\n  */\n  WATCHPOINT_ASSERT(rc == MEMCACHED_SUCCESS);\n  size_t hosts_connected = 0;\n  for (uint32_t x = 0; x < number_of_keys; x++) {\n    uint32_t server_key;\n\n    if (is_group_key_set) {\n      server_key = master_server_key;\n    } else {\n      server_key = memcached_generate_hash_with_redistribution(ptr, keys[x], key_length[x]);\n    }\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n    libmemcached_io_vector_st vector[] = {\n        {get_command, get_command_length},\n        {memcached_literal_param(\" \")},\n        {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n        {keys[x], key_length[x]}};\n\n    if (instance->response_count() == 0) {\n      rc = memcached_connect(instance);\n\n      if (memcached_failed(rc)) {\n        memcached_set_error(*instance, rc, MEMCACHED_AT);\n        continue;\n      }\n      hosts_connected++;\n\n      if ((memcached_io_writev(instance, vector, 1, false)) == false) {\n        failures_occured_in_sending = true;\n        continue;\n      }\n      WATCHPOINT_ASSERT(instance->cursor_active_ == 0);\n      memcached_instance_response_increment(instance);\n      WATCHPOINT_ASSERT(instance->cursor_active_ == 1);\n    }\n\n    {\n      if ((memcached_io_writev(instance, (vector + 1), 3, false)) == false) {\n        memcached_instance_response_reset(instance);\n        failures_occured_in_sending = true;\n        continue;\n      }\n    }\n  }\n\n  if (hosts_connected == 0) {\n    LIBMEMCACHED_MEMCACHED_MGET_END();\n\n    if (memcached_failed(rc)) {\n      return rc;\n    }\n\n    return memcached_set_error(*ptr, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  /*\n    Should we muddle on if some servers are dead?\n  */\n  bool success_happened = false;\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n    if (instance->response_count()) {\n      /* We need to do something about non-connnected hosts in the future */\n      if ((memcached_io_write(instance, \"\\r\\n\", 2, true)) == -1) {\n        failures_occured_in_sending = true;\n      } else {\n        success_happened = true;\n      }\n    }\n  }\n\n  LIBMEMCACHED_MEMCACHED_MGET_END();\n\n  if (failures_occured_in_sending and success_happened) {\n    return MEMCACHED_SOME_ERRORS;\n  }\n\n  if (success_happened) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  return MEMCACHED_FAILURE; // Complete failure occurred\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t mget_by_key_real(memcached_st *ptr, const char *group_key,\n                                             size_t group_key_length, const char *const *keys,\n                                             const size_t *key_length, size_t number_of_keys,\n                                             const bool mget_mode);",
            "static memcached_return_t binary_mget_by_key(memcached_st *ptr, const uint32_t master_server_key,\n                                             const bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t mget_by_key_real(memcached_st *ptr, const char *group_key,\n                                             size_t group_key_length, const char *const *keys,\n                                             const size_t *key_length, size_t number_of_keys,\n                                             const bool mget_mode);\nstatic memcached_return_t binary_mget_by_key(memcached_st *ptr, const uint32_t master_server_key,\n                                             const bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode);\n\nstatic memcached_return_t mget_by_key_real(memcached_st *ptr, const char *group_key,\n                                           size_t group_key_length, const char *const *keys,\n                                             const size_t *key_length, size_t number_of_keys,\n                                             const bool mget_mode) {\n  bool failures_occured_in_sending = false;\n  const char *get_command = \"get\";\n  uint8_t get_command_length = 3;\n  unsigned int master_server_key = (unsigned int) -1; /* 0 is a valid server id! */\n\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_is_udp(ptr)) {\n    return memcached_set_error(*ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  LIBMEMCACHED_MEMCACHED_MGET_START();\n\n  if (number_of_keys == 0) {\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Numbers of keys provided was zero\"));\n  }\n\n  if (memcached_failed((rc = memcached_key_test(*ptr, keys, key_length, number_of_keys)))) {\n    assert(memcached_last_error(ptr) == rc);\n\n    return rc;\n  }\n\n  bool is_group_key_set = false;\n  if (group_key and group_key_length) {\n    master_server_key =\n        memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n    is_group_key_set = true;\n  }\n\n  /*\n    Here is where we pay for the non-block API. We need to remove any data sitting\n    in the queue before we start our get.\n\n    It might be optimum to bounce the connection if count > some number.\n  */\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n    if (instance->response_count()) {\n      char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n\n      if (ptr->flags.no_block || ptr->flags.buffer_requests) {\n        memcached_io_write(instance);\n      }\n\n      while (instance->response_count()) {\n        (void) memcached_response(instance, buffer, MEMCACHED_DEFAULT_COMMAND_SIZE, &ptr->result);\n      }\n    }\n  }\n\n  if (memcached_is_binary(ptr)) {\n    return binary_mget_by_key(ptr, master_server_key, is_group_key_set, keys, key_length,\n                              number_of_keys, mget_mode);\n  }\n\n  if (ptr->flags.support_cas) {\n    get_command = \"gets\";\n    get_command_length = 4;\n  }\n\n  /*\n    If a server fails we warn about errors and start all over with sending keys\n    to the server.\n  */\n  WATCHPOINT_ASSERT(rc == MEMCACHED_SUCCESS);\n  size_t hosts_connected = 0;\n  for (uint32_t x = 0; x < number_of_keys; x++) {\n    uint32_t server_key;\n\n    if (is_group_key_set) {\n      server_key = master_server_key;\n    } else {\n      server_key = memcached_generate_hash_with_redistribution(ptr, keys[x], key_length[x]);\n    }\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n    libmemcached_io_vector_st vector[] = {\n        {get_command, get_command_length},\n        {memcached_literal_param(\" \")},\n        {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n        {keys[x], key_length[x]}};\n\n    if (instance->response_count() == 0) {\n      rc = memcached_connect(instance);\n\n      if (memcached_failed(rc)) {\n        memcached_set_error(*instance, rc, MEMCACHED_AT);\n        continue;\n      }\n      hosts_connected++;\n\n      if ((memcached_io_writev(instance, vector, 1, false)) == false) {\n        failures_occured_in_sending = true;\n        continue;\n      }\n      WATCHPOINT_ASSERT(instance->cursor_active_ == 0);\n      memcached_instance_response_increment(instance);\n      WATCHPOINT_ASSERT(instance->cursor_active_ == 1);\n    }\n\n    {\n      if ((memcached_io_writev(instance, (vector + 1), 3, false)) == false) {\n        memcached_instance_response_reset(instance);\n        failures_occured_in_sending = true;\n        continue;\n      }\n    }\n  }\n\n  if (hosts_connected == 0) {\n    LIBMEMCACHED_MEMCACHED_MGET_END();\n\n    if (memcached_failed(rc)) {\n      return rc;\n    }\n\n    return memcached_set_error(*ptr, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  /*\n    Should we muddle on if some servers are dead?\n  */\n  bool success_happened = false;\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n    if (instance->response_count()) {\n      /* We need to do something about non-connnected hosts in the future */\n      if ((memcached_io_write(instance, \"\\r\\n\", 2, true)) == -1) {\n        failures_occured_in_sending = true;\n      } else {\n        success_happened = true;\n      }\n    }\n  }\n\n  LIBMEMCACHED_MEMCACHED_MGET_END();\n\n  if (failures_occured_in_sending and success_happened) {\n    return MEMCACHED_SOME_ERRORS;\n  }\n\n  if (success_happened) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  return MEMCACHED_FAILURE; // Complete failure occurred\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_mget_by_key(memcached_st *shell, const char *group_key,\n                                         size_t group_key_length, const char *const *keys,\n                                         const size_t *key_length, size_t number_of_keys) {\n  Memcached *ptr = memcached2Memcached(shell);\n  return mget_by_key_real(ptr, group_key, group_key_length, keys, key_length, number_of_keys, true);\n}"
  },
  {
    "function_name": "mget_by_key_real",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/get.cc",
    "lines": "136-294",
    "snippet": "static memcached_return_t mget_by_key_real(memcached_st *ptr, const char *group_key,\n                                           size_t group_key_length, const char *const *keys,\n                                             const size_t *key_length, size_t number_of_keys,\n                                             const bool mget_mode) {\n  bool failures_occured_in_sending = false;\n  const char *get_command = \"get\";\n  uint8_t get_command_length = 3;\n  unsigned int master_server_key = (unsigned int) -1; /* 0 is a valid server id! */\n\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_is_udp(ptr)) {\n    return memcached_set_error(*ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  LIBMEMCACHED_MEMCACHED_MGET_START();\n\n  if (number_of_keys == 0) {\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Numbers of keys provided was zero\"));\n  }\n\n  if (memcached_failed((rc = memcached_key_test(*ptr, keys, key_length, number_of_keys)))) {\n    assert(memcached_last_error(ptr) == rc);\n\n    return rc;\n  }\n\n  bool is_group_key_set = false;\n  if (group_key and group_key_length) {\n    master_server_key =\n        memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n    is_group_key_set = true;\n  }\n\n  /*\n    Here is where we pay for the non-block API. We need to remove any data sitting\n    in the queue before we start our get.\n\n    It might be optimum to bounce the connection if count > some number.\n  */\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n    if (instance->response_count()) {\n      char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n\n      if (ptr->flags.no_block || ptr->flags.buffer_requests) {\n        memcached_io_write(instance);\n      }\n\n      while (instance->response_count()) {\n        (void) memcached_response(instance, buffer, MEMCACHED_DEFAULT_COMMAND_SIZE, &ptr->result);\n      }\n    }\n  }\n\n  if (memcached_is_binary(ptr)) {\n    return binary_mget_by_key(ptr, master_server_key, is_group_key_set, keys, key_length,\n                              number_of_keys, mget_mode);\n  }\n\n  if (ptr->flags.support_cas) {\n    get_command = \"gets\";\n    get_command_length = 4;\n  }\n\n  /*\n    If a server fails we warn about errors and start all over with sending keys\n    to the server.\n  */\n  WATCHPOINT_ASSERT(rc == MEMCACHED_SUCCESS);\n  size_t hosts_connected = 0;\n  for (uint32_t x = 0; x < number_of_keys; x++) {\n    uint32_t server_key;\n\n    if (is_group_key_set) {\n      server_key = master_server_key;\n    } else {\n      server_key = memcached_generate_hash_with_redistribution(ptr, keys[x], key_length[x]);\n    }\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n    libmemcached_io_vector_st vector[] = {\n        {get_command, get_command_length},\n        {memcached_literal_param(\" \")},\n        {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n        {keys[x], key_length[x]}};\n\n    if (instance->response_count() == 0) {\n      rc = memcached_connect(instance);\n\n      if (memcached_failed(rc)) {\n        memcached_set_error(*instance, rc, MEMCACHED_AT);\n        continue;\n      }\n      hosts_connected++;\n\n      if ((memcached_io_writev(instance, vector, 1, false)) == false) {\n        failures_occured_in_sending = true;\n        continue;\n      }\n      WATCHPOINT_ASSERT(instance->cursor_active_ == 0);\n      memcached_instance_response_increment(instance);\n      WATCHPOINT_ASSERT(instance->cursor_active_ == 1);\n    }\n\n    {\n      if ((memcached_io_writev(instance, (vector + 1), 3, false)) == false) {\n        memcached_instance_response_reset(instance);\n        failures_occured_in_sending = true;\n        continue;\n      }\n    }\n  }\n\n  if (hosts_connected == 0) {\n    LIBMEMCACHED_MEMCACHED_MGET_END();\n\n    if (memcached_failed(rc)) {\n      return rc;\n    }\n\n    return memcached_set_error(*ptr, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  /*\n    Should we muddle on if some servers are dead?\n  */\n  bool success_happened = false;\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n    if (instance->response_count()) {\n      /* We need to do something about non-connnected hosts in the future */\n      if ((memcached_io_write(instance, \"\\r\\n\", 2, true)) == -1) {\n        failures_occured_in_sending = true;\n      } else {\n        success_happened = true;\n      }\n    }\n  }\n\n  LIBMEMCACHED_MEMCACHED_MGET_END();\n\n  if (failures_occured_in_sending and success_happened) {\n    return MEMCACHED_SOME_ERRORS;\n  }\n\n  if (success_happened) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  return MEMCACHED_FAILURE; // Complete failure occurred\n}",
    "includes": [
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_return_t mget_by_key_real(memcached_st *ptr, const char *group_key,\n                                             size_t group_key_length, const char *const *keys,\n                                             const size_t *key_length, size_t number_of_keys,\n                                             const bool mget_mode);",
      "static memcached_return_t binary_mget_by_key(memcached_st *ptr, const uint32_t master_server_key,\n                                             const bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_MGET_END",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_io_write",
          "args": [
            "instance",
            "\"\\r\\n\"",
            "2",
            "true"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "608-631",
          "snippet": "bool memcached_io_writev(memcached_instance_st *instance, libmemcached_io_vector_st vector[],\n                         const size_t number_of, const bool with_flush) {\n  ssize_t complete_total = 0;\n  ssize_t total = 0;\n\n  for (size_t x = 0; x < number_of; x++, vector++) {\n    complete_total += vector->length;\n    if (vector->length) {\n      size_t written;\n      if ((_io_write(instance, vector->buffer, vector->length, false, written)) == false) {\n        return false;\n      }\n      total += written;\n    }\n  }\n\n  if (with_flush) {\n    if (memcached_io_write(instance) == false) {\n      return false;\n    }\n  }\n\n  return (complete_total == total);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_io_writev(memcached_instance_st *instance, libmemcached_io_vector_st vector[],\n                         const size_t number_of, const bool with_flush) {\n  ssize_t complete_total = 0;\n  ssize_t total = 0;\n\n  for (size_t x = 0; x < number_of; x++, vector++) {\n    complete_total += vector->length;\n    if (vector->length) {\n      size_t written;\n      if ((_io_write(instance, vector->buffer, vector->length, false, written)) == false) {\n        return false;\n      }\n      total += written;\n    }\n  }\n\n  if (with_flush) {\n    if (memcached_io_write(instance) == false) {\n      return false;\n    }\n  }\n\n  return (complete_total == total);\n}"
        }
      },
      {
        "call_info": {
          "callee": "instance->response_count",
          "args": [],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "response_count",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.hpp",
          "lines": "62-62",
          "snippet": "uint32_t response_count() const { return cursor_active_; }",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#    include <netdb.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "memcached_return_t memcached_instance_push(memcached_st *ptr, const memcached_instance_st *,\n                                           uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#    include <netdb.h>\n\nmemcached_return_t memcached_instance_push(memcached_st *ptr, const memcached_instance_st *,\n                                           uint32_t);\n\nmemcached_instance_st {\n  uint32_t response_count() const { return cursor_active_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "ptr",
            "x"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "ptr"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "MEMCACHED_NO_SERVERS",
            "MEMCACHED_AT"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_MGET_END",
          "args": [],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_response_reset",
          "args": [
            "instance"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "instance->cursor_active_ == 1"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_response_increment",
          "args": [
            "instance"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "instance->cursor_active_ == 0"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_connect",
          "args": [
            "instance"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
          "lines": "598-600",
          "snippet": "memcached_return_t memcached_connect(memcached_instance_st *server) {\n  return _memcached_connect(server, true);\n}",
          "includes": [
            "#include <cassert>",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_connect(memcached_instance_st *server) {\n  return _memcached_connect(server, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_array_size",
          "args": [
            "ptr->_namespace"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_array_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/array.cc",
          "lines": "78-84",
          "snippet": "size_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"libmemcached/common.h\"\n\nsize_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_array_string",
          "args": [
            "ptr->_namespace"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\" \""
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "ptr",
            "server_key"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_generate_hash_with_redistribution",
          "args": [
            "ptr",
            "keys[x]",
            "key_length[x]"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_generate_hash_with_redistribution",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
          "lines": "109-116",
          "snippet": "uint32_t memcached_generate_hash_with_redistribution(memcached_st *ptr, const char *key,\n                                                     size_t key_length) {\n  uint32_t hash = _generate_hash_wrapper(ptr, key, key_length);\n\n  _regen_for_auto_eject(ptr);\n\n  return dispatch_host(ptr, hash);\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nuint32_t memcached_generate_hash_with_redistribution(memcached_st *ptr, const char *key,\n                                                     size_t key_length) {\n  uint32_t hash = _generate_hash_wrapper(ptr, key, key_length);\n\n  _regen_for_auto_eject(ptr);\n\n  return dispatch_host(ptr, hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "rc == MEMCACHED_SUCCESS"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "binary_mget_by_key",
          "args": [
            "ptr",
            "master_server_key",
            "is_group_key_set",
            "keys",
            "key_length",
            "number_of_keys",
            "mget_mode"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "binary_mget_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/get.cc",
          "lines": "547-583",
          "snippet": "static memcached_return_t binary_mget_by_key(memcached_st *ptr, const uint32_t master_server_key,\n                                             bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode) {\n  if (ptr->number_of_replicas == 0) {\n    return simple_binary_mget(ptr, master_server_key, is_group_key_set, keys, key_length,\n                              number_of_keys, mget_mode);\n  }\n\n  uint32_t *hash = libmemcached_xvalloc(ptr, number_of_keys, uint32_t);\n  bool *dead_servers = libmemcached_xcalloc(ptr, memcached_server_count(ptr), bool);\n\n  if (hash == NULL or dead_servers == NULL) {\n    libmemcached_free(ptr, hash);\n    libmemcached_free(ptr, dead_servers);\n    return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n  }\n\n  if (is_group_key_set) {\n    for (size_t x = 0; x < number_of_keys; x++) {\n      hash[x] = master_server_key;\n    }\n  } else {\n    for (size_t x = 0; x < number_of_keys; x++) {\n      hash[x] = memcached_generate_hash_with_redistribution(ptr, keys[x], key_length[x]);\n    }\n  }\n\n  memcached_return_t rc =\n      replication_binary_mget(ptr, hash, dead_servers, keys, key_length, number_of_keys);\n\n  WATCHPOINT_IFERROR(rc);\n  libmemcached_free(ptr, hash);\n  libmemcached_free(ptr, dead_servers);\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t mget_by_key_real(memcached_st *ptr, const char *group_key,\n                                             size_t group_key_length, const char *const *keys,\n                                             const size_t *key_length, size_t number_of_keys,\n                                             const bool mget_mode);",
            "static memcached_return_t binary_mget_by_key(memcached_st *ptr, const uint32_t master_server_key,\n                                             const bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t mget_by_key_real(memcached_st *ptr, const char *group_key,\n                                             size_t group_key_length, const char *const *keys,\n                                             const size_t *key_length, size_t number_of_keys,\n                                             const bool mget_mode);\nstatic memcached_return_t binary_mget_by_key(memcached_st *ptr, const uint32_t master_server_key,\n                                             const bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode);\n\nstatic memcached_return_t binary_mget_by_key(memcached_st *ptr, const uint32_t master_server_key,\n                                             bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode) {\n  if (ptr->number_of_replicas == 0) {\n    return simple_binary_mget(ptr, master_server_key, is_group_key_set, keys, key_length,\n                              number_of_keys, mget_mode);\n  }\n\n  uint32_t *hash = libmemcached_xvalloc(ptr, number_of_keys, uint32_t);\n  bool *dead_servers = libmemcached_xcalloc(ptr, memcached_server_count(ptr), bool);\n\n  if (hash == NULL or dead_servers == NULL) {\n    libmemcached_free(ptr, hash);\n    libmemcached_free(ptr, dead_servers);\n    return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n  }\n\n  if (is_group_key_set) {\n    for (size_t x = 0; x < number_of_keys; x++) {\n      hash[x] = master_server_key;\n    }\n  } else {\n    for (size_t x = 0; x < number_of_keys; x++) {\n      hash[x] = memcached_generate_hash_with_redistribution(ptr, keys[x], key_length[x]);\n    }\n  }\n\n  memcached_return_t rc =\n      replication_binary_mget(ptr, hash, dead_servers, keys, key_length, number_of_keys);\n\n  WATCHPOINT_IFERROR(rc);\n  libmemcached_free(ptr, hash);\n  libmemcached_free(ptr, dead_servers);\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_binary",
          "args": [
            "ptr"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_response",
          "args": [
            "instance",
            "buffer",
            "MEMCACHED_DEFAULT_COMMAND_SIZE",
            "&ptr->result"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
          "lines": "789-834",
          "snippet": "memcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_io_write",
          "args": [
            "instance"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "592-595",
          "snippet": "bool memcached_io_write(memcached_instance_st *instance) {\n  size_t written;\n  return _io_write(instance, NULL, 0, true, written);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_io_write(memcached_instance_st *instance) {\n  size_t written;\n  return _io_write(instance, NULL, 0, true, written);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "ptr",
            "x"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "memcached_last_error(ptr) == rc"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error",
          "args": [
            "ptr"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_last_error_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "500-511",
          "snippet": "int memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nint memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "(rc = memcached_key_test(*ptr, keys, key_length, number_of_keys))"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_key_test",
          "args": [
            "*ptr",
            "keys",
            "key_length",
            "number_of_keys"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_key_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/key.cc",
          "lines": "43-81",
          "snippet": "memcached_return_t memcached_key_test(memcached_st &memc, const char *const *keys,\n                                      const size_t *key_length, size_t number_of_keys) {\n  if (number_of_keys == 0) {\n    return memcached_set_error(memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Numbers of keys provided was zero\"));\n  }\n\n  if (keys == NULL or key_length == NULL) {\n    return memcached_set_error(memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n                               memcached_literal_param(\"Key was NULL or length of key was zero.\"));\n  }\n\n  const bool is_binary = memcached_flag(memc, MEMCACHED_FLAG_BINARY_PROTOCOL);\n\n  // If we don't need to verify the key, or we are using the binary protoocol,\n  // we just check the size of the key\n  for (size_t x = 0; x < number_of_keys; ++x) {\n    // We should set binary key, but the memcached server is broken for\n    // longer keys at the moment.\n    memcached_return_t rc =\n        memcached_validate_key_length(*(key_length + x), false /* memc.flags.binary_protocol */);\n    if (memcached_failed(rc)) {\n      return memcached_set_error(memc, rc, MEMCACHED_AT,\n                                 memcached_literal_param(\"Key provided was too long.\"));\n    }\n\n    if (memc.flags.verify_key and is_binary == false) {\n      for (size_t y = 0; y < *(key_length + x); ++y) {\n        if ((isgraph(keys[x][y])) == 0) {\n          return memcached_set_error(\n              memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n              memcached_literal_param(\"Key provided had invalid character.\"));\n        }\n      }\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_key_test(memcached_st &memc, const char *const *keys,\n                                      const size_t *key_length, size_t number_of_keys) {\n  if (number_of_keys == 0) {\n    return memcached_set_error(memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Numbers of keys provided was zero\"));\n  }\n\n  if (keys == NULL or key_length == NULL) {\n    return memcached_set_error(memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n                               memcached_literal_param(\"Key was NULL or length of key was zero.\"));\n  }\n\n  const bool is_binary = memcached_flag(memc, MEMCACHED_FLAG_BINARY_PROTOCOL);\n\n  // If we don't need to verify the key, or we are using the binary protoocol,\n  // we just check the size of the key\n  for (size_t x = 0; x < number_of_keys; ++x) {\n    // We should set binary key, but the memcached server is broken for\n    // longer keys at the moment.\n    memcached_return_t rc =\n        memcached_validate_key_length(*(key_length + x), false /* memc.flags.binary_protocol */);\n    if (memcached_failed(rc)) {\n      return memcached_set_error(memc, rc, MEMCACHED_AT,\n                                 memcached_literal_param(\"Key provided was too long.\"));\n    }\n\n    if (memc.flags.verify_key and is_binary == false) {\n      for (size_t y = 0; y < *(key_length + x); ++y) {\n        if ((isgraph(keys[x][y])) == 0) {\n          return memcached_set_error(\n              memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n              memcached_literal_param(\"Key provided had invalid character.\"));\n        }\n      }\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Numbers of keys provided was zero\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_MGET_START",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_udp",
          "args": [
            "ptr"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = initialize_query(ptr, true)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_query",
          "args": [
            "ptr",
            "true"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/initialize_query.cc",
          "lines": "18-39",
          "snippet": "memcached_return_t initialize_query(Memcached *self, bool increment_query_id) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (increment_query_id) {\n    self->query_id++;\n  }\n\n  if (self->state.is_time_for_rebuild) {\n    memcached_reset(self);\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return memcached_set_error(*self, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  memcached_error_free(*self);\n  memcached_result_reset(&self->result);\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t initialize_query(Memcached *self, bool increment_query_id) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (increment_query_id) {\n    self->query_id++;\n  }\n\n  if (self->state.is_time_for_rebuild) {\n    memcached_reset(self);\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return memcached_set_error(*self, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  memcached_error_free(*self);\n  memcached_result_reset(&self->result);\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t mget_by_key_real(memcached_st *ptr, const char *group_key,\n                                             size_t group_key_length, const char *const *keys,\n                                             const size_t *key_length, size_t number_of_keys,\n                                             const bool mget_mode);\nstatic memcached_return_t binary_mget_by_key(memcached_st *ptr, const uint32_t master_server_key,\n                                             const bool is_group_key_set, const char *const *keys,\n                                             const size_t *key_length, const size_t number_of_keys,\n                                             const bool mget_mode);\n\nstatic memcached_return_t mget_by_key_real(memcached_st *ptr, const char *group_key,\n                                           size_t group_key_length, const char *const *keys,\n                                             const size_t *key_length, size_t number_of_keys,\n                                             const bool mget_mode) {\n  bool failures_occured_in_sending = false;\n  const char *get_command = \"get\";\n  uint8_t get_command_length = 3;\n  unsigned int master_server_key = (unsigned int) -1; /* 0 is a valid server id! */\n\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_is_udp(ptr)) {\n    return memcached_set_error(*ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  LIBMEMCACHED_MEMCACHED_MGET_START();\n\n  if (number_of_keys == 0) {\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Numbers of keys provided was zero\"));\n  }\n\n  if (memcached_failed((rc = memcached_key_test(*ptr, keys, key_length, number_of_keys)))) {\n    assert(memcached_last_error(ptr) == rc);\n\n    return rc;\n  }\n\n  bool is_group_key_set = false;\n  if (group_key and group_key_length) {\n    master_server_key =\n        memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n    is_group_key_set = true;\n  }\n\n  /*\n    Here is where we pay for the non-block API. We need to remove any data sitting\n    in the queue before we start our get.\n\n    It might be optimum to bounce the connection if count > some number.\n  */\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n    if (instance->response_count()) {\n      char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n\n      if (ptr->flags.no_block || ptr->flags.buffer_requests) {\n        memcached_io_write(instance);\n      }\n\n      while (instance->response_count()) {\n        (void) memcached_response(instance, buffer, MEMCACHED_DEFAULT_COMMAND_SIZE, &ptr->result);\n      }\n    }\n  }\n\n  if (memcached_is_binary(ptr)) {\n    return binary_mget_by_key(ptr, master_server_key, is_group_key_set, keys, key_length,\n                              number_of_keys, mget_mode);\n  }\n\n  if (ptr->flags.support_cas) {\n    get_command = \"gets\";\n    get_command_length = 4;\n  }\n\n  /*\n    If a server fails we warn about errors and start all over with sending keys\n    to the server.\n  */\n  WATCHPOINT_ASSERT(rc == MEMCACHED_SUCCESS);\n  size_t hosts_connected = 0;\n  for (uint32_t x = 0; x < number_of_keys; x++) {\n    uint32_t server_key;\n\n    if (is_group_key_set) {\n      server_key = master_server_key;\n    } else {\n      server_key = memcached_generate_hash_with_redistribution(ptr, keys[x], key_length[x]);\n    }\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n    libmemcached_io_vector_st vector[] = {\n        {get_command, get_command_length},\n        {memcached_literal_param(\" \")},\n        {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n        {keys[x], key_length[x]}};\n\n    if (instance->response_count() == 0) {\n      rc = memcached_connect(instance);\n\n      if (memcached_failed(rc)) {\n        memcached_set_error(*instance, rc, MEMCACHED_AT);\n        continue;\n      }\n      hosts_connected++;\n\n      if ((memcached_io_writev(instance, vector, 1, false)) == false) {\n        failures_occured_in_sending = true;\n        continue;\n      }\n      WATCHPOINT_ASSERT(instance->cursor_active_ == 0);\n      memcached_instance_response_increment(instance);\n      WATCHPOINT_ASSERT(instance->cursor_active_ == 1);\n    }\n\n    {\n      if ((memcached_io_writev(instance, (vector + 1), 3, false)) == false) {\n        memcached_instance_response_reset(instance);\n        failures_occured_in_sending = true;\n        continue;\n      }\n    }\n  }\n\n  if (hosts_connected == 0) {\n    LIBMEMCACHED_MEMCACHED_MGET_END();\n\n    if (memcached_failed(rc)) {\n      return rc;\n    }\n\n    return memcached_set_error(*ptr, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  /*\n    Should we muddle on if some servers are dead?\n  */\n  bool success_happened = false;\n  for (uint32_t x = 0; x < memcached_server_count(ptr); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, x);\n\n    if (instance->response_count()) {\n      /* We need to do something about non-connnected hosts in the future */\n      if ((memcached_io_write(instance, \"\\r\\n\", 2, true)) == -1) {\n        failures_occured_in_sending = true;\n      } else {\n        success_happened = true;\n      }\n    }\n  }\n\n  LIBMEMCACHED_MEMCACHED_MGET_END();\n\n  if (failures_occured_in_sending and success_happened) {\n    return MEMCACHED_SOME_ERRORS;\n  }\n\n  if (success_happened) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  return MEMCACHED_FAILURE; // Complete failure occurred\n}"
  },
  {
    "function_name": "memcached_mget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/get.cc",
    "lines": "126-129",
    "snippet": "memcached_return_t memcached_mget(memcached_st *ptr, const char *const *keys,\n                                  const size_t *key_length, size_t number_of_keys) {\n  return memcached_mget_by_key(ptr, NULL, 0, keys, key_length, number_of_keys);\n}",
    "includes": [
      "#include \"p9y/random.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_mget_by_key",
          "args": [
            "ptr",
            "NULL",
            "0",
            "keys",
            "key_length",
            "number_of_keys"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_mget_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/get.cc",
          "lines": "296-301",
          "snippet": "memcached_return_t memcached_mget_by_key(memcached_st *shell, const char *group_key,\n                                         size_t group_key_length, const char *const *keys,\n                                         const size_t *key_length, size_t number_of_keys) {\n  Memcached *ptr = memcached2Memcached(shell);\n  return mget_by_key_real(ptr, group_key, group_key_length, keys, key_length, number_of_keys, true);\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_mget_by_key(memcached_st *shell, const char *group_key,\n                                         size_t group_key_length, const char *const *keys,\n                                         const size_t *key_length, size_t number_of_keys) {\n  Memcached *ptr = memcached2Memcached(shell);\n  return mget_by_key_real(ptr, group_key, group_key_length, keys, key_length, number_of_keys, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_mget(memcached_st *ptr, const char *const *keys,\n                                  const size_t *key_length, size_t number_of_keys) {\n  return memcached_mget_by_key(ptr, NULL, 0, keys, key_length, number_of_keys);\n}"
  }
]