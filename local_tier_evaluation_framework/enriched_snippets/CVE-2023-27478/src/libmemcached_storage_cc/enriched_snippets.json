[
  {
    "function_name": "memcached_cas_by_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
    "lines": "440-446",
    "snippet": "memcached_return_t memcached_cas_by_key(memcached_st *ptr, const char *group_key,\n                                        size_t group_key_length, const char *key, size_t key_length,\n                                        const char *value, size_t value_length, time_t expiration,\n                                        uint32_t flags, uint64_t cas) {\n  return memcached_send(ptr, group_key, group_key_length, key, key_length, value, value_length,\n                        expiration, flags, cas, CAS_OP);\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_send",
          "args": [
            "ptr",
            "group_key",
            "group_key_length",
            "key",
            "key_length",
            "value",
            "value_length",
            "expiration",
            "flags",
            "cas",
            "CAS_OP"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "268-323",
          "snippet": "static inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_cas_by_key(memcached_st *ptr, const char *group_key,\n                                        size_t group_key_length, const char *key, size_t key_length,\n                                        const char *value, size_t value_length, time_t expiration,\n                                        uint32_t flags, uint64_t cas) {\n  return memcached_send(ptr, group_key, group_key_length, key, key_length, value, value_length,\n                        expiration, flags, cas, CAS_OP);\n}"
  },
  {
    "function_name": "memcached_append_by_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
    "lines": "432-438",
    "snippet": "memcached_return_t memcached_append_by_key(memcached_st *ptr, const char *group_key,\n                                           size_t group_key_length, const char *key,\n                                           size_t key_length, const char *value,\n                                           size_t value_length, time_t expiration, uint32_t flags) {\n  return memcached_send(ptr, group_key, group_key_length, key, key_length, value, value_length,\n                        expiration, flags, 0, APPEND_OP);\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_send",
          "args": [
            "ptr",
            "group_key",
            "group_key_length",
            "key",
            "key_length",
            "value",
            "value_length",
            "expiration",
            "flags",
            "0",
            "APPEND_OP"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "268-323",
          "snippet": "static inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_append_by_key(memcached_st *ptr, const char *group_key,\n                                           size_t group_key_length, const char *key,\n                                           size_t key_length, const char *value,\n                                           size_t value_length, time_t expiration, uint32_t flags) {\n  return memcached_send(ptr, group_key, group_key_length, key, key_length, value, value_length,\n                        expiration, flags, 0, APPEND_OP);\n}"
  },
  {
    "function_name": "memcached_prepend_by_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
    "lines": "423-430",
    "snippet": "memcached_return_t memcached_prepend_by_key(memcached_st *ptr, const char *group_key,\n                                            size_t group_key_length, const char *key,\n                                            size_t key_length, const char *value,\n                                            size_t value_length, time_t expiration,\n                                            uint32_t flags) {\n  return memcached_send(ptr, group_key, group_key_length, key, key_length, value, value_length,\n                        expiration, flags, 0, PREPEND_OP);\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_send",
          "args": [
            "ptr",
            "group_key",
            "group_key_length",
            "key",
            "key_length",
            "value",
            "value_length",
            "expiration",
            "flags",
            "0",
            "PREPEND_OP"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "268-323",
          "snippet": "static inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_prepend_by_key(memcached_st *ptr, const char *group_key,\n                                            size_t group_key_length, const char *key,\n                                            size_t key_length, const char *value,\n                                            size_t value_length, time_t expiration,\n                                            uint32_t flags) {\n  return memcached_send(ptr, group_key, group_key_length, key, key_length, value, value_length,\n                        expiration, flags, 0, PREPEND_OP);\n}"
  },
  {
    "function_name": "memcached_replace_by_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
    "lines": "410-421",
    "snippet": "memcached_return_t memcached_replace_by_key(memcached_st *ptr, const char *group_key,\n                                            size_t group_key_length, const char *key,\n                                            size_t key_length, const char *value,\n                                            size_t value_length, time_t expiration,\n                                            uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_REPLACE_START();\n  rc = memcached_send(ptr, group_key, group_key_length, key, key_length, value, value_length,\n                      expiration, flags, 0, REPLACE_OP);\n  LIBMEMCACHED_MEMCACHED_REPLACE_END();\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_REPLACE_END",
          "args": [],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_send",
          "args": [
            "ptr",
            "group_key",
            "group_key_length",
            "key",
            "key_length",
            "value",
            "value_length",
            "expiration",
            "flags",
            "0",
            "REPLACE_OP"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "268-323",
          "snippet": "static inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_REPLACE_START",
          "args": [],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_replace_by_key(memcached_st *ptr, const char *group_key,\n                                            size_t group_key_length, const char *key,\n                                            size_t key_length, const char *value,\n                                            size_t value_length, time_t expiration,\n                                            uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_REPLACE_START();\n  rc = memcached_send(ptr, group_key, group_key_length, key, key_length, value, value_length,\n                      expiration, flags, 0, REPLACE_OP);\n  LIBMEMCACHED_MEMCACHED_REPLACE_END();\n  return rc;\n}"
  },
  {
    "function_name": "memcached_add_by_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
    "lines": "398-408",
    "snippet": "memcached_return_t memcached_add_by_key(memcached_st *ptr, const char *group_key,\n                                        size_t group_key_length, const char *key, size_t key_length,\n                                        const char *value, size_t value_length, time_t expiration,\n                                        uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_ADD_START();\n  rc = memcached_send(ptr, group_key, group_key_length, key, key_length, value, value_length,\n                      expiration, flags, 0, ADD_OP);\n  LIBMEMCACHED_MEMCACHED_ADD_END();\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_ADD_END",
          "args": [],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_send",
          "args": [
            "ptr",
            "group_key",
            "group_key_length",
            "key",
            "key_length",
            "value",
            "value_length",
            "expiration",
            "flags",
            "0",
            "ADD_OP"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "268-323",
          "snippet": "static inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_ADD_START",
          "args": [],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_add_by_key(memcached_st *ptr, const char *group_key,\n                                        size_t group_key_length, const char *key, size_t key_length,\n                                        const char *value, size_t value_length, time_t expiration,\n                                        uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_ADD_START();\n  rc = memcached_send(ptr, group_key, group_key_length, key, key_length, value, value_length,\n                      expiration, flags, 0, ADD_OP);\n  LIBMEMCACHED_MEMCACHED_ADD_END();\n  return rc;\n}"
  },
  {
    "function_name": "memcached_set_by_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
    "lines": "386-396",
    "snippet": "memcached_return_t memcached_set_by_key(memcached_st *ptr, const char *group_key,\n                                        size_t group_key_length, const char *key, size_t key_length,\n                                        const char *value, size_t value_length, time_t expiration,\n                                        uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_SET_START();\n  rc = memcached_send(ptr, group_key, group_key_length, key, key_length, value, value_length,\n                      expiration, flags, 0, SET_OP);\n  LIBMEMCACHED_MEMCACHED_SET_END();\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_SET_END",
          "args": [],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_send",
          "args": [
            "ptr",
            "group_key",
            "group_key_length",
            "key",
            "key_length",
            "value",
            "value_length",
            "expiration",
            "flags",
            "0",
            "SET_OP"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "268-323",
          "snippet": "static inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_SET_START",
          "args": [],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_by_key(memcached_st *ptr, const char *group_key,\n                                        size_t group_key_length, const char *key, size_t key_length,\n                                        const char *value, size_t value_length, time_t expiration,\n                                        uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_SET_START();\n  rc = memcached_send(ptr, group_key, group_key_length, key, key_length, value, value_length,\n                      expiration, flags, 0, SET_OP);\n  LIBMEMCACHED_MEMCACHED_SET_END();\n  return rc;\n}"
  },
  {
    "function_name": "memcached_cas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
    "lines": "377-384",
    "snippet": "memcached_return_t memcached_cas(memcached_st *ptr, const char *key, size_t key_length,\n                                 const char *value, size_t value_length, time_t expiration,\n                                 uint32_t flags, uint64_t cas) {\n  memcached_return_t rc;\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      cas, CAS_OP);\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_send",
          "args": [
            "ptr",
            "key",
            "key_length",
            "key",
            "key_length",
            "value",
            "value_length",
            "expiration",
            "flags",
            "cas",
            "CAS_OP"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "268-323",
          "snippet": "static inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_cas(memcached_st *ptr, const char *key, size_t key_length,\n                                 const char *value, size_t value_length, time_t expiration,\n                                 uint32_t flags, uint64_t cas) {\n  memcached_return_t rc;\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      cas, CAS_OP);\n  return rc;\n}"
  },
  {
    "function_name": "memcached_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
    "lines": "368-375",
    "snippet": "memcached_return_t memcached_append(memcached_st *ptr, const char *key, size_t key_length,\n                                    const char *value, size_t value_length, time_t expiration,\n                                    uint32_t flags) {\n  memcached_return_t rc;\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      0, APPEND_OP);\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_send",
          "args": [
            "ptr",
            "key",
            "key_length",
            "key",
            "key_length",
            "value",
            "value_length",
            "expiration",
            "flags",
            "0",
            "APPEND_OP"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "268-323",
          "snippet": "static inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_append(memcached_st *ptr, const char *key, size_t key_length,\n                                    const char *value, size_t value_length, time_t expiration,\n                                    uint32_t flags) {\n  memcached_return_t rc;\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      0, APPEND_OP);\n  return rc;\n}"
  },
  {
    "function_name": "memcached_prepend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
    "lines": "359-366",
    "snippet": "memcached_return_t memcached_prepend(memcached_st *ptr, const char *key, size_t key_length,\n                                     const char *value, size_t value_length, time_t expiration,\n                                     uint32_t flags) {\n  memcached_return_t rc;\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      0, PREPEND_OP);\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_send",
          "args": [
            "ptr",
            "key",
            "key_length",
            "key",
            "key_length",
            "value",
            "value_length",
            "expiration",
            "flags",
            "0",
            "PREPEND_OP"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "268-323",
          "snippet": "static inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_prepend(memcached_st *ptr, const char *key, size_t key_length,\n                                     const char *value, size_t value_length, time_t expiration,\n                                     uint32_t flags) {\n  memcached_return_t rc;\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      0, PREPEND_OP);\n  return rc;\n}"
  },
  {
    "function_name": "memcached_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
    "lines": "348-357",
    "snippet": "memcached_return_t memcached_replace(memcached_st *ptr, const char *key, size_t key_length,\n                                     const char *value, size_t value_length, time_t expiration,\n                                     uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_REPLACE_START();\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      0, REPLACE_OP);\n  LIBMEMCACHED_MEMCACHED_REPLACE_END();\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_REPLACE_END",
          "args": [],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_send",
          "args": [
            "ptr",
            "key",
            "key_length",
            "key",
            "key_length",
            "value",
            "value_length",
            "expiration",
            "flags",
            "0",
            "REPLACE_OP"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "268-323",
          "snippet": "static inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_REPLACE_START",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_replace(memcached_st *ptr, const char *key, size_t key_length,\n                                     const char *value, size_t value_length, time_t expiration,\n                                     uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_REPLACE_START();\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      0, REPLACE_OP);\n  LIBMEMCACHED_MEMCACHED_REPLACE_END();\n  return rc;\n}"
  },
  {
    "function_name": "memcached_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
    "lines": "336-346",
    "snippet": "memcached_return_t memcached_add(memcached_st *ptr, const char *key, size_t key_length,\n                                 const char *value, size_t value_length, time_t expiration,\n                                 uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_ADD_START();\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      0, ADD_OP);\n\n  LIBMEMCACHED_MEMCACHED_ADD_END();\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_ADD_END",
          "args": [],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_send",
          "args": [
            "ptr",
            "key",
            "key_length",
            "key",
            "key_length",
            "value",
            "value_length",
            "expiration",
            "flags",
            "0",
            "ADD_OP"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "268-323",
          "snippet": "static inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_ADD_START",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_add(memcached_st *ptr, const char *key, size_t key_length,\n                                 const char *value, size_t value_length, time_t expiration,\n                                 uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_ADD_START();\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      0, ADD_OP);\n\n  LIBMEMCACHED_MEMCACHED_ADD_END();\n  return rc;\n}"
  },
  {
    "function_name": "memcached_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
    "lines": "325-334",
    "snippet": "memcached_return_t memcached_set(memcached_st *ptr, const char *key, size_t key_length,\n                                 const char *value, size_t value_length, time_t expiration,\n                                 uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_SET_START();\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      0, SET_OP);\n  LIBMEMCACHED_MEMCACHED_SET_END();\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_SET_END",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_send",
          "args": [
            "ptr",
            "key",
            "key_length",
            "key",
            "key_length",
            "value",
            "value_length",
            "expiration",
            "flags",
            "0",
            "SET_OP"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "268-323",
          "snippet": "static inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_SET_START",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set(memcached_st *ptr, const char *key, size_t key_length,\n                                 const char *value, size_t value_length, time_t expiration,\n                                 uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_SET_START();\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      0, SET_OP);\n  LIBMEMCACHED_MEMCACHED_SET_END();\n  return rc;\n}"
  },
  {
    "function_name": "memcached_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
    "lines": "268-323",
    "snippet": "static inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashkit_string_free",
          "args": [
            "destination"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "hashkit_string_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/string.cc",
          "lines": "139-148",
          "snippet": "void hashkit_string_free(hashkit_string_st *ptr) {\n  if (ptr == NULL) {\n    return;\n  }\n\n  if (ptr->string) {\n    free(ptr->string);\n  }\n  free(ptr);\n}",
          "includes": [
            "#include <cstring>",
            "#include <cassert>",
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstring>\n#include <cassert>\n#include \"libhashkit/common.h\"\n\nvoid hashkit_string_free(hashkit_string_st *ptr) {\n  if (ptr == NULL) {\n    return;\n  }\n\n  if (ptr->string) {\n    free(ptr->string);\n  }\n  free(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_send_ascii",
          "args": [
            "ptr",
            "instance",
            "key",
            "key_length",
            "value",
            "value_length",
            "expiration",
            "flags",
            "cas",
            "flush",
            "reply",
            "verb"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_send_ascii",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "179-266",
          "snippet": "static memcached_return_t\nmemcached_send_ascii(Memcached *ptr, memcached_instance_st *instance, const char *key,\n                     const size_t key_length, const char *value, const size_t value_length,\n                     const time_t expiration, const uint32_t flags, const uint64_t cas,\n                     const bool flush, const bool reply, const memcached_storage_action_t verb) {\n  char flags_buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1];\n  int flags_buffer_length = snprintf(flags_buffer, sizeof(flags_buffer), \" %u\", flags);\n  if (size_t(flags_buffer_length) >= sizeof(flags_buffer) or flags_buffer_length < 0) {\n    return memcached_set_error(\n        *instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n        memcached_literal_param(\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\"));\n  }\n\n  char expiration_buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1 + 1];\n  int expiration_buffer_length = snprintf(expiration_buffer, sizeof(expiration_buffer), \" %lld\",\n                                          (long long) expiration);\n  if (size_t(expiration_buffer_length) >= sizeof(expiration_buffer) or expiration_buffer_length < 0)\n  {\n    return memcached_set_error(\n        *instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n        memcached_literal_param(\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\"));\n  }\n\n  char value_buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1];\n  int value_buffer_length =\n      snprintf(value_buffer, sizeof(value_buffer), \" %llu\", (unsigned long long) value_length);\n  if (size_t(value_buffer_length) >= sizeof(value_buffer) or value_buffer_length < 0) {\n    return memcached_set_error(\n        *instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n        memcached_literal_param(\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\"));\n  }\n\n  char cas_buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1];\n  int cas_buffer_length = 0;\n  if (cas) {\n    cas_buffer_length = snprintf(cas_buffer, sizeof(cas_buffer), \" %llu\", (unsigned long long) cas);\n    if (size_t(cas_buffer_length) >= sizeof(cas_buffer) or cas_buffer_length < 0) {\n      return memcached_set_error(\n          *instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n          memcached_literal_param(\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\"));\n    }\n  }\n\n  libmemcached_io_vector_st vector[] = {\n      {NULL, 0},\n      {storage_op_string(verb), strlen(storage_op_string(verb))},\n      {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n      {key, key_length},\n      {flags_buffer, size_t(flags_buffer_length)},\n      {expiration_buffer, size_t(expiration_buffer_length)},\n      {value_buffer, size_t(value_buffer_length)},\n      {cas_buffer, size_t(cas_buffer_length)},\n      {\" noreply\", reply ? 0 : memcached_literal_param_size(\" noreply\")},\n      {memcached_literal_param(\"\\r\\n\")},\n      {value, value_length},\n      {memcached_literal_param(\"\\r\\n\")}};\n\n  /* Send command header */\n  memcached_return_t rc = memcached_vdo(instance, vector, 12, flush);\n\n  // If we should not reply, return with MEMCACHED_SUCCESS, unless error\n  if (reply == false) {\n    return memcached_success(rc) ? MEMCACHED_SUCCESS : rc;\n  }\n\n  if (flush == false) {\n    return memcached_success(rc) ? MEMCACHED_BUFFERED : rc;\n  }\n\n  if (rc == MEMCACHED_SUCCESS) {\n    char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n    rc = memcached_response(instance, buffer, sizeof(buffer), NULL);\n\n    if (rc == MEMCACHED_STORED) {\n      return MEMCACHED_SUCCESS;\n    }\n  }\n\n  assert(memcached_failed(rc));\n#if 0\n  if (memcached_has_error(ptr) == false)\n  {\n    return memcached_set_error(*ptr, rc, MEMCACHED_AT);\n  }\n#endif\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t\nmemcached_send_ascii(Memcached *ptr, memcached_instance_st *instance, const char *key,\n                     const size_t key_length, const char *value, const size_t value_length,\n                     const time_t expiration, const uint32_t flags, const uint64_t cas,\n                     const bool flush, const bool reply, const memcached_storage_action_t verb) {\n  char flags_buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1];\n  int flags_buffer_length = snprintf(flags_buffer, sizeof(flags_buffer), \" %u\", flags);\n  if (size_t(flags_buffer_length) >= sizeof(flags_buffer) or flags_buffer_length < 0) {\n    return memcached_set_error(\n        *instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n        memcached_literal_param(\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\"));\n  }\n\n  char expiration_buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1 + 1];\n  int expiration_buffer_length = snprintf(expiration_buffer, sizeof(expiration_buffer), \" %lld\",\n                                          (long long) expiration);\n  if (size_t(expiration_buffer_length) >= sizeof(expiration_buffer) or expiration_buffer_length < 0)\n  {\n    return memcached_set_error(\n        *instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n        memcached_literal_param(\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\"));\n  }\n\n  char value_buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1];\n  int value_buffer_length =\n      snprintf(value_buffer, sizeof(value_buffer), \" %llu\", (unsigned long long) value_length);\n  if (size_t(value_buffer_length) >= sizeof(value_buffer) or value_buffer_length < 0) {\n    return memcached_set_error(\n        *instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n        memcached_literal_param(\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\"));\n  }\n\n  char cas_buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1];\n  int cas_buffer_length = 0;\n  if (cas) {\n    cas_buffer_length = snprintf(cas_buffer, sizeof(cas_buffer), \" %llu\", (unsigned long long) cas);\n    if (size_t(cas_buffer_length) >= sizeof(cas_buffer) or cas_buffer_length < 0) {\n      return memcached_set_error(\n          *instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n          memcached_literal_param(\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\"));\n    }\n  }\n\n  libmemcached_io_vector_st vector[] = {\n      {NULL, 0},\n      {storage_op_string(verb), strlen(storage_op_string(verb))},\n      {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n      {key, key_length},\n      {flags_buffer, size_t(flags_buffer_length)},\n      {expiration_buffer, size_t(expiration_buffer_length)},\n      {value_buffer, size_t(value_buffer_length)},\n      {cas_buffer, size_t(cas_buffer_length)},\n      {\" noreply\", reply ? 0 : memcached_literal_param_size(\" noreply\")},\n      {memcached_literal_param(\"\\r\\n\")},\n      {value, value_length},\n      {memcached_literal_param(\"\\r\\n\")}};\n\n  /* Send command header */\n  memcached_return_t rc = memcached_vdo(instance, vector, 12, flush);\n\n  // If we should not reply, return with MEMCACHED_SUCCESS, unless error\n  if (reply == false) {\n    return memcached_success(rc) ? MEMCACHED_SUCCESS : rc;\n  }\n\n  if (flush == false) {\n    return memcached_success(rc) ? MEMCACHED_BUFFERED : rc;\n  }\n\n  if (rc == MEMCACHED_SUCCESS) {\n    char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n    rc = memcached_response(instance, buffer, sizeof(buffer), NULL);\n\n    if (rc == MEMCACHED_STORED) {\n      return MEMCACHED_SUCCESS;\n    }\n  }\n\n  assert(memcached_failed(rc));\n#if 0\n  if (memcached_has_error(ptr) == false)\n  {\n    return memcached_set_error(*ptr, rc, MEMCACHED_AT);\n  }\n#endif\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_send_binary",
          "args": [
            "ptr",
            "instance",
            "server_key",
            "key",
            "key_length",
            "value",
            "value_length",
            "expiration",
            "flags",
            "cas",
            "flush",
            "reply",
            "verb"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_send_binary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "103-177",
          "snippet": "static memcached_return_t memcached_send_binary(Memcached *ptr, memcached_instance_st *server,\n                                                uint32_t server_key, const char *key,\n                                                const size_t key_length, const char *value,\n                                                const size_t value_length, const time_t expiration,\n                                                const uint32_t flags, const uint64_t cas,\n                                                const bool flush, const bool reply,\n                                                memcached_storage_action_t verb) {\n  protocol_binary_request_set request = {};\n  size_t send_length = sizeof(request.bytes);\n\n  initialize_binary_request(server, request.message.header);\n\n  request.message.header.request.opcode = get_com_code(verb, reply);\n  request.message.header.request.keylen =\n      htons((uint16_t)(key_length + memcached_array_size(ptr->_namespace)));\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n  if (verb == APPEND_OP or verb == PREPEND_OP) {\n    send_length -= 8; /* append & prepend does not contain extras! */\n  } else {\n    request.message.header.request.extlen = 8;\n    request.message.body.flags = htonl(flags);\n    request.message.body.expiration = htonl((uint32_t) expiration);\n  }\n\n  request.message.header.request.bodylen =\n      htonl((uint32_t)(key_length + memcached_array_size(ptr->_namespace) + value_length\n                       + request.message.header.request.extlen));\n\n  if (cas) {\n    request.message.header.request.cas = memcached_htonll(cas);\n  }\n\n  libmemcached_io_vector_st vector[] = {\n      {NULL, 0},\n      {request.bytes, send_length},\n      {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n      {key, key_length},\n      {value, value_length}};\n\n  /* write the header */\n  memcached_return_t rc;\n  if ((rc = memcached_vdo(server, vector, 5, flush)) != MEMCACHED_SUCCESS) {\n    assert(memcached_last_error(server->root) != MEMCACHED_SUCCESS);\n    return memcached_last_error(server->root);\n  }\n\n  if (verb == SET_OP and ptr->number_of_replicas > 0) {\n    request.message.header.request.opcode = PROTOCOL_BINARY_CMD_SETQ;\n    WATCHPOINT_STRING(\"replicating\");\n\n    for (uint32_t x = 0; x < ptr->number_of_replicas; x++) {\n      ++server_key;\n      if (server_key == memcached_server_count(ptr)) {\n        server_key = 0;\n      }\n\n      memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n      if (memcached_success(memcached_vdo(instance, vector, 5, false))) {\n        memcached_server_response_decrement(instance);\n      }\n    }\n  }\n\n  if (flush == false) {\n    return MEMCACHED_BUFFERED;\n  }\n\n  // No reply always assumes success\n  if (reply == false) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  return memcached_response(server, NULL, 0, NULL);\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t memcached_send_binary(Memcached *ptr, memcached_instance_st *server,\n                                                uint32_t server_key, const char *key,\n                                                const size_t key_length, const char *value,\n                                                const size_t value_length, const time_t expiration,\n                                                const uint32_t flags, const uint64_t cas,\n                                                const bool flush, const bool reply,\n                                                memcached_storage_action_t verb) {\n  protocol_binary_request_set request = {};\n  size_t send_length = sizeof(request.bytes);\n\n  initialize_binary_request(server, request.message.header);\n\n  request.message.header.request.opcode = get_com_code(verb, reply);\n  request.message.header.request.keylen =\n      htons((uint16_t)(key_length + memcached_array_size(ptr->_namespace)));\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n  if (verb == APPEND_OP or verb == PREPEND_OP) {\n    send_length -= 8; /* append & prepend does not contain extras! */\n  } else {\n    request.message.header.request.extlen = 8;\n    request.message.body.flags = htonl(flags);\n    request.message.body.expiration = htonl((uint32_t) expiration);\n  }\n\n  request.message.header.request.bodylen =\n      htonl((uint32_t)(key_length + memcached_array_size(ptr->_namespace) + value_length\n                       + request.message.header.request.extlen));\n\n  if (cas) {\n    request.message.header.request.cas = memcached_htonll(cas);\n  }\n\n  libmemcached_io_vector_st vector[] = {\n      {NULL, 0},\n      {request.bytes, send_length},\n      {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n      {key, key_length},\n      {value, value_length}};\n\n  /* write the header */\n  memcached_return_t rc;\n  if ((rc = memcached_vdo(server, vector, 5, flush)) != MEMCACHED_SUCCESS) {\n    assert(memcached_last_error(server->root) != MEMCACHED_SUCCESS);\n    return memcached_last_error(server->root);\n  }\n\n  if (verb == SET_OP and ptr->number_of_replicas > 0) {\n    request.message.header.request.opcode = PROTOCOL_BINARY_CMD_SETQ;\n    WATCHPOINT_STRING(\"replicating\");\n\n    for (uint32_t x = 0; x < ptr->number_of_replicas; x++) {\n      ++server_key;\n      if (server_key == memcached_server_count(ptr)) {\n        server_key = 0;\n      }\n\n      memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n      if (memcached_success(memcached_vdo(instance, vector, 5, false))) {\n        memcached_server_response_decrement(instance);\n      }\n    }\n  }\n\n  if (flush == false) {\n    return MEMCACHED_BUFFERED;\n  }\n\n  // No reply always assumes success\n  if (reply == false) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  return memcached_response(server, NULL, 0, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_binary",
          "args": [
            "ptr"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashkit_string_length",
          "args": [
            "destination"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "hashkit_string_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/string.cc",
          "lines": "154-156",
          "snippet": "size_t hashkit_string_length(const hashkit_string_st *self) {\n  return size_t(self->end - self->string);\n}",
          "includes": [
            "#include <cstring>",
            "#include <cassert>",
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstring>\n#include <cassert>\n#include \"libhashkit/common.h\"\n\nsize_t hashkit_string_length(const hashkit_string_st *self) {\n  return size_t(self->end - self->string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashkit_string_c_str",
          "args": [
            "destination"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashkit_encrypt",
          "args": [
            "&ptr->hashkit",
            "value",
            "value_length"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "MEMCACHED_NOT_SUPPORTED",
            "MEMCACHED_AT",
            "memcached_literal_param(\"Operation not allowed while encyrption is enabled\")"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Operation not allowed while encyrption is enabled\""
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "can_be_encrypted",
          "args": [
            "verb"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "can_be_encrypted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "45-59",
          "snippet": "static inline bool can_be_encrypted(const memcached_storage_action_t verb) {\n  switch (verb) {\n  case SET_OP:\n  case ADD_OP:\n  case CAS_OP:\n  case REPLACE_OP:\n    return true;\n\n  case APPEND_OP:\n  case PREPEND_OP:\n    break;\n  }\n\n  return false;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline bool can_be_encrypted(const memcached_storage_action_t verb) {\n  switch (verb) {\n  case SET_OP:\n  case ADD_OP:\n  case CAS_OP:\n  case REPLACE_OP:\n    return true;\n\n  case APPEND_OP:\n  case PREPEND_OP:\n    break;\n  }\n\n  return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_encrypted",
          "args": [
            "ptr"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_replying",
          "args": [
            "ptr"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_buffering",
          "args": [
            "instance->root"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_SET",
          "args": [
            "instance->io_wait_count.write = 0"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_SET",
          "args": [
            "instance->io_wait_count.read = 0"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "ptr",
            "server_key"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_generate_hash_with_redistribution",
          "args": [
            "ptr",
            "group_key",
            "group_key_length"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_generate_hash_with_redistribution",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
          "lines": "109-116",
          "snippet": "uint32_t memcached_generate_hash_with_redistribution(memcached_st *ptr, const char *key,\n                                                     size_t key_length) {\n  uint32_t hash = _generate_hash_wrapper(ptr, key, key_length);\n\n  _regen_for_auto_eject(ptr);\n\n  return dispatch_host(ptr, hash);\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nuint32_t memcached_generate_hash_with_redistribution(memcached_st *ptr, const char *key,\n                                                     size_t key_length) {\n  uint32_t hash = _generate_hash_wrapper(ptr, key, key_length);\n\n  _regen_for_auto_eject(ptr);\n\n  return dispatch_host(ptr, hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_last_error",
          "args": [
            "ptr"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_last_error_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "500-511",
          "snippet": "int memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nint memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "memcached_key_test(*ptr, (const char **) &key, &key_length, 1)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_key_test",
          "args": [
            "*ptr",
            "(const char **) &key",
            "&key_length",
            "1"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_key_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/key.cc",
          "lines": "43-81",
          "snippet": "memcached_return_t memcached_key_test(memcached_st &memc, const char *const *keys,\n                                      const size_t *key_length, size_t number_of_keys) {\n  if (number_of_keys == 0) {\n    return memcached_set_error(memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Numbers of keys provided was zero\"));\n  }\n\n  if (keys == NULL or key_length == NULL) {\n    return memcached_set_error(memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n                               memcached_literal_param(\"Key was NULL or length of key was zero.\"));\n  }\n\n  const bool is_binary = memcached_flag(memc, MEMCACHED_FLAG_BINARY_PROTOCOL);\n\n  // If we don't need to verify the key, or we are using the binary protoocol,\n  // we just check the size of the key\n  for (size_t x = 0; x < number_of_keys; ++x) {\n    // We should set binary key, but the memcached server is broken for\n    // longer keys at the moment.\n    memcached_return_t rc =\n        memcached_validate_key_length(*(key_length + x), false /* memc.flags.binary_protocol */);\n    if (memcached_failed(rc)) {\n      return memcached_set_error(memc, rc, MEMCACHED_AT,\n                                 memcached_literal_param(\"Key provided was too long.\"));\n    }\n\n    if (memc.flags.verify_key and is_binary == false) {\n      for (size_t y = 0; y < *(key_length + x); ++y) {\n        if ((isgraph(keys[x][y])) == 0) {\n          return memcached_set_error(\n              memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n              memcached_literal_param(\"Key provided had invalid character.\"));\n        }\n      }\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_key_test(memcached_st &memc, const char *const *keys,\n                                      const size_t *key_length, size_t number_of_keys) {\n  if (number_of_keys == 0) {\n    return memcached_set_error(memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Numbers of keys provided was zero\"));\n  }\n\n  if (keys == NULL or key_length == NULL) {\n    return memcached_set_error(memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n                               memcached_literal_param(\"Key was NULL or length of key was zero.\"));\n  }\n\n  const bool is_binary = memcached_flag(memc, MEMCACHED_FLAG_BINARY_PROTOCOL);\n\n  // If we don't need to verify the key, or we are using the binary protoocol,\n  // we just check the size of the key\n  for (size_t x = 0; x < number_of_keys; ++x) {\n    // We should set binary key, but the memcached server is broken for\n    // longer keys at the moment.\n    memcached_return_t rc =\n        memcached_validate_key_length(*(key_length + x), false /* memc.flags.binary_protocol */);\n    if (memcached_failed(rc)) {\n      return memcached_set_error(memc, rc, MEMCACHED_AT,\n                                 memcached_literal_param(\"Key provided was too long.\"));\n    }\n\n    if (memc.flags.verify_key and is_binary == false) {\n      for (size_t y = 0; y < *(key_length + x); ++y) {\n        if ((isgraph(keys[x][y])) == 0) {\n          return memcached_set_error(\n              memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n              memcached_literal_param(\"Key provided had invalid character.\"));\n        }\n      }\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = initialize_query(ptr, true)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_query",
          "args": [
            "ptr",
            "true"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/initialize_query.cc",
          "lines": "18-39",
          "snippet": "memcached_return_t initialize_query(Memcached *self, bool increment_query_id) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (increment_query_id) {\n    self->query_id++;\n  }\n\n  if (self->state.is_time_for_rebuild) {\n    memcached_reset(self);\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return memcached_set_error(*self, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  memcached_error_free(*self);\n  memcached_result_reset(&self->result);\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t initialize_query(Memcached *self, bool increment_query_id) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (increment_query_id) {\n    self->query_id++;\n  }\n\n  if (self->state.is_time_for_rebuild) {\n    memcached_reset(self);\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return memcached_set_error(*self, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  memcached_error_free(*self);\n  memcached_result_reset(&self->result);\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline memcached_return_t\nmemcached_send(memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n               size_t key_length, const char *value, size_t value_length, const time_t expiration,\n               const uint32_t flags, const uint64_t cas, memcached_storage_action_t verb) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  if (memcached_failed(memcached_key_test(*ptr, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(ptr);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(ptr, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n  WATCHPOINT_SET(instance->io_wait_count.read = 0);\n  WATCHPOINT_SET(instance->io_wait_count.write = 0);\n\n  bool flush = true;\n  if (memcached_is_buffering(instance->root) and verb == SET_OP) {\n    flush = false;\n  }\n\n  bool reply = memcached_is_replying(ptr);\n\n  hashkit_string_st *destination = NULL;\n\n  if (memcached_is_encrypted(ptr)) {\n    if (can_be_encrypted(verb) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n          memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n    }\n\n    if ((destination = hashkit_encrypt(&ptr->hashkit, value, value_length)) == NULL) {\n      return rc;\n    }\n    value = hashkit_string_c_str(destination);\n    value_length = hashkit_string_length(destination);\n  }\n\n  if (memcached_is_binary(ptr)) {\n    rc = memcached_send_binary(ptr, instance, server_key, key, key_length, value, value_length,\n                               expiration, flags, cas, flush, reply, verb);\n  } else {\n    rc = memcached_send_ascii(ptr, instance, key, key_length, value, value_length, expiration,\n                              flags, cas, flush, reply, verb);\n  }\n\n  hashkit_string_free(destination);\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_send_ascii",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
    "lines": "179-266",
    "snippet": "static memcached_return_t\nmemcached_send_ascii(Memcached *ptr, memcached_instance_st *instance, const char *key,\n                     const size_t key_length, const char *value, const size_t value_length,\n                     const time_t expiration, const uint32_t flags, const uint64_t cas,\n                     const bool flush, const bool reply, const memcached_storage_action_t verb) {\n  char flags_buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1];\n  int flags_buffer_length = snprintf(flags_buffer, sizeof(flags_buffer), \" %u\", flags);\n  if (size_t(flags_buffer_length) >= sizeof(flags_buffer) or flags_buffer_length < 0) {\n    return memcached_set_error(\n        *instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n        memcached_literal_param(\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\"));\n  }\n\n  char expiration_buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1 + 1];\n  int expiration_buffer_length = snprintf(expiration_buffer, sizeof(expiration_buffer), \" %lld\",\n                                          (long long) expiration);\n  if (size_t(expiration_buffer_length) >= sizeof(expiration_buffer) or expiration_buffer_length < 0)\n  {\n    return memcached_set_error(\n        *instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n        memcached_literal_param(\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\"));\n  }\n\n  char value_buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1];\n  int value_buffer_length =\n      snprintf(value_buffer, sizeof(value_buffer), \" %llu\", (unsigned long long) value_length);\n  if (size_t(value_buffer_length) >= sizeof(value_buffer) or value_buffer_length < 0) {\n    return memcached_set_error(\n        *instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n        memcached_literal_param(\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\"));\n  }\n\n  char cas_buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1];\n  int cas_buffer_length = 0;\n  if (cas) {\n    cas_buffer_length = snprintf(cas_buffer, sizeof(cas_buffer), \" %llu\", (unsigned long long) cas);\n    if (size_t(cas_buffer_length) >= sizeof(cas_buffer) or cas_buffer_length < 0) {\n      return memcached_set_error(\n          *instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n          memcached_literal_param(\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\"));\n    }\n  }\n\n  libmemcached_io_vector_st vector[] = {\n      {NULL, 0},\n      {storage_op_string(verb), strlen(storage_op_string(verb))},\n      {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n      {key, key_length},\n      {flags_buffer, size_t(flags_buffer_length)},\n      {expiration_buffer, size_t(expiration_buffer_length)},\n      {value_buffer, size_t(value_buffer_length)},\n      {cas_buffer, size_t(cas_buffer_length)},\n      {\" noreply\", reply ? 0 : memcached_literal_param_size(\" noreply\")},\n      {memcached_literal_param(\"\\r\\n\")},\n      {value, value_length},\n      {memcached_literal_param(\"\\r\\n\")}};\n\n  /* Send command header */\n  memcached_return_t rc = memcached_vdo(instance, vector, 12, flush);\n\n  // If we should not reply, return with MEMCACHED_SUCCESS, unless error\n  if (reply == false) {\n    return memcached_success(rc) ? MEMCACHED_SUCCESS : rc;\n  }\n\n  if (flush == false) {\n    return memcached_success(rc) ? MEMCACHED_BUFFERED : rc;\n  }\n\n  if (rc == MEMCACHED_SUCCESS) {\n    char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n    rc = memcached_response(instance, buffer, sizeof(buffer), NULL);\n\n    if (rc == MEMCACHED_STORED) {\n      return MEMCACHED_SUCCESS;\n    }\n  }\n\n  assert(memcached_failed(rc));\n#if 0\n  if (memcached_has_error(ptr) == false)\n  {\n    return memcached_set_error(*ptr, rc, MEMCACHED_AT);\n  }\n#endif\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "rc",
            "MEMCACHED_AT"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_has_error",
          "args": [
            "ptr"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "memcached_failed(rc)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_response",
          "args": [
            "instance",
            "buffer",
            "sizeof(buffer)",
            "NULL"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
          "lines": "789-834",
          "snippet": "memcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_vdo",
          "args": [
            "instance",
            "vector",
            "12",
            "flush"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_vdo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/do.cc",
          "lines": "64-100",
          "snippet": "memcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"\\r\\n\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"\\r\\n\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param_size",
          "args": [
            "\" noreply\""
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "cas_buffer_length"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "value_buffer_length"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "expiration_buffer_length"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "flags_buffer_length"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_array_size",
          "args": [
            "ptr->_namespace"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_array_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/array.cc",
          "lines": "78-84",
          "snippet": "size_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"libmemcached/common.h\"\n\nsize_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_array_string",
          "args": [
            "ptr->_namespace"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "storage_op_string(verb)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storage_op_string",
          "args": [
            "verb"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storage_op_string",
          "args": [
            "verb"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "cas_buffer_length"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cas_buffer",
            "sizeof(cas_buffer)",
            "\" %llu\"",
            "(unsigned long long) cas"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "value_buffer_length"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "value_buffer",
            "sizeof(value_buffer)",
            "\" %llu\"",
            "(unsigned long long) value_length"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "expiration_buffer_length"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "expiration_buffer",
            "sizeof(expiration_buffer)",
            "\" %lld\"",
            "(long long) expiration"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "flags_buffer_length"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "flags_buffer",
            "sizeof(flags_buffer)",
            "\" %u\"",
            "flags"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t\nmemcached_send_ascii(Memcached *ptr, memcached_instance_st *instance, const char *key,\n                     const size_t key_length, const char *value, const size_t value_length,\n                     const time_t expiration, const uint32_t flags, const uint64_t cas,\n                     const bool flush, const bool reply, const memcached_storage_action_t verb) {\n  char flags_buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1];\n  int flags_buffer_length = snprintf(flags_buffer, sizeof(flags_buffer), \" %u\", flags);\n  if (size_t(flags_buffer_length) >= sizeof(flags_buffer) or flags_buffer_length < 0) {\n    return memcached_set_error(\n        *instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n        memcached_literal_param(\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\"));\n  }\n\n  char expiration_buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1 + 1];\n  int expiration_buffer_length = snprintf(expiration_buffer, sizeof(expiration_buffer), \" %lld\",\n                                          (long long) expiration);\n  if (size_t(expiration_buffer_length) >= sizeof(expiration_buffer) or expiration_buffer_length < 0)\n  {\n    return memcached_set_error(\n        *instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n        memcached_literal_param(\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\"));\n  }\n\n  char value_buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1];\n  int value_buffer_length =\n      snprintf(value_buffer, sizeof(value_buffer), \" %llu\", (unsigned long long) value_length);\n  if (size_t(value_buffer_length) >= sizeof(value_buffer) or value_buffer_length < 0) {\n    return memcached_set_error(\n        *instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n        memcached_literal_param(\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\"));\n  }\n\n  char cas_buffer[MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH + 1];\n  int cas_buffer_length = 0;\n  if (cas) {\n    cas_buffer_length = snprintf(cas_buffer, sizeof(cas_buffer), \" %llu\", (unsigned long long) cas);\n    if (size_t(cas_buffer_length) >= sizeof(cas_buffer) or cas_buffer_length < 0) {\n      return memcached_set_error(\n          *instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n          memcached_literal_param(\"snprintf(MEMCACHED_MAXIMUM_INTEGER_DISPLAY_LENGTH)\"));\n    }\n  }\n\n  libmemcached_io_vector_st vector[] = {\n      {NULL, 0},\n      {storage_op_string(verb), strlen(storage_op_string(verb))},\n      {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n      {key, key_length},\n      {flags_buffer, size_t(flags_buffer_length)},\n      {expiration_buffer, size_t(expiration_buffer_length)},\n      {value_buffer, size_t(value_buffer_length)},\n      {cas_buffer, size_t(cas_buffer_length)},\n      {\" noreply\", reply ? 0 : memcached_literal_param_size(\" noreply\")},\n      {memcached_literal_param(\"\\r\\n\")},\n      {value, value_length},\n      {memcached_literal_param(\"\\r\\n\")}};\n\n  /* Send command header */\n  memcached_return_t rc = memcached_vdo(instance, vector, 12, flush);\n\n  // If we should not reply, return with MEMCACHED_SUCCESS, unless error\n  if (reply == false) {\n    return memcached_success(rc) ? MEMCACHED_SUCCESS : rc;\n  }\n\n  if (flush == false) {\n    return memcached_success(rc) ? MEMCACHED_BUFFERED : rc;\n  }\n\n  if (rc == MEMCACHED_SUCCESS) {\n    char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n    rc = memcached_response(instance, buffer, sizeof(buffer), NULL);\n\n    if (rc == MEMCACHED_STORED) {\n      return MEMCACHED_SUCCESS;\n    }\n  }\n\n  assert(memcached_failed(rc));\n#if 0\n  if (memcached_has_error(ptr) == false)\n  {\n    return memcached_set_error(*ptr, rc, MEMCACHED_AT);\n  }\n#endif\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_send_binary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
    "lines": "103-177",
    "snippet": "static memcached_return_t memcached_send_binary(Memcached *ptr, memcached_instance_st *server,\n                                                uint32_t server_key, const char *key,\n                                                const size_t key_length, const char *value,\n                                                const size_t value_length, const time_t expiration,\n                                                const uint32_t flags, const uint64_t cas,\n                                                const bool flush, const bool reply,\n                                                memcached_storage_action_t verb) {\n  protocol_binary_request_set request = {};\n  size_t send_length = sizeof(request.bytes);\n\n  initialize_binary_request(server, request.message.header);\n\n  request.message.header.request.opcode = get_com_code(verb, reply);\n  request.message.header.request.keylen =\n      htons((uint16_t)(key_length + memcached_array_size(ptr->_namespace)));\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n  if (verb == APPEND_OP or verb == PREPEND_OP) {\n    send_length -= 8; /* append & prepend does not contain extras! */\n  } else {\n    request.message.header.request.extlen = 8;\n    request.message.body.flags = htonl(flags);\n    request.message.body.expiration = htonl((uint32_t) expiration);\n  }\n\n  request.message.header.request.bodylen =\n      htonl((uint32_t)(key_length + memcached_array_size(ptr->_namespace) + value_length\n                       + request.message.header.request.extlen));\n\n  if (cas) {\n    request.message.header.request.cas = memcached_htonll(cas);\n  }\n\n  libmemcached_io_vector_st vector[] = {\n      {NULL, 0},\n      {request.bytes, send_length},\n      {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n      {key, key_length},\n      {value, value_length}};\n\n  /* write the header */\n  memcached_return_t rc;\n  if ((rc = memcached_vdo(server, vector, 5, flush)) != MEMCACHED_SUCCESS) {\n    assert(memcached_last_error(server->root) != MEMCACHED_SUCCESS);\n    return memcached_last_error(server->root);\n  }\n\n  if (verb == SET_OP and ptr->number_of_replicas > 0) {\n    request.message.header.request.opcode = PROTOCOL_BINARY_CMD_SETQ;\n    WATCHPOINT_STRING(\"replicating\");\n\n    for (uint32_t x = 0; x < ptr->number_of_replicas; x++) {\n      ++server_key;\n      if (server_key == memcached_server_count(ptr)) {\n        server_key = 0;\n      }\n\n      memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n      if (memcached_success(memcached_vdo(instance, vector, 5, false))) {\n        memcached_server_response_decrement(instance);\n      }\n    }\n  }\n\n  if (flush == false) {\n    return MEMCACHED_BUFFERED;\n  }\n\n  // No reply always assumes success\n  if (reply == false) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  return memcached_response(server, NULL, 0, NULL);\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_response",
          "args": [
            "server",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
          "lines": "789-834",
          "snippet": "memcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_response_decrement",
          "args": [
            "instance"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "memcached_vdo(instance, vector, 5, false)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_vdo",
          "args": [
            "instance",
            "vector",
            "5",
            "false"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_vdo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/do.cc",
          "lines": "64-100",
          "snippet": "memcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "ptr",
            "server_key"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "ptr"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_STRING",
          "args": [
            "\"replicating\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error",
          "args": [
            "server->root"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_last_error_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "500-511",
          "snippet": "int memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nint memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "memcached_last_error(server->root) != MEMCACHED_SUCCESS"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_array_size",
          "args": [
            "ptr->_namespace"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_array_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/array.cc",
          "lines": "78-84",
          "snippet": "size_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"libmemcached/common.h\"\n\nsize_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_array_string",
          "args": [
            "ptr->_namespace"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_htonll",
          "args": [
            "cas"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_htonll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "55-61",
          "snippet": "uint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "(uint16_t)(key_length + memcached_array_size(ptr->_namespace))"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_com_code",
          "args": [
            "verb",
            "reply"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "get_com_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "61-101",
          "snippet": "static inline uint8_t get_com_code(const memcached_storage_action_t verb, const bool reply) {\n  if (reply == false) {\n    switch (verb) {\n    case SET_OP:\n      return PROTOCOL_BINARY_CMD_SETQ;\n\n    case ADD_OP:\n      return PROTOCOL_BINARY_CMD_ADDQ;\n\n    case CAS_OP: /* FALLTHROUGH */\n    case REPLACE_OP:\n      return PROTOCOL_BINARY_CMD_REPLACEQ;\n\n    case APPEND_OP:\n      return PROTOCOL_BINARY_CMD_APPENDQ;\n\n    case PREPEND_OP:\n      return PROTOCOL_BINARY_CMD_PREPENDQ;\n    }\n  }\n\n  switch (verb) {\n  case SET_OP:\n    break;\n\n  case ADD_OP:\n    return PROTOCOL_BINARY_CMD_ADD;\n\n  case CAS_OP: /* FALLTHROUGH */\n  case REPLACE_OP:\n    return PROTOCOL_BINARY_CMD_REPLACE;\n\n  case APPEND_OP:\n    return PROTOCOL_BINARY_CMD_APPEND;\n\n  case PREPEND_OP:\n    return PROTOCOL_BINARY_CMD_PREPEND;\n  }\n\n  return PROTOCOL_BINARY_CMD_SET;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline uint8_t get_com_code(const memcached_storage_action_t verb, const bool reply) {\n  if (reply == false) {\n    switch (verb) {\n    case SET_OP:\n      return PROTOCOL_BINARY_CMD_SETQ;\n\n    case ADD_OP:\n      return PROTOCOL_BINARY_CMD_ADDQ;\n\n    case CAS_OP: /* FALLTHROUGH */\n    case REPLACE_OP:\n      return PROTOCOL_BINARY_CMD_REPLACEQ;\n\n    case APPEND_OP:\n      return PROTOCOL_BINARY_CMD_APPENDQ;\n\n    case PREPEND_OP:\n      return PROTOCOL_BINARY_CMD_PREPENDQ;\n    }\n  }\n\n  switch (verb) {\n  case SET_OP:\n    break;\n\n  case ADD_OP:\n    return PROTOCOL_BINARY_CMD_ADD;\n\n  case CAS_OP: /* FALLTHROUGH */\n  case REPLACE_OP:\n    return PROTOCOL_BINARY_CMD_REPLACE;\n\n  case APPEND_OP:\n    return PROTOCOL_BINARY_CMD_APPEND;\n\n  case PREPEND_OP:\n    return PROTOCOL_BINARY_CMD_PREPEND;\n  }\n\n  return PROTOCOL_BINARY_CMD_SET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_binary_request",
          "args": [
            "server",
            "request.message.header"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_binary_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "20-25",
          "snippet": "void initialize_binary_request(memcached_instance_st *server,\n                               protocol_binary_request_header &header) {\n  server->request_id++;\n  header.request.magic = PROTOCOL_BINARY_REQ;\n  header.request.opaque = htons(server->request_id);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid initialize_binary_request(memcached_instance_st *server,\n                               protocol_binary_request_header &header) {\n  server->request_id++;\n  header.request.magic = PROTOCOL_BINARY_REQ;\n  header.request.opaque = htons(server->request_id);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t memcached_send_binary(Memcached *ptr, memcached_instance_st *server,\n                                                uint32_t server_key, const char *key,\n                                                const size_t key_length, const char *value,\n                                                const size_t value_length, const time_t expiration,\n                                                const uint32_t flags, const uint64_t cas,\n                                                const bool flush, const bool reply,\n                                                memcached_storage_action_t verb) {\n  protocol_binary_request_set request = {};\n  size_t send_length = sizeof(request.bytes);\n\n  initialize_binary_request(server, request.message.header);\n\n  request.message.header.request.opcode = get_com_code(verb, reply);\n  request.message.header.request.keylen =\n      htons((uint16_t)(key_length + memcached_array_size(ptr->_namespace)));\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n  if (verb == APPEND_OP or verb == PREPEND_OP) {\n    send_length -= 8; /* append & prepend does not contain extras! */\n  } else {\n    request.message.header.request.extlen = 8;\n    request.message.body.flags = htonl(flags);\n    request.message.body.expiration = htonl((uint32_t) expiration);\n  }\n\n  request.message.header.request.bodylen =\n      htonl((uint32_t)(key_length + memcached_array_size(ptr->_namespace) + value_length\n                       + request.message.header.request.extlen));\n\n  if (cas) {\n    request.message.header.request.cas = memcached_htonll(cas);\n  }\n\n  libmemcached_io_vector_st vector[] = {\n      {NULL, 0},\n      {request.bytes, send_length},\n      {memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace)},\n      {key, key_length},\n      {value, value_length}};\n\n  /* write the header */\n  memcached_return_t rc;\n  if ((rc = memcached_vdo(server, vector, 5, flush)) != MEMCACHED_SUCCESS) {\n    assert(memcached_last_error(server->root) != MEMCACHED_SUCCESS);\n    return memcached_last_error(server->root);\n  }\n\n  if (verb == SET_OP and ptr->number_of_replicas > 0) {\n    request.message.header.request.opcode = PROTOCOL_BINARY_CMD_SETQ;\n    WATCHPOINT_STRING(\"replicating\");\n\n    for (uint32_t x = 0; x < ptr->number_of_replicas; x++) {\n      ++server_key;\n      if (server_key == memcached_server_count(ptr)) {\n        server_key = 0;\n      }\n\n      memcached_instance_st *instance = memcached_instance_fetch(ptr, server_key);\n\n      if (memcached_success(memcached_vdo(instance, vector, 5, false))) {\n        memcached_server_response_decrement(instance);\n      }\n    }\n  }\n\n  if (flush == false) {\n    return MEMCACHED_BUFFERED;\n  }\n\n  // No reply always assumes success\n  if (reply == false) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  return memcached_response(server, NULL, 0, NULL);\n}"
  },
  {
    "function_name": "get_com_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
    "lines": "61-101",
    "snippet": "static inline uint8_t get_com_code(const memcached_storage_action_t verb, const bool reply) {\n  if (reply == false) {\n    switch (verb) {\n    case SET_OP:\n      return PROTOCOL_BINARY_CMD_SETQ;\n\n    case ADD_OP:\n      return PROTOCOL_BINARY_CMD_ADDQ;\n\n    case CAS_OP: /* FALLTHROUGH */\n    case REPLACE_OP:\n      return PROTOCOL_BINARY_CMD_REPLACEQ;\n\n    case APPEND_OP:\n      return PROTOCOL_BINARY_CMD_APPENDQ;\n\n    case PREPEND_OP:\n      return PROTOCOL_BINARY_CMD_PREPENDQ;\n    }\n  }\n\n  switch (verb) {\n  case SET_OP:\n    break;\n\n  case ADD_OP:\n    return PROTOCOL_BINARY_CMD_ADD;\n\n  case CAS_OP: /* FALLTHROUGH */\n  case REPLACE_OP:\n    return PROTOCOL_BINARY_CMD_REPLACE;\n\n  case APPEND_OP:\n    return PROTOCOL_BINARY_CMD_APPEND;\n\n  case PREPEND_OP:\n    return PROTOCOL_BINARY_CMD_PREPEND;\n  }\n\n  return PROTOCOL_BINARY_CMD_SET;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline uint8_t get_com_code(const memcached_storage_action_t verb, const bool reply) {\n  if (reply == false) {\n    switch (verb) {\n    case SET_OP:\n      return PROTOCOL_BINARY_CMD_SETQ;\n\n    case ADD_OP:\n      return PROTOCOL_BINARY_CMD_ADDQ;\n\n    case CAS_OP: /* FALLTHROUGH */\n    case REPLACE_OP:\n      return PROTOCOL_BINARY_CMD_REPLACEQ;\n\n    case APPEND_OP:\n      return PROTOCOL_BINARY_CMD_APPENDQ;\n\n    case PREPEND_OP:\n      return PROTOCOL_BINARY_CMD_PREPENDQ;\n    }\n  }\n\n  switch (verb) {\n  case SET_OP:\n    break;\n\n  case ADD_OP:\n    return PROTOCOL_BINARY_CMD_ADD;\n\n  case CAS_OP: /* FALLTHROUGH */\n  case REPLACE_OP:\n    return PROTOCOL_BINARY_CMD_REPLACE;\n\n  case APPEND_OP:\n    return PROTOCOL_BINARY_CMD_APPEND;\n\n  case PREPEND_OP:\n    return PROTOCOL_BINARY_CMD_PREPEND;\n  }\n\n  return PROTOCOL_BINARY_CMD_SET;\n}"
  },
  {
    "function_name": "can_be_encrypted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
    "lines": "45-59",
    "snippet": "static inline bool can_be_encrypted(const memcached_storage_action_t verb) {\n  switch (verb) {\n  case SET_OP:\n  case ADD_OP:\n  case CAS_OP:\n  case REPLACE_OP:\n    return true;\n\n  case APPEND_OP:\n  case PREPEND_OP:\n    break;\n  }\n\n  return false;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic inline bool can_be_encrypted(const memcached_storage_action_t verb) {\n  switch (verb) {\n  case SET_OP:\n  case ADD_OP:\n  case CAS_OP:\n  case REPLACE_OP:\n    return true;\n\n  case APPEND_OP:\n  case PREPEND_OP:\n    break;\n  }\n\n  return false;\n}"
  }
]