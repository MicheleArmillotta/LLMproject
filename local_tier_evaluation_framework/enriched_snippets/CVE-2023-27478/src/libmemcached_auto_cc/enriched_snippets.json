[
  {
    "function_name": "memcached_decrement_with_initial_by_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
    "lines": "266-278",
    "snippet": "memcached_return_t memcached_decrement_with_initial_by_key(\n    memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n    size_t key_length, uint64_t offset, uint64_t initial, time_t expiration, uint64_t *value) {\n  LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_START();\n  Memcached *memc = memcached2Memcached(shell);\n  memcached_return_t rc = increment_decrement_with_initial_by_key(\n      PROTOCOL_BINARY_CMD_DECREMENT, memc, group_key, group_key_length, key, key_length, offset,\n      initial, expiration, value);\n\n  LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_END();\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_END",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "increment_decrement_with_initial_by_key",
          "args": [
            "PROTOCOL_BINARY_CMD_DECREMENT",
            "memc",
            "group_key",
            "group_key_length",
            "key",
            "key_length",
            "offset",
            "initial",
            "expiration",
            "value"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "increment_decrement_with_initial_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
          "lines": "158-203",
          "snippet": "static memcached_return_t\nincrement_decrement_with_initial_by_key(const protocol_binary_command command, Memcached *memc,\n                                        const char *group_key, size_t group_key_length,\n                                        const char *key, size_t key_length, uint64_t offset,\n                                        uint64_t initial, time_t expiration, uint64_t *value) {\n  uint64_t local_value;\n  if (value == NULL) {\n    value = &local_value;\n  }\n\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(memc, true))) {\n    return rc;\n  }\n\n  if (memcached_is_encrypted(memc)) {\n    return memcached_set_error(\n        *memc, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"Operation not allowed while encryption is enabled\"));\n  }\n\n  if (memcached_failed(rc = memcached_key_test(*memc, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(memc);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(memc, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(memc, server_key);\n\n  bool reply = memcached_is_replying(instance->root);\n\n  if (memcached_is_binary(memc)) {\n    rc = binary_incr_decr(instance, command, key, key_length, offset, initial, uint32_t(expiration),\n                          reply);\n\n  } else {\n    rc = memcached_set_error(\n        *memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"memcached_increment_with_initial_by_key() is not supported via the ASCII protocol\"));\n  }\n\n  auto_response(instance, reply, rc, value);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t\nincrement_decrement_with_initial_by_key(const protocol_binary_command command, Memcached *memc,\n                                        const char *group_key, size_t group_key_length,\n                                        const char *key, size_t key_length, uint64_t offset,\n                                        uint64_t initial, time_t expiration, uint64_t *value) {\n  uint64_t local_value;\n  if (value == NULL) {\n    value = &local_value;\n  }\n\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(memc, true))) {\n    return rc;\n  }\n\n  if (memcached_is_encrypted(memc)) {\n    return memcached_set_error(\n        *memc, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"Operation not allowed while encryption is enabled\"));\n  }\n\n  if (memcached_failed(rc = memcached_key_test(*memc, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(memc);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(memc, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(memc, server_key);\n\n  bool reply = memcached_is_replying(instance->root);\n\n  if (memcached_is_binary(memc)) {\n    rc = binary_incr_decr(instance, command, key, key_length, offset, initial, uint32_t(expiration),\n                          reply);\n\n  } else {\n    rc = memcached_set_error(\n        *memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"memcached_increment_with_initial_by_key() is not supported via the ASCII protocol\"));\n  }\n\n  auto_response(instance, reply, rc, value);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_START",
          "args": [],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_decrement_with_initial_by_key(\n    memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n    size_t key_length, uint64_t offset, uint64_t initial, time_t expiration, uint64_t *value) {\n  LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_START();\n  Memcached *memc = memcached2Memcached(shell);\n  memcached_return_t rc = increment_decrement_with_initial_by_key(\n      PROTOCOL_BINARY_CMD_DECREMENT, memc, group_key, group_key_length, key, key_length, offset,\n      initial, expiration, value);\n\n  LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_END();\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_decrement_with_initial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
    "lines": "258-264",
    "snippet": "memcached_return_t memcached_decrement_with_initial(memcached_st *memc, const char *key,\n                                                    size_t key_length, uint64_t offset,\n                                                    uint64_t initial, time_t expiration,\n                                                    uint64_t *value) {\n  return memcached_decrement_with_initial_by_key(memc, key, key_length, key, key_length, offset,\n                                                 initial, expiration, value);\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_decrement_with_initial_by_key",
          "args": [
            "memc",
            "key",
            "key_length",
            "key",
            "key_length",
            "offset",
            "initial",
            "expiration",
            "value"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_decrement_with_initial_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
          "lines": "266-278",
          "snippet": "memcached_return_t memcached_decrement_with_initial_by_key(\n    memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n    size_t key_length, uint64_t offset, uint64_t initial, time_t expiration, uint64_t *value) {\n  LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_START();\n  Memcached *memc = memcached2Memcached(shell);\n  memcached_return_t rc = increment_decrement_with_initial_by_key(\n      PROTOCOL_BINARY_CMD_DECREMENT, memc, group_key, group_key_length, key, key_length, offset,\n      initial, expiration, value);\n\n  LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_END();\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_decrement_with_initial_by_key(\n    memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n    size_t key_length, uint64_t offset, uint64_t initial, time_t expiration, uint64_t *value) {\n  LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_START();\n  Memcached *memc = memcached2Memcached(shell);\n  memcached_return_t rc = increment_decrement_with_initial_by_key(\n      PROTOCOL_BINARY_CMD_DECREMENT, memc, group_key, group_key_length, key, key_length, offset,\n      initial, expiration, value);\n\n  LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_END();\n\n  return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_decrement_with_initial(memcached_st *memc, const char *key,\n                                                    size_t key_length, uint64_t offset,\n                                                    uint64_t initial, time_t expiration,\n                                                    uint64_t *value) {\n  return memcached_decrement_with_initial_by_key(memc, key, key_length, key, key_length, offset,\n                                                 initial, expiration, value);\n}"
  },
  {
    "function_name": "memcached_increment_with_initial_by_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
    "lines": "245-256",
    "snippet": "memcached_return_t memcached_increment_with_initial_by_key(\n    memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n    size_t key_length, uint64_t offset, uint64_t initial, time_t expiration, uint64_t *value) {\n  LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_START();\n  Memcached *memc = memcached2Memcached(shell);\n  memcached_return_t rc = increment_decrement_with_initial_by_key(\n      PROTOCOL_BINARY_CMD_INCREMENT, memc, group_key, group_key_length, key, key_length, offset,\n      initial, expiration, value);\n  LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_END();\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_END",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "increment_decrement_with_initial_by_key",
          "args": [
            "PROTOCOL_BINARY_CMD_INCREMENT",
            "memc",
            "group_key",
            "group_key_length",
            "key",
            "key_length",
            "offset",
            "initial",
            "expiration",
            "value"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "increment_decrement_with_initial_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
          "lines": "158-203",
          "snippet": "static memcached_return_t\nincrement_decrement_with_initial_by_key(const protocol_binary_command command, Memcached *memc,\n                                        const char *group_key, size_t group_key_length,\n                                        const char *key, size_t key_length, uint64_t offset,\n                                        uint64_t initial, time_t expiration, uint64_t *value) {\n  uint64_t local_value;\n  if (value == NULL) {\n    value = &local_value;\n  }\n\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(memc, true))) {\n    return rc;\n  }\n\n  if (memcached_is_encrypted(memc)) {\n    return memcached_set_error(\n        *memc, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"Operation not allowed while encryption is enabled\"));\n  }\n\n  if (memcached_failed(rc = memcached_key_test(*memc, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(memc);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(memc, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(memc, server_key);\n\n  bool reply = memcached_is_replying(instance->root);\n\n  if (memcached_is_binary(memc)) {\n    rc = binary_incr_decr(instance, command, key, key_length, offset, initial, uint32_t(expiration),\n                          reply);\n\n  } else {\n    rc = memcached_set_error(\n        *memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"memcached_increment_with_initial_by_key() is not supported via the ASCII protocol\"));\n  }\n\n  auto_response(instance, reply, rc, value);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t\nincrement_decrement_with_initial_by_key(const protocol_binary_command command, Memcached *memc,\n                                        const char *group_key, size_t group_key_length,\n                                        const char *key, size_t key_length, uint64_t offset,\n                                        uint64_t initial, time_t expiration, uint64_t *value) {\n  uint64_t local_value;\n  if (value == NULL) {\n    value = &local_value;\n  }\n\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(memc, true))) {\n    return rc;\n  }\n\n  if (memcached_is_encrypted(memc)) {\n    return memcached_set_error(\n        *memc, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"Operation not allowed while encryption is enabled\"));\n  }\n\n  if (memcached_failed(rc = memcached_key_test(*memc, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(memc);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(memc, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(memc, server_key);\n\n  bool reply = memcached_is_replying(instance->root);\n\n  if (memcached_is_binary(memc)) {\n    rc = binary_incr_decr(instance, command, key, key_length, offset, initial, uint32_t(expiration),\n                          reply);\n\n  } else {\n    rc = memcached_set_error(\n        *memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"memcached_increment_with_initial_by_key() is not supported via the ASCII protocol\"));\n  }\n\n  auto_response(instance, reply, rc, value);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_START",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_increment_with_initial_by_key(\n    memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n    size_t key_length, uint64_t offset, uint64_t initial, time_t expiration, uint64_t *value) {\n  LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_START();\n  Memcached *memc = memcached2Memcached(shell);\n  memcached_return_t rc = increment_decrement_with_initial_by_key(\n      PROTOCOL_BINARY_CMD_INCREMENT, memc, group_key, group_key_length, key, key_length, offset,\n      initial, expiration, value);\n  LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_END();\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_increment_with_initial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
    "lines": "237-243",
    "snippet": "memcached_return_t memcached_increment_with_initial(memcached_st *memc, const char *key,\n                                                    size_t key_length, uint64_t offset,\n                                                    uint64_t initial, time_t expiration,\n                                                    uint64_t *value) {\n  return memcached_increment_with_initial_by_key(memc, key, key_length, key, key_length, offset,\n                                                 initial, expiration, value);\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_increment_with_initial_by_key",
          "args": [
            "memc",
            "key",
            "key_length",
            "key",
            "key_length",
            "offset",
            "initial",
            "expiration",
            "value"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_increment_with_initial_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
          "lines": "245-256",
          "snippet": "memcached_return_t memcached_increment_with_initial_by_key(\n    memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n    size_t key_length, uint64_t offset, uint64_t initial, time_t expiration, uint64_t *value) {\n  LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_START();\n  Memcached *memc = memcached2Memcached(shell);\n  memcached_return_t rc = increment_decrement_with_initial_by_key(\n      PROTOCOL_BINARY_CMD_INCREMENT, memc, group_key, group_key_length, key, key_length, offset,\n      initial, expiration, value);\n  LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_END();\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_increment_with_initial_by_key(\n    memcached_st *shell, const char *group_key, size_t group_key_length, const char *key,\n    size_t key_length, uint64_t offset, uint64_t initial, time_t expiration, uint64_t *value) {\n  LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_START();\n  Memcached *memc = memcached2Memcached(shell);\n  memcached_return_t rc = increment_decrement_with_initial_by_key(\n      PROTOCOL_BINARY_CMD_INCREMENT, memc, group_key, group_key_length, key, key_length, offset,\n      initial, expiration, value);\n  LIBMEMCACHED_MEMCACHED_INCREMENT_WITH_INITIAL_END();\n\n  return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_increment_with_initial(memcached_st *memc, const char *key,\n                                                    size_t key_length, uint64_t offset,\n                                                    uint64_t initial, time_t expiration,\n                                                    uint64_t *value) {\n  return memcached_increment_with_initial_by_key(memc, key, key_length, key, key_length, offset,\n                                                 initial, expiration, value);\n}"
  },
  {
    "function_name": "memcached_decrement_by_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
    "lines": "224-235",
    "snippet": "memcached_return_t memcached_decrement_by_key(memcached_st *shell, const char *group_key,\n                                              size_t group_key_length, const char *key,\n                                              size_t key_length, uint64_t offset, uint64_t *value) {\n  Memcached *memc = memcached2Memcached(shell);\n  LIBMEMCACHED_MEMCACHED_DECREMENT_START();\n  memcached_return_t rc =\n      increment_decrement_by_key(PROTOCOL_BINARY_CMD_DECREMENT, memc, group_key, group_key_length,\n                                 key, key_length, offset, value);\n  LIBMEMCACHED_MEMCACHED_DECREMENT_END();\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_DECREMENT_END",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "increment_decrement_by_key",
          "args": [
            "PROTOCOL_BINARY_CMD_DECREMENT",
            "memc",
            "group_key",
            "group_key_length",
            "key",
            "key_length",
            "offset",
            "value"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "increment_decrement_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
          "lines": "114-156",
          "snippet": "static memcached_return_t increment_decrement_by_key(const protocol_binary_command command,\n                                                     Memcached *memc, const char *group_key,\n                                                     size_t group_key_length, const char *key,\n                                                     size_t key_length, uint64_t offset,\n                                                     uint64_t *value) {\n  uint64_t local_value;\n  if (value == NULL) {\n    value = &local_value;\n  }\n\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(memc, true))) {\n    return rc;\n  }\n\n  if (memcached_is_encrypted(memc)) {\n    return memcached_set_error(\n        *memc, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n  }\n\n  if (memcached_failed(rc = memcached_key_test(*memc, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(memc);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(memc, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(memc, server_key);\n\n  bool reply = memcached_is_replying(instance->root);\n\n  if (memcached_is_binary(memc)) {\n    rc = binary_incr_decr(instance, command, key, key_length, uint64_t(offset), 0,\n                          MEMCACHED_EXPIRATION_NOT_ADD, reply);\n  } else {\n    rc = text_incr_decr(instance, command == PROTOCOL_BINARY_CMD_INCREMENT ? true : false, key,\n                        key_length, offset, reply);\n  }\n\n  auto_response(instance, reply, rc, value);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t increment_decrement_by_key(const protocol_binary_command command,\n                                                     Memcached *memc, const char *group_key,\n                                                     size_t group_key_length, const char *key,\n                                                     size_t key_length, uint64_t offset,\n                                                     uint64_t *value) {\n  uint64_t local_value;\n  if (value == NULL) {\n    value = &local_value;\n  }\n\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(memc, true))) {\n    return rc;\n  }\n\n  if (memcached_is_encrypted(memc)) {\n    return memcached_set_error(\n        *memc, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n  }\n\n  if (memcached_failed(rc = memcached_key_test(*memc, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(memc);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(memc, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(memc, server_key);\n\n  bool reply = memcached_is_replying(instance->root);\n\n  if (memcached_is_binary(memc)) {\n    rc = binary_incr_decr(instance, command, key, key_length, uint64_t(offset), 0,\n                          MEMCACHED_EXPIRATION_NOT_ADD, reply);\n  } else {\n    rc = text_incr_decr(instance, command == PROTOCOL_BINARY_CMD_INCREMENT ? true : false, key,\n                        key_length, offset, reply);\n  }\n\n  auto_response(instance, reply, rc, value);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_DECREMENT_START",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_decrement_by_key(memcached_st *shell, const char *group_key,\n                                              size_t group_key_length, const char *key,\n                                              size_t key_length, uint64_t offset, uint64_t *value) {\n  Memcached *memc = memcached2Memcached(shell);\n  LIBMEMCACHED_MEMCACHED_DECREMENT_START();\n  memcached_return_t rc =\n      increment_decrement_by_key(PROTOCOL_BINARY_CMD_DECREMENT, memc, group_key, group_key_length,\n                                 key, key_length, offset, value);\n  LIBMEMCACHED_MEMCACHED_DECREMENT_END();\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_increment_by_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
    "lines": "210-222",
    "snippet": "memcached_return_t memcached_increment_by_key(memcached_st *shell, const char *group_key,\n                                              size_t group_key_length, const char *key,\n                                              size_t key_length, uint64_t offset, uint64_t *value) {\n  Memcached *memc = memcached2Memcached(shell);\n  LIBMEMCACHED_MEMCACHED_INCREMENT_START();\n  memcached_return_t rc =\n      increment_decrement_by_key(PROTOCOL_BINARY_CMD_INCREMENT, memc, group_key, group_key_length,\n                                 key, key_length, offset, value);\n\n  LIBMEMCACHED_MEMCACHED_INCREMENT_END();\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_INCREMENT_END",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "increment_decrement_by_key",
          "args": [
            "PROTOCOL_BINARY_CMD_INCREMENT",
            "memc",
            "group_key",
            "group_key_length",
            "key",
            "key_length",
            "offset",
            "value"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "increment_decrement_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
          "lines": "114-156",
          "snippet": "static memcached_return_t increment_decrement_by_key(const protocol_binary_command command,\n                                                     Memcached *memc, const char *group_key,\n                                                     size_t group_key_length, const char *key,\n                                                     size_t key_length, uint64_t offset,\n                                                     uint64_t *value) {\n  uint64_t local_value;\n  if (value == NULL) {\n    value = &local_value;\n  }\n\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(memc, true))) {\n    return rc;\n  }\n\n  if (memcached_is_encrypted(memc)) {\n    return memcached_set_error(\n        *memc, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n  }\n\n  if (memcached_failed(rc = memcached_key_test(*memc, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(memc);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(memc, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(memc, server_key);\n\n  bool reply = memcached_is_replying(instance->root);\n\n  if (memcached_is_binary(memc)) {\n    rc = binary_incr_decr(instance, command, key, key_length, uint64_t(offset), 0,\n                          MEMCACHED_EXPIRATION_NOT_ADD, reply);\n  } else {\n    rc = text_incr_decr(instance, command == PROTOCOL_BINARY_CMD_INCREMENT ? true : false, key,\n                        key_length, offset, reply);\n  }\n\n  auto_response(instance, reply, rc, value);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t increment_decrement_by_key(const protocol_binary_command command,\n                                                     Memcached *memc, const char *group_key,\n                                                     size_t group_key_length, const char *key,\n                                                     size_t key_length, uint64_t offset,\n                                                     uint64_t *value) {\n  uint64_t local_value;\n  if (value == NULL) {\n    value = &local_value;\n  }\n\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(memc, true))) {\n    return rc;\n  }\n\n  if (memcached_is_encrypted(memc)) {\n    return memcached_set_error(\n        *memc, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n  }\n\n  if (memcached_failed(rc = memcached_key_test(*memc, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(memc);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(memc, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(memc, server_key);\n\n  bool reply = memcached_is_replying(instance->root);\n\n  if (memcached_is_binary(memc)) {\n    rc = binary_incr_decr(instance, command, key, key_length, uint64_t(offset), 0,\n                          MEMCACHED_EXPIRATION_NOT_ADD, reply);\n  } else {\n    rc = text_incr_decr(instance, command == PROTOCOL_BINARY_CMD_INCREMENT ? true : false, key,\n                        key_length, offset, reply);\n  }\n\n  auto_response(instance, reply, rc, value);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_INCREMENT_START",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_increment_by_key(memcached_st *shell, const char *group_key,\n                                              size_t group_key_length, const char *key,\n                                              size_t key_length, uint64_t offset, uint64_t *value) {\n  Memcached *memc = memcached2Memcached(shell);\n  LIBMEMCACHED_MEMCACHED_INCREMENT_START();\n  memcached_return_t rc =\n      increment_decrement_by_key(PROTOCOL_BINARY_CMD_INCREMENT, memc, group_key, group_key_length,\n                                 key, key_length, offset, value);\n\n  LIBMEMCACHED_MEMCACHED_INCREMENT_END();\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_decrement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
    "lines": "205-208",
    "snippet": "memcached_return_t memcached_decrement(memcached_st *memc, const char *key, size_t key_length,\n                                       uint32_t offset, uint64_t *value) {\n  return memcached_decrement_by_key(memc, key, key_length, key, key_length, offset, value);\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_decrement_by_key",
          "args": [
            "memc",
            "key",
            "key_length",
            "key",
            "key_length",
            "offset",
            "value"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_decrement_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
          "lines": "224-235",
          "snippet": "memcached_return_t memcached_decrement_by_key(memcached_st *shell, const char *group_key,\n                                              size_t group_key_length, const char *key,\n                                              size_t key_length, uint64_t offset, uint64_t *value) {\n  Memcached *memc = memcached2Memcached(shell);\n  LIBMEMCACHED_MEMCACHED_DECREMENT_START();\n  memcached_return_t rc =\n      increment_decrement_by_key(PROTOCOL_BINARY_CMD_DECREMENT, memc, group_key, group_key_length,\n                                 key, key_length, offset, value);\n  LIBMEMCACHED_MEMCACHED_DECREMENT_END();\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_decrement_by_key(memcached_st *shell, const char *group_key,\n                                              size_t group_key_length, const char *key,\n                                              size_t key_length, uint64_t offset, uint64_t *value) {\n  Memcached *memc = memcached2Memcached(shell);\n  LIBMEMCACHED_MEMCACHED_DECREMENT_START();\n  memcached_return_t rc =\n      increment_decrement_by_key(PROTOCOL_BINARY_CMD_DECREMENT, memc, group_key, group_key_length,\n                                 key, key_length, offset, value);\n  LIBMEMCACHED_MEMCACHED_DECREMENT_END();\n\n  return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_decrement(memcached_st *memc, const char *key, size_t key_length,\n                                       uint32_t offset, uint64_t *value) {\n  return memcached_decrement_by_key(memc, key, key_length, key, key_length, offset, value);\n}"
  },
  {
    "function_name": "increment_decrement_with_initial_by_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
    "lines": "158-203",
    "snippet": "static memcached_return_t\nincrement_decrement_with_initial_by_key(const protocol_binary_command command, Memcached *memc,\n                                        const char *group_key, size_t group_key_length,\n                                        const char *key, size_t key_length, uint64_t offset,\n                                        uint64_t initial, time_t expiration, uint64_t *value) {\n  uint64_t local_value;\n  if (value == NULL) {\n    value = &local_value;\n  }\n\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(memc, true))) {\n    return rc;\n  }\n\n  if (memcached_is_encrypted(memc)) {\n    return memcached_set_error(\n        *memc, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"Operation not allowed while encryption is enabled\"));\n  }\n\n  if (memcached_failed(rc = memcached_key_test(*memc, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(memc);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(memc, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(memc, server_key);\n\n  bool reply = memcached_is_replying(instance->root);\n\n  if (memcached_is_binary(memc)) {\n    rc = binary_incr_decr(instance, command, key, key_length, offset, initial, uint32_t(expiration),\n                          reply);\n\n  } else {\n    rc = memcached_set_error(\n        *memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"memcached_increment_with_initial_by_key() is not supported via the ASCII protocol\"));\n  }\n\n  auto_response(instance, reply, rc, value);\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "auto_response",
          "args": [
            "instance",
            "reply",
            "rc",
            "value"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "auto_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
          "lines": "18-40",
          "snippet": "static void auto_response(memcached_instance_st *instance, const bool reply, memcached_return_t &rc,\n                          uint64_t *value) {\n  // If the message was successfully sent, then get the response, otherwise\n  // fail.\n  if (memcached_success(rc)) {\n    if (reply == false) {\n      *value = UINT64_MAX;\n      return;\n    }\n\n    rc = memcached_response(instance, &instance->root->result);\n  }\n\n  if (memcached_fatal(rc)) {\n    assert(memcached_last_error(instance->root) != MEMCACHED_SUCCESS);\n    *value = UINT64_MAX;\n  } else if (memcached_failed(rc)) {\n    *value = UINT64_MAX;\n  } else {\n    assert(memcached_last_error(instance->root) != MEMCACHED_NOTFOUND);\n    *value = instance->root->result.numeric_value;\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic void auto_response(memcached_instance_st *instance, const bool reply, memcached_return_t &rc,\n                          uint64_t *value) {\n  // If the message was successfully sent, then get the response, otherwise\n  // fail.\n  if (memcached_success(rc)) {\n    if (reply == false) {\n      *value = UINT64_MAX;\n      return;\n    }\n\n    rc = memcached_response(instance, &instance->root->result);\n  }\n\n  if (memcached_fatal(rc)) {\n    assert(memcached_last_error(instance->root) != MEMCACHED_SUCCESS);\n    *value = UINT64_MAX;\n  } else if (memcached_failed(rc)) {\n    *value = UINT64_MAX;\n  } else {\n    assert(memcached_last_error(instance->root) != MEMCACHED_NOTFOUND);\n    *value = instance->root->result.numeric_value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*memc",
            "MEMCACHED_INVALID_ARGUMENTS",
            "MEMCACHED_AT",
            "memcached_literal_param(\n            \"memcached_increment_with_initial_by_key() is not supported via the ASCII protocol\")"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"memcached_increment_with_initial_by_key() is not supported via the ASCII protocol\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "binary_incr_decr",
          "args": [
            "instance",
            "command",
            "key",
            "key_length",
            "offset",
            "initial",
            "uint32_t(expiration)",
            "reply"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "binary_incr_decr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
          "lines": "70-107",
          "snippet": "static memcached_return_t binary_incr_decr(memcached_instance_st *instance,\n                                           protocol_binary_command cmd, const char *key,\n                                           const size_t key_length, const uint64_t offset,\n                                           const uint64_t initial, const uint32_t expiration,\n                                           const bool reply) {\n  if (reply == false) {\n    if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {\n      cmd = PROTOCOL_BINARY_CMD_DECREMENTQ;\n    }\n\n    if (cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n      cmd = PROTOCOL_BINARY_CMD_INCREMENTQ;\n    }\n  }\n  protocol_binary_request_incr request = {}; // = {.bytes= {0}};\n\n  initialize_binary_request(instance, request.message.header);\n\n  request.message.header.request.opcode = cmd;\n  request.message.header.request.keylen =\n      htons((uint16_t)(key_length + memcached_array_size(instance->root->_namespace)));\n  request.message.header.request.extlen = 20;\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n  request.message.header.request.bodylen =\n      htonl((uint32_t)(key_length + memcached_array_size(instance->root->_namespace)\n                       + request.message.header.request.extlen));\n  request.message.body.delta = memcached_htonll(offset);\n  request.message.body.initial = memcached_htonll(initial);\n  request.message.body.expiration = htonl((uint32_t) expiration);\n\n  libmemcached_io_vector_st vector[] = {{NULL, 0},\n                                        {request.bytes, sizeof(request.bytes)},\n                                        {memcached_array_string(instance->root->_namespace),\n                                         memcached_array_size(instance->root->_namespace)},\n                                        {key, key_length}};\n\n  return memcached_vdo(instance, vector, 4, true);\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t binary_incr_decr(memcached_instance_st *instance,\n                                           protocol_binary_command cmd, const char *key,\n                                           const size_t key_length, const uint64_t offset,\n                                           const uint64_t initial, const uint32_t expiration,\n                                           const bool reply) {\n  if (reply == false) {\n    if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {\n      cmd = PROTOCOL_BINARY_CMD_DECREMENTQ;\n    }\n\n    if (cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n      cmd = PROTOCOL_BINARY_CMD_INCREMENTQ;\n    }\n  }\n  protocol_binary_request_incr request = {}; // = {.bytes= {0}};\n\n  initialize_binary_request(instance, request.message.header);\n\n  request.message.header.request.opcode = cmd;\n  request.message.header.request.keylen =\n      htons((uint16_t)(key_length + memcached_array_size(instance->root->_namespace)));\n  request.message.header.request.extlen = 20;\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n  request.message.header.request.bodylen =\n      htonl((uint32_t)(key_length + memcached_array_size(instance->root->_namespace)\n                       + request.message.header.request.extlen));\n  request.message.body.delta = memcached_htonll(offset);\n  request.message.body.initial = memcached_htonll(initial);\n  request.message.body.expiration = htonl((uint32_t) expiration);\n\n  libmemcached_io_vector_st vector[] = {{NULL, 0},\n                                        {request.bytes, sizeof(request.bytes)},\n                                        {memcached_array_string(instance->root->_namespace),\n                                         memcached_array_size(instance->root->_namespace)},\n                                        {key, key_length}};\n\n  return memcached_vdo(instance, vector, 4, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uint32_t",
          "args": [
            "expiration"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_binary",
          "args": [
            "memc"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_replying",
          "args": [
            "instance->root"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "memc",
            "server_key"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_generate_hash_with_redistribution",
          "args": [
            "memc",
            "group_key",
            "group_key_length"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_generate_hash_with_redistribution",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
          "lines": "109-116",
          "snippet": "uint32_t memcached_generate_hash_with_redistribution(memcached_st *ptr, const char *key,\n                                                     size_t key_length) {\n  uint32_t hash = _generate_hash_wrapper(ptr, key, key_length);\n\n  _regen_for_auto_eject(ptr);\n\n  return dispatch_host(ptr, hash);\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nuint32_t memcached_generate_hash_with_redistribution(memcached_st *ptr, const char *key,\n                                                     size_t key_length) {\n  uint32_t hash = _generate_hash_wrapper(ptr, key, key_length);\n\n  _regen_for_auto_eject(ptr);\n\n  return dispatch_host(ptr, hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_last_error",
          "args": [
            "memc"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_last_error_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "500-511",
          "snippet": "int memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nint memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = memcached_key_test(*memc, (const char **) &key, &key_length, 1)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_key_test",
          "args": [
            "*memc",
            "(const char **) &key",
            "&key_length",
            "1"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_key_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/key.cc",
          "lines": "43-81",
          "snippet": "memcached_return_t memcached_key_test(memcached_st &memc, const char *const *keys,\n                                      const size_t *key_length, size_t number_of_keys) {\n  if (number_of_keys == 0) {\n    return memcached_set_error(memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Numbers of keys provided was zero\"));\n  }\n\n  if (keys == NULL or key_length == NULL) {\n    return memcached_set_error(memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n                               memcached_literal_param(\"Key was NULL or length of key was zero.\"));\n  }\n\n  const bool is_binary = memcached_flag(memc, MEMCACHED_FLAG_BINARY_PROTOCOL);\n\n  // If we don't need to verify the key, or we are using the binary protoocol,\n  // we just check the size of the key\n  for (size_t x = 0; x < number_of_keys; ++x) {\n    // We should set binary key, but the memcached server is broken for\n    // longer keys at the moment.\n    memcached_return_t rc =\n        memcached_validate_key_length(*(key_length + x), false /* memc.flags.binary_protocol */);\n    if (memcached_failed(rc)) {\n      return memcached_set_error(memc, rc, MEMCACHED_AT,\n                                 memcached_literal_param(\"Key provided was too long.\"));\n    }\n\n    if (memc.flags.verify_key and is_binary == false) {\n      for (size_t y = 0; y < *(key_length + x); ++y) {\n        if ((isgraph(keys[x][y])) == 0) {\n          return memcached_set_error(\n              memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n              memcached_literal_param(\"Key provided had invalid character.\"));\n        }\n      }\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_key_test(memcached_st &memc, const char *const *keys,\n                                      const size_t *key_length, size_t number_of_keys) {\n  if (number_of_keys == 0) {\n    return memcached_set_error(memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Numbers of keys provided was zero\"));\n  }\n\n  if (keys == NULL or key_length == NULL) {\n    return memcached_set_error(memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n                               memcached_literal_param(\"Key was NULL or length of key was zero.\"));\n  }\n\n  const bool is_binary = memcached_flag(memc, MEMCACHED_FLAG_BINARY_PROTOCOL);\n\n  // If we don't need to verify the key, or we are using the binary protoocol,\n  // we just check the size of the key\n  for (size_t x = 0; x < number_of_keys; ++x) {\n    // We should set binary key, but the memcached server is broken for\n    // longer keys at the moment.\n    memcached_return_t rc =\n        memcached_validate_key_length(*(key_length + x), false /* memc.flags.binary_protocol */);\n    if (memcached_failed(rc)) {\n      return memcached_set_error(memc, rc, MEMCACHED_AT,\n                                 memcached_literal_param(\"Key provided was too long.\"));\n    }\n\n    if (memc.flags.verify_key and is_binary == false) {\n      for (size_t y = 0; y < *(key_length + x); ++y) {\n        if ((isgraph(keys[x][y])) == 0) {\n          return memcached_set_error(\n              memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n              memcached_literal_param(\"Key provided had invalid character.\"));\n        }\n      }\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Operation not allowed while encryption is enabled\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_encrypted",
          "args": [
            "memc"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = initialize_query(memc, true)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_query",
          "args": [
            "memc",
            "true"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/initialize_query.cc",
          "lines": "18-39",
          "snippet": "memcached_return_t initialize_query(Memcached *self, bool increment_query_id) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (increment_query_id) {\n    self->query_id++;\n  }\n\n  if (self->state.is_time_for_rebuild) {\n    memcached_reset(self);\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return memcached_set_error(*self, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  memcached_error_free(*self);\n  memcached_result_reset(&self->result);\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t initialize_query(Memcached *self, bool increment_query_id) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (increment_query_id) {\n    self->query_id++;\n  }\n\n  if (self->state.is_time_for_rebuild) {\n    memcached_reset(self);\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return memcached_set_error(*self, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  memcached_error_free(*self);\n  memcached_result_reset(&self->result);\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t\nincrement_decrement_with_initial_by_key(const protocol_binary_command command, Memcached *memc,\n                                        const char *group_key, size_t group_key_length,\n                                        const char *key, size_t key_length, uint64_t offset,\n                                        uint64_t initial, time_t expiration, uint64_t *value) {\n  uint64_t local_value;\n  if (value == NULL) {\n    value = &local_value;\n  }\n\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(memc, true))) {\n    return rc;\n  }\n\n  if (memcached_is_encrypted(memc)) {\n    return memcached_set_error(\n        *memc, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"Operation not allowed while encryption is enabled\"));\n  }\n\n  if (memcached_failed(rc = memcached_key_test(*memc, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(memc);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(memc, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(memc, server_key);\n\n  bool reply = memcached_is_replying(instance->root);\n\n  if (memcached_is_binary(memc)) {\n    rc = binary_incr_decr(instance, command, key, key_length, offset, initial, uint32_t(expiration),\n                          reply);\n\n  } else {\n    rc = memcached_set_error(\n        *memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"memcached_increment_with_initial_by_key() is not supported via the ASCII protocol\"));\n  }\n\n  auto_response(instance, reply, rc, value);\n\n  return rc;\n}"
  },
  {
    "function_name": "increment_decrement_by_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
    "lines": "114-156",
    "snippet": "static memcached_return_t increment_decrement_by_key(const protocol_binary_command command,\n                                                     Memcached *memc, const char *group_key,\n                                                     size_t group_key_length, const char *key,\n                                                     size_t key_length, uint64_t offset,\n                                                     uint64_t *value) {\n  uint64_t local_value;\n  if (value == NULL) {\n    value = &local_value;\n  }\n\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(memc, true))) {\n    return rc;\n  }\n\n  if (memcached_is_encrypted(memc)) {\n    return memcached_set_error(\n        *memc, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n  }\n\n  if (memcached_failed(rc = memcached_key_test(*memc, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(memc);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(memc, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(memc, server_key);\n\n  bool reply = memcached_is_replying(instance->root);\n\n  if (memcached_is_binary(memc)) {\n    rc = binary_incr_decr(instance, command, key, key_length, uint64_t(offset), 0,\n                          MEMCACHED_EXPIRATION_NOT_ADD, reply);\n  } else {\n    rc = text_incr_decr(instance, command == PROTOCOL_BINARY_CMD_INCREMENT ? true : false, key,\n                        key_length, offset, reply);\n  }\n\n  auto_response(instance, reply, rc, value);\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "auto_response",
          "args": [
            "instance",
            "reply",
            "rc",
            "value"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "auto_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
          "lines": "18-40",
          "snippet": "static void auto_response(memcached_instance_st *instance, const bool reply, memcached_return_t &rc,\n                          uint64_t *value) {\n  // If the message was successfully sent, then get the response, otherwise\n  // fail.\n  if (memcached_success(rc)) {\n    if (reply == false) {\n      *value = UINT64_MAX;\n      return;\n    }\n\n    rc = memcached_response(instance, &instance->root->result);\n  }\n\n  if (memcached_fatal(rc)) {\n    assert(memcached_last_error(instance->root) != MEMCACHED_SUCCESS);\n    *value = UINT64_MAX;\n  } else if (memcached_failed(rc)) {\n    *value = UINT64_MAX;\n  } else {\n    assert(memcached_last_error(instance->root) != MEMCACHED_NOTFOUND);\n    *value = instance->root->result.numeric_value;\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic void auto_response(memcached_instance_st *instance, const bool reply, memcached_return_t &rc,\n                          uint64_t *value) {\n  // If the message was successfully sent, then get the response, otherwise\n  // fail.\n  if (memcached_success(rc)) {\n    if (reply == false) {\n      *value = UINT64_MAX;\n      return;\n    }\n\n    rc = memcached_response(instance, &instance->root->result);\n  }\n\n  if (memcached_fatal(rc)) {\n    assert(memcached_last_error(instance->root) != MEMCACHED_SUCCESS);\n    *value = UINT64_MAX;\n  } else if (memcached_failed(rc)) {\n    *value = UINT64_MAX;\n  } else {\n    assert(memcached_last_error(instance->root) != MEMCACHED_NOTFOUND);\n    *value = instance->root->result.numeric_value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_incr_decr",
          "args": [
            "instance",
            "command == PROTOCOL_BINARY_CMD_INCREMENT ? true : false",
            "key",
            "key_length",
            "offset",
            "reply"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "text_incr_decr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
          "lines": "42-68",
          "snippet": "static memcached_return_t text_incr_decr(memcached_instance_st *instance, const bool is_incr,\n                                         const char *key, size_t key_length, const uint64_t offset,\n                                         const bool reply) {\n  char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n\n  int send_length = snprintf(buffer, sizeof(buffer), \" %\" PRIu64, offset);\n  if (size_t(send_length) >= sizeof(buffer) or send_length < 0) {\n    return memcached_set_error(*instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"snprintf(MEMCACHED_DEFAULT_COMMAND_SIZE)\"));\n  }\n\n  libmemcached_io_vector_st vector[] = {\n      {NULL, 0},\n      {memcached_literal_param(\"incr \")},\n      {memcached_array_string(instance->root->_namespace),\n       memcached_array_size(instance->root->_namespace)},\n      {key, key_length},\n      {buffer, size_t(send_length)},\n      {\" noreply\", reply ? 0 : memcached_literal_param_size(\" noreply\")},\n      {memcached_literal_param(\"\\r\\n\")}};\n\n  if (is_incr == false) {\n    vector[1].buffer = \"decr \";\n  }\n\n  return memcached_vdo(instance, vector, 7, true);\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t text_incr_decr(memcached_instance_st *instance, const bool is_incr,\n                                         const char *key, size_t key_length, const uint64_t offset,\n                                         const bool reply) {\n  char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n\n  int send_length = snprintf(buffer, sizeof(buffer), \" %\" PRIu64, offset);\n  if (size_t(send_length) >= sizeof(buffer) or send_length < 0) {\n    return memcached_set_error(*instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"snprintf(MEMCACHED_DEFAULT_COMMAND_SIZE)\"));\n  }\n\n  libmemcached_io_vector_st vector[] = {\n      {NULL, 0},\n      {memcached_literal_param(\"incr \")},\n      {memcached_array_string(instance->root->_namespace),\n       memcached_array_size(instance->root->_namespace)},\n      {key, key_length},\n      {buffer, size_t(send_length)},\n      {\" noreply\", reply ? 0 : memcached_literal_param_size(\" noreply\")},\n      {memcached_literal_param(\"\\r\\n\")}};\n\n  if (is_incr == false) {\n    vector[1].buffer = \"decr \";\n  }\n\n  return memcached_vdo(instance, vector, 7, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "binary_incr_decr",
          "args": [
            "instance",
            "command",
            "key",
            "key_length",
            "uint64_t(offset)",
            "0",
            "MEMCACHED_EXPIRATION_NOT_ADD",
            "reply"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "binary_incr_decr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
          "lines": "70-107",
          "snippet": "static memcached_return_t binary_incr_decr(memcached_instance_st *instance,\n                                           protocol_binary_command cmd, const char *key,\n                                           const size_t key_length, const uint64_t offset,\n                                           const uint64_t initial, const uint32_t expiration,\n                                           const bool reply) {\n  if (reply == false) {\n    if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {\n      cmd = PROTOCOL_BINARY_CMD_DECREMENTQ;\n    }\n\n    if (cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n      cmd = PROTOCOL_BINARY_CMD_INCREMENTQ;\n    }\n  }\n  protocol_binary_request_incr request = {}; // = {.bytes= {0}};\n\n  initialize_binary_request(instance, request.message.header);\n\n  request.message.header.request.opcode = cmd;\n  request.message.header.request.keylen =\n      htons((uint16_t)(key_length + memcached_array_size(instance->root->_namespace)));\n  request.message.header.request.extlen = 20;\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n  request.message.header.request.bodylen =\n      htonl((uint32_t)(key_length + memcached_array_size(instance->root->_namespace)\n                       + request.message.header.request.extlen));\n  request.message.body.delta = memcached_htonll(offset);\n  request.message.body.initial = memcached_htonll(initial);\n  request.message.body.expiration = htonl((uint32_t) expiration);\n\n  libmemcached_io_vector_st vector[] = {{NULL, 0},\n                                        {request.bytes, sizeof(request.bytes)},\n                                        {memcached_array_string(instance->root->_namespace),\n                                         memcached_array_size(instance->root->_namespace)},\n                                        {key, key_length}};\n\n  return memcached_vdo(instance, vector, 4, true);\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t binary_incr_decr(memcached_instance_st *instance,\n                                           protocol_binary_command cmd, const char *key,\n                                           const size_t key_length, const uint64_t offset,\n                                           const uint64_t initial, const uint32_t expiration,\n                                           const bool reply) {\n  if (reply == false) {\n    if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {\n      cmd = PROTOCOL_BINARY_CMD_DECREMENTQ;\n    }\n\n    if (cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n      cmd = PROTOCOL_BINARY_CMD_INCREMENTQ;\n    }\n  }\n  protocol_binary_request_incr request = {}; // = {.bytes= {0}};\n\n  initialize_binary_request(instance, request.message.header);\n\n  request.message.header.request.opcode = cmd;\n  request.message.header.request.keylen =\n      htons((uint16_t)(key_length + memcached_array_size(instance->root->_namespace)));\n  request.message.header.request.extlen = 20;\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n  request.message.header.request.bodylen =\n      htonl((uint32_t)(key_length + memcached_array_size(instance->root->_namespace)\n                       + request.message.header.request.extlen));\n  request.message.body.delta = memcached_htonll(offset);\n  request.message.body.initial = memcached_htonll(initial);\n  request.message.body.expiration = htonl((uint32_t) expiration);\n\n  libmemcached_io_vector_st vector[] = {{NULL, 0},\n                                        {request.bytes, sizeof(request.bytes)},\n                                        {memcached_array_string(instance->root->_namespace),\n                                         memcached_array_size(instance->root->_namespace)},\n                                        {key, key_length}};\n\n  return memcached_vdo(instance, vector, 4, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uint64_t",
          "args": [
            "offset"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_binary",
          "args": [
            "memc"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_replying",
          "args": [
            "instance->root"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "memc",
            "server_key"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_generate_hash_with_redistribution",
          "args": [
            "memc",
            "group_key",
            "group_key_length"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_generate_hash_with_redistribution",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
          "lines": "109-116",
          "snippet": "uint32_t memcached_generate_hash_with_redistribution(memcached_st *ptr, const char *key,\n                                                     size_t key_length) {\n  uint32_t hash = _generate_hash_wrapper(ptr, key, key_length);\n\n  _regen_for_auto_eject(ptr);\n\n  return dispatch_host(ptr, hash);\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nuint32_t memcached_generate_hash_with_redistribution(memcached_st *ptr, const char *key,\n                                                     size_t key_length) {\n  uint32_t hash = _generate_hash_wrapper(ptr, key, key_length);\n\n  _regen_for_auto_eject(ptr);\n\n  return dispatch_host(ptr, hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_last_error",
          "args": [
            "memc"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_last_error_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "500-511",
          "snippet": "int memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nint memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = memcached_key_test(*memc, (const char **) &key, &key_length, 1)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_key_test",
          "args": [
            "*memc",
            "(const char **) &key",
            "&key_length",
            "1"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_key_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/key.cc",
          "lines": "43-81",
          "snippet": "memcached_return_t memcached_key_test(memcached_st &memc, const char *const *keys,\n                                      const size_t *key_length, size_t number_of_keys) {\n  if (number_of_keys == 0) {\n    return memcached_set_error(memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Numbers of keys provided was zero\"));\n  }\n\n  if (keys == NULL or key_length == NULL) {\n    return memcached_set_error(memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n                               memcached_literal_param(\"Key was NULL or length of key was zero.\"));\n  }\n\n  const bool is_binary = memcached_flag(memc, MEMCACHED_FLAG_BINARY_PROTOCOL);\n\n  // If we don't need to verify the key, or we are using the binary protoocol,\n  // we just check the size of the key\n  for (size_t x = 0; x < number_of_keys; ++x) {\n    // We should set binary key, but the memcached server is broken for\n    // longer keys at the moment.\n    memcached_return_t rc =\n        memcached_validate_key_length(*(key_length + x), false /* memc.flags.binary_protocol */);\n    if (memcached_failed(rc)) {\n      return memcached_set_error(memc, rc, MEMCACHED_AT,\n                                 memcached_literal_param(\"Key provided was too long.\"));\n    }\n\n    if (memc.flags.verify_key and is_binary == false) {\n      for (size_t y = 0; y < *(key_length + x); ++y) {\n        if ((isgraph(keys[x][y])) == 0) {\n          return memcached_set_error(\n              memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n              memcached_literal_param(\"Key provided had invalid character.\"));\n        }\n      }\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_key_test(memcached_st &memc, const char *const *keys,\n                                      const size_t *key_length, size_t number_of_keys) {\n  if (number_of_keys == 0) {\n    return memcached_set_error(memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Numbers of keys provided was zero\"));\n  }\n\n  if (keys == NULL or key_length == NULL) {\n    return memcached_set_error(memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n                               memcached_literal_param(\"Key was NULL or length of key was zero.\"));\n  }\n\n  const bool is_binary = memcached_flag(memc, MEMCACHED_FLAG_BINARY_PROTOCOL);\n\n  // If we don't need to verify the key, or we are using the binary protoocol,\n  // we just check the size of the key\n  for (size_t x = 0; x < number_of_keys; ++x) {\n    // We should set binary key, but the memcached server is broken for\n    // longer keys at the moment.\n    memcached_return_t rc =\n        memcached_validate_key_length(*(key_length + x), false /* memc.flags.binary_protocol */);\n    if (memcached_failed(rc)) {\n      return memcached_set_error(memc, rc, MEMCACHED_AT,\n                                 memcached_literal_param(\"Key provided was too long.\"));\n    }\n\n    if (memc.flags.verify_key and is_binary == false) {\n      for (size_t y = 0; y < *(key_length + x); ++y) {\n        if ((isgraph(keys[x][y])) == 0) {\n          return memcached_set_error(\n              memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n              memcached_literal_param(\"Key provided had invalid character.\"));\n        }\n      }\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*memc",
            "MEMCACHED_NOT_SUPPORTED",
            "MEMCACHED_AT",
            "memcached_literal_param(\"Operation not allowed while encyrption is enabled\")"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Operation not allowed while encyrption is enabled\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_encrypted",
          "args": [
            "memc"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = initialize_query(memc, true)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_query",
          "args": [
            "memc",
            "true"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/initialize_query.cc",
          "lines": "18-39",
          "snippet": "memcached_return_t initialize_query(Memcached *self, bool increment_query_id) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (increment_query_id) {\n    self->query_id++;\n  }\n\n  if (self->state.is_time_for_rebuild) {\n    memcached_reset(self);\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return memcached_set_error(*self, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  memcached_error_free(*self);\n  memcached_result_reset(&self->result);\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t initialize_query(Memcached *self, bool increment_query_id) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (increment_query_id) {\n    self->query_id++;\n  }\n\n  if (self->state.is_time_for_rebuild) {\n    memcached_reset(self);\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return memcached_set_error(*self, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  memcached_error_free(*self);\n  memcached_result_reset(&self->result);\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t increment_decrement_by_key(const protocol_binary_command command,\n                                                     Memcached *memc, const char *group_key,\n                                                     size_t group_key_length, const char *key,\n                                                     size_t key_length, uint64_t offset,\n                                                     uint64_t *value) {\n  uint64_t local_value;\n  if (value == NULL) {\n    value = &local_value;\n  }\n\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(memc, true))) {\n    return rc;\n  }\n\n  if (memcached_is_encrypted(memc)) {\n    return memcached_set_error(\n        *memc, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"Operation not allowed while encyrption is enabled\"));\n  }\n\n  if (memcached_failed(rc = memcached_key_test(*memc, (const char **) &key, &key_length, 1))) {\n    return memcached_last_error(memc);\n  }\n\n  uint32_t server_key =\n      memcached_generate_hash_with_redistribution(memc, group_key, group_key_length);\n  memcached_instance_st *instance = memcached_instance_fetch(memc, server_key);\n\n  bool reply = memcached_is_replying(instance->root);\n\n  if (memcached_is_binary(memc)) {\n    rc = binary_incr_decr(instance, command, key, key_length, uint64_t(offset), 0,\n                          MEMCACHED_EXPIRATION_NOT_ADD, reply);\n  } else {\n    rc = text_incr_decr(instance, command == PROTOCOL_BINARY_CMD_INCREMENT ? true : false, key,\n                        key_length, offset, reply);\n  }\n\n  auto_response(instance, reply, rc, value);\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_increment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
    "lines": "109-112",
    "snippet": "memcached_return_t memcached_increment(memcached_st *memc, const char *key, size_t key_length,\n                                       uint32_t offset, uint64_t *value) {\n  return memcached_increment_by_key(memc, key, key_length, key, key_length, offset, value);\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_increment_by_key",
          "args": [
            "memc",
            "key",
            "key_length",
            "key",
            "key_length",
            "offset",
            "value"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_increment_by_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
          "lines": "210-222",
          "snippet": "memcached_return_t memcached_increment_by_key(memcached_st *shell, const char *group_key,\n                                              size_t group_key_length, const char *key,\n                                              size_t key_length, uint64_t offset, uint64_t *value) {\n  Memcached *memc = memcached2Memcached(shell);\n  LIBMEMCACHED_MEMCACHED_INCREMENT_START();\n  memcached_return_t rc =\n      increment_decrement_by_key(PROTOCOL_BINARY_CMD_INCREMENT, memc, group_key, group_key_length,\n                                 key, key_length, offset, value);\n\n  LIBMEMCACHED_MEMCACHED_INCREMENT_END();\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_increment_by_key(memcached_st *shell, const char *group_key,\n                                              size_t group_key_length, const char *key,\n                                              size_t key_length, uint64_t offset, uint64_t *value) {\n  Memcached *memc = memcached2Memcached(shell);\n  LIBMEMCACHED_MEMCACHED_INCREMENT_START();\n  memcached_return_t rc =\n      increment_decrement_by_key(PROTOCOL_BINARY_CMD_INCREMENT, memc, group_key, group_key_length,\n                                 key, key_length, offset, value);\n\n  LIBMEMCACHED_MEMCACHED_INCREMENT_END();\n\n  return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_increment(memcached_st *memc, const char *key, size_t key_length,\n                                       uint32_t offset, uint64_t *value) {\n  return memcached_increment_by_key(memc, key, key_length, key, key_length, offset, value);\n}"
  },
  {
    "function_name": "binary_incr_decr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
    "lines": "70-107",
    "snippet": "static memcached_return_t binary_incr_decr(memcached_instance_st *instance,\n                                           protocol_binary_command cmd, const char *key,\n                                           const size_t key_length, const uint64_t offset,\n                                           const uint64_t initial, const uint32_t expiration,\n                                           const bool reply) {\n  if (reply == false) {\n    if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {\n      cmd = PROTOCOL_BINARY_CMD_DECREMENTQ;\n    }\n\n    if (cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n      cmd = PROTOCOL_BINARY_CMD_INCREMENTQ;\n    }\n  }\n  protocol_binary_request_incr request = {}; // = {.bytes= {0}};\n\n  initialize_binary_request(instance, request.message.header);\n\n  request.message.header.request.opcode = cmd;\n  request.message.header.request.keylen =\n      htons((uint16_t)(key_length + memcached_array_size(instance->root->_namespace)));\n  request.message.header.request.extlen = 20;\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n  request.message.header.request.bodylen =\n      htonl((uint32_t)(key_length + memcached_array_size(instance->root->_namespace)\n                       + request.message.header.request.extlen));\n  request.message.body.delta = memcached_htonll(offset);\n  request.message.body.initial = memcached_htonll(initial);\n  request.message.body.expiration = htonl((uint32_t) expiration);\n\n  libmemcached_io_vector_st vector[] = {{NULL, 0},\n                                        {request.bytes, sizeof(request.bytes)},\n                                        {memcached_array_string(instance->root->_namespace),\n                                         memcached_array_size(instance->root->_namespace)},\n                                        {key, key_length}};\n\n  return memcached_vdo(instance, vector, 4, true);\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_vdo",
          "args": [
            "instance",
            "vector",
            "4",
            "true"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_vdo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/do.cc",
          "lines": "64-100",
          "snippet": "memcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_array_size",
          "args": [
            "instance->root->_namespace"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_array_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/array.cc",
          "lines": "78-84",
          "snippet": "size_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"libmemcached/common.h\"\n\nsize_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_array_string",
          "args": [
            "instance->root->_namespace"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(uint32_t) expiration"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_htonll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "55-61",
          "snippet": "uint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "(uint16_t)(key_length + memcached_array_size(instance->root->_namespace))"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_binary_request",
          "args": [
            "instance",
            "request.message.header"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_binary_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "20-25",
          "snippet": "void initialize_binary_request(memcached_instance_st *server,\n                               protocol_binary_request_header &header) {\n  server->request_id++;\n  header.request.magic = PROTOCOL_BINARY_REQ;\n  header.request.opaque = htons(server->request_id);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid initialize_binary_request(memcached_instance_st *server,\n                               protocol_binary_request_header &header) {\n  server->request_id++;\n  header.request.magic = PROTOCOL_BINARY_REQ;\n  header.request.opaque = htons(server->request_id);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t binary_incr_decr(memcached_instance_st *instance,\n                                           protocol_binary_command cmd, const char *key,\n                                           const size_t key_length, const uint64_t offset,\n                                           const uint64_t initial, const uint32_t expiration,\n                                           const bool reply) {\n  if (reply == false) {\n    if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {\n      cmd = PROTOCOL_BINARY_CMD_DECREMENTQ;\n    }\n\n    if (cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n      cmd = PROTOCOL_BINARY_CMD_INCREMENTQ;\n    }\n  }\n  protocol_binary_request_incr request = {}; // = {.bytes= {0}};\n\n  initialize_binary_request(instance, request.message.header);\n\n  request.message.header.request.opcode = cmd;\n  request.message.header.request.keylen =\n      htons((uint16_t)(key_length + memcached_array_size(instance->root->_namespace)));\n  request.message.header.request.extlen = 20;\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n  request.message.header.request.bodylen =\n      htonl((uint32_t)(key_length + memcached_array_size(instance->root->_namespace)\n                       + request.message.header.request.extlen));\n  request.message.body.delta = memcached_htonll(offset);\n  request.message.body.initial = memcached_htonll(initial);\n  request.message.body.expiration = htonl((uint32_t) expiration);\n\n  libmemcached_io_vector_st vector[] = {{NULL, 0},\n                                        {request.bytes, sizeof(request.bytes)},\n                                        {memcached_array_string(instance->root->_namespace),\n                                         memcached_array_size(instance->root->_namespace)},\n                                        {key, key_length}};\n\n  return memcached_vdo(instance, vector, 4, true);\n}"
  },
  {
    "function_name": "text_incr_decr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
    "lines": "42-68",
    "snippet": "static memcached_return_t text_incr_decr(memcached_instance_st *instance, const bool is_incr,\n                                         const char *key, size_t key_length, const uint64_t offset,\n                                         const bool reply) {\n  char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n\n  int send_length = snprintf(buffer, sizeof(buffer), \" %\" PRIu64, offset);\n  if (size_t(send_length) >= sizeof(buffer) or send_length < 0) {\n    return memcached_set_error(*instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"snprintf(MEMCACHED_DEFAULT_COMMAND_SIZE)\"));\n  }\n\n  libmemcached_io_vector_st vector[] = {\n      {NULL, 0},\n      {memcached_literal_param(\"incr \")},\n      {memcached_array_string(instance->root->_namespace),\n       memcached_array_size(instance->root->_namespace)},\n      {key, key_length},\n      {buffer, size_t(send_length)},\n      {\" noreply\", reply ? 0 : memcached_literal_param_size(\" noreply\")},\n      {memcached_literal_param(\"\\r\\n\")}};\n\n  if (is_incr == false) {\n    vector[1].buffer = \"decr \";\n  }\n\n  return memcached_vdo(instance, vector, 7, true);\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_vdo",
          "args": [
            "instance",
            "vector",
            "7",
            "true"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_vdo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/do.cc",
          "lines": "64-100",
          "snippet": "memcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"\\r\\n\""
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param_size",
          "args": [
            "\" noreply\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "send_length"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_array_size",
          "args": [
            "instance->root->_namespace"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_array_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/array.cc",
          "lines": "78-84",
          "snippet": "size_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"libmemcached/common.h\"\n\nsize_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_array_string",
          "args": [
            "instance->root->_namespace"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"incr \""
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*instance",
            "MEMCACHED_MEMORY_ALLOCATION_FAILURE",
            "MEMCACHED_AT",
            "memcached_literal_param(\"snprintf(MEMCACHED_DEFAULT_COMMAND_SIZE)\")"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"snprintf(MEMCACHED_DEFAULT_COMMAND_SIZE)\""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "send_length"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\" %\"PRIu64",
            "offset"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t text_incr_decr(memcached_instance_st *instance, const bool is_incr,\n                                         const char *key, size_t key_length, const uint64_t offset,\n                                         const bool reply) {\n  char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n\n  int send_length = snprintf(buffer, sizeof(buffer), \" %\" PRIu64, offset);\n  if (size_t(send_length) >= sizeof(buffer) or send_length < 0) {\n    return memcached_set_error(*instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"snprintf(MEMCACHED_DEFAULT_COMMAND_SIZE)\"));\n  }\n\n  libmemcached_io_vector_st vector[] = {\n      {NULL, 0},\n      {memcached_literal_param(\"incr \")},\n      {memcached_array_string(instance->root->_namespace),\n       memcached_array_size(instance->root->_namespace)},\n      {key, key_length},\n      {buffer, size_t(send_length)},\n      {\" noreply\", reply ? 0 : memcached_literal_param_size(\" noreply\")},\n      {memcached_literal_param(\"\\r\\n\")}};\n\n  if (is_incr == false) {\n    vector[1].buffer = \"decr \";\n  }\n\n  return memcached_vdo(instance, vector, 7, true);\n}"
  },
  {
    "function_name": "auto_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/auto.cc",
    "lines": "18-40",
    "snippet": "static void auto_response(memcached_instance_st *instance, const bool reply, memcached_return_t &rc,\n                          uint64_t *value) {\n  // If the message was successfully sent, then get the response, otherwise\n  // fail.\n  if (memcached_success(rc)) {\n    if (reply == false) {\n      *value = UINT64_MAX;\n      return;\n    }\n\n    rc = memcached_response(instance, &instance->root->result);\n  }\n\n  if (memcached_fatal(rc)) {\n    assert(memcached_last_error(instance->root) != MEMCACHED_SUCCESS);\n    *value = UINT64_MAX;\n  } else if (memcached_failed(rc)) {\n    *value = UINT64_MAX;\n  } else {\n    assert(memcached_last_error(instance->root) != MEMCACHED_NOTFOUND);\n    *value = instance->root->result.numeric_value;\n  }\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "memcached_last_error(instance->root) != MEMCACHED_NOTFOUND"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error",
          "args": [
            "instance->root"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_last_error_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "500-511",
          "snippet": "int memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nint memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "memcached_last_error(instance->root) != MEMCACHED_SUCCESS"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_fatal",
          "args": [
            "rc"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_response",
          "args": [
            "instance",
            "&instance->root->result"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
          "lines": "782-787",
          "snippet": "memcached_return_t memcached_response(memcached_instance_st *instance,\n                                      memcached_result_st *result) {\n  char buffer[1024];\n\n  return memcached_response(instance, buffer, sizeof(buffer), result);\n}",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_response(memcached_instance_st *instance,\n                                      memcached_result_st *result) {\n  char buffer[1024];\n\n  return memcached_response(instance, buffer, sizeof(buffer), result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic void auto_response(memcached_instance_st *instance, const bool reply, memcached_return_t &rc,\n                          uint64_t *value) {\n  // If the message was successfully sent, then get the response, otherwise\n  // fail.\n  if (memcached_success(rc)) {\n    if (reply == false) {\n      *value = UINT64_MAX;\n      return;\n    }\n\n    rc = memcached_response(instance, &instance->root->result);\n  }\n\n  if (memcached_fatal(rc)) {\n    assert(memcached_last_error(instance->root) != MEMCACHED_SUCCESS);\n    *value = UINT64_MAX;\n  } else if (memcached_failed(rc)) {\n    *value = UINT64_MAX;\n  } else {\n    assert(memcached_last_error(instance->root) != MEMCACHED_NOTFOUND);\n    *value = instance->root->result.numeric_value;\n  }\n}"
  }
]