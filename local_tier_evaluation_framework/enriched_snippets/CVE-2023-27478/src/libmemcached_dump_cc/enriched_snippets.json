[
  {
    "function_name": "memcached_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/dump.cc",
    "lines": "112-131",
    "snippet": "memcached_return_t memcached_dump(memcached_st *shell, memcached_dump_fn *callback, void *context,\n                                  uint32_t number_of_callbacks) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  /*\n    No support for Binary protocol yet\n    @todo Fix this so that we just flush, switch to ascii, and then go back to binary.\n  */\n  if (memcached_is_binary(ptr)) {\n    return memcached_set_error(\n        *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"Binary protocol is not supported for memcached_dump()\"));\n  }\n\n  return ascii_dump(ptr, callback, context, number_of_callbacks);\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ascii_dump",
          "args": [
            "ptr",
            "callback",
            "context",
            "number_of_callbacks"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/dump.cc",
          "lines": "18-110",
          "snippet": "static memcached_return_t ascii_dump(Memcached *memc, memcached_dump_fn *callback, void *context,\n                                     uint32_t number_of_callbacks) {\n  memcached_version(memc);\n  /* MAX_NUMBER_OF_SLAB_CLASSES is defined to 200 in Memcached 1.4.10 */\n  for (uint32_t x = 0; x < 200; x++) {\n    char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n    int buffer_length = snprintf(buffer, sizeof(buffer), \"%u\", x);\n    if (size_t(buffer_length) >= sizeof(buffer) or buffer_length < 0) {\n      return memcached_set_error(\n          *memc, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n          memcached_literal_param(\"snprintf(MEMCACHED_DEFAULT_COMMAND_SIZE)\"));\n    }\n\n    // @NOTE the hard coded zero means \"no limit\"\n    libmemcached_io_vector_st vector[] = {{memcached_literal_param(\"stats cachedump \")},\n                                          {buffer, size_t(buffer_length)},\n                                          {memcached_literal_param(\" 0\\r\\n\")}};\n\n    // Send message to all servers\n    for (uint32_t server_key = 0; server_key < memcached_server_count(memc); server_key++) {\n      memcached_instance_st *instance = memcached_instance_fetch(memc, server_key);\n\n      // skip slabs >63 for server versions >= 1.4.23\n      if (x < 64 || memcached_version_instance_cmp(instance, 1, 4, 23) < 0) {\n        memcached_return_t vdo_rc;\n        if (memcached_failed((vdo_rc = memcached_vdo(instance, vector, 3, true)))) {\n          return vdo_rc;\n        }\n      }\n    }\n\n    // Collect the returned items\n    memcached_instance_st *instance;\n    memcached_return_t read_ret = MEMCACHED_SUCCESS;\n    while ((instance = memcached_io_get_readable_server(memc, read_ret))) {\n      memcached_return_t response_rc =\n          memcached_response(instance, buffer, MEMCACHED_DEFAULT_COMMAND_SIZE, NULL);\n      if (response_rc == MEMCACHED_ITEM) {\n        char *string_ptr, *end_ptr;\n\n        string_ptr = buffer;\n        string_ptr += 5; /* Move past ITEM */\n\n        for (end_ptr = string_ptr; isgraph(*end_ptr); end_ptr++) {\n        };\n\n        char *key = string_ptr;\n        key[(size_t)(end_ptr - string_ptr)] = 0;\n\n        for (uint32_t callback_counter = 0; callback_counter < number_of_callbacks;\n             callback_counter++) {\n          memcached_return_t callback_rc =\n              (*callback[callback_counter])(memc, key, (size_t)(end_ptr - string_ptr), context);\n          if (callback_rc != MEMCACHED_SUCCESS) {\n            // @todo build up a message for the error from the value\n            memcached_set_error(*instance, callback_rc, MEMCACHED_AT);\n            break;\n          }\n        }\n      } else if (response_rc == MEMCACHED_END) {\n        // All items have been returned\n      } else if (response_rc == MEMCACHED_SERVER_ERROR) {\n        /* If we try to request stats cachedump for a slab class that is too big\n         * the server will return an incorrect error message:\n         * \"MEMCACHED_SERVER_ERROR failed to allocate memory\"\n         * This isn't really a fatal error, so let's just skip it. I want to\n         * fix the return value from the memcached server to a CLIENT_ERROR,\n         * so let's add support for that as well right now.\n         */\n        assert(response_rc == MEMCACHED_SUCCESS); // Just fail\n        return response_rc;\n      } else if (response_rc == MEMCACHED_CLIENT_ERROR) {\n        /* The maximum number of slabs has changed in the past (currently 1<<6-1),\n         * so ignore any client errors complaining about an illegal slab id.\n         */\n        if (0\n            == strncmp(buffer, \"CLIENT_ERROR Illegal slab id\",\n                       sizeof(\"CLIENT_ERROR Illegal slab id\") - 1))\n        {\n          memcached_error_free(*instance);\n          memcached_error_free(*memc);\n        } else {\n          return response_rc;\n        }\n      } else {\n        // IO error of some sort must have occurred\n        return response_rc;\n      }\n    }\n  }\n\n  return memcached_has_current_error(*memc) ? MEMCACHED_SOME_ERRORS : MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t ascii_dump(Memcached *memc, memcached_dump_fn *callback, void *context,\n                                     uint32_t number_of_callbacks) {\n  memcached_version(memc);\n  /* MAX_NUMBER_OF_SLAB_CLASSES is defined to 200 in Memcached 1.4.10 */\n  for (uint32_t x = 0; x < 200; x++) {\n    char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n    int buffer_length = snprintf(buffer, sizeof(buffer), \"%u\", x);\n    if (size_t(buffer_length) >= sizeof(buffer) or buffer_length < 0) {\n      return memcached_set_error(\n          *memc, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n          memcached_literal_param(\"snprintf(MEMCACHED_DEFAULT_COMMAND_SIZE)\"));\n    }\n\n    // @NOTE the hard coded zero means \"no limit\"\n    libmemcached_io_vector_st vector[] = {{memcached_literal_param(\"stats cachedump \")},\n                                          {buffer, size_t(buffer_length)},\n                                          {memcached_literal_param(\" 0\\r\\n\")}};\n\n    // Send message to all servers\n    for (uint32_t server_key = 0; server_key < memcached_server_count(memc); server_key++) {\n      memcached_instance_st *instance = memcached_instance_fetch(memc, server_key);\n\n      // skip slabs >63 for server versions >= 1.4.23\n      if (x < 64 || memcached_version_instance_cmp(instance, 1, 4, 23) < 0) {\n        memcached_return_t vdo_rc;\n        if (memcached_failed((vdo_rc = memcached_vdo(instance, vector, 3, true)))) {\n          return vdo_rc;\n        }\n      }\n    }\n\n    // Collect the returned items\n    memcached_instance_st *instance;\n    memcached_return_t read_ret = MEMCACHED_SUCCESS;\n    while ((instance = memcached_io_get_readable_server(memc, read_ret))) {\n      memcached_return_t response_rc =\n          memcached_response(instance, buffer, MEMCACHED_DEFAULT_COMMAND_SIZE, NULL);\n      if (response_rc == MEMCACHED_ITEM) {\n        char *string_ptr, *end_ptr;\n\n        string_ptr = buffer;\n        string_ptr += 5; /* Move past ITEM */\n\n        for (end_ptr = string_ptr; isgraph(*end_ptr); end_ptr++) {\n        };\n\n        char *key = string_ptr;\n        key[(size_t)(end_ptr - string_ptr)] = 0;\n\n        for (uint32_t callback_counter = 0; callback_counter < number_of_callbacks;\n             callback_counter++) {\n          memcached_return_t callback_rc =\n              (*callback[callback_counter])(memc, key, (size_t)(end_ptr - string_ptr), context);\n          if (callback_rc != MEMCACHED_SUCCESS) {\n            // @todo build up a message for the error from the value\n            memcached_set_error(*instance, callback_rc, MEMCACHED_AT);\n            break;\n          }\n        }\n      } else if (response_rc == MEMCACHED_END) {\n        // All items have been returned\n      } else if (response_rc == MEMCACHED_SERVER_ERROR) {\n        /* If we try to request stats cachedump for a slab class that is too big\n         * the server will return an incorrect error message:\n         * \"MEMCACHED_SERVER_ERROR failed to allocate memory\"\n         * This isn't really a fatal error, so let's just skip it. I want to\n         * fix the return value from the memcached server to a CLIENT_ERROR,\n         * so let's add support for that as well right now.\n         */\n        assert(response_rc == MEMCACHED_SUCCESS); // Just fail\n        return response_rc;\n      } else if (response_rc == MEMCACHED_CLIENT_ERROR) {\n        /* The maximum number of slabs has changed in the past (currently 1<<6-1),\n         * so ignore any client errors complaining about an illegal slab id.\n         */\n        if (0\n            == strncmp(buffer, \"CLIENT_ERROR Illegal slab id\",\n                       sizeof(\"CLIENT_ERROR Illegal slab id\") - 1))\n        {\n          memcached_error_free(*instance);\n          memcached_error_free(*memc);\n        } else {\n          return response_rc;\n        }\n      } else {\n        // IO error of some sort must have occurred\n        return response_rc;\n      }\n    }\n  }\n\n  return memcached_has_current_error(*memc) ? MEMCACHED_SOME_ERRORS : MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "MEMCACHED_NOT_SUPPORTED",
            "MEMCACHED_AT",
            "memcached_literal_param(\"Binary protocol is not supported for memcached_dump()\")"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Binary protocol is not supported for memcached_dump()\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_binary",
          "args": [
            "ptr"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = initialize_query(ptr, true)"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_query",
          "args": [
            "ptr",
            "true"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/initialize_query.cc",
          "lines": "18-39",
          "snippet": "memcached_return_t initialize_query(Memcached *self, bool increment_query_id) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (increment_query_id) {\n    self->query_id++;\n  }\n\n  if (self->state.is_time_for_rebuild) {\n    memcached_reset(self);\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return memcached_set_error(*self, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  memcached_error_free(*self);\n  memcached_result_reset(&self->result);\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t initialize_query(Memcached *self, bool increment_query_id) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (increment_query_id) {\n    self->query_id++;\n  }\n\n  if (self->state.is_time_for_rebuild) {\n    memcached_reset(self);\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return memcached_set_error(*self, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  memcached_error_free(*self);\n  memcached_result_reset(&self->result);\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_dump(memcached_st *shell, memcached_dump_fn *callback, void *context,\n                                  uint32_t number_of_callbacks) {\n  Memcached *ptr = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(ptr, true))) {\n    return rc;\n  }\n\n  /*\n    No support for Binary protocol yet\n    @todo Fix this so that we just flush, switch to ascii, and then go back to binary.\n  */\n  if (memcached_is_binary(ptr)) {\n    return memcached_set_error(\n        *ptr, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"Binary protocol is not supported for memcached_dump()\"));\n  }\n\n  return ascii_dump(ptr, callback, context, number_of_callbacks);\n}"
  },
  {
    "function_name": "ascii_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/dump.cc",
    "lines": "18-110",
    "snippet": "static memcached_return_t ascii_dump(Memcached *memc, memcached_dump_fn *callback, void *context,\n                                     uint32_t number_of_callbacks) {\n  memcached_version(memc);\n  /* MAX_NUMBER_OF_SLAB_CLASSES is defined to 200 in Memcached 1.4.10 */\n  for (uint32_t x = 0; x < 200; x++) {\n    char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n    int buffer_length = snprintf(buffer, sizeof(buffer), \"%u\", x);\n    if (size_t(buffer_length) >= sizeof(buffer) or buffer_length < 0) {\n      return memcached_set_error(\n          *memc, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n          memcached_literal_param(\"snprintf(MEMCACHED_DEFAULT_COMMAND_SIZE)\"));\n    }\n\n    // @NOTE the hard coded zero means \"no limit\"\n    libmemcached_io_vector_st vector[] = {{memcached_literal_param(\"stats cachedump \")},\n                                          {buffer, size_t(buffer_length)},\n                                          {memcached_literal_param(\" 0\\r\\n\")}};\n\n    // Send message to all servers\n    for (uint32_t server_key = 0; server_key < memcached_server_count(memc); server_key++) {\n      memcached_instance_st *instance = memcached_instance_fetch(memc, server_key);\n\n      // skip slabs >63 for server versions >= 1.4.23\n      if (x < 64 || memcached_version_instance_cmp(instance, 1, 4, 23) < 0) {\n        memcached_return_t vdo_rc;\n        if (memcached_failed((vdo_rc = memcached_vdo(instance, vector, 3, true)))) {\n          return vdo_rc;\n        }\n      }\n    }\n\n    // Collect the returned items\n    memcached_instance_st *instance;\n    memcached_return_t read_ret = MEMCACHED_SUCCESS;\n    while ((instance = memcached_io_get_readable_server(memc, read_ret))) {\n      memcached_return_t response_rc =\n          memcached_response(instance, buffer, MEMCACHED_DEFAULT_COMMAND_SIZE, NULL);\n      if (response_rc == MEMCACHED_ITEM) {\n        char *string_ptr, *end_ptr;\n\n        string_ptr = buffer;\n        string_ptr += 5; /* Move past ITEM */\n\n        for (end_ptr = string_ptr; isgraph(*end_ptr); end_ptr++) {\n        };\n\n        char *key = string_ptr;\n        key[(size_t)(end_ptr - string_ptr)] = 0;\n\n        for (uint32_t callback_counter = 0; callback_counter < number_of_callbacks;\n             callback_counter++) {\n          memcached_return_t callback_rc =\n              (*callback[callback_counter])(memc, key, (size_t)(end_ptr - string_ptr), context);\n          if (callback_rc != MEMCACHED_SUCCESS) {\n            // @todo build up a message for the error from the value\n            memcached_set_error(*instance, callback_rc, MEMCACHED_AT);\n            break;\n          }\n        }\n      } else if (response_rc == MEMCACHED_END) {\n        // All items have been returned\n      } else if (response_rc == MEMCACHED_SERVER_ERROR) {\n        /* If we try to request stats cachedump for a slab class that is too big\n         * the server will return an incorrect error message:\n         * \"MEMCACHED_SERVER_ERROR failed to allocate memory\"\n         * This isn't really a fatal error, so let's just skip it. I want to\n         * fix the return value from the memcached server to a CLIENT_ERROR,\n         * so let's add support for that as well right now.\n         */\n        assert(response_rc == MEMCACHED_SUCCESS); // Just fail\n        return response_rc;\n      } else if (response_rc == MEMCACHED_CLIENT_ERROR) {\n        /* The maximum number of slabs has changed in the past (currently 1<<6-1),\n         * so ignore any client errors complaining about an illegal slab id.\n         */\n        if (0\n            == strncmp(buffer, \"CLIENT_ERROR Illegal slab id\",\n                       sizeof(\"CLIENT_ERROR Illegal slab id\") - 1))\n        {\n          memcached_error_free(*instance);\n          memcached_error_free(*memc);\n        } else {\n          return response_rc;\n        }\n      } else {\n        // IO error of some sort must have occurred\n        return response_rc;\n      }\n    }\n  }\n\n  return memcached_has_current_error(*memc) ? MEMCACHED_SOME_ERRORS : MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_has_current_error",
          "args": [
            "*memc"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_has_current_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "483-485",
          "snippet": "bool memcached_has_current_error(memcached_instance_st &server) {\n  return memcached_has_current_error(*(server.root));\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_has_current_error(memcached_instance_st &server) {\n  return memcached_has_current_error(*(server.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_error_free",
          "args": [
            "*memc"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "447-450",
          "snippet": "void memcached_error_free(memcached_server_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_free(memcached_server_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buffer",
            "\"CLIENT_ERROR Illegal slab id\"",
            "sizeof(\"CLIENT_ERROR Illegal slab id\") - 1"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "response_rc == MEMCACHED_SUCCESS"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*instance",
            "callback_rc",
            "MEMCACHED_AT"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "memc",
            "key",
            "(size_t)(end_ptr - string_ptr)",
            "context"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isgraph",
          "args": [
            "*end_ptr"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_response",
          "args": [
            "instance",
            "buffer",
            "MEMCACHED_DEFAULT_COMMAND_SIZE",
            "NULL"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
          "lines": "789-834",
          "snippet": "memcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_io_get_readable_server",
          "args": [
            "memc",
            "read_ret"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "(vdo_rc = memcached_vdo(instance, vector, 3, true))"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_vdo",
          "args": [
            "instance",
            "vector",
            "3",
            "true"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_vdo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/do.cc",
          "lines": "64-100",
          "snippet": "memcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_version_instance_cmp",
          "args": [
            "instance",
            "1",
            "4",
            "23"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_version_instance_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/version.cc",
          "lines": "147-162",
          "snippet": "int8_t memcached_version_instance_cmp(memcached_instance_st *instance, uint8_t maj, uint8_t min,\n                                      uint8_t mic) {\n  if (!instance || memcached_server_major_version(instance) == UINT8_MAX) {\n    return INT8_MIN;\n  } else {\n    uint32_t sv, cv;\n\n    sv = memcached_server_micro_version(instance) | memcached_server_minor_version(instance) << 8\n        | memcached_server_major_version(instance) << 16;\n    cv = mic | min << 8 | maj << 16;\n    if (sv < cv) {\n      return -1;\n    }\n    return sv != cv;\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nint8_t memcached_version_instance_cmp(memcached_instance_st *instance, uint8_t maj, uint8_t min,\n                                      uint8_t mic) {\n  if (!instance || memcached_server_major_version(instance) == UINT8_MAX) {\n    return INT8_MIN;\n  } else {\n    uint32_t sv, cv;\n\n    sv = memcached_server_micro_version(instance) | memcached_server_minor_version(instance) << 8\n        | memcached_server_major_version(instance) << 16;\n    cv = mic | min << 8 | maj << 16;\n    if (sv < cv) {\n      return -1;\n    }\n    return sv != cv;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "memc",
            "server_key"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "memc"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\" 0\\r\\n\""
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "buffer_length"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"stats cachedump \""
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"snprintf(MEMCACHED_DEFAULT_COMMAND_SIZE)\""
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "buffer_length"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"%u\"",
            "x"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_version",
          "args": [
            "memc"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/version.cc",
          "lines": "164-184",
          "snippet": "memcached_return_t memcached_version(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    memcached_return_t rc;\n    if (memcached_failed(rc = initialize_query(memc, true))) {\n      return rc;\n    }\n\n    if (memcached_is_udp(memc)) {\n      return MEMCACHED_NOT_SUPPORTED;\n    }\n\n    if (memcached_is_binary(memc)) {\n      return memcached_version_binary(memc);\n    }\n\n    return memcached_version_textual(memc);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_version(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    memcached_return_t rc;\n    if (memcached_failed(rc = initialize_query(memc, true))) {\n      return rc;\n    }\n\n    if (memcached_is_udp(memc)) {\n      return MEMCACHED_NOT_SUPPORTED;\n    }\n\n    if (memcached_is_binary(memc)) {\n      return memcached_version_binary(memc);\n    }\n\n    return memcached_version_textual(memc);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t ascii_dump(Memcached *memc, memcached_dump_fn *callback, void *context,\n                                     uint32_t number_of_callbacks) {\n  memcached_version(memc);\n  /* MAX_NUMBER_OF_SLAB_CLASSES is defined to 200 in Memcached 1.4.10 */\n  for (uint32_t x = 0; x < 200; x++) {\n    char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n    int buffer_length = snprintf(buffer, sizeof(buffer), \"%u\", x);\n    if (size_t(buffer_length) >= sizeof(buffer) or buffer_length < 0) {\n      return memcached_set_error(\n          *memc, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n          memcached_literal_param(\"snprintf(MEMCACHED_DEFAULT_COMMAND_SIZE)\"));\n    }\n\n    // @NOTE the hard coded zero means \"no limit\"\n    libmemcached_io_vector_st vector[] = {{memcached_literal_param(\"stats cachedump \")},\n                                          {buffer, size_t(buffer_length)},\n                                          {memcached_literal_param(\" 0\\r\\n\")}};\n\n    // Send message to all servers\n    for (uint32_t server_key = 0; server_key < memcached_server_count(memc); server_key++) {\n      memcached_instance_st *instance = memcached_instance_fetch(memc, server_key);\n\n      // skip slabs >63 for server versions >= 1.4.23\n      if (x < 64 || memcached_version_instance_cmp(instance, 1, 4, 23) < 0) {\n        memcached_return_t vdo_rc;\n        if (memcached_failed((vdo_rc = memcached_vdo(instance, vector, 3, true)))) {\n          return vdo_rc;\n        }\n      }\n    }\n\n    // Collect the returned items\n    memcached_instance_st *instance;\n    memcached_return_t read_ret = MEMCACHED_SUCCESS;\n    while ((instance = memcached_io_get_readable_server(memc, read_ret))) {\n      memcached_return_t response_rc =\n          memcached_response(instance, buffer, MEMCACHED_DEFAULT_COMMAND_SIZE, NULL);\n      if (response_rc == MEMCACHED_ITEM) {\n        char *string_ptr, *end_ptr;\n\n        string_ptr = buffer;\n        string_ptr += 5; /* Move past ITEM */\n\n        for (end_ptr = string_ptr; isgraph(*end_ptr); end_ptr++) {\n        };\n\n        char *key = string_ptr;\n        key[(size_t)(end_ptr - string_ptr)] = 0;\n\n        for (uint32_t callback_counter = 0; callback_counter < number_of_callbacks;\n             callback_counter++) {\n          memcached_return_t callback_rc =\n              (*callback[callback_counter])(memc, key, (size_t)(end_ptr - string_ptr), context);\n          if (callback_rc != MEMCACHED_SUCCESS) {\n            // @todo build up a message for the error from the value\n            memcached_set_error(*instance, callback_rc, MEMCACHED_AT);\n            break;\n          }\n        }\n      } else if (response_rc == MEMCACHED_END) {\n        // All items have been returned\n      } else if (response_rc == MEMCACHED_SERVER_ERROR) {\n        /* If we try to request stats cachedump for a slab class that is too big\n         * the server will return an incorrect error message:\n         * \"MEMCACHED_SERVER_ERROR failed to allocate memory\"\n         * This isn't really a fatal error, so let's just skip it. I want to\n         * fix the return value from the memcached server to a CLIENT_ERROR,\n         * so let's add support for that as well right now.\n         */\n        assert(response_rc == MEMCACHED_SUCCESS); // Just fail\n        return response_rc;\n      } else if (response_rc == MEMCACHED_CLIENT_ERROR) {\n        /* The maximum number of slabs has changed in the past (currently 1<<6-1),\n         * so ignore any client errors complaining about an illegal slab id.\n         */\n        if (0\n            == strncmp(buffer, \"CLIENT_ERROR Illegal slab id\",\n                       sizeof(\"CLIENT_ERROR Illegal slab id\") - 1))\n        {\n          memcached_error_free(*instance);\n          memcached_error_free(*memc);\n        } else {\n          return response_rc;\n        }\n      } else {\n        // IO error of some sort must have occurred\n        return response_rc;\n      }\n    }\n  }\n\n  return memcached_has_current_error(*memc) ? MEMCACHED_SOME_ERRORS : MEMCACHED_SUCCESS;\n}"
  }
]