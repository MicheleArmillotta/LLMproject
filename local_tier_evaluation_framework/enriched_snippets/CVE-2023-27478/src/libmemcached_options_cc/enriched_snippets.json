[
  {
    "function_name": "memcached_parse_configure_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/options.cc",
    "lines": "139-147",
    "snippet": "memcached_return_t memcached_parse_configure_file(memcached_st &self,\n                                                  memcached_array_st &filename) {\n  WATCHPOINT_ASSERT(memcached_array_size(&filename));\n  if (not memcached_array_size(&filename)) {\n    return memcached_set_error(self, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT);\n  }\n\n  return _parse_file_options(self, &filename);\n}",
    "includes": [
      "#include \"libmemcached/csl/context.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_parse_file_options",
          "args": [
            "self",
            "&filename"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "_parse_file_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/options.cc",
          "lines": "30-52",
          "snippet": "static memcached_return_t _parse_file_options(memcached_st &self, memcached_array_st *real_name) {\n  FILE *fp = fopen(memcached_array_string(real_name), \"r\");\n  if (not fp) {\n    memcached_string_t error_message = memcached_array_to_string(real_name);\n    memcached_return_t rc = memcached_set_errno(self, errno, MEMCACHED_AT, error_message);\n    return rc;\n  }\n\n  char buffer[BUFSIZ];\n  memcached_return_t rc = MEMCACHED_INVALID_ARGUMENTS;\n  while (fgets(buffer, sizeof(buffer), fp)) {\n    size_t length = strlen(buffer);\n\n    if (length == 1 and buffer[0] == '\\n')\n      continue;\n\n    if (memcached_failed(rc = memcached_parse_configuration(&self, buffer, length)))\n      break;\n  }\n  fclose(fp);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/csl/context.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t _parse_file_options(memcached_st &self, memcached_array_st *real_name) {\n  FILE *fp = fopen(memcached_array_string(real_name), \"r\");\n  if (not fp) {\n    memcached_string_t error_message = memcached_array_to_string(real_name);\n    memcached_return_t rc = memcached_set_errno(self, errno, MEMCACHED_AT, error_message);\n    return rc;\n  }\n\n  char buffer[BUFSIZ];\n  memcached_return_t rc = MEMCACHED_INVALID_ARGUMENTS;\n  while (fgets(buffer, sizeof(buffer), fp)) {\n    size_t length = strlen(buffer);\n\n    if (length == 1 and buffer[0] == '\\n')\n      continue;\n\n    if (memcached_failed(rc = memcached_parse_configuration(&self, buffer, length)))\n      break;\n  }\n  fclose(fp);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "self",
            "MEMCACHED_INVALID_ARGUMENTS",
            "MEMCACHED_AT"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_array_size",
          "args": [
            "&filename"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_array_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/array.cc",
          "lines": "78-84",
          "snippet": "size_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"libmemcached/common.h\"\n\nsize_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "memcached_array_size(&filename)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_parse_configure_file(memcached_st &self,\n                                                  memcached_array_st &filename) {\n  WATCHPOINT_ASSERT(memcached_array_size(&filename));\n  if (not memcached_array_size(&filename)) {\n    return memcached_set_error(self, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT);\n  }\n\n  return _parse_file_options(self, &filename);\n}"
  },
  {
    "function_name": "memcached_parse_configure_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/options.cc",
    "lines": "116-137",
    "snippet": "memcached_return_t memcached_parse_configure_file(memcached_st &self, const char *filename,\n                                                  size_t length) {\n  if (not filename) {\n    return memcached_set_error(self, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT);\n  }\n\n  WATCHPOINT_ASSERT(self);\n  if (not length) {\n    return memcached_set_error(self, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT);\n  }\n\n  memcached_array_st *tmp_array = memcached_strcpy(&self, filename, length);\n\n  if (not tmp_array) {\n    return memcached_set_error(self, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n  }\n\n  memcached_return_t rc = memcached_parse_configure_file(self, *tmp_array);\n  memcached_array_free(tmp_array);\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/csl/context.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_array_free",
          "args": [
            "tmp_array"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_array_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/array.cc",
          "lines": "71-76",
          "snippet": "void memcached_array_free(memcached_array_st *array) {\n  if (array) {\n    WATCHPOINT_ASSERT(array->root);\n    libmemcached_free(array->root, array);\n  }\n}",
          "includes": [
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"libmemcached/common.h\"\n\nvoid memcached_array_free(memcached_array_st *array) {\n  if (array) {\n    WATCHPOINT_ASSERT(array->root);\n    libmemcached_free(array->root, array);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_parse_configure_file",
          "args": [
            "self",
            "*tmp_array"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_parse_configure_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/options.cc",
          "lines": "139-147",
          "snippet": "memcached_return_t memcached_parse_configure_file(memcached_st &self,\n                                                  memcached_array_st &filename) {\n  WATCHPOINT_ASSERT(memcached_array_size(&filename));\n  if (not memcached_array_size(&filename)) {\n    return memcached_set_error(self, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT);\n  }\n\n  return _parse_file_options(self, &filename);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "self",
            "MEMCACHED_MEMORY_ALLOCATION_FAILURE",
            "MEMCACHED_AT"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_strcpy",
          "args": [
            "&self",
            "filename",
            "length"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "self"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_parse_configure_file(memcached_st &self, const char *filename,\n                                                  size_t length) {\n  if (not filename) {\n    return memcached_set_error(self, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT);\n  }\n\n  WATCHPOINT_ASSERT(self);\n  if (not length) {\n    return memcached_set_error(self, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT);\n  }\n\n  memcached_array_st *tmp_array = memcached_strcpy(&self, filename, length);\n\n  if (not tmp_array) {\n    return memcached_set_error(self, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n  }\n\n  memcached_return_t rc = memcached_parse_configure_file(self, *tmp_array);\n  memcached_array_free(tmp_array);\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_set_configuration_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/options.cc",
    "lines": "108-114",
    "snippet": "void memcached_set_configuration_file(memcached_st *self, const char *filename,\n                                      size_t filename_length) {\n  assert_msg(filename, \"Invalid filename\");\n  assert_msg(filename_length, \"Invalid filename_length\");\n  memcached_array_free(self->configure.filename);\n  self->configure.filename = memcached_strcpy(self, filename, filename_length);\n}",
    "includes": [
      "#include \"libmemcached/csl/context.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_strcpy",
          "args": [
            "self",
            "filename",
            "filename_length"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_array_free",
          "args": [
            "self->configure.filename"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_array_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/array.cc",
          "lines": "71-76",
          "snippet": "void memcached_array_free(memcached_array_st *array) {\n  if (array) {\n    WATCHPOINT_ASSERT(array->root);\n    libmemcached_free(array->root, array);\n  }\n}",
          "includes": [
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"libmemcached/common.h\"\n\nvoid memcached_array_free(memcached_array_st *array) {\n  if (array) {\n    WATCHPOINT_ASSERT(array->root);\n    libmemcached_free(array->root, array);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "filename_length",
            "\"Invalid filename_length\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "filename",
            "\"Invalid filename\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_set_configuration_file(memcached_st *self, const char *filename,\n                                      size_t filename_length) {\n  assert_msg(filename, \"Invalid filename\");\n  assert_msg(filename_length, \"Invalid filename_length\");\n  memcached_array_free(self->configure.filename);\n  self->configure.filename = memcached_strcpy(self, filename, filename_length);\n}"
  },
  {
    "function_name": "memcached_parse_configuration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/options.cc",
    "lines": "93-106",
    "snippet": "memcached_return_t memcached_parse_configuration(memcached_st *self, char const *option_string,\n                                                 size_t length) {\n  WATCHPOINT_ASSERT(self);\n  if (not self) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  memcached_return_t rc;\n  Context context(option_string, length, self, rc);\n\n  context.start();\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/csl/context.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.start",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "self"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_parse_configuration(memcached_st *self, char const *option_string,\n                                                 size_t length) {\n  WATCHPOINT_ASSERT(self);\n  if (not self) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  memcached_return_t rc;\n  Context context(option_string, length, self, rc);\n\n  context.start();\n\n  return rc;\n}"
  },
  {
    "function_name": "libmemcached_check_configuration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/options.cc",
    "lines": "54-91",
    "snippet": "memcached_return_t libmemcached_check_configuration(const char *option_string, size_t length,\n                                                    char *error_buffer, size_t error_buffer_size) {\n  memcached_st memc, *memc_ptr;\n\n  if (option_string == NULL or length == 0) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (error_buffer and error_buffer_size) {\n    error_buffer[0] = 0;\n  }\n\n  if (not(memc_ptr = memcached_create(&memc))) {\n    return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n  }\n\n  memcached_return_t rc = memcached_parse_configuration(memc_ptr, option_string, length);\n  if (memcached_failed(rc) and error_buffer and error_buffer_size) {\n    strncpy(error_buffer, memcached_last_error_message(memc_ptr), error_buffer_size);\n    error_buffer[error_buffer_size - 1] = 0;\n  }\n\n  bool has_filename = memcached_behavior_get(memc_ptr, MEMCACHED_BEHAVIOR_LOAD_FROM_FILE);\n  if (memcached_success(rc) and has_filename) {\n    assert_msg(memcached_parse_filename(memc_ptr), \"Invalid configuration file\");\n    assert_msg(memcached_parse_filename_length(memc_ptr), \"Invalid configuration file\");\n    rc = _parse_file_options(*memc_ptr, memc_ptr->configure.filename);\n\n    if (memcached_failed(rc) and error_buffer and error_buffer_size) {\n      strncpy(error_buffer, memcached_last_error_message(memc_ptr), error_buffer_size);\n      error_buffer[error_buffer_size - 1] = 0;\n    }\n  }\n\n  memcached_free(memc_ptr);\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/csl/context.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_free",
          "args": [
            "memc_ptr"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
          "lines": "257-261",
          "snippet": "void memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "error_buffer",
            "memcached_last_error_message(memc_ptr)",
            "error_buffer_size"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error_message",
          "args": [
            "memc_ptr"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_parse_file_options",
          "args": [
            "*memc_ptr",
            "memc_ptr->configure.filename"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "_parse_file_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/options.cc",
          "lines": "30-52",
          "snippet": "static memcached_return_t _parse_file_options(memcached_st &self, memcached_array_st *real_name) {\n  FILE *fp = fopen(memcached_array_string(real_name), \"r\");\n  if (not fp) {\n    memcached_string_t error_message = memcached_array_to_string(real_name);\n    memcached_return_t rc = memcached_set_errno(self, errno, MEMCACHED_AT, error_message);\n    return rc;\n  }\n\n  char buffer[BUFSIZ];\n  memcached_return_t rc = MEMCACHED_INVALID_ARGUMENTS;\n  while (fgets(buffer, sizeof(buffer), fp)) {\n    size_t length = strlen(buffer);\n\n    if (length == 1 and buffer[0] == '\\n')\n      continue;\n\n    if (memcached_failed(rc = memcached_parse_configuration(&self, buffer, length)))\n      break;\n  }\n  fclose(fp);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/csl/context.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t _parse_file_options(memcached_st &self, memcached_array_st *real_name) {\n  FILE *fp = fopen(memcached_array_string(real_name), \"r\");\n  if (not fp) {\n    memcached_string_t error_message = memcached_array_to_string(real_name);\n    memcached_return_t rc = memcached_set_errno(self, errno, MEMCACHED_AT, error_message);\n    return rc;\n  }\n\n  char buffer[BUFSIZ];\n  memcached_return_t rc = MEMCACHED_INVALID_ARGUMENTS;\n  while (fgets(buffer, sizeof(buffer), fp)) {\n    size_t length = strlen(buffer);\n\n    if (length == 1 and buffer[0] == '\\n')\n      continue;\n\n    if (memcached_failed(rc = memcached_parse_configuration(&self, buffer, length)))\n      break;\n  }\n  fclose(fp);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "memcached_parse_filename_length(memc_ptr)",
            "\"Invalid configuration file\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_parse_filename_length",
          "args": [
            "memc_ptr"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_parse_filename_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/options.cc",
          "lines": "26-28",
          "snippet": "size_t memcached_parse_filename_length(memcached_st *memc) {\n  return memcached_array_size(memc->configure.filename);\n}",
          "includes": [
            "#include \"libmemcached/csl/context.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nsize_t memcached_parse_filename_length(memcached_st *memc) {\n  return memcached_array_size(memc->configure.filename);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "memcached_parse_filename(memc_ptr)",
            "\"Invalid configuration file\""
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_behavior_get",
          "args": [
            "memc_ptr",
            "MEMCACHED_BEHAVIOR_LOAD_FROM_FILE"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_behavior_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "288-482",
          "snippet": "uint64_t memcached_behavior_get(memcached_st *shell, const memcached_behavior_t flag) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    return ptr->number_of_replicas;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    return ptr->io_msg_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    return ptr->io_bytes_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    return ptr->io_key_prefetch;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    return ptr->flags.binary_protocol;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    return ptr->flags.support_cas;\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return true;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    return ptr->flags.no_block;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    return ptr->flags.buffer_requests;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    return memcached_is_udp(ptr);\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    return ptr->flags.tcp_nodelay;\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    return ptr->flags.verify_key;\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED:\n    if (memcached_is_consistent_distribution(ptr)) {\n      return memcached_is_weighted_ketama(ptr);\n    }\n    return false;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return ptr->distribution;\n\n  case MEMCACHED_BEHAVIOR_KETAMA:\n    return memcached_is_consistent_distribution(ptr);\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return hashkit_get_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return hashkit_get_distribution_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    return ptr->server_failure_limit;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    return ptr->server_timeout_limit;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS:\n    return ptr->flags.use_sort_hosts;\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    return (uint64_t) ptr->poll_timeout;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    return (uint64_t) ptr->connect_timeout;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    return (uint64_t) ptr->retry_timeout;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    return uint64_t(ptr->dead_timeout);\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    return (uint64_t) ptr->snd_timeout;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    return (uint64_t) ptr->rcv_timeout;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    return (uint64_t) ptr->tcp_keepidle;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->send_size != -1) // If value is -1 then we are using the default\n    {\n      return (uint64_t) ptr->send_size;\n    }\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    if (instance) // If we have an instance we test, otherwise we just set and pray\n    {\n      /* REFACTOR */\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_SNDBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->recv_size != -1) // If value is -1 then we are using the default\n      return (uint64_t) ptr->recv_size;\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    /**\n      @note REFACTOR\n    */\n    if (instance) {\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_RCVBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                        memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n    return 0;\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    return ptr->flags.hash_with_namespace;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    return ptr->flags.reply ? false : true;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    return ptr->flags.randomize_replica_read;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n#ifdef HAVE_MSG_MORE\n    return true;\n#else\n    return false;\n#endif\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    return ptr->flags.tcp_keepalive;\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return bool(memcached_parse_filename(ptr));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_get()\");\n    return 0;\n  }\n\n  /* NOTREACHED */\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nuint64_t memcached_behavior_get(memcached_st *shell, const memcached_behavior_t flag) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    return ptr->number_of_replicas;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    return ptr->io_msg_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    return ptr->io_bytes_watermark;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    return ptr->io_key_prefetch;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    return ptr->flags.binary_protocol;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    return ptr->flags.support_cas;\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return true;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    return ptr->flags.no_block;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    return ptr->flags.buffer_requests;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    return memcached_is_udp(ptr);\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    return ptr->flags.tcp_nodelay;\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    return ptr->flags.verify_key;\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED:\n    if (memcached_is_consistent_distribution(ptr)) {\n      return memcached_is_weighted_ketama(ptr);\n    }\n    return false;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return ptr->distribution;\n\n  case MEMCACHED_BEHAVIOR_KETAMA:\n    return memcached_is_consistent_distribution(ptr);\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return hashkit_get_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return hashkit_get_distribution_function(&ptr->hashkit);\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    return ptr->server_failure_limit;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    return ptr->server_timeout_limit;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS:\n    return ptr->flags.use_sort_hosts;\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    return (uint64_t) ptr->poll_timeout;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    return (uint64_t) ptr->connect_timeout;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    return (uint64_t) ptr->retry_timeout;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    return uint64_t(ptr->dead_timeout);\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    return (uint64_t) ptr->snd_timeout;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    return (uint64_t) ptr->rcv_timeout;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    return (uint64_t) ptr->tcp_keepidle;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->send_size != -1) // If value is -1 then we are using the default\n    {\n      return (uint64_t) ptr->send_size;\n    }\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    if (instance) // If we have an instance we test, otherwise we just set and pray\n    {\n      /* REFACTOR */\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_SNDBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE: {\n    int sock_size = 0;\n    socklen_t sock_length = sizeof(int);\n\n    if (ptr->recv_size != -1) // If value is -1 then we are using the default\n      return (uint64_t) ptr->recv_size;\n\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, 0);\n\n    /**\n      @note REFACTOR\n    */\n    if (instance) {\n      /* We just try the first host, and if it is down we return zero */\n      if (memcached_failed(memcached_connect(instance))) {\n        return 0;\n      }\n\n      if (memcached_failed(memcached_io_wait_for_write(instance))) {\n        return 0;\n      }\n\n      if (getsockopt(instance->fd, SOL_SOCKET, SO_RCVBUF, (char *) &sock_size, &sock_length) < 0) {\n        memcached_set_errno(*ptr, get_socket_errno(), MEMCACHED_AT);\n        return 0; /* Zero means error */\n      }\n    }\n\n    return (uint64_t) sock_size;\n  }\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                        memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n    return 0;\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    return ptr->flags.hash_with_namespace;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    return ptr->flags.reply ? false : true;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    return ptr->flags.auto_eject_hosts;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    return ptr->flags.randomize_replica_read;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n#ifdef HAVE_MSG_MORE\n    return true;\n#else\n    return false;\n#endif\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    return ptr->flags.tcp_keepalive;\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return bool(memcached_parse_filename(ptr));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_get()\");\n    return 0;\n  }\n\n  /* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "error_buffer",
            "memcached_last_error_message(memc_ptr)",
            "error_buffer_size"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error_message",
          "args": [
            "memc_ptr"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_parse_configuration",
          "args": [
            "memc_ptr",
            "option_string",
            "length"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_parse_configuration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/options.cc",
          "lines": "93-106",
          "snippet": "memcached_return_t memcached_parse_configuration(memcached_st *self, char const *option_string,\n                                                 size_t length) {\n  WATCHPOINT_ASSERT(self);\n  if (not self) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  memcached_return_t rc;\n  Context context(option_string, length, self, rc);\n\n  context.start();\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/csl/context.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_parse_configuration(memcached_st *self, char const *option_string,\n                                                 size_t length) {\n  WATCHPOINT_ASSERT(self);\n  if (not self) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  memcached_return_t rc;\n  Context context(option_string, length, self, rc);\n\n  context.start();\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_create",
          "args": [
            "&memc"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t libmemcached_check_configuration(const char *option_string, size_t length,\n                                                    char *error_buffer, size_t error_buffer_size) {\n  memcached_st memc, *memc_ptr;\n\n  if (option_string == NULL or length == 0) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (error_buffer and error_buffer_size) {\n    error_buffer[0] = 0;\n  }\n\n  if (not(memc_ptr = memcached_create(&memc))) {\n    return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n  }\n\n  memcached_return_t rc = memcached_parse_configuration(memc_ptr, option_string, length);\n  if (memcached_failed(rc) and error_buffer and error_buffer_size) {\n    strncpy(error_buffer, memcached_last_error_message(memc_ptr), error_buffer_size);\n    error_buffer[error_buffer_size - 1] = 0;\n  }\n\n  bool has_filename = memcached_behavior_get(memc_ptr, MEMCACHED_BEHAVIOR_LOAD_FROM_FILE);\n  if (memcached_success(rc) and has_filename) {\n    assert_msg(memcached_parse_filename(memc_ptr), \"Invalid configuration file\");\n    assert_msg(memcached_parse_filename_length(memc_ptr), \"Invalid configuration file\");\n    rc = _parse_file_options(*memc_ptr, memc_ptr->configure.filename);\n\n    if (memcached_failed(rc) and error_buffer and error_buffer_size) {\n      strncpy(error_buffer, memcached_last_error_message(memc_ptr), error_buffer_size);\n      error_buffer[error_buffer_size - 1] = 0;\n    }\n  }\n\n  memcached_free(memc_ptr);\n\n  return rc;\n}"
  },
  {
    "function_name": "_parse_file_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/options.cc",
    "lines": "30-52",
    "snippet": "static memcached_return_t _parse_file_options(memcached_st &self, memcached_array_st *real_name) {\n  FILE *fp = fopen(memcached_array_string(real_name), \"r\");\n  if (not fp) {\n    memcached_string_t error_message = memcached_array_to_string(real_name);\n    memcached_return_t rc = memcached_set_errno(self, errno, MEMCACHED_AT, error_message);\n    return rc;\n  }\n\n  char buffer[BUFSIZ];\n  memcached_return_t rc = MEMCACHED_INVALID_ARGUMENTS;\n  while (fgets(buffer, sizeof(buffer), fp)) {\n    size_t length = strlen(buffer);\n\n    if (length == 1 and buffer[0] == '\\n')\n      continue;\n\n    if (memcached_failed(rc = memcached_parse_configuration(&self, buffer, length)))\n      break;\n  }\n  fclose(fp);\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/csl/context.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = memcached_parse_configuration(&self, buffer, length)"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_parse_configuration",
          "args": [
            "&self",
            "buffer",
            "length"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_parse_configuration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/options.cc",
          "lines": "93-106",
          "snippet": "memcached_return_t memcached_parse_configuration(memcached_st *self, char const *option_string,\n                                                 size_t length) {\n  WATCHPOINT_ASSERT(self);\n  if (not self) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  memcached_return_t rc;\n  Context context(option_string, length, self, rc);\n\n  context.start();\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/csl/context.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_parse_configuration(memcached_st *self, char const *option_string,\n                                                 size_t length) {\n  WATCHPOINT_ASSERT(self);\n  if (not self) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  memcached_return_t rc;\n  Context context(option_string, length, self, rc);\n\n  context.start();\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "fp"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_errno",
          "args": [
            "self",
            "errno",
            "MEMCACHED_AT",
            "error_message"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "340-376",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  size_t size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n  }\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n#if 0\n  if (self.root->error_messages->rc != self.error_messages->rc)\n  {\n    fprintf(stderr, \"%s:%d %s != %s\\n\", __FILE__, __LINE__,\n            memcached_strerror(NULL, self.root->error_messages->rc),\n            memcached_strerror(NULL, self.error_messages->rc));\n  }\n#endif\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  size_t size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n  }\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n#if 0\n  if (self.root->error_messages->rc != self.error_messages->rc)\n  {\n    fprintf(stderr, \"%s:%d %s != %s\\n\", __FILE__, __LINE__,\n            memcached_strerror(NULL, self.root->error_messages->rc),\n            memcached_strerror(NULL, self.error_messages->rc));\n  }\n#endif\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_array_to_string",
          "args": [
            "real_name"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_array_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/array.cc",
          "lines": "60-69",
          "snippet": "memcached_string_t memcached_array_to_string(memcached_array_st *array) {\n  assert(array);\n  assert(array->c_str);\n  assert(array->size);\n  memcached_string_t tmp;\n  tmp.c_str = array->c_str;\n  tmp.size = array->size;\n\n  return tmp;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_string_t memcached_array_to_string(memcached_array_st *array) {\n  assert(array);\n  assert(array->c_str);\n  assert(array->size);\n  memcached_string_t tmp;\n  tmp.c_str = array->c_str;\n  tmp.size = array->size;\n\n  return tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "memcached_array_string(real_name)",
            "\"r\""
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_array_string",
          "args": [
            "real_name"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t _parse_file_options(memcached_st &self, memcached_array_st *real_name) {\n  FILE *fp = fopen(memcached_array_string(real_name), \"r\");\n  if (not fp) {\n    memcached_string_t error_message = memcached_array_to_string(real_name);\n    memcached_return_t rc = memcached_set_errno(self, errno, MEMCACHED_AT, error_message);\n    return rc;\n  }\n\n  char buffer[BUFSIZ];\n  memcached_return_t rc = MEMCACHED_INVALID_ARGUMENTS;\n  while (fgets(buffer, sizeof(buffer), fp)) {\n    size_t length = strlen(buffer);\n\n    if (length == 1 and buffer[0] == '\\n')\n      continue;\n\n    if (memcached_failed(rc = memcached_parse_configuration(&self, buffer, length)))\n      break;\n  }\n  fclose(fp);\n\n  return rc;\n}"
  },
  {
    "function_name": "memcached_parse_filename_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/options.cc",
    "lines": "26-28",
    "snippet": "size_t memcached_parse_filename_length(memcached_st *memc) {\n  return memcached_array_size(memc->configure.filename);\n}",
    "includes": [
      "#include \"libmemcached/csl/context.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_array_size",
          "args": [
            "memc->configure.filename"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_array_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/array.cc",
          "lines": "78-84",
          "snippet": "size_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"libmemcached/common.h\"\n\nsize_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nsize_t memcached_parse_filename_length(memcached_st *memc) {\n  return memcached_array_size(memc->configure.filename);\n}"
  }
]