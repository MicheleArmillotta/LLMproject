[
  {
    "function_name": "libmemcached_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memory.h",
    "lines": "30-40",
    "snippet": "static inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}",
    "includes": [
      "#  include <stdlib.h>",
      "#  include <stddef.h>",
      "#  include <cstdlib>",
      "#  include <cstddef>",
      "#include \"libmemcached/common.h\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mem"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_result_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/result.cc",
          "lines": "66-82",
          "snippet": "void memcached_result_free(memcached_result_st *ptr) {\n  if (ptr == NULL) {\n    return;\n  }\n\n  memcached_string_free(&ptr->value);\n  ptr->numeric_value = UINT64_MAX;\n\n  if (memcached_is_allocated(ptr)) {\n    WATCHPOINT_ASSERT(\n        ptr->root); // Without a root, that means that result was not properly initialized.\n    libmemcached_free(ptr->root, ptr);\n  } else {\n    ptr->count = 0;\n    ptr->options.is_initialized = false;\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_result_free(memcached_result_st *ptr) {\n  if (ptr == NULL) {\n    return;\n  }\n\n  memcached_string_free(&ptr->value);\n  ptr->numeric_value = UINT64_MAX;\n\n  if (memcached_is_allocated(ptr)) {\n    WATCHPOINT_ASSERT(\n        ptr->root); // Without a root, that means that result was not properly initialized.\n    libmemcached_free(ptr->root, ptr);\n  } else {\n    ptr->count = 0;\n    ptr->options.is_initialized = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::free",
          "args": [
            "mem"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "self->allocators.free",
          "args": [
            "self",
            "mem",
            "self->allocators.context"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include <stdlib.h>\n#  include <stddef.h>\n#  include <cstdlib>\n#  include <cstddef>\n#include \"libmemcached/common.h\"\n#include \"mem_config.h\"\n\nstatic inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}"
  }
]