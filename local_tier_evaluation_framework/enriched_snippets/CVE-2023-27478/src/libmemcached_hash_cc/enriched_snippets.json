[
  {
    "function_name": "memcached_set_hashkit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
    "lines": "136-146",
    "snippet": "memcached_return_t memcached_set_hashkit(memcached_st *shell, hashkit_st *hashk) {\n  Memcached *self = memcached2Memcached(shell);\n  if (self) {\n    hashkit_free(&self->hashkit);\n    hashkit_clone(&self->hashkit, hashk);\n\n    return MEMCACHED_SUCCESS;\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
    "includes": [
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashkit_clone",
          "args": [
            "&self->hashkit",
            "hashk"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashkit_free",
          "args": [
            "&self->hashkit"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "hashkit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/hashkit.cc",
          "lines": "55-64",
          "snippet": "void hashkit_free(hashkit_st *self) {\n  if (self and self->_key) {\n    aes_free_key((aes_key_t *) self->_key);\n    self->_key = NULL;\n  }\n\n  if (hashkit_is_allocated(self)) {\n    free(self);\n  }\n}",
          "includes": [
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libhashkit/common.h\"\n\nvoid hashkit_free(hashkit_st *self) {\n  if (self and self->_key) {\n    aes_free_key((aes_key_t *) self->_key);\n    self->_key = NULL;\n  }\n\n  if (hashkit_is_allocated(self)) {\n    free(self);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_hashkit(memcached_st *shell, hashkit_st *hashk) {\n  Memcached *self = memcached2Memcached(shell);\n  if (self) {\n    hashkit_free(&self->hashkit);\n    hashkit_clone(&self->hashkit, hashk);\n\n    return MEMCACHED_SUCCESS;\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
  },
  {
    "function_name": "memcached_generate_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
    "lines": "118-125",
    "snippet": "uint32_t memcached_generate_hash(const memcached_st *shell, const char *key, size_t key_length) {\n  const Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    return dispatch_host(ptr, _generate_hash_wrapper(ptr, key, key_length));\n  }\n\n  return UINT32_MAX;\n}",
    "includes": [
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dispatch_host",
          "args": [
            "ptr",
            "_generate_hash_wrapper(ptr, key, key_length)"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "dispatch_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
          "lines": "30-67",
          "snippet": "static uint32_t dispatch_host(const Memcached *ptr, uint32_t hash) {\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY: {\n    uint32_t num = ptr->ketama.continuum_points_counter;\n    WATCHPOINT_ASSERT(ptr->ketama.continuum);\n\n    memcached_continuum_item_st *begin, *end, *left, *right, *middle;\n    begin = left = ptr->ketama.continuum;\n    end = right = ptr->ketama.continuum + num;\n\n    while (left < right) {\n      middle = left + (right - left) / 2;\n      if (middle->value < hash)\n        left = middle + 1;\n      else\n        right = middle;\n    }\n    if (right == end)\n      right = begin;\n    return right->index;\n  }\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    return hash % memcached_server_count(ptr);\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    return (uint32_t) random() % memcached_server_count(ptr);\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET: {\n    return memcached_virtual_bucket_get(ptr, hash);\n  }\n  default:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n    WATCHPOINT_ASSERT(0); /* We have added a distribution without extending the logic */\n    return hash % memcached_server_count(ptr);\n  }\n  /* NOTREACHED */\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nstatic uint32_t dispatch_host(const Memcached *ptr, uint32_t hash) {\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY: {\n    uint32_t num = ptr->ketama.continuum_points_counter;\n    WATCHPOINT_ASSERT(ptr->ketama.continuum);\n\n    memcached_continuum_item_st *begin, *end, *left, *right, *middle;\n    begin = left = ptr->ketama.continuum;\n    end = right = ptr->ketama.continuum + num;\n\n    while (left < right) {\n      middle = left + (right - left) / 2;\n      if (middle->value < hash)\n        left = middle + 1;\n      else\n        right = middle;\n    }\n    if (right == end)\n      right = begin;\n    return right->index;\n  }\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    return hash % memcached_server_count(ptr);\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    return (uint32_t) random() % memcached_server_count(ptr);\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET: {\n    return memcached_virtual_bucket_get(ptr, hash);\n  }\n  default:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n    WATCHPOINT_ASSERT(0); /* We have added a distribution without extending the logic */\n    return hash % memcached_server_count(ptr);\n  }\n  /* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "_generate_hash_wrapper",
          "args": [
            "ptr",
            "key",
            "key_length"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "_generate_hash_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
          "lines": "72-93",
          "snippet": "static inline uint32_t _generate_hash_wrapper(const Memcached *ptr, const char *key,\n                                              size_t key_length) {\n  WATCHPOINT_ASSERT(memcached_server_count(ptr));\n\n  if (memcached_server_count(ptr) == 1)\n    return 0;\n\n  if (ptr->flags.hash_with_namespace) {\n    size_t temp_length = memcached_array_size(ptr->_namespace) + key_length;\n    char temp[MEMCACHED_MAX_KEY];\n\n    if (temp_length > MEMCACHED_MAX_KEY - 1)\n      return 0;\n\n    strncpy(temp, memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace));\n    strncpy(temp + memcached_array_size(ptr->_namespace), key, key_length);\n\n    return generate_hash(ptr, temp, temp_length);\n  } else {\n    return generate_hash(ptr, key, key_length);\n  }\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nstatic inline uint32_t _generate_hash_wrapper(const Memcached *ptr, const char *key,\n                                              size_t key_length) {\n  WATCHPOINT_ASSERT(memcached_server_count(ptr));\n\n  if (memcached_server_count(ptr) == 1)\n    return 0;\n\n  if (ptr->flags.hash_with_namespace) {\n    size_t temp_length = memcached_array_size(ptr->_namespace) + key_length;\n    char temp[MEMCACHED_MAX_KEY];\n\n    if (temp_length > MEMCACHED_MAX_KEY - 1)\n      return 0;\n\n    strncpy(temp, memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace));\n    strncpy(temp + memcached_array_size(ptr->_namespace), key, key_length);\n\n    return generate_hash(ptr, temp, temp_length);\n  } else {\n    return generate_hash(ptr, key, key_length);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nuint32_t memcached_generate_hash(const memcached_st *shell, const char *key, size_t key_length) {\n  const Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    return dispatch_host(ptr, _generate_hash_wrapper(ptr, key, key_length));\n  }\n\n  return UINT32_MAX;\n}"
  },
  {
    "function_name": "memcached_generate_hash_with_redistribution",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
    "lines": "109-116",
    "snippet": "uint32_t memcached_generate_hash_with_redistribution(memcached_st *ptr, const char *key,\n                                                     size_t key_length) {\n  uint32_t hash = _generate_hash_wrapper(ptr, key, key_length);\n\n  _regen_for_auto_eject(ptr);\n\n  return dispatch_host(ptr, hash);\n}",
    "includes": [
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dispatch_host",
          "args": [
            "ptr",
            "hash"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "dispatch_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
          "lines": "30-67",
          "snippet": "static uint32_t dispatch_host(const Memcached *ptr, uint32_t hash) {\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY: {\n    uint32_t num = ptr->ketama.continuum_points_counter;\n    WATCHPOINT_ASSERT(ptr->ketama.continuum);\n\n    memcached_continuum_item_st *begin, *end, *left, *right, *middle;\n    begin = left = ptr->ketama.continuum;\n    end = right = ptr->ketama.continuum + num;\n\n    while (left < right) {\n      middle = left + (right - left) / 2;\n      if (middle->value < hash)\n        left = middle + 1;\n      else\n        right = middle;\n    }\n    if (right == end)\n      right = begin;\n    return right->index;\n  }\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    return hash % memcached_server_count(ptr);\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    return (uint32_t) random() % memcached_server_count(ptr);\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET: {\n    return memcached_virtual_bucket_get(ptr, hash);\n  }\n  default:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n    WATCHPOINT_ASSERT(0); /* We have added a distribution without extending the logic */\n    return hash % memcached_server_count(ptr);\n  }\n  /* NOTREACHED */\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nstatic uint32_t dispatch_host(const Memcached *ptr, uint32_t hash) {\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY: {\n    uint32_t num = ptr->ketama.continuum_points_counter;\n    WATCHPOINT_ASSERT(ptr->ketama.continuum);\n\n    memcached_continuum_item_st *begin, *end, *left, *right, *middle;\n    begin = left = ptr->ketama.continuum;\n    end = right = ptr->ketama.continuum + num;\n\n    while (left < right) {\n      middle = left + (right - left) / 2;\n      if (middle->value < hash)\n        left = middle + 1;\n      else\n        right = middle;\n    }\n    if (right == end)\n      right = begin;\n    return right->index;\n  }\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    return hash % memcached_server_count(ptr);\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    return (uint32_t) random() % memcached_server_count(ptr);\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET: {\n    return memcached_virtual_bucket_get(ptr, hash);\n  }\n  default:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n    WATCHPOINT_ASSERT(0); /* We have added a distribution without extending the logic */\n    return hash % memcached_server_count(ptr);\n  }\n  /* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "_regen_for_auto_eject",
          "args": [
            "ptr"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "_regen_for_auto_eject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
          "lines": "95-103",
          "snippet": "static inline void _regen_for_auto_eject(Memcached *ptr) {\n  if (_is_auto_eject_host(ptr) && ptr->ketama.next_distribution_rebuild) {\n    struct timeval now;\n\n    if (gettimeofday(&now, NULL) == 0 and now.tv_sec > ptr->ketama.next_distribution_rebuild) {\n      run_distribution(ptr);\n    }\n  }\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nstatic inline void _regen_for_auto_eject(Memcached *ptr) {\n  if (_is_auto_eject_host(ptr) && ptr->ketama.next_distribution_rebuild) {\n    struct timeval now;\n\n    if (gettimeofday(&now, NULL) == 0 and now.tv_sec > ptr->ketama.next_distribution_rebuild) {\n      run_distribution(ptr);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_generate_hash_wrapper",
          "args": [
            "ptr",
            "key",
            "key_length"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "_generate_hash_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
          "lines": "72-93",
          "snippet": "static inline uint32_t _generate_hash_wrapper(const Memcached *ptr, const char *key,\n                                              size_t key_length) {\n  WATCHPOINT_ASSERT(memcached_server_count(ptr));\n\n  if (memcached_server_count(ptr) == 1)\n    return 0;\n\n  if (ptr->flags.hash_with_namespace) {\n    size_t temp_length = memcached_array_size(ptr->_namespace) + key_length;\n    char temp[MEMCACHED_MAX_KEY];\n\n    if (temp_length > MEMCACHED_MAX_KEY - 1)\n      return 0;\n\n    strncpy(temp, memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace));\n    strncpy(temp + memcached_array_size(ptr->_namespace), key, key_length);\n\n    return generate_hash(ptr, temp, temp_length);\n  } else {\n    return generate_hash(ptr, key, key_length);\n  }\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nstatic inline uint32_t _generate_hash_wrapper(const Memcached *ptr, const char *key,\n                                              size_t key_length) {\n  WATCHPOINT_ASSERT(memcached_server_count(ptr));\n\n  if (memcached_server_count(ptr) == 1)\n    return 0;\n\n  if (ptr->flags.hash_with_namespace) {\n    size_t temp_length = memcached_array_size(ptr->_namespace) + key_length;\n    char temp[MEMCACHED_MAX_KEY];\n\n    if (temp_length > MEMCACHED_MAX_KEY - 1)\n      return 0;\n\n    strncpy(temp, memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace));\n    strncpy(temp + memcached_array_size(ptr->_namespace), key, key_length);\n\n    return generate_hash(ptr, temp, temp_length);\n  } else {\n    return generate_hash(ptr, key, key_length);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nuint32_t memcached_generate_hash_with_redistribution(memcached_st *ptr, const char *key,\n                                                     size_t key_length) {\n  uint32_t hash = _generate_hash_wrapper(ptr, key, key_length);\n\n  _regen_for_auto_eject(ptr);\n\n  return dispatch_host(ptr, hash);\n}"
  },
  {
    "function_name": "memcached_autoeject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
    "lines": "105-107",
    "snippet": "void memcached_autoeject(memcached_st *ptr) {\n  _regen_for_auto_eject(ptr);\n}",
    "includes": [
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_regen_for_auto_eject",
          "args": [
            "ptr"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "_regen_for_auto_eject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
          "lines": "95-103",
          "snippet": "static inline void _regen_for_auto_eject(Memcached *ptr) {\n  if (_is_auto_eject_host(ptr) && ptr->ketama.next_distribution_rebuild) {\n    struct timeval now;\n\n    if (gettimeofday(&now, NULL) == 0 and now.tv_sec > ptr->ketama.next_distribution_rebuild) {\n      run_distribution(ptr);\n    }\n  }\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nstatic inline void _regen_for_auto_eject(Memcached *ptr) {\n  if (_is_auto_eject_host(ptr) && ptr->ketama.next_distribution_rebuild) {\n    struct timeval now;\n\n    if (gettimeofday(&now, NULL) == 0 and now.tv_sec > ptr->ketama.next_distribution_rebuild) {\n      run_distribution(ptr);\n    }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_autoeject(memcached_st *ptr) {\n  _regen_for_auto_eject(ptr);\n}"
  },
  {
    "function_name": "_regen_for_auto_eject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
    "lines": "95-103",
    "snippet": "static inline void _regen_for_auto_eject(Memcached *ptr) {\n  if (_is_auto_eject_host(ptr) && ptr->ketama.next_distribution_rebuild) {\n    struct timeval now;\n\n    if (gettimeofday(&now, NULL) == 0 and now.tv_sec > ptr->ketama.next_distribution_rebuild) {\n      run_distribution(ptr);\n    }\n  }\n}",
    "includes": [
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "run_distribution",
          "args": [
            "ptr"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "run_distribution",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "46-72",
          "snippet": "memcached_return_t run_distribution(Memcached *ptr) {\n  if (ptr->flags.use_sort_hosts) {\n    sort_hosts(ptr);\n  }\n\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return update_continuum(ptr);\n\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    break;\n\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    srandom((uint32_t) time(NULL));\n    break;\n\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n  default:\n    assert_msg(0, \"Invalid distribution type passed to run_distribution()\");\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t update_continuum(Memcached *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t run_distribution(Memcached *ptr) {\n  if (ptr->flags.use_sort_hosts) {\n    sort_hosts(ptr);\n  }\n\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return update_continuum(ptr);\n\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    break;\n\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    srandom((uint32_t) time(NULL));\n    break;\n\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n  default:\n    assert_msg(0, \"Invalid distribution type passed to run_distribution()\");\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gettimeofday",
          "args": [
            "&now",
            "NULL"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "gettimeofday",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/win32/wrappers.h",
          "lines": "87-103",
          "snippet": "static inline int gettimeofday(struct timeval* tp, struct timezone* tzp) {\n  using clock = std::chrono::system_clock;\n  auto as_sec = [] (auto d) {\n      return std::chrono::duration_cast<std::chrono::seconds>(d);\n  };\n  auto as_usec = [] (auto d) {\n      return std::chrono::duration_cast<std::chrono::microseconds>(d);\n  };\n\n  auto now = clock::now().time_since_epoch();\n  auto sec = as_sec(now);\n  auto usec = as_usec(now - sec);\n\n  tp->tv_sec = sec.count();\n  tp->tv_usec = usec.count();\n  return 0;\n}",
          "includes": [
            "#  include <chrono>",
            "#include <inttypes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <chrono>\n#include <inttypes.h>\n\nstatic inline int gettimeofday(struct timeval* tp, struct timezone* tzp) {\n  using clock = std::chrono::system_clock;\n  auto as_sec = [] (auto d) {\n      return std::chrono::duration_cast<std::chrono::seconds>(d);\n  };\n  auto as_usec = [] (auto d) {\n      return std::chrono::duration_cast<std::chrono::microseconds>(d);\n  };\n\n  auto now = clock::now().time_since_epoch();\n  auto sec = as_sec(now);\n  auto usec = as_usec(now - sec);\n\n  tp->tv_sec = sec.count();\n  tp->tv_usec = usec.count();\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_is_auto_eject_host",
          "args": [
            "ptr"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "_is_auto_eject_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "284-286",
          "snippet": "bool _is_auto_eject_host(const memcached_st *ptr) {\n  return ptr->flags.auto_eject_hosts;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nbool _is_auto_eject_host(const memcached_st *ptr) {\n  return ptr->flags.auto_eject_hosts;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nstatic inline void _regen_for_auto_eject(Memcached *ptr) {\n  if (_is_auto_eject_host(ptr) && ptr->ketama.next_distribution_rebuild) {\n    struct timeval now;\n\n    if (gettimeofday(&now, NULL) == 0 and now.tv_sec > ptr->ketama.next_distribution_rebuild) {\n      run_distribution(ptr);\n    }\n  }\n}"
  },
  {
    "function_name": "_generate_hash_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
    "lines": "72-93",
    "snippet": "static inline uint32_t _generate_hash_wrapper(const Memcached *ptr, const char *key,\n                                              size_t key_length) {\n  WATCHPOINT_ASSERT(memcached_server_count(ptr));\n\n  if (memcached_server_count(ptr) == 1)\n    return 0;\n\n  if (ptr->flags.hash_with_namespace) {\n    size_t temp_length = memcached_array_size(ptr->_namespace) + key_length;\n    char temp[MEMCACHED_MAX_KEY];\n\n    if (temp_length > MEMCACHED_MAX_KEY - 1)\n      return 0;\n\n    strncpy(temp, memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace));\n    strncpy(temp + memcached_array_size(ptr->_namespace), key, key_length);\n\n    return generate_hash(ptr, temp, temp_length);\n  } else {\n    return generate_hash(ptr, key, key_length);\n  }\n}",
    "includes": [
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generate_hash",
          "args": [
            "ptr",
            "key",
            "key_length"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_generate_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
          "lines": "118-125",
          "snippet": "uint32_t memcached_generate_hash(const memcached_st *shell, const char *key, size_t key_length) {\n  const Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    return dispatch_host(ptr, _generate_hash_wrapper(ptr, key, key_length));\n  }\n\n  return UINT32_MAX;\n}",
          "includes": [
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nuint32_t memcached_generate_hash(const memcached_st *shell, const char *key, size_t key_length) {\n  const Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    return dispatch_host(ptr, _generate_hash_wrapper(ptr, key, key_length));\n  }\n\n  return UINT32_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "temp + memcached_array_size(ptr->_namespace)",
            "key",
            "key_length"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_array_size",
          "args": [
            "ptr->_namespace"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_array_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/array.cc",
          "lines": "78-84",
          "snippet": "size_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"libmemcached/common.h\"\n\nsize_t memcached_array_size(memcached_array_st *array) {\n  if (array) {\n    return array->size;\n  }\n\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "temp",
            "memcached_array_string(ptr->_namespace)",
            "memcached_array_size(ptr->_namespace)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_array_string",
          "args": [
            "ptr->_namespace"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "ptr"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "memcached_server_count(ptr)"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nstatic inline uint32_t _generate_hash_wrapper(const Memcached *ptr, const char *key,\n                                              size_t key_length) {\n  WATCHPOINT_ASSERT(memcached_server_count(ptr));\n\n  if (memcached_server_count(ptr) == 1)\n    return 0;\n\n  if (ptr->flags.hash_with_namespace) {\n    size_t temp_length = memcached_array_size(ptr->_namespace) + key_length;\n    char temp[MEMCACHED_MAX_KEY];\n\n    if (temp_length > MEMCACHED_MAX_KEY - 1)\n      return 0;\n\n    strncpy(temp, memcached_array_string(ptr->_namespace), memcached_array_size(ptr->_namespace));\n    strncpy(temp + memcached_array_size(ptr->_namespace), key, key_length);\n\n    return generate_hash(ptr, temp, temp_length);\n  } else {\n    return generate_hash(ptr, key, key_length);\n  }\n}"
  },
  {
    "function_name": "dispatch_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
    "lines": "30-67",
    "snippet": "static uint32_t dispatch_host(const Memcached *ptr, uint32_t hash) {\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY: {\n    uint32_t num = ptr->ketama.continuum_points_counter;\n    WATCHPOINT_ASSERT(ptr->ketama.continuum);\n\n    memcached_continuum_item_st *begin, *end, *left, *right, *middle;\n    begin = left = ptr->ketama.continuum;\n    end = right = ptr->ketama.continuum + num;\n\n    while (left < right) {\n      middle = left + (right - left) / 2;\n      if (middle->value < hash)\n        left = middle + 1;\n      else\n        right = middle;\n    }\n    if (right == end)\n      right = begin;\n    return right->index;\n  }\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    return hash % memcached_server_count(ptr);\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    return (uint32_t) random() % memcached_server_count(ptr);\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET: {\n    return memcached_virtual_bucket_get(ptr, hash);\n  }\n  default:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n    WATCHPOINT_ASSERT(0); /* We have added a distribution without extending the logic */\n    return hash % memcached_server_count(ptr);\n  }\n  /* NOTREACHED */\n}",
    "includes": [
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "ptr"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "0"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_virtual_bucket_get",
          "args": [
            "ptr",
            "hash"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_virtual_bucket_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/virtual_bucket.cc",
          "lines": "74-85",
          "snippet": "uint32_t memcached_virtual_bucket_get(const memcached_st *self, uint32_t digest) {\n  if (self) {\n    if (self->virtual_bucket) {\n      uint32_t result = (uint32_t)(digest & (self->virtual_bucket->size - 1));\n      return self->virtual_bucket->buckets[result].master;\n    }\n\n    return (uint32_t)(digest & (self->number_of_hosts - 1));\n  }\n\n  return 0;\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nuint32_t memcached_virtual_bucket_get(const memcached_st *self, uint32_t digest) {\n  if (self) {\n    if (self->virtual_bucket) {\n      uint32_t result = (uint32_t)(digest & (self->virtual_bucket->size - 1));\n      return self->virtual_bucket->buckets[result].master;\n    }\n\n    return (uint32_t)(digest & (self->number_of_hosts - 1));\n  }\n\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "random",
          "args": [],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "random64",
          "container": "random64",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/random.hpp",
          "lines": "26-29",
          "snippet": "random64()\n  : gen{static_cast<typ>(time_clock::now().time_since_epoch().count())}\n  , dst{}\n  {}",
          "includes": [
            "#include <random>",
            "#include \"time.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <random>\n#include \"time.hpp\"\n\nrandom64 {\n  random64()\n    : gen{static_cast<typ>(time_clock::now().time_since_epoch().count())}\n    , dst{}\n    {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "ptr->ketama.continuum"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nstatic uint32_t dispatch_host(const Memcached *ptr, uint32_t hash) {\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY: {\n    uint32_t num = ptr->ketama.continuum_points_counter;\n    WATCHPOINT_ASSERT(ptr->ketama.continuum);\n\n    memcached_continuum_item_st *begin, *end, *left, *right, *middle;\n    begin = left = ptr->ketama.continuum;\n    end = right = ptr->ketama.continuum + num;\n\n    while (left < right) {\n      middle = left + (right - left) / 2;\n      if (middle->value < hash)\n        left = middle + 1;\n      else\n        right = middle;\n    }\n    if (right == end)\n      right = begin;\n    return right->index;\n  }\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    return hash % memcached_server_count(ptr);\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    return (uint32_t) random() % memcached_server_count(ptr);\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET: {\n    return memcached_virtual_bucket_get(ptr, hash);\n  }\n  default:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n    WATCHPOINT_ASSERT(0); /* We have added a distribution without extending the logic */\n    return hash % memcached_server_count(ptr);\n  }\n  /* NOTREACHED */\n}"
  },
  {
    "function_name": "generate_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
    "lines": "26-28",
    "snippet": "static inline uint32_t generate_hash(const Memcached *ptr, const char *key, size_t key_length) {\n  return hashkit_digest(&ptr->hashkit, key, key_length);\n}",
    "includes": [
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashkit_digest",
          "args": [
            "&ptr->hashkit",
            "key",
            "key_length"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "libhashkit_digest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/digest.cc",
          "lines": "22-69",
          "snippet": "uint32_t libhashkit_digest(const char *key, size_t key_length,\n                           hashkit_hash_algorithm_t hash_algorithm) {\n  switch (hash_algorithm) {\n  case HASHKIT_HASH_DEFAULT:\n    return libhashkit_one_at_a_time(key, key_length);\n  case HASHKIT_HASH_MD5:\n    return libhashkit_md5(key, key_length);\n  case HASHKIT_HASH_CRC:\n    return libhashkit_crc32(key, key_length);\n  case HASHKIT_HASH_FNV1_64:\n    return libhashkit_fnv1_64(key, key_length);\n  case HASHKIT_HASH_FNV1A_64:\n    return libhashkit_fnv1a_64(key, key_length);\n  case HASHKIT_HASH_FNV1_32:\n    return libhashkit_fnv1_32(key, key_length);\n  case HASHKIT_HASH_FNV1A_32:\n    return libhashkit_fnv1a_32(key, key_length);\n  case HASHKIT_HASH_HSIEH:\n#ifdef HAVE_HSIEH_HASH\n    return libhashkit_hsieh(key, key_length);\n#else\n    return 1;\n#endif\n  case HASHKIT_HASH_MURMUR3:\n    return libhashkit_murmur3(key, key_length);\n\n  case HASHKIT_HASH_MURMUR:\n#ifdef HAVE_MURMUR_HASH\n    return libhashkit_murmur(key, key_length);\n#else\n    return 1;\n#endif\n  case HASHKIT_HASH_JENKINS:\n    return libhashkit_jenkins(key, key_length);\n  case HASHKIT_HASH_CUSTOM:\n  case HASHKIT_HASH_MAX:\n  default:\n    if (DEBUG) {\n      fprintf(stderr,\n              \"hashkit_hash_t was extended but libhashkit_generate_value was not updated\\n\");\n      fflush(stderr);\n      assert(0);\n    }\n    break;\n  }\n\n  return 1;\n}",
          "includes": [
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libhashkit/common.h\"\n\nuint32_t libhashkit_digest(const char *key, size_t key_length,\n                           hashkit_hash_algorithm_t hash_algorithm) {\n  switch (hash_algorithm) {\n  case HASHKIT_HASH_DEFAULT:\n    return libhashkit_one_at_a_time(key, key_length);\n  case HASHKIT_HASH_MD5:\n    return libhashkit_md5(key, key_length);\n  case HASHKIT_HASH_CRC:\n    return libhashkit_crc32(key, key_length);\n  case HASHKIT_HASH_FNV1_64:\n    return libhashkit_fnv1_64(key, key_length);\n  case HASHKIT_HASH_FNV1A_64:\n    return libhashkit_fnv1a_64(key, key_length);\n  case HASHKIT_HASH_FNV1_32:\n    return libhashkit_fnv1_32(key, key_length);\n  case HASHKIT_HASH_FNV1A_32:\n    return libhashkit_fnv1a_32(key, key_length);\n  case HASHKIT_HASH_HSIEH:\n#ifdef HAVE_HSIEH_HASH\n    return libhashkit_hsieh(key, key_length);\n#else\n    return 1;\n#endif\n  case HASHKIT_HASH_MURMUR3:\n    return libhashkit_murmur3(key, key_length);\n\n  case HASHKIT_HASH_MURMUR:\n#ifdef HAVE_MURMUR_HASH\n    return libhashkit_murmur(key, key_length);\n#else\n    return 1;\n#endif\n  case HASHKIT_HASH_JENKINS:\n    return libhashkit_jenkins(key, key_length);\n  case HASHKIT_HASH_CUSTOM:\n  case HASHKIT_HASH_MAX:\n  default:\n    if (DEBUG) {\n      fprintf(stderr,\n              \"hashkit_hash_t was extended but libhashkit_generate_value was not updated\\n\");\n      fflush(stderr);\n      assert(0);\n    }\n    break;\n  }\n\n  return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nstatic inline uint32_t generate_hash(const Memcached *ptr, const char *key, size_t key_length) {\n  return hashkit_digest(&ptr->hashkit, key, key_length);\n}"
  },
  {
    "function_name": "memcached_generate_hash_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hash.cc",
    "lines": "21-24",
    "snippet": "uint32_t memcached_generate_hash_value(const char *key, size_t key_length,\n                                       memcached_hash_t hash_algorithm) {\n  return libhashkit_digest(key, key_length, (hashkit_hash_algorithm_t) hash_algorithm);\n}",
    "includes": [
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libhashkit_digest",
          "args": [
            "key",
            "key_length",
            "(hashkit_hash_algorithm_t) hash_algorithm"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "libhashkit_digest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/digest.cc",
          "lines": "22-69",
          "snippet": "uint32_t libhashkit_digest(const char *key, size_t key_length,\n                           hashkit_hash_algorithm_t hash_algorithm) {\n  switch (hash_algorithm) {\n  case HASHKIT_HASH_DEFAULT:\n    return libhashkit_one_at_a_time(key, key_length);\n  case HASHKIT_HASH_MD5:\n    return libhashkit_md5(key, key_length);\n  case HASHKIT_HASH_CRC:\n    return libhashkit_crc32(key, key_length);\n  case HASHKIT_HASH_FNV1_64:\n    return libhashkit_fnv1_64(key, key_length);\n  case HASHKIT_HASH_FNV1A_64:\n    return libhashkit_fnv1a_64(key, key_length);\n  case HASHKIT_HASH_FNV1_32:\n    return libhashkit_fnv1_32(key, key_length);\n  case HASHKIT_HASH_FNV1A_32:\n    return libhashkit_fnv1a_32(key, key_length);\n  case HASHKIT_HASH_HSIEH:\n#ifdef HAVE_HSIEH_HASH\n    return libhashkit_hsieh(key, key_length);\n#else\n    return 1;\n#endif\n  case HASHKIT_HASH_MURMUR3:\n    return libhashkit_murmur3(key, key_length);\n\n  case HASHKIT_HASH_MURMUR:\n#ifdef HAVE_MURMUR_HASH\n    return libhashkit_murmur(key, key_length);\n#else\n    return 1;\n#endif\n  case HASHKIT_HASH_JENKINS:\n    return libhashkit_jenkins(key, key_length);\n  case HASHKIT_HASH_CUSTOM:\n  case HASHKIT_HASH_MAX:\n  default:\n    if (DEBUG) {\n      fprintf(stderr,\n              \"hashkit_hash_t was extended but libhashkit_generate_value was not updated\\n\");\n      fflush(stderr);\n      assert(0);\n    }\n    break;\n  }\n\n  return 1;\n}",
          "includes": [
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libhashkit/common.h\"\n\nuint32_t libhashkit_digest(const char *key, size_t key_length,\n                           hashkit_hash_algorithm_t hash_algorithm) {\n  switch (hash_algorithm) {\n  case HASHKIT_HASH_DEFAULT:\n    return libhashkit_one_at_a_time(key, key_length);\n  case HASHKIT_HASH_MD5:\n    return libhashkit_md5(key, key_length);\n  case HASHKIT_HASH_CRC:\n    return libhashkit_crc32(key, key_length);\n  case HASHKIT_HASH_FNV1_64:\n    return libhashkit_fnv1_64(key, key_length);\n  case HASHKIT_HASH_FNV1A_64:\n    return libhashkit_fnv1a_64(key, key_length);\n  case HASHKIT_HASH_FNV1_32:\n    return libhashkit_fnv1_32(key, key_length);\n  case HASHKIT_HASH_FNV1A_32:\n    return libhashkit_fnv1a_32(key, key_length);\n  case HASHKIT_HASH_HSIEH:\n#ifdef HAVE_HSIEH_HASH\n    return libhashkit_hsieh(key, key_length);\n#else\n    return 1;\n#endif\n  case HASHKIT_HASH_MURMUR3:\n    return libhashkit_murmur3(key, key_length);\n\n  case HASHKIT_HASH_MURMUR:\n#ifdef HAVE_MURMUR_HASH\n    return libhashkit_murmur(key, key_length);\n#else\n    return 1;\n#endif\n  case HASHKIT_HASH_JENKINS:\n    return libhashkit_jenkins(key, key_length);\n  case HASHKIT_HASH_CUSTOM:\n  case HASHKIT_HASH_MAX:\n  default:\n    if (DEBUG) {\n      fprintf(stderr,\n              \"hashkit_hash_t was extended but libhashkit_generate_value was not updated\\n\");\n      fflush(stderr);\n      assert(0);\n    }\n    break;\n  }\n\n  return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nuint32_t memcached_generate_hash_value(const char *key, size_t key_length,\n                                       memcached_hash_t hash_algorithm) {\n  return libhashkit_digest(key, key_length, (hashkit_hash_algorithm_t) hash_algorithm);\n}"
  }
]