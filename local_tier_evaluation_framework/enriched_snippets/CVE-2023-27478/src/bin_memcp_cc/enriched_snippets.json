[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcp.cc",
    "lines": "147-252",
    "snippet": "int main(int argc, char *argv[]) {\n  std::vector<memcp_file> files{};\n  client_options opt{PROGRAM_NAME, PROGRAM_VERSION, PROGRAM_DESCRIPTION,\n                     \"file [file ...]\"\n                     \"\\n\\t\\t\\t# NOTE: order of flags and positional\"\n                     \"\\n\\t\\t\\t#       arguments matters on GNU systems\"};\n\n  opt.add(nullptr, '-', no_argument, \"GNU argv extension\")\n      .parse = [&files](client_options &opt_, client_options::extended_option &ext) {\n    add_file(files, opt_, ext.arg);\n    return true;\n  };\n\n  for (const auto &def : opt.defaults) {\n    opt.add(def);\n  }\n\n  opt.add(\"set\", 'S', no_argument, \"Perform SET operations.\")\n      .parse = [](client_options &opt_, client_options::extended_option &) {\n    opt_.unset(\"add\");\n    opt_.unset(\"replace\");\n    return true;\n  };\n  opt.add(\"add\", 'A', no_argument, \"Perform ADD operations.\")\n      .parse = [](client_options &opt_, client_options::extended_option &) {\n    opt_.unset(\"set\");\n    opt_.unset(\"replace\");\n    return true;\n  };\n  opt.add(\"replace\", 'R', no_argument, \"Perform REPLACE operations.\")\n      .parse = [](client_options &opt_, client_options::extended_option &) {\n    opt_.unset(\"set\");\n    opt_.unset(\"add\");\n    return true;\n  };\n\n  opt.add(\"udp\", 'U', no_argument, \"Use UDP.\")\n      .apply = [](const client_options &opt_, const client_options::extended_option &ext, memcached_st *memc) {\n    if (MEMCACHED_SUCCESS != memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_USE_UDP, ext.set)) {\n      if (!opt_.isset(\"quiet\")) {\n        std::cerr << memcached_last_error_message(memc) << \"\\n\";\n      }\n      return false;\n    }\n    return true;\n  };\n  opt.add(\"flags\", 'F', required_argument, \"Set key flags, too.\");\n  opt.add(\"expire\", 'e', required_argument, \"Set expire time, too.\");\n\n  opt.add(\"basename\", '.', no_argument, \"Use basename of path as key (default).\");\n  opt.add(\"relative\", '+', no_argument, \"Use relative path (as passed), instead of basename only.\");\n  opt.add(\"absolute\", '/', no_argument, \"Use absolute path (real path), instead of basename only.\");\n\n  // defaults\n  opt.set(\"set\");\n  opt.set(\"basename\");\n\n  char **argp = nullptr;\n  if (!opt.parse(argc, argv, &argp)) {\n    exit(EXIT_FAILURE);\n  }\n\n  memcached_st memc;\n  if (!check_memcached(opt, memc)) {\n    exit(EXIT_FAILURE);\n  }\n\n  if (!opt.apply(&memc)) {\n    exit(EXIT_FAILURE);\n  }\n\n  if (files.empty()) {\n    if (!check_argp(opt, argp, \"No file(s) provided.\")) {\n      memcached_free(&memc);\n      exit(EXIT_FAILURE);\n    }\n    for (auto arg = argp; *arg; ++arg) {\n      add_file(files, opt, *arg);\n    }\n  }\n\n  auto exit_code = EXIT_SUCCESS;\n  for (auto &file : files) {\n    char *path = nullptr;\n    if (!path2key(opt, file, &path)) {\n      exit_code = EXIT_FAILURE;\n      continue;\n    }\n\n    auto rc = memcp(opt, memc, path, file);\n    if (memcached_success(rc)) {\n      if (opt.isset(\"verbose\")) {\n        std::cout << path << \"\\n\";\n      }\n    } else {\n      exit_code = EXIT_FAILURE;\n    }\n  }\n\n  if (!check_buffering(opt, memc)) {\n    exit_code = EXIT_FAILURE;\n  }\n\n  memcached_free(&memc);\n  exit(exit_code);\n}",
    "includes": [
      "#include <sstream>",
      "#include <fstream>",
      "#include <cstdlib>",
      "#include <climits>",
      "#include <cerrno>",
      "#include \"p9y/realpath.hpp\"",
      "#include \"p9y/libgen.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [
      "#define PROGRAM_VERSION     \"1.1\"",
      "#define PROGRAM_DESCRIPTION \"Copy a set of files to a memcached cluster.\"",
      "#define PROGRAM_NAME        \"memcp\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "exit_code"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_free",
          "args": [
            "&memc"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
          "lines": "257-261",
          "snippet": "void memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_buffering",
          "args": [
            "opt",
            "memc"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "check_buffering",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/checks.hpp",
          "lines": "25-35",
          "snippet": "bool check_buffering(const client_options &opt, memcached_st &memc) {\n  if (opt.isset(\"buffer\")) {\n    if (MEMCACHED_SUCCESS != memcached_flush_buffers(&memc)) {\n      if (!opt.isset(\"quiet\")) {\n        std::cerr << memcached_last_error_message(&memc) << \"\\n\";\n      }\n      return false;\n    }\n  }\n  return true;\n}",
          "includes": [
            "#include <fstream>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include \"libmemcached/common.h\"",
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <cstring>\n#include <cerrno>\n#include \"libmemcached/common.h\"\n#include \"options.hpp\"\n\nbool check_buffering(const client_options &opt, memcached_st &memc) {\n  if (opt.isset(\"buffer\")) {\n    if (MEMCACHED_SUCCESS != memcached_flush_buffers(&memc)) {\n      if (!opt.isset(\"quiet\")) {\n        std::cerr << memcached_last_error_message(&memc) << \"\\n\";\n      }\n      return false;\n    }\n  }\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "opt.isset",
          "args": [
            "\"verbose\""
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "isset",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "289-291",
          "snippet": "bool isset(int c) const {\n    return has(c) && get(c).set;\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool isset(int c) const {\n      return has(c) && get(c).set;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcp",
          "args": [
            "opt",
            "memc",
            "path",
            "file"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "memcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcp.cc",
          "lines": "61-94",
          "snippet": "static memcached_return_t memcp(const client_options &opt, memcached_st &memc, const char *key,\n                  const memcp_file &file) {\n  std::ifstream fstream{};\n  std::istream *istream = check_istream(opt, file.path, fstream);\n\n  if (!istream){\n    return MEMCACHED_ERROR;\n  }\n\n  const char *mode;\n  memcached_return_t rc;\n  auto data = stream2string(*istream);\n  if (file.op == memcp_file::mode::REPLACE) {\n    mode = \"replace\";\n    rc = memcached_replace(&memc, key, strlen(key), data.c_str(), data.length(),\n        file.expire, file.flags);\n  } else if (file.op == memcp_file::mode::ADD) {\n    mode = \"add\";\n    rc = memcached_add(&memc, key, strlen(key), data.c_str(), data.length(),\n        file.expire, file.flags);\n  } else {\n    mode = \"set\";\n    rc = memcached_set(&memc, key, strlen(key), data.c_str(), data.length(),\n        file.expire, file.flags);\n  }\n\n  if (!memcached_success(rc)) {\n    auto error = memcached_last_error(&memc)\n                 ? memcached_last_error_message(&memc)\n                 : memcached_strerror(&memc, rc);\n    std::cerr << \"Error occurred during memcached_\" << mode <<\"('\" << key << \"'): \" << error << \"\\n\";\n  }\n  return rc;\n}",
          "includes": [
            "#include <sstream>",
            "#include <fstream>",
            "#include <cstdlib>",
            "#include <climits>",
            "#include <cerrno>",
            "#include \"p9y/realpath.hpp\"",
            "#include \"p9y/libgen.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sstream>\n#include <fstream>\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n#include \"p9y/realpath.hpp\"\n#include \"p9y/libgen.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic memcached_return_t memcp(const client_options &opt, memcached_st &memc, const char *key,\n                  const memcp_file &file) {\n  std::ifstream fstream{};\n  std::istream *istream = check_istream(opt, file.path, fstream);\n\n  if (!istream){\n    return MEMCACHED_ERROR;\n  }\n\n  const char *mode;\n  memcached_return_t rc;\n  auto data = stream2string(*istream);\n  if (file.op == memcp_file::mode::REPLACE) {\n    mode = \"replace\";\n    rc = memcached_replace(&memc, key, strlen(key), data.c_str(), data.length(),\n        file.expire, file.flags);\n  } else if (file.op == memcp_file::mode::ADD) {\n    mode = \"add\";\n    rc = memcached_add(&memc, key, strlen(key), data.c_str(), data.length(),\n        file.expire, file.flags);\n  } else {\n    mode = \"set\";\n    rc = memcached_set(&memc, key, strlen(key), data.c_str(), data.length(),\n        file.expire, file.flags);\n  }\n\n  if (!memcached_success(rc)) {\n    auto error = memcached_last_error(&memc)\n                 ? memcached_last_error_message(&memc)\n                 : memcached_strerror(&memc, rc);\n    std::cerr << \"Error occurred during memcached_\" << mode <<\"('\" << key << \"'): \" << error << \"\\n\";\n  }\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path2key",
          "args": [
            "opt",
            "file",
            "&path"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "path2key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcp.cc",
          "lines": "129-145",
          "snippet": "static bool path2key(const client_options &opt, memcp_file &file, char **path) {\n  static char rpath[PATH_MAX + 1];\n  if (file.key == memcp_file::type::absolute) {\n    *path = realpath(file.path, rpath);\n    if (!*path) {\n      if (!opt.isset(\"quiet\")) {\n        perror(file.path);\n      }\n      return false;\n    }\n  } else if (file.key == memcp_file::type::relative) {\n    *path = file.path;\n  } else {\n    *path = basename(file.path);\n  }\n  return true;\n}",
          "includes": [
            "#include <sstream>",
            "#include <fstream>",
            "#include <cstdlib>",
            "#include <climits>",
            "#include <cerrno>",
            "#include \"p9y/realpath.hpp\"",
            "#include \"p9y/libgen.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sstream>\n#include <fstream>\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n#include \"p9y/realpath.hpp\"\n#include \"p9y/libgen.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic bool path2key(const client_options &opt, memcp_file &file, char **path) {\n  static char rpath[PATH_MAX + 1];\n  if (file.key == memcp_file::type::absolute) {\n    *path = realpath(file.path, rpath);\n    if (!*path) {\n      if (!opt.isset(\"quiet\")) {\n        perror(file.path);\n      }\n      return false;\n    }\n  } else if (file.key == memcp_file::type::relative) {\n    *path = file.path;\n  } else {\n    *path = basename(file.path);\n  }\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_file",
          "args": [
            "files",
            "opt",
            "*arg"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "add_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcp.cc",
          "lines": "96-127",
          "snippet": "static void add_file(std::vector<memcp_file> &files, const client_options &opt, char *file) {\n  memcp_file::type type = memcp_file::type::basename;\n  memcp_file::mode mode = memcp_file::mode::SET;\n  uint32_t flags = 0;\n  time_t expire = 0;\n\n  if (opt.isset(\"absolute\")) {\n    type = memcp_file::type::absolute;\n  } else if (opt.isset(\"relative\")) {\n    type = memcp_file::type::relative;\n  }\n\n  if (opt.isset(\"replace\")) {\n    mode = memcp_file::mode::REPLACE;\n  } else if (opt.isset(\"add\")) {\n    mode = memcp_file::mode::ADD;\n  }\n\n  if (auto flags_str = opt.argof(\"flags\")) {\n    flags = std::stoul(flags_str);\n  }\n  if (auto expire_str = opt.argof(\"expire\")) {\n    expire = std::stoul(expire_str);\n  }\n\n  if (opt.isset(\"debug\")) {\n    auto mode_str = mode == memcp_file::mode::REPLACE ? \"REPLACE\" : mode == memcp_file::mode::ADD ? \"ADD\" : \"SET\";\n    std::cerr << \"Scheduling \" << mode_str << \" '\" << file << \"' (expire=\" << expire << \", flags=\" << flags << \").\\n\";\n  }\n\n  files.emplace_back(memcp_file{type, mode, file, flags, expire});\n}",
          "includes": [
            "#include <sstream>",
            "#include <fstream>",
            "#include <cstdlib>",
            "#include <climits>",
            "#include <cerrno>",
            "#include \"p9y/realpath.hpp\"",
            "#include \"p9y/libgen.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sstream>\n#include <fstream>\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n#include \"p9y/realpath.hpp\"\n#include \"p9y/libgen.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic void add_file(std::vector<memcp_file> &files, const client_options &opt, char *file) {\n  memcp_file::type type = memcp_file::type::basename;\n  memcp_file::mode mode = memcp_file::mode::SET;\n  uint32_t flags = 0;\n  time_t expire = 0;\n\n  if (opt.isset(\"absolute\")) {\n    type = memcp_file::type::absolute;\n  } else if (opt.isset(\"relative\")) {\n    type = memcp_file::type::relative;\n  }\n\n  if (opt.isset(\"replace\")) {\n    mode = memcp_file::mode::REPLACE;\n  } else if (opt.isset(\"add\")) {\n    mode = memcp_file::mode::ADD;\n  }\n\n  if (auto flags_str = opt.argof(\"flags\")) {\n    flags = std::stoul(flags_str);\n  }\n  if (auto expire_str = opt.argof(\"expire\")) {\n    expire = std::stoul(expire_str);\n  }\n\n  if (opt.isset(\"debug\")) {\n    auto mode_str = mode == memcp_file::mode::REPLACE ? \"REPLACE\" : mode == memcp_file::mode::ADD ? \"ADD\" : \"SET\";\n    std::cerr << \"Scheduling \" << mode_str << \" '\" << file << \"' (expire=\" << expire << \", flags=\" << flags << \").\\n\";\n  }\n\n  files.emplace_back(memcp_file{type, mode, file, flags, expire});\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_argp",
          "args": [
            "opt",
            "argp",
            "\"No file(s) provided.\""
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "check_argp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/checks.hpp",
          "lines": "37-45",
          "snippet": "bool check_argp(const client_options &opt, char **argp, const char *error_msg) {\n  if (argp && *argp) {\n    return true;\n  }\n  if (!opt.isset(\"quiet\")) {\n    std::cerr << error_msg << \"\\n\";\n  }\n  return false;\n}",
          "includes": [
            "#include <fstream>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include \"libmemcached/common.h\"",
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <cstring>\n#include <cerrno>\n#include \"libmemcached/common.h\"\n#include \"options.hpp\"\n\nbool check_argp(const client_options &opt, char **argp, const char *error_msg) {\n  if (argp && *argp) {\n    return true;\n  }\n  if (!opt.isset(\"quiet\")) {\n    std::cerr << error_msg << \"\\n\";\n  }\n  return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "files.empty",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.apply",
          "args": [
            "&memc"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "apply",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.cpp",
          "lines": "149-177",
          "snippet": "bool client_options::apply(memcached_st *memc) {\n#ifdef _WIN32\n  WSADATA wsaData;\n  if (WSAStartup(MAKEWORD(2, 2), &wsaData)) {\n    std::cerr << \"Socket Initialization Error.\\n\";\n    return false;\n  }\n#endif // _WIN32\n\n  extended_option *servers = nullptr;\n  for (auto &opt : options) {\n    if (opt.apply) {\n      // servers should be applied last, so they take up any behaviors previously set\n      if (opt.opt.val == 's' && opt.opt.name == std::string(\"servers\")) {\n        servers = &opt;\n        continue;\n      }\n      if (!opt.apply(*this, opt, memc)) {\n        return false;\n      }\n    }\n  }\n  if (servers) {\n    if (!servers->apply(*this, *servers, memc)) {\n      return false;\n    }\n  }\n  return true;\n}",
          "includes": [
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"options.hpp\"\n\nclient_options {\n  bool client_options::apply(memcached_st *memc) {\n  #ifdef _WIN32\n    WSADATA wsaData;\n    if (WSAStartup(MAKEWORD(2, 2), &wsaData)) {\n      std::cerr << \"Socket Initialization Error.\\n\";\n      return false;\n    }\n  #endif // _WIN32\n  \n    extended_option *servers = nullptr;\n    for (auto &opt : options) {\n      if (opt.apply) {\n        // servers should be applied last, so they take up any behaviors previously set\n        if (opt.opt.val == 's' && opt.opt.name == std::string(\"servers\")) {\n          servers = &opt;\n          continue;\n        }\n        if (!opt.apply(*this, opt, memc)) {\n          return false;\n        }\n      }\n    }\n    if (servers) {\n      if (!servers->apply(*this, *servers, memc)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_memcached",
          "args": [
            "opt",
            "memc"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "check_memcached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/checks.hpp",
          "lines": "47-55",
          "snippet": "bool check_memcached(const client_options &opt, memcached_st &memc) {\n  if (!memcached_create(&memc)) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failed to initialize memcached client.\\n\";\n    }\n    return false;\n  }\n  return true;\n}",
          "includes": [
            "#include <fstream>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include \"libmemcached/common.h\"",
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <cstring>\n#include <cerrno>\n#include \"libmemcached/common.h\"\n#include \"options.hpp\"\n\nbool check_memcached(const client_options &opt, memcached_st &memc) {\n  if (!memcached_create(&memc)) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failed to initialize memcached client.\\n\";\n    }\n    return false;\n  }\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.parse",
          "args": [
            "argc",
            "argv",
            "&argp"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.cpp",
          "lines": "88-147",
          "snippet": "bool client_options::parse(int argc, char **argv, char ***argp) {\n  /* extern */ optind = 1;\n  auto debug = has(\"debug\") ? &get(\"debug\") : nullptr;\n  std::string short_opts{};\n  std::vector<option> long_opts{};\n\n  short_opts.reserve(options.size() * 3);\n  long_opts.reserve(options.size() + 1);\n\n  for (const auto &ext : options) {\n    if (ext.opt.val) {\n      short_opts.push_back(ext.opt.val);\n      for (int i = 0; i < ext.opt.has_arg; ++i) {\n        short_opts.push_back(':');\n      }\n    }\n    if (ext.opt.name) {\n      long_opts.push_back(ext.opt);\n    }\n  }\n  long_opts.push_back({});\n\n  while (true) {\n    auto opt = getopt_long(argc, argv, short_opts.c_str(), long_opts.data(), nullptr);\n\n    if (debug->set && opt > 0) {\n      std::cerr << \"Processing option '\" << (char) opt << \"' (\" << opt << \")\\n\";\n    }\n    if (opt == '?') {\n      return false;\n    }\n    if (opt == -1) {\n      if (argp) {\n        *argp = &argv[optind];\n      }\n      return true;\n    }\n\n    auto &ext_opt = get(opt);\n\n    // grab optional argument\n    if (ext_opt.opt.has_arg == optional_argument && !optarg) {\n      auto next_arg = argv[optind];\n\n      if (next_arg && *next_arg && *next_arg != '-') {\n        optarg = next_arg;\n        ++optind;\n      }\n    }\n\n    ext_opt.set = true;\n    ext_opt.arg = optarg;\n\n    if (ext_opt.parse) {\n      if (!ext_opt.parse(*this, ext_opt)) {\n        return false;\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"options.hpp\"\n\nclient_options {\n  bool client_options::parse(int argc, char **argv, char ***argp) {\n    /* extern */ optind = 1;\n    auto debug = has(\"debug\") ? &get(\"debug\") : nullptr;\n    std::string short_opts{};\n    std::vector<option> long_opts{};\n  \n    short_opts.reserve(options.size() * 3);\n    long_opts.reserve(options.size() + 1);\n  \n    for (const auto &ext : options) {\n      if (ext.opt.val) {\n        short_opts.push_back(ext.opt.val);\n        for (int i = 0; i < ext.opt.has_arg; ++i) {\n          short_opts.push_back(':');\n        }\n      }\n      if (ext.opt.name) {\n        long_opts.push_back(ext.opt);\n      }\n    }\n    long_opts.push_back({});\n  \n    while (true) {\n      auto opt = getopt_long(argc, argv, short_opts.c_str(), long_opts.data(), nullptr);\n  \n      if (debug->set && opt > 0) {\n        std::cerr << \"Processing option '\" << (char) opt << \"' (\" << opt << \")\\n\";\n      }\n      if (opt == '?') {\n        return false;\n      }\n      if (opt == -1) {\n        if (argp) {\n          *argp = &argv[optind];\n        }\n        return true;\n      }\n  \n      auto &ext_opt = get(opt);\n  \n      // grab optional argument\n      if (ext_opt.opt.has_arg == optional_argument && !optarg) {\n        auto next_arg = argv[optind];\n  \n        if (next_arg && *next_arg && *next_arg != '-') {\n          optarg = next_arg;\n          ++optind;\n        }\n      }\n  \n      ext_opt.set = true;\n      ext_opt.arg = optarg;\n  \n      if (ext_opt.parse) {\n        if (!ext_opt.parse(*this, ext_opt)) {\n          return false;\n        }\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "opt.set",
          "args": [
            "\"basename\""
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "307-313",
          "snippet": "void set(int c, bool set_ = true, char *optarg_ = nullptr) {\n    if (has(c)) {\n      auto &opt = get(c);\n      opt.set = set_;\n      opt.arg = optarg_;\n    }\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  void set(int c, bool set_ = true, char *optarg_ = nullptr) {\n      if (has(c)) {\n        auto &opt = get(c);\n        opt.set = set_;\n        opt.arg = optarg_;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"absolute\"",
            "'/'",
            "no_argument",
            "\"Use absolute path (real path), instead of basename only.\""
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"relative\"",
            "'+'",
            "no_argument",
            "\"Use relative path (as passed), instead of basename only.\""
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"basename\"",
            "'.'",
            "no_argument",
            "\"Use basename of path as key (default).\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"expire\"",
            "'e'",
            "required_argument",
            "\"Set expire time, too.\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"flags\"",
            "'F'",
            "required_argument",
            "\"Set key flags, too.\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error_message",
          "args": [
            "memc"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_behavior_set",
          "args": [
            "memc",
            "MEMCACHED_BEHAVIOR_USE_UDP",
            "ext.set"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_behavior_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "48-282",
          "snippet": "memcached_return_t memcached_behavior_set(memcached_st *shell, const memcached_behavior_t flag,\n                                          uint64_t data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    ptr->number_of_replicas = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    ptr->io_msg_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    ptr->io_bytes_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    ptr->io_key_prefetch = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    ptr->snd_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    ptr->rcv_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    if (data == 0) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT requires a value greater then zero.\"));\n    }\n    ptr->server_failure_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    ptr->server_timeout_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    if (data) {\n      ptr->flags.verify_key = false;\n    }\n    ptr->flags.binary_protocol = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    ptr->flags.support_cas = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    ptr->flags.no_block = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    if (memcached_is_udp(ptr)) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS cannot be set while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    ptr->flags.buffer_requests = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    ptr->flags.use_udp = bool(data);\n    if (bool(data)) {\n      ptr->flags.reply = false;\n      ptr->flags.buffer_requests = false;\n    } else {\n      ptr->flags.reply = true;\n    }\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    ptr->flags.tcp_nodelay = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    ptr->flags.tcp_keepalive = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return memcached_behavior_set_distribution(ptr, (memcached_server_distribution_t) data);\n\n  case MEMCACHED_BEHAVIOR_KETAMA: {\n    if (data) // Turn on\n    {\n      return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    }\n\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_MODULA);\n  }\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED: {\n    if (bool(data) == false) {\n      return memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_KETAMA, true);\n    }\n\n    (void) memcached_behavior_set_key_hash(ptr, MEMCACHED_HASH_MD5);\n    (void) memcached_behavior_set_distribution_hash(ptr, MEMCACHED_HASH_MD5);\n    /**\n      @note We try to keep the same distribution going. This should be deprecated and rewritten.\n    */\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED);\n  }\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return memcached_behavior_set_key_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return memcached_behavior_set_distribution_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS has been deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    if (ptr->flags.binary_protocol) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_VERIFY_KEY if the binary protocol has been enabled.\"));\n    }\n    ptr->flags.verify_key = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS: {\n    ptr->flags.use_sort_hosts = bool(data);\n    return run_distribution(ptr);\n  }\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    ptr->poll_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    ptr->connect_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    ptr->retry_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    ptr->dead_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE:\n    ptr->send_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE:\n    ptr->recv_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    ptr->tcp_keepidle = (uint32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    return memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                               memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    ptr->flags.hash_with_namespace = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    if (memcached_is_udp(ptr) and bool(data) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_NOREPLY cannot be disabled while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    // We reverse the logic here to make it easier to understand throughout the\n    // code.\n    ptr->flags.reply = bool(data) ? false : true;\n    break;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    srandom((uint32_t) time(NULL));\n    ptr->flags.randomize_replica_read = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_CORK is now incorporated into the driver by default.\"));\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_LOAD_FROM_FILE can not be set with memcached_behavior_set()\"));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    /* Shouldn't get here */\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_set()\");\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid behavior passed to memcached_behavior_set()\"));\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_behavior_set(memcached_st *shell, const memcached_behavior_t flag,\n                                          uint64_t data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    ptr->number_of_replicas = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    ptr->io_msg_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    ptr->io_bytes_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    ptr->io_key_prefetch = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    ptr->snd_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    ptr->rcv_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    if (data == 0) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT requires a value greater then zero.\"));\n    }\n    ptr->server_failure_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    ptr->server_timeout_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    if (data) {\n      ptr->flags.verify_key = false;\n    }\n    ptr->flags.binary_protocol = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    ptr->flags.support_cas = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    ptr->flags.no_block = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    if (memcached_is_udp(ptr)) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS cannot be set while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    ptr->flags.buffer_requests = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    ptr->flags.use_udp = bool(data);\n    if (bool(data)) {\n      ptr->flags.reply = false;\n      ptr->flags.buffer_requests = false;\n    } else {\n      ptr->flags.reply = true;\n    }\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    ptr->flags.tcp_nodelay = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    ptr->flags.tcp_keepalive = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return memcached_behavior_set_distribution(ptr, (memcached_server_distribution_t) data);\n\n  case MEMCACHED_BEHAVIOR_KETAMA: {\n    if (data) // Turn on\n    {\n      return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    }\n\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_MODULA);\n  }\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED: {\n    if (bool(data) == false) {\n      return memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_KETAMA, true);\n    }\n\n    (void) memcached_behavior_set_key_hash(ptr, MEMCACHED_HASH_MD5);\n    (void) memcached_behavior_set_distribution_hash(ptr, MEMCACHED_HASH_MD5);\n    /**\n      @note We try to keep the same distribution going. This should be deprecated and rewritten.\n    */\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED);\n  }\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return memcached_behavior_set_key_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return memcached_behavior_set_distribution_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS has been deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    if (ptr->flags.binary_protocol) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_VERIFY_KEY if the binary protocol has been enabled.\"));\n    }\n    ptr->flags.verify_key = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS: {\n    ptr->flags.use_sort_hosts = bool(data);\n    return run_distribution(ptr);\n  }\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    ptr->poll_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    ptr->connect_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    ptr->retry_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    ptr->dead_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE:\n    ptr->send_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE:\n    ptr->recv_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    ptr->tcp_keepidle = (uint32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    return memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                               memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    ptr->flags.hash_with_namespace = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    if (memcached_is_udp(ptr) and bool(data) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_NOREPLY cannot be disabled while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    // We reverse the logic here to make it easier to understand throughout the\n    // code.\n    ptr->flags.reply = bool(data) ? false : true;\n    break;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    srandom((uint32_t) time(NULL));\n    ptr->flags.randomize_replica_read = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_CORK is now incorporated into the driver by default.\"));\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_LOAD_FROM_FILE can not be set with memcached_behavior_set()\"));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    /* Shouldn't get here */\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_set()\");\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid behavior passed to memcached_behavior_set()\"));\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"udp\"",
            "'U'",
            "no_argument",
            "\"Use UDP.\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt_.unset",
          "args": [
            "\"add\""
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "unset",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "296-298",
          "snippet": "void unset(int c) {\n    set(c, false);\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  void unset(int c) {\n      set(c, false);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"replace\"",
            "'R'",
            "no_argument",
            "\"Perform REPLACE operations.\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"add\"",
            "'A'",
            "no_argument",
            "\"Perform ADD operations.\""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"set\"",
            "'S'",
            "no_argument",
            "\"Perform SET operations.\""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "def"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "nullptr",
            "'-'",
            "no_argument",
            "\"GNU argv extension\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sstream>\n#include <fstream>\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n#include \"p9y/realpath.hpp\"\n#include \"p9y/libgen.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\n#define PROGRAM_VERSION     \"1.1\"\n#define PROGRAM_DESCRIPTION \"Copy a set of files to a memcached cluster.\"\n#define PROGRAM_NAME        \"memcp\"\n\nint main(int argc, char *argv[]) {\n  std::vector<memcp_file> files{};\n  client_options opt{PROGRAM_NAME, PROGRAM_VERSION, PROGRAM_DESCRIPTION,\n                     \"file [file ...]\"\n                     \"\\n\\t\\t\\t# NOTE: order of flags and positional\"\n                     \"\\n\\t\\t\\t#       arguments matters on GNU systems\"};\n\n  opt.add(nullptr, '-', no_argument, \"GNU argv extension\")\n      .parse = [&files](client_options &opt_, client_options::extended_option &ext) {\n    add_file(files, opt_, ext.arg);\n    return true;\n  };\n\n  for (const auto &def : opt.defaults) {\n    opt.add(def);\n  }\n\n  opt.add(\"set\", 'S', no_argument, \"Perform SET operations.\")\n      .parse = [](client_options &opt_, client_options::extended_option &) {\n    opt_.unset(\"add\");\n    opt_.unset(\"replace\");\n    return true;\n  };\n  opt.add(\"add\", 'A', no_argument, \"Perform ADD operations.\")\n      .parse = [](client_options &opt_, client_options::extended_option &) {\n    opt_.unset(\"set\");\n    opt_.unset(\"replace\");\n    return true;\n  };\n  opt.add(\"replace\", 'R', no_argument, \"Perform REPLACE operations.\")\n      .parse = [](client_options &opt_, client_options::extended_option &) {\n    opt_.unset(\"set\");\n    opt_.unset(\"add\");\n    return true;\n  };\n\n  opt.add(\"udp\", 'U', no_argument, \"Use UDP.\")\n      .apply = [](const client_options &opt_, const client_options::extended_option &ext, memcached_st *memc) {\n    if (MEMCACHED_SUCCESS != memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_USE_UDP, ext.set)) {\n      if (!opt_.isset(\"quiet\")) {\n        std::cerr << memcached_last_error_message(memc) << \"\\n\";\n      }\n      return false;\n    }\n    return true;\n  };\n  opt.add(\"flags\", 'F', required_argument, \"Set key flags, too.\");\n  opt.add(\"expire\", 'e', required_argument, \"Set expire time, too.\");\n\n  opt.add(\"basename\", '.', no_argument, \"Use basename of path as key (default).\");\n  opt.add(\"relative\", '+', no_argument, \"Use relative path (as passed), instead of basename only.\");\n  opt.add(\"absolute\", '/', no_argument, \"Use absolute path (real path), instead of basename only.\");\n\n  // defaults\n  opt.set(\"set\");\n  opt.set(\"basename\");\n\n  char **argp = nullptr;\n  if (!opt.parse(argc, argv, &argp)) {\n    exit(EXIT_FAILURE);\n  }\n\n  memcached_st memc;\n  if (!check_memcached(opt, memc)) {\n    exit(EXIT_FAILURE);\n  }\n\n  if (!opt.apply(&memc)) {\n    exit(EXIT_FAILURE);\n  }\n\n  if (files.empty()) {\n    if (!check_argp(opt, argp, \"No file(s) provided.\")) {\n      memcached_free(&memc);\n      exit(EXIT_FAILURE);\n    }\n    for (auto arg = argp; *arg; ++arg) {\n      add_file(files, opt, *arg);\n    }\n  }\n\n  auto exit_code = EXIT_SUCCESS;\n  for (auto &file : files) {\n    char *path = nullptr;\n    if (!path2key(opt, file, &path)) {\n      exit_code = EXIT_FAILURE;\n      continue;\n    }\n\n    auto rc = memcp(opt, memc, path, file);\n    if (memcached_success(rc)) {\n      if (opt.isset(\"verbose\")) {\n        std::cout << path << \"\\n\";\n      }\n    } else {\n      exit_code = EXIT_FAILURE;\n    }\n  }\n\n  if (!check_buffering(opt, memc)) {\n    exit_code = EXIT_FAILURE;\n  }\n\n  memcached_free(&memc);\n  exit(exit_code);\n}"
  },
  {
    "function_name": "path2key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcp.cc",
    "lines": "129-145",
    "snippet": "static bool path2key(const client_options &opt, memcp_file &file, char **path) {\n  static char rpath[PATH_MAX + 1];\n  if (file.key == memcp_file::type::absolute) {\n    *path = realpath(file.path, rpath);\n    if (!*path) {\n      if (!opt.isset(\"quiet\")) {\n        perror(file.path);\n      }\n      return false;\n    }\n  } else if (file.key == memcp_file::type::relative) {\n    *path = file.path;\n  } else {\n    *path = basename(file.path);\n  }\n  return true;\n}",
    "includes": [
      "#include <sstream>",
      "#include <fstream>",
      "#include <cstdlib>",
      "#include <climits>",
      "#include <cerrno>",
      "#include \"p9y/realpath.hpp\"",
      "#include \"p9y/libgen.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "basename",
          "args": [
            "file.path"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "file.path"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.isset",
          "args": [
            "\"quiet\""
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "isset",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "289-291",
          "snippet": "bool isset(int c) const {\n    return has(c) && get(c).set;\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool isset(int c) const {\n      return has(c) && get(c).set;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "file.path",
            "rpath"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sstream>\n#include <fstream>\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n#include \"p9y/realpath.hpp\"\n#include \"p9y/libgen.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic bool path2key(const client_options &opt, memcp_file &file, char **path) {\n  static char rpath[PATH_MAX + 1];\n  if (file.key == memcp_file::type::absolute) {\n    *path = realpath(file.path, rpath);\n    if (!*path) {\n      if (!opt.isset(\"quiet\")) {\n        perror(file.path);\n      }\n      return false;\n    }\n  } else if (file.key == memcp_file::type::relative) {\n    *path = file.path;\n  } else {\n    *path = basename(file.path);\n  }\n  return true;\n}"
  },
  {
    "function_name": "add_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcp.cc",
    "lines": "96-127",
    "snippet": "static void add_file(std::vector<memcp_file> &files, const client_options &opt, char *file) {\n  memcp_file::type type = memcp_file::type::basename;\n  memcp_file::mode mode = memcp_file::mode::SET;\n  uint32_t flags = 0;\n  time_t expire = 0;\n\n  if (opt.isset(\"absolute\")) {\n    type = memcp_file::type::absolute;\n  } else if (opt.isset(\"relative\")) {\n    type = memcp_file::type::relative;\n  }\n\n  if (opt.isset(\"replace\")) {\n    mode = memcp_file::mode::REPLACE;\n  } else if (opt.isset(\"add\")) {\n    mode = memcp_file::mode::ADD;\n  }\n\n  if (auto flags_str = opt.argof(\"flags\")) {\n    flags = std::stoul(flags_str);\n  }\n  if (auto expire_str = opt.argof(\"expire\")) {\n    expire = std::stoul(expire_str);\n  }\n\n  if (opt.isset(\"debug\")) {\n    auto mode_str = mode == memcp_file::mode::REPLACE ? \"REPLACE\" : mode == memcp_file::mode::ADD ? \"ADD\" : \"SET\";\n    std::cerr << \"Scheduling \" << mode_str << \" '\" << file << \"' (expire=\" << expire << \", flags=\" << flags << \").\\n\";\n  }\n\n  files.emplace_back(memcp_file{type, mode, file, flags, expire});\n}",
    "includes": [
      "#include <sstream>",
      "#include <fstream>",
      "#include <cstdlib>",
      "#include <climits>",
      "#include <cerrno>",
      "#include \"p9y/realpath.hpp\"",
      "#include \"p9y/libgen.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "files.emplace_back",
          "args": [
            "memcp_file{type, mode, file, flags, expire}"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.isset",
          "args": [
            "\"debug\""
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "isset",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "289-291",
          "snippet": "bool isset(int c) const {\n    return has(c) && get(c).set;\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool isset(int c) const {\n      return has(c) && get(c).set;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::stoul",
          "args": [
            "expire_str"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.argof",
          "args": [
            "\"expire\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::stoul",
          "args": [
            "flags_str"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.argof",
          "args": [
            "\"flags\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sstream>\n#include <fstream>\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n#include \"p9y/realpath.hpp\"\n#include \"p9y/libgen.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic void add_file(std::vector<memcp_file> &files, const client_options &opt, char *file) {\n  memcp_file::type type = memcp_file::type::basename;\n  memcp_file::mode mode = memcp_file::mode::SET;\n  uint32_t flags = 0;\n  time_t expire = 0;\n\n  if (opt.isset(\"absolute\")) {\n    type = memcp_file::type::absolute;\n  } else if (opt.isset(\"relative\")) {\n    type = memcp_file::type::relative;\n  }\n\n  if (opt.isset(\"replace\")) {\n    mode = memcp_file::mode::REPLACE;\n  } else if (opt.isset(\"add\")) {\n    mode = memcp_file::mode::ADD;\n  }\n\n  if (auto flags_str = opt.argof(\"flags\")) {\n    flags = std::stoul(flags_str);\n  }\n  if (auto expire_str = opt.argof(\"expire\")) {\n    expire = std::stoul(expire_str);\n  }\n\n  if (opt.isset(\"debug\")) {\n    auto mode_str = mode == memcp_file::mode::REPLACE ? \"REPLACE\" : mode == memcp_file::mode::ADD ? \"ADD\" : \"SET\";\n    std::cerr << \"Scheduling \" << mode_str << \" '\" << file << \"' (expire=\" << expire << \", flags=\" << flags << \").\\n\";\n  }\n\n  files.emplace_back(memcp_file{type, mode, file, flags, expire});\n}"
  },
  {
    "function_name": "memcp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcp.cc",
    "lines": "61-94",
    "snippet": "static memcached_return_t memcp(const client_options &opt, memcached_st &memc, const char *key,\n                  const memcp_file &file) {\n  std::ifstream fstream{};\n  std::istream *istream = check_istream(opt, file.path, fstream);\n\n  if (!istream){\n    return MEMCACHED_ERROR;\n  }\n\n  const char *mode;\n  memcached_return_t rc;\n  auto data = stream2string(*istream);\n  if (file.op == memcp_file::mode::REPLACE) {\n    mode = \"replace\";\n    rc = memcached_replace(&memc, key, strlen(key), data.c_str(), data.length(),\n        file.expire, file.flags);\n  } else if (file.op == memcp_file::mode::ADD) {\n    mode = \"add\";\n    rc = memcached_add(&memc, key, strlen(key), data.c_str(), data.length(),\n        file.expire, file.flags);\n  } else {\n    mode = \"set\";\n    rc = memcached_set(&memc, key, strlen(key), data.c_str(), data.length(),\n        file.expire, file.flags);\n  }\n\n  if (!memcached_success(rc)) {\n    auto error = memcached_last_error(&memc)\n                 ? memcached_last_error_message(&memc)\n                 : memcached_strerror(&memc, rc);\n    std::cerr << \"Error occurred during memcached_\" << mode <<\"('\" << key << \"'): \" << error << \"\\n\";\n  }\n  return rc;\n}",
    "includes": [
      "#include <sstream>",
      "#include <fstream>",
      "#include <cstdlib>",
      "#include <climits>",
      "#include <cerrno>",
      "#include \"p9y/realpath.hpp\"",
      "#include \"p9y/libgen.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_strerror",
          "args": [
            "&memc",
            "rc"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error_message",
          "args": [
            "&memc"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error",
          "args": [
            "&memc"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_last_error_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "500-511",
          "snippet": "int memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nint memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set",
          "args": [
            "&memc",
            "key",
            "strlen(key)",
            "data.c_str()",
            "data.length()",
            "file.expire",
            "file.flags"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "325-334",
          "snippet": "memcached_return_t memcached_set(memcached_st *ptr, const char *key, size_t key_length,\n                                 const char *value, size_t value_length, time_t expiration,\n                                 uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_SET_START();\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      0, SET_OP);\n  LIBMEMCACHED_MEMCACHED_SET_END();\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set(memcached_st *ptr, const char *key, size_t key_length,\n                                 const char *value, size_t value_length, time_t expiration,\n                                 uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_SET_START();\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      0, SET_OP);\n  LIBMEMCACHED_MEMCACHED_SET_END();\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.length",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.c_str",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_add",
          "args": [
            "&memc",
            "key",
            "strlen(key)",
            "data.c_str()",
            "data.length()",
            "file.expire",
            "file.flags"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "336-346",
          "snippet": "memcached_return_t memcached_add(memcached_st *ptr, const char *key, size_t key_length,\n                                 const char *value, size_t value_length, time_t expiration,\n                                 uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_ADD_START();\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      0, ADD_OP);\n\n  LIBMEMCACHED_MEMCACHED_ADD_END();\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_add(memcached_st *ptr, const char *key, size_t key_length,\n                                 const char *value, size_t value_length, time_t expiration,\n                                 uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_ADD_START();\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      0, ADD_OP);\n\n  LIBMEMCACHED_MEMCACHED_ADD_END();\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.length",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.c_str",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_replace",
          "args": [
            "&memc",
            "key",
            "strlen(key)",
            "data.c_str()",
            "data.length()",
            "file.expire",
            "file.flags"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/storage.cc",
          "lines": "348-357",
          "snippet": "memcached_return_t memcached_replace(memcached_st *ptr, const char *key, size_t key_length,\n                                     const char *value, size_t value_length, time_t expiration,\n                                     uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_REPLACE_START();\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      0, REPLACE_OP);\n  LIBMEMCACHED_MEMCACHED_REPLACE_END();\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_replace(memcached_st *ptr, const char *key, size_t key_length,\n                                     const char *value, size_t value_length, time_t expiration,\n                                     uint32_t flags) {\n  memcached_return_t rc;\n  LIBMEMCACHED_MEMCACHED_REPLACE_START();\n  rc = memcached_send(ptr, key, key_length, key, key_length, value, value_length, expiration, flags,\n                      0, REPLACE_OP);\n  LIBMEMCACHED_MEMCACHED_REPLACE_END();\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.length",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.c_str",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream2string",
          "args": [
            "*istream"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "stream2string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcp.cc",
          "lines": "57-59",
          "snippet": "static inline std::string stream2string(const std::istream &istream) {\n  return dynamic_cast<std::ostringstream &&>(std::ostringstream{} << istream.rdbuf()).str();\n}",
          "includes": [
            "#include <sstream>",
            "#include <fstream>",
            "#include <cstdlib>",
            "#include <climits>",
            "#include <cerrno>",
            "#include \"p9y/realpath.hpp\"",
            "#include \"p9y/libgen.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sstream>\n#include <fstream>\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n#include \"p9y/realpath.hpp\"\n#include \"p9y/libgen.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic inline std::string stream2string(const std::istream &istream) {\n  return dynamic_cast<std::ostringstream &&>(std::ostringstream{} << istream.rdbuf()).str();\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_istream",
          "args": [
            "opt",
            "file.path",
            "fstream"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sstream>\n#include <fstream>\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n#include \"p9y/realpath.hpp\"\n#include \"p9y/libgen.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic memcached_return_t memcp(const client_options &opt, memcached_st &memc, const char *key,\n                  const memcp_file &file) {\n  std::ifstream fstream{};\n  std::istream *istream = check_istream(opt, file.path, fstream);\n\n  if (!istream){\n    return MEMCACHED_ERROR;\n  }\n\n  const char *mode;\n  memcached_return_t rc;\n  auto data = stream2string(*istream);\n  if (file.op == memcp_file::mode::REPLACE) {\n    mode = \"replace\";\n    rc = memcached_replace(&memc, key, strlen(key), data.c_str(), data.length(),\n        file.expire, file.flags);\n  } else if (file.op == memcp_file::mode::ADD) {\n    mode = \"add\";\n    rc = memcached_add(&memc, key, strlen(key), data.c_str(), data.length(),\n        file.expire, file.flags);\n  } else {\n    mode = \"set\";\n    rc = memcached_set(&memc, key, strlen(key), data.c_str(), data.length(),\n        file.expire, file.flags);\n  }\n\n  if (!memcached_success(rc)) {\n    auto error = memcached_last_error(&memc)\n                 ? memcached_last_error_message(&memc)\n                 : memcached_strerror(&memc, rc);\n    std::cerr << \"Error occurred during memcached_\" << mode <<\"('\" << key << \"'): \" << error << \"\\n\";\n  }\n  return rc;\n}"
  },
  {
    "function_name": "stream2string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcp.cc",
    "lines": "57-59",
    "snippet": "static inline std::string stream2string(const std::istream &istream) {\n  return dynamic_cast<std::ostringstream &&>(std::ostringstream{} << istream.rdbuf()).str();\n}",
    "includes": [
      "#include <sstream>",
      "#include <fstream>",
      "#include <cstdlib>",
      "#include <climits>",
      "#include <cerrno>",
      "#include \"p9y/realpath.hpp\"",
      "#include \"p9y/libgen.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dynamic_cast<std::ostringstream &&>",
          "args": [],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dynamic_cast<std::ostringstream &&>",
          "args": [
            "std::ostringstream{} << istream.rdbuf()"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "istream.rdbuf",
          "args": [],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sstream>\n#include <fstream>\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n#include \"p9y/realpath.hpp\"\n#include \"p9y/libgen.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic inline std::string stream2string(const std::istream &istream) {\n  return dynamic_cast<std::ostringstream &&>(std::ostringstream{} << istream.rdbuf()).str();\n}"
  }
]