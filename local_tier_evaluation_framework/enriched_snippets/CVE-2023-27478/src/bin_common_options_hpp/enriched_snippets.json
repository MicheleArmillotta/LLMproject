[
  {
    "function_name": "find",
    "container": "client_options",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
    "lines": "368-372",
    "snippet": "iterator find(int c) {\n    return find([c](const extended_option &ext) {\n      return ext.opt.val == c || (c == 1 && ext.opt.val == '-');\n    });\n  }",
    "includes": [
      "#include \"p9y/getopt.hpp\"",
      "#include \"libmemcached/common.h\"",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "#include <functional>",
      "#include <climits>",
      "#include <cstdint>",
      "#include <algorithm>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find",
          "args": [
            "[c](const extended_option &ext) {\n      return ext.opt.val == c || (c == 1 && ext.opt.val == '-');\n    }"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "368-372",
          "snippet": "iterator find(int c) {\n    return find([c](const extended_option &ext) {\n      return ext.opt.val == c || (c == 1 && ext.opt.val == '-');\n    });\n  }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  iterator find(int c) {\n      return find([c](const extended_option &ext) {\n        return ext.opt.val == c || (c == 1 && ext.opt.val == '-');\n      });\n    }\n}"
  },
  {
    "function_name": "find",
    "container": "client_options",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
    "lines": "363-367",
    "snippet": "iterator find(const std::string &name) {\n    return find([&name](const extended_option &ext) {\n      return ext.opt.name && ext.opt.name == name;\n    });\n  }",
    "includes": [
      "#include \"p9y/getopt.hpp\"",
      "#include \"libmemcached/common.h\"",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "#include <functional>",
      "#include <climits>",
      "#include <cstdint>",
      "#include <algorithm>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find",
          "args": [
            "[&name](const extended_option &ext) {\n      return ext.opt.name && ext.opt.name == name;\n    }"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "368-372",
          "snippet": "iterator find(int c) {\n    return find([c](const extended_option &ext) {\n      return ext.opt.val == c || (c == 1 && ext.opt.val == '-');\n    });\n  }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  iterator find(const std::string &name) {\n      return find([&name](const extended_option &ext) {\n        return ext.opt.name && ext.opt.name == name;\n      });\n    }\n}"
  },
  {
    "function_name": "find",
    "container": "client_options",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
    "lines": "360-362",
    "snippet": "iterator find(const predicate &pred) {\n    return std::find_if(options.begin(), options.end(), pred);\n  }",
    "includes": [
      "#include \"p9y/getopt.hpp\"",
      "#include \"libmemcached/common.h\"",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "#include <functional>",
      "#include <climits>",
      "#include <cstdint>",
      "#include <algorithm>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::find_if",
          "args": [
            "options.begin()",
            "options.end()",
            "pred"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "options.end",
          "args": [],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Context",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/csl/context.h",
          "lines": "44-46",
          "snippet": "bool end() {\n    return _end;\n  }",
          "includes": [
            "#include \"libmemcached/csl/parser.h\"",
            "#include \"libmemcached/csl/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/csl/parser.h\"\n#include \"libmemcached/csl/common.h\"\n\nContext {\n  bool end() {\n      return _end;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "options.begin",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  iterator find(const predicate &pred) {\n      return std::find_if(options.begin(), options.end(), pred);\n    }\n}"
  },
  {
    "function_name": "find",
    "container": "client_options",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
    "lines": "354-358",
    "snippet": "const_iterator find(int c) const {\n    return find([c](const extended_option &ext) {\n      return ext.opt.val == c || (c == 1 && ext.opt.val == '-');\n    });\n  }",
    "includes": [
      "#include \"p9y/getopt.hpp\"",
      "#include \"libmemcached/common.h\"",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "#include <functional>",
      "#include <climits>",
      "#include <cstdint>",
      "#include <algorithm>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find",
          "args": [
            "[c](const extended_option &ext) {\n      return ext.opt.val == c || (c == 1 && ext.opt.val == '-');\n    }"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "368-372",
          "snippet": "iterator find(int c) {\n    return find([c](const extended_option &ext) {\n      return ext.opt.val == c || (c == 1 && ext.opt.val == '-');\n    });\n  }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  const_iterator find(int c) const {\n      return find([c](const extended_option &ext) {\n        return ext.opt.val == c || (c == 1 && ext.opt.val == '-');\n      });\n    }\n}"
  },
  {
    "function_name": "find",
    "container": "client_options",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
    "lines": "349-353",
    "snippet": "const_iterator find(const std::string &name) const {\n    return find([&name](const extended_option &ext) {\n      return ext.opt.name && ext.opt.name == name;\n    });\n  }",
    "includes": [
      "#include \"p9y/getopt.hpp\"",
      "#include \"libmemcached/common.h\"",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "#include <functional>",
      "#include <climits>",
      "#include <cstdint>",
      "#include <algorithm>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find",
          "args": [
            "[&name](const extended_option &ext) {\n      return ext.opt.name && ext.opt.name == name;\n    }"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "368-372",
          "snippet": "iterator find(int c) {\n    return find([c](const extended_option &ext) {\n      return ext.opt.val == c || (c == 1 && ext.opt.val == '-');\n    });\n  }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  const_iterator find(const std::string &name) const {\n      return find([&name](const extended_option &ext) {\n        return ext.opt.name && ext.opt.name == name;\n      });\n    }\n}"
  },
  {
    "function_name": "find",
    "container": "client_options",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
    "lines": "346-348",
    "snippet": "const_iterator find(const predicate &pred) const {\n    return std::find_if(options.cbegin(), options.cend(), pred);\n  }",
    "includes": [
      "#include \"p9y/getopt.hpp\"",
      "#include \"libmemcached/common.h\"",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "#include <functional>",
      "#include <climits>",
      "#include <cstdint>",
      "#include <algorithm>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::find_if",
          "args": [
            "options.cbegin()",
            "options.cend()",
            "pred"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "options.cend",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "options.cbegin",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  const_iterator find(const predicate &pred) const {\n      return std::find_if(options.cbegin(), options.cend(), pred);\n    }\n}"
  },
  {
    "function_name": "set",
    "container": "client_options",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
    "lines": "307-313",
    "snippet": "void set(int c, bool set_ = true, char *optarg_ = nullptr) {\n    if (has(c)) {\n      auto &opt = get(c);\n      opt.set = set_;\n      opt.arg = optarg_;\n    }\n  }",
    "includes": [
      "#include \"p9y/getopt.hpp\"",
      "#include \"libmemcached/common.h\"",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "#include <functional>",
      "#include <climits>",
      "#include <cstdint>",
      "#include <algorithm>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get",
          "args": [
            "c"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "hashkit_get_distribution_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/function.cc",
          "lines": "175-181",
          "snippet": "hashkit_hash_algorithm_t hashkit_get_distribution_function(const hashkit_st *self) {\n  if (self == NULL) {\n    return HASHKIT_HASH_DEFAULT;\n  }\n\n  return get_function_type(self->distribution_hash.function);\n}",
          "includes": [
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libhashkit/common.h\"\n\nhashkit_hash_algorithm_t hashkit_get_distribution_function(const hashkit_st *self) {\n  if (self == NULL) {\n    return HASHKIT_HASH_DEFAULT;\n  }\n\n  return get_function_type(self->distribution_hash.function);\n}"
        }
      },
      {
        "call_info": {
          "callee": "has",
          "args": [
            "c"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "has",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "281-284",
          "snippet": "bool has(int c) const {\n    auto found = find(c);\n    return found != options.cend();\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool has(int c) const {\n      auto found = find(c);\n      return found != options.cend();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  void set(int c, bool set_ = true, char *optarg_ = nullptr) {\n      if (has(c)) {\n        auto &opt = get(c);\n        opt.set = set_;\n        opt.arg = optarg_;\n      }\n    }\n}"
  },
  {
    "function_name": "set",
    "container": "client_options",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
    "lines": "300-306",
    "snippet": "void set(const std::string &name, bool set_ = true, char *optarg_ = nullptr) {\n    if (has(name)) {\n      auto &opt = get(name);\n      opt.set = set_;\n      opt.arg = optarg_;\n    }\n  }",
    "includes": [
      "#include \"p9y/getopt.hpp\"",
      "#include \"libmemcached/common.h\"",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "#include <functional>",
      "#include <climits>",
      "#include <cstdint>",
      "#include <algorithm>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get",
          "args": [
            "name"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "hashkit_get_distribution_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/function.cc",
          "lines": "175-181",
          "snippet": "hashkit_hash_algorithm_t hashkit_get_distribution_function(const hashkit_st *self) {\n  if (self == NULL) {\n    return HASHKIT_HASH_DEFAULT;\n  }\n\n  return get_function_type(self->distribution_hash.function);\n}",
          "includes": [
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libhashkit/common.h\"\n\nhashkit_hash_algorithm_t hashkit_get_distribution_function(const hashkit_st *self) {\n  if (self == NULL) {\n    return HASHKIT_HASH_DEFAULT;\n  }\n\n  return get_function_type(self->distribution_hash.function);\n}"
        }
      },
      {
        "call_info": {
          "callee": "has",
          "args": [
            "name"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "has",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "281-284",
          "snippet": "bool has(int c) const {\n    auto found = find(c);\n    return found != options.cend();\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool has(int c) const {\n      auto found = find(c);\n      return found != options.cend();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  void set(const std::string &name, bool set_ = true, char *optarg_ = nullptr) {\n      if (has(name)) {\n        auto &opt = get(name);\n        opt.set = set_;\n        opt.arg = optarg_;\n      }\n    }\n}"
  },
  {
    "function_name": "unset",
    "container": "client_options",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
    "lines": "296-298",
    "snippet": "void unset(int c) {\n    set(c, false);\n  }",
    "includes": [
      "#include \"p9y/getopt.hpp\"",
      "#include \"libmemcached/common.h\"",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "#include <functional>",
      "#include <climits>",
      "#include <cstdint>",
      "#include <algorithm>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set",
          "args": [
            "c",
            "false"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "hashkit_string_set_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/string.cc",
          "lines": "190-195",
          "snippet": "void hashkit_string_set_length(hashkit_string_st *self, size_t length) {\n  assert(self);\n  if (self and _string_check(self, length)) {\n    self->end = self->string + length;\n  }\n}",
          "includes": [
            "#include <cstring>",
            "#include <cassert>",
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstring>\n#include <cassert>\n#include \"libhashkit/common.h\"\n\nvoid hashkit_string_set_length(hashkit_string_st *self, size_t length) {\n  assert(self);\n  if (self and _string_check(self, length)) {\n    self->end = self->string + length;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  void unset(int c) {\n      set(c, false);\n    }\n}"
  },
  {
    "function_name": "unset",
    "container": "client_options",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
    "lines": "293-295",
    "snippet": "void unset(const std::string &name) {\n    set(name, false);\n  }",
    "includes": [
      "#include \"p9y/getopt.hpp\"",
      "#include \"libmemcached/common.h\"",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "#include <functional>",
      "#include <climits>",
      "#include <cstdint>",
      "#include <algorithm>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set",
          "args": [
            "name",
            "false"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "hashkit_string_set_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/string.cc",
          "lines": "190-195",
          "snippet": "void hashkit_string_set_length(hashkit_string_st *self, size_t length) {\n  assert(self);\n  if (self and _string_check(self, length)) {\n    self->end = self->string + length;\n  }\n}",
          "includes": [
            "#include <cstring>",
            "#include <cassert>",
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstring>\n#include <cassert>\n#include \"libhashkit/common.h\"\n\nvoid hashkit_string_set_length(hashkit_string_st *self, size_t length) {\n  assert(self);\n  if (self and _string_check(self, length)) {\n    self->end = self->string + length;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  void unset(const std::string &name) {\n      set(name, false);\n    }\n}"
  },
  {
    "function_name": "isset",
    "container": "client_options",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
    "lines": "289-291",
    "snippet": "bool isset(int c) const {\n    return has(c) && get(c).set;\n  }",
    "includes": [
      "#include \"p9y/getopt.hpp\"",
      "#include \"libmemcached/common.h\"",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "#include <functional>",
      "#include <climits>",
      "#include <cstdint>",
      "#include <algorithm>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get",
          "args": [
            "c"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "hashkit_get_distribution_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/function.cc",
          "lines": "175-181",
          "snippet": "hashkit_hash_algorithm_t hashkit_get_distribution_function(const hashkit_st *self) {\n  if (self == NULL) {\n    return HASHKIT_HASH_DEFAULT;\n  }\n\n  return get_function_type(self->distribution_hash.function);\n}",
          "includes": [
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libhashkit/common.h\"\n\nhashkit_hash_algorithm_t hashkit_get_distribution_function(const hashkit_st *self) {\n  if (self == NULL) {\n    return HASHKIT_HASH_DEFAULT;\n  }\n\n  return get_function_type(self->distribution_hash.function);\n}"
        }
      },
      {
        "call_info": {
          "callee": "has",
          "args": [
            "c"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "has",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "281-284",
          "snippet": "bool has(int c) const {\n    auto found = find(c);\n    return found != options.cend();\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool has(int c) const {\n      auto found = find(c);\n      return found != options.cend();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool isset(int c) const {\n      return has(c) && get(c).set;\n    }\n}"
  },
  {
    "function_name": "isset",
    "container": "client_options",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
    "lines": "286-288",
    "snippet": "bool isset(const std::string &name) const {\n    return has(name) && get(name).set;\n  }",
    "includes": [
      "#include \"p9y/getopt.hpp\"",
      "#include \"libmemcached/common.h\"",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "#include <functional>",
      "#include <climits>",
      "#include <cstdint>",
      "#include <algorithm>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get",
          "args": [
            "name"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "hashkit_get_distribution_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/function.cc",
          "lines": "175-181",
          "snippet": "hashkit_hash_algorithm_t hashkit_get_distribution_function(const hashkit_st *self) {\n  if (self == NULL) {\n    return HASHKIT_HASH_DEFAULT;\n  }\n\n  return get_function_type(self->distribution_hash.function);\n}",
          "includes": [
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libhashkit/common.h\"\n\nhashkit_hash_algorithm_t hashkit_get_distribution_function(const hashkit_st *self) {\n  if (self == NULL) {\n    return HASHKIT_HASH_DEFAULT;\n  }\n\n  return get_function_type(self->distribution_hash.function);\n}"
        }
      },
      {
        "call_info": {
          "callee": "has",
          "args": [
            "name"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "has",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "281-284",
          "snippet": "bool has(int c) const {\n    auto found = find(c);\n    return found != options.cend();\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool has(int c) const {\n      auto found = find(c);\n      return found != options.cend();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool isset(const std::string &name) const {\n      return has(name) && get(name).set;\n    }\n}"
  },
  {
    "function_name": "has",
    "container": "client_options",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
    "lines": "281-284",
    "snippet": "bool has(int c) const {\n    auto found = find(c);\n    return found != options.cend();\n  }",
    "includes": [
      "#include \"p9y/getopt.hpp\"",
      "#include \"libmemcached/common.h\"",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "#include <functional>",
      "#include <climits>",
      "#include <cstdint>",
      "#include <algorithm>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "options.cend",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find",
          "args": [
            "c"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "368-372",
          "snippet": "iterator find(int c) {\n    return find([c](const extended_option &ext) {\n      return ext.opt.val == c || (c == 1 && ext.opt.val == '-');\n    });\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  iterator find(int c) {\n      return find([c](const extended_option &ext) {\n        return ext.opt.val == c || (c == 1 && ext.opt.val == '-');\n      });\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool has(int c) const {\n      auto found = find(c);\n      return found != options.cend();\n    }\n}"
  },
  {
    "function_name": "has",
    "container": "client_options",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
    "lines": "277-280",
    "snippet": "bool has(const std::string &name) const {\n    auto found = find(name);\n    return found != options.cend();\n  }",
    "includes": [
      "#include \"p9y/getopt.hpp\"",
      "#include \"libmemcached/common.h\"",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "#include <functional>",
      "#include <climits>",
      "#include <cstdint>",
      "#include <algorithm>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "options.cend",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find",
          "args": [
            "name"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "368-372",
          "snippet": "iterator find(int c) {\n    return find([c](const extended_option &ext) {\n      return ext.opt.val == c || (c == 1 && ext.opt.val == '-');\n    });\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  iterator find(int c) {\n      return find([c](const extended_option &ext) {\n        return ext.opt.val == c || (c == 1 && ext.opt.val == '-');\n      });\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool has(const std::string &name) const {\n      auto found = find(name);\n      return found != options.cend();\n    }\n}"
  },
  {
    "function_name": "client_options",
    "container": "client_options",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
    "lines": "49-234",
    "snippet": "client_options(const char *prg, const char *ver, const char *dsc, const char *arg = nullptr)\n  : options{}\n  , defaults{}\n  , prog_name{prg}\n  , prog_vers{ver}\n  , prog_desc{dsc}\n  , prog_argp{arg}\n  {\n\n    def(\"help\", 'h', no_argument, \"Print this help.\")\n        .apply = [](const client_options &opt, const extended_option &ext, memcached_st *) {\n      if (ext.set) {\n        opt.print_help();\n        exit(EXIT_SUCCESS);\n      }\n      return true;\n    };\n    def(\"version\", 'V', no_argument, \"Print program version.\")\n        .apply = [](const client_options &opt, const extended_option &ext, memcached_st *) {\n      if (ext.set) {\n        opt.print_version();\n        exit(EXIT_SUCCESS);\n      }\n      return true;\n    };\n\n    def(\"verbose\", 'v', no_argument, \"Print more informational output.\")\n        .parse = [](client_options &opt, extended_option &) {\n      opt.unset(\"quiet\");\n      return true;\n    };\n    def(\"debug\", 'd', no_argument, \"Print output useful only for debugging.\")\n        .parse = [](client_options &opt, extended_option &) {\n      opt.set(\"verbose\");\n      opt.unset(\"quiet\");\n      return true;\n    };\n    def(\"quiet\", 'q', no_argument, \"Print no output, not even errors.\")\n        .parse = [](client_options &opt, extended_option &) {\n      opt.unset(\"verbose\");\n      opt.unset(\"debug\");\n      return true;\n    };\n\n    def(\"password\", 'p', required_argument, \"SASL password.\");\n    def(\"username\", 'u', required_argument, \"SASL username.\")\n        .apply = [](const client_options &opt, const extended_option &ext, memcached_st *memc) {\n      if (auto username = ext.arg) {\n#if !LIBMEMCACHED_WITH_SASL_SUPPORT\n          (void) memc;\n          if (!opt.isset(\"quiet\")) {\n            std::cerr\n                << \"SASL username '\" << username << \"' was supplied, but binary was not built with SASL support.\\n\";\n          }\n          return false;\n#else\n        if (memc) {\n          if (MEMCACHED_SUCCESS\n              != memcached_set_sasl_auth_data(memc, username, opt.argof(\"password\"))) {\n            if (!opt.isset(\"quiet\")) {\n              std::cerr << memcached_last_error_message(memc);\n            }\n            return false;\n          }\n        }\n#endif\n      }\n      return true;\n    };\n\n    def(\"binary\", 'b', no_argument, \"Use the binary memcached protocol.\")\n        .apply = [](const client_options &opt, const extended_option &ext, memcached_st *memc) {\n      if (MEMCACHED_SUCCESS != memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_BINARY_PROTOCOL, ext.set)) {\n        if(!opt.isset(\"quiet\")) {\n          std::cerr << memcached_last_error_message(memc);\n        }\n        return false;\n      }\n      return true;\n    };\n    def(\"buffer\", 'B', no_argument, \"Buffer requests.\")\n        .apply = [](const client_options &opt, const extended_option &ext, memcached_st *memc) {\n      if (MEMCACHED_SUCCESS != memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_BUFFER_REQUESTS, ext.set)) {\n        if(!opt.isset(\"quiet\")) {\n          std::cerr << memcached_last_error_message(memc);\n        }\n        return false;\n      }\n      return true;\n    };\n    def(\"non-blocking\", 'n', no_argument, \"Use non-blocking connections.\")\n        .apply = [](const client_options &opt, const extended_option &ext, memcached_st *memc) {\n      if (MEMCACHED_SUCCESS != memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_NO_BLOCK, ext.set)) {\n        if(!opt.isset(\"quiet\")) {\n          std::cerr << memcached_last_error_message(memc);\n        }\n        return false;\n      }\n      return true;\n    };\n    def(\"tcp-nodelay\", 'N', no_argument, \"Disable Nagle's algorithm.\")\n        .apply = [](const client_options &opt, const extended_option &ext, memcached_st *memc) {\n      if (MEMCACHED_SUCCESS != memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_TCP_NODELAY, ext.set)) {\n        if(!opt.isset(\"quiet\")) {\n          std::cerr << memcached_last_error_message(memc);\n        }\n        return false;\n      }\n      return true;\n    };\n    def(\"servers\", 's', required_argument, \"List of servers to connect to.\")\n        .apply = [](const client_options &opt, const extended_option &ext, memcached_st *memc) {\n      auto servers = ext.arg;\n      if (!servers) {\n        if (opt.isset(\"verbose\")) {\n          std::cerr << \"Checking environment for a server list in MEMCACHED_SERVERS.\\n\";\n        }\n        servers = getenv(\"MEMCACHED_SERVERS\");\n        if (!servers || !*servers) {\n          if (!opt.isset(\"quiet\")) {\n            std::cerr << \"No servers provided.\\n\";\n          }\n          return false;\n        }\n      }\n\n      auto server_list = memcached_servers_parse(servers);\n      if (!server_list || !memcached_server_list_count(server_list)) {\n        if (!opt.isset(\"quiet\")) {\n          std::cerr << \"Invalid server list provided: '\" << servers << \"'\\n\";\n        }\n        if (server_list) {\n          memcached_server_list_free(server_list);\n        }\n        return false;\n      }\n\n      if (MEMCACHED_SUCCESS != memcached_server_push(memc, server_list)) {\n        if (!opt.isset(\"quiet\")) {\n          std::cerr << memcached_last_error_message(memc);\n        }\n        memcached_server_list_free(server_list);\n        return false;\n      }\n      memcached_server_list_free(server_list);\n      return true;\n    };\n    def(\"hash\", 'H', required_argument, \"Key hashing method.\")\n        .apply = [](const client_options &opt, const extended_option &ext, memcached_st *memc) {\n      if (ext.set) {\n        std::string hash_wanted{ext.arg};\n        memcached_hash_t hash = MEMCACHED_HASH_DEFAULT;\n\n        std::transform(hash_wanted.begin(), hash_wanted.end(), hash_wanted.begin(), ::toupper);\n\n        if (opt.isset(\"verbose\")) {\n          std::cerr << \"Checking for hash '\" << hash_wanted << \"'.\\n\";\n        }\n        for (int h = MEMCACHED_HASH_DEFAULT; h < MEMCACHED_HASH_MAX; ++h) {\n          auto hash_type = static_cast<memcached_hash_t>(h);\n          std::string hash_string{libmemcached_string_hash(hash_type)};\n\n          if (hash_wanted.length() == hash_string.length()) {\n            auto ci = std::equal(hash_string.begin(), hash_string.end(), hash_wanted.begin(),\n                                 [](int a, int b) { return ::toupper(a) == b; });\n            if (ci) {\n              hash = hash_type;\n              break;\n            }\n          }\n        }\n        if (hash == MEMCACHED_HASH_DEFAULT) {\n          if (!opt.isset(\"quiet\")) {\n            std::cerr << \"Could not find hash '\" << hash_wanted << \"'.\\n\";\n          }\n        }\n        if (MEMCACHED_SUCCESS != memcached_behavior_set_key_hash(memc, hash)) {\n          if (!opt.isset(\"quiet\")) {\n            std::cerr << memcached_last_error_message(memc);\n          }\n          return false;\n        }\n      }\n      return true;\n    };\n  }",
    "includes": [
      "#include \"p9y/getopt.hpp\"",
      "#include \"libmemcached/common.h\"",
      "#include <vector>",
      "#include <string>",
      "#include <iostream>",
      "#include <functional>",
      "#include <climits>",
      "#include <cstdint>",
      "#include <algorithm>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_last_error_message",
          "args": [
            "memc"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.isset",
          "args": [
            "\"quiet\""
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "isset",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "289-291",
          "snippet": "bool isset(int c) const {\n    return has(c) && get(c).set;\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool isset(int c) const {\n      return has(c) && get(c).set;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_behavior_set_key_hash",
          "args": [
            "memc",
            "hash"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_behavior_set_key_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "533-545",
          "snippet": "memcached_return_t memcached_behavior_set_key_hash(memcached_st *shell, memcached_hash_t type) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    if (hashkit_success(hashkit_set_function(&ptr->hashkit, (hashkit_hash_algorithm_t) type))) {\n      return MEMCACHED_SUCCESS;\n    }\n\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Invalid memcached_hash_t()\"));\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_behavior_set_key_hash(memcached_st *shell, memcached_hash_t type) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    if (hashkit_success(hashkit_set_function(&ptr->hashkit, (hashkit_hash_algorithm_t) type))) {\n      return MEMCACHED_SUCCESS;\n    }\n\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Invalid memcached_hash_t()\"));\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::equal",
          "args": [
            "hash_string.begin()",
            "hash_string.end()",
            "hash_wanted.begin()",
            "[](int a, int b) { return ::toupper(a) == b; }"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::toupper",
          "args": [
            "a"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_wanted.begin",
          "args": [],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_string.end",
          "args": [],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Context",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/csl/context.h",
          "lines": "44-46",
          "snippet": "bool end() {\n    return _end;\n  }",
          "includes": [
            "#include \"libmemcached/csl/parser.h\"",
            "#include \"libmemcached/csl/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/csl/parser.h\"\n#include \"libmemcached/csl/common.h\"\n\nContext {\n  bool end() {\n      return _end;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_string.begin",
          "args": [],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_string.length",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_wanted.length",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libmemcached_string_hash",
          "args": [
            "hash_type"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<memcached_hash_t>",
          "args": [
            "h"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::transform",
          "args": [
            "hash_wanted.begin()",
            "hash_wanted.end()",
            "hash_wanted.begin()",
            "::toupper"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_wanted.begin",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_wanted.begin",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "def",
          "args": [
            "\"hash\"",
            "'H'",
            "required_argument",
            "\"Key hashing method.\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_list_free",
          "args": [
            "server_list"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_list_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "98-109",
          "snippet": "void memcached_server_list_free(memcached_server_list_st self) {\n  if (self) {\n    for (uint32_t x = 0; x < memcached_server_list_count(self); x++) {\n      assert_msg(not memcached_is_allocated(&self[x]),\n                 \"You have called memcached_server_list_free(), but you did not pass it a valid \"\n                 \"memcached_server_list_st\");\n      server_free(&self[x]);\n    }\n\n    libmemcached_free(self->root, self);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_server_list_free(memcached_server_list_st self) {\n  if (self) {\n    for (uint32_t x = 0; x < memcached_server_list_count(self); x++) {\n      assert_msg(not memcached_is_allocated(&self[x]),\n                 \"You have called memcached_server_list_free(), but you did not pass it a valid \"\n                 \"memcached_server_list_st\");\n      server_free(&self[x]);\n    }\n\n    libmemcached_free(self->root, self);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_last_error_message",
          "args": [
            "memc"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_push",
          "args": [
            "memc",
            "server_list"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "327-373",
          "snippet": "memcached_return_t memcached_server_push(memcached_st *shell, const memcached_server_list_st list) {\n  if (list == NULL) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    uint32_t original_host_size = memcached_server_count(ptr);\n    uint32_t count = memcached_server_list_count(list);\n    uint32_t host_list_size = count + original_host_size;\n\n    memcached_instance_st *new_host_list = libmemcached_xrealloc(\n        ptr, memcached_instance_list(ptr), host_list_size, memcached_instance_st);\n\n    if (new_host_list == NULL) {\n      return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n    }\n\n    memcached_instance_set(ptr, new_host_list, host_list_size);\n\n    ptr->state.is_parsing = true;\n    for (uint32_t x = 0; x < count; ++x, ++original_host_size) {\n      WATCHPOINT_ASSERT(list[x].hostname[0]);\n\n      // We have extended the array, and now we will find it, and use it.\n      memcached_instance_st *instance = memcached_instance_fetch(ptr, original_host_size);\n      WATCHPOINT_ASSERT(instance);\n\n      memcached_string_t hostname = {memcached_string_make_from_cstr(list[x].hostname)};\n      if (instance_create_with(ptr, instance, hostname, list[x].port, list[x].weight, list[x].type)\n          == NULL)\n      {\n        ptr->state.is_parsing = false;\n        return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n      }\n\n      if (list[x].weight > 1) {\n        memcached_set_weighted_ketama(ptr, true);\n      }\n    }\n    ptr->state.is_parsing = false;\n\n    return run_distribution(ptr);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t update_continuum(Memcached *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t memcached_server_push(memcached_st *shell, const memcached_server_list_st list) {\n  if (list == NULL) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    uint32_t original_host_size = memcached_server_count(ptr);\n    uint32_t count = memcached_server_list_count(list);\n    uint32_t host_list_size = count + original_host_size;\n\n    memcached_instance_st *new_host_list = libmemcached_xrealloc(\n        ptr, memcached_instance_list(ptr), host_list_size, memcached_instance_st);\n\n    if (new_host_list == NULL) {\n      return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n    }\n\n    memcached_instance_set(ptr, new_host_list, host_list_size);\n\n    ptr->state.is_parsing = true;\n    for (uint32_t x = 0; x < count; ++x, ++original_host_size) {\n      WATCHPOINT_ASSERT(list[x].hostname[0]);\n\n      // We have extended the array, and now we will find it, and use it.\n      memcached_instance_st *instance = memcached_instance_fetch(ptr, original_host_size);\n      WATCHPOINT_ASSERT(instance);\n\n      memcached_string_t hostname = {memcached_string_make_from_cstr(list[x].hostname)};\n      if (instance_create_with(ptr, instance, hostname, list[x].port, list[x].weight, list[x].type)\n          == NULL)\n      {\n        ptr->state.is_parsing = false;\n        return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n      }\n\n      if (list[x].weight > 1) {\n        memcached_set_weighted_ketama(ptr, true);\n      }\n    }\n    ptr->state.is_parsing = false;\n\n    return run_distribution(ptr);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_list_count",
          "args": [
            "server_list"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_list_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "83-85",
          "snippet": "uint32_t memcached_server_list_count(const memcached_server_list_st self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_list_count(const memcached_server_list_st self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_servers_parse",
          "args": [
            "servers"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_servers_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/parse.cc",
          "lines": "18-94",
          "snippet": "memcached_server_list_st memcached_servers_parse(const char *server_strings) {\n  char *string;\n  const char *begin_ptr;\n  const char *end_ptr;\n  memcached_server_st *servers = NULL;\n  memcached_return_t rc;\n\n  WATCHPOINT_ASSERT(server_strings);\n\n  end_ptr = server_strings + strlen(server_strings);\n\n  for (begin_ptr = server_strings, string = (char *) strchr(server_strings, ',');\n       begin_ptr != end_ptr; string = (char *) strchr(begin_ptr, ','))\n  {\n    char buffer[HUGE_STRING_LEN];\n    char *ptr, *ptr2 = NULL;\n    uint32_t weight = 0;\n\n    if (string) {\n      memcpy(buffer, begin_ptr, (size_t)(string - begin_ptr));\n      buffer[(unsigned int) (string - begin_ptr)] = 0;\n      begin_ptr = string + 1;\n    } else {\n      size_t length = strlen(begin_ptr);\n      memcpy(buffer, begin_ptr, length);\n      buffer[length] = 0;\n      begin_ptr = end_ptr;\n    }\n\n    ptr = strchr(buffer, '[');\n    if (ptr) {\n      ptr2 = strchr(ptr+1, ']');\n    }\n    if (ptr && ptr2) {\n      // [IPv6]:port\n      ptr = strchr(ptr2+1, ':');\n    } else {\n      // IPv4:port or name:port\n      ptr = strchr(buffer, ':');\n    }\n    in_port_t port = 0;\n    if (ptr) {\n      ptr[0] = 0;\n\n      ptr++;\n\n      errno = 0;\n      port = (in_port_t) strtoul(ptr, (char **) NULL, 10);\n      if (errno) {\n        memcached_server_free(servers);\n        return NULL;\n      }\n\n      ptr2 = strchr(ptr, ' ');\n      if (!ptr2)\n        ptr2 = strchr(ptr, ':');\n\n      if (ptr2) {\n        ptr2++;\n        errno = 0;\n        weight = uint32_t(strtoul(ptr2, (char **) NULL, 10));\n        if (errno) {\n          memcached_server_free(servers);\n          return NULL;\n        }\n      }\n    }\n\n    servers = memcached_server_list_append_with_weight(servers, buffer, port, weight, &rc);\n\n    if (isspace(*begin_ptr)) {\n      begin_ptr++;\n    }\n  }\n\n  return servers;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_server_list_st memcached_servers_parse(const char *server_strings) {\n  char *string;\n  const char *begin_ptr;\n  const char *end_ptr;\n  memcached_server_st *servers = NULL;\n  memcached_return_t rc;\n\n  WATCHPOINT_ASSERT(server_strings);\n\n  end_ptr = server_strings + strlen(server_strings);\n\n  for (begin_ptr = server_strings, string = (char *) strchr(server_strings, ',');\n       begin_ptr != end_ptr; string = (char *) strchr(begin_ptr, ','))\n  {\n    char buffer[HUGE_STRING_LEN];\n    char *ptr, *ptr2 = NULL;\n    uint32_t weight = 0;\n\n    if (string) {\n      memcpy(buffer, begin_ptr, (size_t)(string - begin_ptr));\n      buffer[(unsigned int) (string - begin_ptr)] = 0;\n      begin_ptr = string + 1;\n    } else {\n      size_t length = strlen(begin_ptr);\n      memcpy(buffer, begin_ptr, length);\n      buffer[length] = 0;\n      begin_ptr = end_ptr;\n    }\n\n    ptr = strchr(buffer, '[');\n    if (ptr) {\n      ptr2 = strchr(ptr+1, ']');\n    }\n    if (ptr && ptr2) {\n      // [IPv6]:port\n      ptr = strchr(ptr2+1, ':');\n    } else {\n      // IPv4:port or name:port\n      ptr = strchr(buffer, ':');\n    }\n    in_port_t port = 0;\n    if (ptr) {\n      ptr[0] = 0;\n\n      ptr++;\n\n      errno = 0;\n      port = (in_port_t) strtoul(ptr, (char **) NULL, 10);\n      if (errno) {\n        memcached_server_free(servers);\n        return NULL;\n      }\n\n      ptr2 = strchr(ptr, ' ');\n      if (!ptr2)\n        ptr2 = strchr(ptr, ':');\n\n      if (ptr2) {\n        ptr2++;\n        errno = 0;\n        weight = uint32_t(strtoul(ptr2, (char **) NULL, 10));\n        if (errno) {\n          memcached_server_free(servers);\n          return NULL;\n        }\n      }\n    }\n\n    servers = memcached_server_list_append_with_weight(servers, buffer, port, weight, &rc);\n\n    if (isspace(*begin_ptr)) {\n      begin_ptr++;\n    }\n  }\n\n  return servers;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"MEMCACHED_SERVERS\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "def",
          "args": [
            "\"servers\"",
            "'s'",
            "required_argument",
            "\"List of servers to connect to.\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error_message",
          "args": [
            "memc"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_behavior_set",
          "args": [
            "memc",
            "MEMCACHED_BEHAVIOR_TCP_NODELAY",
            "ext.set"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_behavior_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "48-282",
          "snippet": "memcached_return_t memcached_behavior_set(memcached_st *shell, const memcached_behavior_t flag,\n                                          uint64_t data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    ptr->number_of_replicas = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    ptr->io_msg_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    ptr->io_bytes_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    ptr->io_key_prefetch = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    ptr->snd_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    ptr->rcv_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    if (data == 0) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT requires a value greater then zero.\"));\n    }\n    ptr->server_failure_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    ptr->server_timeout_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    if (data) {\n      ptr->flags.verify_key = false;\n    }\n    ptr->flags.binary_protocol = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    ptr->flags.support_cas = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    ptr->flags.no_block = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    if (memcached_is_udp(ptr)) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS cannot be set while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    ptr->flags.buffer_requests = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    ptr->flags.use_udp = bool(data);\n    if (bool(data)) {\n      ptr->flags.reply = false;\n      ptr->flags.buffer_requests = false;\n    } else {\n      ptr->flags.reply = true;\n    }\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    ptr->flags.tcp_nodelay = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    ptr->flags.tcp_keepalive = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return memcached_behavior_set_distribution(ptr, (memcached_server_distribution_t) data);\n\n  case MEMCACHED_BEHAVIOR_KETAMA: {\n    if (data) // Turn on\n    {\n      return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    }\n\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_MODULA);\n  }\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED: {\n    if (bool(data) == false) {\n      return memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_KETAMA, true);\n    }\n\n    (void) memcached_behavior_set_key_hash(ptr, MEMCACHED_HASH_MD5);\n    (void) memcached_behavior_set_distribution_hash(ptr, MEMCACHED_HASH_MD5);\n    /**\n      @note We try to keep the same distribution going. This should be deprecated and rewritten.\n    */\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED);\n  }\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return memcached_behavior_set_key_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return memcached_behavior_set_distribution_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS has been deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    if (ptr->flags.binary_protocol) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_VERIFY_KEY if the binary protocol has been enabled.\"));\n    }\n    ptr->flags.verify_key = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS: {\n    ptr->flags.use_sort_hosts = bool(data);\n    return run_distribution(ptr);\n  }\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    ptr->poll_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    ptr->connect_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    ptr->retry_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    ptr->dead_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE:\n    ptr->send_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE:\n    ptr->recv_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    ptr->tcp_keepidle = (uint32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    return memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                               memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    ptr->flags.hash_with_namespace = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    if (memcached_is_udp(ptr) and bool(data) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_NOREPLY cannot be disabled while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    // We reverse the logic here to make it easier to understand throughout the\n    // code.\n    ptr->flags.reply = bool(data) ? false : true;\n    break;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    srandom((uint32_t) time(NULL));\n    ptr->flags.randomize_replica_read = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_CORK is now incorporated into the driver by default.\"));\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_LOAD_FROM_FILE can not be set with memcached_behavior_set()\"));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    /* Shouldn't get here */\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_set()\");\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid behavior passed to memcached_behavior_set()\"));\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_behavior_set(memcached_st *shell, const memcached_behavior_t flag,\n                                          uint64_t data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    ptr->number_of_replicas = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    ptr->io_msg_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    ptr->io_bytes_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    ptr->io_key_prefetch = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    ptr->snd_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    ptr->rcv_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    if (data == 0) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT requires a value greater then zero.\"));\n    }\n    ptr->server_failure_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    ptr->server_timeout_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    if (data) {\n      ptr->flags.verify_key = false;\n    }\n    ptr->flags.binary_protocol = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    ptr->flags.support_cas = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    ptr->flags.no_block = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    if (memcached_is_udp(ptr)) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS cannot be set while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    ptr->flags.buffer_requests = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    ptr->flags.use_udp = bool(data);\n    if (bool(data)) {\n      ptr->flags.reply = false;\n      ptr->flags.buffer_requests = false;\n    } else {\n      ptr->flags.reply = true;\n    }\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    ptr->flags.tcp_nodelay = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    ptr->flags.tcp_keepalive = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return memcached_behavior_set_distribution(ptr, (memcached_server_distribution_t) data);\n\n  case MEMCACHED_BEHAVIOR_KETAMA: {\n    if (data) // Turn on\n    {\n      return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    }\n\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_MODULA);\n  }\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED: {\n    if (bool(data) == false) {\n      return memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_KETAMA, true);\n    }\n\n    (void) memcached_behavior_set_key_hash(ptr, MEMCACHED_HASH_MD5);\n    (void) memcached_behavior_set_distribution_hash(ptr, MEMCACHED_HASH_MD5);\n    /**\n      @note We try to keep the same distribution going. This should be deprecated and rewritten.\n    */\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED);\n  }\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return memcached_behavior_set_key_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return memcached_behavior_set_distribution_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS has been deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    if (ptr->flags.binary_protocol) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_VERIFY_KEY if the binary protocol has been enabled.\"));\n    }\n    ptr->flags.verify_key = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS: {\n    ptr->flags.use_sort_hosts = bool(data);\n    return run_distribution(ptr);\n  }\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    ptr->poll_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    ptr->connect_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    ptr->retry_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    ptr->dead_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE:\n    ptr->send_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE:\n    ptr->recv_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    ptr->tcp_keepidle = (uint32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    return memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                               memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    ptr->flags.hash_with_namespace = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    if (memcached_is_udp(ptr) and bool(data) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_NOREPLY cannot be disabled while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    // We reverse the logic here to make it easier to understand throughout the\n    // code.\n    ptr->flags.reply = bool(data) ? false : true;\n    break;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    srandom((uint32_t) time(NULL));\n    ptr->flags.randomize_replica_read = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_CORK is now incorporated into the driver by default.\"));\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_LOAD_FROM_FILE can not be set with memcached_behavior_set()\"));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    /* Shouldn't get here */\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_set()\");\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid behavior passed to memcached_behavior_set()\"));\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "def",
          "args": [
            "\"tcp-nodelay\"",
            "'N'",
            "no_argument",
            "\"Disable Nagle's algorithm.\""
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error_message",
          "args": [
            "memc"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "def",
          "args": [
            "\"non-blocking\"",
            "'n'",
            "no_argument",
            "\"Use non-blocking connections.\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error_message",
          "args": [
            "memc"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "def",
          "args": [
            "\"buffer\"",
            "'B'",
            "no_argument",
            "\"Buffer requests.\""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error_message",
          "args": [
            "memc"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "def",
          "args": [
            "\"binary\"",
            "'b'",
            "no_argument",
            "\"Use the binary memcached protocol.\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error_message",
          "args": [
            "memc"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_sasl_auth_data",
          "args": [
            "memc",
            "username",
            "opt.argof(\"password\")"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_sasl_auth_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
          "lines": "466-468",
          "snippet": "memcached_return_t memcached_set_sasl_auth_data(memcached_st *, const char *, const char *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}",
          "includes": [
            "#  include <pthread.h>",
            "#    include <sasl/sasl.h>",
            "#include <atomic>",
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_sasl_auth_data(memcached_st *, const char *, const char *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "opt.argof",
          "args": [
            "\"password\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "def",
          "args": [
            "\"username\"",
            "'u'",
            "required_argument",
            "\"SASL username.\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "def",
          "args": [
            "\"password\"",
            "'p'",
            "required_argument",
            "\"SASL password.\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.unset",
          "args": [
            "\"debug\""
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "unset",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "296-298",
          "snippet": "void unset(int c) {\n    set(c, false);\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  void unset(int c) {\n      set(c, false);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "def",
          "args": [
            "\"quiet\"",
            "'q'",
            "no_argument",
            "\"Print no output, not even errors.\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.set",
          "args": [
            "\"verbose\""
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "307-313",
          "snippet": "void set(int c, bool set_ = true, char *optarg_ = nullptr) {\n    if (has(c)) {\n      auto &opt = get(c);\n      opt.set = set_;\n      opt.arg = optarg_;\n    }\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  void set(int c, bool set_ = true, char *optarg_ = nullptr) {\n      if (has(c)) {\n        auto &opt = get(c);\n        opt.set = set_;\n        opt.arg = optarg_;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "def",
          "args": [
            "\"debug\"",
            "'d'",
            "no_argument",
            "\"Print output useful only for debugging.\""
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "def",
          "args": [
            "\"verbose\"",
            "'v'",
            "no_argument",
            "\"Print more informational output.\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.print_version",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "print_version",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.cpp",
          "lines": "18-21",
          "snippet": "void client_options::print_version() const {\n  std::cout << prog_name << \" v\" << prog_vers << \" (libmemcached v\" << LIBMEMCACHED_VERSION_STRING << \")\"\n            << std::endl;\n}",
          "includes": [
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"options.hpp\"\n\nclient_options {\n  void client_options::print_version() const {\n    std::cout << prog_name << \" v\" << prog_vers << \" (libmemcached v\" << LIBMEMCACHED_VERSION_STRING << \")\"\n              << std::endl;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "def",
          "args": [
            "\"version\"",
            "'V'",
            "no_argument",
            "\"Print program version.\""
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.print_help",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "print_help",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.cpp",
          "lines": "23-86",
          "snippet": "void client_options::print_help() const {\n  print_version();\n  std::cout << \"\\n\\t\" << prog_desc << \"\\n\\n\";\n  std::cout << \"Usage:\\n\\t\" << prog_name << \" -[\";\n  for (const auto &opt : options) {\n    if (!opt.opt.has_arg && opt.opt.val != '-') {\n      std::cout << (char) opt.opt.val;\n    }\n  }\n  std::cout << \"] [-\";\n  for (const auto &ext : options) {\n    if (ext.opt.has_arg) {\n      std::cout << (char) ext.opt.val;\n      if ((&ext) != &*options.rbegin())\n        std::cout << '|';\n    }\n  }\n  std::cout << \" <arg>] \";\n\n  if (prog_argp) {\n    std::cout << prog_argp;\n  }\n  std::cout << \"\\n\\nOptions:\\n\";\n  for (const auto &ext : options) {\n    if (ext.opt.val == '-' || !(ext.opt.val || ext.opt.name)) {\n      continue;\n    }\n    std::cout << \"\\t\";\n    if (ext.opt.val) {\n      std::cout << \"-\" << (char) ext.opt.val;\n      if (ext.opt.name) {\n        std::cout << \"|\";\n      }\n    } else {\n      std::cout << \"   \";\n    }\n    if (ext.opt.name) {\n      std::cout << \"--\" << ext.opt.name << \" \";\n    } else {\n      std::cout << \" \";\n    }\n    if (ext.opt.has_arg) {\n      if (ext.opt.has_arg == optional_argument) {\n        std::cout << \"[\";\n      } else {\n        std::cout << \"<\";\n      }\n      std::cout << \"arg\";\n      if (ext.opt.has_arg == optional_argument) {\n        std::cout << \"]\";\n      } else {\n        std::cout << \">\";\n      }\n    }\n    std::cout << \"\\n\\t\\t\" << ext.help << \"\\n\";\n  }\n\n  if (has(\"servers\")) {\n    std::cout << \"\\nEnvironment:\\n\";\n    std::cout << \"\\tMEMCACHED_SERVERS=\\n\";\n    std::cout << \"\\t\\tList of servers to use if `-s|--servers` was not provided.\\n\";\n  }\n  std::cout << std::endl;\n}",
          "includes": [
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"options.hpp\"\n\nclient_options {\n  void client_options::print_help() const {\n    print_version();\n    std::cout << \"\\n\\t\" << prog_desc << \"\\n\\n\";\n    std::cout << \"Usage:\\n\\t\" << prog_name << \" -[\";\n    for (const auto &opt : options) {\n      if (!opt.opt.has_arg && opt.opt.val != '-') {\n        std::cout << (char) opt.opt.val;\n      }\n    }\n    std::cout << \"] [-\";\n    for (const auto &ext : options) {\n      if (ext.opt.has_arg) {\n        std::cout << (char) ext.opt.val;\n        if ((&ext) != &*options.rbegin())\n          std::cout << '|';\n      }\n    }\n    std::cout << \" <arg>] \";\n  \n    if (prog_argp) {\n      std::cout << prog_argp;\n    }\n    std::cout << \"\\n\\nOptions:\\n\";\n    for (const auto &ext : options) {\n      if (ext.opt.val == '-' || !(ext.opt.val || ext.opt.name)) {\n        continue;\n      }\n      std::cout << \"\\t\";\n      if (ext.opt.val) {\n        std::cout << \"-\" << (char) ext.opt.val;\n        if (ext.opt.name) {\n          std::cout << \"|\";\n        }\n      } else {\n        std::cout << \"   \";\n      }\n      if (ext.opt.name) {\n        std::cout << \"--\" << ext.opt.name << \" \";\n      } else {\n        std::cout << \" \";\n      }\n      if (ext.opt.has_arg) {\n        if (ext.opt.has_arg == optional_argument) {\n          std::cout << \"[\";\n        } else {\n          std::cout << \"<\";\n        }\n        std::cout << \"arg\";\n        if (ext.opt.has_arg == optional_argument) {\n          std::cout << \"]\";\n        } else {\n          std::cout << \">\";\n        }\n      }\n      std::cout << \"\\n\\t\\t\" << ext.help << \"\\n\";\n    }\n  \n    if (has(\"servers\")) {\n      std::cout << \"\\nEnvironment:\\n\";\n      std::cout << \"\\tMEMCACHED_SERVERS=\\n\";\n      std::cout << \"\\t\\tList of servers to use if `-s|--servers` was not provided.\\n\";\n    }\n    std::cout << std::endl;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "def",
          "args": [
            "\"help\"",
            "'h'",
            "no_argument",
            "\"Print this help.\""
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  client_options(const char *prg, const char *ver, const char *dsc, const char *arg = nullptr)\n    : options{}\n    , defaults{}\n    , prog_name{prg}\n    , prog_vers{ver}\n    , prog_desc{dsc}\n    , prog_argp{arg}\n    {\n  \n      def(\"help\", 'h', no_argument, \"Print this help.\")\n          .apply = [](const client_options &opt, const extended_option &ext, memcached_st *) {\n        if (ext.set) {\n          opt.print_help();\n          exit(EXIT_SUCCESS);\n        }\n        return true;\n      };\n      def(\"version\", 'V', no_argument, \"Print program version.\")\n          .apply = [](const client_options &opt, const extended_option &ext, memcached_st *) {\n        if (ext.set) {\n          opt.print_version();\n          exit(EXIT_SUCCESS);\n        }\n        return true;\n      };\n  \n      def(\"verbose\", 'v', no_argument, \"Print more informational output.\")\n          .parse = [](client_options &opt, extended_option &) {\n        opt.unset(\"quiet\");\n        return true;\n      };\n      def(\"debug\", 'd', no_argument, \"Print output useful only for debugging.\")\n          .parse = [](client_options &opt, extended_option &) {\n        opt.set(\"verbose\");\n        opt.unset(\"quiet\");\n        return true;\n      };\n      def(\"quiet\", 'q', no_argument, \"Print no output, not even errors.\")\n          .parse = [](client_options &opt, extended_option &) {\n        opt.unset(\"verbose\");\n        opt.unset(\"debug\");\n        return true;\n      };\n  \n      def(\"password\", 'p', required_argument, \"SASL password.\");\n      def(\"username\", 'u', required_argument, \"SASL username.\")\n          .apply = [](const client_options &opt, const extended_option &ext, memcached_st *memc) {\n        if (auto username = ext.arg) {\n  #if !LIBMEMCACHED_WITH_SASL_SUPPORT\n            (void) memc;\n            if (!opt.isset(\"quiet\")) {\n              std::cerr\n                  << \"SASL username '\" << username << \"' was supplied, but binary was not built with SASL support.\\n\";\n            }\n            return false;\n  #else\n          if (memc) {\n            if (MEMCACHED_SUCCESS\n                != memcached_set_sasl_auth_data(memc, username, opt.argof(\"password\"))) {\n              if (!opt.isset(\"quiet\")) {\n                std::cerr << memcached_last_error_message(memc);\n              }\n              return false;\n            }\n          }\n  #endif\n        }\n        return true;\n      };\n  \n      def(\"binary\", 'b', no_argument, \"Use the binary memcached protocol.\")\n          .apply = [](const client_options &opt, const extended_option &ext, memcached_st *memc) {\n        if (MEMCACHED_SUCCESS != memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_BINARY_PROTOCOL, ext.set)) {\n          if(!opt.isset(\"quiet\")) {\n            std::cerr << memcached_last_error_message(memc);\n          }\n          return false;\n        }\n        return true;\n      };\n      def(\"buffer\", 'B', no_argument, \"Buffer requests.\")\n          .apply = [](const client_options &opt, const extended_option &ext, memcached_st *memc) {\n        if (MEMCACHED_SUCCESS != memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_BUFFER_REQUESTS, ext.set)) {\n          if(!opt.isset(\"quiet\")) {\n            std::cerr << memcached_last_error_message(memc);\n          }\n          return false;\n        }\n        return true;\n      };\n      def(\"non-blocking\", 'n', no_argument, \"Use non-blocking connections.\")\n          .apply = [](const client_options &opt, const extended_option &ext, memcached_st *memc) {\n        if (MEMCACHED_SUCCESS != memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_NO_BLOCK, ext.set)) {\n          if(!opt.isset(\"quiet\")) {\n            std::cerr << memcached_last_error_message(memc);\n          }\n          return false;\n        }\n        return true;\n      };\n      def(\"tcp-nodelay\", 'N', no_argument, \"Disable Nagle's algorithm.\")\n          .apply = [](const client_options &opt, const extended_option &ext, memcached_st *memc) {\n        if (MEMCACHED_SUCCESS != memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_TCP_NODELAY, ext.set)) {\n          if(!opt.isset(\"quiet\")) {\n            std::cerr << memcached_last_error_message(memc);\n          }\n          return false;\n        }\n        return true;\n      };\n      def(\"servers\", 's', required_argument, \"List of servers to connect to.\")\n          .apply = [](const client_options &opt, const extended_option &ext, memcached_st *memc) {\n        auto servers = ext.arg;\n        if (!servers) {\n          if (opt.isset(\"verbose\")) {\n            std::cerr << \"Checking environment for a server list in MEMCACHED_SERVERS.\\n\";\n          }\n          servers = getenv(\"MEMCACHED_SERVERS\");\n          if (!servers || !*servers) {\n            if (!opt.isset(\"quiet\")) {\n              std::cerr << \"No servers provided.\\n\";\n            }\n            return false;\n          }\n        }\n  \n        auto server_list = memcached_servers_parse(servers);\n        if (!server_list || !memcached_server_list_count(server_list)) {\n          if (!opt.isset(\"quiet\")) {\n            std::cerr << \"Invalid server list provided: '\" << servers << \"'\\n\";\n          }\n          if (server_list) {\n            memcached_server_list_free(server_list);\n          }\n          return false;\n        }\n  \n        if (MEMCACHED_SUCCESS != memcached_server_push(memc, server_list)) {\n          if (!opt.isset(\"quiet\")) {\n            std::cerr << memcached_last_error_message(memc);\n          }\n          memcached_server_list_free(server_list);\n          return false;\n        }\n        memcached_server_list_free(server_list);\n        return true;\n      };\n      def(\"hash\", 'H', required_argument, \"Key hashing method.\")\n          .apply = [](const client_options &opt, const extended_option &ext, memcached_st *memc) {\n        if (ext.set) {\n          std::string hash_wanted{ext.arg};\n          memcached_hash_t hash = MEMCACHED_HASH_DEFAULT;\n  \n          std::transform(hash_wanted.begin(), hash_wanted.end(), hash_wanted.begin(), ::toupper);\n  \n          if (opt.isset(\"verbose\")) {\n            std::cerr << \"Checking for hash '\" << hash_wanted << \"'.\\n\";\n          }\n          for (int h = MEMCACHED_HASH_DEFAULT; h < MEMCACHED_HASH_MAX; ++h) {\n            auto hash_type = static_cast<memcached_hash_t>(h);\n            std::string hash_string{libmemcached_string_hash(hash_type)};\n  \n            if (hash_wanted.length() == hash_string.length()) {\n              auto ci = std::equal(hash_string.begin(), hash_string.end(), hash_wanted.begin(),\n                                   [](int a, int b) { return ::toupper(a) == b; });\n              if (ci) {\n                hash = hash_type;\n                break;\n              }\n            }\n          }\n          if (hash == MEMCACHED_HASH_DEFAULT) {\n            if (!opt.isset(\"quiet\")) {\n              std::cerr << \"Could not find hash '\" << hash_wanted << \"'.\\n\";\n            }\n          }\n          if (MEMCACHED_SUCCESS != memcached_behavior_set_key_hash(memc, hash)) {\n            if (!opt.isset(\"quiet\")) {\n              std::cerr << memcached_last_error_message(memc);\n            }\n            return false;\n          }\n        }\n        return true;\n      };\n    }\n}"
  }
]