[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memstat.cc",
    "lines": "208-294",
    "snippet": "int main(int argc, char *argv[]) {\n  client_options opt{PROGRAM_NAME, PROGRAM_VERSION, PROGRAM_DESCRIPTION, \"[stat ...]\"};\n\n  for (const auto &def : opt.defaults) {\n    if (def.opt.val != 'H') {\n      // no need for --hash\n      opt.add(def);\n    }\n  }\n\n  opt.add(\"args\", 'A', required_argument, \"Stat args. DEPRECATED: use positional arguments.\");\n  opt.add(\"server-version\", 'S', no_argument, \"Print server version.\");\n  opt.add(\"analyze\", 'a', optional_argument, \"Analyze server characteristics (options: default, latency).\");\n  opt.add(\"iterations\", 0, required_argument, \"Iteration count of GETs sent by the latency test (default: 1000).\");\n\n  char **argp = nullptr;\n  if (!opt.parse(argc, argv, &argp)) {\n    exit(EXIT_FAILURE);\n  }\n\n  memcached_st memc;\n  if (!check_memcached(opt, memc)) {\n    exit(EXIT_FAILURE);\n  }\n\n  if (!opt.apply(&memc)) {\n    memcached_free(&memc);\n    exit(EXIT_FAILURE);\n  }\n\n  auto exit_code = EXIT_SUCCESS;\n  if (opt.isset('S')) {\n    if (opt.isset(\"verbose\")) {\n      std::cout << \"Server versions:\\n\";\n    }\n    if (MEMCACHED_SUCCESS != memcached_version(&memc)) {\n      exit_code = EXIT_FAILURE;\n    }\n    memcached_server_fn cb[] = {&print_server_version};\n    memcached_server_cursor(&memc, cb, nullptr, 1);\n    goto done;\n  }\n\n  if (opt.isset(\"analyze\")) {\n    const char *analyze = opt.argof(\"analyze\");\n    if (analyze && strcmp(analyze, \"default\")) {\n      if (!strcmp(analyze, \"latency\")) {\n        if (!analyze_latency(opt, &memc)) {\n          exit_code = EXIT_FAILURE;\n        }\n        goto done;\n      }\n\n      if (!opt.isset(\"quiet\")) {\n        std::cerr << \"Unknown --analyze mode: '\" << analyze << \"'.\\n\";\n      }\n    }\n\n    memcached_return_t rc;\n    auto stat = memcached_stat(&memc, nullptr, &rc);\n    if (!memcached_success(rc)) {\n      exit_code = EXIT_FAILURE;\n      if (!opt.isset(\"quiet\")) {\n        std::cerr << memcached_last_error_message(&memc) << \"\\n\";\n      }\n    } else if (!analyze_stat(opt, &memc, stat)) {\n      exit_code = EXIT_FAILURE;\n    }\n    memcached_stat_free(&memc, stat);\n    goto done;\n  }\n\n  if (!*argp || opt.isset('A')) {\n    if (!memstat(opt, memc, opt.argof('A'))) {\n      exit_code = EXIT_FAILURE;\n    }\n  }\n  for (auto arg = argp; *arg; ++arg) {\n    if (!memstat(opt, memc, *arg)) {\n      exit_code = EXIT_FAILURE;\n    }\n  }\n\ndone:\n  memcached_free(&memc);\n  exit(exit_code);\n}",
    "includes": [
      "#include <iomanip>",
      "#include <cstdio>",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [
      "#define PROGRAM_VERSION     \"1.1\"",
      "#define PROGRAM_DESCRIPTION \"Print stats/version of or analyze a memcached cluster.\"",
      "#define PROGRAM_NAME        \"memstat\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "exit_code"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_free",
          "args": [
            "&memc"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
          "lines": "257-261",
          "snippet": "void memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memstat",
          "args": [
            "opt",
            "memc",
            "*arg"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "memstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memstat.cc",
          "lines": "191-206",
          "snippet": "static bool memstat(const client_options &opt, memcached_st &memc, const char *arg) {\n  memcached_instance_st *context = nullptr;\n  auto rc = memcached_stat_execute(&memc, arg, print_stat, &context);\n  if (memcached_success(rc)) {\n    return true;\n  }\n  if (!opt.isset(\"quiet\")) {\n    std::cerr << \"Failed to 'STAT \" << (arg ? arg : \"\") << \"': \";\n    if (memcached_last_error(&memc)) {\n      std::cerr << memcached_last_error_message(&memc) << \"\\n\";\n    } else {\n      std::cerr << memcached_strerror(&memc, rc) << \"\\n\";\n    }\n  }\n  return false;\n}",
          "includes": [
            "#include <iomanip>",
            "#include <cstdio>",
            "#include \"common/time.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <cstdio>\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic bool memstat(const client_options &opt, memcached_st &memc, const char *arg) {\n  memcached_instance_st *context = nullptr;\n  auto rc = memcached_stat_execute(&memc, arg, print_stat, &context);\n  if (memcached_success(rc)) {\n    return true;\n  }\n  if (!opt.isset(\"quiet\")) {\n    std::cerr << \"Failed to 'STAT \" << (arg ? arg : \"\") << \"': \";\n    if (memcached_last_error(&memc)) {\n      std::cerr << memcached_last_error_message(&memc) << \"\\n\";\n    } else {\n      std::cerr << memcached_strerror(&memc, rc) << \"\\n\";\n    }\n  }\n  return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "opt.argof",
          "args": [
            "'A'"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.isset",
          "args": [
            "'A'"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "isset",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "289-291",
          "snippet": "bool isset(int c) const {\n    return has(c) && get(c).set;\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool isset(int c) const {\n      return has(c) && get(c).set;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_stat_free",
          "args": [
            "&memc",
            "stat"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_stat_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/stats.cc",
          "lines": "594-599",
          "snippet": "void memcached_stat_free(const memcached_st *, memcached_stat_st *memc_stat) {\n  WATCHPOINT_ASSERT(memc_stat); // Be polite, but when debugging catch this as an error\n  if (memc_stat) {\n    libmemcached_free(memc_stat->root, memc_stat);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_stat_free(const memcached_st *, memcached_stat_st *memc_stat) {\n  WATCHPOINT_ASSERT(memc_stat); // Be polite, but when debugging catch this as an error\n  if (memc_stat) {\n    libmemcached_free(memc_stat->root, memc_stat);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "analyze_stat",
          "args": [
            "opt",
            "&memc",
            "stat"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "analyze_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memstat.cc",
          "lines": "72-85",
          "snippet": "static bool analyze_stat(const client_options &opt, memcached_st *memc, memcached_stat_st *stat) {\n  memcached_return_t rc;\n  auto report = memcached_analyze(memc, stat, &rc);\n\n  if (rc != MEMCACHED_SUCCESS || !report) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failure to analyze servers:\" << memcached_strerror(memc, rc) << \".\\n\";\n    }\n    return false;\n  }\n  print_report(memc, report);\n  free(report);\n  return true;\n}",
          "includes": [
            "#include <iomanip>",
            "#include <cstdio>",
            "#include \"common/time.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <cstdio>\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic bool analyze_stat(const client_options &opt, memcached_st *memc, memcached_stat_st *stat) {\n  memcached_return_t rc;\n  auto report = memcached_analyze(memc, stat, &rc);\n\n  if (rc != MEMCACHED_SUCCESS || !report) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failure to analyze servers:\" << memcached_strerror(memc, rc) << \".\\n\";\n    }\n    return false;\n  }\n  print_report(memc, report);\n  free(report);\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_last_error_message",
          "args": [
            "&memc"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_stat",
          "args": [
            "&memc",
            "nullptr",
            "&rc"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "analyze_latency",
          "args": [
            "opt",
            "&memc"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "analyze_latency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memstat.cc",
          "lines": "144-170",
          "snippet": "static bool analyze_latency(client_options &opt, memcached_st *root) {\n  uint32_t num_of_tests = DEFAULT_LATENCY_ITERATIONS;\n\n  if (auto iter_str = opt.argof(\"iterations\")) {\n    num_of_tests = std::stoul(iter_str);\n  }\n\n  std::vector<memcached_st> servers{memcached_server_count(root)};\n\n  uint32_t i = 0;\n  for (auto &memc : servers) {\n    memcached_clone(&memc, root);\n    memcached_servers_reset(&memc);\n    auto instance = memcached_server_instance_by_position(root, i++);\n    memcached_server_add(&memc, memcached_server_name(instance), memcached_server_port(instance));\n    //pre-connect\n    memcached_version(&memc);\n  }\n\n  latency_test(num_of_tests, servers);\n\n  for (auto &memc : servers) {\n    memcached_free(&memc);\n  }\n\n  return true;\n}",
          "includes": [
            "#include <iomanip>",
            "#include <cstdio>",
            "#include \"common/time.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [
            "#define DEFAULT_LATENCY_ITERATIONS 100 // update help string, if changed"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <cstdio>\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\n#define DEFAULT_LATENCY_ITERATIONS 100 // update help string, if changed\n\nstatic bool analyze_latency(client_options &opt, memcached_st *root) {\n  uint32_t num_of_tests = DEFAULT_LATENCY_ITERATIONS;\n\n  if (auto iter_str = opt.argof(\"iterations\")) {\n    num_of_tests = std::stoul(iter_str);\n  }\n\n  std::vector<memcached_st> servers{memcached_server_count(root)};\n\n  uint32_t i = 0;\n  for (auto &memc : servers) {\n    memcached_clone(&memc, root);\n    memcached_servers_reset(&memc);\n    auto instance = memcached_server_instance_by_position(root, i++);\n    memcached_server_add(&memc, memcached_server_name(instance), memcached_server_port(instance));\n    //pre-connect\n    memcached_version(&memc);\n  }\n\n  latency_test(num_of_tests, servers);\n\n  for (auto &memc : servers) {\n    memcached_free(&memc);\n  }\n\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "analyze",
            "\"latency\""
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "analyze",
            "\"default\""
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.argof",
          "args": [
            "\"analyze\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_cursor",
          "args": [
            "&memc",
            "cb",
            "nullptr",
            "1"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
          "lines": "147-171",
          "snippet": "memcached_return_t memcached_server_cursor(const memcached_st *shell,\n                                           const memcached_server_fn *callback, void *context,\n                                           uint32_t number_of_callbacks) {\n  const Memcached *memc = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_const_query(memc))) {\n    return rc;\n  }\n\n  size_t errors = 0;\n  for (uint32_t x = 0; x < memcached_instance_list_count(memc); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(memc, x);\n\n    for (uint32_t y = 0; y < number_of_callbacks; y++) {\n      memcached_return_t ret = (*callback[y])(memc, instance, context);\n\n      if (memcached_failed(ret)) {\n        errors++;\n        continue;\n      }\n    }\n  }\n\n  return errors ? MEMCACHED_SOME_ERRORS : MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_server_cursor(const memcached_st *shell,\n                                           const memcached_server_fn *callback, void *context,\n                                           uint32_t number_of_callbacks) {\n  const Memcached *memc = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_const_query(memc))) {\n    return rc;\n  }\n\n  size_t errors = 0;\n  for (uint32_t x = 0; x < memcached_instance_list_count(memc); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(memc, x);\n\n    for (uint32_t y = 0; y < number_of_callbacks; y++) {\n      memcached_return_t ret = (*callback[y])(memc, instance, context);\n\n      if (memcached_failed(ret)) {\n        errors++;\n        continue;\n      }\n    }\n  }\n\n  return errors ? MEMCACHED_SOME_ERRORS : MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_version",
          "args": [
            "&memc"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/version.cc",
          "lines": "164-184",
          "snippet": "memcached_return_t memcached_version(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    memcached_return_t rc;\n    if (memcached_failed(rc = initialize_query(memc, true))) {\n      return rc;\n    }\n\n    if (memcached_is_udp(memc)) {\n      return MEMCACHED_NOT_SUPPORTED;\n    }\n\n    if (memcached_is_binary(memc)) {\n      return memcached_version_binary(memc);\n    }\n\n    return memcached_version_textual(memc);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_version(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    memcached_return_t rc;\n    if (memcached_failed(rc = initialize_query(memc, true))) {\n      return rc;\n    }\n\n    if (memcached_is_udp(memc)) {\n      return MEMCACHED_NOT_SUPPORTED;\n    }\n\n    if (memcached_is_binary(memc)) {\n      return memcached_version_binary(memc);\n    }\n\n    return memcached_version_textual(memc);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.apply",
          "args": [
            "&memc"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "apply",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.cpp",
          "lines": "149-177",
          "snippet": "bool client_options::apply(memcached_st *memc) {\n#ifdef _WIN32\n  WSADATA wsaData;\n  if (WSAStartup(MAKEWORD(2, 2), &wsaData)) {\n    std::cerr << \"Socket Initialization Error.\\n\";\n    return false;\n  }\n#endif // _WIN32\n\n  extended_option *servers = nullptr;\n  for (auto &opt : options) {\n    if (opt.apply) {\n      // servers should be applied last, so they take up any behaviors previously set\n      if (opt.opt.val == 's' && opt.opt.name == std::string(\"servers\")) {\n        servers = &opt;\n        continue;\n      }\n      if (!opt.apply(*this, opt, memc)) {\n        return false;\n      }\n    }\n  }\n  if (servers) {\n    if (!servers->apply(*this, *servers, memc)) {\n      return false;\n    }\n  }\n  return true;\n}",
          "includes": [
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"options.hpp\"\n\nclient_options {\n  bool client_options::apply(memcached_st *memc) {\n  #ifdef _WIN32\n    WSADATA wsaData;\n    if (WSAStartup(MAKEWORD(2, 2), &wsaData)) {\n      std::cerr << \"Socket Initialization Error.\\n\";\n      return false;\n    }\n  #endif // _WIN32\n  \n    extended_option *servers = nullptr;\n    for (auto &opt : options) {\n      if (opt.apply) {\n        // servers should be applied last, so they take up any behaviors previously set\n        if (opt.opt.val == 's' && opt.opt.name == std::string(\"servers\")) {\n          servers = &opt;\n          continue;\n        }\n        if (!opt.apply(*this, opt, memc)) {\n          return false;\n        }\n      }\n    }\n    if (servers) {\n      if (!servers->apply(*this, *servers, memc)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_memcached",
          "args": [
            "opt",
            "memc"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "check_memcached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/checks.hpp",
          "lines": "47-55",
          "snippet": "bool check_memcached(const client_options &opt, memcached_st &memc) {\n  if (!memcached_create(&memc)) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failed to initialize memcached client.\\n\";\n    }\n    return false;\n  }\n  return true;\n}",
          "includes": [
            "#include <fstream>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include \"libmemcached/common.h\"",
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <cstring>\n#include <cerrno>\n#include \"libmemcached/common.h\"\n#include \"options.hpp\"\n\nbool check_memcached(const client_options &opt, memcached_st &memc) {\n  if (!memcached_create(&memc)) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failed to initialize memcached client.\\n\";\n    }\n    return false;\n  }\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.parse",
          "args": [
            "argc",
            "argv",
            "&argp"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.cpp",
          "lines": "88-147",
          "snippet": "bool client_options::parse(int argc, char **argv, char ***argp) {\n  /* extern */ optind = 1;\n  auto debug = has(\"debug\") ? &get(\"debug\") : nullptr;\n  std::string short_opts{};\n  std::vector<option> long_opts{};\n\n  short_opts.reserve(options.size() * 3);\n  long_opts.reserve(options.size() + 1);\n\n  for (const auto &ext : options) {\n    if (ext.opt.val) {\n      short_opts.push_back(ext.opt.val);\n      for (int i = 0; i < ext.opt.has_arg; ++i) {\n        short_opts.push_back(':');\n      }\n    }\n    if (ext.opt.name) {\n      long_opts.push_back(ext.opt);\n    }\n  }\n  long_opts.push_back({});\n\n  while (true) {\n    auto opt = getopt_long(argc, argv, short_opts.c_str(), long_opts.data(), nullptr);\n\n    if (debug->set && opt > 0) {\n      std::cerr << \"Processing option '\" << (char) opt << \"' (\" << opt << \")\\n\";\n    }\n    if (opt == '?') {\n      return false;\n    }\n    if (opt == -1) {\n      if (argp) {\n        *argp = &argv[optind];\n      }\n      return true;\n    }\n\n    auto &ext_opt = get(opt);\n\n    // grab optional argument\n    if (ext_opt.opt.has_arg == optional_argument && !optarg) {\n      auto next_arg = argv[optind];\n\n      if (next_arg && *next_arg && *next_arg != '-') {\n        optarg = next_arg;\n        ++optind;\n      }\n    }\n\n    ext_opt.set = true;\n    ext_opt.arg = optarg;\n\n    if (ext_opt.parse) {\n      if (!ext_opt.parse(*this, ext_opt)) {\n        return false;\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"options.hpp\"\n\nclient_options {\n  bool client_options::parse(int argc, char **argv, char ***argp) {\n    /* extern */ optind = 1;\n    auto debug = has(\"debug\") ? &get(\"debug\") : nullptr;\n    std::string short_opts{};\n    std::vector<option> long_opts{};\n  \n    short_opts.reserve(options.size() * 3);\n    long_opts.reserve(options.size() + 1);\n  \n    for (const auto &ext : options) {\n      if (ext.opt.val) {\n        short_opts.push_back(ext.opt.val);\n        for (int i = 0; i < ext.opt.has_arg; ++i) {\n          short_opts.push_back(':');\n        }\n      }\n      if (ext.opt.name) {\n        long_opts.push_back(ext.opt);\n      }\n    }\n    long_opts.push_back({});\n  \n    while (true) {\n      auto opt = getopt_long(argc, argv, short_opts.c_str(), long_opts.data(), nullptr);\n  \n      if (debug->set && opt > 0) {\n        std::cerr << \"Processing option '\" << (char) opt << \"' (\" << opt << \")\\n\";\n      }\n      if (opt == '?') {\n        return false;\n      }\n      if (opt == -1) {\n        if (argp) {\n          *argp = &argv[optind];\n        }\n        return true;\n      }\n  \n      auto &ext_opt = get(opt);\n  \n      // grab optional argument\n      if (ext_opt.opt.has_arg == optional_argument && !optarg) {\n        auto next_arg = argv[optind];\n  \n        if (next_arg && *next_arg && *next_arg != '-') {\n          optarg = next_arg;\n          ++optind;\n        }\n      }\n  \n      ext_opt.set = true;\n      ext_opt.arg = optarg;\n  \n      if (ext_opt.parse) {\n        if (!ext_opt.parse(*this, ext_opt)) {\n          return false;\n        }\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"iterations\"",
            "0",
            "required_argument",
            "\"Iteration count of GETs sent by the latency test (default: 1000).\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"analyze\"",
            "'a'",
            "optional_argument",
            "\"Analyze server characteristics (options: default, latency).\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"server-version\"",
            "'S'",
            "no_argument",
            "\"Print server version.\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"args\"",
            "'A'",
            "required_argument",
            "\"Stat args. DEPRECATED: use positional arguments.\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "def"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <cstdio>\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\n#define PROGRAM_VERSION     \"1.1\"\n#define PROGRAM_DESCRIPTION \"Print stats/version of or analyze a memcached cluster.\"\n#define PROGRAM_NAME        \"memstat\"\n\nint main(int argc, char *argv[]) {\n  client_options opt{PROGRAM_NAME, PROGRAM_VERSION, PROGRAM_DESCRIPTION, \"[stat ...]\"};\n\n  for (const auto &def : opt.defaults) {\n    if (def.opt.val != 'H') {\n      // no need for --hash\n      opt.add(def);\n    }\n  }\n\n  opt.add(\"args\", 'A', required_argument, \"Stat args. DEPRECATED: use positional arguments.\");\n  opt.add(\"server-version\", 'S', no_argument, \"Print server version.\");\n  opt.add(\"analyze\", 'a', optional_argument, \"Analyze server characteristics (options: default, latency).\");\n  opt.add(\"iterations\", 0, required_argument, \"Iteration count of GETs sent by the latency test (default: 1000).\");\n\n  char **argp = nullptr;\n  if (!opt.parse(argc, argv, &argp)) {\n    exit(EXIT_FAILURE);\n  }\n\n  memcached_st memc;\n  if (!check_memcached(opt, memc)) {\n    exit(EXIT_FAILURE);\n  }\n\n  if (!opt.apply(&memc)) {\n    memcached_free(&memc);\n    exit(EXIT_FAILURE);\n  }\n\n  auto exit_code = EXIT_SUCCESS;\n  if (opt.isset('S')) {\n    if (opt.isset(\"verbose\")) {\n      std::cout << \"Server versions:\\n\";\n    }\n    if (MEMCACHED_SUCCESS != memcached_version(&memc)) {\n      exit_code = EXIT_FAILURE;\n    }\n    memcached_server_fn cb[] = {&print_server_version};\n    memcached_server_cursor(&memc, cb, nullptr, 1);\n    goto done;\n  }\n\n  if (opt.isset(\"analyze\")) {\n    const char *analyze = opt.argof(\"analyze\");\n    if (analyze && strcmp(analyze, \"default\")) {\n      if (!strcmp(analyze, \"latency\")) {\n        if (!analyze_latency(opt, &memc)) {\n          exit_code = EXIT_FAILURE;\n        }\n        goto done;\n      }\n\n      if (!opt.isset(\"quiet\")) {\n        std::cerr << \"Unknown --analyze mode: '\" << analyze << \"'.\\n\";\n      }\n    }\n\n    memcached_return_t rc;\n    auto stat = memcached_stat(&memc, nullptr, &rc);\n    if (!memcached_success(rc)) {\n      exit_code = EXIT_FAILURE;\n      if (!opt.isset(\"quiet\")) {\n        std::cerr << memcached_last_error_message(&memc) << \"\\n\";\n      }\n    } else if (!analyze_stat(opt, &memc, stat)) {\n      exit_code = EXIT_FAILURE;\n    }\n    memcached_stat_free(&memc, stat);\n    goto done;\n  }\n\n  if (!*argp || opt.isset('A')) {\n    if (!memstat(opt, memc, opt.argof('A'))) {\n      exit_code = EXIT_FAILURE;\n    }\n  }\n  for (auto arg = argp; *arg; ++arg) {\n    if (!memstat(opt, memc, *arg)) {\n      exit_code = EXIT_FAILURE;\n    }\n  }\n\ndone:\n  memcached_free(&memc);\n  exit(exit_code);\n}"
  },
  {
    "function_name": "memstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memstat.cc",
    "lines": "191-206",
    "snippet": "static bool memstat(const client_options &opt, memcached_st &memc, const char *arg) {\n  memcached_instance_st *context = nullptr;\n  auto rc = memcached_stat_execute(&memc, arg, print_stat, &context);\n  if (memcached_success(rc)) {\n    return true;\n  }\n  if (!opt.isset(\"quiet\")) {\n    std::cerr << \"Failed to 'STAT \" << (arg ? arg : \"\") << \"': \";\n    if (memcached_last_error(&memc)) {\n      std::cerr << memcached_last_error_message(&memc) << \"\\n\";\n    } else {\n      std::cerr << memcached_strerror(&memc, rc) << \"\\n\";\n    }\n  }\n  return false;\n}",
    "includes": [
      "#include <iomanip>",
      "#include <cstdio>",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_strerror",
          "args": [
            "&memc",
            "rc"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error_message",
          "args": [
            "&memc"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error",
          "args": [
            "&memc"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_last_error_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "500-511",
          "snippet": "int memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nint memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "opt.isset",
          "args": [
            "\"quiet\""
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "isset",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "289-291",
          "snippet": "bool isset(int c) const {\n    return has(c) && get(c).set;\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool isset(int c) const {\n      return has(c) && get(c).set;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_stat_execute",
          "args": [
            "&memc",
            "arg",
            "print_stat",
            "&context"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_stat_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/stats.cc",
          "lines": "616-626",
          "snippet": "memcached_return_t memcached_stat_execute(memcached_st *shell, const char *args,\n                                          memcached_stat_fn func, void *context) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memcached_fatal(memcached_version(memc))) {\n    return memcached_last_error(memc);\n  }\n\n  local_context check(func, context, args, args ? strlen(args) : 0);\n\n  return memcached_server_execute(memc, call_stat_fn, (void *) &check);\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_stat_execute(memcached_st *shell, const char *args,\n                                          memcached_stat_fn func, void *context) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memcached_fatal(memcached_version(memc))) {\n    return memcached_last_error(memc);\n  }\n\n  local_context check(func, context, args, args ? strlen(args) : 0);\n\n  return memcached_server_execute(memc, call_stat_fn, (void *) &check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <cstdio>\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic bool memstat(const client_options &opt, memcached_st &memc, const char *arg) {\n  memcached_instance_st *context = nullptr;\n  auto rc = memcached_stat_execute(&memc, arg, print_stat, &context);\n  if (memcached_success(rc)) {\n    return true;\n  }\n  if (!opt.isset(\"quiet\")) {\n    std::cerr << \"Failed to 'STAT \" << (arg ? arg : \"\") << \"': \";\n    if (memcached_last_error(&memc)) {\n      std::cerr << memcached_last_error_message(&memc) << \"\\n\";\n    } else {\n      std::cerr << memcached_strerror(&memc, rc) << \"\\n\";\n    }\n  }\n  return false;\n}"
  },
  {
    "function_name": "print_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memstat.cc",
    "lines": "172-189",
    "snippet": "static memcached_return_t print_stat(const memcached_instance_st *server,\n                                     const char *key, size_t key_length,\n                                     const char *value, size_t value_length, void *context) {\n  auto instance = static_cast<const memcached_instance_st **>(context);\n\n  if (*instance != server) {\n    *instance = server;\n\n    std::cout << \"Server: \" << memcached_server_name(server)\n              << \" (\" << memcached_server_port(server) << \")\\n\";\n  }\n\n  std::cout << \"\\t\";\n  std::cout.write(key, key_length) << \": \";\n  std::cout.write(value, value_length) << \"\\n\";\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include <iomanip>",
      "#include <cstdio>",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::cout.write",
          "args": [
            "value",
            "value_length"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::cout.write",
          "args": [
            "key",
            "key_length"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_port",
          "args": [
            "server"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "153-160",
          "snippet": "in_port_t memcached_server_port(const memcached_instance_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL) {\n    return 0;\n  }\n\n  return self->port();\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nin_port_t memcached_server_port(const memcached_instance_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL) {\n    return 0;\n  }\n\n  return self->port();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_name",
          "args": [
            "server"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<const memcached_instance_st **>",
          "args": [
            "context"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <cstdio>\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic memcached_return_t print_stat(const memcached_instance_st *server,\n                                     const char *key, size_t key_length,\n                                     const char *value, size_t value_length, void *context) {\n  auto instance = static_cast<const memcached_instance_st **>(context);\n\n  if (*instance != server) {\n    *instance = server;\n\n    std::cout << \"Server: \" << memcached_server_name(server)\n              << \" (\" << memcached_server_port(server) << \")\\n\";\n  }\n\n  std::cout << \"\\t\";\n  std::cout.write(key, key_length) << \": \";\n  std::cout.write(value, value_length) << \"\\n\";\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "analyze_latency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memstat.cc",
    "lines": "144-170",
    "snippet": "static bool analyze_latency(client_options &opt, memcached_st *root) {\n  uint32_t num_of_tests = DEFAULT_LATENCY_ITERATIONS;\n\n  if (auto iter_str = opt.argof(\"iterations\")) {\n    num_of_tests = std::stoul(iter_str);\n  }\n\n  std::vector<memcached_st> servers{memcached_server_count(root)};\n\n  uint32_t i = 0;\n  for (auto &memc : servers) {\n    memcached_clone(&memc, root);\n    memcached_servers_reset(&memc);\n    auto instance = memcached_server_instance_by_position(root, i++);\n    memcached_server_add(&memc, memcached_server_name(instance), memcached_server_port(instance));\n    //pre-connect\n    memcached_version(&memc);\n  }\n\n  latency_test(num_of_tests, servers);\n\n  for (auto &memc : servers) {\n    memcached_free(&memc);\n  }\n\n  return true;\n}",
    "includes": [
      "#include <iomanip>",
      "#include <cstdio>",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [
      "#define DEFAULT_LATENCY_ITERATIONS 100 // update help string, if changed"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_free",
          "args": [
            "&memc"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
          "lines": "257-261",
          "snippet": "void memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "latency_test",
          "args": [
            "num_of_tests",
            "servers"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "latency_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memstat.cc",
          "lines": "87-142",
          "snippet": "static void latency_test(uint32_t iterations, std::vector<memcached_st> &servers) {\n  const char *test_key = \"libmemcached_test_key\";\n  size_t test_key_len = strlen(test_key);\n  const memcached_instance_st *slowest_server = nullptr;\n  time_point::duration slowest_time{};\n  std::vector<const memcached_instance_st *> failed_servers{};\n\n  std::cout << \"Network Latency Test:\\n\\n\" << std::showpoint << std::fixed << std::setprecision(3);\n\n  for (auto &memc : servers) {\n    memcached_return_t rc = memcached_last_error(&memc);\n\n    auto start = time_clock::now();\n    for (auto i = 0u; i < iterations; ++i) {\n      free(memcached_get(&memc, test_key, test_key_len, nullptr, nullptr, &rc));\n      if (memcached_fatal(rc)) {\n        break;\n      }\n    }\n    auto elapsed = time_clock::now() - start;\n\n    auto inst = memcached_server_instance_by_position(&memc, 0);\n    std::cout << \"\\t \" << memcached_server_name(inst)\n              << \" (\" << memcached_server_port(inst) << \") \";\n\n    if (memcached_fatal(rc)) {\n      std::cout << \"  => failed to reach the server\\n\";\n      failed_servers.push_back(inst);\n    } else {\n      std::cout << \"  => \"\n                << time_format(elapsed/iterations).count() << \" seconds (\"\n                << time_format_ms(elapsed/iterations).count() << \"ms)\\n\";\n      if (slowest_time == time_point::duration::zero() || slowest_time < elapsed) {\n        slowest_time = elapsed;\n        slowest_server = inst;\n      }\n    }\n  }\n\n  if (servers.size() > 1 && slowest_server) {\n    std::cout << \"\\n---\\n\\nSlowest Server: \"\n              << memcached_server_name(slowest_server) << \"(\"\n              << memcached_server_port(slowest_server) << \")\"\n              << \" => \"\n              << time_format(slowest_time/iterations).count() << \" seconds (\"\n              << time_format_ms(slowest_time/iterations).count() << \"ms)\\n\";\n  }\n  if (!failed_servers.empty()) {\n    for (const auto inst : failed_servers) {\n      std::cout << \"Failed Server:  \" << memcached_server_name(inst)\n                << \" (\" << memcached_server_port(inst)\n                << \") => \" << memcached_strerror(inst->root, memcached_server_error_return(inst))\n                << \"\\n\";\n    }\n  }\n}",
          "includes": [
            "#include <iomanip>",
            "#include <cstdio>",
            "#include \"common/time.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <cstdio>\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic void latency_test(uint32_t iterations, std::vector<memcached_st> &servers) {\n  const char *test_key = \"libmemcached_test_key\";\n  size_t test_key_len = strlen(test_key);\n  const memcached_instance_st *slowest_server = nullptr;\n  time_point::duration slowest_time{};\n  std::vector<const memcached_instance_st *> failed_servers{};\n\n  std::cout << \"Network Latency Test:\\n\\n\" << std::showpoint << std::fixed << std::setprecision(3);\n\n  for (auto &memc : servers) {\n    memcached_return_t rc = memcached_last_error(&memc);\n\n    auto start = time_clock::now();\n    for (auto i = 0u; i < iterations; ++i) {\n      free(memcached_get(&memc, test_key, test_key_len, nullptr, nullptr, &rc));\n      if (memcached_fatal(rc)) {\n        break;\n      }\n    }\n    auto elapsed = time_clock::now() - start;\n\n    auto inst = memcached_server_instance_by_position(&memc, 0);\n    std::cout << \"\\t \" << memcached_server_name(inst)\n              << \" (\" << memcached_server_port(inst) << \") \";\n\n    if (memcached_fatal(rc)) {\n      std::cout << \"  => failed to reach the server\\n\";\n      failed_servers.push_back(inst);\n    } else {\n      std::cout << \"  => \"\n                << time_format(elapsed/iterations).count() << \" seconds (\"\n                << time_format_ms(elapsed/iterations).count() << \"ms)\\n\";\n      if (slowest_time == time_point::duration::zero() || slowest_time < elapsed) {\n        slowest_time = elapsed;\n        slowest_server = inst;\n      }\n    }\n  }\n\n  if (servers.size() > 1 && slowest_server) {\n    std::cout << \"\\n---\\n\\nSlowest Server: \"\n              << memcached_server_name(slowest_server) << \"(\"\n              << memcached_server_port(slowest_server) << \")\"\n              << \" => \"\n              << time_format(slowest_time/iterations).count() << \" seconds (\"\n              << time_format_ms(slowest_time/iterations).count() << \"ms)\\n\";\n  }\n  if (!failed_servers.empty()) {\n    for (const auto inst : failed_servers) {\n      std::cout << \"Failed Server:  \" << memcached_server_name(inst)\n                << \" (\" << memcached_server_port(inst)\n                << \") => \" << memcached_strerror(inst->root, memcached_server_error_return(inst))\n                << \"\\n\";\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_version",
          "args": [
            "&memc"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/version.cc",
          "lines": "164-184",
          "snippet": "memcached_return_t memcached_version(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    memcached_return_t rc;\n    if (memcached_failed(rc = initialize_query(memc, true))) {\n      return rc;\n    }\n\n    if (memcached_is_udp(memc)) {\n      return MEMCACHED_NOT_SUPPORTED;\n    }\n\n    if (memcached_is_binary(memc)) {\n      return memcached_version_binary(memc);\n    }\n\n    return memcached_version_textual(memc);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_version(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    memcached_return_t rc;\n    if (memcached_failed(rc = initialize_query(memc, true))) {\n      return rc;\n    }\n\n    if (memcached_is_udp(memc)) {\n      return MEMCACHED_NOT_SUPPORTED;\n    }\n\n    if (memcached_is_binary(memc)) {\n      return memcached_version_binary(memc);\n    }\n\n    return memcached_version_textual(memc);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_add",
          "args": [
            "&memc",
            "memcached_server_name(instance)",
            "memcached_server_port(instance)"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "458-460",
          "snippet": "memcached_return_t memcached_server_add(memcached_st *shell, const char *hostname, in_port_t port) {\n  return memcached_server_add_with_weight(shell, hostname, port, 0);\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_server_add(memcached_st *shell, const char *hostname, in_port_t port) {\n  return memcached_server_add_with_weight(shell, hostname, port, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_port",
          "args": [
            "instance"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "153-160",
          "snippet": "in_port_t memcached_server_port(const memcached_instance_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL) {\n    return 0;\n  }\n\n  return self->port();\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nin_port_t memcached_server_port(const memcached_instance_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL) {\n    return 0;\n  }\n\n  return self->port();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_name",
          "args": [
            "instance"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_instance_by_position",
          "args": [
            "root",
            "i++"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_servers_reset",
          "args": [
            "&memc"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_servers_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
          "lines": "234-247",
          "snippet": "void memcached_servers_reset(memcached_st *shell) {\n  Memcached *self = memcached2Memcached(shell);\n  if (self) {\n    libmemcached_free(self, self->ketama.continuum);\n    self->ketama.continuum = NULL;\n    self->ketama.continuum_count = 0;\n    self->ketama.continuum_points_counter = 0;\n\n    memcached_instance_list_free(memcached_instance_list(self), self->number_of_hosts);\n    memcached_instance_set(self, NULL, 0);\n\n    memcached_reset_last_disconnected_server(self);\n  }\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_servers_reset(memcached_st *shell) {\n  Memcached *self = memcached2Memcached(shell);\n  if (self) {\n    libmemcached_free(self, self->ketama.continuum);\n    self->ketama.continuum = NULL;\n    self->ketama.continuum_count = 0;\n    self->ketama.continuum_points_counter = 0;\n\n    memcached_instance_list_free(memcached_instance_list(self), self->number_of_hosts);\n    memcached_instance_set(self, NULL, 0);\n\n    memcached_reset_last_disconnected_server(self);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_clone",
          "args": [
            "&memc",
            "root"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_clone_sasl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
          "lines": "470-472",
          "snippet": "memcached_return_t memcached_clone_sasl(memcached_st *, const memcached_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}",
          "includes": [
            "#  include <pthread.h>",
            "#    include <sasl/sasl.h>",
            "#include <atomic>",
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_clone_sasl(memcached_st *, const memcached_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "root"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::stoul",
          "args": [
            "iter_str"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.argof",
          "args": [
            "\"iterations\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <cstdio>\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\n#define DEFAULT_LATENCY_ITERATIONS 100 // update help string, if changed\n\nstatic bool analyze_latency(client_options &opt, memcached_st *root) {\n  uint32_t num_of_tests = DEFAULT_LATENCY_ITERATIONS;\n\n  if (auto iter_str = opt.argof(\"iterations\")) {\n    num_of_tests = std::stoul(iter_str);\n  }\n\n  std::vector<memcached_st> servers{memcached_server_count(root)};\n\n  uint32_t i = 0;\n  for (auto &memc : servers) {\n    memcached_clone(&memc, root);\n    memcached_servers_reset(&memc);\n    auto instance = memcached_server_instance_by_position(root, i++);\n    memcached_server_add(&memc, memcached_server_name(instance), memcached_server_port(instance));\n    //pre-connect\n    memcached_version(&memc);\n  }\n\n  latency_test(num_of_tests, servers);\n\n  for (auto &memc : servers) {\n    memcached_free(&memc);\n  }\n\n  return true;\n}"
  },
  {
    "function_name": "latency_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memstat.cc",
    "lines": "87-142",
    "snippet": "static void latency_test(uint32_t iterations, std::vector<memcached_st> &servers) {\n  const char *test_key = \"libmemcached_test_key\";\n  size_t test_key_len = strlen(test_key);\n  const memcached_instance_st *slowest_server = nullptr;\n  time_point::duration slowest_time{};\n  std::vector<const memcached_instance_st *> failed_servers{};\n\n  std::cout << \"Network Latency Test:\\n\\n\" << std::showpoint << std::fixed << std::setprecision(3);\n\n  for (auto &memc : servers) {\n    memcached_return_t rc = memcached_last_error(&memc);\n\n    auto start = time_clock::now();\n    for (auto i = 0u; i < iterations; ++i) {\n      free(memcached_get(&memc, test_key, test_key_len, nullptr, nullptr, &rc));\n      if (memcached_fatal(rc)) {\n        break;\n      }\n    }\n    auto elapsed = time_clock::now() - start;\n\n    auto inst = memcached_server_instance_by_position(&memc, 0);\n    std::cout << \"\\t \" << memcached_server_name(inst)\n              << \" (\" << memcached_server_port(inst) << \") \";\n\n    if (memcached_fatal(rc)) {\n      std::cout << \"  => failed to reach the server\\n\";\n      failed_servers.push_back(inst);\n    } else {\n      std::cout << \"  => \"\n                << time_format(elapsed/iterations).count() << \" seconds (\"\n                << time_format_ms(elapsed/iterations).count() << \"ms)\\n\";\n      if (slowest_time == time_point::duration::zero() || slowest_time < elapsed) {\n        slowest_time = elapsed;\n        slowest_server = inst;\n      }\n    }\n  }\n\n  if (servers.size() > 1 && slowest_server) {\n    std::cout << \"\\n---\\n\\nSlowest Server: \"\n              << memcached_server_name(slowest_server) << \"(\"\n              << memcached_server_port(slowest_server) << \")\"\n              << \" => \"\n              << time_format(slowest_time/iterations).count() << \" seconds (\"\n              << time_format_ms(slowest_time/iterations).count() << \"ms)\\n\";\n  }\n  if (!failed_servers.empty()) {\n    for (const auto inst : failed_servers) {\n      std::cout << \"Failed Server:  \" << memcached_server_name(inst)\n                << \" (\" << memcached_server_port(inst)\n                << \") => \" << memcached_strerror(inst->root, memcached_server_error_return(inst))\n                << \"\\n\";\n    }\n  }\n}",
    "includes": [
      "#include <iomanip>",
      "#include <cstdio>",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_strerror",
          "args": [
            "inst->root",
            "memcached_server_error_return(inst)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_error_return",
          "args": [
            "inst"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_error_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "541-551",
          "snippet": "memcached_return_t memcached_server_error_return(const memcached_instance_st *ptr) {\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (ptr->error_messages) {\n    return ptr->error_messages->rc;\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_server_error_return(const memcached_instance_st *ptr) {\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (ptr->error_messages) {\n    return ptr->error_messages->rc;\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_port",
          "args": [
            "inst"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "153-160",
          "snippet": "in_port_t memcached_server_port(const memcached_instance_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL) {\n    return 0;\n  }\n\n  return self->port();\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nin_port_t memcached_server_port(const memcached_instance_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL) {\n    return 0;\n  }\n\n  return self->port();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_name",
          "args": [
            "inst"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "failed_servers.empty",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format_ms",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format_ms",
          "args": [
            "slowest_time/iterations"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format",
          "args": [
            "slowest_time/iterations"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_name",
          "args": [
            "slowest_server"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "servers.size",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_point::duration::zero",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format_ms",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format_ms",
          "args": [
            "elapsed/iterations"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_format",
          "args": [
            "elapsed/iterations"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "failed_servers.push_back",
          "args": [
            "inst"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_fatal",
          "args": [
            "rc"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_name",
          "args": [
            "inst"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_instance_by_position",
          "args": [
            "&memc",
            "0"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_clock::now",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_fatal",
          "args": [
            "rc"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "memcached_get(&memc, test_key, test_key_len, nullptr, nullptr, &rc)"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "aes_free_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/aes.cc",
          "lines": "286-290",
          "snippet": "void aes_free_key(aes_key_t *key) {\n  if (key) {\n    free(key);\n  }\n}",
          "includes": [
            "#  include \"libhashkit/rijndael.hpp\"",
            "#include <openssl/evp.h>",
            "#include <cstring>",
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"libhashkit/rijndael.hpp\"\n#include <openssl/evp.h>\n#include <cstring>\n#include \"libhashkit/common.h\"\n\nvoid aes_free_key(aes_key_t *key) {\n  if (key) {\n    free(key);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_get",
          "args": [
            "&memc",
            "test_key",
            "test_key_len",
            "nullptr",
            "nullptr",
            "&rc"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_clock::now",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error",
          "args": [
            "&memc"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_last_error_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "500-511",
          "snippet": "int memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nint memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::setprecision",
          "args": [
            "3"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "test_key"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <cstdio>\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic void latency_test(uint32_t iterations, std::vector<memcached_st> &servers) {\n  const char *test_key = \"libmemcached_test_key\";\n  size_t test_key_len = strlen(test_key);\n  const memcached_instance_st *slowest_server = nullptr;\n  time_point::duration slowest_time{};\n  std::vector<const memcached_instance_st *> failed_servers{};\n\n  std::cout << \"Network Latency Test:\\n\\n\" << std::showpoint << std::fixed << std::setprecision(3);\n\n  for (auto &memc : servers) {\n    memcached_return_t rc = memcached_last_error(&memc);\n\n    auto start = time_clock::now();\n    for (auto i = 0u; i < iterations; ++i) {\n      free(memcached_get(&memc, test_key, test_key_len, nullptr, nullptr, &rc));\n      if (memcached_fatal(rc)) {\n        break;\n      }\n    }\n    auto elapsed = time_clock::now() - start;\n\n    auto inst = memcached_server_instance_by_position(&memc, 0);\n    std::cout << \"\\t \" << memcached_server_name(inst)\n              << \" (\" << memcached_server_port(inst) << \") \";\n\n    if (memcached_fatal(rc)) {\n      std::cout << \"  => failed to reach the server\\n\";\n      failed_servers.push_back(inst);\n    } else {\n      std::cout << \"  => \"\n                << time_format(elapsed/iterations).count() << \" seconds (\"\n                << time_format_ms(elapsed/iterations).count() << \"ms)\\n\";\n      if (slowest_time == time_point::duration::zero() || slowest_time < elapsed) {\n        slowest_time = elapsed;\n        slowest_server = inst;\n      }\n    }\n  }\n\n  if (servers.size() > 1 && slowest_server) {\n    std::cout << \"\\n---\\n\\nSlowest Server: \"\n              << memcached_server_name(slowest_server) << \"(\"\n              << memcached_server_port(slowest_server) << \")\"\n              << \" => \"\n              << time_format(slowest_time/iterations).count() << \" seconds (\"\n              << time_format_ms(slowest_time/iterations).count() << \"ms)\\n\";\n  }\n  if (!failed_servers.empty()) {\n    for (const auto inst : failed_servers) {\n      std::cout << \"Failed Server:  \" << memcached_server_name(inst)\n                << \" (\" << memcached_server_port(inst)\n                << \") => \" << memcached_strerror(inst->root, memcached_server_error_return(inst))\n                << \"\\n\";\n    }\n  }\n}"
  },
  {
    "function_name": "analyze_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memstat.cc",
    "lines": "72-85",
    "snippet": "static bool analyze_stat(const client_options &opt, memcached_st *memc, memcached_stat_st *stat) {\n  memcached_return_t rc;\n  auto report = memcached_analyze(memc, stat, &rc);\n\n  if (rc != MEMCACHED_SUCCESS || !report) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failure to analyze servers:\" << memcached_strerror(memc, rc) << \".\\n\";\n    }\n    return false;\n  }\n  print_report(memc, report);\n  free(report);\n  return true;\n}",
    "includes": [
      "#include <iomanip>",
      "#include <cstdio>",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "report"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "aes_free_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/aes.cc",
          "lines": "286-290",
          "snippet": "void aes_free_key(aes_key_t *key) {\n  if (key) {\n    free(key);\n  }\n}",
          "includes": [
            "#  include \"libhashkit/rijndael.hpp\"",
            "#include <openssl/evp.h>",
            "#include <cstring>",
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"libhashkit/rijndael.hpp\"\n#include <openssl/evp.h>\n#include <cstring>\n#include \"libhashkit/common.h\"\n\nvoid aes_free_key(aes_key_t *key) {\n  if (key) {\n    free(key);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_report",
          "args": [
            "memc",
            "report"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "print_report",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memstat.cc",
          "lines": "41-70",
          "snippet": "static void print_report(memcached_st *memc, memcached_analysis_st *report) {\n  uint32_t server_count = memcached_server_count(memc);\n  auto most_consumed_server = memcached_server_instance_by_position(memc, report->most_consumed_server);\n  auto least_free_server = memcached_server_instance_by_position(memc, report->least_free_server);\n  auto oldest_server = memcached_server_instance_by_position(memc, report->oldest_server);\n\n  printf(\"Memcached Cluster Analysis Report\\n\\n\");\n  printf(\"\\tNumber of Servers Analyzed         : %u\\n\", server_count);\n  printf(\"\\tAverage Item Size (incl/overhead)  : %u bytes\\n\", report->average_item_size);\n\n  if (server_count == 1) {\n    printf(\"\\nFor a detailed report, you must supply multiple servers.\\n\");\n    return;\n  }\n\n  printf(\"\\n\");\n  printf(\"\\tNode with most memory consumption  : %s:%u (%llu bytes)\\n\",\n      memcached_server_name(most_consumed_server),\n      (uint32_t) memcached_server_port(most_consumed_server),\n      (unsigned long long) report->most_used_bytes);\n  printf(\"\\tNode with least free space         : %s:%u (%llu bytes remaining)\\n\",\n      memcached_server_name(least_free_server),\n      (uint32_t) memcached_server_port(least_free_server),\n      (unsigned long long) report->least_remaining_bytes);\n  printf(\"\\tNode with longest uptime           : %s:%u (%us)\\n\",\n      memcached_server_name(oldest_server), (uint32_t) memcached_server_port(oldest_server),\n      report->longest_uptime);\n  printf(\"\\tPool-wide Hit Ratio                : %1.f%%\\n\", report->pool_hit_ratio);\n  printf(\"\\n\");\n}",
          "includes": [
            "#include <iomanip>",
            "#include <cstdio>",
            "#include \"common/time.hpp\"",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <cstdio>\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic void print_report(memcached_st *memc, memcached_analysis_st *report) {\n  uint32_t server_count = memcached_server_count(memc);\n  auto most_consumed_server = memcached_server_instance_by_position(memc, report->most_consumed_server);\n  auto least_free_server = memcached_server_instance_by_position(memc, report->least_free_server);\n  auto oldest_server = memcached_server_instance_by_position(memc, report->oldest_server);\n\n  printf(\"Memcached Cluster Analysis Report\\n\\n\");\n  printf(\"\\tNumber of Servers Analyzed         : %u\\n\", server_count);\n  printf(\"\\tAverage Item Size (incl/overhead)  : %u bytes\\n\", report->average_item_size);\n\n  if (server_count == 1) {\n    printf(\"\\nFor a detailed report, you must supply multiple servers.\\n\");\n    return;\n  }\n\n  printf(\"\\n\");\n  printf(\"\\tNode with most memory consumption  : %s:%u (%llu bytes)\\n\",\n      memcached_server_name(most_consumed_server),\n      (uint32_t) memcached_server_port(most_consumed_server),\n      (unsigned long long) report->most_used_bytes);\n  printf(\"\\tNode with least free space         : %s:%u (%llu bytes remaining)\\n\",\n      memcached_server_name(least_free_server),\n      (uint32_t) memcached_server_port(least_free_server),\n      (unsigned long long) report->least_remaining_bytes);\n  printf(\"\\tNode with longest uptime           : %s:%u (%us)\\n\",\n      memcached_server_name(oldest_server), (uint32_t) memcached_server_port(oldest_server),\n      report->longest_uptime);\n  printf(\"\\tPool-wide Hit Ratio                : %1.f%%\\n\", report->pool_hit_ratio);\n  printf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_strerror",
          "args": [
            "memc",
            "rc"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.isset",
          "args": [
            "\"quiet\""
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "isset",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "289-291",
          "snippet": "bool isset(int c) const {\n    return has(c) && get(c).set;\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool isset(int c) const {\n      return has(c) && get(c).set;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_analyze",
          "args": [
            "memc",
            "stat",
            "&rc"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <cstdio>\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic bool analyze_stat(const client_options &opt, memcached_st *memc, memcached_stat_st *stat) {\n  memcached_return_t rc;\n  auto report = memcached_analyze(memc, stat, &rc);\n\n  if (rc != MEMCACHED_SUCCESS || !report) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failure to analyze servers:\" << memcached_strerror(memc, rc) << \".\\n\";\n    }\n    return false;\n  }\n  print_report(memc, report);\n  free(report);\n  return true;\n}"
  },
  {
    "function_name": "print_report",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memstat.cc",
    "lines": "41-70",
    "snippet": "static void print_report(memcached_st *memc, memcached_analysis_st *report) {\n  uint32_t server_count = memcached_server_count(memc);\n  auto most_consumed_server = memcached_server_instance_by_position(memc, report->most_consumed_server);\n  auto least_free_server = memcached_server_instance_by_position(memc, report->least_free_server);\n  auto oldest_server = memcached_server_instance_by_position(memc, report->oldest_server);\n\n  printf(\"Memcached Cluster Analysis Report\\n\\n\");\n  printf(\"\\tNumber of Servers Analyzed         : %u\\n\", server_count);\n  printf(\"\\tAverage Item Size (incl/overhead)  : %u bytes\\n\", report->average_item_size);\n\n  if (server_count == 1) {\n    printf(\"\\nFor a detailed report, you must supply multiple servers.\\n\");\n    return;\n  }\n\n  printf(\"\\n\");\n  printf(\"\\tNode with most memory consumption  : %s:%u (%llu bytes)\\n\",\n      memcached_server_name(most_consumed_server),\n      (uint32_t) memcached_server_port(most_consumed_server),\n      (unsigned long long) report->most_used_bytes);\n  printf(\"\\tNode with least free space         : %s:%u (%llu bytes remaining)\\n\",\n      memcached_server_name(least_free_server),\n      (uint32_t) memcached_server_port(least_free_server),\n      (unsigned long long) report->least_remaining_bytes);\n  printf(\"\\tNode with longest uptime           : %s:%u (%us)\\n\",\n      memcached_server_name(oldest_server), (uint32_t) memcached_server_port(oldest_server),\n      report->longest_uptime);\n  printf(\"\\tPool-wide Hit Ratio                : %1.f%%\\n\", report->pool_hit_ratio);\n  printf(\"\\n\");\n}",
    "includes": [
      "#include <iomanip>",
      "#include <cstdio>",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tPool-wide Hit Ratio                : %1.f%%\\n\"",
            "report->pool_hit_ratio"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tNode with longest uptime           : %s:%u (%us)\\n\"",
            "memcached_server_name(oldest_server)",
            "(uint32_t) memcached_server_port(oldest_server)",
            "report->longest_uptime"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_port",
          "args": [
            "oldest_server"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "153-160",
          "snippet": "in_port_t memcached_server_port(const memcached_instance_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL) {\n    return 0;\n  }\n\n  return self->port();\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nin_port_t memcached_server_port(const memcached_instance_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL) {\n    return 0;\n  }\n\n  return self->port();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_name",
          "args": [
            "oldest_server"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tNode with least free space         : %s:%u (%llu bytes remaining)\\n\"",
            "memcached_server_name(least_free_server)",
            "(uint32_t) memcached_server_port(least_free_server)",
            "(unsigned long long) report->least_remaining_bytes"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_name",
          "args": [
            "least_free_server"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tNode with most memory consumption  : %s:%u (%llu bytes)\\n\"",
            "memcached_server_name(most_consumed_server)",
            "(uint32_t) memcached_server_port(most_consumed_server)",
            "(unsigned long long) report->most_used_bytes"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_name",
          "args": [
            "most_consumed_server"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nFor a detailed report, you must supply multiple servers.\\n\""
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tAverage Item Size (incl/overhead)  : %u bytes\\n\"",
            "report->average_item_size"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tNumber of Servers Analyzed         : %u\\n\"",
            "server_count"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Memcached Cluster Analysis Report\\n\\n\""
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_instance_by_position",
          "args": [
            "memc",
            "report->oldest_server"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_instance_by_position",
          "args": [
            "memc",
            "report->least_free_server"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_instance_by_position",
          "args": [
            "memc",
            "report->most_consumed_server"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "memc"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <cstdio>\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic void print_report(memcached_st *memc, memcached_analysis_st *report) {\n  uint32_t server_count = memcached_server_count(memc);\n  auto most_consumed_server = memcached_server_instance_by_position(memc, report->most_consumed_server);\n  auto least_free_server = memcached_server_instance_by_position(memc, report->least_free_server);\n  auto oldest_server = memcached_server_instance_by_position(memc, report->oldest_server);\n\n  printf(\"Memcached Cluster Analysis Report\\n\\n\");\n  printf(\"\\tNumber of Servers Analyzed         : %u\\n\", server_count);\n  printf(\"\\tAverage Item Size (incl/overhead)  : %u bytes\\n\", report->average_item_size);\n\n  if (server_count == 1) {\n    printf(\"\\nFor a detailed report, you must supply multiple servers.\\n\");\n    return;\n  }\n\n  printf(\"\\n\");\n  printf(\"\\tNode with most memory consumption  : %s:%u (%llu bytes)\\n\",\n      memcached_server_name(most_consumed_server),\n      (uint32_t) memcached_server_port(most_consumed_server),\n      (unsigned long long) report->most_used_bytes);\n  printf(\"\\tNode with least free space         : %s:%u (%llu bytes remaining)\\n\",\n      memcached_server_name(least_free_server),\n      (uint32_t) memcached_server_port(least_free_server),\n      (unsigned long long) report->least_remaining_bytes);\n  printf(\"\\tNode with longest uptime           : %s:%u (%us)\\n\",\n      memcached_server_name(oldest_server), (uint32_t) memcached_server_port(oldest_server),\n      report->longest_uptime);\n  printf(\"\\tPool-wide Hit Ratio                : %1.f%%\\n\", report->pool_hit_ratio);\n  printf(\"\\n\");\n}"
  },
  {
    "function_name": "print_server_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memstat.cc",
    "lines": "31-39",
    "snippet": "static memcached_return_t print_server_version(const memcached_st *,\n                                               const memcached_instance_st *instance, void *) {\n  std::cerr << memcached_server_name(instance) << \":\" << memcached_server_port(instance) << \" \"\n            << int(memcached_server_major_version(instance)) << \".\"\n            << int(memcached_server_minor_version(instance)) << \".\"\n            << int(memcached_server_micro_version(instance)) << std::endl;\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include <iomanip>",
      "#include <cstdio>",
      "#include \"common/time.hpp\"",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "int",
          "args": [
            "memcached_server_micro_version(instance)"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "414-427",
          "snippet": "void memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_micro_version",
          "args": [
            "instance"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_micro_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "221-227",
          "snippet": "uint8_t memcached_server_micro_version(const memcached_instance_st *instance) {\n  if (instance) {\n    return instance->micro_version;\n  }\n\n  return UINT8_MAX;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint8_t memcached_server_micro_version(const memcached_instance_st *instance) {\n  if (instance) {\n    return instance->micro_version;\n  }\n\n  return UINT8_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_minor_version",
          "args": [
            "instance"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_minor_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "213-219",
          "snippet": "uint8_t memcached_server_minor_version(const memcached_instance_st *instance) {\n  if (instance) {\n    return instance->minor_version;\n  }\n\n  return UINT8_MAX;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint8_t memcached_server_minor_version(const memcached_instance_st *instance) {\n  if (instance) {\n    return instance->minor_version;\n  }\n\n  return UINT8_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_major_version",
          "args": [
            "instance"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_major_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "205-211",
          "snippet": "uint8_t memcached_server_major_version(const memcached_instance_st *instance) {\n  if (instance) {\n    return instance->major_version;\n  }\n\n  return UINT8_MAX;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint8_t memcached_server_major_version(const memcached_instance_st *instance) {\n  if (instance) {\n    return instance->major_version;\n  }\n\n  return UINT8_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_port",
          "args": [
            "instance"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "153-160",
          "snippet": "in_port_t memcached_server_port(const memcached_instance_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL) {\n    return 0;\n  }\n\n  return self->port();\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nin_port_t memcached_server_port(const memcached_instance_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL) {\n    return 0;\n  }\n\n  return self->port();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_name",
          "args": [
            "instance"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <cstdio>\n#include \"common/time.hpp\"\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nstatic memcached_return_t print_server_version(const memcached_st *,\n                                               const memcached_instance_st *instance, void *) {\n  std::cerr << memcached_server_name(instance) << \":\" << memcached_server_port(instance) << \" \"\n            << int(memcached_server_major_version(instance)) << \".\"\n            << int(memcached_server_minor_version(instance)) << \".\"\n            << int(memcached_server_micro_version(instance)) << std::endl;\n\n  return MEMCACHED_SUCCESS;\n}"
  }
]