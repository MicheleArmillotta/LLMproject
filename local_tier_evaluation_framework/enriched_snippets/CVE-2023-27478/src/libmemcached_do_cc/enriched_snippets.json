[
  {
    "function_name": "memcached_vdo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/do.cc",
    "lines": "64-100",
    "snippet": "memcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_server_response_increment",
          "args": [
            "instance"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_response_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/common.h",
          "lines": "137-140",
          "snippet": "static inline void memcached_server_response_increment(memcached_instance_st *instance) {\n  instance->events(POLLIN);\n  instance->cursor_active_++;\n}",
          "includes": [
            "#  include \"p9y/poll.hpp\"",
            "#include \"libmemcached/continuum.hpp\"",
            "#  include \"libmemcached/version.hpp\"",
            "#  include \"libmemcached/result.h\"",
            "#  include \"libmemcached/key.hpp\"",
            "#  include \"libmemcached/server.hpp\"",
            "#  include \"libmemcached/assert.hpp\"",
            "#  include \"libmemcached/backtrace.hpp\"",
            "#  include \"libmemcached/virtual_bucket.h\"",
            "#  include \"libmemcached/namespace.h\"",
            "#  include \"libmemcached/response.h\"",
            "#include \"libmemcached/initialize_query.h\"",
            "#include \"libmemcached/byteorder.h\"",
            "#include \"libmemcached/libmemcached_probes.h\"",
            "#include \"libmemcached/array.h\"",
            "#include \"libmemcached/internal.h\"",
            "#  include \"libmemcached/server_list.hpp\"",
            "#  include \"libmemcached/sasl.hpp\"",
            "#  include \"libmemcached/behavior.hpp\"",
            "#  include \"libmemcached/flag.hpp\"",
            "#  include \"libmemcached/server.hpp\"",
            "#  include \"libmemcached/server_instance.h\"",
            "#  include \"libmemcached/instance.hpp\"",
            "#  include \"libmemcached/quit.hpp\"",
            "#  include \"libmemcached/hash.hpp\"",
            "#  include \"libmemcached/allocators.hpp\"",
            "#  include \"libmemcached/connect.hpp\"",
            "#  include \"libmemcached/do.hpp\"",
            "#  include \"libmemcached/udp.hpp\"",
            "#  include \"libmemcached/io.hpp\"",
            "#  include \"libmemcachedprotocol-0.0/binary.h\"",
            "#  include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/io.h\"",
            "#include \"libmemcached/memory.h\"",
            "#include \"libmemcached/error.hpp\"",
            "#include \"libmemcached/is.h\"",
            "#include \"libmemcached/watchpoint.h\"",
            "#include \"libmemcached-1.0/memcached.h\"",
            "#  include <dlfcn.h>",
            "#  include <strings.h>",
            "#include <fcntl.h>",
            "#  include <sys/time.h>",
            "#include \"p9y/socket.hpp\"",
            "#  include <iso646.h>",
            "#  include <limits.h>",
            "#  include <errno.h>",
            "#  include <time.h>",
            "#  include <string.h>",
            "#  include <stdlib.h>",
            "#  include <stdio.h>",
            "#  include <stddef.h>",
            "#  include <ciso646>",
            "#  include <climits>",
            "#  include <cerrno>",
            "#  include <cctype>",
            "#  include <ctime>",
            "#  include <cstring>",
            "#  include <cstdlib>",
            "#  include <cstdio>",
            "#  include <cstddef>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"p9y/poll.hpp\"\n#include \"libmemcached/continuum.hpp\"\n#  include \"libmemcached/version.hpp\"\n#  include \"libmemcached/result.h\"\n#  include \"libmemcached/key.hpp\"\n#  include \"libmemcached/server.hpp\"\n#  include \"libmemcached/assert.hpp\"\n#  include \"libmemcached/backtrace.hpp\"\n#  include \"libmemcached/virtual_bucket.h\"\n#  include \"libmemcached/namespace.h\"\n#  include \"libmemcached/response.h\"\n#include \"libmemcached/initialize_query.h\"\n#include \"libmemcached/byteorder.h\"\n#include \"libmemcached/libmemcached_probes.h\"\n#include \"libmemcached/array.h\"\n#include \"libmemcached/internal.h\"\n#  include \"libmemcached/server_list.hpp\"\n#  include \"libmemcached/sasl.hpp\"\n#  include \"libmemcached/behavior.hpp\"\n#  include \"libmemcached/flag.hpp\"\n#  include \"libmemcached/server.hpp\"\n#  include \"libmemcached/server_instance.h\"\n#  include \"libmemcached/instance.hpp\"\n#  include \"libmemcached/quit.hpp\"\n#  include \"libmemcached/hash.hpp\"\n#  include \"libmemcached/allocators.hpp\"\n#  include \"libmemcached/connect.hpp\"\n#  include \"libmemcached/do.hpp\"\n#  include \"libmemcached/udp.hpp\"\n#  include \"libmemcached/io.hpp\"\n#  include \"libmemcachedprotocol-0.0/binary.h\"\n#  include \"libmemcached/string.hpp\"\n#include \"libmemcached/io.h\"\n#include \"libmemcached/memory.h\"\n#include \"libmemcached/error.hpp\"\n#include \"libmemcached/is.h\"\n#include \"libmemcached/watchpoint.h\"\n#include \"libmemcached-1.0/memcached.h\"\n#  include <dlfcn.h>\n#  include <strings.h>\n#include <fcntl.h>\n#  include <sys/time.h>\n#include \"p9y/socket.hpp\"\n#  include <iso646.h>\n#  include <limits.h>\n#  include <errno.h>\n#  include <time.h>\n#  include <string.h>\n#  include <stdlib.h>\n#  include <stdio.h>\n#  include <stddef.h>\n#  include <ciso646>\n#  include <climits>\n#  include <cerrno>\n#  include <cctype>\n#  include <ctime>\n#  include <cstring>\n#  include <cstdlib>\n#  include <cstdio>\n#  include <cstddef>\n#include \"mem_config.h\"\n\nstatic inline void memcached_server_response_increment(memcached_instance_st *instance) {\n  instance->events(POLLIN);\n  instance->cursor_active_++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_udp",
          "args": [
            "instance->root"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_replying",
          "args": [
            "instance->root"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_io_reset",
          "args": [
            "instance"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "740-742",
          "snippet": "void memcached_io_reset(memcached_instance_st *instance) {\n  memcached_quit_server(instance, true);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_io_reset(memcached_instance_st *instance) {\n  memcached_quit_server(instance, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*instance",
            "MEMCACHED_WRITE_FAILURE",
            "MEMCACHED_AT"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_last_error",
          "args": [
            "instance->root"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_last_error_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "500-511",
          "snippet": "int memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nint memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_io_writev",
          "args": [
            "instance",
            "vector",
            "count",
            "with_flush"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "608-631",
          "snippet": "bool memcached_io_writev(memcached_instance_st *instance, libmemcached_io_vector_st vector[],\n                         const size_t number_of, const bool with_flush) {\n  ssize_t complete_total = 0;\n  ssize_t total = 0;\n\n  for (size_t x = 0; x < number_of; x++, vector++) {\n    complete_total += vector->length;\n    if (vector->length) {\n      size_t written;\n      if ((_io_write(instance, vector->buffer, vector->length, false, written)) == false) {\n        return false;\n      }\n      total += written;\n    }\n  }\n\n  if (with_flush) {\n    if (memcached_io_write(instance) == false) {\n      return false;\n    }\n  }\n\n  return (complete_total == total);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_io_writev(memcached_instance_st *instance, libmemcached_io_vector_st vector[],\n                         const size_t number_of, const bool with_flush) {\n  ssize_t complete_total = 0;\n  ssize_t total = 0;\n\n  for (size_t x = 0; x < number_of; x++, vector++) {\n    complete_total += vector->length;\n    if (vector->length) {\n      size_t written;\n      if ((_io_write(instance, vector->buffer, vector->length, false, written)) == false) {\n        return false;\n      }\n      total += written;\n    }\n  }\n\n  if (with_flush) {\n    if (memcached_io_write(instance) == false) {\n      return false;\n    }\n  }\n\n  return (complete_total == total);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc = _vdo_udp(instance, vector, count)"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_vdo_udp",
          "args": [
            "instance",
            "vector",
            "count"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "_vdo_udp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/do.cc",
          "lines": "18-62",
          "snippet": "static memcached_return_t _vdo_udp(memcached_instance_st *instance,\n                                   libmemcached_io_vector_st vector[], const size_t count) {\n#if HAVE_SENDMSG && HAVE_STRUCT_MSGHDR\n  if (vector[0].buffer or vector[0].length) {\n    return memcached_set_error(\n        *instance->root, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"UDP messages was attempted, but vector was not setup for it\"));\n  }\n\n  struct msghdr msg;\n  memset(&msg, 0, sizeof(msg));\n\n  increment_udp_message_id(instance);\n  vector[0].buffer = instance->write_buffer;\n  vector[0].length = UDP_DATAGRAM_HEADER_LENGTH;\n\n  msg.msg_iov = (struct iovec *) vector;\n#  ifdef __APPLE__\n  msg.msg_iovlen = int(count);\n#  else\n  msg.msg_iovlen = count;\n#  endif\n\n  uint32_t retry = 5;\n  while (--retry) {\n    ssize_t sendmsg_length = ::sendmsg(instance->fd, &msg, 0);\n    if (sendmsg_length > 0) {\n      break;\n    } else if (sendmsg_length < 0) {\n      if (errno == EMSGSIZE) {\n        return memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n      }\n\n      return memcached_set_errno(*instance, errno, MEMCACHED_AT);\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n#else\n  (void) instance;\n  (void) vector;\n  (void) count;\n  return MEMCACHED_FAILURE;\n#endif\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t _vdo_udp(memcached_instance_st *instance,\n                                   libmemcached_io_vector_st vector[], const size_t count) {\n#if HAVE_SENDMSG && HAVE_STRUCT_MSGHDR\n  if (vector[0].buffer or vector[0].length) {\n    return memcached_set_error(\n        *instance->root, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"UDP messages was attempted, but vector was not setup for it\"));\n  }\n\n  struct msghdr msg;\n  memset(&msg, 0, sizeof(msg));\n\n  increment_udp_message_id(instance);\n  vector[0].buffer = instance->write_buffer;\n  vector[0].length = UDP_DATAGRAM_HEADER_LENGTH;\n\n  msg.msg_iov = (struct iovec *) vector;\n#  ifdef __APPLE__\n  msg.msg_iovlen = int(count);\n#  else\n  msg.msg_iovlen = count;\n#  endif\n\n  uint32_t retry = 5;\n  while (--retry) {\n    ssize_t sendmsg_length = ::sendmsg(instance->fd, &msg, 0);\n    if (sendmsg_length > 0) {\n      break;\n    } else if (sendmsg_length < 0) {\n      if (errno == EMSGSIZE) {\n        return memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n      }\n\n      return memcached_set_errno(*instance, errno, MEMCACHED_AT);\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n#else\n  (void) instance;\n  (void) vector;\n  (void) count;\n  return MEMCACHED_FAILURE;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_udp",
          "args": [
            "instance->root"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "instance->error_messages",
            "\"memcached_connect() returned an error but the Instance showed none.\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ERROR",
          "args": [
            "rc"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = memcached_connect(instance)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_connect",
          "args": [
            "instance"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
          "lines": "598-600",
          "snippet": "memcached_return_t memcached_connect(memcached_instance_st *server) {\n  return _memcached_connect(server, true);\n}",
          "includes": [
            "#include <cassert>",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_connect(memcached_instance_st *server) {\n  return _memcached_connect(server, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "vector",
            "\"Invalid vector passed\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}"
  },
  {
    "function_name": "_vdo_udp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/do.cc",
    "lines": "18-62",
    "snippet": "static memcached_return_t _vdo_udp(memcached_instance_st *instance,\n                                   libmemcached_io_vector_st vector[], const size_t count) {\n#if HAVE_SENDMSG && HAVE_STRUCT_MSGHDR\n  if (vector[0].buffer or vector[0].length) {\n    return memcached_set_error(\n        *instance->root, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"UDP messages was attempted, but vector was not setup for it\"));\n  }\n\n  struct msghdr msg;\n  memset(&msg, 0, sizeof(msg));\n\n  increment_udp_message_id(instance);\n  vector[0].buffer = instance->write_buffer;\n  vector[0].length = UDP_DATAGRAM_HEADER_LENGTH;\n\n  msg.msg_iov = (struct iovec *) vector;\n#  ifdef __APPLE__\n  msg.msg_iovlen = int(count);\n#  else\n  msg.msg_iovlen = count;\n#  endif\n\n  uint32_t retry = 5;\n  while (--retry) {\n    ssize_t sendmsg_length = ::sendmsg(instance->fd, &msg, 0);\n    if (sendmsg_length > 0) {\n      break;\n    } else if (sendmsg_length < 0) {\n      if (errno == EMSGSIZE) {\n        return memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n      }\n\n      return memcached_set_errno(*instance, errno, MEMCACHED_AT);\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n#else\n  (void) instance;\n  (void) vector;\n  (void) count;\n  return MEMCACHED_FAILURE;\n#endif\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_errno",
          "args": [
            "*instance",
            "errno",
            "MEMCACHED_AT"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "378-398",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*instance",
            "MEMCACHED_WRITE_FAILURE",
            "MEMCACHED_AT"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "::sendmsg",
          "args": [
            "instance->fd",
            "&msg",
            "0"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "count"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "414-427",
          "snippet": "void memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "increment_udp_message_id",
          "args": [
            "instance"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "increment_udp_message_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/udp.cc",
          "lines": "29-39",
          "snippet": "void increment_udp_message_id(memcached_instance_st *ptr) {\n  struct udp_datagram_header_st *header = (struct udp_datagram_header_st *) ptr->write_buffer;\n  uint16_t cur_req = get_udp_datagram_request_id(header);\n  int msg_num = get_msg_num_from_request_id(cur_req);\n  int thread_id = get_thread_id_from_request_id(cur_req);\n\n  if (((++msg_num) & UDP_REQUEST_ID_THREAD_MASK))\n    msg_num = 0;\n\n  header->request_id = htons((uint16_t)(thread_id | msg_num));\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid increment_udp_message_id(memcached_instance_st *ptr) {\n  struct udp_datagram_header_st *header = (struct udp_datagram_header_st *) ptr->write_buffer;\n  uint16_t cur_req = get_udp_datagram_request_id(header);\n  int msg_num = get_msg_num_from_request_id(cur_req);\n  int thread_id = get_thread_id_from_request_id(cur_req);\n\n  if (((++msg_num) & UDP_REQUEST_ID_THREAD_MASK))\n    msg_num = 0;\n\n  header->request_id = htons((uint16_t)(thread_id | msg_num));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&msg",
            "0",
            "sizeof(msg)"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"UDP messages was attempted, but vector was not setup for it\""
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t _vdo_udp(memcached_instance_st *instance,\n                                   libmemcached_io_vector_st vector[], const size_t count) {\n#if HAVE_SENDMSG && HAVE_STRUCT_MSGHDR\n  if (vector[0].buffer or vector[0].length) {\n    return memcached_set_error(\n        *instance->root, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT,\n        memcached_literal_param(\"UDP messages was attempted, but vector was not setup for it\"));\n  }\n\n  struct msghdr msg;\n  memset(&msg, 0, sizeof(msg));\n\n  increment_udp_message_id(instance);\n  vector[0].buffer = instance->write_buffer;\n  vector[0].length = UDP_DATAGRAM_HEADER_LENGTH;\n\n  msg.msg_iov = (struct iovec *) vector;\n#  ifdef __APPLE__\n  msg.msg_iovlen = int(count);\n#  else\n  msg.msg_iovlen = count;\n#  endif\n\n  uint32_t retry = 5;\n  while (--retry) {\n    ssize_t sendmsg_length = ::sendmsg(instance->fd, &msg, 0);\n    if (sendmsg_length > 0) {\n      break;\n    } else if (sendmsg_length < 0) {\n      if (errno == EMSGSIZE) {\n        return memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n      }\n\n      return memcached_set_errno(*instance, errno, MEMCACHED_AT);\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n#else\n  (void) instance;\n  (void) vector;\n  (void) count;\n  return MEMCACHED_FAILURE;\n#endif\n}"
  }
]