[
  {
    "function_name": "memcached_quit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
    "lines": "109-117",
    "snippet": "void memcached_quit(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(memc, true))) {\n    return;\n  }\n\n  send_quit(memc);\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_quit",
          "args": [
            "memc"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "send_quit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
          "lines": "101-107",
          "snippet": "void send_quit(Memcached *memc) {\n  for (uint32_t x = 0; x < memcached_server_count(memc); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(memc, x);\n\n    memcached_quit_server(instance, false);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid send_quit(Memcached *memc) {\n  for (uint32_t x = 0; x < memcached_server_count(memc); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(memc, x);\n\n    memcached_quit_server(instance, false);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = initialize_query(memc, true)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_query",
          "args": [
            "memc",
            "true"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/initialize_query.cc",
          "lines": "18-39",
          "snippet": "memcached_return_t initialize_query(Memcached *self, bool increment_query_id) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (increment_query_id) {\n    self->query_id++;\n  }\n\n  if (self->state.is_time_for_rebuild) {\n    memcached_reset(self);\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return memcached_set_error(*self, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  memcached_error_free(*self);\n  memcached_result_reset(&self->result);\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t initialize_query(Memcached *self, bool increment_query_id) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (increment_query_id) {\n    self->query_id++;\n  }\n\n  if (self->state.is_time_for_rebuild) {\n    memcached_reset(self);\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return memcached_set_error(*self, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  memcached_error_free(*self);\n  memcached_result_reset(&self->result);\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_quit(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  memcached_return_t rc;\n  if (memcached_failed(rc = initialize_query(memc, true))) {\n    return;\n  }\n\n  send_quit(memc);\n}"
  },
  {
    "function_name": "send_quit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
    "lines": "101-107",
    "snippet": "void send_quit(Memcached *memc) {\n  for (uint32_t x = 0; x < memcached_server_count(memc); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(memc, x);\n\n    memcached_quit_server(instance, false);\n  }\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_quit_server",
          "args": [
            "instance",
            "false"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_quit_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
          "lines": "75-99",
          "snippet": "void memcached_quit_server(memcached_instance_st *instance, bool io_death) {\n  if (instance->valid()) {\n    if (io_death == false and memcached_is_udp(instance->root) == false\n        and instance->is_shutting_down() == false)\n    {\n      send_quit_message(instance);\n\n      instance->start_close_socket();\n      drain_instance(instance);\n    }\n  }\n\n  instance->close_socket();\n\n  if (io_death and memcached_is_udp(instance->root)) {\n    /*\n       If using UDP, we should stop using the server briefly on every IO\n       failure. If using TCP, it may be that the connection went down a\n       short while ago (e.g. the server failed) and we've only just\n       noticed, so we should only set the retry timeout on a connect\n       failure (which doesn't call this method).\n       */\n    memcached_mark_server_for_timeout(instance);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_quit_server(memcached_instance_st *instance, bool io_death) {\n  if (instance->valid()) {\n    if (io_death == false and memcached_is_udp(instance->root) == false\n        and instance->is_shutting_down() == false)\n    {\n      send_quit_message(instance);\n\n      instance->start_close_socket();\n      drain_instance(instance);\n    }\n  }\n\n  instance->close_socket();\n\n  if (io_death and memcached_is_udp(instance->root)) {\n    /*\n       If using UDP, we should stop using the server briefly on every IO\n       failure. If using TCP, it may be that the connection went down a\n       short while ago (e.g. the server failed) and we've only just\n       noticed, so we should only set the retry timeout on a connect\n       failure (which doesn't call this method).\n       */\n    memcached_mark_server_for_timeout(instance);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "memc",
            "x"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "memc"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid send_quit(Memcached *memc) {\n  for (uint32_t x = 0; x < memcached_server_count(memc); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(memc, x);\n\n    memcached_quit_server(instance, false);\n  }\n}"
  },
  {
    "function_name": "memcached_quit_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
    "lines": "75-99",
    "snippet": "void memcached_quit_server(memcached_instance_st *instance, bool io_death) {\n  if (instance->valid()) {\n    if (io_death == false and memcached_is_udp(instance->root) == false\n        and instance->is_shutting_down() == false)\n    {\n      send_quit_message(instance);\n\n      instance->start_close_socket();\n      drain_instance(instance);\n    }\n  }\n\n  instance->close_socket();\n\n  if (io_death and memcached_is_udp(instance->root)) {\n    /*\n       If using UDP, we should stop using the server briefly on every IO\n       failure. If using TCP, it may be that the connection went down a\n       short while ago (e.g. the server failed) and we've only just\n       noticed, so we should only set the retry timeout on a connect\n       failure (which doesn't call this method).\n       */\n    memcached_mark_server_for_timeout(instance);\n  }\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_mark_server_for_timeout",
          "args": [
            "instance"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_mark_server_for_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.hpp",
          "lines": "44-67",
          "snippet": "static inline void memcached_mark_server_for_timeout(memcached_instance_st *server) {\n  if (server->state != MEMCACHED_SERVER_STATE_IN_TIMEOUT) {\n    if (server->server_timeout_counter_query_id != server->root->query_id) {\n      server->server_timeout_counter++;\n      server->server_timeout_counter_query_id = server->root->query_id;\n    }\n\n    if (server->server_timeout_counter >= server->root->server_timeout_limit) {\n      struct timeval next_time;\n      if (gettimeofday(&next_time, NULL) == 0) {\n        server->next_retry = next_time.tv_sec + server->root->retry_timeout;\n      } else {\n        server->next_retry = 1; // Setting the value to 1 causes the timeout to occur immediately\n      }\n\n      server->state = MEMCACHED_SERVER_STATE_IN_TIMEOUT;\n      if (server->server_failure_counter_query_id != server->root->query_id) {\n        server->server_failure_counter++;\n        server->server_failure_counter_query_id = server->root->query_id;\n      }\n      set_last_disconnected_host(server);\n    }\n  }\n}",
          "includes": [
            "#include <cassert>",
            "#include \"p9y/gettimeofday.hpp\""
          ],
          "macros_used": [],
          "globals_used": [
            "void memcached_instance_free(memcached_instance_st *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"p9y/gettimeofday.hpp\"\n\nvoid memcached_instance_free(memcached_instance_st *);\n\nstatic inline void memcached_mark_server_for_timeout(memcached_instance_st *server) {\n  if (server->state != MEMCACHED_SERVER_STATE_IN_TIMEOUT) {\n    if (server->server_timeout_counter_query_id != server->root->query_id) {\n      server->server_timeout_counter++;\n      server->server_timeout_counter_query_id = server->root->query_id;\n    }\n\n    if (server->server_timeout_counter >= server->root->server_timeout_limit) {\n      struct timeval next_time;\n      if (gettimeofday(&next_time, NULL) == 0) {\n        server->next_retry = next_time.tv_sec + server->root->retry_timeout;\n      } else {\n        server->next_retry = 1; // Setting the value to 1 causes the timeout to occur immediately\n      }\n\n      server->state = MEMCACHED_SERVER_STATE_IN_TIMEOUT;\n      if (server->server_failure_counter_query_id != server->root->query_id) {\n        server->server_failure_counter++;\n        server->server_failure_counter_query_id = server->root->query_id;\n      }\n      set_last_disconnected_host(server);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_udp",
          "args": [
            "instance->root"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instance->close_socket",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "close_socket",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "647-677",
          "snippet": "void memcached_instance_st::close_socket() {\n  if (fd != INVALID_SOCKET) {\n    int shutdown_options = SHUT_RD;\n    if (options.is_shutting_down == false) {\n      shutdown_options = SHUT_RDWR;\n    }\n\n    /* in case of death shutdown to avoid blocking at close() */\n    if (shutdown(fd, shutdown_options) == SOCKET_ERROR and get_socket_errno() != ENOTCONN) {\n      WATCHPOINT_NUMBER(fd);\n      WATCHPOINT_ERRNO(get_socket_errno());\n      WATCHPOINT_ASSERT(get_socket_errno());\n    }\n\n    reset_socket();\n    state = MEMCACHED_SERVER_STATE_NEW;\n  }\n\n  state = MEMCACHED_SERVER_STATE_NEW;\n  cursor_active_ = 0;\n  io_bytes_sent = 0;\n  write_buffer_offset = size_t(root and memcached_is_udp(root) ? UDP_DATAGRAM_HEADER_LENGTH : 0);\n  read_buffer_length = 0;\n  read_ptr = read_buffer;\n  options.is_shutting_down = false;\n  memcached_server_response_reset(this);\n\n  // We reset the version so that if we end up talking to a different server\n  // we don't have stale server version information.\n  major_version = minor_version = micro_version = UINT8_MAX;\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_instance_st {\n  void memcached_instance_st::close_socket() {\n    if (fd != INVALID_SOCKET) {\n      int shutdown_options = SHUT_RD;\n      if (options.is_shutting_down == false) {\n        shutdown_options = SHUT_RDWR;\n      }\n  \n      /* in case of death shutdown to avoid blocking at close() */\n      if (shutdown(fd, shutdown_options) == SOCKET_ERROR and get_socket_errno() != ENOTCONN) {\n        WATCHPOINT_NUMBER(fd);\n        WATCHPOINT_ERRNO(get_socket_errno());\n        WATCHPOINT_ASSERT(get_socket_errno());\n      }\n  \n      reset_socket();\n      state = MEMCACHED_SERVER_STATE_NEW;\n    }\n  \n    state = MEMCACHED_SERVER_STATE_NEW;\n    cursor_active_ = 0;\n    io_bytes_sent = 0;\n    write_buffer_offset = size_t(root and memcached_is_udp(root) ? UDP_DATAGRAM_HEADER_LENGTH : 0);\n    read_buffer_length = 0;\n    read_ptr = read_buffer;\n    options.is_shutting_down = false;\n    memcached_server_response_reset(this);\n  \n    // We reset the version so that if we end up talking to a different server\n    // we don't have stale server version information.\n    major_version = minor_version = micro_version = UINT8_MAX;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "drain_instance",
          "args": [
            "instance"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "drain_instance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
          "lines": "41-63",
          "snippet": "void drain_instance(memcached_instance_st *instance) {\n  /* read until socket is closed, or there is an error\n   * closing the socket before all data is read\n   * results in server throwing away all data which is\n   * not read\n   *\n   * In .40 we began to only do this if we had been doing buffered\n   * requests of had replication enabled.\n   */\n  if (instance->root->flags.buffer_requests or instance->root->number_of_replicas) {\n    memcached_io_slurp(instance);\n  }\n\n  /*\n   * memcached_io_read may call memcached_quit_server with io_death if\n   * it encounters problems, but we don't care about those occurences.\n   * The intention of that loop is to drain the data sent from the\n   * server to ensure that the server processed all of the data we\n   * sent to the server.\n   */\n  instance->server_failure_counter = 0;\n  instance->server_timeout_counter = 0;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid drain_instance(memcached_instance_st *instance) {\n  /* read until socket is closed, or there is an error\n   * closing the socket before all data is read\n   * results in server throwing away all data which is\n   * not read\n   *\n   * In .40 we began to only do this if we had been doing buffered\n   * requests of had replication enabled.\n   */\n  if (instance->root->flags.buffer_requests or instance->root->number_of_replicas) {\n    memcached_io_slurp(instance);\n  }\n\n  /*\n   * memcached_io_read may call memcached_quit_server with io_death if\n   * it encounters problems, but we don't care about those occurences.\n   * The intention of that loop is to drain the data sent from the\n   * server to ensure that the server processed all of the data we\n   * sent to the server.\n   */\n  instance->server_failure_counter = 0;\n  instance->server_timeout_counter = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "instance->start_close_socket",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "start_close_socket",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "633-638",
          "snippet": "void memcached_instance_st::start_close_socket() {\n  if (fd != INVALID_SOCKET) {\n    shutdown(fd, SHUT_WR);\n    options.is_shutting_down = true;\n  }\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_instance_st {\n  void memcached_instance_st::start_close_socket() {\n    if (fd != INVALID_SOCKET) {\n      shutdown(fd, SHUT_WR);\n      options.is_shutting_down = true;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_quit_message",
          "args": [
            "instance"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "send_quit_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
          "lines": "19-39",
          "snippet": "memcached_return_t send_quit_message(memcached_instance_st *instance) {\n  memcached_return_t rc;\n  if (instance->root->flags.binary_protocol) {\n    protocol_binary_request_quit request = {}; // = {.bytes= {0}};\n\n    initialize_binary_request(instance, request.message.header);\n\n    request.message.header.request.opcode = PROTOCOL_BINARY_CMD_QUIT;\n    request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n\n    libmemcached_io_vector_st vector[] = {{request.bytes, sizeof(request.bytes)}};\n\n    rc = memcached_vdo(instance, vector, 1, true);\n  } else {\n    libmemcached_io_vector_st vector[] = {{memcached_literal_param(\"quit\\r\\n\")}};\n\n    rc = memcached_vdo(instance, vector, 1, true);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t send_quit_message(memcached_instance_st *instance) {\n  memcached_return_t rc;\n  if (instance->root->flags.binary_protocol) {\n    protocol_binary_request_quit request = {}; // = {.bytes= {0}};\n\n    initialize_binary_request(instance, request.message.header);\n\n    request.message.header.request.opcode = PROTOCOL_BINARY_CMD_QUIT;\n    request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n\n    libmemcached_io_vector_st vector[] = {{request.bytes, sizeof(request.bytes)}};\n\n    rc = memcached_vdo(instance, vector, 1, true);\n  } else {\n    libmemcached_io_vector_st vector[] = {{memcached_literal_param(\"quit\\r\\n\")}};\n\n    rc = memcached_vdo(instance, vector, 1, true);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "instance->is_shutting_down",
          "args": [],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "is_shutting_down",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
          "lines": "280-282",
          "snippet": "bool memcached_instance_st::is_shutting_down() const {\n  return options.is_shutting_down;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_instance_st {\n  bool memcached_instance_st::is_shutting_down() const {\n    return options.is_shutting_down;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_udp",
          "args": [
            "instance->root"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instance->valid",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "valid",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
          "lines": "272-278",
          "snippet": "bool memcached_instance_st::valid() const {\n  if (fd == INVALID_SOCKET) {\n    return false;\n  }\n\n  return true;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_instance_st {\n  bool memcached_instance_st::valid() const {\n    if (fd == INVALID_SOCKET) {\n      return false;\n    }\n  \n    return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_quit_server(memcached_instance_st *instance, bool io_death) {\n  if (instance->valid()) {\n    if (io_death == false and memcached_is_udp(instance->root) == false\n        and instance->is_shutting_down() == false)\n    {\n      send_quit_message(instance);\n\n      instance->start_close_socket();\n      drain_instance(instance);\n    }\n  }\n\n  instance->close_socket();\n\n  if (io_death and memcached_is_udp(instance->root)) {\n    /*\n       If using UDP, we should stop using the server briefly on every IO\n       failure. If using TCP, it may be that the connection went down a\n       short while ago (e.g. the server failed) and we've only just\n       noticed, so we should only set the retry timeout on a connect\n       failure (which doesn't call this method).\n       */\n    memcached_mark_server_for_timeout(instance);\n  }\n}"
  },
  {
    "function_name": "drain_instance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
    "lines": "41-63",
    "snippet": "void drain_instance(memcached_instance_st *instance) {\n  /* read until socket is closed, or there is an error\n   * closing the socket before all data is read\n   * results in server throwing away all data which is\n   * not read\n   *\n   * In .40 we began to only do this if we had been doing buffered\n   * requests of had replication enabled.\n   */\n  if (instance->root->flags.buffer_requests or instance->root->number_of_replicas) {\n    memcached_io_slurp(instance);\n  }\n\n  /*\n   * memcached_io_read may call memcached_quit_server with io_death if\n   * it encounters problems, but we don't care about those occurences.\n   * The intention of that loop is to drain the data sent from the\n   * server to ensure that the server processed all of the data we\n   * sent to the server.\n   */\n  instance->server_failure_counter = 0;\n  instance->server_timeout_counter = 0;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_io_slurp",
          "args": [
            "instance"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_slurp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "493-544",
          "snippet": "memcached_return_t memcached_io_slurp(memcached_instance_st *instance) {\n  assert_msg(instance, \"Programmer error, invalid Instance\");\n  assert(memcached_is_udp(instance->root) == false);\n\n  if (instance->fd == INVALID_SOCKET) {\n    assert_msg(int(instance->state) <= int(MEMCACHED_SERVER_STATE_ADDRINFO),\n               \"Invalid socket state\");\n    return MEMCACHED_CONNECTION_FAILURE;\n  }\n\n  ssize_t data_read;\n  char buffer[MEMCACHED_MAX_BUFFER];\n  do {\n    data_read = ::recv(instance->fd, instance->read_buffer, sizeof(buffer), MSG_NOSIGNAL);\n    if (data_read == SOCKET_ERROR) {\n      switch (get_socket_errno()) {\n      case EINTR: // We just retry\n        continue;\n\n      case ETIMEDOUT: // OSX\n#if EWOULDBLOCK != EAGAIN\n      case EWOULDBLOCK:\n#endif\n      case EAGAIN:\n#ifdef ERESTART\n      case ERESTART:\n#endif\n        if (memcached_success(io_wait(instance, POLLIN))) {\n          continue;\n        }\n        return MEMCACHED_IN_PROGRESS;\n\n        /* fall through */\n\n      case ENOTCONN: // Programmer Error\n      case ENOTSOCK:\n        assert(0);\n        /* fall through */\n      case EBADF:\n        assert_msg(instance->fd != INVALID_SOCKET, \"Invalid socket state\");\n        /* fall through */\n      case EINVAL:\n      case EFAULT:\n      case ECONNREFUSED:\n      default:\n        return MEMCACHED_CONNECTION_FAILURE; // We want this!\n      }\n    }\n  } while (data_read > 0);\n\n  return MEMCACHED_CONNECTION_FAILURE;\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_io_slurp(memcached_instance_st *instance) {\n  assert_msg(instance, \"Programmer error, invalid Instance\");\n  assert(memcached_is_udp(instance->root) == false);\n\n  if (instance->fd == INVALID_SOCKET) {\n    assert_msg(int(instance->state) <= int(MEMCACHED_SERVER_STATE_ADDRINFO),\n               \"Invalid socket state\");\n    return MEMCACHED_CONNECTION_FAILURE;\n  }\n\n  ssize_t data_read;\n  char buffer[MEMCACHED_MAX_BUFFER];\n  do {\n    data_read = ::recv(instance->fd, instance->read_buffer, sizeof(buffer), MSG_NOSIGNAL);\n    if (data_read == SOCKET_ERROR) {\n      switch (get_socket_errno()) {\n      case EINTR: // We just retry\n        continue;\n\n      case ETIMEDOUT: // OSX\n#if EWOULDBLOCK != EAGAIN\n      case EWOULDBLOCK:\n#endif\n      case EAGAIN:\n#ifdef ERESTART\n      case ERESTART:\n#endif\n        if (memcached_success(io_wait(instance, POLLIN))) {\n          continue;\n        }\n        return MEMCACHED_IN_PROGRESS;\n\n        /* fall through */\n\n      case ENOTCONN: // Programmer Error\n      case ENOTSOCK:\n        assert(0);\n        /* fall through */\n      case EBADF:\n        assert_msg(instance->fd != INVALID_SOCKET, \"Invalid socket state\");\n        /* fall through */\n      case EINVAL:\n      case EFAULT:\n      case ECONNREFUSED:\n      default:\n        return MEMCACHED_CONNECTION_FAILURE; // We want this!\n      }\n    }\n  } while (data_read > 0);\n\n  return MEMCACHED_CONNECTION_FAILURE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid drain_instance(memcached_instance_st *instance) {\n  /* read until socket is closed, or there is an error\n   * closing the socket before all data is read\n   * results in server throwing away all data which is\n   * not read\n   *\n   * In .40 we began to only do this if we had been doing buffered\n   * requests of had replication enabled.\n   */\n  if (instance->root->flags.buffer_requests or instance->root->number_of_replicas) {\n    memcached_io_slurp(instance);\n  }\n\n  /*\n   * memcached_io_read may call memcached_quit_server with io_death if\n   * it encounters problems, but we don't care about those occurences.\n   * The intention of that loop is to drain the data sent from the\n   * server to ensure that the server processed all of the data we\n   * sent to the server.\n   */\n  instance->server_failure_counter = 0;\n  instance->server_timeout_counter = 0;\n}"
  },
  {
    "function_name": "send_quit_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
    "lines": "19-39",
    "snippet": "memcached_return_t send_quit_message(memcached_instance_st *instance) {\n  memcached_return_t rc;\n  if (instance->root->flags.binary_protocol) {\n    protocol_binary_request_quit request = {}; // = {.bytes= {0}};\n\n    initialize_binary_request(instance, request.message.header);\n\n    request.message.header.request.opcode = PROTOCOL_BINARY_CMD_QUIT;\n    request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n\n    libmemcached_io_vector_st vector[] = {{request.bytes, sizeof(request.bytes)}};\n\n    rc = memcached_vdo(instance, vector, 1, true);\n  } else {\n    libmemcached_io_vector_st vector[] = {{memcached_literal_param(\"quit\\r\\n\")}};\n\n    rc = memcached_vdo(instance, vector, 1, true);\n  }\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_vdo",
          "args": [
            "instance",
            "vector",
            "1",
            "true"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_vdo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/do.cc",
          "lines": "64-100",
          "snippet": "memcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"quit\\r\\n\""
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_binary_request",
          "args": [
            "instance",
            "request.message.header"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_binary_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "20-25",
          "snippet": "void initialize_binary_request(memcached_instance_st *server,\n                               protocol_binary_request_header &header) {\n  server->request_id++;\n  header.request.magic = PROTOCOL_BINARY_REQ;\n  header.request.opaque = htons(server->request_id);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid initialize_binary_request(memcached_instance_st *server,\n                               protocol_binary_request_header &header) {\n  server->request_id++;\n  header.request.magic = PROTOCOL_BINARY_REQ;\n  header.request.opaque = htons(server->request_id);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t send_quit_message(memcached_instance_st *instance) {\n  memcached_return_t rc;\n  if (instance->root->flags.binary_protocol) {\n    protocol_binary_request_quit request = {}; // = {.bytes= {0}};\n\n    initialize_binary_request(instance, request.message.header);\n\n    request.message.header.request.opcode = PROTOCOL_BINARY_CMD_QUIT;\n    request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n\n    libmemcached_io_vector_st vector[] = {{request.bytes, sizeof(request.bytes)}};\n\n    rc = memcached_vdo(instance, vector, 1, true);\n  } else {\n    libmemcached_io_vector_st vector[] = {{memcached_literal_param(\"quit\\r\\n\")}};\n\n    rc = memcached_vdo(instance, vector, 1, true);\n  }\n\n  return rc;\n}"
  }
]