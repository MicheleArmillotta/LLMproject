[
  {
    "function_name": "memcached_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
    "lines": "598-600",
    "snippet": "memcached_return_t memcached_connect(memcached_instance_st *server) {\n  return _memcached_connect(server, true);\n}",
    "includes": [
      "#include <cassert>",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_memcached_connect",
          "args": [
            "server",
            "true"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "_memcached_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
          "lines": "518-596",
          "snippet": "static memcached_return_t _memcached_connect(memcached_instance_st *server,\n                                             const bool set_last_disconnected) {\n  assert(server);\n  if (server->fd != INVALID_SOCKET) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  LIBMEMCACHED_MEMCACHED_CONNECT_START();\n\n  bool in_timeout = false;\n  memcached_return_t rc;\n  if (memcached_failed(rc = backoff_handling(server, in_timeout))) {\n    set_last_disconnected_host(server);\n    return rc;\n  }\n\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT and server->root->sasl.callbacks\n      and memcached_is_udp(server->root))\n  {\n    return memcached_set_error(\n        *server, MEMCACHED_INVALID_HOST_PROTOCOL, MEMCACHED_AT,\n        memcached_literal_param(\"SASL is not supported for UDP connections\"));\n  }\n\n  if (server->hostname()[0] == '/') {\n    server->type = MEMCACHED_CONNECTION_UNIX_SOCKET;\n  }\n\n  /* We need to clean up the multi startup piece */\n  switch (server->type) {\n  case MEMCACHED_CONNECTION_UDP:\n  case MEMCACHED_CONNECTION_TCP:\n    rc = network_connect(server);\n\n#if defined(LIBMEMCACHED_WITH_SASL_SUPPORT)\n    if (LIBMEMCACHED_WITH_SASL_SUPPORT) {\n      if (server->fd != INVALID_SOCKET and server->root->sasl.callbacks) {\n        rc = memcached_sasl_authenticate_connection(server);\n        if (memcached_failed(rc) and server->fd != INVALID_SOCKET) {\n          WATCHPOINT_ASSERT(server->fd != INVALID_SOCKET);\n          server->reset_socket();\n        }\n      }\n    }\n#endif\n    break;\n\n  case MEMCACHED_CONNECTION_UNIX_SOCKET:\n    rc = unix_socket_connect(server);\n    break;\n  }\n\n  if (memcached_success(rc)) {\n    server->mark_server_as_clean();\n    memcached_version_instance(server);\n    return rc;\n  } else if (set_last_disconnected) {\n    set_last_disconnected_host(server);\n    if (memcached_has_current_error(*server)) {\n      memcached_mark_server_for_timeout(server);\n      assert(memcached_failed(memcached_instance_error_return(server)));\n    } else {\n      memcached_set_error(*server, rc, MEMCACHED_AT);\n      memcached_mark_server_for_timeout(server);\n    }\n\n    LIBMEMCACHED_MEMCACHED_CONNECT_END();\n\n    if (in_timeout) {\n      char buffer[1024];\n      int snprintf_length =\n          snprintf(buffer, sizeof(buffer), \"%s:%d\", server->hostname(), int(server->port()));\n      return memcached_set_error(*server, MEMCACHED_SERVER_TEMPORARILY_DISABLED, MEMCACHED_AT,\n                                 buffer, snprintf_length);\n    }\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t _memcached_connect(memcached_instance_st *server,\n                                             const bool set_last_disconnected) {\n  assert(server);\n  if (server->fd != INVALID_SOCKET) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  LIBMEMCACHED_MEMCACHED_CONNECT_START();\n\n  bool in_timeout = false;\n  memcached_return_t rc;\n  if (memcached_failed(rc = backoff_handling(server, in_timeout))) {\n    set_last_disconnected_host(server);\n    return rc;\n  }\n\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT and server->root->sasl.callbacks\n      and memcached_is_udp(server->root))\n  {\n    return memcached_set_error(\n        *server, MEMCACHED_INVALID_HOST_PROTOCOL, MEMCACHED_AT,\n        memcached_literal_param(\"SASL is not supported for UDP connections\"));\n  }\n\n  if (server->hostname()[0] == '/') {\n    server->type = MEMCACHED_CONNECTION_UNIX_SOCKET;\n  }\n\n  /* We need to clean up the multi startup piece */\n  switch (server->type) {\n  case MEMCACHED_CONNECTION_UDP:\n  case MEMCACHED_CONNECTION_TCP:\n    rc = network_connect(server);\n\n#if defined(LIBMEMCACHED_WITH_SASL_SUPPORT)\n    if (LIBMEMCACHED_WITH_SASL_SUPPORT) {\n      if (server->fd != INVALID_SOCKET and server->root->sasl.callbacks) {\n        rc = memcached_sasl_authenticate_connection(server);\n        if (memcached_failed(rc) and server->fd != INVALID_SOCKET) {\n          WATCHPOINT_ASSERT(server->fd != INVALID_SOCKET);\n          server->reset_socket();\n        }\n      }\n    }\n#endif\n    break;\n\n  case MEMCACHED_CONNECTION_UNIX_SOCKET:\n    rc = unix_socket_connect(server);\n    break;\n  }\n\n  if (memcached_success(rc)) {\n    server->mark_server_as_clean();\n    memcached_version_instance(server);\n    return rc;\n  } else if (set_last_disconnected) {\n    set_last_disconnected_host(server);\n    if (memcached_has_current_error(*server)) {\n      memcached_mark_server_for_timeout(server);\n      assert(memcached_failed(memcached_instance_error_return(server)));\n    } else {\n      memcached_set_error(*server, rc, MEMCACHED_AT);\n      memcached_mark_server_for_timeout(server);\n    }\n\n    LIBMEMCACHED_MEMCACHED_CONNECT_END();\n\n    if (in_timeout) {\n      char buffer[1024];\n      int snprintf_length =\n          snprintf(buffer, sizeof(buffer), \"%s:%d\", server->hostname(), int(server->port()));\n      return memcached_set_error(*server, MEMCACHED_SERVER_TEMPORARILY_DISABLED, MEMCACHED_AT,\n                                 buffer, snprintf_length);\n    }\n  }\n\n  return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_connect(memcached_instance_st *server) {\n  return _memcached_connect(server, true);\n}"
  },
  {
    "function_name": "_memcached_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
    "lines": "518-596",
    "snippet": "static memcached_return_t _memcached_connect(memcached_instance_st *server,\n                                             const bool set_last_disconnected) {\n  assert(server);\n  if (server->fd != INVALID_SOCKET) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  LIBMEMCACHED_MEMCACHED_CONNECT_START();\n\n  bool in_timeout = false;\n  memcached_return_t rc;\n  if (memcached_failed(rc = backoff_handling(server, in_timeout))) {\n    set_last_disconnected_host(server);\n    return rc;\n  }\n\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT and server->root->sasl.callbacks\n      and memcached_is_udp(server->root))\n  {\n    return memcached_set_error(\n        *server, MEMCACHED_INVALID_HOST_PROTOCOL, MEMCACHED_AT,\n        memcached_literal_param(\"SASL is not supported for UDP connections\"));\n  }\n\n  if (server->hostname()[0] == '/') {\n    server->type = MEMCACHED_CONNECTION_UNIX_SOCKET;\n  }\n\n  /* We need to clean up the multi startup piece */\n  switch (server->type) {\n  case MEMCACHED_CONNECTION_UDP:\n  case MEMCACHED_CONNECTION_TCP:\n    rc = network_connect(server);\n\n#if defined(LIBMEMCACHED_WITH_SASL_SUPPORT)\n    if (LIBMEMCACHED_WITH_SASL_SUPPORT) {\n      if (server->fd != INVALID_SOCKET and server->root->sasl.callbacks) {\n        rc = memcached_sasl_authenticate_connection(server);\n        if (memcached_failed(rc) and server->fd != INVALID_SOCKET) {\n          WATCHPOINT_ASSERT(server->fd != INVALID_SOCKET);\n          server->reset_socket();\n        }\n      }\n    }\n#endif\n    break;\n\n  case MEMCACHED_CONNECTION_UNIX_SOCKET:\n    rc = unix_socket_connect(server);\n    break;\n  }\n\n  if (memcached_success(rc)) {\n    server->mark_server_as_clean();\n    memcached_version_instance(server);\n    return rc;\n  } else if (set_last_disconnected) {\n    set_last_disconnected_host(server);\n    if (memcached_has_current_error(*server)) {\n      memcached_mark_server_for_timeout(server);\n      assert(memcached_failed(memcached_instance_error_return(server)));\n    } else {\n      memcached_set_error(*server, rc, MEMCACHED_AT);\n      memcached_mark_server_for_timeout(server);\n    }\n\n    LIBMEMCACHED_MEMCACHED_CONNECT_END();\n\n    if (in_timeout) {\n      char buffer[1024];\n      int snprintf_length =\n          snprintf(buffer, sizeof(buffer), \"%s:%d\", server->hostname(), int(server->port()));\n      return memcached_set_error(*server, MEMCACHED_SERVER_TEMPORARILY_DISABLED, MEMCACHED_AT,\n                                 buffer, snprintf_length);\n    }\n  }\n\n  return rc;\n}",
    "includes": [
      "#include <cassert>",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*server",
            "MEMCACHED_SERVER_TEMPORARILY_DISABLED",
            "MEMCACHED_AT",
            "buffer",
            "snprintf_length"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "183-192",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, const char *str, size_t length) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(rc != MEMCACHED_SOME_ERRORS,\n             \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a Instance\");\n\n  memcached_string_t tmp = {str, length};\n  return memcached_set_error(self, rc, at, tmp);\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, const char *str, size_t length) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(rc != MEMCACHED_SOME_ERRORS,\n             \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a Instance\");\n\n  memcached_string_t tmp = {str, length};\n  return memcached_set_error(self, rc, at, tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"%s:%d\"",
            "server->hostname()",
            "int(server->port())"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "server->port()"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "414-427",
          "snippet": "void memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->port",
          "args": [],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "port",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.hpp",
          "lines": "40-40",
          "snippet": "in_port_t port() const { return port_; }",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#    include <netdb.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#    include <netdb.h>\n\nmemcached_instance_st {\n  in_port_t port() const { return port_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->hostname",
          "args": [],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_CONNECT_END",
          "args": [],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_mark_server_for_timeout",
          "args": [
            "server"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_mark_server_for_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.hpp",
          "lines": "44-67",
          "snippet": "static inline void memcached_mark_server_for_timeout(memcached_instance_st *server) {\n  if (server->state != MEMCACHED_SERVER_STATE_IN_TIMEOUT) {\n    if (server->server_timeout_counter_query_id != server->root->query_id) {\n      server->server_timeout_counter++;\n      server->server_timeout_counter_query_id = server->root->query_id;\n    }\n\n    if (server->server_timeout_counter >= server->root->server_timeout_limit) {\n      struct timeval next_time;\n      if (gettimeofday(&next_time, NULL) == 0) {\n        server->next_retry = next_time.tv_sec + server->root->retry_timeout;\n      } else {\n        server->next_retry = 1; // Setting the value to 1 causes the timeout to occur immediately\n      }\n\n      server->state = MEMCACHED_SERVER_STATE_IN_TIMEOUT;\n      if (server->server_failure_counter_query_id != server->root->query_id) {\n        server->server_failure_counter++;\n        server->server_failure_counter_query_id = server->root->query_id;\n      }\n      set_last_disconnected_host(server);\n    }\n  }\n}",
          "includes": [
            "#include <cassert>",
            "#include \"p9y/gettimeofday.hpp\""
          ],
          "macros_used": [],
          "globals_used": [
            "void memcached_instance_free(memcached_instance_st *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"p9y/gettimeofday.hpp\"\n\nvoid memcached_instance_free(memcached_instance_st *);\n\nstatic inline void memcached_mark_server_for_timeout(memcached_instance_st *server) {\n  if (server->state != MEMCACHED_SERVER_STATE_IN_TIMEOUT) {\n    if (server->server_timeout_counter_query_id != server->root->query_id) {\n      server->server_timeout_counter++;\n      server->server_timeout_counter_query_id = server->root->query_id;\n    }\n\n    if (server->server_timeout_counter >= server->root->server_timeout_limit) {\n      struct timeval next_time;\n      if (gettimeofday(&next_time, NULL) == 0) {\n        server->next_retry = next_time.tv_sec + server->root->retry_timeout;\n      } else {\n        server->next_retry = 1; // Setting the value to 1 causes the timeout to occur immediately\n      }\n\n      server->state = MEMCACHED_SERVER_STATE_IN_TIMEOUT;\n      if (server->server_failure_counter_query_id != server->root->query_id) {\n        server->server_failure_counter++;\n        server->server_failure_counter_query_id = server->root->query_id;\n      }\n      set_last_disconnected_host(server);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "memcached_failed(memcached_instance_error_return(server))"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "memcached_instance_error_return(server)"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_error_return",
          "args": [
            "server"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_error_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "553-563",
          "snippet": "memcached_return_t memcached_instance_error_return(memcached_instance_st *instance) {\n  if (instance == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (instance->error_messages) {\n    return instance->error_messages->rc;\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_instance_error_return(memcached_instance_st *instance) {\n  if (instance == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (instance->error_messages) {\n    return instance->error_messages->rc;\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_has_current_error",
          "args": [
            "*server"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_has_current_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "483-485",
          "snippet": "bool memcached_has_current_error(memcached_instance_st &server) {\n  return memcached_has_current_error(*(server.root));\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_has_current_error(memcached_instance_st &server) {\n  return memcached_has_current_error(*(server.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_last_disconnected_host",
          "args": [
            "server"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "set_last_disconnected_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
          "lines": "233-254",
          "snippet": "void set_last_disconnected_host(memcached_instance_st *self) {\n  assert(self->root);\n  if (self->root) {\n    if (memcached_server_get_last_disconnect(self->root)\n        and memcached_server_get_last_disconnect(self->root)->version == self->version)\n    {\n      return;\n    }\n\n    // const_cast\n    memcached_st *root = (memcached_st *) self->root;\n\n    memcached_instance_free((memcached_instance_st *) (root->last_disconnected_server));\n\n    // We set is_parsing so that no lookup happens\n    root->state.is_parsing = true;\n    root->last_disconnected_server = memcached_instance_clone(self);\n    root->state.is_parsing = false;\n\n    ((memcached_instance_st *) memcached_server_get_last_disconnect(root))->version = self->version;\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid set_last_disconnected_host(memcached_instance_st *self) {\n  assert(self->root);\n  if (self->root) {\n    if (memcached_server_get_last_disconnect(self->root)\n        and memcached_server_get_last_disconnect(self->root)->version == self->version)\n    {\n      return;\n    }\n\n    // const_cast\n    memcached_st *root = (memcached_st *) self->root;\n\n    memcached_instance_free((memcached_instance_st *) (root->last_disconnected_server));\n\n    // We set is_parsing so that no lookup happens\n    root->state.is_parsing = true;\n    root->last_disconnected_server = memcached_instance_clone(self);\n    root->state.is_parsing = false;\n\n    ((memcached_instance_st *) memcached_server_get_last_disconnect(root))->version = self->version;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_version_instance",
          "args": [
            "server"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_version_instance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/version.cc",
          "lines": "130-145",
          "snippet": "void memcached_version_instance(memcached_instance_st *instance) {\n  if (instance) {\n    if (memcached_has_root(instance)) {\n      if (memcached_is_fetching_version(instance->root)) {\n        if (memcached_is_udp(instance->root) == false) {\n          if (memcached_is_binary(instance->root)) {\n            version_binary_instance(instance);\n            return;\n          }\n\n          version_ascii_instance(instance);\n        }\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_version_instance(memcached_instance_st *instance) {\n  if (instance) {\n    if (memcached_has_root(instance)) {\n      if (memcached_is_fetching_version(instance->root)) {\n        if (memcached_is_udp(instance->root) == false) {\n          if (memcached_is_binary(instance->root)) {\n            version_binary_instance(instance);\n            return;\n          }\n\n          version_ascii_instance(instance);\n        }\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->mark_server_as_clean",
          "args": [],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "mark_server_as_clean",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.hpp",
          "lines": "44-48",
          "snippet": "void mark_server_as_clean() {\n    server_failure_counter = 0;\n    server_timeout_counter = 0;\n    next_retry = 0;\n  }",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#    include <netdb.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#    include <netdb.h>\n\nmemcached_instance_st {\n  void mark_server_as_clean() {\n      server_failure_counter = 0;\n      server_timeout_counter = 0;\n      next_retry = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unix_socket_connect",
          "args": [
            "server"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "unix_socket_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
          "lines": "258-321",
          "snippet": "static memcached_return_t unix_socket_connect(memcached_instance_st *server) {\n#ifndef _WIN32\n  WATCHPOINT_ASSERT(server->fd == INVALID_SOCKET);\n\n  do {\n    int type = SOCK_STREAM;\n    if (SOCK_CLOEXEC) {\n      type |= SOCK_CLOEXEC;\n    }\n\n    if (SOCK_NONBLOCK) {\n      type |= SOCK_NONBLOCK;\n    }\n\n    if ((server->fd = socket(AF_UNIX, type, 0)) == -1) {\n      return memcached_set_errno(*server, errno, NULL);\n    }\n\n    struct sockaddr_un servAddr;\n\n    memset(&servAddr, 0, sizeof(struct sockaddr_un));\n    servAddr.sun_family = AF_UNIX;\n    if (strlen(server->hostname()) >= sizeof(servAddr.sun_path)) {\n      return memcached_set_error(*server, MEMCACHED_FAIL_UNIX_SOCKET, MEMCACHED_AT);\n    }\n    strncpy(servAddr.sun_path, server->hostname(),\n            sizeof(servAddr.sun_path) - 1); /* Copy filename */\n\n    if (connect(server->fd, (struct sockaddr *) &servAddr, sizeof(servAddr)) == -1) {\n      switch (errno) {\n      case EINPROGRESS:\n      case EALREADY:\n      case EAGAIN:\n        server->events(POLLOUT);\n        break;\n\n      case EINTR:\n        server->reset_socket();\n        continue;\n\n      case EISCONN: /* We were spinning waiting on connect */\n      {\n        assert(0); // Programmer error\n        server->reset_socket();\n        continue;\n      }\n\n      default:\n        WATCHPOINT_ERRNO(errno);\n        server->reset_socket();\n        return memcached_set_errno(*server, errno, MEMCACHED_AT);\n      }\n    }\n  } while (0);\n  server->state = MEMCACHED_SERVER_STATE_CONNECTED;\n\n  WATCHPOINT_ASSERT(server->fd != INVALID_SOCKET);\n\n  return MEMCACHED_SUCCESS;\n#else\n  (void) server;\n  return MEMCACHED_NOT_SUPPORTED;\n#endif\n}",
          "includes": [
            "#include <cassert>",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t unix_socket_connect(memcached_instance_st *server) {\n#ifndef _WIN32\n  WATCHPOINT_ASSERT(server->fd == INVALID_SOCKET);\n\n  do {\n    int type = SOCK_STREAM;\n    if (SOCK_CLOEXEC) {\n      type |= SOCK_CLOEXEC;\n    }\n\n    if (SOCK_NONBLOCK) {\n      type |= SOCK_NONBLOCK;\n    }\n\n    if ((server->fd = socket(AF_UNIX, type, 0)) == -1) {\n      return memcached_set_errno(*server, errno, NULL);\n    }\n\n    struct sockaddr_un servAddr;\n\n    memset(&servAddr, 0, sizeof(struct sockaddr_un));\n    servAddr.sun_family = AF_UNIX;\n    if (strlen(server->hostname()) >= sizeof(servAddr.sun_path)) {\n      return memcached_set_error(*server, MEMCACHED_FAIL_UNIX_SOCKET, MEMCACHED_AT);\n    }\n    strncpy(servAddr.sun_path, server->hostname(),\n            sizeof(servAddr.sun_path) - 1); /* Copy filename */\n\n    if (connect(server->fd, (struct sockaddr *) &servAddr, sizeof(servAddr)) == -1) {\n      switch (errno) {\n      case EINPROGRESS:\n      case EALREADY:\n      case EAGAIN:\n        server->events(POLLOUT);\n        break;\n\n      case EINTR:\n        server->reset_socket();\n        continue;\n\n      case EISCONN: /* We were spinning waiting on connect */\n      {\n        assert(0); // Programmer error\n        server->reset_socket();\n        continue;\n      }\n\n      default:\n        WATCHPOINT_ERRNO(errno);\n        server->reset_socket();\n        return memcached_set_errno(*server, errno, MEMCACHED_AT);\n      }\n    }\n  } while (0);\n  server->state = MEMCACHED_SERVER_STATE_CONNECTED;\n\n  WATCHPOINT_ASSERT(server->fd != INVALID_SOCKET);\n\n  return MEMCACHED_SUCCESS;\n#else\n  (void) server;\n  return MEMCACHED_NOT_SUPPORTED;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->reset_socket",
          "args": [],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "reset_socket",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "640-645",
          "snippet": "void memcached_instance_st::reset_socket() {\n  if (fd != INVALID_SOCKET) {\n    (void) closesocket(fd);\n    fd = INVALID_SOCKET;\n  }\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_instance_st {\n  void memcached_instance_st::reset_socket() {\n    if (fd != INVALID_SOCKET) {\n      (void) closesocket(fd);\n      fd = INVALID_SOCKET;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "server->fd != INVALID_SOCKET"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_sasl_authenticate_connection",
          "args": [
            "server"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_sasl_authenticate_connection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
          "lines": "478-480",
          "snippet": "memcached_return_t memcached_sasl_authenticate_connection(memcached_instance_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}",
          "includes": [
            "#  include <pthread.h>",
            "#    include <sasl/sasl.h>",
            "#include <atomic>",
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_sasl_authenticate_connection(memcached_instance_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "network_connect",
          "args": [
            "server"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "network_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
          "lines": "323-450",
          "snippet": "static memcached_return_t network_connect(memcached_instance_st *server) {\n  bool timeout_error_occured = false;\n\n  WATCHPOINT_ASSERT(server->fd == INVALID_SOCKET);\n  WATCHPOINT_ASSERT(server->cursor_active_ == 0);\n\n  /*\n    We want to check both of these because if address_info_next has been fully tried, we want to do\n    a new lookup to make sure we have picked up on any new DNS information.\n  */\n  if (server->address_info == NULL or server->address_info_next == NULL) {\n    WATCHPOINT_ASSERT(server->state == MEMCACHED_SERVER_STATE_NEW);\n    server->address_info_next = NULL;\n    memcached_return_t rc = set_hostinfo(server);\n\n    if (memcached_failed(rc)) {\n      return rc;\n    }\n  }\n\n  assert(server->address_info_next);\n  assert(server->address_info);\n\n  /* Create the socket */\n  while (server->address_info_next and server->fd == INVALID_SOCKET) {\n    int type = server->address_info_next->ai_socktype;\n    if (SOCK_CLOEXEC) {\n      type |= SOCK_CLOEXEC;\n    }\n\n    if (SOCK_NONBLOCK) {\n      type |= SOCK_NONBLOCK;\n    }\n\n    server->fd =\n        socket(server->address_info_next->ai_family, type, server->address_info_next->ai_protocol);\n\n    if (int(server->fd) == SOCKET_ERROR) {\n      return memcached_set_errno(*server, get_socket_errno(), NULL);\n    }\n\n    if (set_socket_options(server) == false) {\n      server->reset_socket();\n      return MEMCACHED_CONNECTION_FAILURE;\n    }\n\n    /* connect to server */\n    if ((connect(server->fd, server->address_info_next->ai_addr,\n                 server->address_info_next->ai_addrlen)\n         != SOCKET_ERROR))\n    {\n      server->state = MEMCACHED_SERVER_STATE_CONNECTED;\n      return MEMCACHED_SUCCESS;\n    }\n\n    /* An error occurred */\n    int local_error = get_socket_errno();\n    switch (local_error) {\n    case ETIMEDOUT:\n      timeout_error_occured = true;\n      break;\n\n#if EWOULDBLOCK != EAGAIN\n    case EWOULDBLOCK:\n#endif\n    case EAGAIN:\n    case EINPROGRESS: // nonblocking mode - first return\n    case EALREADY:    // nonblocking mode - subsequent returns\n    {\n      server->events(POLLOUT);\n      server->state = MEMCACHED_SERVER_STATE_IN_PROGRESS;\n      memcached_return_t rc = memcached_io_poll(server, IO_POLL_CONNECT, local_error);\n\n      if (memcached_success(rc)) {\n        server->state = MEMCACHED_SERVER_STATE_CONNECTED;\n        return MEMCACHED_SUCCESS;\n      }\n\n      // A timeout here is treated as an error, we will not retry\n      if (rc == MEMCACHED_TIMEOUT) {\n        timeout_error_occured = true;\n      }\n    } break;\n\n    case EISCONN:           // we are connected :-)\n      WATCHPOINT_ASSERT(0); // This is a programmer's error\n      break;\n\n    case EINTR: // Special case, we retry ai_addr\n      WATCHPOINT_ASSERT(server->fd != INVALID_SOCKET);\n      server->reset_socket();\n      continue;\n\n    case ECONNREFUSED:\n      // Probably not running service\n\n    default:\n      memcached_set_errno(*server, local_error, MEMCACHED_AT);\n      break;\n    }\n\n    WATCHPOINT_ASSERT(server->fd != INVALID_SOCKET);\n    server->reset_socket();\n    server->address_info_next = server->address_info_next->ai_next;\n  }\n\n  WATCHPOINT_ASSERT(server->fd == INVALID_SOCKET);\n\n  if (timeout_error_occured) {\n    server->reset_socket();\n  }\n\n  WATCHPOINT_STRING(\"Never got a good file descriptor\");\n\n  if (memcached_has_current_error(*server)) {\n    return memcached_instance_error_return(server);\n  }\n\n  if (timeout_error_occured and server->state < MEMCACHED_SERVER_STATE_IN_PROGRESS) {\n    return memcached_set_error(\n        *server, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n        memcached_literal_param(\n            \"if (timeout_error_occured and server->state < MEMCACHED_SERVER_STATE_IN_PROGRESS)\"));\n  }\n\n  return memcached_set_error(*server, MEMCACHED_CONNECTION_FAILURE,\n                             MEMCACHED_AT); /* The last error should be from connect() */\n}",
          "includes": [
            "#include <cassert>",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t network_connect(memcached_instance_st *server) {\n  bool timeout_error_occured = false;\n\n  WATCHPOINT_ASSERT(server->fd == INVALID_SOCKET);\n  WATCHPOINT_ASSERT(server->cursor_active_ == 0);\n\n  /*\n    We want to check both of these because if address_info_next has been fully tried, we want to do\n    a new lookup to make sure we have picked up on any new DNS information.\n  */\n  if (server->address_info == NULL or server->address_info_next == NULL) {\n    WATCHPOINT_ASSERT(server->state == MEMCACHED_SERVER_STATE_NEW);\n    server->address_info_next = NULL;\n    memcached_return_t rc = set_hostinfo(server);\n\n    if (memcached_failed(rc)) {\n      return rc;\n    }\n  }\n\n  assert(server->address_info_next);\n  assert(server->address_info);\n\n  /* Create the socket */\n  while (server->address_info_next and server->fd == INVALID_SOCKET) {\n    int type = server->address_info_next->ai_socktype;\n    if (SOCK_CLOEXEC) {\n      type |= SOCK_CLOEXEC;\n    }\n\n    if (SOCK_NONBLOCK) {\n      type |= SOCK_NONBLOCK;\n    }\n\n    server->fd =\n        socket(server->address_info_next->ai_family, type, server->address_info_next->ai_protocol);\n\n    if (int(server->fd) == SOCKET_ERROR) {\n      return memcached_set_errno(*server, get_socket_errno(), NULL);\n    }\n\n    if (set_socket_options(server) == false) {\n      server->reset_socket();\n      return MEMCACHED_CONNECTION_FAILURE;\n    }\n\n    /* connect to server */\n    if ((connect(server->fd, server->address_info_next->ai_addr,\n                 server->address_info_next->ai_addrlen)\n         != SOCKET_ERROR))\n    {\n      server->state = MEMCACHED_SERVER_STATE_CONNECTED;\n      return MEMCACHED_SUCCESS;\n    }\n\n    /* An error occurred */\n    int local_error = get_socket_errno();\n    switch (local_error) {\n    case ETIMEDOUT:\n      timeout_error_occured = true;\n      break;\n\n#if EWOULDBLOCK != EAGAIN\n    case EWOULDBLOCK:\n#endif\n    case EAGAIN:\n    case EINPROGRESS: // nonblocking mode - first return\n    case EALREADY:    // nonblocking mode - subsequent returns\n    {\n      server->events(POLLOUT);\n      server->state = MEMCACHED_SERVER_STATE_IN_PROGRESS;\n      memcached_return_t rc = memcached_io_poll(server, IO_POLL_CONNECT, local_error);\n\n      if (memcached_success(rc)) {\n        server->state = MEMCACHED_SERVER_STATE_CONNECTED;\n        return MEMCACHED_SUCCESS;\n      }\n\n      // A timeout here is treated as an error, we will not retry\n      if (rc == MEMCACHED_TIMEOUT) {\n        timeout_error_occured = true;\n      }\n    } break;\n\n    case EISCONN:           // we are connected :-)\n      WATCHPOINT_ASSERT(0); // This is a programmer's error\n      break;\n\n    case EINTR: // Special case, we retry ai_addr\n      WATCHPOINT_ASSERT(server->fd != INVALID_SOCKET);\n      server->reset_socket();\n      continue;\n\n    case ECONNREFUSED:\n      // Probably not running service\n\n    default:\n      memcached_set_errno(*server, local_error, MEMCACHED_AT);\n      break;\n    }\n\n    WATCHPOINT_ASSERT(server->fd != INVALID_SOCKET);\n    server->reset_socket();\n    server->address_info_next = server->address_info_next->ai_next;\n  }\n\n  WATCHPOINT_ASSERT(server->fd == INVALID_SOCKET);\n\n  if (timeout_error_occured) {\n    server->reset_socket();\n  }\n\n  WATCHPOINT_STRING(\"Never got a good file descriptor\");\n\n  if (memcached_has_current_error(*server)) {\n    return memcached_instance_error_return(server);\n  }\n\n  if (timeout_error_occured and server->state < MEMCACHED_SERVER_STATE_IN_PROGRESS) {\n    return memcached_set_error(\n        *server, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n        memcached_literal_param(\n            \"if (timeout_error_occured and server->state < MEMCACHED_SERVER_STATE_IN_PROGRESS)\"));\n  }\n\n  return memcached_set_error(*server, MEMCACHED_CONNECTION_FAILURE,\n                             MEMCACHED_AT); /* The last error should be from connect() */\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->hostname",
          "args": [],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"SASL is not supported for UDP connections\""
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_udp",
          "args": [
            "server->root"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = backoff_handling(server, in_timeout)"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backoff_handling",
          "args": [
            "server",
            "in_timeout"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "backoff_handling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
          "lines": "458-516",
          "snippet": "static memcached_return_t backoff_handling(memcached_instance_st *server, bool &in_timeout) {\n  struct timeval curr_time;\n  bool _gettime_success = (gettimeofday(&curr_time, NULL) == 0);\n\n  /*\n    If we hit server_failure_limit then something is completely wrong about the server.\n\n    1) If autoeject is enabled we do that.\n    2) If not? We go into timeout again, there is much else to do :(\n  */\n  if (server->server_failure_counter >= server->root->server_failure_limit) {\n    /*\n      We just auto_eject if we hit this point\n    */\n    if (_is_auto_eject_host(server->root)) {\n      set_last_disconnected_host(server);\n\n      // Retry dead servers if requested\n      if (_gettime_success and server->root->dead_timeout > 0) {\n        server->next_retry = curr_time.tv_sec + server->root->dead_timeout;\n\n        // We only retry dead servers once before assuming failure again\n        server->server_failure_counter = server->root->server_failure_limit - 1;\n      }\n\n      memcached_return_t rc;\n      if (memcached_failed(rc = run_distribution((memcached_st *) server->root))) {\n        return memcached_set_error(\n            *server, rc, MEMCACHED_AT,\n            memcached_literal_param(\"Backoff handling failed during run_distribution\"));\n      }\n\n      return memcached_set_error(*server, MEMCACHED_SERVER_MARKED_DEAD, MEMCACHED_AT);\n    }\n\n    server->state = MEMCACHED_SERVER_STATE_IN_TIMEOUT;\n\n    // Sanity check/setting\n    if (server->next_retry == 0) {\n      server->next_retry = 1;\n    }\n  }\n\n  if (server->state == MEMCACHED_SERVER_STATE_IN_TIMEOUT) {\n    /*\n      If next_retry is less then our current time, then we reset and try everything again.\n    */\n    if (_gettime_success and server->next_retry < curr_time.tv_sec) {\n      server->state = MEMCACHED_SERVER_STATE_NEW;\n      server->server_timeout_counter = 0;\n    } else {\n      return memcached_set_error(*server, MEMCACHED_SERVER_TEMPORARILY_DISABLED, MEMCACHED_AT);\n    }\n\n    in_timeout = true;\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t backoff_handling(memcached_instance_st *server, bool &in_timeout) {\n  struct timeval curr_time;\n  bool _gettime_success = (gettimeofday(&curr_time, NULL) == 0);\n\n  /*\n    If we hit server_failure_limit then something is completely wrong about the server.\n\n    1) If autoeject is enabled we do that.\n    2) If not? We go into timeout again, there is much else to do :(\n  */\n  if (server->server_failure_counter >= server->root->server_failure_limit) {\n    /*\n      We just auto_eject if we hit this point\n    */\n    if (_is_auto_eject_host(server->root)) {\n      set_last_disconnected_host(server);\n\n      // Retry dead servers if requested\n      if (_gettime_success and server->root->dead_timeout > 0) {\n        server->next_retry = curr_time.tv_sec + server->root->dead_timeout;\n\n        // We only retry dead servers once before assuming failure again\n        server->server_failure_counter = server->root->server_failure_limit - 1;\n      }\n\n      memcached_return_t rc;\n      if (memcached_failed(rc = run_distribution((memcached_st *) server->root))) {\n        return memcached_set_error(\n            *server, rc, MEMCACHED_AT,\n            memcached_literal_param(\"Backoff handling failed during run_distribution\"));\n      }\n\n      return memcached_set_error(*server, MEMCACHED_SERVER_MARKED_DEAD, MEMCACHED_AT);\n    }\n\n    server->state = MEMCACHED_SERVER_STATE_IN_TIMEOUT;\n\n    // Sanity check/setting\n    if (server->next_retry == 0) {\n      server->next_retry = 1;\n    }\n  }\n\n  if (server->state == MEMCACHED_SERVER_STATE_IN_TIMEOUT) {\n    /*\n      If next_retry is less then our current time, then we reset and try everything again.\n    */\n    if (_gettime_success and server->next_retry < curr_time.tv_sec) {\n      server->state = MEMCACHED_SERVER_STATE_NEW;\n      server->server_timeout_counter = 0;\n    } else {\n      return memcached_set_error(*server, MEMCACHED_SERVER_TEMPORARILY_DISABLED, MEMCACHED_AT);\n    }\n\n    in_timeout = true;\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIBMEMCACHED_MEMCACHED_CONNECT_START",
          "args": [],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "server"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t _memcached_connect(memcached_instance_st *server,\n                                             const bool set_last_disconnected) {\n  assert(server);\n  if (server->fd != INVALID_SOCKET) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  LIBMEMCACHED_MEMCACHED_CONNECT_START();\n\n  bool in_timeout = false;\n  memcached_return_t rc;\n  if (memcached_failed(rc = backoff_handling(server, in_timeout))) {\n    set_last_disconnected_host(server);\n    return rc;\n  }\n\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT and server->root->sasl.callbacks\n      and memcached_is_udp(server->root))\n  {\n    return memcached_set_error(\n        *server, MEMCACHED_INVALID_HOST_PROTOCOL, MEMCACHED_AT,\n        memcached_literal_param(\"SASL is not supported for UDP connections\"));\n  }\n\n  if (server->hostname()[0] == '/') {\n    server->type = MEMCACHED_CONNECTION_UNIX_SOCKET;\n  }\n\n  /* We need to clean up the multi startup piece */\n  switch (server->type) {\n  case MEMCACHED_CONNECTION_UDP:\n  case MEMCACHED_CONNECTION_TCP:\n    rc = network_connect(server);\n\n#if defined(LIBMEMCACHED_WITH_SASL_SUPPORT)\n    if (LIBMEMCACHED_WITH_SASL_SUPPORT) {\n      if (server->fd != INVALID_SOCKET and server->root->sasl.callbacks) {\n        rc = memcached_sasl_authenticate_connection(server);\n        if (memcached_failed(rc) and server->fd != INVALID_SOCKET) {\n          WATCHPOINT_ASSERT(server->fd != INVALID_SOCKET);\n          server->reset_socket();\n        }\n      }\n    }\n#endif\n    break;\n\n  case MEMCACHED_CONNECTION_UNIX_SOCKET:\n    rc = unix_socket_connect(server);\n    break;\n  }\n\n  if (memcached_success(rc)) {\n    server->mark_server_as_clean();\n    memcached_version_instance(server);\n    return rc;\n  } else if (set_last_disconnected) {\n    set_last_disconnected_host(server);\n    if (memcached_has_current_error(*server)) {\n      memcached_mark_server_for_timeout(server);\n      assert(memcached_failed(memcached_instance_error_return(server)));\n    } else {\n      memcached_set_error(*server, rc, MEMCACHED_AT);\n      memcached_mark_server_for_timeout(server);\n    }\n\n    LIBMEMCACHED_MEMCACHED_CONNECT_END();\n\n    if (in_timeout) {\n      char buffer[1024];\n      int snprintf_length =\n          snprintf(buffer, sizeof(buffer), \"%s:%d\", server->hostname(), int(server->port()));\n      return memcached_set_error(*server, MEMCACHED_SERVER_TEMPORARILY_DISABLED, MEMCACHED_AT,\n                                 buffer, snprintf_length);\n    }\n  }\n\n  return rc;\n}"
  },
  {
    "function_name": "backoff_handling",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
    "lines": "458-516",
    "snippet": "static memcached_return_t backoff_handling(memcached_instance_st *server, bool &in_timeout) {\n  struct timeval curr_time;\n  bool _gettime_success = (gettimeofday(&curr_time, NULL) == 0);\n\n  /*\n    If we hit server_failure_limit then something is completely wrong about the server.\n\n    1) If autoeject is enabled we do that.\n    2) If not? We go into timeout again, there is much else to do :(\n  */\n  if (server->server_failure_counter >= server->root->server_failure_limit) {\n    /*\n      We just auto_eject if we hit this point\n    */\n    if (_is_auto_eject_host(server->root)) {\n      set_last_disconnected_host(server);\n\n      // Retry dead servers if requested\n      if (_gettime_success and server->root->dead_timeout > 0) {\n        server->next_retry = curr_time.tv_sec + server->root->dead_timeout;\n\n        // We only retry dead servers once before assuming failure again\n        server->server_failure_counter = server->root->server_failure_limit - 1;\n      }\n\n      memcached_return_t rc;\n      if (memcached_failed(rc = run_distribution((memcached_st *) server->root))) {\n        return memcached_set_error(\n            *server, rc, MEMCACHED_AT,\n            memcached_literal_param(\"Backoff handling failed during run_distribution\"));\n      }\n\n      return memcached_set_error(*server, MEMCACHED_SERVER_MARKED_DEAD, MEMCACHED_AT);\n    }\n\n    server->state = MEMCACHED_SERVER_STATE_IN_TIMEOUT;\n\n    // Sanity check/setting\n    if (server->next_retry == 0) {\n      server->next_retry = 1;\n    }\n  }\n\n  if (server->state == MEMCACHED_SERVER_STATE_IN_TIMEOUT) {\n    /*\n      If next_retry is less then our current time, then we reset and try everything again.\n    */\n    if (_gettime_success and server->next_retry < curr_time.tv_sec) {\n      server->state = MEMCACHED_SERVER_STATE_NEW;\n      server->server_timeout_counter = 0;\n    } else {\n      return memcached_set_error(*server, MEMCACHED_SERVER_TEMPORARILY_DISABLED, MEMCACHED_AT);\n    }\n\n    in_timeout = true;\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include <cassert>",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*server",
            "MEMCACHED_SERVER_TEMPORARILY_DISABLED",
            "MEMCACHED_AT"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Backoff handling failed during run_distribution\""
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = run_distribution((memcached_st *) server->root)"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_distribution",
          "args": [
            "(memcached_st *) server->root"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "run_distribution",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "46-72",
          "snippet": "memcached_return_t run_distribution(Memcached *ptr) {\n  if (ptr->flags.use_sort_hosts) {\n    sort_hosts(ptr);\n  }\n\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return update_continuum(ptr);\n\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    break;\n\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    srandom((uint32_t) time(NULL));\n    break;\n\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n  default:\n    assert_msg(0, \"Invalid distribution type passed to run_distribution()\");\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t update_continuum(Memcached *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t run_distribution(Memcached *ptr) {\n  if (ptr->flags.use_sort_hosts) {\n    sort_hosts(ptr);\n  }\n\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return update_continuum(ptr);\n\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    break;\n\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    srandom((uint32_t) time(NULL));\n    break;\n\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n  default:\n    assert_msg(0, \"Invalid distribution type passed to run_distribution()\");\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_last_disconnected_host",
          "args": [
            "server"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "set_last_disconnected_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
          "lines": "233-254",
          "snippet": "void set_last_disconnected_host(memcached_instance_st *self) {\n  assert(self->root);\n  if (self->root) {\n    if (memcached_server_get_last_disconnect(self->root)\n        and memcached_server_get_last_disconnect(self->root)->version == self->version)\n    {\n      return;\n    }\n\n    // const_cast\n    memcached_st *root = (memcached_st *) self->root;\n\n    memcached_instance_free((memcached_instance_st *) (root->last_disconnected_server));\n\n    // We set is_parsing so that no lookup happens\n    root->state.is_parsing = true;\n    root->last_disconnected_server = memcached_instance_clone(self);\n    root->state.is_parsing = false;\n\n    ((memcached_instance_st *) memcached_server_get_last_disconnect(root))->version = self->version;\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid set_last_disconnected_host(memcached_instance_st *self) {\n  assert(self->root);\n  if (self->root) {\n    if (memcached_server_get_last_disconnect(self->root)\n        and memcached_server_get_last_disconnect(self->root)->version == self->version)\n    {\n      return;\n    }\n\n    // const_cast\n    memcached_st *root = (memcached_st *) self->root;\n\n    memcached_instance_free((memcached_instance_st *) (root->last_disconnected_server));\n\n    // We set is_parsing so that no lookup happens\n    root->state.is_parsing = true;\n    root->last_disconnected_server = memcached_instance_clone(self);\n    root->state.is_parsing = false;\n\n    ((memcached_instance_st *) memcached_server_get_last_disconnect(root))->version = self->version;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_is_auto_eject_host",
          "args": [
            "server->root"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "_is_auto_eject_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "284-286",
          "snippet": "bool _is_auto_eject_host(const memcached_st *ptr) {\n  return ptr->flags.auto_eject_hosts;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nbool _is_auto_eject_host(const memcached_st *ptr) {\n  return ptr->flags.auto_eject_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gettimeofday",
          "args": [
            "&curr_time",
            "NULL"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "gettimeofday",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/win32/wrappers.h",
          "lines": "87-103",
          "snippet": "static inline int gettimeofday(struct timeval* tp, struct timezone* tzp) {\n  using clock = std::chrono::system_clock;\n  auto as_sec = [] (auto d) {\n      return std::chrono::duration_cast<std::chrono::seconds>(d);\n  };\n  auto as_usec = [] (auto d) {\n      return std::chrono::duration_cast<std::chrono::microseconds>(d);\n  };\n\n  auto now = clock::now().time_since_epoch();\n  auto sec = as_sec(now);\n  auto usec = as_usec(now - sec);\n\n  tp->tv_sec = sec.count();\n  tp->tv_usec = usec.count();\n  return 0;\n}",
          "includes": [
            "#  include <chrono>",
            "#include <inttypes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <chrono>\n#include <inttypes.h>\n\nstatic inline int gettimeofday(struct timeval* tp, struct timezone* tzp) {\n  using clock = std::chrono::system_clock;\n  auto as_sec = [] (auto d) {\n      return std::chrono::duration_cast<std::chrono::seconds>(d);\n  };\n  auto as_usec = [] (auto d) {\n      return std::chrono::duration_cast<std::chrono::microseconds>(d);\n  };\n\n  auto now = clock::now().time_since_epoch();\n  auto sec = as_sec(now);\n  auto usec = as_usec(now - sec);\n\n  tp->tv_sec = sec.count();\n  tp->tv_usec = usec.count();\n  return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t backoff_handling(memcached_instance_st *server, bool &in_timeout) {\n  struct timeval curr_time;\n  bool _gettime_success = (gettimeofday(&curr_time, NULL) == 0);\n\n  /*\n    If we hit server_failure_limit then something is completely wrong about the server.\n\n    1) If autoeject is enabled we do that.\n    2) If not? We go into timeout again, there is much else to do :(\n  */\n  if (server->server_failure_counter >= server->root->server_failure_limit) {\n    /*\n      We just auto_eject if we hit this point\n    */\n    if (_is_auto_eject_host(server->root)) {\n      set_last_disconnected_host(server);\n\n      // Retry dead servers if requested\n      if (_gettime_success and server->root->dead_timeout > 0) {\n        server->next_retry = curr_time.tv_sec + server->root->dead_timeout;\n\n        // We only retry dead servers once before assuming failure again\n        server->server_failure_counter = server->root->server_failure_limit - 1;\n      }\n\n      memcached_return_t rc;\n      if (memcached_failed(rc = run_distribution((memcached_st *) server->root))) {\n        return memcached_set_error(\n            *server, rc, MEMCACHED_AT,\n            memcached_literal_param(\"Backoff handling failed during run_distribution\"));\n      }\n\n      return memcached_set_error(*server, MEMCACHED_SERVER_MARKED_DEAD, MEMCACHED_AT);\n    }\n\n    server->state = MEMCACHED_SERVER_STATE_IN_TIMEOUT;\n\n    // Sanity check/setting\n    if (server->next_retry == 0) {\n      server->next_retry = 1;\n    }\n  }\n\n  if (server->state == MEMCACHED_SERVER_STATE_IN_TIMEOUT) {\n    /*\n      If next_retry is less then our current time, then we reset and try everything again.\n    */\n    if (_gettime_success and server->next_retry < curr_time.tv_sec) {\n      server->state = MEMCACHED_SERVER_STATE_NEW;\n      server->server_timeout_counter = 0;\n    } else {\n      return memcached_set_error(*server, MEMCACHED_SERVER_TEMPORARILY_DISABLED, MEMCACHED_AT);\n    }\n\n    in_timeout = true;\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "network_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
    "lines": "323-450",
    "snippet": "static memcached_return_t network_connect(memcached_instance_st *server) {\n  bool timeout_error_occured = false;\n\n  WATCHPOINT_ASSERT(server->fd == INVALID_SOCKET);\n  WATCHPOINT_ASSERT(server->cursor_active_ == 0);\n\n  /*\n    We want to check both of these because if address_info_next has been fully tried, we want to do\n    a new lookup to make sure we have picked up on any new DNS information.\n  */\n  if (server->address_info == NULL or server->address_info_next == NULL) {\n    WATCHPOINT_ASSERT(server->state == MEMCACHED_SERVER_STATE_NEW);\n    server->address_info_next = NULL;\n    memcached_return_t rc = set_hostinfo(server);\n\n    if (memcached_failed(rc)) {\n      return rc;\n    }\n  }\n\n  assert(server->address_info_next);\n  assert(server->address_info);\n\n  /* Create the socket */\n  while (server->address_info_next and server->fd == INVALID_SOCKET) {\n    int type = server->address_info_next->ai_socktype;\n    if (SOCK_CLOEXEC) {\n      type |= SOCK_CLOEXEC;\n    }\n\n    if (SOCK_NONBLOCK) {\n      type |= SOCK_NONBLOCK;\n    }\n\n    server->fd =\n        socket(server->address_info_next->ai_family, type, server->address_info_next->ai_protocol);\n\n    if (int(server->fd) == SOCKET_ERROR) {\n      return memcached_set_errno(*server, get_socket_errno(), NULL);\n    }\n\n    if (set_socket_options(server) == false) {\n      server->reset_socket();\n      return MEMCACHED_CONNECTION_FAILURE;\n    }\n\n    /* connect to server */\n    if ((connect(server->fd, server->address_info_next->ai_addr,\n                 server->address_info_next->ai_addrlen)\n         != SOCKET_ERROR))\n    {\n      server->state = MEMCACHED_SERVER_STATE_CONNECTED;\n      return MEMCACHED_SUCCESS;\n    }\n\n    /* An error occurred */\n    int local_error = get_socket_errno();\n    switch (local_error) {\n    case ETIMEDOUT:\n      timeout_error_occured = true;\n      break;\n\n#if EWOULDBLOCK != EAGAIN\n    case EWOULDBLOCK:\n#endif\n    case EAGAIN:\n    case EINPROGRESS: // nonblocking mode - first return\n    case EALREADY:    // nonblocking mode - subsequent returns\n    {\n      server->events(POLLOUT);\n      server->state = MEMCACHED_SERVER_STATE_IN_PROGRESS;\n      memcached_return_t rc = memcached_io_poll(server, IO_POLL_CONNECT, local_error);\n\n      if (memcached_success(rc)) {\n        server->state = MEMCACHED_SERVER_STATE_CONNECTED;\n        return MEMCACHED_SUCCESS;\n      }\n\n      // A timeout here is treated as an error, we will not retry\n      if (rc == MEMCACHED_TIMEOUT) {\n        timeout_error_occured = true;\n      }\n    } break;\n\n    case EISCONN:           // we are connected :-)\n      WATCHPOINT_ASSERT(0); // This is a programmer's error\n      break;\n\n    case EINTR: // Special case, we retry ai_addr\n      WATCHPOINT_ASSERT(server->fd != INVALID_SOCKET);\n      server->reset_socket();\n      continue;\n\n    case ECONNREFUSED:\n      // Probably not running service\n\n    default:\n      memcached_set_errno(*server, local_error, MEMCACHED_AT);\n      break;\n    }\n\n    WATCHPOINT_ASSERT(server->fd != INVALID_SOCKET);\n    server->reset_socket();\n    server->address_info_next = server->address_info_next->ai_next;\n  }\n\n  WATCHPOINT_ASSERT(server->fd == INVALID_SOCKET);\n\n  if (timeout_error_occured) {\n    server->reset_socket();\n  }\n\n  WATCHPOINT_STRING(\"Never got a good file descriptor\");\n\n  if (memcached_has_current_error(*server)) {\n    return memcached_instance_error_return(server);\n  }\n\n  if (timeout_error_occured and server->state < MEMCACHED_SERVER_STATE_IN_PROGRESS) {\n    return memcached_set_error(\n        *server, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n        memcached_literal_param(\n            \"if (timeout_error_occured and server->state < MEMCACHED_SERVER_STATE_IN_PROGRESS)\"));\n  }\n\n  return memcached_set_error(*server, MEMCACHED_CONNECTION_FAILURE,\n                             MEMCACHED_AT); /* The last error should be from connect() */\n}",
    "includes": [
      "#include <cassert>",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*server",
            "MEMCACHED_CONNECTION_FAILURE",
            "MEMCACHED_AT"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"if (timeout_error_occured and server->state < MEMCACHED_SERVER_STATE_IN_PROGRESS)\""
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_error_return",
          "args": [
            "server"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_error_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "553-563",
          "snippet": "memcached_return_t memcached_instance_error_return(memcached_instance_st *instance) {\n  if (instance == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (instance->error_messages) {\n    return instance->error_messages->rc;\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_instance_error_return(memcached_instance_st *instance) {\n  if (instance == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (instance->error_messages) {\n    return instance->error_messages->rc;\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_has_current_error",
          "args": [
            "*server"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_has_current_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "483-485",
          "snippet": "bool memcached_has_current_error(memcached_instance_st &server) {\n  return memcached_has_current_error(*(server.root));\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_has_current_error(memcached_instance_st &server) {\n  return memcached_has_current_error(*(server.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_STRING",
          "args": [
            "\"Never got a good file descriptor\""
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->reset_socket",
          "args": [],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "reset_socket",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "640-645",
          "snippet": "void memcached_instance_st::reset_socket() {\n  if (fd != INVALID_SOCKET) {\n    (void) closesocket(fd);\n    fd = INVALID_SOCKET;\n  }\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_instance_st {\n  void memcached_instance_st::reset_socket() {\n    if (fd != INVALID_SOCKET) {\n      (void) closesocket(fd);\n      fd = INVALID_SOCKET;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "server->fd == INVALID_SOCKET"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "server->fd != INVALID_SOCKET"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_errno",
          "args": [
            "*server",
            "local_error",
            "MEMCACHED_AT"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "378-398",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "server->fd != INVALID_SOCKET"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "0"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_io_poll",
          "args": [
            "server",
            "IO_POLL_CONNECT",
            "local_error"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_io_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "150-242",
          "snippet": "memcached_return_t memcached_io_poll(memcached_instance_st *inst, int16_t events, int prev_errno) {\n  int32_t timeout;\n  pollfd pfd{};\n  pfd.fd = inst->fd;\n  pfd.events = events ? events : inst->events();\n\n  if (events) {\n    timeout = inst->root->poll_timeout;\n  } else {\n    timeout = inst->root->connect_timeout;\n  }\n\n  if (!timeout) {\n    return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                               memcached_literal_param(\"timeout was set to zero\"));\n  }\n\n  timespec tspec{}; // for clock_gettime()\n  int64_t start, elapsed; // ns\n  int32_t poll_timeout = timeout; // ms\n\n  if (clock_gettime(CLOCK_MONOTONIC, &tspec)) {\n    return memcached_set_errno(*inst, errno, MEMCACHED_AT,\n                               memcached_literal_param(\"clock_gettime()\"));\n  }\n  start = tspec.tv_sec * 1000000000 + tspec.tv_nsec;\n  while (true) {\n    int active = poll(&pfd, 1, poll_timeout);\n\n    if (active == SOCKET_ERROR) {\n      int local_errno = get_socket_errno();\n\n      switch (local_errno) {\n#ifdef HAVE_ERESTART\n        case ERESTART:\n#endif\n      case EINTR:\n        clock_gettime(CLOCK_MONOTONIC, &tspec);\n        elapsed = tspec.tv_sec * 1000000000 + tspec.tv_nsec - start;\n        if (elapsed / 1000000 >= timeout || !start /* safety if clock_gettime is broken */) {\n          return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                                     memcached_literal_param(\"timeout on interrupt or restart\"));\n        }\n        poll_timeout -= elapsed / 1000000;\n        continue;\n\n      case EFAULT:\n      case ENOMEM:\n        return memcached_set_error(*inst, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n\n      case EINVAL:\n        return memcached_set_error(*inst, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                            memcached_literal_param(\"RLIMIT_NOFILE exceeded, or invalid timeout\"));\n      default:\n        if (events == IO_POLL_CONNECT) {\n          inst->reset_socket();\n          inst->state = MEMCACHED_SERVER_STATE_NEW;\n        }\n        return memcached_set_errno(*inst, local_errno, MEMCACHED_AT, memcached_literal_param(\"poll()\"));\n      }\n    }\n\n    if (active == 0) {\n      /* do not test SO_ERROR on EALREADY */\n      if (prev_errno != EALREADY) {\n        memcached_return_t rc = io_sock_err(inst, memcached_literal_param(\"getsockopt() after poll() timed out\"));\n        if (MEMCACHED_SUCCESS != rc) {\n          return rc;\n        }\n      }\n      return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                                 memcached_literal_param(\"time out\"));\n    }\n\n    assert_msg(active == 1, \"poll() returned an unexpected number of active file descriptors\");\n\n    if (pfd.revents & (POLLERR|POLLHUP|POLLNVAL)) {\n      memcached_return_t rc = io_sock_err(inst, memcached_literal_param(\"poll(POLLERR|POLLHUP|POLLNVAL)\"));\n      if (MEMCACHED_SUCCESS != rc) {\n        if (events != IO_POLL_CONNECT) {\n          memcached_quit_server(inst, true);\n        }\n        return rc;\n      }\n    }\n    if (pfd.revents & events || (events == IO_POLL_CONNECT && pfd.revents & POLLOUT)) {\n      return MEMCACHED_SUCCESS;\n    }\n#if DEBUG\n    dprintf(STDERR_FILENO, \"io_poll() looped!\\n\");\n#endif\n  }\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_io_poll(memcached_instance_st *inst, int16_t events, int prev_errno) {\n  int32_t timeout;\n  pollfd pfd{};\n  pfd.fd = inst->fd;\n  pfd.events = events ? events : inst->events();\n\n  if (events) {\n    timeout = inst->root->poll_timeout;\n  } else {\n    timeout = inst->root->connect_timeout;\n  }\n\n  if (!timeout) {\n    return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                               memcached_literal_param(\"timeout was set to zero\"));\n  }\n\n  timespec tspec{}; // for clock_gettime()\n  int64_t start, elapsed; // ns\n  int32_t poll_timeout = timeout; // ms\n\n  if (clock_gettime(CLOCK_MONOTONIC, &tspec)) {\n    return memcached_set_errno(*inst, errno, MEMCACHED_AT,\n                               memcached_literal_param(\"clock_gettime()\"));\n  }\n  start = tspec.tv_sec * 1000000000 + tspec.tv_nsec;\n  while (true) {\n    int active = poll(&pfd, 1, poll_timeout);\n\n    if (active == SOCKET_ERROR) {\n      int local_errno = get_socket_errno();\n\n      switch (local_errno) {\n#ifdef HAVE_ERESTART\n        case ERESTART:\n#endif\n      case EINTR:\n        clock_gettime(CLOCK_MONOTONIC, &tspec);\n        elapsed = tspec.tv_sec * 1000000000 + tspec.tv_nsec - start;\n        if (elapsed / 1000000 >= timeout || !start /* safety if clock_gettime is broken */) {\n          return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                                     memcached_literal_param(\"timeout on interrupt or restart\"));\n        }\n        poll_timeout -= elapsed / 1000000;\n        continue;\n\n      case EFAULT:\n      case ENOMEM:\n        return memcached_set_error(*inst, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n\n      case EINVAL:\n        return memcached_set_error(*inst, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                            memcached_literal_param(\"RLIMIT_NOFILE exceeded, or invalid timeout\"));\n      default:\n        if (events == IO_POLL_CONNECT) {\n          inst->reset_socket();\n          inst->state = MEMCACHED_SERVER_STATE_NEW;\n        }\n        return memcached_set_errno(*inst, local_errno, MEMCACHED_AT, memcached_literal_param(\"poll()\"));\n      }\n    }\n\n    if (active == 0) {\n      /* do not test SO_ERROR on EALREADY */\n      if (prev_errno != EALREADY) {\n        memcached_return_t rc = io_sock_err(inst, memcached_literal_param(\"getsockopt() after poll() timed out\"));\n        if (MEMCACHED_SUCCESS != rc) {\n          return rc;\n        }\n      }\n      return memcached_set_error(*inst, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                                 memcached_literal_param(\"time out\"));\n    }\n\n    assert_msg(active == 1, \"poll() returned an unexpected number of active file descriptors\");\n\n    if (pfd.revents & (POLLERR|POLLHUP|POLLNVAL)) {\n      memcached_return_t rc = io_sock_err(inst, memcached_literal_param(\"poll(POLLERR|POLLHUP|POLLNVAL)\"));\n      if (MEMCACHED_SUCCESS != rc) {\n        if (events != IO_POLL_CONNECT) {\n          memcached_quit_server(inst, true);\n        }\n        return rc;\n      }\n    }\n    if (pfd.revents & events || (events == IO_POLL_CONNECT && pfd.revents & POLLOUT)) {\n      return MEMCACHED_SUCCESS;\n    }\n#if DEBUG\n    dprintf(STDERR_FILENO, \"io_poll() looped!\\n\");\n#endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->events",
          "args": [
            "POLLOUT"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "events",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
          "lines": "83-89",
          "snippet": "void memcached_instance_st::events(short arg) {\n  if ((_events | arg) == _events) {\n    return;\n  }\n\n  _events |= arg;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_instance_st {\n  void memcached_instance_st::events(short arg) {\n    if ((_events | arg) == _events) {\n      return;\n    }\n  \n    _events |= arg;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_socket_errno",
          "args": [],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/p9y/p9y.cpp",
          "lines": "48-93",
          "snippet": "int get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}",
          "includes": [
            "#include \"clock_gettime.hpp\"",
            "#include \"poll.hpp\"",
            "#include \"socket.hpp\"",
            "# include <chrono>",
            "#include \"gettimeofday.hpp\"",
            "#include \"realpath.hpp\"",
            "# include <cstring>",
            "#include \"libgen.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"clock_gettime.hpp\"\n#include \"poll.hpp\"\n#include \"socket.hpp\"\n# include <chrono>\n#include \"gettimeofday.hpp\"\n#include \"realpath.hpp\"\n# include <cstring>\n#include \"libgen.hpp\"\n\nint get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "server->fd",
            "server->address_info_next->ai_addr",
            "server->address_info_next->ai_addrlen"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_socket_options",
          "args": [
            "server"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "set_socket_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
          "lines": "124-256",
          "snippet": "static bool set_socket_options(memcached_instance_st *server) {\n  assert_msg(server->fd != INVALID_SOCKET, \"invalid socket was passed to set_socket_options()\");\n\n#ifdef HAVE_FCNTL\n  // If SOCK_CLOEXEC exists then we don't need to call the following\n  if (SOCK_CLOEXEC == 0) {\n    if (FD_CLOEXEC) {\n      int flags;\n      do {\n        flags = fcntl(server->fd, F_GETFD, 0);\n      } while (flags == -1 and (errno == EINTR or errno == EAGAIN));\n\n      if (flags != -1) {\n        int rval;\n        do {\n          rval = fcntl(server->fd, F_SETFD, flags | FD_CLOEXEC);\n        } while (rval == -1 && (errno == EINTR or errno == EAGAIN));\n        // we currently ignore the case where rval is -1\n      }\n    }\n  }\n#endif\n\n  if (memcached_is_udp(server->root)) {\n    return true;\n  }\n\n#ifdef HAVE_SO_SNDTIMEO\n  if (server->root->snd_timeout > 0) {\n    struct timeval waittime;\n\n    waittime.tv_sec = server->root->snd_timeout / 1000000;\n    waittime.tv_usec = server->root->snd_timeout % 1000000;\n\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_SNDTIMEO, (char *) &waittime,\n                           (socklen_t) sizeof(struct timeval));\n    (void) error;\n    assert(error == 0);\n  }\n#endif\n\n#ifdef HAVE_SO_RCVTIMEO\n  if (server->root->rcv_timeout > 0) {\n    struct timeval waittime;\n\n    waittime.tv_sec = server->root->rcv_timeout / 1000000;\n    waittime.tv_usec = server->root->rcv_timeout % 1000000;\n\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_RCVTIMEO, (char *) &waittime,\n                           (socklen_t) sizeof(struct timeval));\n    (void) (error);\n    assert(error == 0);\n  }\n#endif\n\n#if defined(_WIN32)\n#else\n#  if defined(SO_NOSIGPIPE)\n  if (SO_NOSIGPIPE) {\n    int set = 1;\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_NOSIGPIPE, (void *) &set, sizeof(int));\n\n    assert(error == 0);\n\n    // This is not considered a fatal error\n    if (error == -1) {\n#    if 0\n      perror(\"setsockopt(SO_NOSIGPIPE)\");\n#    endif\n    }\n  }\n#  endif // SO_NOSIGPIPE\n#endif   // _WIN32\n\n  if (server->root->flags.no_block) {\n    struct linger linger;\n\n    linger.l_onoff = 1;\n    linger.l_linger = 0; /* By default on close() just drop the socket */\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_LINGER, (char *) &linger,\n                           (socklen_t) sizeof(struct linger));\n    (void) (error);\n    assert(error == 0);\n  }\n\n  if (TCP_NODELAY) {\n    if (server->root->flags.tcp_nodelay) {\n      int flag = 1;\n\n      int error =\n          setsockopt(server->fd, IPPROTO_TCP, TCP_NODELAY, (char *) &flag, (socklen_t) sizeof(int));\n      (void) (error);\n      assert(error == 0);\n    }\n  }\n\n  if (server->root->flags.tcp_keepalive) {\n    int flag = 1;\n\n    int error =\n        setsockopt(server->fd, SOL_SOCKET, SO_KEEPALIVE, (char *) &flag, (socklen_t) sizeof(int));\n    (void) (error);\n    assert(error == 0);\n  }\n\n  if (TCP_KEEPIDLE) {\n    if (server->root->tcp_keepidle > 0) {\n      int error = setsockopt(server->fd, IPPROTO_TCP, TCP_KEEPIDLE,\n                             (char *) &server->root->tcp_keepidle, (socklen_t) sizeof(int));\n      (void) (error);\n      assert(error == 0);\n    }\n  }\n\n  if (server->root->send_size > 0) {\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_SNDBUF, (char *) &server->root->send_size,\n                           (socklen_t) sizeof(int));\n    (void) (error);\n    assert(error == 0);\n  }\n\n  if (server->root->recv_size > 0) {\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_RCVBUF, (char *) &server->root->recv_size,\n                           (socklen_t) sizeof(int));\n    (void) (error);\n    assert(error == 0);\n  }\n\n  /* libmemcached will always use nonblocking IO to avoid write deadlocks */\n  set_socket_nonblocking(server);\n\n  return true;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic bool set_socket_options(memcached_instance_st *server) {\n  assert_msg(server->fd != INVALID_SOCKET, \"invalid socket was passed to set_socket_options()\");\n\n#ifdef HAVE_FCNTL\n  // If SOCK_CLOEXEC exists then we don't need to call the following\n  if (SOCK_CLOEXEC == 0) {\n    if (FD_CLOEXEC) {\n      int flags;\n      do {\n        flags = fcntl(server->fd, F_GETFD, 0);\n      } while (flags == -1 and (errno == EINTR or errno == EAGAIN));\n\n      if (flags != -1) {\n        int rval;\n        do {\n          rval = fcntl(server->fd, F_SETFD, flags | FD_CLOEXEC);\n        } while (rval == -1 && (errno == EINTR or errno == EAGAIN));\n        // we currently ignore the case where rval is -1\n      }\n    }\n  }\n#endif\n\n  if (memcached_is_udp(server->root)) {\n    return true;\n  }\n\n#ifdef HAVE_SO_SNDTIMEO\n  if (server->root->snd_timeout > 0) {\n    struct timeval waittime;\n\n    waittime.tv_sec = server->root->snd_timeout / 1000000;\n    waittime.tv_usec = server->root->snd_timeout % 1000000;\n\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_SNDTIMEO, (char *) &waittime,\n                           (socklen_t) sizeof(struct timeval));\n    (void) error;\n    assert(error == 0);\n  }\n#endif\n\n#ifdef HAVE_SO_RCVTIMEO\n  if (server->root->rcv_timeout > 0) {\n    struct timeval waittime;\n\n    waittime.tv_sec = server->root->rcv_timeout / 1000000;\n    waittime.tv_usec = server->root->rcv_timeout % 1000000;\n\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_RCVTIMEO, (char *) &waittime,\n                           (socklen_t) sizeof(struct timeval));\n    (void) (error);\n    assert(error == 0);\n  }\n#endif\n\n#if defined(_WIN32)\n#else\n#  if defined(SO_NOSIGPIPE)\n  if (SO_NOSIGPIPE) {\n    int set = 1;\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_NOSIGPIPE, (void *) &set, sizeof(int));\n\n    assert(error == 0);\n\n    // This is not considered a fatal error\n    if (error == -1) {\n#    if 0\n      perror(\"setsockopt(SO_NOSIGPIPE)\");\n#    endif\n    }\n  }\n#  endif // SO_NOSIGPIPE\n#endif   // _WIN32\n\n  if (server->root->flags.no_block) {\n    struct linger linger;\n\n    linger.l_onoff = 1;\n    linger.l_linger = 0; /* By default on close() just drop the socket */\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_LINGER, (char *) &linger,\n                           (socklen_t) sizeof(struct linger));\n    (void) (error);\n    assert(error == 0);\n  }\n\n  if (TCP_NODELAY) {\n    if (server->root->flags.tcp_nodelay) {\n      int flag = 1;\n\n      int error =\n          setsockopt(server->fd, IPPROTO_TCP, TCP_NODELAY, (char *) &flag, (socklen_t) sizeof(int));\n      (void) (error);\n      assert(error == 0);\n    }\n  }\n\n  if (server->root->flags.tcp_keepalive) {\n    int flag = 1;\n\n    int error =\n        setsockopt(server->fd, SOL_SOCKET, SO_KEEPALIVE, (char *) &flag, (socklen_t) sizeof(int));\n    (void) (error);\n    assert(error == 0);\n  }\n\n  if (TCP_KEEPIDLE) {\n    if (server->root->tcp_keepidle > 0) {\n      int error = setsockopt(server->fd, IPPROTO_TCP, TCP_KEEPIDLE,\n                             (char *) &server->root->tcp_keepidle, (socklen_t) sizeof(int));\n      (void) (error);\n      assert(error == 0);\n    }\n  }\n\n  if (server->root->send_size > 0) {\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_SNDBUF, (char *) &server->root->send_size,\n                           (socklen_t) sizeof(int));\n    (void) (error);\n    assert(error == 0);\n  }\n\n  if (server->root->recv_size > 0) {\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_RCVBUF, (char *) &server->root->recv_size,\n                           (socklen_t) sizeof(int));\n    (void) (error);\n    assert(error == 0);\n  }\n\n  /* libmemcached will always use nonblocking IO to avoid write deadlocks */\n  set_socket_nonblocking(server);\n\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "server->fd"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "414-427",
          "snippet": "void memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "server->address_info_next->ai_family",
            "type",
            "server->address_info_next->ai_protocol"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_add_unix_socket_with_weight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "426-441",
          "snippet": "memcached_return_t memcached_server_add_unix_socket_with_weight(memcached_st *shell,\n                                                                const char *filename,\n                                                                uint32_t weight) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    memcached_string_t _filename = {memcached_string_make_from_cstr(filename)};\n    if (memcached_is_valid_filename(_filename) == false) {\n      return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                                 memcached_literal_param(\"Invalid filename for socket provided\"));\n    }\n\n    return server_add(ptr, _filename, 0, weight, MEMCACHED_CONNECTION_UNIX_SOCKET);\n  }\n\n  return MEMCACHED_FAILURE;\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t update_continuum(Memcached *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t memcached_server_add_unix_socket_with_weight(memcached_st *shell,\n                                                                const char *filename,\n                                                                uint32_t weight) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    memcached_string_t _filename = {memcached_string_make_from_cstr(filename)};\n    if (memcached_is_valid_filename(_filename) == false) {\n      return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                                 memcached_literal_param(\"Invalid filename for socket provided\"));\n    }\n\n    return server_add(ptr, _filename, 0, weight, MEMCACHED_CONNECTION_UNIX_SOCKET);\n  }\n\n  return MEMCACHED_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "server->address_info"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "server->address_info_next"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_hostinfo",
          "args": [
            "server"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "set_hostinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
          "lines": "21-91",
          "snippet": "static memcached_return_t set_hostinfo(memcached_instance_st *server) {\n  assert(server->type != MEMCACHED_CONNECTION_UNIX_SOCKET);\n  assert(server->hostname());\n\n  server->clear_addrinfo();\n\n  char str_host[MEMCACHED_NI_MAXHOST] = {0}, str_port[MEMCACHED_NI_MAXSERV] = {0};\n  errno = 0;\n\n  auto length = snprintf(str_port, MEMCACHED_NI_MAXSERV, \"%u\", uint32_t(server->port()));\n  if (length <= 0 or errno) {\n    return memcached_set_error(*server, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"snprintf(NI_MAXSERV)\"));\n  }\n\n  struct addrinfo hints{};\n  hints.ai_family = AF_UNSPEC;\n  if (memcached_is_udp(server->root)) {\n    hints.ai_protocol = IPPROTO_UDP;\n    hints.ai_socktype = SOCK_DGRAM;\n  } else {\n    hints.ai_protocol = IPPROTO_TCP;\n    hints.ai_socktype = SOCK_STREAM;\n  }\n\n  auto hostname = server->hostname();\n  if (*hostname == '[') {\n    auto closing_bracket = &hostname[strlen(hostname) - 1];\n    if (*closing_bracket == ']') {\n      auto host_len = closing_bracket - hostname - 1;\n      if (host_len < MEMCACHED_NI_MAXHOST) {\n        hostname = strncpy(str_host, hostname + 1, host_len);\n      }\n    }\n  }\n\n  auto errcode = getaddrinfo(hostname, str_port, &hints, &server->address_info);\n  switch (errcode) {\n  case 0:\n    server->address_info_next = server->address_info;\n    server->state = MEMCACHED_SERVER_STATE_ADDRINFO;\n    break;\n\n  case EAI_AGAIN:\n    return memcached_set_error(*server, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                               memcached_string_make_from_cstr(gai_strerror(errcode)));\n\n  case EAI_SYSTEM:\n    server->clear_addrinfo();\n    return memcached_set_errno(*server, errno, MEMCACHED_AT,\n                               memcached_literal_param(\"getaddrinfo(EAI_SYSTEM)\"));\n\n  case EAI_BADFLAGS:\n    server->clear_addrinfo();\n    return memcached_set_error(*server, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"getaddrinfo(EAI_BADFLAGS)\"));\n\n  case EAI_MEMORY:\n    server->clear_addrinfo();\n    return memcached_set_error(*server, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"getaddrinfo(EAI_MEMORY)\"));\n\n  default: {\n    server->clear_addrinfo();\n    return memcached_set_error(*server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT,\n                               memcached_string_make_from_cstr(gai_strerror(errcode)));\n  }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t set_hostinfo(memcached_instance_st *server) {\n  assert(server->type != MEMCACHED_CONNECTION_UNIX_SOCKET);\n  assert(server->hostname());\n\n  server->clear_addrinfo();\n\n  char str_host[MEMCACHED_NI_MAXHOST] = {0}, str_port[MEMCACHED_NI_MAXSERV] = {0};\n  errno = 0;\n\n  auto length = snprintf(str_port, MEMCACHED_NI_MAXSERV, \"%u\", uint32_t(server->port()));\n  if (length <= 0 or errno) {\n    return memcached_set_error(*server, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"snprintf(NI_MAXSERV)\"));\n  }\n\n  struct addrinfo hints{};\n  hints.ai_family = AF_UNSPEC;\n  if (memcached_is_udp(server->root)) {\n    hints.ai_protocol = IPPROTO_UDP;\n    hints.ai_socktype = SOCK_DGRAM;\n  } else {\n    hints.ai_protocol = IPPROTO_TCP;\n    hints.ai_socktype = SOCK_STREAM;\n  }\n\n  auto hostname = server->hostname();\n  if (*hostname == '[') {\n    auto closing_bracket = &hostname[strlen(hostname) - 1];\n    if (*closing_bracket == ']') {\n      auto host_len = closing_bracket - hostname - 1;\n      if (host_len < MEMCACHED_NI_MAXHOST) {\n        hostname = strncpy(str_host, hostname + 1, host_len);\n      }\n    }\n  }\n\n  auto errcode = getaddrinfo(hostname, str_port, &hints, &server->address_info);\n  switch (errcode) {\n  case 0:\n    server->address_info_next = server->address_info;\n    server->state = MEMCACHED_SERVER_STATE_ADDRINFO;\n    break;\n\n  case EAI_AGAIN:\n    return memcached_set_error(*server, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                               memcached_string_make_from_cstr(gai_strerror(errcode)));\n\n  case EAI_SYSTEM:\n    server->clear_addrinfo();\n    return memcached_set_errno(*server, errno, MEMCACHED_AT,\n                               memcached_literal_param(\"getaddrinfo(EAI_SYSTEM)\"));\n\n  case EAI_BADFLAGS:\n    server->clear_addrinfo();\n    return memcached_set_error(*server, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"getaddrinfo(EAI_BADFLAGS)\"));\n\n  case EAI_MEMORY:\n    server->clear_addrinfo();\n    return memcached_set_error(*server, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"getaddrinfo(EAI_MEMORY)\"));\n\n  default: {\n    server->clear_addrinfo();\n    return memcached_set_error(*server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT,\n                               memcached_string_make_from_cstr(gai_strerror(errcode)));\n  }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "server->state == MEMCACHED_SERVER_STATE_NEW"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "server->cursor_active_ == 0"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "server->fd == INVALID_SOCKET"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t network_connect(memcached_instance_st *server) {\n  bool timeout_error_occured = false;\n\n  WATCHPOINT_ASSERT(server->fd == INVALID_SOCKET);\n  WATCHPOINT_ASSERT(server->cursor_active_ == 0);\n\n  /*\n    We want to check both of these because if address_info_next has been fully tried, we want to do\n    a new lookup to make sure we have picked up on any new DNS information.\n  */\n  if (server->address_info == NULL or server->address_info_next == NULL) {\n    WATCHPOINT_ASSERT(server->state == MEMCACHED_SERVER_STATE_NEW);\n    server->address_info_next = NULL;\n    memcached_return_t rc = set_hostinfo(server);\n\n    if (memcached_failed(rc)) {\n      return rc;\n    }\n  }\n\n  assert(server->address_info_next);\n  assert(server->address_info);\n\n  /* Create the socket */\n  while (server->address_info_next and server->fd == INVALID_SOCKET) {\n    int type = server->address_info_next->ai_socktype;\n    if (SOCK_CLOEXEC) {\n      type |= SOCK_CLOEXEC;\n    }\n\n    if (SOCK_NONBLOCK) {\n      type |= SOCK_NONBLOCK;\n    }\n\n    server->fd =\n        socket(server->address_info_next->ai_family, type, server->address_info_next->ai_protocol);\n\n    if (int(server->fd) == SOCKET_ERROR) {\n      return memcached_set_errno(*server, get_socket_errno(), NULL);\n    }\n\n    if (set_socket_options(server) == false) {\n      server->reset_socket();\n      return MEMCACHED_CONNECTION_FAILURE;\n    }\n\n    /* connect to server */\n    if ((connect(server->fd, server->address_info_next->ai_addr,\n                 server->address_info_next->ai_addrlen)\n         != SOCKET_ERROR))\n    {\n      server->state = MEMCACHED_SERVER_STATE_CONNECTED;\n      return MEMCACHED_SUCCESS;\n    }\n\n    /* An error occurred */\n    int local_error = get_socket_errno();\n    switch (local_error) {\n    case ETIMEDOUT:\n      timeout_error_occured = true;\n      break;\n\n#if EWOULDBLOCK != EAGAIN\n    case EWOULDBLOCK:\n#endif\n    case EAGAIN:\n    case EINPROGRESS: // nonblocking mode - first return\n    case EALREADY:    // nonblocking mode - subsequent returns\n    {\n      server->events(POLLOUT);\n      server->state = MEMCACHED_SERVER_STATE_IN_PROGRESS;\n      memcached_return_t rc = memcached_io_poll(server, IO_POLL_CONNECT, local_error);\n\n      if (memcached_success(rc)) {\n        server->state = MEMCACHED_SERVER_STATE_CONNECTED;\n        return MEMCACHED_SUCCESS;\n      }\n\n      // A timeout here is treated as an error, we will not retry\n      if (rc == MEMCACHED_TIMEOUT) {\n        timeout_error_occured = true;\n      }\n    } break;\n\n    case EISCONN:           // we are connected :-)\n      WATCHPOINT_ASSERT(0); // This is a programmer's error\n      break;\n\n    case EINTR: // Special case, we retry ai_addr\n      WATCHPOINT_ASSERT(server->fd != INVALID_SOCKET);\n      server->reset_socket();\n      continue;\n\n    case ECONNREFUSED:\n      // Probably not running service\n\n    default:\n      memcached_set_errno(*server, local_error, MEMCACHED_AT);\n      break;\n    }\n\n    WATCHPOINT_ASSERT(server->fd != INVALID_SOCKET);\n    server->reset_socket();\n    server->address_info_next = server->address_info_next->ai_next;\n  }\n\n  WATCHPOINT_ASSERT(server->fd == INVALID_SOCKET);\n\n  if (timeout_error_occured) {\n    server->reset_socket();\n  }\n\n  WATCHPOINT_STRING(\"Never got a good file descriptor\");\n\n  if (memcached_has_current_error(*server)) {\n    return memcached_instance_error_return(server);\n  }\n\n  if (timeout_error_occured and server->state < MEMCACHED_SERVER_STATE_IN_PROGRESS) {\n    return memcached_set_error(\n        *server, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n        memcached_literal_param(\n            \"if (timeout_error_occured and server->state < MEMCACHED_SERVER_STATE_IN_PROGRESS)\"));\n  }\n\n  return memcached_set_error(*server, MEMCACHED_CONNECTION_FAILURE,\n                             MEMCACHED_AT); /* The last error should be from connect() */\n}"
  },
  {
    "function_name": "unix_socket_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
    "lines": "258-321",
    "snippet": "static memcached_return_t unix_socket_connect(memcached_instance_st *server) {\n#ifndef _WIN32\n  WATCHPOINT_ASSERT(server->fd == INVALID_SOCKET);\n\n  do {\n    int type = SOCK_STREAM;\n    if (SOCK_CLOEXEC) {\n      type |= SOCK_CLOEXEC;\n    }\n\n    if (SOCK_NONBLOCK) {\n      type |= SOCK_NONBLOCK;\n    }\n\n    if ((server->fd = socket(AF_UNIX, type, 0)) == -1) {\n      return memcached_set_errno(*server, errno, NULL);\n    }\n\n    struct sockaddr_un servAddr;\n\n    memset(&servAddr, 0, sizeof(struct sockaddr_un));\n    servAddr.sun_family = AF_UNIX;\n    if (strlen(server->hostname()) >= sizeof(servAddr.sun_path)) {\n      return memcached_set_error(*server, MEMCACHED_FAIL_UNIX_SOCKET, MEMCACHED_AT);\n    }\n    strncpy(servAddr.sun_path, server->hostname(),\n            sizeof(servAddr.sun_path) - 1); /* Copy filename */\n\n    if (connect(server->fd, (struct sockaddr *) &servAddr, sizeof(servAddr)) == -1) {\n      switch (errno) {\n      case EINPROGRESS:\n      case EALREADY:\n      case EAGAIN:\n        server->events(POLLOUT);\n        break;\n\n      case EINTR:\n        server->reset_socket();\n        continue;\n\n      case EISCONN: /* We were spinning waiting on connect */\n      {\n        assert(0); // Programmer error\n        server->reset_socket();\n        continue;\n      }\n\n      default:\n        WATCHPOINT_ERRNO(errno);\n        server->reset_socket();\n        return memcached_set_errno(*server, errno, MEMCACHED_AT);\n      }\n    }\n  } while (0);\n  server->state = MEMCACHED_SERVER_STATE_CONNECTED;\n\n  WATCHPOINT_ASSERT(server->fd != INVALID_SOCKET);\n\n  return MEMCACHED_SUCCESS;\n#else\n  (void) server;\n  return MEMCACHED_NOT_SUPPORTED;\n#endif\n}",
    "includes": [
      "#include <cassert>",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "server->fd != INVALID_SOCKET"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_errno",
          "args": [
            "*server",
            "errno",
            "MEMCACHED_AT"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "378-398",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->reset_socket",
          "args": [],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "reset_socket",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "640-645",
          "snippet": "void memcached_instance_st::reset_socket() {\n  if (fd != INVALID_SOCKET) {\n    (void) closesocket(fd);\n    fd = INVALID_SOCKET;\n  }\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_instance_st {\n  void memcached_instance_st::reset_socket() {\n    if (fd != INVALID_SOCKET) {\n      (void) closesocket(fd);\n      fd = INVALID_SOCKET;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ERRNO",
          "args": [
            "errno"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->events",
          "args": [
            "POLLOUT"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "events",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
          "lines": "83-89",
          "snippet": "void memcached_instance_st::events(short arg) {\n  if ((_events | arg) == _events) {\n    return;\n  }\n\n  _events |= arg;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_instance_st {\n  void memcached_instance_st::events(short arg) {\n    if ((_events | arg) == _events) {\n      return;\n    }\n  \n    _events |= arg;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "server->fd",
            "(struct sockaddr *) &servAddr",
            "sizeof(servAddr)"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "servAddr.sun_path",
            "server->hostname()",
            "sizeof(servAddr.sun_path) - 1"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->hostname",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*server",
            "MEMCACHED_FAIL_UNIX_SOCKET",
            "MEMCACHED_AT"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "server->hostname()"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->hostname",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&servAddr",
            "0",
            "sizeof(struct sockaddr_un)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_UNIX",
            "type",
            "0"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_add_unix_socket_with_weight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "426-441",
          "snippet": "memcached_return_t memcached_server_add_unix_socket_with_weight(memcached_st *shell,\n                                                                const char *filename,\n                                                                uint32_t weight) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    memcached_string_t _filename = {memcached_string_make_from_cstr(filename)};\n    if (memcached_is_valid_filename(_filename) == false) {\n      return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                                 memcached_literal_param(\"Invalid filename for socket provided\"));\n    }\n\n    return server_add(ptr, _filename, 0, weight, MEMCACHED_CONNECTION_UNIX_SOCKET);\n  }\n\n  return MEMCACHED_FAILURE;\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t update_continuum(Memcached *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t memcached_server_add_unix_socket_with_weight(memcached_st *shell,\n                                                                const char *filename,\n                                                                uint32_t weight) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    memcached_string_t _filename = {memcached_string_make_from_cstr(filename)};\n    if (memcached_is_valid_filename(_filename) == false) {\n      return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                                 memcached_literal_param(\"Invalid filename for socket provided\"));\n    }\n\n    return server_add(ptr, _filename, 0, weight, MEMCACHED_CONNECTION_UNIX_SOCKET);\n  }\n\n  return MEMCACHED_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "server->fd == INVALID_SOCKET"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t unix_socket_connect(memcached_instance_st *server) {\n#ifndef _WIN32\n  WATCHPOINT_ASSERT(server->fd == INVALID_SOCKET);\n\n  do {\n    int type = SOCK_STREAM;\n    if (SOCK_CLOEXEC) {\n      type |= SOCK_CLOEXEC;\n    }\n\n    if (SOCK_NONBLOCK) {\n      type |= SOCK_NONBLOCK;\n    }\n\n    if ((server->fd = socket(AF_UNIX, type, 0)) == -1) {\n      return memcached_set_errno(*server, errno, NULL);\n    }\n\n    struct sockaddr_un servAddr;\n\n    memset(&servAddr, 0, sizeof(struct sockaddr_un));\n    servAddr.sun_family = AF_UNIX;\n    if (strlen(server->hostname()) >= sizeof(servAddr.sun_path)) {\n      return memcached_set_error(*server, MEMCACHED_FAIL_UNIX_SOCKET, MEMCACHED_AT);\n    }\n    strncpy(servAddr.sun_path, server->hostname(),\n            sizeof(servAddr.sun_path) - 1); /* Copy filename */\n\n    if (connect(server->fd, (struct sockaddr *) &servAddr, sizeof(servAddr)) == -1) {\n      switch (errno) {\n      case EINPROGRESS:\n      case EALREADY:\n      case EAGAIN:\n        server->events(POLLOUT);\n        break;\n\n      case EINTR:\n        server->reset_socket();\n        continue;\n\n      case EISCONN: /* We were spinning waiting on connect */\n      {\n        assert(0); // Programmer error\n        server->reset_socket();\n        continue;\n      }\n\n      default:\n        WATCHPOINT_ERRNO(errno);\n        server->reset_socket();\n        return memcached_set_errno(*server, errno, MEMCACHED_AT);\n      }\n    }\n  } while (0);\n  server->state = MEMCACHED_SERVER_STATE_CONNECTED;\n\n  WATCHPOINT_ASSERT(server->fd != INVALID_SOCKET);\n\n  return MEMCACHED_SUCCESS;\n#else\n  (void) server;\n  return MEMCACHED_NOT_SUPPORTED;\n#endif\n}"
  },
  {
    "function_name": "set_socket_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
    "lines": "124-256",
    "snippet": "static bool set_socket_options(memcached_instance_st *server) {\n  assert_msg(server->fd != INVALID_SOCKET, \"invalid socket was passed to set_socket_options()\");\n\n#ifdef HAVE_FCNTL\n  // If SOCK_CLOEXEC exists then we don't need to call the following\n  if (SOCK_CLOEXEC == 0) {\n    if (FD_CLOEXEC) {\n      int flags;\n      do {\n        flags = fcntl(server->fd, F_GETFD, 0);\n      } while (flags == -1 and (errno == EINTR or errno == EAGAIN));\n\n      if (flags != -1) {\n        int rval;\n        do {\n          rval = fcntl(server->fd, F_SETFD, flags | FD_CLOEXEC);\n        } while (rval == -1 && (errno == EINTR or errno == EAGAIN));\n        // we currently ignore the case where rval is -1\n      }\n    }\n  }\n#endif\n\n  if (memcached_is_udp(server->root)) {\n    return true;\n  }\n\n#ifdef HAVE_SO_SNDTIMEO\n  if (server->root->snd_timeout > 0) {\n    struct timeval waittime;\n\n    waittime.tv_sec = server->root->snd_timeout / 1000000;\n    waittime.tv_usec = server->root->snd_timeout % 1000000;\n\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_SNDTIMEO, (char *) &waittime,\n                           (socklen_t) sizeof(struct timeval));\n    (void) error;\n    assert(error == 0);\n  }\n#endif\n\n#ifdef HAVE_SO_RCVTIMEO\n  if (server->root->rcv_timeout > 0) {\n    struct timeval waittime;\n\n    waittime.tv_sec = server->root->rcv_timeout / 1000000;\n    waittime.tv_usec = server->root->rcv_timeout % 1000000;\n\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_RCVTIMEO, (char *) &waittime,\n                           (socklen_t) sizeof(struct timeval));\n    (void) (error);\n    assert(error == 0);\n  }\n#endif\n\n#if defined(_WIN32)\n#else\n#  if defined(SO_NOSIGPIPE)\n  if (SO_NOSIGPIPE) {\n    int set = 1;\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_NOSIGPIPE, (void *) &set, sizeof(int));\n\n    assert(error == 0);\n\n    // This is not considered a fatal error\n    if (error == -1) {\n#    if 0\n      perror(\"setsockopt(SO_NOSIGPIPE)\");\n#    endif\n    }\n  }\n#  endif // SO_NOSIGPIPE\n#endif   // _WIN32\n\n  if (server->root->flags.no_block) {\n    struct linger linger;\n\n    linger.l_onoff = 1;\n    linger.l_linger = 0; /* By default on close() just drop the socket */\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_LINGER, (char *) &linger,\n                           (socklen_t) sizeof(struct linger));\n    (void) (error);\n    assert(error == 0);\n  }\n\n  if (TCP_NODELAY) {\n    if (server->root->flags.tcp_nodelay) {\n      int flag = 1;\n\n      int error =\n          setsockopt(server->fd, IPPROTO_TCP, TCP_NODELAY, (char *) &flag, (socklen_t) sizeof(int));\n      (void) (error);\n      assert(error == 0);\n    }\n  }\n\n  if (server->root->flags.tcp_keepalive) {\n    int flag = 1;\n\n    int error =\n        setsockopt(server->fd, SOL_SOCKET, SO_KEEPALIVE, (char *) &flag, (socklen_t) sizeof(int));\n    (void) (error);\n    assert(error == 0);\n  }\n\n  if (TCP_KEEPIDLE) {\n    if (server->root->tcp_keepidle > 0) {\n      int error = setsockopt(server->fd, IPPROTO_TCP, TCP_KEEPIDLE,\n                             (char *) &server->root->tcp_keepidle, (socklen_t) sizeof(int));\n      (void) (error);\n      assert(error == 0);\n    }\n  }\n\n  if (server->root->send_size > 0) {\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_SNDBUF, (char *) &server->root->send_size,\n                           (socklen_t) sizeof(int));\n    (void) (error);\n    assert(error == 0);\n  }\n\n  if (server->root->recv_size > 0) {\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_RCVBUF, (char *) &server->root->recv_size,\n                           (socklen_t) sizeof(int));\n    (void) (error);\n    assert(error == 0);\n  }\n\n  /* libmemcached will always use nonblocking IO to avoid write deadlocks */\n  set_socket_nonblocking(server);\n\n  return true;\n}",
    "includes": [
      "#include <cassert>",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_socket_nonblocking",
          "args": [
            "server"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "set_socket_nonblocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
          "lines": "93-122",
          "snippet": "static inline void set_socket_nonblocking(memcached_instance_st *server) {\n#if defined(_WIN32)\n  u_long arg = 1;\n  if (ioctlsocket(server->fd, FIONBIO, &arg) == SOCKET_ERROR) {\n    memcached_set_errno(*server, get_socket_errno(), NULL);\n  }\n#else\n  int flags;\n\n  if (SOCK_NONBLOCK == 0) {\n    do {\n      flags = fcntl(server->fd, F_GETFL, 0);\n    } while (flags == -1 && (errno == EINTR || errno == EAGAIN));\n\n    if (flags == -1) {\n      memcached_set_errno(*server, errno, NULL);\n    } else if ((flags & O_NONBLOCK) == 0) {\n      int rval;\n\n      do {\n        rval = fcntl(server->fd, F_SETFL, flags | O_NONBLOCK);\n      } while (rval == -1 && (errno == EINTR or errno == EAGAIN));\n\n      if (rval == -1) {\n        memcached_set_errno(*server, errno, NULL);\n      }\n    }\n  }\n#endif\n}",
          "includes": [
            "#include <cassert>",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic inline void set_socket_nonblocking(memcached_instance_st *server) {\n#if defined(_WIN32)\n  u_long arg = 1;\n  if (ioctlsocket(server->fd, FIONBIO, &arg) == SOCKET_ERROR) {\n    memcached_set_errno(*server, get_socket_errno(), NULL);\n  }\n#else\n  int flags;\n\n  if (SOCK_NONBLOCK == 0) {\n    do {\n      flags = fcntl(server->fd, F_GETFL, 0);\n    } while (flags == -1 && (errno == EINTR || errno == EAGAIN));\n\n    if (flags == -1) {\n      memcached_set_errno(*server, errno, NULL);\n    } else if ((flags & O_NONBLOCK) == 0) {\n      int rval;\n\n      do {\n        rval = fcntl(server->fd, F_SETFL, flags | O_NONBLOCK);\n      } while (rval == -1 && (errno == EINTR or errno == EAGAIN));\n\n      if (rval == -1) {\n        memcached_set_errno(*server, errno, NULL);\n      }\n    }\n  }\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "error == 0"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "server->fd",
            "SOL_SOCKET",
            "SO_RCVBUF",
            "(char *) &server->root->recv_size",
            "(socklen_t) sizeof(int)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "error == 0"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "server->fd",
            "SOL_SOCKET",
            "SO_SNDBUF",
            "(char *) &server->root->send_size",
            "(socklen_t) sizeof(int)"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "error == 0"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "server->fd",
            "IPPROTO_TCP",
            "TCP_KEEPIDLE",
            "(char *) &server->root->tcp_keepidle",
            "(socklen_t) sizeof(int)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "error == 0"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "server->fd",
            "SOL_SOCKET",
            "SO_KEEPALIVE",
            "(char *) &flag",
            "(socklen_t) sizeof(int)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "error == 0"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "server->fd",
            "IPPROTO_TCP",
            "TCP_NODELAY",
            "(char *) &flag",
            "(socklen_t) sizeof(int)"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "error == 0"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "server->fd",
            "SOL_SOCKET",
            "SO_LINGER",
            "(char *) &linger",
            "(socklen_t) sizeof(struct linger)"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"setsockopt(SO_NOSIGPIPE)\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "error == 0"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "server->fd",
            "SOL_SOCKET",
            "SO_NOSIGPIPE",
            "(void *) &set",
            "sizeof(int)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "error == 0"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "server->fd",
            "SOL_SOCKET",
            "SO_RCVTIMEO",
            "(char *) &waittime",
            "(socklen_t) sizeof(struct timeval)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "error == 0"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "server->fd",
            "SOL_SOCKET",
            "SO_SNDTIMEO",
            "(char *) &waittime",
            "(socklen_t) sizeof(struct timeval)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_udp",
          "args": [
            "server->root"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "server->fd",
            "F_SETFD",
            "flags | FD_CLOEXEC"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "server->fd",
            "F_GETFD",
            "0"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "server->fd != INVALID_SOCKET",
            "\"invalid socket was passed to set_socket_options()\""
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic bool set_socket_options(memcached_instance_st *server) {\n  assert_msg(server->fd != INVALID_SOCKET, \"invalid socket was passed to set_socket_options()\");\n\n#ifdef HAVE_FCNTL\n  // If SOCK_CLOEXEC exists then we don't need to call the following\n  if (SOCK_CLOEXEC == 0) {\n    if (FD_CLOEXEC) {\n      int flags;\n      do {\n        flags = fcntl(server->fd, F_GETFD, 0);\n      } while (flags == -1 and (errno == EINTR or errno == EAGAIN));\n\n      if (flags != -1) {\n        int rval;\n        do {\n          rval = fcntl(server->fd, F_SETFD, flags | FD_CLOEXEC);\n        } while (rval == -1 && (errno == EINTR or errno == EAGAIN));\n        // we currently ignore the case where rval is -1\n      }\n    }\n  }\n#endif\n\n  if (memcached_is_udp(server->root)) {\n    return true;\n  }\n\n#ifdef HAVE_SO_SNDTIMEO\n  if (server->root->snd_timeout > 0) {\n    struct timeval waittime;\n\n    waittime.tv_sec = server->root->snd_timeout / 1000000;\n    waittime.tv_usec = server->root->snd_timeout % 1000000;\n\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_SNDTIMEO, (char *) &waittime,\n                           (socklen_t) sizeof(struct timeval));\n    (void) error;\n    assert(error == 0);\n  }\n#endif\n\n#ifdef HAVE_SO_RCVTIMEO\n  if (server->root->rcv_timeout > 0) {\n    struct timeval waittime;\n\n    waittime.tv_sec = server->root->rcv_timeout / 1000000;\n    waittime.tv_usec = server->root->rcv_timeout % 1000000;\n\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_RCVTIMEO, (char *) &waittime,\n                           (socklen_t) sizeof(struct timeval));\n    (void) (error);\n    assert(error == 0);\n  }\n#endif\n\n#if defined(_WIN32)\n#else\n#  if defined(SO_NOSIGPIPE)\n  if (SO_NOSIGPIPE) {\n    int set = 1;\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_NOSIGPIPE, (void *) &set, sizeof(int));\n\n    assert(error == 0);\n\n    // This is not considered a fatal error\n    if (error == -1) {\n#    if 0\n      perror(\"setsockopt(SO_NOSIGPIPE)\");\n#    endif\n    }\n  }\n#  endif // SO_NOSIGPIPE\n#endif   // _WIN32\n\n  if (server->root->flags.no_block) {\n    struct linger linger;\n\n    linger.l_onoff = 1;\n    linger.l_linger = 0; /* By default on close() just drop the socket */\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_LINGER, (char *) &linger,\n                           (socklen_t) sizeof(struct linger));\n    (void) (error);\n    assert(error == 0);\n  }\n\n  if (TCP_NODELAY) {\n    if (server->root->flags.tcp_nodelay) {\n      int flag = 1;\n\n      int error =\n          setsockopt(server->fd, IPPROTO_TCP, TCP_NODELAY, (char *) &flag, (socklen_t) sizeof(int));\n      (void) (error);\n      assert(error == 0);\n    }\n  }\n\n  if (server->root->flags.tcp_keepalive) {\n    int flag = 1;\n\n    int error =\n        setsockopt(server->fd, SOL_SOCKET, SO_KEEPALIVE, (char *) &flag, (socklen_t) sizeof(int));\n    (void) (error);\n    assert(error == 0);\n  }\n\n  if (TCP_KEEPIDLE) {\n    if (server->root->tcp_keepidle > 0) {\n      int error = setsockopt(server->fd, IPPROTO_TCP, TCP_KEEPIDLE,\n                             (char *) &server->root->tcp_keepidle, (socklen_t) sizeof(int));\n      (void) (error);\n      assert(error == 0);\n    }\n  }\n\n  if (server->root->send_size > 0) {\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_SNDBUF, (char *) &server->root->send_size,\n                           (socklen_t) sizeof(int));\n    (void) (error);\n    assert(error == 0);\n  }\n\n  if (server->root->recv_size > 0) {\n    int error = setsockopt(server->fd, SOL_SOCKET, SO_RCVBUF, (char *) &server->root->recv_size,\n                           (socklen_t) sizeof(int));\n    (void) (error);\n    assert(error == 0);\n  }\n\n  /* libmemcached will always use nonblocking IO to avoid write deadlocks */\n  set_socket_nonblocking(server);\n\n  return true;\n}"
  },
  {
    "function_name": "set_socket_nonblocking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
    "lines": "93-122",
    "snippet": "static inline void set_socket_nonblocking(memcached_instance_st *server) {\n#if defined(_WIN32)\n  u_long arg = 1;\n  if (ioctlsocket(server->fd, FIONBIO, &arg) == SOCKET_ERROR) {\n    memcached_set_errno(*server, get_socket_errno(), NULL);\n  }\n#else\n  int flags;\n\n  if (SOCK_NONBLOCK == 0) {\n    do {\n      flags = fcntl(server->fd, F_GETFL, 0);\n    } while (flags == -1 && (errno == EINTR || errno == EAGAIN));\n\n    if (flags == -1) {\n      memcached_set_errno(*server, errno, NULL);\n    } else if ((flags & O_NONBLOCK) == 0) {\n      int rval;\n\n      do {\n        rval = fcntl(server->fd, F_SETFL, flags | O_NONBLOCK);\n      } while (rval == -1 && (errno == EINTR or errno == EAGAIN));\n\n      if (rval == -1) {\n        memcached_set_errno(*server, errno, NULL);\n      }\n    }\n  }\n#endif\n}",
    "includes": [
      "#include <cassert>",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_errno",
          "args": [
            "*server",
            "errno",
            "NULL"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "378-398",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "server->fd",
            "F_SETFL",
            "flags | O_NONBLOCK"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "server->fd",
            "F_GETFL",
            "0"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_socket_errno",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/p9y/p9y.cpp",
          "lines": "48-93",
          "snippet": "int get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}",
          "includes": [
            "#include \"clock_gettime.hpp\"",
            "#include \"poll.hpp\"",
            "#include \"socket.hpp\"",
            "# include <chrono>",
            "#include \"gettimeofday.hpp\"",
            "#include \"realpath.hpp\"",
            "# include <cstring>",
            "#include \"libgen.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"clock_gettime.hpp\"\n#include \"poll.hpp\"\n#include \"socket.hpp\"\n# include <chrono>\n#include \"gettimeofday.hpp\"\n#include \"realpath.hpp\"\n# include <cstring>\n#include \"libgen.hpp\"\n\nint get_socket_errno() {\n    int local_errno = WSAGetLastError();\n\n  switch (local_errno) {\n  case WSAEINVAL:\n    local_errno = EINPROGRESS;\n    break;\n  case WSAEALREADY:\n  case WSAEWOULDBLOCK:\n    local_errno = EAGAIN;\n    break;\n\n  case WSAECONNREFUSED:\n    local_errno = ECONNREFUSED;\n    break;\n\n  case WSAENETUNREACH:\n    local_errno = ENETUNREACH;\n    break;\n\n  case WSAETIMEDOUT:\n    local_errno = ETIMEDOUT;\n    break;\n\n  case WSAECONNRESET:\n    local_errno = ECONNRESET;\n    break;\n\n  case WSAEADDRINUSE:\n    local_errno = EADDRINUSE;\n    break;\n\n  case WSAEOPNOTSUPP:\n    local_errno = EOPNOTSUPP;\n    break;\n\n  case WSAENOPROTOOPT:\n    local_errno = ENOPROTOOPT;\n    break;\n\n  default:\n    break;\n  }\n\n  return local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctlsocket",
          "args": [
            "server->fd",
            "FIONBIO",
            "&arg"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic inline void set_socket_nonblocking(memcached_instance_st *server) {\n#if defined(_WIN32)\n  u_long arg = 1;\n  if (ioctlsocket(server->fd, FIONBIO, &arg) == SOCKET_ERROR) {\n    memcached_set_errno(*server, get_socket_errno(), NULL);\n  }\n#else\n  int flags;\n\n  if (SOCK_NONBLOCK == 0) {\n    do {\n      flags = fcntl(server->fd, F_GETFL, 0);\n    } while (flags == -1 && (errno == EINTR || errno == EAGAIN));\n\n    if (flags == -1) {\n      memcached_set_errno(*server, errno, NULL);\n    } else if ((flags & O_NONBLOCK) == 0) {\n      int rval;\n\n      do {\n        rval = fcntl(server->fd, F_SETFL, flags | O_NONBLOCK);\n      } while (rval == -1 && (errno == EINTR or errno == EAGAIN));\n\n      if (rval == -1) {\n        memcached_set_errno(*server, errno, NULL);\n      }\n    }\n  }\n#endif\n}"
  },
  {
    "function_name": "set_hostinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/connect.cc",
    "lines": "21-91",
    "snippet": "static memcached_return_t set_hostinfo(memcached_instance_st *server) {\n  assert(server->type != MEMCACHED_CONNECTION_UNIX_SOCKET);\n  assert(server->hostname());\n\n  server->clear_addrinfo();\n\n  char str_host[MEMCACHED_NI_MAXHOST] = {0}, str_port[MEMCACHED_NI_MAXSERV] = {0};\n  errno = 0;\n\n  auto length = snprintf(str_port, MEMCACHED_NI_MAXSERV, \"%u\", uint32_t(server->port()));\n  if (length <= 0 or errno) {\n    return memcached_set_error(*server, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"snprintf(NI_MAXSERV)\"));\n  }\n\n  struct addrinfo hints{};\n  hints.ai_family = AF_UNSPEC;\n  if (memcached_is_udp(server->root)) {\n    hints.ai_protocol = IPPROTO_UDP;\n    hints.ai_socktype = SOCK_DGRAM;\n  } else {\n    hints.ai_protocol = IPPROTO_TCP;\n    hints.ai_socktype = SOCK_STREAM;\n  }\n\n  auto hostname = server->hostname();\n  if (*hostname == '[') {\n    auto closing_bracket = &hostname[strlen(hostname) - 1];\n    if (*closing_bracket == ']') {\n      auto host_len = closing_bracket - hostname - 1;\n      if (host_len < MEMCACHED_NI_MAXHOST) {\n        hostname = strncpy(str_host, hostname + 1, host_len);\n      }\n    }\n  }\n\n  auto errcode = getaddrinfo(hostname, str_port, &hints, &server->address_info);\n  switch (errcode) {\n  case 0:\n    server->address_info_next = server->address_info;\n    server->state = MEMCACHED_SERVER_STATE_ADDRINFO;\n    break;\n\n  case EAI_AGAIN:\n    return memcached_set_error(*server, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                               memcached_string_make_from_cstr(gai_strerror(errcode)));\n\n  case EAI_SYSTEM:\n    server->clear_addrinfo();\n    return memcached_set_errno(*server, errno, MEMCACHED_AT,\n                               memcached_literal_param(\"getaddrinfo(EAI_SYSTEM)\"));\n\n  case EAI_BADFLAGS:\n    server->clear_addrinfo();\n    return memcached_set_error(*server, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"getaddrinfo(EAI_BADFLAGS)\"));\n\n  case EAI_MEMORY:\n    server->clear_addrinfo();\n    return memcached_set_error(*server, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"getaddrinfo(EAI_MEMORY)\"));\n\n  default: {\n    server->clear_addrinfo();\n    return memcached_set_error(*server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT,\n                               memcached_string_make_from_cstr(gai_strerror(errcode)));\n  }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include <cassert>",
      "#include \"p9y/poll.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*server",
            "MEMCACHED_HOST_LOOKUP_FAILURE",
            "MEMCACHED_AT",
            "memcached_string_make_from_cstr(gai_strerror(errcode))"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_string_make_from_cstr",
          "args": [
            "gai_strerror(errcode)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "errcode"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->clear_addrinfo",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "clear_addrinfo",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.hpp",
          "lines": "129-135",
          "snippet": "void clear_addrinfo() {\n    if (address_info) {\n      freeaddrinfo(address_info);\n      address_info = NULL;\n      address_info_next = NULL;\n    }\n  }",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#    include <netdb.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#    include <netdb.h>\n\nmemcached_instance_st {\n  void clear_addrinfo() {\n      if (address_info) {\n        freeaddrinfo(address_info);\n        address_info = NULL;\n        address_info_next = NULL;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"getaddrinfo(EAI_MEMORY)\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"getaddrinfo(EAI_BADFLAGS)\""
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_errno",
          "args": [
            "*server",
            "errno",
            "MEMCACHED_AT",
            "memcached_literal_param(\"getaddrinfo(EAI_SYSTEM)\")"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "340-376",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  size_t size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n  }\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n#if 0\n  if (self.root->error_messages->rc != self.error_messages->rc)\n  {\n    fprintf(stderr, \"%s:%d %s != %s\\n\", __FILE__, __LINE__,\n            memcached_strerror(NULL, self.root->error_messages->rc),\n            memcached_strerror(NULL, self.error_messages->rc));\n  }\n#endif\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno, const char *at,\n                                       memcached_string_t &str) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  size_t size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n  }\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n#if 0\n  if (self.root->error_messages->rc != self.error_messages->rc)\n  {\n    fprintf(stderr, \"%s:%d %s != %s\\n\", __FILE__, __LINE__,\n            memcached_strerror(NULL, self.root->error_messages->rc),\n            memcached_strerror(NULL, self.error_messages->rc));\n  }\n#endif\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"getaddrinfo(EAI_SYSTEM)\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_string_make_from_cstr",
          "args": [
            "gai_strerror(errcode)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "errcode"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "hostname",
            "str_port",
            "&hints",
            "&server->address_info"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "str_host",
            "hostname + 1",
            "host_len"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "hostname"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->hostname",
          "args": [],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_udp",
          "args": [
            "server->root"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"snprintf(NI_MAXSERV)\""
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str_port",
            "MEMCACHED_NI_MAXSERV",
            "\"%u\"",
            "uint32_t(server->port())"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint32_t",
          "args": [
            "server->port()"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->port",
          "args": [],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "port",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.hpp",
          "lines": "40-40",
          "snippet": "in_port_t port() const { return port_; }",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#    include <netdb.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#    include <netdb.h>\n\nmemcached_instance_st {\n  in_port_t port() const { return port_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "server->hostname()"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->hostname",
          "args": [],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "server->type != MEMCACHED_CONNECTION_UNIX_SOCKET"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cassert>\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t set_hostinfo(memcached_instance_st *server) {\n  assert(server->type != MEMCACHED_CONNECTION_UNIX_SOCKET);\n  assert(server->hostname());\n\n  server->clear_addrinfo();\n\n  char str_host[MEMCACHED_NI_MAXHOST] = {0}, str_port[MEMCACHED_NI_MAXSERV] = {0};\n  errno = 0;\n\n  auto length = snprintf(str_port, MEMCACHED_NI_MAXSERV, \"%u\", uint32_t(server->port()));\n  if (length <= 0 or errno) {\n    return memcached_set_error(*server, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"snprintf(NI_MAXSERV)\"));\n  }\n\n  struct addrinfo hints{};\n  hints.ai_family = AF_UNSPEC;\n  if (memcached_is_udp(server->root)) {\n    hints.ai_protocol = IPPROTO_UDP;\n    hints.ai_socktype = SOCK_DGRAM;\n  } else {\n    hints.ai_protocol = IPPROTO_TCP;\n    hints.ai_socktype = SOCK_STREAM;\n  }\n\n  auto hostname = server->hostname();\n  if (*hostname == '[') {\n    auto closing_bracket = &hostname[strlen(hostname) - 1];\n    if (*closing_bracket == ']') {\n      auto host_len = closing_bracket - hostname - 1;\n      if (host_len < MEMCACHED_NI_MAXHOST) {\n        hostname = strncpy(str_host, hostname + 1, host_len);\n      }\n    }\n  }\n\n  auto errcode = getaddrinfo(hostname, str_port, &hints, &server->address_info);\n  switch (errcode) {\n  case 0:\n    server->address_info_next = server->address_info;\n    server->state = MEMCACHED_SERVER_STATE_ADDRINFO;\n    break;\n\n  case EAI_AGAIN:\n    return memcached_set_error(*server, MEMCACHED_TIMEOUT, MEMCACHED_AT,\n                               memcached_string_make_from_cstr(gai_strerror(errcode)));\n\n  case EAI_SYSTEM:\n    server->clear_addrinfo();\n    return memcached_set_errno(*server, errno, MEMCACHED_AT,\n                               memcached_literal_param(\"getaddrinfo(EAI_SYSTEM)\"));\n\n  case EAI_BADFLAGS:\n    server->clear_addrinfo();\n    return memcached_set_error(*server, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"getaddrinfo(EAI_BADFLAGS)\"));\n\n  case EAI_MEMORY:\n    server->clear_addrinfo();\n    return memcached_set_error(*server, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                               memcached_literal_param(\"getaddrinfo(EAI_MEMORY)\"));\n\n  default: {\n    server->clear_addrinfo();\n    return memcached_set_error(*server, MEMCACHED_HOST_LOOKUP_FAILURE, MEMCACHED_AT,\n                               memcached_string_make_from_cstr(gai_strerror(errcode)));\n  }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
  }
]