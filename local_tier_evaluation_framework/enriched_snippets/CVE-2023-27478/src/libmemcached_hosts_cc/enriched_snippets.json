[
  {
    "function_name": "memcached_server_add_parsed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
    "lines": "491-502",
    "snippet": "memcached_return_t memcached_server_add_parsed(memcached_st *ptr, const char *hostname,\n                                               size_t hostname_length, in_port_t port,\n                                               uint32_t weight) {\n  char buffer[MEMCACHED_NI_MAXHOST] = {0};\n\n  memcpy(buffer, hostname, hostname_length);\n  buffer[hostname_length] = 0;\n\n  memcached_string_t _hostname = {buffer, hostname_length};\n\n  return server_add(ptr, _hostname, port, weight, MEMCACHED_CONNECTION_TCP);\n}",
    "includes": [
      "#include <cmath>",
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_return_t update_continuum(Memcached *ptr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "server_add",
          "args": [
            "ptr",
            "_hostname",
            "port",
            "weight",
            "MEMCACHED_CONNECTION_TCP"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_add_parsed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "491-502",
          "snippet": "memcached_return_t memcached_server_add_parsed(memcached_st *ptr, const char *hostname,\n                                               size_t hostname_length, in_port_t port,\n                                               uint32_t weight) {\n  char buffer[MEMCACHED_NI_MAXHOST] = {0};\n\n  memcpy(buffer, hostname, hostname_length);\n  buffer[hostname_length] = 0;\n\n  memcached_string_t _hostname = {buffer, hostname_length};\n\n  return server_add(ptr, _hostname, port, weight, MEMCACHED_CONNECTION_TCP);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "hostname",
            "hostname_length"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t memcached_server_add_parsed(memcached_st *ptr, const char *hostname,\n                                               size_t hostname_length, in_port_t port,\n                                               uint32_t weight) {\n  char buffer[MEMCACHED_NI_MAXHOST] = {0};\n\n  memcpy(buffer, hostname, hostname_length);\n  buffer[hostname_length] = 0;\n\n  memcached_string_t _hostname = {buffer, hostname_length};\n\n  return server_add(ptr, _hostname, port, weight, MEMCACHED_CONNECTION_TCP);\n}"
  },
  {
    "function_name": "memcached_server_add_with_weight",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
    "lines": "462-489",
    "snippet": "memcached_return_t memcached_server_add_with_weight(memcached_st *shell, const char *hostname,\n                                                    in_port_t port, uint32_t weight) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (port == 0) {\n    port = MEMCACHED_DEFAULT_PORT;\n  }\n\n  size_t hostname_length = hostname ? strlen(hostname) : 0;\n  if (hostname_length == 0) {\n    hostname = \"localhost\";\n    hostname_length = memcached_literal_param_size(\"localhost\");\n  }\n\n  memcached_string_t _hostname = {hostname, hostname_length};\n\n  if (memcached_is_valid_servername(_hostname) == false) {\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Invalid hostname provided\"));\n  }\n\n  return server_add(ptr, _hostname, port, weight,\n                    _hostname.c_str[0] == '/' ? MEMCACHED_CONNECTION_UNIX_SOCKET\n                                              : MEMCACHED_CONNECTION_TCP);\n}",
    "includes": [
      "#include <cmath>",
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_return_t update_continuum(Memcached *ptr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "server_add",
          "args": [
            "ptr",
            "_hostname",
            "port",
            "weight",
            "_hostname.c_str[0] == '/' ? MEMCACHED_CONNECTION_UNIX_SOCKET\n                                              : MEMCACHED_CONNECTION_TCP"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_add_parsed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "491-502",
          "snippet": "memcached_return_t memcached_server_add_parsed(memcached_st *ptr, const char *hostname,\n                                               size_t hostname_length, in_port_t port,\n                                               uint32_t weight) {\n  char buffer[MEMCACHED_NI_MAXHOST] = {0};\n\n  memcpy(buffer, hostname, hostname_length);\n  buffer[hostname_length] = 0;\n\n  memcached_string_t _hostname = {buffer, hostname_length};\n\n  return server_add(ptr, _hostname, port, weight, MEMCACHED_CONNECTION_TCP);\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t update_continuum(Memcached *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t memcached_server_add_parsed(memcached_st *ptr, const char *hostname,\n                                               size_t hostname_length, in_port_t port,\n                                               uint32_t weight) {\n  char buffer[MEMCACHED_NI_MAXHOST] = {0};\n\n  memcpy(buffer, hostname, hostname_length);\n  buffer[hostname_length] = 0;\n\n  memcached_string_t _hostname = {buffer, hostname_length};\n\n  return server_add(ptr, _hostname, port, weight, MEMCACHED_CONNECTION_TCP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "MEMCACHED_INVALID_ARGUMENTS",
            "MEMCACHED_AT",
            "memcached_literal_param(\"Invalid hostname provided\")"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Invalid hostname provided\""
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_valid_servername",
          "args": [
            "_hostname"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_is_valid_servername",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.hpp",
          "lines": "32-34",
          "snippet": "static inline bool memcached_is_valid_servername(const memcached_string_t &arg) {\n  return (arg.c_str != NULL or arg.size == 0) and arg.size < MEMCACHED_NI_MAXHOST;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"p9y/gettimeofday.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"p9y/gettimeofday.hpp\"\n\nstatic inline bool memcached_is_valid_servername(const memcached_string_t &arg) {\n  return (arg.c_str != NULL or arg.size == 0) and arg.size < MEMCACHED_NI_MAXHOST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param_size",
          "args": [
            "\"localhost\""
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "hostname"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t memcached_server_add_with_weight(memcached_st *shell, const char *hostname,\n                                                    in_port_t port, uint32_t weight) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (port == 0) {\n    port = MEMCACHED_DEFAULT_PORT;\n  }\n\n  size_t hostname_length = hostname ? strlen(hostname) : 0;\n  if (hostname_length == 0) {\n    hostname = \"localhost\";\n    hostname_length = memcached_literal_param_size(\"localhost\");\n  }\n\n  memcached_string_t _hostname = {hostname, hostname_length};\n\n  if (memcached_is_valid_servername(_hostname) == false) {\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Invalid hostname provided\"));\n  }\n\n  return server_add(ptr, _hostname, port, weight,\n                    _hostname.c_str[0] == '/' ? MEMCACHED_CONNECTION_UNIX_SOCKET\n                                              : MEMCACHED_CONNECTION_TCP);\n}"
  },
  {
    "function_name": "memcached_server_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
    "lines": "458-460",
    "snippet": "memcached_return_t memcached_server_add(memcached_st *shell, const char *hostname, in_port_t port) {\n  return memcached_server_add_with_weight(shell, hostname, port, 0);\n}",
    "includes": [
      "#include <cmath>",
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_server_add_with_weight",
          "args": [
            "shell",
            "hostname",
            "port",
            "0"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_add_with_weight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "462-489",
          "snippet": "memcached_return_t memcached_server_add_with_weight(memcached_st *shell, const char *hostname,\n                                                    in_port_t port, uint32_t weight) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (port == 0) {\n    port = MEMCACHED_DEFAULT_PORT;\n  }\n\n  size_t hostname_length = hostname ? strlen(hostname) : 0;\n  if (hostname_length == 0) {\n    hostname = \"localhost\";\n    hostname_length = memcached_literal_param_size(\"localhost\");\n  }\n\n  memcached_string_t _hostname = {hostname, hostname_length};\n\n  if (memcached_is_valid_servername(_hostname) == false) {\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Invalid hostname provided\"));\n  }\n\n  return server_add(ptr, _hostname, port, weight,\n                    _hostname.c_str[0] == '/' ? MEMCACHED_CONNECTION_UNIX_SOCKET\n                                              : MEMCACHED_CONNECTION_TCP);\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t update_continuum(Memcached *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t memcached_server_add_with_weight(memcached_st *shell, const char *hostname,\n                                                    in_port_t port, uint32_t weight) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (port == 0) {\n    port = MEMCACHED_DEFAULT_PORT;\n  }\n\n  size_t hostname_length = hostname ? strlen(hostname) : 0;\n  if (hostname_length == 0) {\n    hostname = \"localhost\";\n    hostname_length = memcached_literal_param_size(\"localhost\");\n  }\n\n  memcached_string_t _hostname = {hostname, hostname_length};\n\n  if (memcached_is_valid_servername(_hostname) == false) {\n    return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Invalid hostname provided\"));\n  }\n\n  return server_add(ptr, _hostname, port, weight,\n                    _hostname.c_str[0] == '/' ? MEMCACHED_CONNECTION_UNIX_SOCKET\n                                              : MEMCACHED_CONNECTION_TCP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_server_add(memcached_st *shell, const char *hostname, in_port_t port) {\n  return memcached_server_add_with_weight(shell, hostname, port, 0);\n}"
  },
  {
    "function_name": "memcached_server_add_udp_with_weight",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
    "lines": "448-456",
    "snippet": "memcached_return_t memcached_server_add_udp_with_weight(memcached_st *shell, const char *,\n                                                        in_port_t, uint32_t) {\n  Memcached *self = memcached2Memcached(shell);\n  if (self) {\n    return memcached_set_error(*self, MEMCACHED_DEPRECATED, MEMCACHED_AT);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
    "includes": [
      "#include <cmath>",
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*self",
            "MEMCACHED_DEPRECATED",
            "MEMCACHED_AT"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_server_add_udp_with_weight(memcached_st *shell, const char *,\n                                                        in_port_t, uint32_t) {\n  Memcached *self = memcached2Memcached(shell);\n  if (self) {\n    return memcached_set_error(*self, MEMCACHED_DEPRECATED, MEMCACHED_AT);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
  },
  {
    "function_name": "memcached_server_add_udp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
    "lines": "443-446",
    "snippet": "memcached_return_t memcached_server_add_udp(memcached_st *ptr, const char *hostname,\n                                            in_port_t port) {\n  return memcached_server_add_udp_with_weight(ptr, hostname, port, 0);\n}",
    "includes": [
      "#include <cmath>",
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_return_t update_continuum(Memcached *ptr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_server_add_udp_with_weight",
          "args": [
            "ptr",
            "hostname",
            "port",
            "0"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_add_udp_with_weight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "448-456",
          "snippet": "memcached_return_t memcached_server_add_udp_with_weight(memcached_st *shell, const char *,\n                                                        in_port_t, uint32_t) {\n  Memcached *self = memcached2Memcached(shell);\n  if (self) {\n    return memcached_set_error(*self, MEMCACHED_DEPRECATED, MEMCACHED_AT);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_server_add_udp_with_weight(memcached_st *shell, const char *,\n                                                        in_port_t, uint32_t) {\n  Memcached *self = memcached2Memcached(shell);\n  if (self) {\n    return memcached_set_error(*self, MEMCACHED_DEPRECATED, MEMCACHED_AT);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t memcached_server_add_udp(memcached_st *ptr, const char *hostname,\n                                            in_port_t port) {\n  return memcached_server_add_udp_with_weight(ptr, hostname, port, 0);\n}"
  },
  {
    "function_name": "memcached_server_add_unix_socket_with_weight",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
    "lines": "426-441",
    "snippet": "memcached_return_t memcached_server_add_unix_socket_with_weight(memcached_st *shell,\n                                                                const char *filename,\n                                                                uint32_t weight) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    memcached_string_t _filename = {memcached_string_make_from_cstr(filename)};\n    if (memcached_is_valid_filename(_filename) == false) {\n      return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                                 memcached_literal_param(\"Invalid filename for socket provided\"));\n    }\n\n    return server_add(ptr, _filename, 0, weight, MEMCACHED_CONNECTION_UNIX_SOCKET);\n  }\n\n  return MEMCACHED_FAILURE;\n}",
    "includes": [
      "#include <cmath>",
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_return_t update_continuum(Memcached *ptr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "server_add",
          "args": [
            "ptr",
            "_filename",
            "0",
            "weight",
            "MEMCACHED_CONNECTION_UNIX_SOCKET"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_add_parsed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "491-502",
          "snippet": "memcached_return_t memcached_server_add_parsed(memcached_st *ptr, const char *hostname,\n                                               size_t hostname_length, in_port_t port,\n                                               uint32_t weight) {\n  char buffer[MEMCACHED_NI_MAXHOST] = {0};\n\n  memcpy(buffer, hostname, hostname_length);\n  buffer[hostname_length] = 0;\n\n  memcached_string_t _hostname = {buffer, hostname_length};\n\n  return server_add(ptr, _hostname, port, weight, MEMCACHED_CONNECTION_TCP);\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t update_continuum(Memcached *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t memcached_server_add_parsed(memcached_st *ptr, const char *hostname,\n                                               size_t hostname_length, in_port_t port,\n                                               uint32_t weight) {\n  char buffer[MEMCACHED_NI_MAXHOST] = {0};\n\n  memcpy(buffer, hostname, hostname_length);\n  buffer[hostname_length] = 0;\n\n  memcached_string_t _hostname = {buffer, hostname_length};\n\n  return server_add(ptr, _hostname, port, weight, MEMCACHED_CONNECTION_TCP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "MEMCACHED_INVALID_ARGUMENTS",
            "MEMCACHED_AT",
            "memcached_literal_param(\"Invalid filename for socket provided\")"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"Invalid filename for socket provided\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_valid_filename",
          "args": [
            "_filename"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_is_valid_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.hpp",
          "lines": "36-38",
          "snippet": "static inline bool memcached_is_valid_filename(const memcached_string_t &arg) {\n  return arg.c_str != NULL and arg.size > 0 and arg.size < MEMCACHED_NI_MAXHOST;\n}",
          "includes": [
            "#include <cassert>",
            "#include \"p9y/gettimeofday.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"p9y/gettimeofday.hpp\"\n\nstatic inline bool memcached_is_valid_filename(const memcached_string_t &arg) {\n  return arg.c_str != NULL and arg.size > 0 and arg.size < MEMCACHED_NI_MAXHOST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_string_make_from_cstr",
          "args": [
            "filename"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t memcached_server_add_unix_socket_with_weight(memcached_st *shell,\n                                                                const char *filename,\n                                                                uint32_t weight) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    memcached_string_t _filename = {memcached_string_make_from_cstr(filename)};\n    if (memcached_is_valid_filename(_filename) == false) {\n      return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                                 memcached_literal_param(\"Invalid filename for socket provided\"));\n    }\n\n    return server_add(ptr, _filename, 0, weight, MEMCACHED_CONNECTION_UNIX_SOCKET);\n  }\n\n  return MEMCACHED_FAILURE;\n}"
  },
  {
    "function_name": "memcached_server_add_unix_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
    "lines": "422-424",
    "snippet": "memcached_return_t memcached_server_add_unix_socket(memcached_st *ptr, const char *filename) {\n  return memcached_server_add_unix_socket_with_weight(ptr, filename, 0);\n}",
    "includes": [
      "#include <cmath>",
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_return_t update_continuum(Memcached *ptr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_server_add_unix_socket_with_weight",
          "args": [
            "ptr",
            "filename",
            "0"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_add_unix_socket_with_weight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "426-441",
          "snippet": "memcached_return_t memcached_server_add_unix_socket_with_weight(memcached_st *shell,\n                                                                const char *filename,\n                                                                uint32_t weight) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    memcached_string_t _filename = {memcached_string_make_from_cstr(filename)};\n    if (memcached_is_valid_filename(_filename) == false) {\n      return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                                 memcached_literal_param(\"Invalid filename for socket provided\"));\n    }\n\n    return server_add(ptr, _filename, 0, weight, MEMCACHED_CONNECTION_UNIX_SOCKET);\n  }\n\n  return MEMCACHED_FAILURE;\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t update_continuum(Memcached *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t memcached_server_add_unix_socket_with_weight(memcached_st *shell,\n                                                                const char *filename,\n                                                                uint32_t weight) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    memcached_string_t _filename = {memcached_string_make_from_cstr(filename)};\n    if (memcached_is_valid_filename(_filename) == false) {\n      return memcached_set_error(*ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                                 memcached_literal_param(\"Invalid filename for socket provided\"));\n    }\n\n    return server_add(ptr, _filename, 0, weight, MEMCACHED_CONNECTION_UNIX_SOCKET);\n  }\n\n  return MEMCACHED_FAILURE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t memcached_server_add_unix_socket(memcached_st *ptr, const char *filename) {\n  return memcached_server_add_unix_socket_with_weight(ptr, filename, 0);\n}"
  },
  {
    "function_name": "memcached_instance_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
    "lines": "375-420",
    "snippet": "memcached_return_t memcached_instance_push(memcached_st *ptr,\n                                           const struct memcached_instance_st *list,\n                                           uint32_t number_of_hosts) {\n  if (list == NULL) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  uint32_t original_host_size = memcached_server_count(ptr);\n  uint32_t host_list_size = number_of_hosts + original_host_size;\n  memcached_instance_st *new_host_list = libmemcached_xrealloc(\n      ptr, memcached_instance_list(ptr), host_list_size, memcached_instance_st);\n\n  if (new_host_list == NULL) {\n    return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n  }\n\n  memcached_instance_set(ptr, new_host_list, host_list_size);\n\n  // We don't bother with lookups for this operation\n  ptr->state.is_parsing = true;\n\n  // We use original_host_size since size will now point to the first new\n  // instance allocated.\n  for (uint32_t x = 0; x < number_of_hosts; ++x, ++original_host_size) {\n    WATCHPOINT_ASSERT(list[x]._hostname[0]);\n\n    // We have extended the array, and now we will find it, and use it.\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, original_host_size);\n    WATCHPOINT_ASSERT(instance);\n\n    memcached_string_t hostname = {memcached_string_make_from_cstr(list[x]._hostname)};\n    if (instance_create_with(ptr, instance, hostname, list[x].port(), list[x].weight, list[x].type)\n        == NULL)\n    {\n      ptr->state.is_parsing = false;\n      return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n    }\n\n    if (list[x].weight > 1) {\n      memcached_set_weighted_ketama(ptr, true);\n    }\n  }\n  ptr->state.is_parsing = false;\n\n  return run_distribution(ptr);\n}",
    "includes": [
      "#include <cmath>",
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_return_t update_continuum(Memcached *ptr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "run_distribution",
          "args": [
            "ptr"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "run_distribution",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "46-72",
          "snippet": "memcached_return_t run_distribution(Memcached *ptr) {\n  if (ptr->flags.use_sort_hosts) {\n    sort_hosts(ptr);\n  }\n\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return update_continuum(ptr);\n\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    break;\n\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    srandom((uint32_t) time(NULL));\n    break;\n\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n  default:\n    assert_msg(0, \"Invalid distribution type passed to run_distribution()\");\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t update_continuum(Memcached *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t run_distribution(Memcached *ptr) {\n  if (ptr->flags.use_sort_hosts) {\n    sort_hosts(ptr);\n  }\n\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return update_continuum(ptr);\n\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    break;\n\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    srandom((uint32_t) time(NULL));\n    break;\n\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n  default:\n    assert_msg(0, \"Invalid distribution type passed to run_distribution()\");\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_weighted_ketama",
          "args": [
            "ptr",
            "true"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "MEMCACHED_MEMORY_ALLOCATION_FAILURE",
            "MEMCACHED_AT"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "instance_create_with",
          "args": [
            "ptr",
            "instance",
            "hostname",
            "list[x].port()",
            "list[x].weight",
            "list[x].type"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list[x].port",
          "args": [],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "port",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.hpp",
          "lines": "40-40",
          "snippet": "in_port_t port() const { return port_; }",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#    include <netdb.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#    include <netdb.h>\n\nmemcached_instance_st {\n  in_port_t port() const { return port_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_string_make_from_cstr",
          "args": [
            "list[x]._hostname"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "instance"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "ptr",
            "original_host_size"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "list[x]._hostname[0]"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_set",
          "args": [
            "ptr",
            "new_host_list",
            "host_list_size"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "91-96",
          "snippet": "void memcached_instance_set(memcached_st *memc, memcached_instance_st *list,\n                            const uint32_t host_list_size) {\n  assert(memc);\n  memc->servers = list;\n  memc->number_of_hosts = host_list_size;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_instance_set(memcached_st *memc, memcached_instance_st *list,\n                            const uint32_t host_list_size) {\n  assert(memc);\n  memc->servers = list;\n  memc->number_of_hosts = host_list_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libmemcached_xrealloc",
          "args": [
            "ptr",
            "memcached_instance_list(ptr)",
            "host_list_size",
            "memcached_instance_st"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_list",
          "args": [
            "ptr"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_list_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "87-89",
          "snippet": "uint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "ptr"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t memcached_instance_push(memcached_st *ptr,\n                                           const struct memcached_instance_st *list,\n                                           uint32_t number_of_hosts) {\n  if (list == NULL) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  uint32_t original_host_size = memcached_server_count(ptr);\n  uint32_t host_list_size = number_of_hosts + original_host_size;\n  memcached_instance_st *new_host_list = libmemcached_xrealloc(\n      ptr, memcached_instance_list(ptr), host_list_size, memcached_instance_st);\n\n  if (new_host_list == NULL) {\n    return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n  }\n\n  memcached_instance_set(ptr, new_host_list, host_list_size);\n\n  // We don't bother with lookups for this operation\n  ptr->state.is_parsing = true;\n\n  // We use original_host_size since size will now point to the first new\n  // instance allocated.\n  for (uint32_t x = 0; x < number_of_hosts; ++x, ++original_host_size) {\n    WATCHPOINT_ASSERT(list[x]._hostname[0]);\n\n    // We have extended the array, and now we will find it, and use it.\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, original_host_size);\n    WATCHPOINT_ASSERT(instance);\n\n    memcached_string_t hostname = {memcached_string_make_from_cstr(list[x]._hostname)};\n    if (instance_create_with(ptr, instance, hostname, list[x].port(), list[x].weight, list[x].type)\n        == NULL)\n    {\n      ptr->state.is_parsing = false;\n      return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n    }\n\n    if (list[x].weight > 1) {\n      memcached_set_weighted_ketama(ptr, true);\n    }\n  }\n  ptr->state.is_parsing = false;\n\n  return run_distribution(ptr);\n}"
  },
  {
    "function_name": "memcached_server_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
    "lines": "327-373",
    "snippet": "memcached_return_t memcached_server_push(memcached_st *shell, const memcached_server_list_st list) {\n  if (list == NULL) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    uint32_t original_host_size = memcached_server_count(ptr);\n    uint32_t count = memcached_server_list_count(list);\n    uint32_t host_list_size = count + original_host_size;\n\n    memcached_instance_st *new_host_list = libmemcached_xrealloc(\n        ptr, memcached_instance_list(ptr), host_list_size, memcached_instance_st);\n\n    if (new_host_list == NULL) {\n      return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n    }\n\n    memcached_instance_set(ptr, new_host_list, host_list_size);\n\n    ptr->state.is_parsing = true;\n    for (uint32_t x = 0; x < count; ++x, ++original_host_size) {\n      WATCHPOINT_ASSERT(list[x].hostname[0]);\n\n      // We have extended the array, and now we will find it, and use it.\n      memcached_instance_st *instance = memcached_instance_fetch(ptr, original_host_size);\n      WATCHPOINT_ASSERT(instance);\n\n      memcached_string_t hostname = {memcached_string_make_from_cstr(list[x].hostname)};\n      if (instance_create_with(ptr, instance, hostname, list[x].port, list[x].weight, list[x].type)\n          == NULL)\n      {\n        ptr->state.is_parsing = false;\n        return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n      }\n\n      if (list[x].weight > 1) {\n        memcached_set_weighted_ketama(ptr, true);\n      }\n    }\n    ptr->state.is_parsing = false;\n\n    return run_distribution(ptr);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
    "includes": [
      "#include <cmath>",
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_return_t update_continuum(Memcached *ptr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "run_distribution",
          "args": [
            "ptr"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "run_distribution",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "46-72",
          "snippet": "memcached_return_t run_distribution(Memcached *ptr) {\n  if (ptr->flags.use_sort_hosts) {\n    sort_hosts(ptr);\n  }\n\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return update_continuum(ptr);\n\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    break;\n\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    srandom((uint32_t) time(NULL));\n    break;\n\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n  default:\n    assert_msg(0, \"Invalid distribution type passed to run_distribution()\");\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t update_continuum(Memcached *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t run_distribution(Memcached *ptr) {\n  if (ptr->flags.use_sort_hosts) {\n    sort_hosts(ptr);\n  }\n\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return update_continuum(ptr);\n\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    break;\n\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    srandom((uint32_t) time(NULL));\n    break;\n\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n  default:\n    assert_msg(0, \"Invalid distribution type passed to run_distribution()\");\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_weighted_ketama",
          "args": [
            "ptr",
            "true"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "MEMCACHED_MEMORY_ALLOCATION_FAILURE",
            "MEMCACHED_AT"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "instance_create_with",
          "args": [
            "ptr",
            "instance",
            "hostname",
            "list[x].port",
            "list[x].weight",
            "list[x].type"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_string_make_from_cstr",
          "args": [
            "list[x].hostname"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "instance"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "ptr",
            "original_host_size"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "list[x].hostname[0]"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_set",
          "args": [
            "ptr",
            "new_host_list",
            "host_list_size"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "91-96",
          "snippet": "void memcached_instance_set(memcached_st *memc, memcached_instance_st *list,\n                            const uint32_t host_list_size) {\n  assert(memc);\n  memc->servers = list;\n  memc->number_of_hosts = host_list_size;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_instance_set(memcached_st *memc, memcached_instance_st *list,\n                            const uint32_t host_list_size) {\n  assert(memc);\n  memc->servers = list;\n  memc->number_of_hosts = host_list_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libmemcached_xrealloc",
          "args": [
            "ptr",
            "memcached_instance_list(ptr)",
            "host_list_size",
            "memcached_instance_st"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_list",
          "args": [
            "ptr"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_list_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "87-89",
          "snippet": "uint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_list_count",
          "args": [
            "list"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_list_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "83-85",
          "snippet": "uint32_t memcached_server_list_count(const memcached_server_list_st self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_list_count(const memcached_server_list_st self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "ptr"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t memcached_server_push(memcached_st *shell, const memcached_server_list_st list) {\n  if (list == NULL) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr) {\n    uint32_t original_host_size = memcached_server_count(ptr);\n    uint32_t count = memcached_server_list_count(list);\n    uint32_t host_list_size = count + original_host_size;\n\n    memcached_instance_st *new_host_list = libmemcached_xrealloc(\n        ptr, memcached_instance_list(ptr), host_list_size, memcached_instance_st);\n\n    if (new_host_list == NULL) {\n      return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n    }\n\n    memcached_instance_set(ptr, new_host_list, host_list_size);\n\n    ptr->state.is_parsing = true;\n    for (uint32_t x = 0; x < count; ++x, ++original_host_size) {\n      WATCHPOINT_ASSERT(list[x].hostname[0]);\n\n      // We have extended the array, and now we will find it, and use it.\n      memcached_instance_st *instance = memcached_instance_fetch(ptr, original_host_size);\n      WATCHPOINT_ASSERT(instance);\n\n      memcached_string_t hostname = {memcached_string_make_from_cstr(list[x].hostname)};\n      if (instance_create_with(ptr, instance, hostname, list[x].port, list[x].weight, list[x].type)\n          == NULL)\n      {\n        ptr->state.is_parsing = false;\n        return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n      }\n\n      if (list[x].weight > 1) {\n        memcached_set_weighted_ketama(ptr, true);\n      }\n    }\n    ptr->state.is_parsing = false;\n\n    return run_distribution(ptr);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
  },
  {
    "function_name": "server_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
    "lines": "287-325",
    "snippet": "static memcached_return_t server_add(Memcached *memc, const memcached_string_t &hostname,\n                                     in_port_t port, uint32_t weight, memcached_connection_t type) {\n  assert_msg(memc, \"Programmer mistake, somehow server_add() was passed a NULL memcached_st\");\n\n  if (memc->number_of_hosts) {\n    assert(memcached_instance_list(memc));\n  }\n\n  if (memcached_instance_list(memc)) {\n    assert(memc->number_of_hosts);\n  }\n\n  uint32_t host_list_size = memc->number_of_hosts + 1;\n  memcached_instance_st *new_host_list = libmemcached_xrealloc(\n      memc, memcached_instance_list(memc), host_list_size, memcached_instance_st);\n\n  if (new_host_list == NULL) {\n    return memcached_set_error(*memc, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n  }\n\n  memcached_instance_set(memc, new_host_list, host_list_size);\n  assert(memc->number_of_hosts == host_list_size);\n\n  /* TODO: Check return type */\n  memcached_instance_st *instance =\n      memcached_instance_fetch(memc, memcached_server_count(memc) - 1);\n\n  if (instance_create_with(memc, instance, hostname, port, weight, type) == NULL) {\n    return memcached_set_error(*memc, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n  }\n\n  if (weight > 1) {\n    if (memcached_is_consistent_distribution(memc)) {\n      memcached_set_weighted_ketama(memc, true);\n    }\n  }\n\n  return run_distribution(memc);\n}",
    "includes": [
      "#include <cmath>",
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "run_distribution",
          "args": [
            "memc"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "run_distribution",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "46-72",
          "snippet": "memcached_return_t run_distribution(Memcached *ptr) {\n  if (ptr->flags.use_sort_hosts) {\n    sort_hosts(ptr);\n  }\n\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return update_continuum(ptr);\n\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    break;\n\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    srandom((uint32_t) time(NULL));\n    break;\n\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n  default:\n    assert_msg(0, \"Invalid distribution type passed to run_distribution()\");\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t update_continuum(Memcached *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t run_distribution(Memcached *ptr) {\n  if (ptr->flags.use_sort_hosts) {\n    sort_hosts(ptr);\n  }\n\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return update_continuum(ptr);\n\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    break;\n\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    srandom((uint32_t) time(NULL));\n    break;\n\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n  default:\n    assert_msg(0, \"Invalid distribution type passed to run_distribution()\");\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_weighted_ketama",
          "args": [
            "memc",
            "true"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_consistent_distribution",
          "args": [
            "memc"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_is_consistent_distribution",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "24-40",
          "snippet": "bool memcached_is_consistent_distribution(const Memcached *memc) {\n  switch (memc->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return true;\n\n  case MEMCACHED_DISTRIBUTION_MODULA:\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n    break;\n  }\n\n  return false;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nbool memcached_is_consistent_distribution(const Memcached *memc) {\n  switch (memc->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return true;\n\n  case MEMCACHED_DISTRIBUTION_MODULA:\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n    break;\n  }\n\n  return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*memc",
            "MEMCACHED_MEMORY_ALLOCATION_FAILURE",
            "MEMCACHED_AT"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "instance_create_with",
          "args": [
            "memc",
            "instance",
            "hostname",
            "port",
            "weight",
            "type"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "memc",
            "memcached_server_count(memc) - 1"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "memc"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "memc->number_of_hosts == host_list_size"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_set",
          "args": [
            "memc",
            "new_host_list",
            "host_list_size"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "91-96",
          "snippet": "void memcached_instance_set(memcached_st *memc, memcached_instance_st *list,\n                            const uint32_t host_list_size) {\n  assert(memc);\n  memc->servers = list;\n  memc->number_of_hosts = host_list_size;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_instance_set(memcached_st *memc, memcached_instance_st *list,\n                            const uint32_t host_list_size) {\n  assert(memc);\n  memc->servers = list;\n  memc->number_of_hosts = host_list_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libmemcached_xrealloc",
          "args": [
            "memc",
            "memcached_instance_list(memc)",
            "host_list_size",
            "memcached_instance_st"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_list",
          "args": [
            "memc"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_list_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "87-89",
          "snippet": "uint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "memc->number_of_hosts"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "memcached_instance_list(memc)"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "memc",
            "\"Programmer mistake, somehow server_add() was passed a NULL memcached_st\""
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t server_add(Memcached *memc, const memcached_string_t &hostname,\n                                     in_port_t port, uint32_t weight, memcached_connection_t type) {\n  assert_msg(memc, \"Programmer mistake, somehow server_add() was passed a NULL memcached_st\");\n\n  if (memc->number_of_hosts) {\n    assert(memcached_instance_list(memc));\n  }\n\n  if (memcached_instance_list(memc)) {\n    assert(memc->number_of_hosts);\n  }\n\n  uint32_t host_list_size = memc->number_of_hosts + 1;\n  memcached_instance_st *new_host_list = libmemcached_xrealloc(\n      memc, memcached_instance_list(memc), host_list_size, memcached_instance_st);\n\n  if (new_host_list == NULL) {\n    return memcached_set_error(*memc, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n  }\n\n  memcached_instance_set(memc, new_host_list, host_list_size);\n  assert(memc->number_of_hosts == host_list_size);\n\n  /* TODO: Check return type */\n  memcached_instance_st *instance =\n      memcached_instance_fetch(memc, memcached_server_count(memc) - 1);\n\n  if (instance_create_with(memc, instance, hostname, port, weight, type) == NULL) {\n    return memcached_set_error(*memc, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n  }\n\n  if (weight > 1) {\n    if (memcached_is_consistent_distribution(memc)) {\n      memcached_set_weighted_ketama(memc, true);\n    }\n  }\n\n  return run_distribution(memc);\n}"
  },
  {
    "function_name": "update_continuum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
    "lines": "105-285",
    "snippet": "static memcached_return_t update_continuum(Memcached *ptr) {\n  uint32_t continuum_index = 0;\n  uint32_t pointer_counter = 0;\n  uint32_t pointer_per_server = MEMCACHED_POINTS_PER_SERVER;\n  uint32_t pointer_per_hash = 1;\n  uint32_t live_servers = 0;\n  struct timeval now;\n\n  if (gettimeofday(&now, NULL)) {\n    return memcached_set_errno(*ptr, errno, MEMCACHED_AT);\n  }\n\n  memcached_instance_st *list = memcached_instance_list(ptr);\n\n  /* count live servers (those without a retry delay set) */\n  bool is_auto_ejecting = _is_auto_eject_host(ptr);\n  if (is_auto_ejecting) {\n    live_servers = 0;\n    ptr->ketama.next_distribution_rebuild = 0;\n    for (uint32_t host_index = 0; host_index < memcached_server_count(ptr); ++host_index) {\n      if (list[host_index].next_retry <= now.tv_sec) {\n        live_servers++;\n      } else {\n        if (ptr->ketama.next_distribution_rebuild == 0\n            or list[host_index].next_retry < ptr->ketama.next_distribution_rebuild)\n        {\n          ptr->ketama.next_distribution_rebuild = list[host_index].next_retry;\n        }\n      }\n    }\n  } else {\n    live_servers = memcached_server_count(ptr);\n  }\n\n  if (live_servers == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  uint32_t points_per_server =\n      (uint32_t)(memcached_is_weighted_ketama(ptr) ? MEMCACHED_POINTS_PER_SERVER_KETAMA\n                                                   : MEMCACHED_POINTS_PER_SERVER);\n  uint32_t continuum_limit = live_servers * points_per_server;\n  uint32_t continuum_extra = MEMCACHED_CONTINUUM_ADDITION * points_per_server;\n\n  if (continuum_limit > ptr->ketama.continuum_count) {\n    memcached_continuum_item_st *new_ptr;\n\n    new_ptr = libmemcached_xrealloc(ptr, ptr->ketama.continuum, continuum_limit + continuum_extra,\n                                    memcached_continuum_item_st);\n\n    if (new_ptr == 0) {\n      return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n    }\n\n    ptr->ketama.continuum = new_ptr;\n    ptr->ketama.continuum_count = continuum_limit + continuum_extra;\n  }\n  assert_msg(ptr->ketama.continuum, \"Programmer Error, empty ketama continuum\");\n\n  uint64_t total_weight = 0;\n  if (memcached_is_weighted_ketama(ptr)) {\n    for (uint32_t host_index = 0; host_index < memcached_server_count(ptr); ++host_index) {\n      if (is_auto_ejecting == false or list[host_index].next_retry <= now.tv_sec) {\n        total_weight += list[host_index].weight;\n      }\n    }\n  }\n\n  for (uint32_t host_index = 0; host_index < memcached_server_count(ptr); ++host_index) {\n    if (is_auto_ejecting and list[host_index].next_retry > now.tv_sec) {\n      continue;\n    }\n\n    if (memcached_is_weighted_ketama(ptr)) {\n      float pct = (float) list[host_index].weight / (float) total_weight;\n      pointer_per_server = (uint32_t)(\n          (::floor((float) (pct * MEMCACHED_POINTS_PER_SERVER_KETAMA / 4 * (float) live_servers\n                            + 0.0000000001F)))\n          * 4);\n      pointer_per_hash = 4;\n      if (0 && DEBUG) {\n        printf(\"ketama_weighted:%s|%d|%llu|%u\\n\", list[host_index]._hostname,\n               list[host_index].port(), (unsigned long long) list[host_index].weight,\n               pointer_per_server);\n      }\n    }\n\n    if (ptr->distribution == MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY) {\n      for (uint32_t pointer_index = 0; pointer_index < pointer_per_server / pointer_per_hash;\n           pointer_index++)\n      {\n        char sort_host[1 + MEMCACHED_NI_MAXHOST + 1 + MEMCACHED_NI_MAXSERV + 1\n                       + MEMCACHED_NI_MAXSERV] = \"\";\n        int sort_host_length;\n\n        // Spymemcached ketema key format is: hostname/ip:port-index\n        // If hostname is not available then: /ip:port-index\n        sort_host_length =\n            snprintf(sort_host, sizeof(sort_host), \"/%s:%u-%u\", list[host_index]._hostname,\n                     (uint32_t) list[host_index].port(), pointer_index);\n\n        if (size_t(sort_host_length) >= sizeof(sort_host) or sort_host_length < 0) {\n          return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                                     memcached_literal_param(\"snprintf(sizeof(sort_host))\"));\n        }\n\n        if (0 && DEBUG) {\n          fprintf(stdout, \"update_continuum: key is %s\\n\", sort_host);\n        }\n\n        if (memcached_is_weighted_ketama(ptr)) {\n          for (uint32_t x = 0; x < pointer_per_hash; x++) {\n            uint32_t value = ketama_server_hash(sort_host, (size_t) sort_host_length, x);\n            ptr->ketama.continuum[continuum_index].index = host_index;\n            ptr->ketama.continuum[continuum_index++].value = value;\n          }\n        } else {\n          uint32_t value = hashkit_digest(&ptr->hashkit, sort_host, (size_t) sort_host_length);\n          ptr->ketama.continuum[continuum_index].index = host_index;\n          ptr->ketama.continuum[continuum_index++].value = value;\n        }\n      }\n    } else {\n      for (uint32_t pointer_index = 1; pointer_index <= pointer_per_server / pointer_per_hash;\n           pointer_index++)\n      {\n        char sort_host[MEMCACHED_NI_MAXHOST + 1 + MEMCACHED_NI_MAXSERV + 1 + MEMCACHED_NI_MAXSERV] =\n            \"\";\n        int sort_host_length;\n\n        if (list[host_index].port() == MEMCACHED_DEFAULT_PORT) {\n          sort_host_length = snprintf(sort_host, sizeof(sort_host), \"%s-%u\",\n                                      list[host_index]._hostname, pointer_index - 1);\n        } else {\n          sort_host_length =\n              snprintf(sort_host, sizeof(sort_host), \"%s:%u-%u\", list[host_index]._hostname,\n                       (uint32_t) list[host_index].port(), pointer_index - 1);\n        }\n\n        if (size_t(sort_host_length) >= sizeof(sort_host) or sort_host_length < 0) {\n          return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                                     memcached_literal_param(\"snprintf(sizeof(sort_host)))\"));\n        }\n\n        if (memcached_is_weighted_ketama(ptr)) {\n          for (uint32_t x = 0; x < pointer_per_hash; x++) {\n            uint32_t value = ketama_server_hash(sort_host, (size_t) sort_host_length, x);\n            ptr->ketama.continuum[continuum_index].index = host_index;\n            ptr->ketama.continuum[continuum_index++].value = value;\n          }\n        } else {\n          uint32_t value = hashkit_digest(&ptr->hashkit, sort_host, (size_t) sort_host_length);\n          ptr->ketama.continuum[continuum_index].index = host_index;\n          ptr->ketama.continuum[continuum_index++].value = value;\n        }\n      }\n    }\n\n    pointer_counter += pointer_per_server;\n  }\n\n  assert_msg(ptr, \"Programmer Error, no valid ptr\");\n  assert_msg(ptr->ketama.continuum, \"Programmer Error, empty ketama continuum\");\n  assert_msg(memcached_server_count(ptr) * MEMCACHED_POINTS_PER_SERVER <= MEMCACHED_CONTINUUM_SIZE,\n             \"invalid size information being given to qsort()\");\n  ptr->ketama.continuum_points_counter = pointer_counter;\n  qsort(ptr->ketama.continuum, ptr->ketama.continuum_points_counter,\n        sizeof(memcached_continuum_item_st), continuum_item_cmp);\n\n  if (DEBUG) {\n    for (uint32_t pointer_index = 0; memcached_server_count(ptr)\n         && pointer_index < ((live_servers * MEMCACHED_POINTS_PER_SERVER) - 1);\n         pointer_index++)\n    {\n      WATCHPOINT_ASSERT(ptr->ketama.continuum[pointer_index].value\n                        <= ptr->ketama.continuum[pointer_index + 1].value);\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include <cmath>",
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_return_t update_continuum(Memcached *ptr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "ptr->ketama.continuum[pointer_index].value\n                        <= ptr->ketama.continuum[pointer_index + 1].value"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "ptr"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "ptr->ketama.continuum",
            "ptr->ketama.continuum_points_counter",
            "sizeof(memcached_continuum_item_st)",
            "continuum_item_cmp"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "memcached_server_count(ptr) * MEMCACHED_POINTS_PER_SERVER <= MEMCACHED_CONTINUUM_SIZE",
            "\"invalid size information being given to qsort()\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "ptr->ketama.continuum",
            "\"Programmer Error, empty ketama continuum\""
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "ptr",
            "\"Programmer Error, no valid ptr\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashkit_digest",
          "args": [
            "&ptr->hashkit",
            "sort_host",
            "(size_t) sort_host_length"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "libhashkit_digest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/digest.cc",
          "lines": "22-69",
          "snippet": "uint32_t libhashkit_digest(const char *key, size_t key_length,\n                           hashkit_hash_algorithm_t hash_algorithm) {\n  switch (hash_algorithm) {\n  case HASHKIT_HASH_DEFAULT:\n    return libhashkit_one_at_a_time(key, key_length);\n  case HASHKIT_HASH_MD5:\n    return libhashkit_md5(key, key_length);\n  case HASHKIT_HASH_CRC:\n    return libhashkit_crc32(key, key_length);\n  case HASHKIT_HASH_FNV1_64:\n    return libhashkit_fnv1_64(key, key_length);\n  case HASHKIT_HASH_FNV1A_64:\n    return libhashkit_fnv1a_64(key, key_length);\n  case HASHKIT_HASH_FNV1_32:\n    return libhashkit_fnv1_32(key, key_length);\n  case HASHKIT_HASH_FNV1A_32:\n    return libhashkit_fnv1a_32(key, key_length);\n  case HASHKIT_HASH_HSIEH:\n#ifdef HAVE_HSIEH_HASH\n    return libhashkit_hsieh(key, key_length);\n#else\n    return 1;\n#endif\n  case HASHKIT_HASH_MURMUR3:\n    return libhashkit_murmur3(key, key_length);\n\n  case HASHKIT_HASH_MURMUR:\n#ifdef HAVE_MURMUR_HASH\n    return libhashkit_murmur(key, key_length);\n#else\n    return 1;\n#endif\n  case HASHKIT_HASH_JENKINS:\n    return libhashkit_jenkins(key, key_length);\n  case HASHKIT_HASH_CUSTOM:\n  case HASHKIT_HASH_MAX:\n  default:\n    if (DEBUG) {\n      fprintf(stderr,\n              \"hashkit_hash_t was extended but libhashkit_generate_value was not updated\\n\");\n      fflush(stderr);\n      assert(0);\n    }\n    break;\n  }\n\n  return 1;\n}",
          "includes": [
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libhashkit/common.h\"\n\nuint32_t libhashkit_digest(const char *key, size_t key_length,\n                           hashkit_hash_algorithm_t hash_algorithm) {\n  switch (hash_algorithm) {\n  case HASHKIT_HASH_DEFAULT:\n    return libhashkit_one_at_a_time(key, key_length);\n  case HASHKIT_HASH_MD5:\n    return libhashkit_md5(key, key_length);\n  case HASHKIT_HASH_CRC:\n    return libhashkit_crc32(key, key_length);\n  case HASHKIT_HASH_FNV1_64:\n    return libhashkit_fnv1_64(key, key_length);\n  case HASHKIT_HASH_FNV1A_64:\n    return libhashkit_fnv1a_64(key, key_length);\n  case HASHKIT_HASH_FNV1_32:\n    return libhashkit_fnv1_32(key, key_length);\n  case HASHKIT_HASH_FNV1A_32:\n    return libhashkit_fnv1a_32(key, key_length);\n  case HASHKIT_HASH_HSIEH:\n#ifdef HAVE_HSIEH_HASH\n    return libhashkit_hsieh(key, key_length);\n#else\n    return 1;\n#endif\n  case HASHKIT_HASH_MURMUR3:\n    return libhashkit_murmur3(key, key_length);\n\n  case HASHKIT_HASH_MURMUR:\n#ifdef HAVE_MURMUR_HASH\n    return libhashkit_murmur(key, key_length);\n#else\n    return 1;\n#endif\n  case HASHKIT_HASH_JENKINS:\n    return libhashkit_jenkins(key, key_length);\n  case HASHKIT_HASH_CUSTOM:\n  case HASHKIT_HASH_MAX:\n  default:\n    if (DEBUG) {\n      fprintf(stderr,\n              \"hashkit_hash_t was extended but libhashkit_generate_value was not updated\\n\");\n      fflush(stderr);\n      assert(0);\n    }\n    break;\n  }\n\n  return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ketama_server_hash",
          "args": [
            "sort_host",
            "(size_t) sort_host_length",
            "x"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "ketama_server_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "74-82",
          "snippet": "static uint32_t ketama_server_hash(const char *key, size_t key_length, uint32_t alignment) {\n  unsigned char results[16];\n\n  libhashkit_md5_signature((unsigned char *) key, key_length, results);\n\n  return ((uint32_t)(results[3 + alignment * 4] & 0xFF) << 24)\n      | ((uint32_t)(results[2 + alignment * 4] & 0xFF) << 16)\n      | ((uint32_t)(results[1 + alignment * 4] & 0xFF) << 8) | (results[0 + alignment * 4] & 0xFF);\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic uint32_t ketama_server_hash(const char *key, size_t key_length, uint32_t alignment) {\n  unsigned char results[16];\n\n  libhashkit_md5_signature((unsigned char *) key, key_length, results);\n\n  return ((uint32_t)(results[3 + alignment * 4] & 0xFF) << 24)\n      | ((uint32_t)(results[2 + alignment * 4] & 0xFF) << 16)\n      | ((uint32_t)(results[1 + alignment * 4] & 0xFF) << 8) | (results[0 + alignment * 4] & 0xFF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_weighted_ketama",
          "args": [
            "ptr"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "MEMCACHED_MEMORY_ALLOCATION_FAILURE",
            "MEMCACHED_AT",
            "memcached_literal_param(\"snprintf(sizeof(sort_host)))\")"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "234-269",
          "snippet": "memcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_error(memcached_instance_st &self, memcached_return_t rc,\n                                       const char *at, memcached_string_t &str) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  assert_msg(\n      rc != MEMCACHED_SOME_ERRORS,\n      \"Programmer error, MEMCACHED_SOME_ERRORS was about to be set on a memcached_instance_st\");\n  if (memcached_fatal(rc) == false and rc != MEMCACHED_CLIENT_ERROR) {\n    return rc;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  char *hostname_port_message_ptr = hostname_port_message;\n  int size = 0;\n  if (str.size) {\n    size = snprintf(hostname_port_message_ptr, sizeof(hostname_port_message), \"%.*s, \",\n                    memcached_string_printf(str));\n    hostname_port_message_ptr += size;\n  }\n\n  size +=\n      append_host_to_string(self, hostname_port_message_ptr, sizeof(hostname_port_message) - size);\n\n  memcached_string_t error_host = {hostname_port_message, size_t(size)};\n\n  assert_msg(self.root, \"Programmer error, root was not set on instance\");\n  if (self.root) {\n    _set(*self.root, &error_host, rc, at);\n    _set(self, (*self.root));\n    assert(self.error_messages);\n    assert(self.root->error_messages);\n    assert(self.error_messages->rc == self.root->error_messages->rc);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"snprintf(sizeof(sort_host)))\""
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "sort_host_length"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "sort_host",
            "sizeof(sort_host)",
            "\"%s:%u-%u\"",
            "list[host_index]._hostname",
            "(uint32_t) list[host_index].port()",
            "pointer_index - 1"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list[host_index].port",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "port",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.hpp",
          "lines": "40-40",
          "snippet": "in_port_t port() const { return port_; }",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#    include <netdb.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#    include <netdb.h>\n\nmemcached_instance_st {\n  in_port_t port() const { return port_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "sort_host",
            "sizeof(sort_host)",
            "\"%s-%u\"",
            "list[host_index]._hostname",
            "pointer_index - 1"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_weighted_ketama",
          "args": [
            "ptr"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"update_continuum: key is %s\\n\"",
            "sort_host"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"snprintf(sizeof(sort_host))\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "sort_host_length"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "sort_host",
            "sizeof(sort_host)",
            "\"/%s:%u-%u\"",
            "list[host_index]._hostname",
            "(uint32_t) list[host_index].port()",
            "pointer_index"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ketama_weighted:%s|%d|%llu|%u\\n\"",
            "list[host_index]._hostname",
            "list[host_index].port()",
            "(unsigned long long) list[host_index].weight",
            "pointer_per_server"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::floor",
          "args": [
            "(float) (pct * MEMCACHED_POINTS_PER_SERVER_KETAMA / 4 * (float) live_servers\n                            + 0.0000000001F)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_weighted_ketama",
          "args": [
            "ptr"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_weighted_ketama",
          "args": [
            "ptr"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "ptr->ketama.continuum",
            "\"Programmer Error, empty ketama continuum\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libmemcached_xrealloc",
          "args": [
            "ptr",
            "ptr->ketama.continuum",
            "continuum_limit + continuum_extra",
            "memcached_continuum_item_st"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_weighted_ketama",
          "args": [
            "ptr"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_is_auto_eject_host",
          "args": [
            "ptr"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "_is_auto_eject_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "284-286",
          "snippet": "bool _is_auto_eject_host(const memcached_st *ptr) {\n  return ptr->flags.auto_eject_hosts;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nbool _is_auto_eject_host(const memcached_st *ptr) {\n  return ptr->flags.auto_eject_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_list",
          "args": [
            "ptr"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_list_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "87-89",
          "snippet": "uint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_errno",
          "args": [
            "*ptr",
            "errno",
            "MEMCACHED_AT"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "378-398",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gettimeofday",
          "args": [
            "&now",
            "NULL"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "gettimeofday",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/win32/wrappers.h",
          "lines": "87-103",
          "snippet": "static inline int gettimeofday(struct timeval* tp, struct timezone* tzp) {\n  using clock = std::chrono::system_clock;\n  auto as_sec = [] (auto d) {\n      return std::chrono::duration_cast<std::chrono::seconds>(d);\n  };\n  auto as_usec = [] (auto d) {\n      return std::chrono::duration_cast<std::chrono::microseconds>(d);\n  };\n\n  auto now = clock::now().time_since_epoch();\n  auto sec = as_sec(now);\n  auto usec = as_usec(now - sec);\n\n  tp->tv_sec = sec.count();\n  tp->tv_usec = usec.count();\n  return 0;\n}",
          "includes": [
            "#  include <chrono>",
            "#include <inttypes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <chrono>\n#include <inttypes.h>\n\nstatic inline int gettimeofday(struct timeval* tp, struct timezone* tzp) {\n  using clock = std::chrono::system_clock;\n  auto as_sec = [] (auto d) {\n      return std::chrono::duration_cast<std::chrono::seconds>(d);\n  };\n  auto as_usec = [] (auto d) {\n      return std::chrono::duration_cast<std::chrono::microseconds>(d);\n  };\n\n  auto now = clock::now().time_since_epoch();\n  auto sec = as_sec(now);\n  auto usec = as_usec(now - sec);\n\n  tp->tv_sec = sec.count();\n  tp->tv_usec = usec.count();\n  return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nstatic memcached_return_t update_continuum(Memcached *ptr) {\n  uint32_t continuum_index = 0;\n  uint32_t pointer_counter = 0;\n  uint32_t pointer_per_server = MEMCACHED_POINTS_PER_SERVER;\n  uint32_t pointer_per_hash = 1;\n  uint32_t live_servers = 0;\n  struct timeval now;\n\n  if (gettimeofday(&now, NULL)) {\n    return memcached_set_errno(*ptr, errno, MEMCACHED_AT);\n  }\n\n  memcached_instance_st *list = memcached_instance_list(ptr);\n\n  /* count live servers (those without a retry delay set) */\n  bool is_auto_ejecting = _is_auto_eject_host(ptr);\n  if (is_auto_ejecting) {\n    live_servers = 0;\n    ptr->ketama.next_distribution_rebuild = 0;\n    for (uint32_t host_index = 0; host_index < memcached_server_count(ptr); ++host_index) {\n      if (list[host_index].next_retry <= now.tv_sec) {\n        live_servers++;\n      } else {\n        if (ptr->ketama.next_distribution_rebuild == 0\n            or list[host_index].next_retry < ptr->ketama.next_distribution_rebuild)\n        {\n          ptr->ketama.next_distribution_rebuild = list[host_index].next_retry;\n        }\n      }\n    }\n  } else {\n    live_servers = memcached_server_count(ptr);\n  }\n\n  if (live_servers == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  uint32_t points_per_server =\n      (uint32_t)(memcached_is_weighted_ketama(ptr) ? MEMCACHED_POINTS_PER_SERVER_KETAMA\n                                                   : MEMCACHED_POINTS_PER_SERVER);\n  uint32_t continuum_limit = live_servers * points_per_server;\n  uint32_t continuum_extra = MEMCACHED_CONTINUUM_ADDITION * points_per_server;\n\n  if (continuum_limit > ptr->ketama.continuum_count) {\n    memcached_continuum_item_st *new_ptr;\n\n    new_ptr = libmemcached_xrealloc(ptr, ptr->ketama.continuum, continuum_limit + continuum_extra,\n                                    memcached_continuum_item_st);\n\n    if (new_ptr == 0) {\n      return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n    }\n\n    ptr->ketama.continuum = new_ptr;\n    ptr->ketama.continuum_count = continuum_limit + continuum_extra;\n  }\n  assert_msg(ptr->ketama.continuum, \"Programmer Error, empty ketama continuum\");\n\n  uint64_t total_weight = 0;\n  if (memcached_is_weighted_ketama(ptr)) {\n    for (uint32_t host_index = 0; host_index < memcached_server_count(ptr); ++host_index) {\n      if (is_auto_ejecting == false or list[host_index].next_retry <= now.tv_sec) {\n        total_weight += list[host_index].weight;\n      }\n    }\n  }\n\n  for (uint32_t host_index = 0; host_index < memcached_server_count(ptr); ++host_index) {\n    if (is_auto_ejecting and list[host_index].next_retry > now.tv_sec) {\n      continue;\n    }\n\n    if (memcached_is_weighted_ketama(ptr)) {\n      float pct = (float) list[host_index].weight / (float) total_weight;\n      pointer_per_server = (uint32_t)(\n          (::floor((float) (pct * MEMCACHED_POINTS_PER_SERVER_KETAMA / 4 * (float) live_servers\n                            + 0.0000000001F)))\n          * 4);\n      pointer_per_hash = 4;\n      if (0 && DEBUG) {\n        printf(\"ketama_weighted:%s|%d|%llu|%u\\n\", list[host_index]._hostname,\n               list[host_index].port(), (unsigned long long) list[host_index].weight,\n               pointer_per_server);\n      }\n    }\n\n    if (ptr->distribution == MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY) {\n      for (uint32_t pointer_index = 0; pointer_index < pointer_per_server / pointer_per_hash;\n           pointer_index++)\n      {\n        char sort_host[1 + MEMCACHED_NI_MAXHOST + 1 + MEMCACHED_NI_MAXSERV + 1\n                       + MEMCACHED_NI_MAXSERV] = \"\";\n        int sort_host_length;\n\n        // Spymemcached ketema key format is: hostname/ip:port-index\n        // If hostname is not available then: /ip:port-index\n        sort_host_length =\n            snprintf(sort_host, sizeof(sort_host), \"/%s:%u-%u\", list[host_index]._hostname,\n                     (uint32_t) list[host_index].port(), pointer_index);\n\n        if (size_t(sort_host_length) >= sizeof(sort_host) or sort_host_length < 0) {\n          return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                                     memcached_literal_param(\"snprintf(sizeof(sort_host))\"));\n        }\n\n        if (0 && DEBUG) {\n          fprintf(stdout, \"update_continuum: key is %s\\n\", sort_host);\n        }\n\n        if (memcached_is_weighted_ketama(ptr)) {\n          for (uint32_t x = 0; x < pointer_per_hash; x++) {\n            uint32_t value = ketama_server_hash(sort_host, (size_t) sort_host_length, x);\n            ptr->ketama.continuum[continuum_index].index = host_index;\n            ptr->ketama.continuum[continuum_index++].value = value;\n          }\n        } else {\n          uint32_t value = hashkit_digest(&ptr->hashkit, sort_host, (size_t) sort_host_length);\n          ptr->ketama.continuum[continuum_index].index = host_index;\n          ptr->ketama.continuum[continuum_index++].value = value;\n        }\n      }\n    } else {\n      for (uint32_t pointer_index = 1; pointer_index <= pointer_per_server / pointer_per_hash;\n           pointer_index++)\n      {\n        char sort_host[MEMCACHED_NI_MAXHOST + 1 + MEMCACHED_NI_MAXSERV + 1 + MEMCACHED_NI_MAXSERV] =\n            \"\";\n        int sort_host_length;\n\n        if (list[host_index].port() == MEMCACHED_DEFAULT_PORT) {\n          sort_host_length = snprintf(sort_host, sizeof(sort_host), \"%s-%u\",\n                                      list[host_index]._hostname, pointer_index - 1);\n        } else {\n          sort_host_length =\n              snprintf(sort_host, sizeof(sort_host), \"%s:%u-%u\", list[host_index]._hostname,\n                       (uint32_t) list[host_index].port(), pointer_index - 1);\n        }\n\n        if (size_t(sort_host_length) >= sizeof(sort_host) or sort_host_length < 0) {\n          return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                                     memcached_literal_param(\"snprintf(sizeof(sort_host)))\"));\n        }\n\n        if (memcached_is_weighted_ketama(ptr)) {\n          for (uint32_t x = 0; x < pointer_per_hash; x++) {\n            uint32_t value = ketama_server_hash(sort_host, (size_t) sort_host_length, x);\n            ptr->ketama.continuum[continuum_index].index = host_index;\n            ptr->ketama.continuum[continuum_index++].value = value;\n          }\n        } else {\n          uint32_t value = hashkit_digest(&ptr->hashkit, sort_host, (size_t) sort_host_length);\n          ptr->ketama.continuum[continuum_index].index = host_index;\n          ptr->ketama.continuum[continuum_index++].value = value;\n        }\n      }\n    }\n\n    pointer_counter += pointer_per_server;\n  }\n\n  assert_msg(ptr, \"Programmer Error, no valid ptr\");\n  assert_msg(ptr->ketama.continuum, \"Programmer Error, empty ketama continuum\");\n  assert_msg(memcached_server_count(ptr) * MEMCACHED_POINTS_PER_SERVER <= MEMCACHED_CONTINUUM_SIZE,\n             \"invalid size information being given to qsort()\");\n  ptr->ketama.continuum_points_counter = pointer_counter;\n  qsort(ptr->ketama.continuum, ptr->ketama.continuum_points_counter,\n        sizeof(memcached_continuum_item_st), continuum_item_cmp);\n\n  if (DEBUG) {\n    for (uint32_t pointer_index = 0; memcached_server_count(ptr)\n         && pointer_index < ((live_servers * MEMCACHED_POINTS_PER_SERVER) - 1);\n         pointer_index++)\n    {\n      WATCHPOINT_ASSERT(ptr->ketama.continuum[pointer_index].value\n                        <= ptr->ketama.continuum[pointer_index + 1].value);\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "continuum_item_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
    "lines": "84-103",
    "snippet": "static int continuum_item_cmp(const void *t1, const void *t2) {\n  memcached_continuum_item_st *ct1 = (memcached_continuum_item_st *) t1;\n  memcached_continuum_item_st *ct2 = (memcached_continuum_item_st *) t2;\n\n  /* Why 153? Hmmm... */\n  WATCHPOINT_ASSERT(ct1->value != 153);\n  if (ct1->value == ct2->value) {\n    if (ct1->index == ct2->index) {\n      return 0;\n    } else if (ct1->index > ct2->index) {\n      return 1;\n    } else {\n      return -1;\n    }\n  } else if (ct1->value > ct2->value) {\n    return 1;\n  } else {\n    return -1;\n  }\n}",
    "includes": [
      "#include <cmath>",
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "ct1->value != 153"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic int continuum_item_cmp(const void *t1, const void *t2) {\n  memcached_continuum_item_st *ct1 = (memcached_continuum_item_st *) t1;\n  memcached_continuum_item_st *ct2 = (memcached_continuum_item_st *) t2;\n\n  /* Why 153? Hmmm... */\n  WATCHPOINT_ASSERT(ct1->value != 153);\n  if (ct1->value == ct2->value) {\n    if (ct1->index == ct2->index) {\n      return 0;\n    } else if (ct1->index > ct2->index) {\n      return 1;\n    } else {\n      return -1;\n    }\n  } else if (ct1->value > ct2->value) {\n    return 1;\n  } else {\n    return -1;\n  }\n}"
  },
  {
    "function_name": "ketama_server_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
    "lines": "74-82",
    "snippet": "static uint32_t ketama_server_hash(const char *key, size_t key_length, uint32_t alignment) {\n  unsigned char results[16];\n\n  libhashkit_md5_signature((unsigned char *) key, key_length, results);\n\n  return ((uint32_t)(results[3 + alignment * 4] & 0xFF) << 24)\n      | ((uint32_t)(results[2 + alignment * 4] & 0xFF) << 16)\n      | ((uint32_t)(results[1 + alignment * 4] & 0xFF) << 8) | (results[0 + alignment * 4] & 0xFF);\n}",
    "includes": [
      "#include <cmath>",
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libhashkit_md5_signature",
          "args": [
            "(unsigned char *) key",
            "key_length",
            "results"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "libhashkit_md5_signature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/algorithm.cc",
          "lines": "62-64",
          "snippet": "void libhashkit_md5_signature(const unsigned char *key, size_t length, unsigned char *result) {\n  md5_signature(key, (uint32_t) length, result);\n}",
          "includes": [
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libhashkit/common.h\"\n\nvoid libhashkit_md5_signature(const unsigned char *key, size_t length, unsigned char *result) {\n  md5_signature(key, (uint32_t) length, result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic uint32_t ketama_server_hash(const char *key, size_t key_length, uint32_t alignment) {\n  unsigned char results[16];\n\n  libhashkit_md5_signature((unsigned char *) key, key_length, results);\n\n  return ((uint32_t)(results[3 + alignment * 4] & 0xFF) << 24)\n      | ((uint32_t)(results[2 + alignment * 4] & 0xFF) << 16)\n      | ((uint32_t)(results[1 + alignment * 4] & 0xFF) << 8) | (results[0 + alignment * 4] & 0xFF);\n}"
  },
  {
    "function_name": "run_distribution",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
    "lines": "46-72",
    "snippet": "memcached_return_t run_distribution(Memcached *ptr) {\n  if (ptr->flags.use_sort_hosts) {\n    sort_hosts(ptr);\n  }\n\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return update_continuum(ptr);\n\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    break;\n\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    srandom((uint32_t) time(NULL));\n    break;\n\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n  default:\n    assert_msg(0, \"Invalid distribution type passed to run_distribution()\");\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include <cmath>",
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_return_t update_continuum(Memcached *ptr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "0",
            "\"Invalid distribution type passed to run_distribution()\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srandom",
          "args": [
            "(uint32_t) time(NULL)"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_mark_server_for_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.hpp",
          "lines": "44-67",
          "snippet": "static inline void memcached_mark_server_for_timeout(memcached_instance_st *server) {\n  if (server->state != MEMCACHED_SERVER_STATE_IN_TIMEOUT) {\n    if (server->server_timeout_counter_query_id != server->root->query_id) {\n      server->server_timeout_counter++;\n      server->server_timeout_counter_query_id = server->root->query_id;\n    }\n\n    if (server->server_timeout_counter >= server->root->server_timeout_limit) {\n      struct timeval next_time;\n      if (gettimeofday(&next_time, NULL) == 0) {\n        server->next_retry = next_time.tv_sec + server->root->retry_timeout;\n      } else {\n        server->next_retry = 1; // Setting the value to 1 causes the timeout to occur immediately\n      }\n\n      server->state = MEMCACHED_SERVER_STATE_IN_TIMEOUT;\n      if (server->server_failure_counter_query_id != server->root->query_id) {\n        server->server_failure_counter++;\n        server->server_failure_counter_query_id = server->root->query_id;\n      }\n      set_last_disconnected_host(server);\n    }\n  }\n}",
          "includes": [
            "#include <cassert>",
            "#include \"p9y/gettimeofday.hpp\""
          ],
          "macros_used": [],
          "globals_used": [
            "void memcached_instance_free(memcached_instance_st *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"p9y/gettimeofday.hpp\"\n\nvoid memcached_instance_free(memcached_instance_st *);\n\nstatic inline void memcached_mark_server_for_timeout(memcached_instance_st *server) {\n  if (server->state != MEMCACHED_SERVER_STATE_IN_TIMEOUT) {\n    if (server->server_timeout_counter_query_id != server->root->query_id) {\n      server->server_timeout_counter++;\n      server->server_timeout_counter_query_id = server->root->query_id;\n    }\n\n    if (server->server_timeout_counter >= server->root->server_timeout_limit) {\n      struct timeval next_time;\n      if (gettimeofday(&next_time, NULL) == 0) {\n        server->next_retry = next_time.tv_sec + server->root->retry_timeout;\n      } else {\n        server->next_retry = 1; // Setting the value to 1 causes the timeout to occur immediately\n      }\n\n      server->state = MEMCACHED_SERVER_STATE_IN_TIMEOUT;\n      if (server->server_failure_counter_query_id != server->root->query_id) {\n        server->server_failure_counter++;\n        server->server_failure_counter_query_id = server->root->query_id;\n      }\n      set_last_disconnected_host(server);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_continuum",
          "args": [
            "ptr"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "update_continuum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "105-285",
          "snippet": "static memcached_return_t update_continuum(Memcached *ptr) {\n  uint32_t continuum_index = 0;\n  uint32_t pointer_counter = 0;\n  uint32_t pointer_per_server = MEMCACHED_POINTS_PER_SERVER;\n  uint32_t pointer_per_hash = 1;\n  uint32_t live_servers = 0;\n  struct timeval now;\n\n  if (gettimeofday(&now, NULL)) {\n    return memcached_set_errno(*ptr, errno, MEMCACHED_AT);\n  }\n\n  memcached_instance_st *list = memcached_instance_list(ptr);\n\n  /* count live servers (those without a retry delay set) */\n  bool is_auto_ejecting = _is_auto_eject_host(ptr);\n  if (is_auto_ejecting) {\n    live_servers = 0;\n    ptr->ketama.next_distribution_rebuild = 0;\n    for (uint32_t host_index = 0; host_index < memcached_server_count(ptr); ++host_index) {\n      if (list[host_index].next_retry <= now.tv_sec) {\n        live_servers++;\n      } else {\n        if (ptr->ketama.next_distribution_rebuild == 0\n            or list[host_index].next_retry < ptr->ketama.next_distribution_rebuild)\n        {\n          ptr->ketama.next_distribution_rebuild = list[host_index].next_retry;\n        }\n      }\n    }\n  } else {\n    live_servers = memcached_server_count(ptr);\n  }\n\n  if (live_servers == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  uint32_t points_per_server =\n      (uint32_t)(memcached_is_weighted_ketama(ptr) ? MEMCACHED_POINTS_PER_SERVER_KETAMA\n                                                   : MEMCACHED_POINTS_PER_SERVER);\n  uint32_t continuum_limit = live_servers * points_per_server;\n  uint32_t continuum_extra = MEMCACHED_CONTINUUM_ADDITION * points_per_server;\n\n  if (continuum_limit > ptr->ketama.continuum_count) {\n    memcached_continuum_item_st *new_ptr;\n\n    new_ptr = libmemcached_xrealloc(ptr, ptr->ketama.continuum, continuum_limit + continuum_extra,\n                                    memcached_continuum_item_st);\n\n    if (new_ptr == 0) {\n      return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n    }\n\n    ptr->ketama.continuum = new_ptr;\n    ptr->ketama.continuum_count = continuum_limit + continuum_extra;\n  }\n  assert_msg(ptr->ketama.continuum, \"Programmer Error, empty ketama continuum\");\n\n  uint64_t total_weight = 0;\n  if (memcached_is_weighted_ketama(ptr)) {\n    for (uint32_t host_index = 0; host_index < memcached_server_count(ptr); ++host_index) {\n      if (is_auto_ejecting == false or list[host_index].next_retry <= now.tv_sec) {\n        total_weight += list[host_index].weight;\n      }\n    }\n  }\n\n  for (uint32_t host_index = 0; host_index < memcached_server_count(ptr); ++host_index) {\n    if (is_auto_ejecting and list[host_index].next_retry > now.tv_sec) {\n      continue;\n    }\n\n    if (memcached_is_weighted_ketama(ptr)) {\n      float pct = (float) list[host_index].weight / (float) total_weight;\n      pointer_per_server = (uint32_t)(\n          (::floor((float) (pct * MEMCACHED_POINTS_PER_SERVER_KETAMA / 4 * (float) live_servers\n                            + 0.0000000001F)))\n          * 4);\n      pointer_per_hash = 4;\n      if (0 && DEBUG) {\n        printf(\"ketama_weighted:%s|%d|%llu|%u\\n\", list[host_index]._hostname,\n               list[host_index].port(), (unsigned long long) list[host_index].weight,\n               pointer_per_server);\n      }\n    }\n\n    if (ptr->distribution == MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY) {\n      for (uint32_t pointer_index = 0; pointer_index < pointer_per_server / pointer_per_hash;\n           pointer_index++)\n      {\n        char sort_host[1 + MEMCACHED_NI_MAXHOST + 1 + MEMCACHED_NI_MAXSERV + 1\n                       + MEMCACHED_NI_MAXSERV] = \"\";\n        int sort_host_length;\n\n        // Spymemcached ketema key format is: hostname/ip:port-index\n        // If hostname is not available then: /ip:port-index\n        sort_host_length =\n            snprintf(sort_host, sizeof(sort_host), \"/%s:%u-%u\", list[host_index]._hostname,\n                     (uint32_t) list[host_index].port(), pointer_index);\n\n        if (size_t(sort_host_length) >= sizeof(sort_host) or sort_host_length < 0) {\n          return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                                     memcached_literal_param(\"snprintf(sizeof(sort_host))\"));\n        }\n\n        if (0 && DEBUG) {\n          fprintf(stdout, \"update_continuum: key is %s\\n\", sort_host);\n        }\n\n        if (memcached_is_weighted_ketama(ptr)) {\n          for (uint32_t x = 0; x < pointer_per_hash; x++) {\n            uint32_t value = ketama_server_hash(sort_host, (size_t) sort_host_length, x);\n            ptr->ketama.continuum[continuum_index].index = host_index;\n            ptr->ketama.continuum[continuum_index++].value = value;\n          }\n        } else {\n          uint32_t value = hashkit_digest(&ptr->hashkit, sort_host, (size_t) sort_host_length);\n          ptr->ketama.continuum[continuum_index].index = host_index;\n          ptr->ketama.continuum[continuum_index++].value = value;\n        }\n      }\n    } else {\n      for (uint32_t pointer_index = 1; pointer_index <= pointer_per_server / pointer_per_hash;\n           pointer_index++)\n      {\n        char sort_host[MEMCACHED_NI_MAXHOST + 1 + MEMCACHED_NI_MAXSERV + 1 + MEMCACHED_NI_MAXSERV] =\n            \"\";\n        int sort_host_length;\n\n        if (list[host_index].port() == MEMCACHED_DEFAULT_PORT) {\n          sort_host_length = snprintf(sort_host, sizeof(sort_host), \"%s-%u\",\n                                      list[host_index]._hostname, pointer_index - 1);\n        } else {\n          sort_host_length =\n              snprintf(sort_host, sizeof(sort_host), \"%s:%u-%u\", list[host_index]._hostname,\n                       (uint32_t) list[host_index].port(), pointer_index - 1);\n        }\n\n        if (size_t(sort_host_length) >= sizeof(sort_host) or sort_host_length < 0) {\n          return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                                     memcached_literal_param(\"snprintf(sizeof(sort_host)))\"));\n        }\n\n        if (memcached_is_weighted_ketama(ptr)) {\n          for (uint32_t x = 0; x < pointer_per_hash; x++) {\n            uint32_t value = ketama_server_hash(sort_host, (size_t) sort_host_length, x);\n            ptr->ketama.continuum[continuum_index].index = host_index;\n            ptr->ketama.continuum[continuum_index++].value = value;\n          }\n        } else {\n          uint32_t value = hashkit_digest(&ptr->hashkit, sort_host, (size_t) sort_host_length);\n          ptr->ketama.continuum[continuum_index].index = host_index;\n          ptr->ketama.continuum[continuum_index++].value = value;\n        }\n      }\n    }\n\n    pointer_counter += pointer_per_server;\n  }\n\n  assert_msg(ptr, \"Programmer Error, no valid ptr\");\n  assert_msg(ptr->ketama.continuum, \"Programmer Error, empty ketama continuum\");\n  assert_msg(memcached_server_count(ptr) * MEMCACHED_POINTS_PER_SERVER <= MEMCACHED_CONTINUUM_SIZE,\n             \"invalid size information being given to qsort()\");\n  ptr->ketama.continuum_points_counter = pointer_counter;\n  qsort(ptr->ketama.continuum, ptr->ketama.continuum_points_counter,\n        sizeof(memcached_continuum_item_st), continuum_item_cmp);\n\n  if (DEBUG) {\n    for (uint32_t pointer_index = 0; memcached_server_count(ptr)\n         && pointer_index < ((live_servers * MEMCACHED_POINTS_PER_SERVER) - 1);\n         pointer_index++)\n    {\n      WATCHPOINT_ASSERT(ptr->ketama.continuum[pointer_index].value\n                        <= ptr->ketama.continuum[pointer_index + 1].value);\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t update_continuum(Memcached *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nstatic memcached_return_t update_continuum(Memcached *ptr) {\n  uint32_t continuum_index = 0;\n  uint32_t pointer_counter = 0;\n  uint32_t pointer_per_server = MEMCACHED_POINTS_PER_SERVER;\n  uint32_t pointer_per_hash = 1;\n  uint32_t live_servers = 0;\n  struct timeval now;\n\n  if (gettimeofday(&now, NULL)) {\n    return memcached_set_errno(*ptr, errno, MEMCACHED_AT);\n  }\n\n  memcached_instance_st *list = memcached_instance_list(ptr);\n\n  /* count live servers (those without a retry delay set) */\n  bool is_auto_ejecting = _is_auto_eject_host(ptr);\n  if (is_auto_ejecting) {\n    live_servers = 0;\n    ptr->ketama.next_distribution_rebuild = 0;\n    for (uint32_t host_index = 0; host_index < memcached_server_count(ptr); ++host_index) {\n      if (list[host_index].next_retry <= now.tv_sec) {\n        live_servers++;\n      } else {\n        if (ptr->ketama.next_distribution_rebuild == 0\n            or list[host_index].next_retry < ptr->ketama.next_distribution_rebuild)\n        {\n          ptr->ketama.next_distribution_rebuild = list[host_index].next_retry;\n        }\n      }\n    }\n  } else {\n    live_servers = memcached_server_count(ptr);\n  }\n\n  if (live_servers == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  uint32_t points_per_server =\n      (uint32_t)(memcached_is_weighted_ketama(ptr) ? MEMCACHED_POINTS_PER_SERVER_KETAMA\n                                                   : MEMCACHED_POINTS_PER_SERVER);\n  uint32_t continuum_limit = live_servers * points_per_server;\n  uint32_t continuum_extra = MEMCACHED_CONTINUUM_ADDITION * points_per_server;\n\n  if (continuum_limit > ptr->ketama.continuum_count) {\n    memcached_continuum_item_st *new_ptr;\n\n    new_ptr = libmemcached_xrealloc(ptr, ptr->ketama.continuum, continuum_limit + continuum_extra,\n                                    memcached_continuum_item_st);\n\n    if (new_ptr == 0) {\n      return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n    }\n\n    ptr->ketama.continuum = new_ptr;\n    ptr->ketama.continuum_count = continuum_limit + continuum_extra;\n  }\n  assert_msg(ptr->ketama.continuum, \"Programmer Error, empty ketama continuum\");\n\n  uint64_t total_weight = 0;\n  if (memcached_is_weighted_ketama(ptr)) {\n    for (uint32_t host_index = 0; host_index < memcached_server_count(ptr); ++host_index) {\n      if (is_auto_ejecting == false or list[host_index].next_retry <= now.tv_sec) {\n        total_weight += list[host_index].weight;\n      }\n    }\n  }\n\n  for (uint32_t host_index = 0; host_index < memcached_server_count(ptr); ++host_index) {\n    if (is_auto_ejecting and list[host_index].next_retry > now.tv_sec) {\n      continue;\n    }\n\n    if (memcached_is_weighted_ketama(ptr)) {\n      float pct = (float) list[host_index].weight / (float) total_weight;\n      pointer_per_server = (uint32_t)(\n          (::floor((float) (pct * MEMCACHED_POINTS_PER_SERVER_KETAMA / 4 * (float) live_servers\n                            + 0.0000000001F)))\n          * 4);\n      pointer_per_hash = 4;\n      if (0 && DEBUG) {\n        printf(\"ketama_weighted:%s|%d|%llu|%u\\n\", list[host_index]._hostname,\n               list[host_index].port(), (unsigned long long) list[host_index].weight,\n               pointer_per_server);\n      }\n    }\n\n    if (ptr->distribution == MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY) {\n      for (uint32_t pointer_index = 0; pointer_index < pointer_per_server / pointer_per_hash;\n           pointer_index++)\n      {\n        char sort_host[1 + MEMCACHED_NI_MAXHOST + 1 + MEMCACHED_NI_MAXSERV + 1\n                       + MEMCACHED_NI_MAXSERV] = \"\";\n        int sort_host_length;\n\n        // Spymemcached ketema key format is: hostname/ip:port-index\n        // If hostname is not available then: /ip:port-index\n        sort_host_length =\n            snprintf(sort_host, sizeof(sort_host), \"/%s:%u-%u\", list[host_index]._hostname,\n                     (uint32_t) list[host_index].port(), pointer_index);\n\n        if (size_t(sort_host_length) >= sizeof(sort_host) or sort_host_length < 0) {\n          return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                                     memcached_literal_param(\"snprintf(sizeof(sort_host))\"));\n        }\n\n        if (0 && DEBUG) {\n          fprintf(stdout, \"update_continuum: key is %s\\n\", sort_host);\n        }\n\n        if (memcached_is_weighted_ketama(ptr)) {\n          for (uint32_t x = 0; x < pointer_per_hash; x++) {\n            uint32_t value = ketama_server_hash(sort_host, (size_t) sort_host_length, x);\n            ptr->ketama.continuum[continuum_index].index = host_index;\n            ptr->ketama.continuum[continuum_index++].value = value;\n          }\n        } else {\n          uint32_t value = hashkit_digest(&ptr->hashkit, sort_host, (size_t) sort_host_length);\n          ptr->ketama.continuum[continuum_index].index = host_index;\n          ptr->ketama.continuum[continuum_index++].value = value;\n        }\n      }\n    } else {\n      for (uint32_t pointer_index = 1; pointer_index <= pointer_per_server / pointer_per_hash;\n           pointer_index++)\n      {\n        char sort_host[MEMCACHED_NI_MAXHOST + 1 + MEMCACHED_NI_MAXSERV + 1 + MEMCACHED_NI_MAXSERV] =\n            \"\";\n        int sort_host_length;\n\n        if (list[host_index].port() == MEMCACHED_DEFAULT_PORT) {\n          sort_host_length = snprintf(sort_host, sizeof(sort_host), \"%s-%u\",\n                                      list[host_index]._hostname, pointer_index - 1);\n        } else {\n          sort_host_length =\n              snprintf(sort_host, sizeof(sort_host), \"%s:%u-%u\", list[host_index]._hostname,\n                       (uint32_t) list[host_index].port(), pointer_index - 1);\n        }\n\n        if (size_t(sort_host_length) >= sizeof(sort_host) or sort_host_length < 0) {\n          return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT,\n                                     memcached_literal_param(\"snprintf(sizeof(sort_host)))\"));\n        }\n\n        if (memcached_is_weighted_ketama(ptr)) {\n          for (uint32_t x = 0; x < pointer_per_hash; x++) {\n            uint32_t value = ketama_server_hash(sort_host, (size_t) sort_host_length, x);\n            ptr->ketama.continuum[continuum_index].index = host_index;\n            ptr->ketama.continuum[continuum_index++].value = value;\n          }\n        } else {\n          uint32_t value = hashkit_digest(&ptr->hashkit, sort_host, (size_t) sort_host_length);\n          ptr->ketama.continuum[continuum_index].index = host_index;\n          ptr->ketama.continuum[continuum_index++].value = value;\n        }\n      }\n    }\n\n    pointer_counter += pointer_per_server;\n  }\n\n  assert_msg(ptr, \"Programmer Error, no valid ptr\");\n  assert_msg(ptr->ketama.continuum, \"Programmer Error, empty ketama continuum\");\n  assert_msg(memcached_server_count(ptr) * MEMCACHED_POINTS_PER_SERVER <= MEMCACHED_CONTINUUM_SIZE,\n             \"invalid size information being given to qsort()\");\n  ptr->ketama.continuum_points_counter = pointer_counter;\n  qsort(ptr->ketama.continuum, ptr->ketama.continuum_points_counter,\n        sizeof(memcached_continuum_item_st), continuum_item_cmp);\n\n  if (DEBUG) {\n    for (uint32_t pointer_index = 0; memcached_server_count(ptr)\n         && pointer_index < ((live_servers * MEMCACHED_POINTS_PER_SERVER) - 1);\n         pointer_index++)\n    {\n      WATCHPOINT_ASSERT(ptr->ketama.continuum[pointer_index].value\n                        <= ptr->ketama.continuum[pointer_index + 1].value);\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort_hosts",
          "args": [
            "ptr"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "sort_hosts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "39-44",
          "snippet": "static void sort_hosts(Memcached *ptr) {\n  if (memcached_server_count(ptr)) {\n    qsort(memcached_instance_list(ptr), memcached_server_count(ptr), sizeof(memcached_instance_st),\n          compare_servers);\n  }\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t update_continuum(Memcached *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nstatic void sort_hosts(Memcached *ptr) {\n  if (memcached_server_count(ptr)) {\n    qsort(memcached_instance_list(ptr), memcached_server_count(ptr), sizeof(memcached_instance_st),\n          compare_servers);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t run_distribution(Memcached *ptr) {\n  if (ptr->flags.use_sort_hosts) {\n    sort_hosts(ptr);\n  }\n\n  switch (ptr->distribution) {\n  case MEMCACHED_DISTRIBUTION_CONSISTENT:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA_SPY:\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED:\n    return update_continuum(ptr);\n\n  case MEMCACHED_DISTRIBUTION_VIRTUAL_BUCKET:\n  case MEMCACHED_DISTRIBUTION_MODULA:\n    break;\n\n  case MEMCACHED_DISTRIBUTION_RANDOM:\n    srandom((uint32_t) time(NULL));\n    break;\n\n  case MEMCACHED_DISTRIBUTION_CONSISTENT_MAX:\n  default:\n    assert_msg(0, \"Invalid distribution type passed to run_distribution()\");\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "sort_hosts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
    "lines": "39-44",
    "snippet": "static void sort_hosts(Memcached *ptr) {\n  if (memcached_server_count(ptr)) {\n    qsort(memcached_instance_list(ptr), memcached_server_count(ptr), sizeof(memcached_instance_st),\n          compare_servers);\n  }\n}",
    "includes": [
      "#include <cmath>",
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static memcached_return_t update_continuum(Memcached *ptr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "memcached_instance_list(ptr)",
            "memcached_server_count(ptr)",
            "sizeof(memcached_instance_st)",
            "compare_servers"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_count",
          "args": [
            "ptr"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "136-142",
          "snippet": "uint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_count(const memcached_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL)\n    return 0;\n\n  return self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_list",
          "args": [
            "ptr"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_list_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "87-89",
          "snippet": "uint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nstatic void sort_hosts(Memcached *ptr) {\n  if (memcached_server_count(ptr)) {\n    qsort(memcached_instance_list(ptr), memcached_server_count(ptr), sizeof(memcached_instance_st),\n          compare_servers);\n  }\n}"
  },
  {
    "function_name": "compare_servers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
    "lines": "26-37",
    "snippet": "static int compare_servers(const void *p1, const void *p2) {\n  const memcached_instance_st *a = (const memcached_instance_st *) p1;\n  const memcached_instance_st *b = (const memcached_instance_st *) p2;\n\n  int return_value = strcmp(a->_hostname, b->_hostname);\n\n  if (return_value == 0) {\n    return_value = int(a->port() - b->port());\n  }\n\n  return return_value;\n}",
    "includes": [
      "#include <cmath>",
      "#include \"p9y/random.hpp\"",
      "#include \"p9y/gettimeofday.hpp\"",
      "#include \"libmemcached/assert.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "int",
          "args": [
            "a->port() - b->port()"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "414-427",
          "snippet": "void memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_print(const Memcached *shell) {\n  const Memcached *self = memcached2Memcached(shell);\n  if (self == NULL) {\n    return;\n  }\n\n  _error_print(self->error_messages);\n\n  for (uint32_t x = 0; x < memcached_server_count(self); x++) {\n    memcached_instance_st *instance = memcached_instance_by_position(self, x);\n\n    _error_print(instance->error_messages);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "b->port",
          "args": [],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "port",
          "container": "memcached_instance_st",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.hpp",
          "lines": "40-40",
          "snippet": "in_port_t port() const { return port_; }",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#    include <netdb.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#    include <netdb.h>\n\nmemcached_instance_st {\n  in_port_t port() const { return port_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->_hostname",
            "b->_hostname"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic int compare_servers(const void *p1, const void *p2) {\n  const memcached_instance_st *a = (const memcached_instance_st *) p1;\n  const memcached_instance_st *b = (const memcached_instance_st *) p2;\n\n  int return_value = strcmp(a->_hostname, b->_hostname);\n\n  if (return_value == 0) {\n    return_value = int(a->port() - b->port());\n  }\n\n  return return_value;\n}"
  }
]