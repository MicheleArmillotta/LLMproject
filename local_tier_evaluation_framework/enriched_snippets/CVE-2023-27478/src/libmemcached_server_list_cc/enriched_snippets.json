[
  {
    "function_name": "memcached_instance_list_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
    "lines": "111-122",
    "snippet": "void memcached_instance_list_free(memcached_instance_st *self, uint32_t instance_count) {\n  if (self) {\n    for (uint32_t x = 0; x < instance_count; x++) {\n      assert_msg(memcached_is_allocated(&self[x]) == false,\n                 \"You have called memcached_server_list_free(), but you did not pass it a valid \"\n                 \"memcached_server_list_st\");\n      instance_free(&self[x]);\n    }\n\n    libmemcached_free(self->root, self);\n  }\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libmemcached_free",
          "args": [
            "self->root",
            "self"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "libmemcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memory.h",
          "lines": "30-40",
          "snippet": "static inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#  include <stddef.h>",
            "#  include <cstdlib>",
            "#  include <cstddef>",
            "#include \"libmemcached/common.h\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#  include <stddef.h>\n#  include <cstdlib>\n#  include <cstddef>\n#include \"libmemcached/common.h\"\n#include \"mem_config.h\"\n\nstatic inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "instance_free",
          "args": [
            "&self[x]"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
          "lines": "141-145",
          "snippet": "void memcached_instance_free(memcached_instance_st *self) {\n  if (self) {\n    instance_free(self);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_instance_free(memcached_instance_st *self) {\n  if (self) {\n    instance_free(self);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "memcached_is_allocated(&self[x]) == false",
            "\"You have called memcached_server_list_free(), but you did not pass it a valid \"\n                 \"memcached_server_list_st\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_allocated",
          "args": [
            "&self[x]"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_instance_list_free(memcached_instance_st *self, uint32_t instance_count) {\n  if (self) {\n    for (uint32_t x = 0; x < instance_count; x++) {\n      assert_msg(memcached_is_allocated(&self[x]) == false,\n                 \"You have called memcached_server_list_free(), but you did not pass it a valid \"\n                 \"memcached_server_list_st\");\n      instance_free(&self[x]);\n    }\n\n    libmemcached_free(self->root, self);\n  }\n}"
  },
  {
    "function_name": "memcached_server_list_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
    "lines": "98-109",
    "snippet": "void memcached_server_list_free(memcached_server_list_st self) {\n  if (self) {\n    for (uint32_t x = 0; x < memcached_server_list_count(self); x++) {\n      assert_msg(not memcached_is_allocated(&self[x]),\n                 \"You have called memcached_server_list_free(), but you did not pass it a valid \"\n                 \"memcached_server_list_st\");\n      server_free(&self[x]);\n    }\n\n    libmemcached_free(self->root, self);\n  }\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libmemcached_free",
          "args": [
            "self->root",
            "self"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "libmemcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memory.h",
          "lines": "30-40",
          "snippet": "static inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#  include <stddef.h>",
            "#  include <cstdlib>",
            "#  include <cstddef>",
            "#include \"libmemcached/common.h\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#  include <stddef.h>\n#  include <cstdlib>\n#  include <cstddef>\n#include \"libmemcached/common.h\"\n#include \"mem_config.h\"\n\nstatic inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "server_free",
          "args": [
            "&self[x]"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "105-116",
          "snippet": "void memcached_server_free(memcached_server_st *self) {\n  if (self == NULL) {\n    return;\n  }\n\n  if (memcached_server_list_count(self)) {\n    memcached_server_list_free(self);\n    return;\n  }\n\n  server_free(self);\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_server_free(memcached_server_st *self) {\n  if (self == NULL) {\n    return;\n  }\n\n  if (memcached_server_list_count(self)) {\n    memcached_server_list_free(self);\n    return;\n  }\n\n  server_free(self);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "not memcached_is_allocated(&self[x])",
            "\"You have called memcached_server_list_free(), but you did not pass it a valid \"\n                 \"memcached_server_list_st\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_is_allocated",
          "args": [
            "&self[x]"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_list_count",
          "args": [
            "self"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_list_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "83-85",
          "snippet": "uint32_t memcached_server_list_count(const memcached_server_list_st self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_list_count(const memcached_server_list_st self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_server_list_free(memcached_server_list_st self) {\n  if (self) {\n    for (uint32_t x = 0; x < memcached_server_list_count(self); x++) {\n      assert_msg(not memcached_is_allocated(&self[x]),\n                 \"You have called memcached_server_list_free(), but you did not pass it a valid \"\n                 \"memcached_server_list_st\");\n      server_free(&self[x]);\n    }\n\n    libmemcached_free(self->root, self);\n  }\n}"
  },
  {
    "function_name": "memcached_instance_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
    "lines": "91-96",
    "snippet": "void memcached_instance_set(memcached_st *memc, memcached_instance_st *list,\n                            const uint32_t host_list_size) {\n  assert(memc);\n  memc->servers = list;\n  memc->number_of_hosts = host_list_size;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "memc"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_instance_set(memcached_st *memc, memcached_instance_st *list,\n                            const uint32_t host_list_size) {\n  assert(memc);\n  memc->servers = list;\n  memc->number_of_hosts = host_list_size;\n}"
  },
  {
    "function_name": "memcached_instance_list_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
    "lines": "87-89",
    "snippet": "uint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}"
  },
  {
    "function_name": "memcached_server_list_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
    "lines": "83-85",
    "snippet": "uint32_t memcached_server_list_count(const memcached_server_list_st self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_list_count(const memcached_server_list_st self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}"
  },
  {
    "function_name": "memcached_server_list_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
    "lines": "77-81",
    "snippet": "memcached_server_list_st memcached_server_list_append(memcached_server_list_st ptr,\n                                                      const char *hostname, in_port_t port,\n                                                      memcached_return_t *error) {\n  return memcached_server_list_append_with_weight(ptr, hostname, port, 0, error);\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_server_list_append_with_weight",
          "args": [
            "ptr",
            "hostname",
            "port",
            "0",
            "error"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_list_append_with_weight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "18-75",
          "snippet": "memcached_server_list_st memcached_server_list_append_with_weight(memcached_server_list_st ptr,\n                                                                  const char *hostname,\n                                                                  in_port_t port, uint32_t weight,\n                                                                  memcached_return_t *error) {\n  memcached_return_t unused;\n  if (error == NULL) {\n    error = &unused;\n  }\n\n  if (hostname == NULL) {\n    hostname = \"localhost\";\n  }\n\n  if (hostname[0] == '/') {\n    port = 0;\n  } else if (port == 0) {\n    port = MEMCACHED_DEFAULT_PORT;\n  }\n\n  /* Increment count for hosts */\n  uint32_t count = 1;\n  if (ptr) {\n    count += memcached_server_list_count(ptr);\n  }\n\n  memcached_server_list_st new_host_list =\n      (memcached_server_st *) realloc(ptr, sizeof(memcached_server_st) * count);\n  if (new_host_list == NULL) {\n#if 0\n    *error= memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n#endif\n    return NULL;\n  }\n\n  memcached_string_t _hostname = {memcached_string_make_from_cstr(hostname)};\n  /* @todo Check return type */\n  if (server_create_with(NULL, &new_host_list[count - 1], _hostname, port, weight,\n                         port ? MEMCACHED_CONNECTION_TCP : MEMCACHED_CONNECTION_UNIX_SOCKET)\n      == NULL)\n  {\n#if 0\n    *error= memcached_set_errno(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n#endif\n    free(new_host_list);\n    return NULL;\n  }\n\n#if 0\n  // Handset allocated since\n  new_host_list->options.is_allocated= true;\n#endif\n\n  /* Backwards compatibility hack */\n  memcached_servers_set_count(new_host_list, count);\n\n  *error = MEMCACHED_SUCCESS;\n  return new_host_list;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_server_list_st memcached_server_list_append_with_weight(memcached_server_list_st ptr,\n                                                                  const char *hostname,\n                                                                  in_port_t port, uint32_t weight,\n                                                                  memcached_return_t *error) {\n  memcached_return_t unused;\n  if (error == NULL) {\n    error = &unused;\n  }\n\n  if (hostname == NULL) {\n    hostname = \"localhost\";\n  }\n\n  if (hostname[0] == '/') {\n    port = 0;\n  } else if (port == 0) {\n    port = MEMCACHED_DEFAULT_PORT;\n  }\n\n  /* Increment count for hosts */\n  uint32_t count = 1;\n  if (ptr) {\n    count += memcached_server_list_count(ptr);\n  }\n\n  memcached_server_list_st new_host_list =\n      (memcached_server_st *) realloc(ptr, sizeof(memcached_server_st) * count);\n  if (new_host_list == NULL) {\n#if 0\n    *error= memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n#endif\n    return NULL;\n  }\n\n  memcached_string_t _hostname = {memcached_string_make_from_cstr(hostname)};\n  /* @todo Check return type */\n  if (server_create_with(NULL, &new_host_list[count - 1], _hostname, port, weight,\n                         port ? MEMCACHED_CONNECTION_TCP : MEMCACHED_CONNECTION_UNIX_SOCKET)\n      == NULL)\n  {\n#if 0\n    *error= memcached_set_errno(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n#endif\n    free(new_host_list);\n    return NULL;\n  }\n\n#if 0\n  // Handset allocated since\n  new_host_list->options.is_allocated= true;\n#endif\n\n  /* Backwards compatibility hack */\n  memcached_servers_set_count(new_host_list, count);\n\n  *error = MEMCACHED_SUCCESS;\n  return new_host_list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_server_list_st memcached_server_list_append(memcached_server_list_st ptr,\n                                                      const char *hostname, in_port_t port,\n                                                      memcached_return_t *error) {\n  return memcached_server_list_append_with_weight(ptr, hostname, port, 0, error);\n}"
  },
  {
    "function_name": "memcached_server_list_append_with_weight",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
    "lines": "18-75",
    "snippet": "memcached_server_list_st memcached_server_list_append_with_weight(memcached_server_list_st ptr,\n                                                                  const char *hostname,\n                                                                  in_port_t port, uint32_t weight,\n                                                                  memcached_return_t *error) {\n  memcached_return_t unused;\n  if (error == NULL) {\n    error = &unused;\n  }\n\n  if (hostname == NULL) {\n    hostname = \"localhost\";\n  }\n\n  if (hostname[0] == '/') {\n    port = 0;\n  } else if (port == 0) {\n    port = MEMCACHED_DEFAULT_PORT;\n  }\n\n  /* Increment count for hosts */\n  uint32_t count = 1;\n  if (ptr) {\n    count += memcached_server_list_count(ptr);\n  }\n\n  memcached_server_list_st new_host_list =\n      (memcached_server_st *) realloc(ptr, sizeof(memcached_server_st) * count);\n  if (new_host_list == NULL) {\n#if 0\n    *error= memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n#endif\n    return NULL;\n  }\n\n  memcached_string_t _hostname = {memcached_string_make_from_cstr(hostname)};\n  /* @todo Check return type */\n  if (server_create_with(NULL, &new_host_list[count - 1], _hostname, port, weight,\n                         port ? MEMCACHED_CONNECTION_TCP : MEMCACHED_CONNECTION_UNIX_SOCKET)\n      == NULL)\n  {\n#if 0\n    *error= memcached_set_errno(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n#endif\n    free(new_host_list);\n    return NULL;\n  }\n\n#if 0\n  // Handset allocated since\n  new_host_list->options.is_allocated= true;\n#endif\n\n  /* Backwards compatibility hack */\n  memcached_servers_set_count(new_host_list, count);\n\n  *error = MEMCACHED_SUCCESS;\n  return new_host_list;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_servers_set_count",
          "args": [
            "new_host_list",
            "count"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_servers_set_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.cc",
          "lines": "127-134",
          "snippet": "uint32_t memcached_servers_set_count(memcached_server_st *servers, uint32_t count) {\n  WATCHPOINT_ASSERT(servers);\n  if (servers == NULL) {\n    return 0;\n  }\n\n  return servers->number_of_hosts = count;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_servers_set_count(memcached_server_st *servers, uint32_t count) {\n  WATCHPOINT_ASSERT(servers);\n  if (servers == NULL) {\n    return 0;\n  }\n\n  return servers->number_of_hosts = count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "new_host_list"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_list_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "98-109",
          "snippet": "void memcached_server_list_free(memcached_server_list_st self) {\n  if (self) {\n    for (uint32_t x = 0; x < memcached_server_list_count(self); x++) {\n      assert_msg(not memcached_is_allocated(&self[x]),\n                 \"You have called memcached_server_list_free(), but you did not pass it a valid \"\n                 \"memcached_server_list_st\");\n      server_free(&self[x]);\n    }\n\n    libmemcached_free(self->root, self);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_server_list_free(memcached_server_list_st self) {\n  if (self) {\n    for (uint32_t x = 0; x < memcached_server_list_count(self); x++) {\n      assert_msg(not memcached_is_allocated(&self[x]),\n                 \"You have called memcached_server_list_free(), but you did not pass it a valid \"\n                 \"memcached_server_list_st\");\n      server_free(&self[x]);\n    }\n\n    libmemcached_free(self->root, self);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_set_errno",
          "args": [
            "*ptr",
            "MEMCACHED_MEMORY_ALLOCATION_FAILURE",
            "MEMCACHED_AT"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "378-398",
          "snippet": "memcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [
            "#define MAX_ERROR_LENGTH 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\n#define MAX_ERROR_LENGTH 2048\n\nmemcached_return_t memcached_set_errno(memcached_instance_st &self, int local_errno,\n                                       const char *at) {\n  if (local_errno == 0) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  char hostname_port_message[MAX_ERROR_LENGTH];\n  size_t size = append_host_to_string(self, hostname_port_message, sizeof(hostname_port_message));\n\n  memcached_string_t error_host = {hostname_port_message, size};\n\n  memcached_return_t rc = MEMCACHED_ERRNO;\n  if (self.root == NULL) {\n    return rc;\n  }\n\n  _set(*self.root, &error_host, rc, at, local_errno);\n  _set(self, (*self.root));\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server_create_with",
          "args": [
            "NULL",
            "&new_host_list[count - 1]",
            "_hostname",
            "port",
            "weight",
            "port ? MEMCACHED_CONNECTION_TCP : MEMCACHED_CONNECTION_UNIX_SOCKET"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_string_make_from_cstr",
          "args": [
            "hostname"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_error",
          "args": [
            "*ptr",
            "MEMCACHED_MEMORY_ALLOCATION_FAILURE",
            "MEMCACHED_AT"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "293-303",
          "snippet": "memcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "ptr",
            "sizeof(memcached_server_st) * count"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_list_count",
          "args": [
            "ptr"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_list_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "83-85",
          "snippet": "uint32_t memcached_server_list_count(const memcached_server_list_st self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_server_list_count(const memcached_server_list_st self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_server_list_st memcached_server_list_append_with_weight(memcached_server_list_st ptr,\n                                                                  const char *hostname,\n                                                                  in_port_t port, uint32_t weight,\n                                                                  memcached_return_t *error) {\n  memcached_return_t unused;\n  if (error == NULL) {\n    error = &unused;\n  }\n\n  if (hostname == NULL) {\n    hostname = \"localhost\";\n  }\n\n  if (hostname[0] == '/') {\n    port = 0;\n  } else if (port == 0) {\n    port = MEMCACHED_DEFAULT_PORT;\n  }\n\n  /* Increment count for hosts */\n  uint32_t count = 1;\n  if (ptr) {\n    count += memcached_server_list_count(ptr);\n  }\n\n  memcached_server_list_st new_host_list =\n      (memcached_server_st *) realloc(ptr, sizeof(memcached_server_st) * count);\n  if (new_host_list == NULL) {\n#if 0\n    *error= memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n#endif\n    return NULL;\n  }\n\n  memcached_string_t _hostname = {memcached_string_make_from_cstr(hostname)};\n  /* @todo Check return type */\n  if (server_create_with(NULL, &new_host_list[count - 1], _hostname, port, weight,\n                         port ? MEMCACHED_CONNECTION_TCP : MEMCACHED_CONNECTION_UNIX_SOCKET)\n      == NULL)\n  {\n#if 0\n    *error= memcached_set_errno(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n#endif\n    free(new_host_list);\n    return NULL;\n  }\n\n#if 0\n  // Handset allocated since\n  new_host_list->options.is_allocated= true;\n#endif\n\n  /* Backwards compatibility hack */\n  memcached_servers_set_count(new_host_list, count);\n\n  *error = MEMCACHED_SUCCESS;\n  return new_host_list;\n}"
  }
]