[
  {
    "function_name": "memcached_mark_server_for_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.hpp",
    "lines": "44-67",
    "snippet": "static inline void memcached_mark_server_for_timeout(memcached_instance_st *server) {\n  if (server->state != MEMCACHED_SERVER_STATE_IN_TIMEOUT) {\n    if (server->server_timeout_counter_query_id != server->root->query_id) {\n      server->server_timeout_counter++;\n      server->server_timeout_counter_query_id = server->root->query_id;\n    }\n\n    if (server->server_timeout_counter >= server->root->server_timeout_limit) {\n      struct timeval next_time;\n      if (gettimeofday(&next_time, NULL) == 0) {\n        server->next_retry = next_time.tv_sec + server->root->retry_timeout;\n      } else {\n        server->next_retry = 1; // Setting the value to 1 causes the timeout to occur immediately\n      }\n\n      server->state = MEMCACHED_SERVER_STATE_IN_TIMEOUT;\n      if (server->server_failure_counter_query_id != server->root->query_id) {\n        server->server_failure_counter++;\n        server->server_failure_counter_query_id = server->root->query_id;\n      }\n      set_last_disconnected_host(server);\n    }\n  }\n}",
    "includes": [
      "#include <cassert>",
      "#include \"p9y/gettimeofday.hpp\""
    ],
    "macros_used": [],
    "globals_used": [
      "void memcached_instance_free(memcached_instance_st *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_last_disconnected_host",
          "args": [
            "server"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "set_last_disconnected_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
          "lines": "233-254",
          "snippet": "void set_last_disconnected_host(memcached_instance_st *self) {\n  assert(self->root);\n  if (self->root) {\n    if (memcached_server_get_last_disconnect(self->root)\n        and memcached_server_get_last_disconnect(self->root)->version == self->version)\n    {\n      return;\n    }\n\n    // const_cast\n    memcached_st *root = (memcached_st *) self->root;\n\n    memcached_instance_free((memcached_instance_st *) (root->last_disconnected_server));\n\n    // We set is_parsing so that no lookup happens\n    root->state.is_parsing = true;\n    root->last_disconnected_server = memcached_instance_clone(self);\n    root->state.is_parsing = false;\n\n    ((memcached_instance_st *) memcached_server_get_last_disconnect(root))->version = self->version;\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid set_last_disconnected_host(memcached_instance_st *self) {\n  assert(self->root);\n  if (self->root) {\n    if (memcached_server_get_last_disconnect(self->root)\n        and memcached_server_get_last_disconnect(self->root)->version == self->version)\n    {\n      return;\n    }\n\n    // const_cast\n    memcached_st *root = (memcached_st *) self->root;\n\n    memcached_instance_free((memcached_instance_st *) (root->last_disconnected_server));\n\n    // We set is_parsing so that no lookup happens\n    root->state.is_parsing = true;\n    root->last_disconnected_server = memcached_instance_clone(self);\n    root->state.is_parsing = false;\n\n    ((memcached_instance_st *) memcached_server_get_last_disconnect(root))->version = self->version;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "gettimeofday",
          "args": [
            "&next_time",
            "NULL"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "gettimeofday",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/win32/wrappers.h",
          "lines": "87-103",
          "snippet": "static inline int gettimeofday(struct timeval* tp, struct timezone* tzp) {\n  using clock = std::chrono::system_clock;\n  auto as_sec = [] (auto d) {\n      return std::chrono::duration_cast<std::chrono::seconds>(d);\n  };\n  auto as_usec = [] (auto d) {\n      return std::chrono::duration_cast<std::chrono::microseconds>(d);\n  };\n\n  auto now = clock::now().time_since_epoch();\n  auto sec = as_sec(now);\n  auto usec = as_usec(now - sec);\n\n  tp->tv_sec = sec.count();\n  tp->tv_usec = usec.count();\n  return 0;\n}",
          "includes": [
            "#  include <chrono>",
            "#include <inttypes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <chrono>\n#include <inttypes.h>\n\nstatic inline int gettimeofday(struct timeval* tp, struct timezone* tzp) {\n  using clock = std::chrono::system_clock;\n  auto as_sec = [] (auto d) {\n      return std::chrono::duration_cast<std::chrono::seconds>(d);\n  };\n  auto as_usec = [] (auto d) {\n      return std::chrono::duration_cast<std::chrono::microseconds>(d);\n  };\n\n  auto now = clock::now().time_since_epoch();\n  auto sec = as_sec(now);\n  auto usec = as_usec(now - sec);\n\n  tp->tv_sec = sec.count();\n  tp->tv_usec = usec.count();\n  return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cassert>\n#include \"p9y/gettimeofday.hpp\"\n\nvoid memcached_instance_free(memcached_instance_st *);\n\nstatic inline void memcached_mark_server_for_timeout(memcached_instance_st *server) {\n  if (server->state != MEMCACHED_SERVER_STATE_IN_TIMEOUT) {\n    if (server->server_timeout_counter_query_id != server->root->query_id) {\n      server->server_timeout_counter++;\n      server->server_timeout_counter_query_id = server->root->query_id;\n    }\n\n    if (server->server_timeout_counter >= server->root->server_timeout_limit) {\n      struct timeval next_time;\n      if (gettimeofday(&next_time, NULL) == 0) {\n        server->next_retry = next_time.tv_sec + server->root->retry_timeout;\n      } else {\n        server->next_retry = 1; // Setting the value to 1 causes the timeout to occur immediately\n      }\n\n      server->state = MEMCACHED_SERVER_STATE_IN_TIMEOUT;\n      if (server->server_failure_counter_query_id != server->root->query_id) {\n        server->server_failure_counter++;\n        server->server_failure_counter_query_id = server->root->query_id;\n      }\n      set_last_disconnected_host(server);\n    }\n  }\n}"
  },
  {
    "function_name": "memcached_is_valid_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.hpp",
    "lines": "36-38",
    "snippet": "static inline bool memcached_is_valid_filename(const memcached_string_t &arg) {\n  return arg.c_str != NULL and arg.size > 0 and arg.size < MEMCACHED_NI_MAXHOST;\n}",
    "includes": [
      "#include <cassert>",
      "#include \"p9y/gettimeofday.hpp\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <cassert>\n#include \"p9y/gettimeofday.hpp\"\n\nstatic inline bool memcached_is_valid_filename(const memcached_string_t &arg) {\n  return arg.c_str != NULL and arg.size > 0 and arg.size < MEMCACHED_NI_MAXHOST;\n}"
  },
  {
    "function_name": "memcached_is_valid_servername",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server.hpp",
    "lines": "32-34",
    "snippet": "static inline bool memcached_is_valid_servername(const memcached_string_t &arg) {\n  return (arg.c_str != NULL or arg.size == 0) and arg.size < MEMCACHED_NI_MAXHOST;\n}",
    "includes": [
      "#include <cassert>",
      "#include \"p9y/gettimeofday.hpp\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <cassert>\n#include \"p9y/gettimeofday.hpp\"\n\nstatic inline bool memcached_is_valid_servername(const memcached_string_t &arg) {\n  return (arg.c_str != NULL or arg.size == 0) and arg.size < MEMCACHED_NI_MAXHOST;\n}"
  }
]