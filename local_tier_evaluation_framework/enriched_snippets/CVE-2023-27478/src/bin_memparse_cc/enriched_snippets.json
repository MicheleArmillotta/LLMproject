[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memparse.cc",
    "lines": "24-43",
    "snippet": "int main(int argc, char *argv[]) {\n  if (argc < 2) {\n    std::cerr << \"No arguments provided.\" << std::endl;\n    return EXIT_FAILURE;\n  }\n\n  for (int x = 1; x < argc; x++) {\n    char buffer[BUFSIZ];\n    memcached_return_t rc;\n    rc = libmemcached_check_configuration(argv[x], strlen(argv[x]), buffer, sizeof(buffer));\n\n    if (rc != MEMCACHED_SUCCESS) {\n      std::cerr << \"Failed to parse argument #\" << x << \" \" << argv[x] << std::endl;\n      std::cerr << buffer << std::endl;\n      return EXIT_FAILURE;\n    }\n  }\n\n  return EXIT_SUCCESS;\n}",
    "includes": [
      "#include \"libmemcached-1.0/memcached.h\"",
      "#include <iostream>",
      "#include <cstring>",
      "#include <cstdio>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libmemcached_check_configuration",
          "args": [
            "argv[x]",
            "strlen(argv[x])",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "libmemcached_check_configuration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/options.cc",
          "lines": "54-91",
          "snippet": "memcached_return_t libmemcached_check_configuration(const char *option_string, size_t length,\n                                                    char *error_buffer, size_t error_buffer_size) {\n  memcached_st memc, *memc_ptr;\n\n  if (option_string == NULL or length == 0) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (error_buffer and error_buffer_size) {\n    error_buffer[0] = 0;\n  }\n\n  if (not(memc_ptr = memcached_create(&memc))) {\n    return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n  }\n\n  memcached_return_t rc = memcached_parse_configuration(memc_ptr, option_string, length);\n  if (memcached_failed(rc) and error_buffer and error_buffer_size) {\n    strncpy(error_buffer, memcached_last_error_message(memc_ptr), error_buffer_size);\n    error_buffer[error_buffer_size - 1] = 0;\n  }\n\n  bool has_filename = memcached_behavior_get(memc_ptr, MEMCACHED_BEHAVIOR_LOAD_FROM_FILE);\n  if (memcached_success(rc) and has_filename) {\n    assert_msg(memcached_parse_filename(memc_ptr), \"Invalid configuration file\");\n    assert_msg(memcached_parse_filename_length(memc_ptr), \"Invalid configuration file\");\n    rc = _parse_file_options(*memc_ptr, memc_ptr->configure.filename);\n\n    if (memcached_failed(rc) and error_buffer and error_buffer_size) {\n      strncpy(error_buffer, memcached_last_error_message(memc_ptr), error_buffer_size);\n      error_buffer[error_buffer_size - 1] = 0;\n    }\n  }\n\n  memcached_free(memc_ptr);\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/csl/context.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t libmemcached_check_configuration(const char *option_string, size_t length,\n                                                    char *error_buffer, size_t error_buffer_size) {\n  memcached_st memc, *memc_ptr;\n\n  if (option_string == NULL or length == 0) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (error_buffer and error_buffer_size) {\n    error_buffer[0] = 0;\n  }\n\n  if (not(memc_ptr = memcached_create(&memc))) {\n    return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n  }\n\n  memcached_return_t rc = memcached_parse_configuration(memc_ptr, option_string, length);\n  if (memcached_failed(rc) and error_buffer and error_buffer_size) {\n    strncpy(error_buffer, memcached_last_error_message(memc_ptr), error_buffer_size);\n    error_buffer[error_buffer_size - 1] = 0;\n  }\n\n  bool has_filename = memcached_behavior_get(memc_ptr, MEMCACHED_BEHAVIOR_LOAD_FROM_FILE);\n  if (memcached_success(rc) and has_filename) {\n    assert_msg(memcached_parse_filename(memc_ptr), \"Invalid configuration file\");\n    assert_msg(memcached_parse_filename_length(memc_ptr), \"Invalid configuration file\");\n    rc = _parse_file_options(*memc_ptr, memc_ptr->configure.filename);\n\n    if (memcached_failed(rc) and error_buffer and error_buffer_size) {\n      strncpy(error_buffer, memcached_last_error_message(memc_ptr), error_buffer_size);\n      error_buffer[error_buffer_size - 1] = 0;\n    }\n  }\n\n  memcached_free(memc_ptr);\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[x]"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached-1.0/memcached.h\"\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include \"mem_config.h\"\n\nint main(int argc, char *argv[]) {\n  if (argc < 2) {\n    std::cerr << \"No arguments provided.\" << std::endl;\n    return EXIT_FAILURE;\n  }\n\n  for (int x = 1; x < argc; x++) {\n    char buffer[BUFSIZ];\n    memcached_return_t rc;\n    rc = libmemcached_check_configuration(argv[x], strlen(argv[x]), buffer, sizeof(buffer));\n\n    if (rc != MEMCACHED_SUCCESS) {\n      std::cerr << \"Failed to parse argument #\" << x << \" \" << argv[x] << std::endl;\n      std::cerr << buffer << std::endl;\n      return EXIT_FAILURE;\n    }\n  }\n\n  return EXIT_SUCCESS;\n}"
  }
]