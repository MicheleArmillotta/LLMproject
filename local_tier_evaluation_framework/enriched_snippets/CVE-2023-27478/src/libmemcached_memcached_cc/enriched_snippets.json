[
  {
    "function_name": "memcached_query_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
    "lines": "401-408",
    "snippet": "uint64_t memcached_query_id(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    return memc->query_id;\n  }\n\n  return 0;\n}",
    "includes": [
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nuint64_t memcached_query_id(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    return memc->query_id;\n  }\n\n  return 0;\n}"
  },
  {
    "function_name": "memcached_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
    "lines": "368-371",
    "snippet": "memcached_return_t memcached_push(memcached_st *destination, const memcached_st *source) {\n  return memcached_instance_push(destination, (memcached_instance_st *) source->servers,\n                                 source->number_of_hosts);\n}",
    "includes": [
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_instance_push",
          "args": [
            "destination",
            "(memcached_instance_st *) source->servers",
            "source->number_of_hosts"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "375-420",
          "snippet": "memcached_return_t memcached_instance_push(memcached_st *ptr,\n                                           const struct memcached_instance_st *list,\n                                           uint32_t number_of_hosts) {\n  if (list == NULL) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  uint32_t original_host_size = memcached_server_count(ptr);\n  uint32_t host_list_size = number_of_hosts + original_host_size;\n  memcached_instance_st *new_host_list = libmemcached_xrealloc(\n      ptr, memcached_instance_list(ptr), host_list_size, memcached_instance_st);\n\n  if (new_host_list == NULL) {\n    return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n  }\n\n  memcached_instance_set(ptr, new_host_list, host_list_size);\n\n  // We don't bother with lookups for this operation\n  ptr->state.is_parsing = true;\n\n  // We use original_host_size since size will now point to the first new\n  // instance allocated.\n  for (uint32_t x = 0; x < number_of_hosts; ++x, ++original_host_size) {\n    WATCHPOINT_ASSERT(list[x]._hostname[0]);\n\n    // We have extended the array, and now we will find it, and use it.\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, original_host_size);\n    WATCHPOINT_ASSERT(instance);\n\n    memcached_string_t hostname = {memcached_string_make_from_cstr(list[x]._hostname)};\n    if (instance_create_with(ptr, instance, hostname, list[x].port(), list[x].weight, list[x].type)\n        == NULL)\n    {\n      ptr->state.is_parsing = false;\n      return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n    }\n\n    if (list[x].weight > 1) {\n      memcached_set_weighted_ketama(ptr, true);\n    }\n  }\n  ptr->state.is_parsing = false;\n\n  return run_distribution(ptr);\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static memcached_return_t update_continuum(Memcached *ptr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t update_continuum(Memcached *ptr);\n\nmemcached_return_t memcached_instance_push(memcached_st *ptr,\n                                           const struct memcached_instance_st *list,\n                                           uint32_t number_of_hosts) {\n  if (list == NULL) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  uint32_t original_host_size = memcached_server_count(ptr);\n  uint32_t host_list_size = number_of_hosts + original_host_size;\n  memcached_instance_st *new_host_list = libmemcached_xrealloc(\n      ptr, memcached_instance_list(ptr), host_list_size, memcached_instance_st);\n\n  if (new_host_list == NULL) {\n    return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n  }\n\n  memcached_instance_set(ptr, new_host_list, host_list_size);\n\n  // We don't bother with lookups for this operation\n  ptr->state.is_parsing = true;\n\n  // We use original_host_size since size will now point to the first new\n  // instance allocated.\n  for (uint32_t x = 0; x < number_of_hosts; ++x, ++original_host_size) {\n    WATCHPOINT_ASSERT(list[x]._hostname[0]);\n\n    // We have extended the array, and now we will find it, and use it.\n    memcached_instance_st *instance = memcached_instance_fetch(ptr, original_host_size);\n    WATCHPOINT_ASSERT(instance);\n\n    memcached_string_t hostname = {memcached_string_make_from_cstr(list[x]._hostname)};\n    if (instance_create_with(ptr, instance, hostname, list[x].port(), list[x].weight, list[x].type)\n        == NULL)\n    {\n      ptr->state.is_parsing = false;\n      return memcached_set_error(*ptr, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);\n    }\n\n    if (list[x].weight > 1) {\n      memcached_set_weighted_ketama(ptr, true);\n    }\n  }\n  ptr->state.is_parsing = false;\n\n  return run_distribution(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_push(memcached_st *destination, const memcached_st *source) {\n  return memcached_instance_push(destination, (memcached_instance_st *) source->servers,\n                                 source->number_of_hosts);\n}"
  },
  {
    "function_name": "memcached_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
    "lines": "257-261",
    "snippet": "void memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}",
    "includes": [
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_free_ex",
          "args": [
            "ptr",
            "true"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_free_ex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
          "lines": "107-143",
          "snippet": "static void memcached_free_ex(Memcached *ptr, bool release_st) {\n  /* If we have anything open, lets close it now */\n  send_quit(ptr);\n  memcached_instance_list_free(memcached_instance_list(ptr), memcached_instance_list_count(ptr));\n  memcached_result_free(&ptr->result);\n\n  memcached_virtual_bucket_free(ptr);\n\n  memcached_instance_free((memcached_instance_st *) ptr->last_disconnected_server);\n\n  if (ptr->on_cleanup) {\n    ptr->on_cleanup(ptr);\n  }\n\n  libmemcached_free(ptr, ptr->ketama.continuum);\n  ptr->ketama.continuum = NULL;\n\n  memcached_array_free(ptr->_namespace);\n  ptr->_namespace = NULL;\n\n  memcached_error_free(*ptr);\n\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT and ptr->sasl.callbacks) {\n    memcached_destroy_sasl_auth_data(ptr);\n  }\n\n  if (release_st) {\n    memcached_array_free(ptr->configure.filename);\n    ptr->configure.filename = NULL;\n  }\n\n  hashkit_free(&ptr->hashkit);\n\n  if (memcached_is_allocated(ptr) and release_st) {\n    libmemcached_free(ptr, ptr);\n  }\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic void memcached_free_ex(Memcached *ptr, bool release_st) {\n  /* If we have anything open, lets close it now */\n  send_quit(ptr);\n  memcached_instance_list_free(memcached_instance_list(ptr), memcached_instance_list_count(ptr));\n  memcached_result_free(&ptr->result);\n\n  memcached_virtual_bucket_free(ptr);\n\n  memcached_instance_free((memcached_instance_st *) ptr->last_disconnected_server);\n\n  if (ptr->on_cleanup) {\n    ptr->on_cleanup(ptr);\n  }\n\n  libmemcached_free(ptr, ptr->ketama.continuum);\n  ptr->ketama.continuum = NULL;\n\n  memcached_array_free(ptr->_namespace);\n  ptr->_namespace = NULL;\n\n  memcached_error_free(*ptr);\n\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT and ptr->sasl.callbacks) {\n    memcached_destroy_sasl_auth_data(ptr);\n  }\n\n  if (release_st) {\n    memcached_array_free(ptr->configure.filename);\n    ptr->configure.filename = NULL;\n  }\n\n  hashkit_free(&ptr->hashkit);\n\n  if (memcached_is_allocated(ptr) and release_st) {\n    libmemcached_free(ptr, ptr);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}"
  },
  {
    "function_name": "memcached_reset_last_disconnected_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
    "lines": "249-255",
    "snippet": "void memcached_reset_last_disconnected_server(memcached_st *shell) {\n  Memcached *self = memcached2Memcached(shell);\n  if (self) {\n    memcached_instance_free((memcached_instance_st *) self->last_disconnected_server);\n    self->last_disconnected_server = NULL;\n  }\n}",
    "includes": [
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_instance_free",
          "args": [
            "(memcached_instance_st *) self->last_disconnected_server"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
          "lines": "141-145",
          "snippet": "void memcached_instance_free(memcached_instance_st *self) {\n  if (self) {\n    instance_free(self);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_instance_free(memcached_instance_st *self) {\n  if (self) {\n    instance_free(self);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_reset_last_disconnected_server(memcached_st *shell) {\n  Memcached *self = memcached2Memcached(shell);\n  if (self) {\n    memcached_instance_free((memcached_instance_st *) self->last_disconnected_server);\n    self->last_disconnected_server = NULL;\n  }\n}"
  },
  {
    "function_name": "memcached_servers_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
    "lines": "234-247",
    "snippet": "void memcached_servers_reset(memcached_st *shell) {\n  Memcached *self = memcached2Memcached(shell);\n  if (self) {\n    libmemcached_free(self, self->ketama.continuum);\n    self->ketama.continuum = NULL;\n    self->ketama.continuum_count = 0;\n    self->ketama.continuum_points_counter = 0;\n\n    memcached_instance_list_free(memcached_instance_list(self), self->number_of_hosts);\n    memcached_instance_set(self, NULL, 0);\n\n    memcached_reset_last_disconnected_server(self);\n  }\n}",
    "includes": [
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_reset_last_disconnected_server",
          "args": [
            "self"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_reset_last_disconnected_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
          "lines": "249-255",
          "snippet": "void memcached_reset_last_disconnected_server(memcached_st *shell) {\n  Memcached *self = memcached2Memcached(shell);\n  if (self) {\n    memcached_instance_free((memcached_instance_st *) self->last_disconnected_server);\n    self->last_disconnected_server = NULL;\n  }\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_reset_last_disconnected_server(memcached_st *shell) {\n  Memcached *self = memcached2Memcached(shell);\n  if (self) {\n    memcached_instance_free((memcached_instance_st *) self->last_disconnected_server);\n    self->last_disconnected_server = NULL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_set",
          "args": [
            "self",
            "NULL",
            "0"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "91-96",
          "snippet": "void memcached_instance_set(memcached_st *memc, memcached_instance_st *list,\n                            const uint32_t host_list_size) {\n  assert(memc);\n  memc->servers = list;\n  memc->number_of_hosts = host_list_size;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_instance_set(memcached_st *memc, memcached_instance_st *list,\n                            const uint32_t host_list_size) {\n  assert(memc);\n  memc->servers = list;\n  memc->number_of_hosts = host_list_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_list_free",
          "args": [
            "memcached_instance_list(self)",
            "self->number_of_hosts"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_list_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "111-122",
          "snippet": "void memcached_instance_list_free(memcached_instance_st *self, uint32_t instance_count) {\n  if (self) {\n    for (uint32_t x = 0; x < instance_count; x++) {\n      assert_msg(memcached_is_allocated(&self[x]) == false,\n                 \"You have called memcached_server_list_free(), but you did not pass it a valid \"\n                 \"memcached_server_list_st\");\n      instance_free(&self[x]);\n    }\n\n    libmemcached_free(self->root, self);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_instance_list_free(memcached_instance_st *self, uint32_t instance_count) {\n  if (self) {\n    for (uint32_t x = 0; x < instance_count; x++) {\n      assert_msg(memcached_is_allocated(&self[x]) == false,\n                 \"You have called memcached_server_list_free(), but you did not pass it a valid \"\n                 \"memcached_server_list_st\");\n      instance_free(&self[x]);\n    }\n\n    libmemcached_free(self->root, self);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_list",
          "args": [
            "self"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_list_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "87-89",
          "snippet": "uint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libmemcached_free",
          "args": [
            "self",
            "self->ketama.continuum"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "libmemcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memory.h",
          "lines": "30-40",
          "snippet": "static inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#  include <stddef.h>",
            "#  include <cstdlib>",
            "#  include <cstddef>",
            "#include \"libmemcached/common.h\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#  include <stddef.h>\n#  include <cstdlib>\n#  include <cstddef>\n#include \"libmemcached/common.h\"\n#include \"mem_config.h\"\n\nstatic inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_servers_reset(memcached_st *shell) {\n  Memcached *self = memcached2Memcached(shell);\n  if (self) {\n    libmemcached_free(self, self->ketama.continuum);\n    self->ketama.continuum = NULL;\n    self->ketama.continuum_count = 0;\n    self->ketama.continuum_points_counter = 0;\n\n    memcached_instance_list_free(memcached_instance_list(self), self->number_of_hosts);\n    memcached_instance_set(self, NULL, 0);\n\n    memcached_reset_last_disconnected_server(self);\n  }\n}"
  },
  {
    "function_name": "memcached_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
    "lines": "213-232",
    "snippet": "memcached_return_t memcached_reset(memcached_st *shell) {\n  Memcached *ptr = memcached2Memcached(shell);\n  WATCHPOINT_ASSERT(ptr);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  bool stored_is_allocated = memcached_is_allocated(ptr);\n  uint64_t query_id = ptr->query_id;\n  memcached_free_ex(ptr, false);\n  memcached_create(ptr);\n  memcached_set_allocated(ptr, stored_is_allocated);\n  ptr->query_id = query_id;\n\n  if (ptr->configure.filename) {\n    return memcached_parse_configure_file(*ptr, memcached_param_array(ptr->configure.filename));\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_parse_configure_file",
          "args": [
            "*ptr",
            "memcached_param_array(ptr->configure.filename)"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_parse_configure_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/options.cc",
          "lines": "139-147",
          "snippet": "memcached_return_t memcached_parse_configure_file(memcached_st &self,\n                                                  memcached_array_st &filename) {\n  WATCHPOINT_ASSERT(memcached_array_size(&filename));\n  if (not memcached_array_size(&filename)) {\n    return memcached_set_error(self, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT);\n  }\n\n  return _parse_file_options(self, &filename);\n}",
          "includes": [
            "#include \"libmemcached/csl/context.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/csl/context.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_parse_configure_file(memcached_st &self,\n                                                  memcached_array_st &filename) {\n  WATCHPOINT_ASSERT(memcached_array_size(&filename));\n  if (not memcached_array_size(&filename)) {\n    return memcached_set_error(self, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT);\n  }\n\n  return _parse_file_options(self, &filename);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_param_array",
          "args": [
            "ptr->configure.filename"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_allocated",
          "args": [
            "ptr",
            "stored_is_allocated"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_create",
          "args": [
            "ptr"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_free_ex",
          "args": [
            "ptr",
            "false"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_free_ex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
          "lines": "107-143",
          "snippet": "static void memcached_free_ex(Memcached *ptr, bool release_st) {\n  /* If we have anything open, lets close it now */\n  send_quit(ptr);\n  memcached_instance_list_free(memcached_instance_list(ptr), memcached_instance_list_count(ptr));\n  memcached_result_free(&ptr->result);\n\n  memcached_virtual_bucket_free(ptr);\n\n  memcached_instance_free((memcached_instance_st *) ptr->last_disconnected_server);\n\n  if (ptr->on_cleanup) {\n    ptr->on_cleanup(ptr);\n  }\n\n  libmemcached_free(ptr, ptr->ketama.continuum);\n  ptr->ketama.continuum = NULL;\n\n  memcached_array_free(ptr->_namespace);\n  ptr->_namespace = NULL;\n\n  memcached_error_free(*ptr);\n\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT and ptr->sasl.callbacks) {\n    memcached_destroy_sasl_auth_data(ptr);\n  }\n\n  if (release_st) {\n    memcached_array_free(ptr->configure.filename);\n    ptr->configure.filename = NULL;\n  }\n\n  hashkit_free(&ptr->hashkit);\n\n  if (memcached_is_allocated(ptr) and release_st) {\n    libmemcached_free(ptr, ptr);\n  }\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic void memcached_free_ex(Memcached *ptr, bool release_st) {\n  /* If we have anything open, lets close it now */\n  send_quit(ptr);\n  memcached_instance_list_free(memcached_instance_list(ptr), memcached_instance_list_count(ptr));\n  memcached_result_free(&ptr->result);\n\n  memcached_virtual_bucket_free(ptr);\n\n  memcached_instance_free((memcached_instance_st *) ptr->last_disconnected_server);\n\n  if (ptr->on_cleanup) {\n    ptr->on_cleanup(ptr);\n  }\n\n  libmemcached_free(ptr, ptr->ketama.continuum);\n  ptr->ketama.continuum = NULL;\n\n  memcached_array_free(ptr->_namespace);\n  ptr->_namespace = NULL;\n\n  memcached_error_free(*ptr);\n\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT and ptr->sasl.callbacks) {\n    memcached_destroy_sasl_auth_data(ptr);\n  }\n\n  if (release_st) {\n    memcached_array_free(ptr->configure.filename);\n    ptr->configure.filename = NULL;\n  }\n\n  hashkit_free(&ptr->hashkit);\n\n  if (memcached_is_allocated(ptr) and release_st) {\n    libmemcached_free(ptr, ptr);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_allocated",
          "args": [
            "ptr"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "ptr"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_reset(memcached_st *shell) {\n  Memcached *ptr = memcached2Memcached(shell);\n  WATCHPOINT_ASSERT(ptr);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  bool stored_is_allocated = memcached_is_allocated(ptr);\n  uint64_t query_id = ptr->query_id;\n  memcached_free_ex(ptr, false);\n  memcached_create(ptr);\n  memcached_set_allocated(ptr, stored_is_allocated);\n  ptr->query_id = query_id;\n\n  if (ptr->configure.filename) {\n    return memcached_parse_configure_file(*ptr, memcached_param_array(ptr->configure.filename));\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "memcached_free_ex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
    "lines": "107-143",
    "snippet": "static void memcached_free_ex(Memcached *ptr, bool release_st) {\n  /* If we have anything open, lets close it now */\n  send_quit(ptr);\n  memcached_instance_list_free(memcached_instance_list(ptr), memcached_instance_list_count(ptr));\n  memcached_result_free(&ptr->result);\n\n  memcached_virtual_bucket_free(ptr);\n\n  memcached_instance_free((memcached_instance_st *) ptr->last_disconnected_server);\n\n  if (ptr->on_cleanup) {\n    ptr->on_cleanup(ptr);\n  }\n\n  libmemcached_free(ptr, ptr->ketama.continuum);\n  ptr->ketama.continuum = NULL;\n\n  memcached_array_free(ptr->_namespace);\n  ptr->_namespace = NULL;\n\n  memcached_error_free(*ptr);\n\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT and ptr->sasl.callbacks) {\n    memcached_destroy_sasl_auth_data(ptr);\n  }\n\n  if (release_st) {\n    memcached_array_free(ptr->configure.filename);\n    ptr->configure.filename = NULL;\n  }\n\n  hashkit_free(&ptr->hashkit);\n\n  if (memcached_is_allocated(ptr) and release_st) {\n    libmemcached_free(ptr, ptr);\n  }\n}",
    "includes": [
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libmemcached_free",
          "args": [
            "ptr",
            "ptr"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "libmemcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memory.h",
          "lines": "30-40",
          "snippet": "static inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#  include <stddef.h>",
            "#  include <cstdlib>",
            "#  include <cstddef>",
            "#include \"libmemcached/common.h\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#  include <stddef.h>\n#  include <cstdlib>\n#  include <cstddef>\n#include \"libmemcached/common.h\"\n#include \"mem_config.h\"\n\nstatic inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_allocated",
          "args": [
            "ptr"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashkit_free",
          "args": [
            "&ptr->hashkit"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "hashkit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/hashkit.cc",
          "lines": "55-64",
          "snippet": "void hashkit_free(hashkit_st *self) {\n  if (self and self->_key) {\n    aes_free_key((aes_key_t *) self->_key);\n    self->_key = NULL;\n  }\n\n  if (hashkit_is_allocated(self)) {\n    free(self);\n  }\n}",
          "includes": [
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libhashkit/common.h\"\n\nvoid hashkit_free(hashkit_st *self) {\n  if (self and self->_key) {\n    aes_free_key((aes_key_t *) self->_key);\n    self->_key = NULL;\n  }\n\n  if (hashkit_is_allocated(self)) {\n    free(self);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_array_free",
          "args": [
            "ptr->configure.filename"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_array_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/array.cc",
          "lines": "71-76",
          "snippet": "void memcached_array_free(memcached_array_st *array) {\n  if (array) {\n    WATCHPOINT_ASSERT(array->root);\n    libmemcached_free(array->root, array);\n  }\n}",
          "includes": [
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include \"libmemcached/common.h\"\n\nvoid memcached_array_free(memcached_array_st *array) {\n  if (array) {\n    WATCHPOINT_ASSERT(array->root);\n    libmemcached_free(array->root, array);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_destroy_sasl_auth_data",
          "args": [
            "ptr"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_destroy_sasl_auth_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
          "lines": "474-476",
          "snippet": "memcached_return_t memcached_destroy_sasl_auth_data(memcached_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}",
          "includes": [
            "#  include <pthread.h>",
            "#    include <sasl/sasl.h>",
            "#include <atomic>",
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_destroy_sasl_auth_data(memcached_st *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_error_free",
          "args": [
            "*ptr"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_error_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "447-450",
          "snippet": "void memcached_error_free(memcached_server_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_error_free(memcached_server_st &self) {\n  _error_free(self.error_messages);\n  self.error_messages = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr->on_cleanup",
          "args": [
            "ptr"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_instance_free",
          "args": [
            "(memcached_instance_st *) ptr->last_disconnected_server"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
          "lines": "141-145",
          "snippet": "void memcached_instance_free(memcached_instance_st *self) {\n  if (self) {\n    instance_free(self);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_instance_free(memcached_instance_st *self) {\n  if (self) {\n    instance_free(self);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_virtual_bucket_free",
          "args": [
            "ptr"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_virtual_bucket_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/virtual_bucket.cc",
          "lines": "65-72",
          "snippet": "void memcached_virtual_bucket_free(memcached_st *self) {\n  if (self) {\n    if (self->virtual_bucket) {\n      free(self->virtual_bucket);\n      self->virtual_bucket = NULL;\n    }\n  }\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_virtual_bucket_free(memcached_st *self) {\n  if (self) {\n    if (self->virtual_bucket) {\n      free(self->virtual_bucket);\n      self->virtual_bucket = NULL;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_result_free",
          "args": [
            "&ptr->result"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_result_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/result.cc",
          "lines": "66-82",
          "snippet": "void memcached_result_free(memcached_result_st *ptr) {\n  if (ptr == NULL) {\n    return;\n  }\n\n  memcached_string_free(&ptr->value);\n  ptr->numeric_value = UINT64_MAX;\n\n  if (memcached_is_allocated(ptr)) {\n    WATCHPOINT_ASSERT(\n        ptr->root); // Without a root, that means that result was not properly initialized.\n    libmemcached_free(ptr->root, ptr);\n  } else {\n    ptr->count = 0;\n    ptr->options.is_initialized = false;\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_result_free(memcached_result_st *ptr) {\n  if (ptr == NULL) {\n    return;\n  }\n\n  memcached_string_free(&ptr->value);\n  ptr->numeric_value = UINT64_MAX;\n\n  if (memcached_is_allocated(ptr)) {\n    WATCHPOINT_ASSERT(\n        ptr->root); // Without a root, that means that result was not properly initialized.\n    libmemcached_free(ptr->root, ptr);\n  } else {\n    ptr->count = 0;\n    ptr->options.is_initialized = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_list_free",
          "args": [
            "memcached_instance_list(ptr)",
            "memcached_instance_list_count(ptr)"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_list_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "111-122",
          "snippet": "void memcached_instance_list_free(memcached_instance_st *self, uint32_t instance_count) {\n  if (self) {\n    for (uint32_t x = 0; x < instance_count; x++) {\n      assert_msg(memcached_is_allocated(&self[x]) == false,\n                 \"You have called memcached_server_list_free(), but you did not pass it a valid \"\n                 \"memcached_server_list_st\");\n      instance_free(&self[x]);\n    }\n\n    libmemcached_free(self->root, self);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_instance_list_free(memcached_instance_st *self, uint32_t instance_count) {\n  if (self) {\n    for (uint32_t x = 0; x < instance_count; x++) {\n      assert_msg(memcached_is_allocated(&self[x]) == false,\n                 \"You have called memcached_server_list_free(), but you did not pass it a valid \"\n                 \"memcached_server_list_st\");\n      instance_free(&self[x]);\n    }\n\n    libmemcached_free(self->root, self);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_list_count",
          "args": [
            "ptr"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_instance_list_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/server_list.cc",
          "lines": "87-89",
          "snippet": "uint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nuint32_t memcached_instance_list_count(const memcached_st *self) {\n  return (self == NULL) ? 0 : self->number_of_hosts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_quit",
          "args": [
            "ptr"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "send_quit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/quit.cc",
          "lines": "101-107",
          "snippet": "void send_quit(Memcached *memc) {\n  for (uint32_t x = 0; x < memcached_server_count(memc); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(memc, x);\n\n    memcached_quit_server(instance, false);\n  }\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid send_quit(Memcached *memc) {\n  for (uint32_t x = 0; x < memcached_server_count(memc); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(memc, x);\n\n    memcached_quit_server(instance, false);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic void memcached_free_ex(Memcached *ptr, bool release_st) {\n  /* If we have anything open, lets close it now */\n  send_quit(ptr);\n  memcached_instance_list_free(memcached_instance_list(ptr), memcached_instance_list_count(ptr));\n  memcached_result_free(&ptr->result);\n\n  memcached_virtual_bucket_free(ptr);\n\n  memcached_instance_free((memcached_instance_st *) ptr->last_disconnected_server);\n\n  if (ptr->on_cleanup) {\n    ptr->on_cleanup(ptr);\n  }\n\n  libmemcached_free(ptr, ptr->ketama.continuum);\n  ptr->ketama.continuum = NULL;\n\n  memcached_array_free(ptr->_namespace);\n  ptr->_namespace = NULL;\n\n  memcached_error_free(*ptr);\n\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT and ptr->sasl.callbacks) {\n    memcached_destroy_sasl_auth_data(ptr);\n  }\n\n  if (release_st) {\n    memcached_array_free(ptr->configure.filename);\n    ptr->configure.filename = NULL;\n  }\n\n  hashkit_free(&ptr->hashkit);\n\n  if (memcached_is_allocated(ptr) and release_st) {\n    libmemcached_free(ptr, ptr);\n  }\n}"
  },
  {
    "function_name": "_memcached_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
    "lines": "21-105",
    "snippet": "static inline bool _memcached_init(Memcached *self) {\n  self->state.is_purging = false;\n  self->state.is_processing_input = false;\n  self->state.is_time_for_rebuild = false;\n  self->state.is_parsing = false;\n\n  self->flags.auto_eject_hosts = false;\n  self->flags.binary_protocol = false;\n  self->flags.buffer_requests = false;\n  self->flags.hash_with_namespace = false;\n  self->flags.no_block = false;\n  self->flags.reply = true;\n  self->flags.randomize_replica_read = false;\n  self->flags.support_cas = false;\n  self->flags.tcp_nodelay = false;\n  self->flags.use_sort_hosts = false;\n  self->flags.use_udp = false;\n  self->flags.verify_key = false;\n  self->flags.tcp_keepalive = false;\n  self->flags.is_aes = false;\n  self->flags.is_fetching_version = false;\n\n  self->virtual_bucket = NULL;\n\n  self->distribution = MEMCACHED_DISTRIBUTION_MODULA;\n\n  if (hashkit_create(&self->hashkit) == NULL) {\n    return false;\n  }\n\n  self->server_info.version = 0;\n\n  self->ketama.continuum = NULL;\n  self->ketama.continuum_count = 0;\n  self->ketama.continuum_points_counter = 0;\n  self->ketama.next_distribution_rebuild = 0;\n  self->ketama.weighted_ = false;\n\n  self->number_of_hosts = 0;\n  self->servers = NULL;\n  self->last_disconnected_server = NULL;\n\n  self->snd_timeout = 0;\n  self->rcv_timeout = 0;\n  self->server_failure_limit = MEMCACHED_SERVER_FAILURE_LIMIT;\n  self->server_timeout_limit = MEMCACHED_SERVER_TIMEOUT_LIMIT;\n  self->query_id = 1; // 0 is considered invalid\n\n  /* TODO, Document why we picked these defaults */\n  self->io_msg_watermark = 500;\n  self->io_bytes_watermark = 65 * 1024;\n\n  self->tcp_keepidle = 0;\n\n  self->io_key_prefetch = 0;\n  self->poll_timeout = MEMCACHED_DEFAULT_TIMEOUT;\n  self->connect_timeout = MEMCACHED_DEFAULT_CONNECT_TIMEOUT;\n  self->retry_timeout = MEMCACHED_SERVER_FAILURE_RETRY_TIMEOUT;\n  self->dead_timeout = MEMCACHED_SERVER_FAILURE_DEAD_TIMEOUT;\n\n  self->send_size = -1;\n  self->recv_size = -1;\n\n  self->user_data = NULL;\n  self->number_of_replicas = 0;\n\n  self->allocators = memcached_allocators_return_default();\n\n  self->on_clone = NULL;\n  self->on_cleanup = NULL;\n  self->get_key_failure = NULL;\n  self->delete_trigger = NULL;\n  self->callbacks = NULL;\n  self->sasl.callbacks = NULL;\n  self->sasl.is_allocated = false;\n\n  self->error_messages = NULL;\n  self->_namespace = NULL;\n  self->configure.initial_pool_size = 1;\n  self->configure.max_pool_size = 1;\n  self->configure.version = -1;\n  self->configure.filename = NULL;\n\n  return true;\n}",
    "includes": [
      "#include \"libmemcached/virtual_bucket.h\"",
      "#include \"libmemcached/options.hpp\"",
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_allocators_return_default",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashkit_create",
          "args": [
            "&self->hashkit"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic inline bool _memcached_init(Memcached *self) {\n  self->state.is_purging = false;\n  self->state.is_processing_input = false;\n  self->state.is_time_for_rebuild = false;\n  self->state.is_parsing = false;\n\n  self->flags.auto_eject_hosts = false;\n  self->flags.binary_protocol = false;\n  self->flags.buffer_requests = false;\n  self->flags.hash_with_namespace = false;\n  self->flags.no_block = false;\n  self->flags.reply = true;\n  self->flags.randomize_replica_read = false;\n  self->flags.support_cas = false;\n  self->flags.tcp_nodelay = false;\n  self->flags.use_sort_hosts = false;\n  self->flags.use_udp = false;\n  self->flags.verify_key = false;\n  self->flags.tcp_keepalive = false;\n  self->flags.is_aes = false;\n  self->flags.is_fetching_version = false;\n\n  self->virtual_bucket = NULL;\n\n  self->distribution = MEMCACHED_DISTRIBUTION_MODULA;\n\n  if (hashkit_create(&self->hashkit) == NULL) {\n    return false;\n  }\n\n  self->server_info.version = 0;\n\n  self->ketama.continuum = NULL;\n  self->ketama.continuum_count = 0;\n  self->ketama.continuum_points_counter = 0;\n  self->ketama.next_distribution_rebuild = 0;\n  self->ketama.weighted_ = false;\n\n  self->number_of_hosts = 0;\n  self->servers = NULL;\n  self->last_disconnected_server = NULL;\n\n  self->snd_timeout = 0;\n  self->rcv_timeout = 0;\n  self->server_failure_limit = MEMCACHED_SERVER_FAILURE_LIMIT;\n  self->server_timeout_limit = MEMCACHED_SERVER_TIMEOUT_LIMIT;\n  self->query_id = 1; // 0 is considered invalid\n\n  /* TODO, Document why we picked these defaults */\n  self->io_msg_watermark = 500;\n  self->io_bytes_watermark = 65 * 1024;\n\n  self->tcp_keepidle = 0;\n\n  self->io_key_prefetch = 0;\n  self->poll_timeout = MEMCACHED_DEFAULT_TIMEOUT;\n  self->connect_timeout = MEMCACHED_DEFAULT_CONNECT_TIMEOUT;\n  self->retry_timeout = MEMCACHED_SERVER_FAILURE_RETRY_TIMEOUT;\n  self->dead_timeout = MEMCACHED_SERVER_FAILURE_DEAD_TIMEOUT;\n\n  self->send_size = -1;\n  self->recv_size = -1;\n\n  self->user_data = NULL;\n  self->number_of_replicas = 0;\n\n  self->allocators = memcached_allocators_return_default();\n\n  self->on_clone = NULL;\n  self->on_cleanup = NULL;\n  self->get_key_failure = NULL;\n  self->delete_trigger = NULL;\n  self->callbacks = NULL;\n  self->sasl.callbacks = NULL;\n  self->sasl.is_allocated = false;\n\n  self->error_messages = NULL;\n  self->_namespace = NULL;\n  self->configure.initial_pool_size = 1;\n  self->configure.max_pool_size = 1;\n  self->configure.version = -1;\n  self->configure.filename = NULL;\n\n  return true;\n}"
  }
]