[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcat.cc",
    "lines": "64-120",
    "snippet": "int main(int argc, char *argv[]) {\n  client_options opt{PROGRAM_NAME, PROGRAM_VERSION, PROGRAM_DESCRIPTION, \"key [key ...]\"};\n\n  for (const auto &def : opt.defaults) {\n    opt.add(def);\n  }\n  opt.add(\"flags\", 'F', no_argument, \"Display key flags, too.\");\n  opt.add(\"file\", 'f', optional_argument, \"Output to file instead of standard output.\"\n                                          \"\\n\\t\\t# NOTE: defaults to <key> if no argument was provided.\");\n\n  char **argp = nullptr;\n  if (!opt.parse(argc, argv, &argp)) {\n    exit(EXIT_FAILURE);\n  }\n\n  if (opt.isset(\"quiet\") && !opt.isset(\"file\")) {\n    std::cerr << \"--quiet operation was requested, but --file was not set.\\n\";\n    exit(EXIT_FAILURE);\n  }\n\n  memcached_st memc;\n  if (!check_memcached(opt, memc)) {\n    exit(EXIT_FAILURE);\n  }\n\n  if (!opt.apply(&memc)) {\n    memcached_free(&memc);\n    exit(EXIT_FAILURE);\n  }\n\n  if (!check_argp(opt, argp, \"No key(s) provided.\")) {\n    memcached_free(&memc);\n    exit(EXIT_FAILURE);\n  }\n\n  auto file_flag = opt.isset(\"file\");\n  auto file = opt.argof(\"file\");\n  auto exit_code = EXIT_SUCCESS;\n  for (auto arg = argp; *arg; ++arg) {\n    auto key = *arg;\n    if (*key) {\n      if (!file && file_flag) {\n        file = key;\n      }\n\n      std::ofstream fstream{};\n      std::ostream *ostream = check_ostream(opt, file, fstream);\n\n      if (!check_return(opt, memc, key, memcat(opt, &memc, key, ostream))) {\n        exit_code = EXIT_FAILURE;\n      }\n    }\n  }\n\n  memcached_free(&memc);\n  exit(exit_code);\n}",
    "includes": [
      "#include <fstream>",
      "#include <iostream>",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [
      "#define PROGRAM_VERSION     \"1.1\"",
      "#define PROGRAM_DESCRIPTION \"Cat a set of key values to stdout.\"",
      "#define PROGRAM_NAME        \"memcat\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "exit_code"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_free",
          "args": [
            "&memc"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
          "lines": "257-261",
          "snippet": "void memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_return",
          "args": [
            "opt",
            "memc",
            "key",
            "memcat(opt, &memc, key, ostream)"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "check_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/checks.hpp",
          "lines": "73-90",
          "snippet": "bool check_return(const client_options &opt, memcached_st &memc, const char *key,\n                  memcached_return_t rc) {\n  if (!memcached_success(rc)) {\n    if (!opt.isset(\"quiet\")) {\n      if (MEMCACHED_NOTFOUND == rc) {\n        if (opt.isset(\"verbose\")) {\n          std::cerr << \"Could not find key '\" << key\n                    << \"': \" << memcached_strerror(&memc, rc) << \"\\n\";;\n        }\n      } else {\n        std::cerr << \"Fatal error for key '\" << key\n                  << \"': \" << memcached_last_error_message(&memc) << \"\\n\";\n      }\n    }\n    return false;\n  }\n  return true;\n}",
          "includes": [
            "#include <fstream>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include \"libmemcached/common.h\"",
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <cstring>\n#include <cerrno>\n#include \"libmemcached/common.h\"\n#include \"options.hpp\"\n\nbool check_return(const client_options &opt, memcached_st &memc, const char *key,\n                  memcached_return_t rc) {\n  if (!memcached_success(rc)) {\n    if (!opt.isset(\"quiet\")) {\n      if (MEMCACHED_NOTFOUND == rc) {\n        if (opt.isset(\"verbose\")) {\n          std::cerr << \"Could not find key '\" << key\n                    << \"': \" << memcached_strerror(&memc, rc) << \"\\n\";;\n        }\n      } else {\n        std::cerr << \"Fatal error for key '\" << key\n                  << \"': \" << memcached_last_error_message(&memc) << \"\\n\";\n      }\n    }\n    return false;\n  }\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcat",
          "args": [
            "opt",
            "&memc",
            "key",
            "ostream"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "memcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcat.cc",
          "lines": "28-62",
          "snippet": "memcached_return_t memcat(const client_options &opt, memcached_st *memc, const char *key, std::ostream *ref) {\n  memcached_return_t rc;\n  uint32_t flags;\n  size_t len;\n  auto val = memcached_get(memc, key, strlen(key), &len, &flags, &rc);\n  auto verbose = opt.isset(\"verbose\");\n\n  if (MEMCACHED_SUCCESS == rc) {\n    if (verbose) {\n      *ref << \"key: \" << key << \"\\n\";\n    }\n    if (opt.isset(\"flags\")) {\n      if (verbose) {\n      *ref << \"flags: \";\n      }\n      *ref << flags << \"\\n\";\n    }\n    if (verbose) {\n      *ref << \"value: \";\n    }\n\n    ref->write(val, len);\n\n    if (verbose || !opt.isset(\"file\")) {\n      *ref << std::endl;\n    }\n\n    ref->flush();\n  }\n\n  if (val) {\n    free(val);\n  }\n  return rc;\n}",
          "includes": [
            "#include <fstream>",
            "#include <iostream>",
            "#include \"common/checks.hpp\"",
            "#include \"common/options.hpp\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <iostream>\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nmemcached_return_t memcat(const client_options &opt, memcached_st *memc, const char *key, std::ostream *ref) {\n  memcached_return_t rc;\n  uint32_t flags;\n  size_t len;\n  auto val = memcached_get(memc, key, strlen(key), &len, &flags, &rc);\n  auto verbose = opt.isset(\"verbose\");\n\n  if (MEMCACHED_SUCCESS == rc) {\n    if (verbose) {\n      *ref << \"key: \" << key << \"\\n\";\n    }\n    if (opt.isset(\"flags\")) {\n      if (verbose) {\n      *ref << \"flags: \";\n      }\n      *ref << flags << \"\\n\";\n    }\n    if (verbose) {\n      *ref << \"value: \";\n    }\n\n    ref->write(val, len);\n\n    if (verbose || !opt.isset(\"file\")) {\n      *ref << std::endl;\n    }\n\n    ref->flush();\n  }\n\n  if (val) {\n    free(val);\n  }\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_ostream",
          "args": [
            "opt",
            "file",
            "fstream"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.argof",
          "args": [
            "\"file\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.isset",
          "args": [
            "\"file\""
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "isset",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "289-291",
          "snippet": "bool isset(int c) const {\n    return has(c) && get(c).set;\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool isset(int c) const {\n      return has(c) && get(c).set;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_argp",
          "args": [
            "opt",
            "argp",
            "\"No key(s) provided.\""
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "check_argp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/checks.hpp",
          "lines": "37-45",
          "snippet": "bool check_argp(const client_options &opt, char **argp, const char *error_msg) {\n  if (argp && *argp) {\n    return true;\n  }\n  if (!opt.isset(\"quiet\")) {\n    std::cerr << error_msg << \"\\n\";\n  }\n  return false;\n}",
          "includes": [
            "#include <fstream>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include \"libmemcached/common.h\"",
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <cstring>\n#include <cerrno>\n#include \"libmemcached/common.h\"\n#include \"options.hpp\"\n\nbool check_argp(const client_options &opt, char **argp, const char *error_msg) {\n  if (argp && *argp) {\n    return true;\n  }\n  if (!opt.isset(\"quiet\")) {\n    std::cerr << error_msg << \"\\n\";\n  }\n  return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.apply",
          "args": [
            "&memc"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "apply",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.cpp",
          "lines": "149-177",
          "snippet": "bool client_options::apply(memcached_st *memc) {\n#ifdef _WIN32\n  WSADATA wsaData;\n  if (WSAStartup(MAKEWORD(2, 2), &wsaData)) {\n    std::cerr << \"Socket Initialization Error.\\n\";\n    return false;\n  }\n#endif // _WIN32\n\n  extended_option *servers = nullptr;\n  for (auto &opt : options) {\n    if (opt.apply) {\n      // servers should be applied last, so they take up any behaviors previously set\n      if (opt.opt.val == 's' && opt.opt.name == std::string(\"servers\")) {\n        servers = &opt;\n        continue;\n      }\n      if (!opt.apply(*this, opt, memc)) {\n        return false;\n      }\n    }\n  }\n  if (servers) {\n    if (!servers->apply(*this, *servers, memc)) {\n      return false;\n    }\n  }\n  return true;\n}",
          "includes": [
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"options.hpp\"\n\nclient_options {\n  bool client_options::apply(memcached_st *memc) {\n  #ifdef _WIN32\n    WSADATA wsaData;\n    if (WSAStartup(MAKEWORD(2, 2), &wsaData)) {\n      std::cerr << \"Socket Initialization Error.\\n\";\n      return false;\n    }\n  #endif // _WIN32\n  \n    extended_option *servers = nullptr;\n    for (auto &opt : options) {\n      if (opt.apply) {\n        // servers should be applied last, so they take up any behaviors previously set\n        if (opt.opt.val == 's' && opt.opt.name == std::string(\"servers\")) {\n          servers = &opt;\n          continue;\n        }\n        if (!opt.apply(*this, opt, memc)) {\n          return false;\n        }\n      }\n    }\n    if (servers) {\n      if (!servers->apply(*this, *servers, memc)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_memcached",
          "args": [
            "opt",
            "memc"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "check_memcached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/checks.hpp",
          "lines": "47-55",
          "snippet": "bool check_memcached(const client_options &opt, memcached_st &memc) {\n  if (!memcached_create(&memc)) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failed to initialize memcached client.\\n\";\n    }\n    return false;\n  }\n  return true;\n}",
          "includes": [
            "#include <fstream>",
            "#include <cstring>",
            "#include <cerrno>",
            "#include \"libmemcached/common.h\"",
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fstream>\n#include <cstring>\n#include <cerrno>\n#include \"libmemcached/common.h\"\n#include \"options.hpp\"\n\nbool check_memcached(const client_options &opt, memcached_st &memc) {\n  if (!memcached_create(&memc)) {\n    if (!opt.isset(\"quiet\")) {\n      std::cerr << \"Failed to initialize memcached client.\\n\";\n    }\n    return false;\n  }\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.parse",
          "args": [
            "argc",
            "argv",
            "&argp"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.cpp",
          "lines": "88-147",
          "snippet": "bool client_options::parse(int argc, char **argv, char ***argp) {\n  /* extern */ optind = 1;\n  auto debug = has(\"debug\") ? &get(\"debug\") : nullptr;\n  std::string short_opts{};\n  std::vector<option> long_opts{};\n\n  short_opts.reserve(options.size() * 3);\n  long_opts.reserve(options.size() + 1);\n\n  for (const auto &ext : options) {\n    if (ext.opt.val) {\n      short_opts.push_back(ext.opt.val);\n      for (int i = 0; i < ext.opt.has_arg; ++i) {\n        short_opts.push_back(':');\n      }\n    }\n    if (ext.opt.name) {\n      long_opts.push_back(ext.opt);\n    }\n  }\n  long_opts.push_back({});\n\n  while (true) {\n    auto opt = getopt_long(argc, argv, short_opts.c_str(), long_opts.data(), nullptr);\n\n    if (debug->set && opt > 0) {\n      std::cerr << \"Processing option '\" << (char) opt << \"' (\" << opt << \")\\n\";\n    }\n    if (opt == '?') {\n      return false;\n    }\n    if (opt == -1) {\n      if (argp) {\n        *argp = &argv[optind];\n      }\n      return true;\n    }\n\n    auto &ext_opt = get(opt);\n\n    // grab optional argument\n    if (ext_opt.opt.has_arg == optional_argument && !optarg) {\n      auto next_arg = argv[optind];\n\n      if (next_arg && *next_arg && *next_arg != '-') {\n        optarg = next_arg;\n        ++optind;\n      }\n    }\n\n    ext_opt.set = true;\n    ext_opt.arg = optarg;\n\n    if (ext_opt.parse) {\n      if (!ext_opt.parse(*this, ext_opt)) {\n        return false;\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"options.hpp\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"options.hpp\"\n\nclient_options {\n  bool client_options::parse(int argc, char **argv, char ***argp) {\n    /* extern */ optind = 1;\n    auto debug = has(\"debug\") ? &get(\"debug\") : nullptr;\n    std::string short_opts{};\n    std::vector<option> long_opts{};\n  \n    short_opts.reserve(options.size() * 3);\n    long_opts.reserve(options.size() + 1);\n  \n    for (const auto &ext : options) {\n      if (ext.opt.val) {\n        short_opts.push_back(ext.opt.val);\n        for (int i = 0; i < ext.opt.has_arg; ++i) {\n          short_opts.push_back(':');\n        }\n      }\n      if (ext.opt.name) {\n        long_opts.push_back(ext.opt);\n      }\n    }\n    long_opts.push_back({});\n  \n    while (true) {\n      auto opt = getopt_long(argc, argv, short_opts.c_str(), long_opts.data(), nullptr);\n  \n      if (debug->set && opt > 0) {\n        std::cerr << \"Processing option '\" << (char) opt << \"' (\" << opt << \")\\n\";\n      }\n      if (opt == '?') {\n        return false;\n      }\n      if (opt == -1) {\n        if (argp) {\n          *argp = &argv[optind];\n        }\n        return true;\n      }\n  \n      auto &ext_opt = get(opt);\n  \n      // grab optional argument\n      if (ext_opt.opt.has_arg == optional_argument && !optarg) {\n        auto next_arg = argv[optind];\n  \n        if (next_arg && *next_arg && *next_arg != '-') {\n          optarg = next_arg;\n          ++optind;\n        }\n      }\n  \n      ext_opt.set = true;\n      ext_opt.arg = optarg;\n  \n      if (ext_opt.parse) {\n        if (!ext_opt.parse(*this, ext_opt)) {\n          return false;\n        }\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"file\"",
            "'f'",
            "optional_argument",
            "\"Output to file instead of standard output.\"\n                                          \"\\n\\t\\t# NOTE: defaults to <key> if no argument was provided.\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "\"flags\"",
            "'F'",
            "no_argument",
            "\"Display key flags, too.\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.add",
          "args": [
            "def"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fstream>\n#include <iostream>\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\n#define PROGRAM_VERSION     \"1.1\"\n#define PROGRAM_DESCRIPTION \"Cat a set of key values to stdout.\"\n#define PROGRAM_NAME        \"memcat\"\n\nint main(int argc, char *argv[]) {\n  client_options opt{PROGRAM_NAME, PROGRAM_VERSION, PROGRAM_DESCRIPTION, \"key [key ...]\"};\n\n  for (const auto &def : opt.defaults) {\n    opt.add(def);\n  }\n  opt.add(\"flags\", 'F', no_argument, \"Display key flags, too.\");\n  opt.add(\"file\", 'f', optional_argument, \"Output to file instead of standard output.\"\n                                          \"\\n\\t\\t# NOTE: defaults to <key> if no argument was provided.\");\n\n  char **argp = nullptr;\n  if (!opt.parse(argc, argv, &argp)) {\n    exit(EXIT_FAILURE);\n  }\n\n  if (opt.isset(\"quiet\") && !opt.isset(\"file\")) {\n    std::cerr << \"--quiet operation was requested, but --file was not set.\\n\";\n    exit(EXIT_FAILURE);\n  }\n\n  memcached_st memc;\n  if (!check_memcached(opt, memc)) {\n    exit(EXIT_FAILURE);\n  }\n\n  if (!opt.apply(&memc)) {\n    memcached_free(&memc);\n    exit(EXIT_FAILURE);\n  }\n\n  if (!check_argp(opt, argp, \"No key(s) provided.\")) {\n    memcached_free(&memc);\n    exit(EXIT_FAILURE);\n  }\n\n  auto file_flag = opt.isset(\"file\");\n  auto file = opt.argof(\"file\");\n  auto exit_code = EXIT_SUCCESS;\n  for (auto arg = argp; *arg; ++arg) {\n    auto key = *arg;\n    if (*key) {\n      if (!file && file_flag) {\n        file = key;\n      }\n\n      std::ofstream fstream{};\n      std::ostream *ostream = check_ostream(opt, file, fstream);\n\n      if (!check_return(opt, memc, key, memcat(opt, &memc, key, ostream))) {\n        exit_code = EXIT_FAILURE;\n      }\n    }\n  }\n\n  memcached_free(&memc);\n  exit(exit_code);\n}"
  },
  {
    "function_name": "memcat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/memcat.cc",
    "lines": "28-62",
    "snippet": "memcached_return_t memcat(const client_options &opt, memcached_st *memc, const char *key, std::ostream *ref) {\n  memcached_return_t rc;\n  uint32_t flags;\n  size_t len;\n  auto val = memcached_get(memc, key, strlen(key), &len, &flags, &rc);\n  auto verbose = opt.isset(\"verbose\");\n\n  if (MEMCACHED_SUCCESS == rc) {\n    if (verbose) {\n      *ref << \"key: \" << key << \"\\n\";\n    }\n    if (opt.isset(\"flags\")) {\n      if (verbose) {\n      *ref << \"flags: \";\n      }\n      *ref << flags << \"\\n\";\n    }\n    if (verbose) {\n      *ref << \"value: \";\n    }\n\n    ref->write(val, len);\n\n    if (verbose || !opt.isset(\"file\")) {\n      *ref << std::endl;\n    }\n\n    ref->flush();\n  }\n\n  if (val) {\n    free(val);\n  }\n  return rc;\n}",
    "includes": [
      "#include <fstream>",
      "#include <iostream>",
      "#include \"common/checks.hpp\"",
      "#include \"common/options.hpp\"",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "val"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "aes_free_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libhashkit/aes.cc",
          "lines": "286-290",
          "snippet": "void aes_free_key(aes_key_t *key) {\n  if (key) {\n    free(key);\n  }\n}",
          "includes": [
            "#  include \"libhashkit/rijndael.hpp\"",
            "#include <openssl/evp.h>",
            "#include <cstring>",
            "#include \"libhashkit/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"libhashkit/rijndael.hpp\"\n#include <openssl/evp.h>\n#include <cstring>\n#include \"libhashkit/common.h\"\n\nvoid aes_free_key(aes_key_t *key) {\n  if (key) {\n    free(key);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref->flush",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt.isset",
          "args": [
            "\"file\""
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "isset",
          "container": "client_options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/bin/common/options.hpp",
          "lines": "289-291",
          "snippet": "bool isset(int c) const {\n    return has(c) && get(c).set;\n  }",
          "includes": [
            "#include \"p9y/getopt.hpp\"",
            "#include \"libmemcached/common.h\"",
            "#include <vector>",
            "#include <string>",
            "#include <iostream>",
            "#include <functional>",
            "#include <climits>",
            "#include <cstdint>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/getopt.hpp\"\n#include \"libmemcached/common.h\"\n#include <vector>\n#include <string>\n#include <iostream>\n#include <functional>\n#include <climits>\n#include <cstdint>\n#include <algorithm>\n\nclient_options {\n  bool isset(int c) const {\n      return has(c) && get(c).set;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref->write",
          "args": [
            "val",
            "len"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_get",
          "args": [
            "memc",
            "key",
            "strlen(key)",
            "&len",
            "&flags",
            "&rc"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <fstream>\n#include <iostream>\n#include \"common/checks.hpp\"\n#include \"common/options.hpp\"\n#include \"mem_config.h\"\n\nmemcached_return_t memcat(const client_options &opt, memcached_st *memc, const char *key, std::ostream *ref) {\n  memcached_return_t rc;\n  uint32_t flags;\n  size_t len;\n  auto val = memcached_get(memc, key, strlen(key), &len, &flags, &rc);\n  auto verbose = opt.isset(\"verbose\");\n\n  if (MEMCACHED_SUCCESS == rc) {\n    if (verbose) {\n      *ref << \"key: \" << key << \"\\n\";\n    }\n    if (opt.isset(\"flags\")) {\n      if (verbose) {\n      *ref << \"flags: \";\n      }\n      *ref << flags << \"\\n\";\n    }\n    if (verbose) {\n      *ref << \"value: \";\n    }\n\n    ref->write(val, len);\n\n    if (verbose || !opt.isset(\"file\")) {\n      *ref << std::endl;\n    }\n\n    ref->flush();\n  }\n\n  if (val) {\n    free(val);\n  }\n  return rc;\n}"
  }
]