[
  {
    "function_name": "memcached_htonll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
    "lines": "55-61",
    "snippet": "uint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include \"libmemcached/byteorder.h\"",
      "#  include <arpa/inet.h>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap64",
          "args": [
            "value"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "swap64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "27-41",
          "snippet": "static inline uint64_t swap64(uint64_t in) {\n#    if !WORDS_BIGENDIAN\n  /* Little endian, flip the bytes around until someone makes a faster/better\n   * way to do this. */\n  uint64_t rv = 0;\n  for (uint8_t x = 0; x < 8; ++x) {\n    rv = (rv << 8) | (in & 0xff);\n    in >>= 8;\n  }\n  return rv;\n#    else\n  /* big-endian machines don't need byte swapping */\n  return in;\n#    endif // WORDS_BIGENDIAN\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nstatic inline uint64_t swap64(uint64_t in) {\n#    if !WORDS_BIGENDIAN\n  /* Little endian, flip the bytes around until someone makes a faster/better\n   * way to do this. */\n  uint64_t rv = 0;\n  for (uint8_t x = 0; x < 8; ++x) {\n    rv = (rv << 8) | (in & 0xff);\n    in >>= 8;\n  }\n  return rv;\n#    else\n  /* big-endian machines don't need byte swapping */\n  return in;\n#    endif // WORDS_BIGENDIAN\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonll",
          "args": [
            "value"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_htonll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "55-61",
          "snippet": "uint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}"
  },
  {
    "function_name": "memcached_ntohll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
    "lines": "47-53",
    "snippet": "uint64_t memcached_ntohll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return ntohll(value);\n#else\n  return swap64(value);\n#endif\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include \"libmemcached/byteorder.h\"",
      "#  include <arpa/inet.h>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap64",
          "args": [
            "value"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "swap64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "27-41",
          "snippet": "static inline uint64_t swap64(uint64_t in) {\n#    if !WORDS_BIGENDIAN\n  /* Little endian, flip the bytes around until someone makes a faster/better\n   * way to do this. */\n  uint64_t rv = 0;\n  for (uint8_t x = 0; x < 8; ++x) {\n    rv = (rv << 8) | (in & 0xff);\n    in >>= 8;\n  }\n  return rv;\n#    else\n  /* big-endian machines don't need byte swapping */\n  return in;\n#    endif // WORDS_BIGENDIAN\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nstatic inline uint64_t swap64(uint64_t in) {\n#    if !WORDS_BIGENDIAN\n  /* Little endian, flip the bytes around until someone makes a faster/better\n   * way to do this. */\n  uint64_t rv = 0;\n  for (uint8_t x = 0; x < 8; ++x) {\n    rv = (rv << 8) | (in & 0xff);\n    in >>= 8;\n  }\n  return rv;\n#    else\n  /* big-endian machines don't need byte swapping */\n  return in;\n#    endif // WORDS_BIGENDIAN\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohll",
          "args": [
            "value"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_ntohll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "47-53",
          "snippet": "uint64_t memcached_ntohll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return ntohll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_ntohll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return ntohll(value);\n#else\n  return swap64(value);\n#endif\n}"
  },
  {
    "function_name": "swap64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
    "lines": "27-41",
    "snippet": "static inline uint64_t swap64(uint64_t in) {\n#    if !WORDS_BIGENDIAN\n  /* Little endian, flip the bytes around until someone makes a faster/better\n   * way to do this. */\n  uint64_t rv = 0;\n  for (uint8_t x = 0; x < 8; ++x) {\n    rv = (rv << 8) | (in & 0xff);\n    in >>= 8;\n  }\n  return rv;\n#    else\n  /* big-endian machines don't need byte swapping */\n  return in;\n#    endif // WORDS_BIGENDIAN\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include \"libmemcached/byteorder.h\"",
      "#  include <arpa/inet.h>",
      "#include \"mem_config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nstatic inline uint64_t swap64(uint64_t in) {\n#    if !WORDS_BIGENDIAN\n  /* Little endian, flip the bytes around until someone makes a faster/better\n   * way to do this. */\n  uint64_t rv = 0;\n  for (uint8_t x = 0; x < 8; ++x) {\n    rv = (rv << 8) | (in & 0xff);\n    in >>= 8;\n  }\n  return rv;\n#    else\n  /* big-endian machines don't need byte swapping */\n  return in;\n#    endif // WORDS_BIGENDIAN\n}"
  }
]