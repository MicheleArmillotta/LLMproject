[
  {
    "function_name": "memcached_stat_execute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/stats.cc",
    "lines": "616-626",
    "snippet": "memcached_return_t memcached_stat_execute(memcached_st *shell, const char *args,\n                                          memcached_stat_fn func, void *context) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memcached_fatal(memcached_version(memc))) {\n    return memcached_last_error(memc);\n  }\n\n  local_context check(func, context, args, args ? strlen(args) : 0);\n\n  return memcached_server_execute(memc, call_stat_fn, (void *) &check);\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_server_execute",
          "args": [
            "memc",
            "call_stat_fn",
            "(void *) &check"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/instance.cc",
          "lines": "173-194",
          "snippet": "memcached_return_t memcached_server_execute(memcached_st *memc,\n                                            memcached_server_execute_fn callback, void *context) {\n  if (callback == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  bool some_errors = false;\n  ;\n  for (uint32_t x = 0; x < memcached_instance_list_count(memc); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(memc, x);\n\n    memcached_return_t rc = (*callback)(memc, instance, context);\n    if (rc == MEMCACHED_INVALID_ARGUMENTS) {\n      return rc;\n    } else if (memcached_fatal(rc)) {\n      some_errors = true;\n    }\n  }\n\n  (void) some_errors;\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_server_execute(memcached_st *memc,\n                                            memcached_server_execute_fn callback, void *context) {\n  if (callback == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  bool some_errors = false;\n  ;\n  for (uint32_t x = 0; x < memcached_instance_list_count(memc); x++) {\n    memcached_instance_st *instance = memcached_instance_fetch(memc, x);\n\n    memcached_return_t rc = (*callback)(memc, instance, context);\n    if (rc == MEMCACHED_INVALID_ARGUMENTS) {\n      return rc;\n    } else if (memcached_fatal(rc)) {\n      some_errors = true;\n    }\n  }\n\n  (void) some_errors;\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "args"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_last_error",
          "args": [
            "memc"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_last_error_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "500-511",
          "snippet": "int memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nint memcached_last_error_errno(const memcached_st *shell) {\n  const Memcached *memc = memcached2Memcached(shell);\n  if (memc == NULL) {\n    return 0;\n  }\n\n  if (memc->error_messages == NULL) {\n    return 0;\n  }\n\n  return memc->error_messages->local_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_fatal",
          "args": [
            "memcached_version(memc)"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_version",
          "args": [
            "memc"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/version.cc",
          "lines": "164-184",
          "snippet": "memcached_return_t memcached_version(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    memcached_return_t rc;\n    if (memcached_failed(rc = initialize_query(memc, true))) {\n      return rc;\n    }\n\n    if (memcached_is_udp(memc)) {\n      return MEMCACHED_NOT_SUPPORTED;\n    }\n\n    if (memcached_is_binary(memc)) {\n      return memcached_version_binary(memc);\n    }\n\n    return memcached_version_textual(memc);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_version(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    memcached_return_t rc;\n    if (memcached_failed(rc = initialize_query(memc, true))) {\n      return rc;\n    }\n\n    if (memcached_is_udp(memc)) {\n      return MEMCACHED_NOT_SUPPORTED;\n    }\n\n    if (memcached_is_binary(memc)) {\n      return memcached_version_binary(memc);\n    }\n\n    return memcached_version_textual(memc);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached2Memcached",
          "args": [
            "shell"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_stat_execute(memcached_st *shell, const char *args,\n                                          memcached_stat_fn func, void *context) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memcached_fatal(memcached_version(memc))) {\n    return memcached_last_error(memc);\n  }\n\n  local_context check(func, context, args, args ? strlen(args) : 0);\n\n  return memcached_server_execute(memc, call_stat_fn, (void *) &check);\n}"
  },
  {
    "function_name": "call_stat_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/stats.cc",
    "lines": "601-614",
    "snippet": "static memcached_return_t call_stat_fn(memcached_st *memc, memcached_instance_st *instance,\n                                       void *context) {\n  if (memc) {\n    local_context *check = (struct local_context *) context;\n\n    if (memcached_is_binary(memc)) {\n      return binary_stats_fetch(NULL, check->args, check->args_length, instance, check);\n    } else {\n      return ascii_stats_fetch(NULL, check->args, check->args_length, instance, check);\n    }\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ascii_stats_fetch",
          "args": [
            "NULL",
            "check->args",
            "check->args_length",
            "instance",
            "check"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_stats_fetch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/stats.cc",
          "lines": "398-451",
          "snippet": "static memcached_return_t ascii_stats_fetch(memcached_stat_st *memc_stat, const char *args,\n                                            const size_t args_length,\n                                            memcached_instance_st *instance,\n                                            struct local_context *check) {\n  libmemcached_io_vector_st vector[] = {\n      {memcached_literal_param(\"stats \")}, {args, args_length}, {memcached_literal_param(\"\\r\\n\")}};\n\n  memcached_return_t rc = memcached_vdo(instance, vector, 3, true);\n  if (memcached_success(rc)) {\n    char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n    while ((rc = memcached_response(instance, buffer, sizeof(buffer), NULL)) == MEMCACHED_STAT) {\n      char *string_ptr = buffer;\n      string_ptr += 5; /* Move past STAT */\n\n      char *end_ptr;\n      for (end_ptr = string_ptr; isgraph(*end_ptr); end_ptr++) {\n      };\n      char *key = string_ptr;\n      key[size_t(end_ptr - string_ptr)] = 0;\n\n      string_ptr = end_ptr + 1;\n      for (end_ptr = string_ptr; !(isspace(*end_ptr)); end_ptr++) {\n      };\n      char *value = string_ptr;\n      value[(size_t)(end_ptr - string_ptr)] = 0;\n#if 0\n      bool check_bool= bool(check);\n      bool check_func_bool= bool(check) ? bool(check->func) : false;\n      fprintf(stderr, \"%s:%d %s %s %d:%d\\n\", __FILE__, __LINE__, key, value, check_bool, check_func_bool);\n#endif\n\n      if (check and check->func) {\n        check->func(instance, key, strlen(key), value, strlen(value), check->context);\n      }\n\n      if (memc_stat) {\n        if ((set_data(memc_stat, key, value)) == MEMCACHED_UNKNOWN_STAT_KEY) {\n          WATCHPOINT_ERROR(MEMCACHED_UNKNOWN_STAT_KEY);\n          WATCHPOINT_ASSERT(0);\n        }\n      }\n    }\n  }\n\n  if (rc == MEMCACHED_ERROR) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (rc == MEMCACHED_END) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t ascii_stats_fetch(memcached_stat_st *memc_stat, const char *args,\n                                            const size_t args_length,\n                                            memcached_instance_st *instance,\n                                            struct local_context *check) {\n  libmemcached_io_vector_st vector[] = {\n      {memcached_literal_param(\"stats \")}, {args, args_length}, {memcached_literal_param(\"\\r\\n\")}};\n\n  memcached_return_t rc = memcached_vdo(instance, vector, 3, true);\n  if (memcached_success(rc)) {\n    char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n    while ((rc = memcached_response(instance, buffer, sizeof(buffer), NULL)) == MEMCACHED_STAT) {\n      char *string_ptr = buffer;\n      string_ptr += 5; /* Move past STAT */\n\n      char *end_ptr;\n      for (end_ptr = string_ptr; isgraph(*end_ptr); end_ptr++) {\n      };\n      char *key = string_ptr;\n      key[size_t(end_ptr - string_ptr)] = 0;\n\n      string_ptr = end_ptr + 1;\n      for (end_ptr = string_ptr; !(isspace(*end_ptr)); end_ptr++) {\n      };\n      char *value = string_ptr;\n      value[(size_t)(end_ptr - string_ptr)] = 0;\n#if 0\n      bool check_bool= bool(check);\n      bool check_func_bool= bool(check) ? bool(check->func) : false;\n      fprintf(stderr, \"%s:%d %s %s %d:%d\\n\", __FILE__, __LINE__, key, value, check_bool, check_func_bool);\n#endif\n\n      if (check and check->func) {\n        check->func(instance, key, strlen(key), value, strlen(value), check->context);\n      }\n\n      if (memc_stat) {\n        if ((set_data(memc_stat, key, value)) == MEMCACHED_UNKNOWN_STAT_KEY) {\n          WATCHPOINT_ERROR(MEMCACHED_UNKNOWN_STAT_KEY);\n          WATCHPOINT_ASSERT(0);\n        }\n      }\n    }\n  }\n\n  if (rc == MEMCACHED_ERROR) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (rc == MEMCACHED_END) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "binary_stats_fetch",
          "args": [
            "NULL",
            "check->args",
            "check->args_length",
            "instance",
            "check"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "binary_stats_fetch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/stats.cc",
          "lines": "330-396",
          "snippet": "static memcached_return_t binary_stats_fetch(memcached_stat_st *memc_stat, const char *args,\n                                             const size_t args_length,\n                                             memcached_instance_st *instance,\n                                             struct local_context *check) {\n  char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n  protocol_binary_request_stats request = {}; // = {.bytes= {0}};\n  memcached_return_t rc;\n\n  initialize_binary_request(instance, request.message.header);\n\n  request.message.header.request.opcode = PROTOCOL_BINARY_CMD_STAT;\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n\n  if (args_length) {\n    request.message.header.request.keylen = htons(uint16_t(args_length));\n    request.message.header.request.bodylen = htonl(uint32_t(args_length));\n\n    libmemcached_io_vector_st vector[] = {{request.bytes, sizeof(request.bytes)},\n                                          {args, args_length}};\n\n    if (memcached_failed(rc = memcached_vdo(instance, vector, 2, true))) {\n      return rc;\n    }\n  } else {\n    libmemcached_io_vector_st vector[] = {{request.bytes, sizeof(request.bytes)}};\n\n    if (memcached_failed(rc = memcached_vdo(instance, vector, 1, true))) {\n      return rc;\n    }\n  }\n\n  memcached_server_response_decrement(instance);\n  while (1) {\n    rc = memcached_response(instance, buffer, sizeof(buffer), NULL);\n\n    if (rc == MEMCACHED_END) {\n      break;\n    }\n\n    if (rc != MEMCACHED_SUCCESS) {\n      return rc;\n    }\n\n    if (check && check->func) {\n      size_t key_length = strlen(buffer);\n\n      check->func(instance, buffer, key_length, buffer + key_length + 1,\n                  strlen(buffer + key_length + 1), check->context);\n    }\n\n    if (memc_stat) {\n      if ((set_data(memc_stat, buffer, buffer + strlen(buffer) + 1)) == MEMCACHED_UNKNOWN_STAT_KEY)\n      {\n        WATCHPOINT_ERROR(MEMCACHED_UNKNOWN_STAT_KEY);\n        WATCHPOINT_ASSERT(0);\n      }\n    }\n  }\n\n  /*\n   * memcached_response will decrement the counter, so I need to reset it..\n   * todo: look at this and try to find a better solution.\n   * */\n  instance->cursor_active_ = 0;\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t binary_stats_fetch(memcached_stat_st *memc_stat, const char *args,\n                                             const size_t args_length,\n                                             memcached_instance_st *instance,\n                                             struct local_context *check) {\n  char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n  protocol_binary_request_stats request = {}; // = {.bytes= {0}};\n  memcached_return_t rc;\n\n  initialize_binary_request(instance, request.message.header);\n\n  request.message.header.request.opcode = PROTOCOL_BINARY_CMD_STAT;\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n\n  if (args_length) {\n    request.message.header.request.keylen = htons(uint16_t(args_length));\n    request.message.header.request.bodylen = htonl(uint32_t(args_length));\n\n    libmemcached_io_vector_st vector[] = {{request.bytes, sizeof(request.bytes)},\n                                          {args, args_length}};\n\n    if (memcached_failed(rc = memcached_vdo(instance, vector, 2, true))) {\n      return rc;\n    }\n  } else {\n    libmemcached_io_vector_st vector[] = {{request.bytes, sizeof(request.bytes)}};\n\n    if (memcached_failed(rc = memcached_vdo(instance, vector, 1, true))) {\n      return rc;\n    }\n  }\n\n  memcached_server_response_decrement(instance);\n  while (1) {\n    rc = memcached_response(instance, buffer, sizeof(buffer), NULL);\n\n    if (rc == MEMCACHED_END) {\n      break;\n    }\n\n    if (rc != MEMCACHED_SUCCESS) {\n      return rc;\n    }\n\n    if (check && check->func) {\n      size_t key_length = strlen(buffer);\n\n      check->func(instance, buffer, key_length, buffer + key_length + 1,\n                  strlen(buffer + key_length + 1), check->context);\n    }\n\n    if (memc_stat) {\n      if ((set_data(memc_stat, buffer, buffer + strlen(buffer) + 1)) == MEMCACHED_UNKNOWN_STAT_KEY)\n      {\n        WATCHPOINT_ERROR(MEMCACHED_UNKNOWN_STAT_KEY);\n        WATCHPOINT_ASSERT(0);\n      }\n    }\n  }\n\n  /*\n   * memcached_response will decrement the counter, so I need to reset it..\n   * todo: look at this and try to find a better solution.\n   * */\n  instance->cursor_active_ = 0;\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_is_binary",
          "args": [
            "memc"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t call_stat_fn(memcached_st *memc, memcached_instance_st *instance,\n                                       void *context) {\n  if (memc) {\n    local_context *check = (struct local_context *) context;\n\n    if (memcached_is_binary(memc)) {\n      return binary_stats_fetch(NULL, check->args, check->args_length, instance, check);\n    } else {\n      return ascii_stats_fetch(NULL, check->args, check->args_length, instance, check);\n    }\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
  },
  {
    "function_name": "memcached_stat_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/stats.cc",
    "lines": "594-599",
    "snippet": "void memcached_stat_free(const memcached_st *, memcached_stat_st *memc_stat) {\n  WATCHPOINT_ASSERT(memc_stat); // Be polite, but when debugging catch this as an error\n  if (memc_stat) {\n    libmemcached_free(memc_stat->root, memc_stat);\n  }\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libmemcached_free",
          "args": [
            "memc_stat->root",
            "memc_stat"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "libmemcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memory.h",
          "lines": "30-40",
          "snippet": "static inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#  include <stddef.h>",
            "#  include <cstdlib>",
            "#  include <cstddef>",
            "#include \"libmemcached/common.h\"",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#  include <stddef.h>\n#  include <cstdlib>\n#  include <cstddef>\n#include \"libmemcached/common.h\"\n#include \"mem_config.h\"\n\nstatic inline void libmemcached_free(const memcached_st *self, void *mem) {\n  if (self) {\n    self->allocators.free(self, mem, self->allocators.context);\n  } else if (mem) {\n#ifdef __cplusplus\n    std::free(mem);\n#else\n    free(mem);\n#endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "memc_stat"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nvoid memcached_stat_free(const memcached_st *, memcached_stat_st *memc_stat) {\n  WATCHPOINT_ASSERT(memc_stat); // Be polite, but when debugging catch this as an error\n  if (memc_stat) {\n    libmemcached_free(memc_stat->root, memc_stat);\n  }\n}"
  },
  {
    "function_name": "memcached_stat_servername",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/stats.cc",
    "lines": "521-563",
    "snippet": "memcached_return_t memcached_stat_servername(memcached_stat_st *memc_stat, char *args,\n                                             const char *hostname, in_port_t port) {\n  memcached_st memc;\n\n  memcached_stat_st unused_memc_stat;\n  if (memc_stat == NULL) {\n    memc_stat = &unused_memc_stat;\n  }\n\n  memset(memc_stat, 0, sizeof(memcached_stat_st));\n\n  memcached_st *memc_ptr = memcached_create(&memc);\n  if (memc_ptr == NULL) {\n    return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n  }\n\n  memcached_return_t rc;\n  if (memcached_failed(rc = memcached_server_add(&memc, hostname, port))) {\n    memcached_free(&memc);\n    return rc;\n  }\n\n  if (memcached_success(rc = initialize_query(memc_ptr, true))) {\n    size_t args_length = 0;\n    if (args) {\n      args_length = strlen(args);\n      rc = memcached_key_test(*memc_ptr, (const char **) &args, &args_length, 1);\n    }\n\n    if (memcached_success(rc)) {\n      memcached_instance_st *instance = memcached_instance_fetch(memc_ptr, 0);\n      if (memc.flags.binary_protocol) {\n        rc = binary_stats_fetch(memc_stat, args, args_length, instance, NULL);\n      } else {\n        rc = ascii_stats_fetch(memc_stat, args, args_length, instance, NULL);\n      }\n    }\n  }\n\n  memcached_free(&memc);\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_free",
          "args": [
            "&memc"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
          "lines": "257-261",
          "snippet": "void memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ascii_stats_fetch",
          "args": [
            "memc_stat",
            "args",
            "args_length",
            "instance",
            "NULL"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "ascii_stats_fetch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/stats.cc",
          "lines": "398-451",
          "snippet": "static memcached_return_t ascii_stats_fetch(memcached_stat_st *memc_stat, const char *args,\n                                            const size_t args_length,\n                                            memcached_instance_st *instance,\n                                            struct local_context *check) {\n  libmemcached_io_vector_st vector[] = {\n      {memcached_literal_param(\"stats \")}, {args, args_length}, {memcached_literal_param(\"\\r\\n\")}};\n\n  memcached_return_t rc = memcached_vdo(instance, vector, 3, true);\n  if (memcached_success(rc)) {\n    char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n    while ((rc = memcached_response(instance, buffer, sizeof(buffer), NULL)) == MEMCACHED_STAT) {\n      char *string_ptr = buffer;\n      string_ptr += 5; /* Move past STAT */\n\n      char *end_ptr;\n      for (end_ptr = string_ptr; isgraph(*end_ptr); end_ptr++) {\n      };\n      char *key = string_ptr;\n      key[size_t(end_ptr - string_ptr)] = 0;\n\n      string_ptr = end_ptr + 1;\n      for (end_ptr = string_ptr; !(isspace(*end_ptr)); end_ptr++) {\n      };\n      char *value = string_ptr;\n      value[(size_t)(end_ptr - string_ptr)] = 0;\n#if 0\n      bool check_bool= bool(check);\n      bool check_func_bool= bool(check) ? bool(check->func) : false;\n      fprintf(stderr, \"%s:%d %s %s %d:%d\\n\", __FILE__, __LINE__, key, value, check_bool, check_func_bool);\n#endif\n\n      if (check and check->func) {\n        check->func(instance, key, strlen(key), value, strlen(value), check->context);\n      }\n\n      if (memc_stat) {\n        if ((set_data(memc_stat, key, value)) == MEMCACHED_UNKNOWN_STAT_KEY) {\n          WATCHPOINT_ERROR(MEMCACHED_UNKNOWN_STAT_KEY);\n          WATCHPOINT_ASSERT(0);\n        }\n      }\n    }\n  }\n\n  if (rc == MEMCACHED_ERROR) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (rc == MEMCACHED_END) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t ascii_stats_fetch(memcached_stat_st *memc_stat, const char *args,\n                                            const size_t args_length,\n                                            memcached_instance_st *instance,\n                                            struct local_context *check) {\n  libmemcached_io_vector_st vector[] = {\n      {memcached_literal_param(\"stats \")}, {args, args_length}, {memcached_literal_param(\"\\r\\n\")}};\n\n  memcached_return_t rc = memcached_vdo(instance, vector, 3, true);\n  if (memcached_success(rc)) {\n    char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n    while ((rc = memcached_response(instance, buffer, sizeof(buffer), NULL)) == MEMCACHED_STAT) {\n      char *string_ptr = buffer;\n      string_ptr += 5; /* Move past STAT */\n\n      char *end_ptr;\n      for (end_ptr = string_ptr; isgraph(*end_ptr); end_ptr++) {\n      };\n      char *key = string_ptr;\n      key[size_t(end_ptr - string_ptr)] = 0;\n\n      string_ptr = end_ptr + 1;\n      for (end_ptr = string_ptr; !(isspace(*end_ptr)); end_ptr++) {\n      };\n      char *value = string_ptr;\n      value[(size_t)(end_ptr - string_ptr)] = 0;\n#if 0\n      bool check_bool= bool(check);\n      bool check_func_bool= bool(check) ? bool(check->func) : false;\n      fprintf(stderr, \"%s:%d %s %s %d:%d\\n\", __FILE__, __LINE__, key, value, check_bool, check_func_bool);\n#endif\n\n      if (check and check->func) {\n        check->func(instance, key, strlen(key), value, strlen(value), check->context);\n      }\n\n      if (memc_stat) {\n        if ((set_data(memc_stat, key, value)) == MEMCACHED_UNKNOWN_STAT_KEY) {\n          WATCHPOINT_ERROR(MEMCACHED_UNKNOWN_STAT_KEY);\n          WATCHPOINT_ASSERT(0);\n        }\n      }\n    }\n  }\n\n  if (rc == MEMCACHED_ERROR) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (rc == MEMCACHED_END) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "binary_stats_fetch",
          "args": [
            "memc_stat",
            "args",
            "args_length",
            "instance",
            "NULL"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "binary_stats_fetch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/stats.cc",
          "lines": "330-396",
          "snippet": "static memcached_return_t binary_stats_fetch(memcached_stat_st *memc_stat, const char *args,\n                                             const size_t args_length,\n                                             memcached_instance_st *instance,\n                                             struct local_context *check) {\n  char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n  protocol_binary_request_stats request = {}; // = {.bytes= {0}};\n  memcached_return_t rc;\n\n  initialize_binary_request(instance, request.message.header);\n\n  request.message.header.request.opcode = PROTOCOL_BINARY_CMD_STAT;\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n\n  if (args_length) {\n    request.message.header.request.keylen = htons(uint16_t(args_length));\n    request.message.header.request.bodylen = htonl(uint32_t(args_length));\n\n    libmemcached_io_vector_st vector[] = {{request.bytes, sizeof(request.bytes)},\n                                          {args, args_length}};\n\n    if (memcached_failed(rc = memcached_vdo(instance, vector, 2, true))) {\n      return rc;\n    }\n  } else {\n    libmemcached_io_vector_st vector[] = {{request.bytes, sizeof(request.bytes)}};\n\n    if (memcached_failed(rc = memcached_vdo(instance, vector, 1, true))) {\n      return rc;\n    }\n  }\n\n  memcached_server_response_decrement(instance);\n  while (1) {\n    rc = memcached_response(instance, buffer, sizeof(buffer), NULL);\n\n    if (rc == MEMCACHED_END) {\n      break;\n    }\n\n    if (rc != MEMCACHED_SUCCESS) {\n      return rc;\n    }\n\n    if (check && check->func) {\n      size_t key_length = strlen(buffer);\n\n      check->func(instance, buffer, key_length, buffer + key_length + 1,\n                  strlen(buffer + key_length + 1), check->context);\n    }\n\n    if (memc_stat) {\n      if ((set_data(memc_stat, buffer, buffer + strlen(buffer) + 1)) == MEMCACHED_UNKNOWN_STAT_KEY)\n      {\n        WATCHPOINT_ERROR(MEMCACHED_UNKNOWN_STAT_KEY);\n        WATCHPOINT_ASSERT(0);\n      }\n    }\n  }\n\n  /*\n   * memcached_response will decrement the counter, so I need to reset it..\n   * todo: look at this and try to find a better solution.\n   * */\n  instance->cursor_active_ = 0;\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t binary_stats_fetch(memcached_stat_st *memc_stat, const char *args,\n                                             const size_t args_length,\n                                             memcached_instance_st *instance,\n                                             struct local_context *check) {\n  char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n  protocol_binary_request_stats request = {}; // = {.bytes= {0}};\n  memcached_return_t rc;\n\n  initialize_binary_request(instance, request.message.header);\n\n  request.message.header.request.opcode = PROTOCOL_BINARY_CMD_STAT;\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n\n  if (args_length) {\n    request.message.header.request.keylen = htons(uint16_t(args_length));\n    request.message.header.request.bodylen = htonl(uint32_t(args_length));\n\n    libmemcached_io_vector_st vector[] = {{request.bytes, sizeof(request.bytes)},\n                                          {args, args_length}};\n\n    if (memcached_failed(rc = memcached_vdo(instance, vector, 2, true))) {\n      return rc;\n    }\n  } else {\n    libmemcached_io_vector_st vector[] = {{request.bytes, sizeof(request.bytes)}};\n\n    if (memcached_failed(rc = memcached_vdo(instance, vector, 1, true))) {\n      return rc;\n    }\n  }\n\n  memcached_server_response_decrement(instance);\n  while (1) {\n    rc = memcached_response(instance, buffer, sizeof(buffer), NULL);\n\n    if (rc == MEMCACHED_END) {\n      break;\n    }\n\n    if (rc != MEMCACHED_SUCCESS) {\n      return rc;\n    }\n\n    if (check && check->func) {\n      size_t key_length = strlen(buffer);\n\n      check->func(instance, buffer, key_length, buffer + key_length + 1,\n                  strlen(buffer + key_length + 1), check->context);\n    }\n\n    if (memc_stat) {\n      if ((set_data(memc_stat, buffer, buffer + strlen(buffer) + 1)) == MEMCACHED_UNKNOWN_STAT_KEY)\n      {\n        WATCHPOINT_ERROR(MEMCACHED_UNKNOWN_STAT_KEY);\n        WATCHPOINT_ASSERT(0);\n      }\n    }\n  }\n\n  /*\n   * memcached_response will decrement the counter, so I need to reset it..\n   * todo: look at this and try to find a better solution.\n   * */\n  instance->cursor_active_ = 0;\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_instance_fetch",
          "args": [
            "memc_ptr",
            "0"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_key_test",
          "args": [
            "*memc_ptr",
            "(const char **) &args",
            "&args_length",
            "1"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_key_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/key.cc",
          "lines": "43-81",
          "snippet": "memcached_return_t memcached_key_test(memcached_st &memc, const char *const *keys,\n                                      const size_t *key_length, size_t number_of_keys) {\n  if (number_of_keys == 0) {\n    return memcached_set_error(memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Numbers of keys provided was zero\"));\n  }\n\n  if (keys == NULL or key_length == NULL) {\n    return memcached_set_error(memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n                               memcached_literal_param(\"Key was NULL or length of key was zero.\"));\n  }\n\n  const bool is_binary = memcached_flag(memc, MEMCACHED_FLAG_BINARY_PROTOCOL);\n\n  // If we don't need to verify the key, or we are using the binary protoocol,\n  // we just check the size of the key\n  for (size_t x = 0; x < number_of_keys; ++x) {\n    // We should set binary key, but the memcached server is broken for\n    // longer keys at the moment.\n    memcached_return_t rc =\n        memcached_validate_key_length(*(key_length + x), false /* memc.flags.binary_protocol */);\n    if (memcached_failed(rc)) {\n      return memcached_set_error(memc, rc, MEMCACHED_AT,\n                                 memcached_literal_param(\"Key provided was too long.\"));\n    }\n\n    if (memc.flags.verify_key and is_binary == false) {\n      for (size_t y = 0; y < *(key_length + x); ++y) {\n        if ((isgraph(keys[x][y])) == 0) {\n          return memcached_set_error(\n              memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n              memcached_literal_param(\"Key provided had invalid character.\"));\n        }\n      }\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_key_test(memcached_st &memc, const char *const *keys,\n                                      const size_t *key_length, size_t number_of_keys) {\n  if (number_of_keys == 0) {\n    return memcached_set_error(memc, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n                               memcached_literal_param(\"Numbers of keys provided was zero\"));\n  }\n\n  if (keys == NULL or key_length == NULL) {\n    return memcached_set_error(memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n                               memcached_literal_param(\"Key was NULL or length of key was zero.\"));\n  }\n\n  const bool is_binary = memcached_flag(memc, MEMCACHED_FLAG_BINARY_PROTOCOL);\n\n  // If we don't need to verify the key, or we are using the binary protoocol,\n  // we just check the size of the key\n  for (size_t x = 0; x < number_of_keys; ++x) {\n    // We should set binary key, but the memcached server is broken for\n    // longer keys at the moment.\n    memcached_return_t rc =\n        memcached_validate_key_length(*(key_length + x), false /* memc.flags.binary_protocol */);\n    if (memcached_failed(rc)) {\n      return memcached_set_error(memc, rc, MEMCACHED_AT,\n                                 memcached_literal_param(\"Key provided was too long.\"));\n    }\n\n    if (memc.flags.verify_key and is_binary == false) {\n      for (size_t y = 0; y < *(key_length + x); ++y) {\n        if ((isgraph(keys[x][y])) == 0) {\n          return memcached_set_error(\n              memc, MEMCACHED_BAD_KEY_PROVIDED, MEMCACHED_AT,\n              memcached_literal_param(\"Key provided had invalid character.\"));\n        }\n      }\n    }\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "args"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc = initialize_query(memc_ptr, true)"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_query",
          "args": [
            "memc_ptr",
            "true"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/initialize_query.cc",
          "lines": "18-39",
          "snippet": "memcached_return_t initialize_query(Memcached *self, bool increment_query_id) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (increment_query_id) {\n    self->query_id++;\n  }\n\n  if (self->state.is_time_for_rebuild) {\n    memcached_reset(self);\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return memcached_set_error(*self, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  memcached_error_free(*self);\n  memcached_result_reset(&self->result);\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t initialize_query(Memcached *self, bool increment_query_id) {\n  if (self == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (increment_query_id) {\n    self->query_id++;\n  }\n\n  if (self->state.is_time_for_rebuild) {\n    memcached_reset(self);\n  }\n\n  if (memcached_server_count(self) == 0) {\n    return memcached_set_error(*self, MEMCACHED_NO_SERVERS, MEMCACHED_AT);\n  }\n\n  memcached_error_free(*self);\n  memcached_result_reset(&self->result);\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = memcached_server_add(&memc, hostname, port)"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_add",
          "args": [
            "&memc",
            "hostname",
            "port"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "458-460",
          "snippet": "memcached_return_t memcached_server_add(memcached_st *shell, const char *hostname, in_port_t port) {\n  return memcached_server_add_with_weight(shell, hostname, port, 0);\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_server_add(memcached_st *shell, const char *hostname, in_port_t port) {\n  return memcached_server_add_with_weight(shell, hostname, port, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_create",
          "args": [
            "&memc"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "memc_stat",
            "0",
            "sizeof(memcached_stat_st)"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_stat_servername(memcached_stat_st *memc_stat, char *args,\n                                             const char *hostname, in_port_t port) {\n  memcached_st memc;\n\n  memcached_stat_st unused_memc_stat;\n  if (memc_stat == NULL) {\n    memc_stat = &unused_memc_stat;\n  }\n\n  memset(memc_stat, 0, sizeof(memcached_stat_st));\n\n  memcached_st *memc_ptr = memcached_create(&memc);\n  if (memc_ptr == NULL) {\n    return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n  }\n\n  memcached_return_t rc;\n  if (memcached_failed(rc = memcached_server_add(&memc, hostname, port))) {\n    memcached_free(&memc);\n    return rc;\n  }\n\n  if (memcached_success(rc = initialize_query(memc_ptr, true))) {\n    size_t args_length = 0;\n    if (args) {\n      args_length = strlen(args);\n      rc = memcached_key_test(*memc_ptr, (const char **) &args, &args_length, 1);\n    }\n\n    if (memcached_success(rc)) {\n      memcached_instance_st *instance = memcached_instance_fetch(memc_ptr, 0);\n      if (memc.flags.binary_protocol) {\n        rc = binary_stats_fetch(memc_stat, args, args_length, instance, NULL);\n      } else {\n        rc = ascii_stats_fetch(memc_stat, args, args_length, instance, NULL);\n      }\n    }\n  }\n\n  memcached_free(&memc);\n\n  return rc;\n}"
  },
  {
    "function_name": "ascii_stats_fetch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/stats.cc",
    "lines": "398-451",
    "snippet": "static memcached_return_t ascii_stats_fetch(memcached_stat_st *memc_stat, const char *args,\n                                            const size_t args_length,\n                                            memcached_instance_st *instance,\n                                            struct local_context *check) {\n  libmemcached_io_vector_st vector[] = {\n      {memcached_literal_param(\"stats \")}, {args, args_length}, {memcached_literal_param(\"\\r\\n\")}};\n\n  memcached_return_t rc = memcached_vdo(instance, vector, 3, true);\n  if (memcached_success(rc)) {\n    char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n    while ((rc = memcached_response(instance, buffer, sizeof(buffer), NULL)) == MEMCACHED_STAT) {\n      char *string_ptr = buffer;\n      string_ptr += 5; /* Move past STAT */\n\n      char *end_ptr;\n      for (end_ptr = string_ptr; isgraph(*end_ptr); end_ptr++) {\n      };\n      char *key = string_ptr;\n      key[size_t(end_ptr - string_ptr)] = 0;\n\n      string_ptr = end_ptr + 1;\n      for (end_ptr = string_ptr; !(isspace(*end_ptr)); end_ptr++) {\n      };\n      char *value = string_ptr;\n      value[(size_t)(end_ptr - string_ptr)] = 0;\n#if 0\n      bool check_bool= bool(check);\n      bool check_func_bool= bool(check) ? bool(check->func) : false;\n      fprintf(stderr, \"%s:%d %s %s %d:%d\\n\", __FILE__, __LINE__, key, value, check_bool, check_func_bool);\n#endif\n\n      if (check and check->func) {\n        check->func(instance, key, strlen(key), value, strlen(value), check->context);\n      }\n\n      if (memc_stat) {\n        if ((set_data(memc_stat, key, value)) == MEMCACHED_UNKNOWN_STAT_KEY) {\n          WATCHPOINT_ERROR(MEMCACHED_UNKNOWN_STAT_KEY);\n          WATCHPOINT_ASSERT(0);\n        }\n      }\n    }\n  }\n\n  if (rc == MEMCACHED_ERROR) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (rc == MEMCACHED_END) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  return rc;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "0"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ERROR",
          "args": [
            "MEMCACHED_UNKNOWN_STAT_KEY"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_data",
          "args": [
            "memc_stat",
            "key",
            "value"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "set_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/stats.cc",
          "lines": "56-240",
          "snippet": "static memcached_return_t set_data(memcached_stat_st *memc_stat, const char *key,\n                                   const char *value) {\n  if (strlen(key) < 1) {\n    WATCHPOINT_STRING(key);\n    return MEMCACHED_UNKNOWN_STAT_KEY;\n  } else if (strcmp(\"pid\", key) == 0) {\n    errno = 0;\n    int64_t temp = strtoll(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n\n    if (temp <= INT32_MAX and (sizeof(pid_t) == sizeof(int32_t))) {\n      memc_stat->pid = pid_t(temp);\n    } else if (temp > -1) {\n      memc_stat->pid = pid_t(temp);\n    } else {\n      // If we got a value less then -1 then something went wrong in the\n      // protocol\n    }\n  } else if (not strcmp(\"uptime\", key)) {\n    errno = 0;\n    memc_stat->uptime = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"time\", key)) {\n    errno = 0;\n    memc_stat->time = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"version\", key)) {\n    memcpy(memc_stat->version, value, strlen(value));\n    memc_stat->version[strlen(value)] = 0;\n  } else if (not strcmp(\"pointer_size\", key)) {\n    errno = 0;\n    memc_stat->pointer_size = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"rusage_user\", key)) {\n    char *walk_ptr;\n    for (walk_ptr = (char *) value; (!ispunct(*walk_ptr)); walk_ptr++) {\n    };\n    *walk_ptr = 0;\n    walk_ptr++;\n\n    errno = 0;\n    memc_stat->rusage_user_seconds = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n\n    errno = 0;\n    memc_stat->rusage_user_microseconds = strtoul(walk_ptr, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"rusage_system\", key)) {\n    char *walk_ptr;\n    for (walk_ptr = (char *) value; (!ispunct(*walk_ptr)); walk_ptr++) {\n    };\n    *walk_ptr = 0;\n    walk_ptr++;\n\n    errno = 0;\n    memc_stat->rusage_system_seconds = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n\n    errno = 0;\n    memc_stat->rusage_system_microseconds = strtoul(walk_ptr, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"curr_items\", key)) {\n    errno = 0;\n    memc_stat->curr_items = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"total_items\", key)) {\n    errno = 0;\n    memc_stat->total_items = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"bytes_read\", key)) {\n    errno = 0;\n    memc_stat->bytes_read = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"bytes_written\", key)) {\n    errno = 0;\n    memc_stat->bytes_written = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"bytes\", key)) {\n    errno = 0;\n    memc_stat->bytes = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"curr_connections\", key)) {\n    errno = 0;\n    memc_stat->curr_connections = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"total_connections\", key)) {\n    errno = 0;\n    memc_stat->total_connections = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"connection_structures\", key)) {\n    errno = 0;\n    memc_stat->connection_structures = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"cmd_get\", key)) {\n    errno = 0;\n    memc_stat->cmd_get = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"cmd_set\", key)) {\n    errno = 0;\n    memc_stat->cmd_set = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"get_hits\", key)) {\n    errno = 0;\n    memc_stat->get_hits = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"get_misses\", key)) {\n    errno = 0;\n    memc_stat->get_misses = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"evictions\", key)) {\n    errno = 0;\n    memc_stat->evictions = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"limit_maxbytes\", key)) {\n    errno = 0;\n    memc_stat->limit_maxbytes = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"threads\", key)) {\n    errno = 0;\n    memc_stat->threads = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if ((strcmp(\"delete_misses\", key) == 0 or /* New stats in the 1.3 beta */\n              strcmp(\"delete_hits\", key) == 0 or   /* Just swallow them for now.. */\n              strcmp(\"incr_misses\", key) == 0 or strcmp(\"incr_hits\", key) == 0\n              or strcmp(\"decr_misses\", key) == 0 or strcmp(\"decr_hits\", key) == 0\n              or strcmp(\"cas_misses\", key) == 0 or strcmp(\"cas_hits\", key) == 0\n              or strcmp(\"cas_badval\", key) == 0 or strcmp(\"cmd_flush\", key) == 0\n              or strcmp(\"accepting_conns\", key) == 0 or strcmp(\"listen_disabled_num\", key) == 0\n              or strcmp(\"conn_yields\", key) == 0 or strcmp(\"auth_cmds\", key) == 0\n              or strcmp(\"auth_errors\", key) == 0 or strcmp(\"reclaimed\", key) == 0)\n             == 0)\n  {\n    WATCHPOINT_STRING(key);\n    /* return MEMCACHED_UNKNOWN_STAT_KEY; */\n    return MEMCACHED_SUCCESS;\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t set_data(memcached_stat_st *memc_stat, const char *key,\n                                   const char *value) {\n  if (strlen(key) < 1) {\n    WATCHPOINT_STRING(key);\n    return MEMCACHED_UNKNOWN_STAT_KEY;\n  } else if (strcmp(\"pid\", key) == 0) {\n    errno = 0;\n    int64_t temp = strtoll(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n\n    if (temp <= INT32_MAX and (sizeof(pid_t) == sizeof(int32_t))) {\n      memc_stat->pid = pid_t(temp);\n    } else if (temp > -1) {\n      memc_stat->pid = pid_t(temp);\n    } else {\n      // If we got a value less then -1 then something went wrong in the\n      // protocol\n    }\n  } else if (not strcmp(\"uptime\", key)) {\n    errno = 0;\n    memc_stat->uptime = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"time\", key)) {\n    errno = 0;\n    memc_stat->time = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"version\", key)) {\n    memcpy(memc_stat->version, value, strlen(value));\n    memc_stat->version[strlen(value)] = 0;\n  } else if (not strcmp(\"pointer_size\", key)) {\n    errno = 0;\n    memc_stat->pointer_size = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"rusage_user\", key)) {\n    char *walk_ptr;\n    for (walk_ptr = (char *) value; (!ispunct(*walk_ptr)); walk_ptr++) {\n    };\n    *walk_ptr = 0;\n    walk_ptr++;\n\n    errno = 0;\n    memc_stat->rusage_user_seconds = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n\n    errno = 0;\n    memc_stat->rusage_user_microseconds = strtoul(walk_ptr, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"rusage_system\", key)) {\n    char *walk_ptr;\n    for (walk_ptr = (char *) value; (!ispunct(*walk_ptr)); walk_ptr++) {\n    };\n    *walk_ptr = 0;\n    walk_ptr++;\n\n    errno = 0;\n    memc_stat->rusage_system_seconds = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n\n    errno = 0;\n    memc_stat->rusage_system_microseconds = strtoul(walk_ptr, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"curr_items\", key)) {\n    errno = 0;\n    memc_stat->curr_items = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"total_items\", key)) {\n    errno = 0;\n    memc_stat->total_items = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"bytes_read\", key)) {\n    errno = 0;\n    memc_stat->bytes_read = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"bytes_written\", key)) {\n    errno = 0;\n    memc_stat->bytes_written = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"bytes\", key)) {\n    errno = 0;\n    memc_stat->bytes = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"curr_connections\", key)) {\n    errno = 0;\n    memc_stat->curr_connections = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"total_connections\", key)) {\n    errno = 0;\n    memc_stat->total_connections = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"connection_structures\", key)) {\n    errno = 0;\n    memc_stat->connection_structures = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"cmd_get\", key)) {\n    errno = 0;\n    memc_stat->cmd_get = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"cmd_set\", key)) {\n    errno = 0;\n    memc_stat->cmd_set = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"get_hits\", key)) {\n    errno = 0;\n    memc_stat->get_hits = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"get_misses\", key)) {\n    errno = 0;\n    memc_stat->get_misses = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"evictions\", key)) {\n    errno = 0;\n    memc_stat->evictions = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"limit_maxbytes\", key)) {\n    errno = 0;\n    memc_stat->limit_maxbytes = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"threads\", key)) {\n    errno = 0;\n    memc_stat->threads = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if ((strcmp(\"delete_misses\", key) == 0 or /* New stats in the 1.3 beta */\n              strcmp(\"delete_hits\", key) == 0 or   /* Just swallow them for now.. */\n              strcmp(\"incr_misses\", key) == 0 or strcmp(\"incr_hits\", key) == 0\n              or strcmp(\"decr_misses\", key) == 0 or strcmp(\"decr_hits\", key) == 0\n              or strcmp(\"cas_misses\", key) == 0 or strcmp(\"cas_hits\", key) == 0\n              or strcmp(\"cas_badval\", key) == 0 or strcmp(\"cmd_flush\", key) == 0\n              or strcmp(\"accepting_conns\", key) == 0 or strcmp(\"listen_disabled_num\", key) == 0\n              or strcmp(\"conn_yields\", key) == 0 or strcmp(\"auth_cmds\", key) == 0\n              or strcmp(\"auth_errors\", key) == 0 or strcmp(\"reclaimed\", key) == 0)\n             == 0)\n  {\n    WATCHPOINT_STRING(key);\n    /* return MEMCACHED_UNKNOWN_STAT_KEY; */\n    return MEMCACHED_SUCCESS;\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check->func",
          "args": [
            "instance",
            "key",
            "strlen(key)",
            "value",
            "strlen(value)",
            "check->context"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s:%d %s %s %d:%d\\n\"",
            "__FILE__",
            "__LINE__",
            "key",
            "value",
            "check_bool",
            "check_func_bool"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "check->func"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "check"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool",
          "args": [
            "check"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*end_ptr"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "end_ptr - string_ptr"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isgraph",
          "args": [
            "*end_ptr"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_response",
          "args": [
            "instance",
            "buffer",
            "sizeof(buffer)",
            "NULL"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
          "lines": "789-834",
          "snippet": "memcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_vdo",
          "args": [
            "instance",
            "vector",
            "3",
            "true"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_vdo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/do.cc",
          "lines": "64-100",
          "snippet": "memcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"\\r\\n\""
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_literal_param",
          "args": [
            "\"stats \""
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t ascii_stats_fetch(memcached_stat_st *memc_stat, const char *args,\n                                            const size_t args_length,\n                                            memcached_instance_st *instance,\n                                            struct local_context *check) {\n  libmemcached_io_vector_st vector[] = {\n      {memcached_literal_param(\"stats \")}, {args, args_length}, {memcached_literal_param(\"\\r\\n\")}};\n\n  memcached_return_t rc = memcached_vdo(instance, vector, 3, true);\n  if (memcached_success(rc)) {\n    char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n    while ((rc = memcached_response(instance, buffer, sizeof(buffer), NULL)) == MEMCACHED_STAT) {\n      char *string_ptr = buffer;\n      string_ptr += 5; /* Move past STAT */\n\n      char *end_ptr;\n      for (end_ptr = string_ptr; isgraph(*end_ptr); end_ptr++) {\n      };\n      char *key = string_ptr;\n      key[size_t(end_ptr - string_ptr)] = 0;\n\n      string_ptr = end_ptr + 1;\n      for (end_ptr = string_ptr; !(isspace(*end_ptr)); end_ptr++) {\n      };\n      char *value = string_ptr;\n      value[(size_t)(end_ptr - string_ptr)] = 0;\n#if 0\n      bool check_bool= bool(check);\n      bool check_func_bool= bool(check) ? bool(check->func) : false;\n      fprintf(stderr, \"%s:%d %s %s %d:%d\\n\", __FILE__, __LINE__, key, value, check_bool, check_func_bool);\n#endif\n\n      if (check and check->func) {\n        check->func(instance, key, strlen(key), value, strlen(value), check->context);\n      }\n\n      if (memc_stat) {\n        if ((set_data(memc_stat, key, value)) == MEMCACHED_UNKNOWN_STAT_KEY) {\n          WATCHPOINT_ERROR(MEMCACHED_UNKNOWN_STAT_KEY);\n          WATCHPOINT_ASSERT(0);\n        }\n      }\n    }\n  }\n\n  if (rc == MEMCACHED_ERROR) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (rc == MEMCACHED_END) {\n    return MEMCACHED_SUCCESS;\n  }\n\n  return rc;\n}"
  },
  {
    "function_name": "binary_stats_fetch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/stats.cc",
    "lines": "330-396",
    "snippet": "static memcached_return_t binary_stats_fetch(memcached_stat_st *memc_stat, const char *args,\n                                             const size_t args_length,\n                                             memcached_instance_st *instance,\n                                             struct local_context *check) {\n  char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n  protocol_binary_request_stats request = {}; // = {.bytes= {0}};\n  memcached_return_t rc;\n\n  initialize_binary_request(instance, request.message.header);\n\n  request.message.header.request.opcode = PROTOCOL_BINARY_CMD_STAT;\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n\n  if (args_length) {\n    request.message.header.request.keylen = htons(uint16_t(args_length));\n    request.message.header.request.bodylen = htonl(uint32_t(args_length));\n\n    libmemcached_io_vector_st vector[] = {{request.bytes, sizeof(request.bytes)},\n                                          {args, args_length}};\n\n    if (memcached_failed(rc = memcached_vdo(instance, vector, 2, true))) {\n      return rc;\n    }\n  } else {\n    libmemcached_io_vector_st vector[] = {{request.bytes, sizeof(request.bytes)}};\n\n    if (memcached_failed(rc = memcached_vdo(instance, vector, 1, true))) {\n      return rc;\n    }\n  }\n\n  memcached_server_response_decrement(instance);\n  while (1) {\n    rc = memcached_response(instance, buffer, sizeof(buffer), NULL);\n\n    if (rc == MEMCACHED_END) {\n      break;\n    }\n\n    if (rc != MEMCACHED_SUCCESS) {\n      return rc;\n    }\n\n    if (check && check->func) {\n      size_t key_length = strlen(buffer);\n\n      check->func(instance, buffer, key_length, buffer + key_length + 1,\n                  strlen(buffer + key_length + 1), check->context);\n    }\n\n    if (memc_stat) {\n      if ((set_data(memc_stat, buffer, buffer + strlen(buffer) + 1)) == MEMCACHED_UNKNOWN_STAT_KEY)\n      {\n        WATCHPOINT_ERROR(MEMCACHED_UNKNOWN_STAT_KEY);\n        WATCHPOINT_ASSERT(0);\n      }\n    }\n  }\n\n  /*\n   * memcached_response will decrement the counter, so I need to reset it..\n   * todo: look at this and try to find a better solution.\n   * */\n  instance->cursor_active_ = 0;\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WATCHPOINT_ASSERT",
          "args": [
            "0"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_ERROR",
          "args": [
            "MEMCACHED_UNKNOWN_STAT_KEY"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_data",
          "args": [
            "memc_stat",
            "buffer",
            "buffer + strlen(buffer) + 1"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "set_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/stats.cc",
          "lines": "56-240",
          "snippet": "static memcached_return_t set_data(memcached_stat_st *memc_stat, const char *key,\n                                   const char *value) {\n  if (strlen(key) < 1) {\n    WATCHPOINT_STRING(key);\n    return MEMCACHED_UNKNOWN_STAT_KEY;\n  } else if (strcmp(\"pid\", key) == 0) {\n    errno = 0;\n    int64_t temp = strtoll(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n\n    if (temp <= INT32_MAX and (sizeof(pid_t) == sizeof(int32_t))) {\n      memc_stat->pid = pid_t(temp);\n    } else if (temp > -1) {\n      memc_stat->pid = pid_t(temp);\n    } else {\n      // If we got a value less then -1 then something went wrong in the\n      // protocol\n    }\n  } else if (not strcmp(\"uptime\", key)) {\n    errno = 0;\n    memc_stat->uptime = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"time\", key)) {\n    errno = 0;\n    memc_stat->time = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"version\", key)) {\n    memcpy(memc_stat->version, value, strlen(value));\n    memc_stat->version[strlen(value)] = 0;\n  } else if (not strcmp(\"pointer_size\", key)) {\n    errno = 0;\n    memc_stat->pointer_size = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"rusage_user\", key)) {\n    char *walk_ptr;\n    for (walk_ptr = (char *) value; (!ispunct(*walk_ptr)); walk_ptr++) {\n    };\n    *walk_ptr = 0;\n    walk_ptr++;\n\n    errno = 0;\n    memc_stat->rusage_user_seconds = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n\n    errno = 0;\n    memc_stat->rusage_user_microseconds = strtoul(walk_ptr, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"rusage_system\", key)) {\n    char *walk_ptr;\n    for (walk_ptr = (char *) value; (!ispunct(*walk_ptr)); walk_ptr++) {\n    };\n    *walk_ptr = 0;\n    walk_ptr++;\n\n    errno = 0;\n    memc_stat->rusage_system_seconds = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n\n    errno = 0;\n    memc_stat->rusage_system_microseconds = strtoul(walk_ptr, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"curr_items\", key)) {\n    errno = 0;\n    memc_stat->curr_items = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"total_items\", key)) {\n    errno = 0;\n    memc_stat->total_items = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"bytes_read\", key)) {\n    errno = 0;\n    memc_stat->bytes_read = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"bytes_written\", key)) {\n    errno = 0;\n    memc_stat->bytes_written = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"bytes\", key)) {\n    errno = 0;\n    memc_stat->bytes = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"curr_connections\", key)) {\n    errno = 0;\n    memc_stat->curr_connections = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"total_connections\", key)) {\n    errno = 0;\n    memc_stat->total_connections = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"connection_structures\", key)) {\n    errno = 0;\n    memc_stat->connection_structures = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"cmd_get\", key)) {\n    errno = 0;\n    memc_stat->cmd_get = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"cmd_set\", key)) {\n    errno = 0;\n    memc_stat->cmd_set = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"get_hits\", key)) {\n    errno = 0;\n    memc_stat->get_hits = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"get_misses\", key)) {\n    errno = 0;\n    memc_stat->get_misses = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"evictions\", key)) {\n    errno = 0;\n    memc_stat->evictions = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"limit_maxbytes\", key)) {\n    errno = 0;\n    memc_stat->limit_maxbytes = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"threads\", key)) {\n    errno = 0;\n    memc_stat->threads = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if ((strcmp(\"delete_misses\", key) == 0 or /* New stats in the 1.3 beta */\n              strcmp(\"delete_hits\", key) == 0 or   /* Just swallow them for now.. */\n              strcmp(\"incr_misses\", key) == 0 or strcmp(\"incr_hits\", key) == 0\n              or strcmp(\"decr_misses\", key) == 0 or strcmp(\"decr_hits\", key) == 0\n              or strcmp(\"cas_misses\", key) == 0 or strcmp(\"cas_hits\", key) == 0\n              or strcmp(\"cas_badval\", key) == 0 or strcmp(\"cmd_flush\", key) == 0\n              or strcmp(\"accepting_conns\", key) == 0 or strcmp(\"listen_disabled_num\", key) == 0\n              or strcmp(\"conn_yields\", key) == 0 or strcmp(\"auth_cmds\", key) == 0\n              or strcmp(\"auth_errors\", key) == 0 or strcmp(\"reclaimed\", key) == 0)\n             == 0)\n  {\n    WATCHPOINT_STRING(key);\n    /* return MEMCACHED_UNKNOWN_STAT_KEY; */\n    return MEMCACHED_SUCCESS;\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t set_data(memcached_stat_st *memc_stat, const char *key,\n                                   const char *value) {\n  if (strlen(key) < 1) {\n    WATCHPOINT_STRING(key);\n    return MEMCACHED_UNKNOWN_STAT_KEY;\n  } else if (strcmp(\"pid\", key) == 0) {\n    errno = 0;\n    int64_t temp = strtoll(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n\n    if (temp <= INT32_MAX and (sizeof(pid_t) == sizeof(int32_t))) {\n      memc_stat->pid = pid_t(temp);\n    } else if (temp > -1) {\n      memc_stat->pid = pid_t(temp);\n    } else {\n      // If we got a value less then -1 then something went wrong in the\n      // protocol\n    }\n  } else if (not strcmp(\"uptime\", key)) {\n    errno = 0;\n    memc_stat->uptime = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"time\", key)) {\n    errno = 0;\n    memc_stat->time = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"version\", key)) {\n    memcpy(memc_stat->version, value, strlen(value));\n    memc_stat->version[strlen(value)] = 0;\n  } else if (not strcmp(\"pointer_size\", key)) {\n    errno = 0;\n    memc_stat->pointer_size = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"rusage_user\", key)) {\n    char *walk_ptr;\n    for (walk_ptr = (char *) value; (!ispunct(*walk_ptr)); walk_ptr++) {\n    };\n    *walk_ptr = 0;\n    walk_ptr++;\n\n    errno = 0;\n    memc_stat->rusage_user_seconds = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n\n    errno = 0;\n    memc_stat->rusage_user_microseconds = strtoul(walk_ptr, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"rusage_system\", key)) {\n    char *walk_ptr;\n    for (walk_ptr = (char *) value; (!ispunct(*walk_ptr)); walk_ptr++) {\n    };\n    *walk_ptr = 0;\n    walk_ptr++;\n\n    errno = 0;\n    memc_stat->rusage_system_seconds = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n\n    errno = 0;\n    memc_stat->rusage_system_microseconds = strtoul(walk_ptr, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"curr_items\", key)) {\n    errno = 0;\n    memc_stat->curr_items = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"total_items\", key)) {\n    errno = 0;\n    memc_stat->total_items = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"bytes_read\", key)) {\n    errno = 0;\n    memc_stat->bytes_read = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"bytes_written\", key)) {\n    errno = 0;\n    memc_stat->bytes_written = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"bytes\", key)) {\n    errno = 0;\n    memc_stat->bytes = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"curr_connections\", key)) {\n    errno = 0;\n    memc_stat->curr_connections = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"total_connections\", key)) {\n    errno = 0;\n    memc_stat->total_connections = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"connection_structures\", key)) {\n    errno = 0;\n    memc_stat->connection_structures = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"cmd_get\", key)) {\n    errno = 0;\n    memc_stat->cmd_get = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"cmd_set\", key)) {\n    errno = 0;\n    memc_stat->cmd_set = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"get_hits\", key)) {\n    errno = 0;\n    memc_stat->get_hits = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"get_misses\", key)) {\n    errno = 0;\n    memc_stat->get_misses = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"evictions\", key)) {\n    errno = 0;\n    memc_stat->evictions = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"limit_maxbytes\", key)) {\n    errno = 0;\n    memc_stat->limit_maxbytes = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"threads\", key)) {\n    errno = 0;\n    memc_stat->threads = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if ((strcmp(\"delete_misses\", key) == 0 or /* New stats in the 1.3 beta */\n              strcmp(\"delete_hits\", key) == 0 or   /* Just swallow them for now.. */\n              strcmp(\"incr_misses\", key) == 0 or strcmp(\"incr_hits\", key) == 0\n              or strcmp(\"decr_misses\", key) == 0 or strcmp(\"decr_hits\", key) == 0\n              or strcmp(\"cas_misses\", key) == 0 or strcmp(\"cas_hits\", key) == 0\n              or strcmp(\"cas_badval\", key) == 0 or strcmp(\"cmd_flush\", key) == 0\n              or strcmp(\"accepting_conns\", key) == 0 or strcmp(\"listen_disabled_num\", key) == 0\n              or strcmp(\"conn_yields\", key) == 0 or strcmp(\"auth_cmds\", key) == 0\n              or strcmp(\"auth_errors\", key) == 0 or strcmp(\"reclaimed\", key) == 0)\n             == 0)\n  {\n    WATCHPOINT_STRING(key);\n    /* return MEMCACHED_UNKNOWN_STAT_KEY; */\n    return MEMCACHED_SUCCESS;\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check->func",
          "args": [
            "instance",
            "buffer",
            "key_length",
            "buffer + key_length + 1",
            "strlen(buffer + key_length + 1)",
            "check->context"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer + key_length + 1"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_response",
          "args": [
            "instance",
            "buffer",
            "sizeof(buffer)",
            "NULL"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
          "lines": "789-834",
          "snippet": "memcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}",
          "includes": [
            "#include \"libmemcached/string.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,\n                                      size_t buffer_length, memcached_result_st *result) {\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  /* We may have old commands in the buffer not sent, first purge */\n  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))\n  {\n    (void) memcached_io_write(instance);\n  }\n\n  /*  Before going into loop wait to see if we have any IO waiting for us */\n  if (0) {\n    memcached_return_t read_rc = memcached_io_wait_for_read(instance);\n    fprintf(stderr, \"%s:%d: %s\\n\", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));\n  }\n\n  /*\n   * The previous implementation purged all pending requests and just\n   * returned the last one. Purge all pending messages to ensure backwards\n   * compatibility.\n   */\n  if (memcached_is_binary(instance->root) == false\n      and memcached_server_response_count(instance) > 1) {\n    memcached_result_st junked_result;\n    memcached_result_st *junked_result_ptr =\n        memcached_result_create(instance->root, &junked_result);\n\n    assert(junked_result_ptr);\n\n    while (memcached_server_response_count(instance) > 1) {\n      memcached_return_t rc =\n          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);\n\n      // @TODO should we return an error on another but a bad read case?\n      if (memcached_fatal(rc)) {\n        memcached_result_free(junked_result_ptr);\n        return rc;\n      }\n    }\n    memcached_result_free(junked_result_ptr);\n  }\n\n  return _read_one_response(instance, buffer, buffer_length, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_response_decrement",
          "args": [
            "instance"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = memcached_vdo(instance, vector, 1, true)"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_vdo",
          "args": [
            "instance",
            "vector",
            "1",
            "true"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_vdo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/do.cc",
          "lines": "64-100",
          "snippet": "memcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_vdo(memcached_instance_st *instance,\n                                 libmemcached_io_vector_st vector[], const size_t count,\n                                 const bool with_flush) {\n  memcached_return_t rc;\n\n  assert_msg(vector, \"Invalid vector passed\");\n\n  if (memcached_failed(rc = memcached_connect(instance))) {\n    WATCHPOINT_ERROR(rc);\n    assert_msg(instance->error_messages,\n               \"memcached_connect() returned an error but the Instance showed none.\");\n    return rc;\n  }\n\n  /*\n  ** Since non buffering ops in UDP mode dont check to make sure they will fit\n  ** before they start writing, if there is any data in buffer, clear it out,\n  ** otherwise we might get a partial write.\n  **/\n  bool sent_success;\n  if (memcached_is_udp(instance->root)) {\n    sent_success = memcached_success(rc = _vdo_udp(instance, vector, count));\n  } else {\n    sent_success = memcached_io_writev(instance, vector, count, with_flush);\n  }\n  if (sent_success == false) {\n    rc = memcached_last_error(instance->root);\n    if (rc == MEMCACHED_SUCCESS) {\n      memcached_set_error(*instance, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    }\n    memcached_io_reset(instance);\n  } else if (memcached_is_replying(instance->root) && !memcached_is_udp(instance->root)) {\n    memcached_server_response_increment(instance);\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc = memcached_vdo(instance, vector, 2, true)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "uint32_t(args_length)"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_htonll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/byteorder.cc",
          "lines": "55-61",
          "snippet": "uint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include \"libmemcached/byteorder.h\"",
            "#  include <arpa/inet.h>",
            "#include \"mem_config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"libmemcached/byteorder.h\"\n#  include <arpa/inet.h>\n#include \"mem_config.h\"\n\nuint64_t memcached_htonll(uint64_t value) {\n#ifdef HAVE_HTONLL\n  return htonll(value);\n#else\n  return swap64(value);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "uint32_t",
          "args": [
            "args_length"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "uint16_t(args_length)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint16_t",
          "args": [
            "args_length"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_binary_request",
          "args": [
            "instance",
            "request.message.header"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_binary_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/io.cc",
          "lines": "20-25",
          "snippet": "void initialize_binary_request(memcached_instance_st *server,\n                               protocol_binary_request_header &header) {\n  server->request_id++;\n  header.request.magic = PROTOCOL_BINARY_REQ;\n  header.request.opaque = htons(server->request_id);\n}",
          "includes": [
            "#include \"p9y/clock_gettime.hpp\"",
            "#include \"p9y/poll.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"p9y/clock_gettime.hpp\"\n#include \"p9y/poll.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid initialize_binary_request(memcached_instance_st *server,\n                               protocol_binary_request_header &header) {\n  server->request_id++;\n  header.request.magic = PROTOCOL_BINARY_REQ;\n  header.request.opaque = htons(server->request_id);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t binary_stats_fetch(memcached_stat_st *memc_stat, const char *args,\n                                             const size_t args_length,\n                                             memcached_instance_st *instance,\n                                             struct local_context *check) {\n  char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];\n  protocol_binary_request_stats request = {}; // = {.bytes= {0}};\n  memcached_return_t rc;\n\n  initialize_binary_request(instance, request.message.header);\n\n  request.message.header.request.opcode = PROTOCOL_BINARY_CMD_STAT;\n  request.message.header.request.datatype = PROTOCOL_BINARY_RAW_BYTES;\n\n  if (args_length) {\n    request.message.header.request.keylen = htons(uint16_t(args_length));\n    request.message.header.request.bodylen = htonl(uint32_t(args_length));\n\n    libmemcached_io_vector_st vector[] = {{request.bytes, sizeof(request.bytes)},\n                                          {args, args_length}};\n\n    if (memcached_failed(rc = memcached_vdo(instance, vector, 2, true))) {\n      return rc;\n    }\n  } else {\n    libmemcached_io_vector_st vector[] = {{request.bytes, sizeof(request.bytes)}};\n\n    if (memcached_failed(rc = memcached_vdo(instance, vector, 1, true))) {\n      return rc;\n    }\n  }\n\n  memcached_server_response_decrement(instance);\n  while (1) {\n    rc = memcached_response(instance, buffer, sizeof(buffer), NULL);\n\n    if (rc == MEMCACHED_END) {\n      break;\n    }\n\n    if (rc != MEMCACHED_SUCCESS) {\n      return rc;\n    }\n\n    if (check && check->func) {\n      size_t key_length = strlen(buffer);\n\n      check->func(instance, buffer, key_length, buffer + key_length + 1,\n                  strlen(buffer + key_length + 1), check->context);\n    }\n\n    if (memc_stat) {\n      if ((set_data(memc_stat, buffer, buffer + strlen(buffer) + 1)) == MEMCACHED_UNKNOWN_STAT_KEY)\n      {\n        WATCHPOINT_ERROR(MEMCACHED_UNKNOWN_STAT_KEY);\n        WATCHPOINT_ASSERT(0);\n      }\n    }\n  }\n\n  /*\n   * memcached_response will decrement the counter, so I need to reset it..\n   * todo: look at this and try to find a better solution.\n   * */\n  instance->cursor_active_ = 0;\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "set_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/stats.cc",
    "lines": "56-240",
    "snippet": "static memcached_return_t set_data(memcached_stat_st *memc_stat, const char *key,\n                                   const char *value) {\n  if (strlen(key) < 1) {\n    WATCHPOINT_STRING(key);\n    return MEMCACHED_UNKNOWN_STAT_KEY;\n  } else if (strcmp(\"pid\", key) == 0) {\n    errno = 0;\n    int64_t temp = strtoll(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n\n    if (temp <= INT32_MAX and (sizeof(pid_t) == sizeof(int32_t))) {\n      memc_stat->pid = pid_t(temp);\n    } else if (temp > -1) {\n      memc_stat->pid = pid_t(temp);\n    } else {\n      // If we got a value less then -1 then something went wrong in the\n      // protocol\n    }\n  } else if (not strcmp(\"uptime\", key)) {\n    errno = 0;\n    memc_stat->uptime = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"time\", key)) {\n    errno = 0;\n    memc_stat->time = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"version\", key)) {\n    memcpy(memc_stat->version, value, strlen(value));\n    memc_stat->version[strlen(value)] = 0;\n  } else if (not strcmp(\"pointer_size\", key)) {\n    errno = 0;\n    memc_stat->pointer_size = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"rusage_user\", key)) {\n    char *walk_ptr;\n    for (walk_ptr = (char *) value; (!ispunct(*walk_ptr)); walk_ptr++) {\n    };\n    *walk_ptr = 0;\n    walk_ptr++;\n\n    errno = 0;\n    memc_stat->rusage_user_seconds = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n\n    errno = 0;\n    memc_stat->rusage_user_microseconds = strtoul(walk_ptr, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"rusage_system\", key)) {\n    char *walk_ptr;\n    for (walk_ptr = (char *) value; (!ispunct(*walk_ptr)); walk_ptr++) {\n    };\n    *walk_ptr = 0;\n    walk_ptr++;\n\n    errno = 0;\n    memc_stat->rusage_system_seconds = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n\n    errno = 0;\n    memc_stat->rusage_system_microseconds = strtoul(walk_ptr, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"curr_items\", key)) {\n    errno = 0;\n    memc_stat->curr_items = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"total_items\", key)) {\n    errno = 0;\n    memc_stat->total_items = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"bytes_read\", key)) {\n    errno = 0;\n    memc_stat->bytes_read = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"bytes_written\", key)) {\n    errno = 0;\n    memc_stat->bytes_written = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"bytes\", key)) {\n    errno = 0;\n    memc_stat->bytes = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"curr_connections\", key)) {\n    errno = 0;\n    memc_stat->curr_connections = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"total_connections\", key)) {\n    errno = 0;\n    memc_stat->total_connections = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"connection_structures\", key)) {\n    errno = 0;\n    memc_stat->connection_structures = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"cmd_get\", key)) {\n    errno = 0;\n    memc_stat->cmd_get = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"cmd_set\", key)) {\n    errno = 0;\n    memc_stat->cmd_set = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"get_hits\", key)) {\n    errno = 0;\n    memc_stat->get_hits = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"get_misses\", key)) {\n    errno = 0;\n    memc_stat->get_misses = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"evictions\", key)) {\n    errno = 0;\n    memc_stat->evictions = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"limit_maxbytes\", key)) {\n    errno = 0;\n    memc_stat->limit_maxbytes = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"threads\", key)) {\n    errno = 0;\n    memc_stat->threads = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if ((strcmp(\"delete_misses\", key) == 0 or /* New stats in the 1.3 beta */\n              strcmp(\"delete_hits\", key) == 0 or   /* Just swallow them for now.. */\n              strcmp(\"incr_misses\", key) == 0 or strcmp(\"incr_hits\", key) == 0\n              or strcmp(\"decr_misses\", key) == 0 or strcmp(\"decr_hits\", key) == 0\n              or strcmp(\"cas_misses\", key) == 0 or strcmp(\"cas_hits\", key) == 0\n              or strcmp(\"cas_badval\", key) == 0 or strcmp(\"cmd_flush\", key) == 0\n              or strcmp(\"accepting_conns\", key) == 0 or strcmp(\"listen_disabled_num\", key) == 0\n              or strcmp(\"conn_yields\", key) == 0 or strcmp(\"auth_cmds\", key) == 0\n              or strcmp(\"auth_errors\", key) == 0 or strcmp(\"reclaimed\", key) == 0)\n             == 0)\n  {\n    WATCHPOINT_STRING(key);\n    /* return MEMCACHED_UNKNOWN_STAT_KEY; */\n    return MEMCACHED_SUCCESS;\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WATCHPOINT_STRING",
          "args": [
            "key"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"reclaimed\"",
            "key"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"auth_errors\"",
            "key"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"auth_cmds\"",
            "key"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"conn_yields\"",
            "key"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"listen_disabled_num\"",
            "key"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"accepting_conns\"",
            "key"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"cmd_flush\"",
            "key"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"cas_badval\"",
            "key"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"cas_hits\"",
            "key"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"cas_misses\"",
            "key"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"decr_hits\"",
            "key"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"decr_misses\"",
            "key"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"incr_hits\"",
            "key"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"incr_misses\"",
            "key"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"delete_hits\"",
            "key"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"delete_misses\"",
            "key"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"threads\"",
            "key"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"limit_maxbytes\"",
            "key"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"evictions\"",
            "key"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"get_misses\"",
            "key"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"get_hits\"",
            "key"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"cmd_set\"",
            "key"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"cmd_get\"",
            "key"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"connection_structures\"",
            "key"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"total_connections\"",
            "key"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"curr_connections\"",
            "key"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"bytes\"",
            "key"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"bytes_written\"",
            "key"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"bytes_read\"",
            "key"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"total_items\"",
            "key"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"curr_items\"",
            "key"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "walk_ptr",
            "(char **) NULL",
            "10"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ispunct",
          "args": [
            "*walk_ptr"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"rusage_system\"",
            "key"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "walk_ptr",
            "(char **) NULL",
            "10"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ispunct",
          "args": [
            "*walk_ptr"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"rusage_user\"",
            "key"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"pointer_size\"",
            "key"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "memc_stat->version",
            "value",
            "strlen(value)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"version\"",
            "key"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"time\"",
            "key"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"uptime\"",
            "key"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_t",
          "args": [
            "temp"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_t",
          "args": [
            "temp"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoll",
          "args": [
            "value",
            "(char **) NULL",
            "10"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"pid\"",
            "key"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WATCHPOINT_STRING",
          "args": [
            "key"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nstatic memcached_return_t set_data(memcached_stat_st *memc_stat, const char *key,\n                                   const char *value) {\n  if (strlen(key) < 1) {\n    WATCHPOINT_STRING(key);\n    return MEMCACHED_UNKNOWN_STAT_KEY;\n  } else if (strcmp(\"pid\", key) == 0) {\n    errno = 0;\n    int64_t temp = strtoll(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n\n    if (temp <= INT32_MAX and (sizeof(pid_t) == sizeof(int32_t))) {\n      memc_stat->pid = pid_t(temp);\n    } else if (temp > -1) {\n      memc_stat->pid = pid_t(temp);\n    } else {\n      // If we got a value less then -1 then something went wrong in the\n      // protocol\n    }\n  } else if (not strcmp(\"uptime\", key)) {\n    errno = 0;\n    memc_stat->uptime = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"time\", key)) {\n    errno = 0;\n    memc_stat->time = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"version\", key)) {\n    memcpy(memc_stat->version, value, strlen(value));\n    memc_stat->version[strlen(value)] = 0;\n  } else if (not strcmp(\"pointer_size\", key)) {\n    errno = 0;\n    memc_stat->pointer_size = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"rusage_user\", key)) {\n    char *walk_ptr;\n    for (walk_ptr = (char *) value; (!ispunct(*walk_ptr)); walk_ptr++) {\n    };\n    *walk_ptr = 0;\n    walk_ptr++;\n\n    errno = 0;\n    memc_stat->rusage_user_seconds = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n\n    errno = 0;\n    memc_stat->rusage_user_microseconds = strtoul(walk_ptr, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"rusage_system\", key)) {\n    char *walk_ptr;\n    for (walk_ptr = (char *) value; (!ispunct(*walk_ptr)); walk_ptr++) {\n    };\n    *walk_ptr = 0;\n    walk_ptr++;\n\n    errno = 0;\n    memc_stat->rusage_system_seconds = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n\n    errno = 0;\n    memc_stat->rusage_system_microseconds = strtoul(walk_ptr, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"curr_items\", key)) {\n    errno = 0;\n    memc_stat->curr_items = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"total_items\", key)) {\n    errno = 0;\n    memc_stat->total_items = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"bytes_read\", key)) {\n    errno = 0;\n    memc_stat->bytes_read = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"bytes_written\", key)) {\n    errno = 0;\n    memc_stat->bytes_written = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"bytes\", key)) {\n    errno = 0;\n    memc_stat->bytes = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"curr_connections\", key)) {\n    errno = 0;\n    memc_stat->curr_connections = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"total_connections\", key)) {\n    errno = 0;\n    memc_stat->total_connections = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"connection_structures\", key)) {\n    errno = 0;\n    memc_stat->connection_structures = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"cmd_get\", key)) {\n    errno = 0;\n    memc_stat->cmd_get = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"cmd_set\", key)) {\n    errno = 0;\n    memc_stat->cmd_set = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"get_hits\", key)) {\n    errno = 0;\n    memc_stat->get_hits = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"get_misses\", key)) {\n    errno = 0;\n    memc_stat->get_misses = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"evictions\", key)) {\n    errno = 0;\n    memc_stat->evictions = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"limit_maxbytes\", key)) {\n    errno = 0;\n    memc_stat->limit_maxbytes = strtoull(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if (not strcmp(\"threads\", key)) {\n    errno = 0;\n    memc_stat->threads = strtoul(value, (char **) NULL, 10);\n    if (errno) {\n      return MEMCACHED_FAILURE;\n    }\n  } else if ((strcmp(\"delete_misses\", key) == 0 or /* New stats in the 1.3 beta */\n              strcmp(\"delete_hits\", key) == 0 or   /* Just swallow them for now.. */\n              strcmp(\"incr_misses\", key) == 0 or strcmp(\"incr_hits\", key) == 0\n              or strcmp(\"decr_misses\", key) == 0 or strcmp(\"decr_hits\", key) == 0\n              or strcmp(\"cas_misses\", key) == 0 or strcmp(\"cas_hits\", key) == 0\n              or strcmp(\"cas_badval\", key) == 0 or strcmp(\"cmd_flush\", key) == 0\n              or strcmp(\"accepting_conns\", key) == 0 or strcmp(\"listen_disabled_num\", key) == 0\n              or strcmp(\"conn_yields\", key) == 0 or strcmp(\"auth_cmds\", key) == 0\n              or strcmp(\"auth_errors\", key) == 0 or strcmp(\"reclaimed\", key) == 0)\n             == 0)\n  {\n    WATCHPOINT_STRING(key);\n    /* return MEMCACHED_UNKNOWN_STAT_KEY; */\n    return MEMCACHED_SUCCESS;\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
  },
  {
    "function_name": "local_context",
    "container": "local_context",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/stats.cc",
    "lines": "48-53",
    "snippet": "local_context(memcached_stat_fn func_arg, void *context_arg, const char *args_arg,\n                const size_t args_length_arg)\n  : func(func_arg)\n  , context(context_arg)\n  , args(args_arg)\n  , args_length(args_length_arg) {}",
    "includes": [
      "#include \"libmemcached/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"libmemcached/common.h\"\n\nlocal_context {\n  local_context(memcached_stat_fn func_arg, void *context_arg, const char *args_arg,\n                  const size_t args_length_arg)\n    : func(func_arg)\n    , context(context_arg)\n    , args(args_arg)\n    , args_length(args_length_arg) {}\n}"
  }
]