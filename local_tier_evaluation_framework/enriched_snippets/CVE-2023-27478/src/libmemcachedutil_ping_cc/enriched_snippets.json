[
  {
    "function_name": "libmemcached_util_ping2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/ping.cc",
    "lines": "54-98",
    "snippet": "bool libmemcached_util_ping2(const char *hostname, in_port_t port, const char *username,\n                             const char *password, memcached_return_t *ret) {\n  if (username == NULL) {\n    return libmemcached_util_ping(hostname, port, ret);\n  }\n\n  memcached_return_t unused;\n  if (not ret)\n    ret = &unused;\n\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT == 0) {\n    *ret = MEMCACHED_NOT_SUPPORTED;\n    return false;\n  }\n\n  memcached_st *memc_ptr = memcached_create(NULL);\n  if (not memc_ptr) {\n    *ret = MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n    return false;\n  }\n\n  if (memcached_failed(*ret = memcached_set_sasl_auth_data(memc_ptr, username, password))) {\n    memcached_free(memc_ptr);\n    return false;\n  }\n\n  memcached_return_t rc = memcached_server_add(memc_ptr, hostname, port);\n  if (memcached_success(rc)) {\n    rc = memcached_version(memc_ptr);\n  }\n\n  if (memcached_failed(rc) and rc == MEMCACHED_SOME_ERRORS) {\n    const memcached_instance_st *instance = memcached_server_instance_by_position(memc_ptr, 0);\n\n    assert_msg(instance and memcached_server_error(instance), \" \");\n    if (instance and memcached_server_error(instance)) {\n      rc = memcached_server_error_return(instance);\n    }\n  }\n  memcached_free(memc_ptr);\n\n  *ret = rc;\n\n  return memcached_success(rc);\n}",
    "includes": [
      "#include \"libmemcachedutil/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_free",
          "args": [
            "memc_ptr"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
          "lines": "257-261",
          "snippet": "void memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_error_return",
          "args": [
            "instance"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_error_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "541-551",
          "snippet": "memcached_return_t memcached_server_error_return(const memcached_instance_st *ptr) {\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (ptr->error_messages) {\n    return ptr->error_messages->rc;\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_server_error_return(const memcached_instance_st *ptr) {\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (ptr->error_messages) {\n    return ptr->error_messages->rc;\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "instance and memcached_server_error(instance)",
            "\" \""
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_instance_by_position",
          "args": [
            "memc_ptr",
            "0"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_version",
          "args": [
            "memc_ptr"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/version.cc",
          "lines": "164-184",
          "snippet": "memcached_return_t memcached_version(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    memcached_return_t rc;\n    if (memcached_failed(rc = initialize_query(memc, true))) {\n      return rc;\n    }\n\n    if (memcached_is_udp(memc)) {\n      return MEMCACHED_NOT_SUPPORTED;\n    }\n\n    if (memcached_is_binary(memc)) {\n      return memcached_version_binary(memc);\n    }\n\n    return memcached_version_textual(memc);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_version(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    memcached_return_t rc;\n    if (memcached_failed(rc = initialize_query(memc, true))) {\n      return rc;\n    }\n\n    if (memcached_is_udp(memc)) {\n      return MEMCACHED_NOT_SUPPORTED;\n    }\n\n    if (memcached_is_binary(memc)) {\n      return memcached_version_binary(memc);\n    }\n\n    return memcached_version_textual(memc);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_add",
          "args": [
            "memc_ptr",
            "hostname",
            "port"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "458-460",
          "snippet": "memcached_return_t memcached_server_add(memcached_st *shell, const char *hostname, in_port_t port) {\n  return memcached_server_add_with_weight(shell, hostname, port, 0);\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_server_add(memcached_st *shell, const char *hostname, in_port_t port) {\n  return memcached_server_add_with_weight(shell, hostname, port, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "*ret = memcached_set_sasl_auth_data(memc_ptr, username, password)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_set_sasl_auth_data",
          "args": [
            "memc_ptr",
            "username",
            "password"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_set_sasl_auth_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/sasl.cc",
          "lines": "466-468",
          "snippet": "memcached_return_t memcached_set_sasl_auth_data(memcached_st *, const char *, const char *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}",
          "includes": [
            "#  include <pthread.h>",
            "#    include <sasl/sasl.h>",
            "#include <atomic>",
            "#include <cassert>",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <pthread.h>\n#    include <sasl/sasl.h>\n#include <atomic>\n#include <cassert>\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_set_sasl_auth_data(memcached_st *, const char *, const char *) {\n  return MEMCACHED_NOT_SUPPORTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_create",
          "args": [
            "NULL"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libmemcached_util_ping",
          "args": [
            "hostname",
            "port",
            "ret"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "libmemcached_util_ping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/ping.cc",
          "lines": "18-52",
          "snippet": "bool libmemcached_util_ping(const char *hostname, in_port_t port, memcached_return_t *ret) {\n  memcached_return_t unused;\n  if (ret == NULL) {\n    ret = &unused;\n  }\n\n  memcached_st *memc_ptr = memcached_create(NULL);\n  if (memc_ptr == NULL) {\n    *ret = MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n    return false;\n  }\n\n  if (memcached_success(\n          (*ret = memcached_behavior_set(memc_ptr, MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT, 400000))))\n  {\n    memcached_return_t rc = memcached_server_add(memc_ptr, hostname, port);\n    if (memcached_success(rc)) {\n      rc = memcached_version(memc_ptr);\n    }\n\n    if (memcached_failed(rc) and rc == MEMCACHED_SOME_ERRORS) {\n      const memcached_instance_st *instance = memcached_server_instance_by_position(memc_ptr, 0);\n\n      assert_msg(instance and memcached_server_error(instance), \" \");\n      if (instance and memcached_server_error(instance)) {\n        rc = memcached_server_error_return(instance);\n      }\n    }\n\n    *ret = rc;\n  }\n  memcached_free(memc_ptr);\n\n  return memcached_success(*ret);\n}",
          "includes": [
            "#include \"libmemcachedutil/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcachedutil/common.h\"\n\nbool libmemcached_util_ping(const char *hostname, in_port_t port, memcached_return_t *ret) {\n  memcached_return_t unused;\n  if (ret == NULL) {\n    ret = &unused;\n  }\n\n  memcached_st *memc_ptr = memcached_create(NULL);\n  if (memc_ptr == NULL) {\n    *ret = MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n    return false;\n  }\n\n  if (memcached_success(\n          (*ret = memcached_behavior_set(memc_ptr, MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT, 400000))))\n  {\n    memcached_return_t rc = memcached_server_add(memc_ptr, hostname, port);\n    if (memcached_success(rc)) {\n      rc = memcached_version(memc_ptr);\n    }\n\n    if (memcached_failed(rc) and rc == MEMCACHED_SOME_ERRORS) {\n      const memcached_instance_st *instance = memcached_server_instance_by_position(memc_ptr, 0);\n\n      assert_msg(instance and memcached_server_error(instance), \" \");\n      if (instance and memcached_server_error(instance)) {\n        rc = memcached_server_error_return(instance);\n      }\n    }\n\n    *ret = rc;\n  }\n  memcached_free(memc_ptr);\n\n  return memcached_success(*ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"libmemcachedutil/common.h\"\n\nbool libmemcached_util_ping2(const char *hostname, in_port_t port, const char *username,\n                             const char *password, memcached_return_t *ret) {\n  if (username == NULL) {\n    return libmemcached_util_ping(hostname, port, ret);\n  }\n\n  memcached_return_t unused;\n  if (not ret)\n    ret = &unused;\n\n  if (LIBMEMCACHED_WITH_SASL_SUPPORT == 0) {\n    *ret = MEMCACHED_NOT_SUPPORTED;\n    return false;\n  }\n\n  memcached_st *memc_ptr = memcached_create(NULL);\n  if (not memc_ptr) {\n    *ret = MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n    return false;\n  }\n\n  if (memcached_failed(*ret = memcached_set_sasl_auth_data(memc_ptr, username, password))) {\n    memcached_free(memc_ptr);\n    return false;\n  }\n\n  memcached_return_t rc = memcached_server_add(memc_ptr, hostname, port);\n  if (memcached_success(rc)) {\n    rc = memcached_version(memc_ptr);\n  }\n\n  if (memcached_failed(rc) and rc == MEMCACHED_SOME_ERRORS) {\n    const memcached_instance_st *instance = memcached_server_instance_by_position(memc_ptr, 0);\n\n    assert_msg(instance and memcached_server_error(instance), \" \");\n    if (instance and memcached_server_error(instance)) {\n      rc = memcached_server_error_return(instance);\n    }\n  }\n  memcached_free(memc_ptr);\n\n  *ret = rc;\n\n  return memcached_success(rc);\n}"
  },
  {
    "function_name": "libmemcached_util_ping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcachedutil/ping.cc",
    "lines": "18-52",
    "snippet": "bool libmemcached_util_ping(const char *hostname, in_port_t port, memcached_return_t *ret) {\n  memcached_return_t unused;\n  if (ret == NULL) {\n    ret = &unused;\n  }\n\n  memcached_st *memc_ptr = memcached_create(NULL);\n  if (memc_ptr == NULL) {\n    *ret = MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n    return false;\n  }\n\n  if (memcached_success(\n          (*ret = memcached_behavior_set(memc_ptr, MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT, 400000))))\n  {\n    memcached_return_t rc = memcached_server_add(memc_ptr, hostname, port);\n    if (memcached_success(rc)) {\n      rc = memcached_version(memc_ptr);\n    }\n\n    if (memcached_failed(rc) and rc == MEMCACHED_SOME_ERRORS) {\n      const memcached_instance_st *instance = memcached_server_instance_by_position(memc_ptr, 0);\n\n      assert_msg(instance and memcached_server_error(instance), \" \");\n      if (instance and memcached_server_error(instance)) {\n        rc = memcached_server_error_return(instance);\n      }\n    }\n\n    *ret = rc;\n  }\n  memcached_free(memc_ptr);\n\n  return memcached_success(*ret);\n}",
    "includes": [
      "#include \"libmemcachedutil/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "*ret"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_free",
          "args": [
            "memc_ptr"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/memcached.cc",
          "lines": "257-261",
          "snippet": "void memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}",
          "includes": [
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nvoid memcached_free(memcached_st *ptr) {\n  if (ptr) {\n    memcached_free_ex(ptr, true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_server_error_return",
          "args": [
            "instance"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_error_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/error.cc",
          "lines": "541-551",
          "snippet": "memcached_return_t memcached_server_error_return(const memcached_instance_st *ptr) {\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (ptr->error_messages) {\n    return ptr->error_messages->rc;\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <cstdio>",
            "#include <cstdarg>",
            "#include <cerrno>",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cstdio>\n#include <cstdarg>\n#include <cerrno>\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_server_error_return(const memcached_instance_st *ptr) {\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  if (ptr->error_messages) {\n    return ptr->error_messages->rc;\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_msg",
          "args": [
            "instance and memcached_server_error(instance)",
            "\" \""
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_instance_by_position",
          "args": [
            "memc_ptr",
            "0"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_failed",
          "args": [
            "rc"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_version",
          "args": [
            "memc_ptr"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/version.cc",
          "lines": "164-184",
          "snippet": "memcached_return_t memcached_version(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    memcached_return_t rc;\n    if (memcached_failed(rc = initialize_query(memc, true))) {\n      return rc;\n    }\n\n    if (memcached_is_udp(memc)) {\n      return MEMCACHED_NOT_SUPPORTED;\n    }\n\n    if (memcached_is_binary(memc)) {\n      return memcached_version_binary(memc);\n    }\n\n    return memcached_version_textual(memc);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}",
          "includes": [
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_version(memcached_st *shell) {\n  Memcached *memc = memcached2Memcached(shell);\n  if (memc) {\n    memcached_return_t rc;\n    if (memcached_failed(rc = initialize_query(memc, true))) {\n      return rc;\n    }\n\n    if (memcached_is_udp(memc)) {\n      return MEMCACHED_NOT_SUPPORTED;\n    }\n\n    if (memcached_is_binary(memc)) {\n      return memcached_version_binary(memc);\n    }\n\n    return memcached_version_textual(memc);\n  }\n\n  return MEMCACHED_INVALID_ARGUMENTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "rc"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_server_add",
          "args": [
            "memc_ptr",
            "hostname",
            "port"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_server_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/hosts.cc",
          "lines": "458-460",
          "snippet": "memcached_return_t memcached_server_add(memcached_st *shell, const char *hostname, in_port_t port) {\n  return memcached_server_add_with_weight(shell, hostname, port, 0);\n}",
          "includes": [
            "#include <cmath>",
            "#include \"p9y/random.hpp\"",
            "#include \"p9y/gettimeofday.hpp\"",
            "#include \"libmemcached/assert.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cmath>\n#include \"p9y/random.hpp\"\n#include \"p9y/gettimeofday.hpp\"\n#include \"libmemcached/assert.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_server_add(memcached_st *shell, const char *hostname, in_port_t port) {\n  return memcached_server_add_with_weight(shell, hostname, port, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_success",
          "args": [
            "(*ret = memcached_behavior_set(memc_ptr, MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT, 400000))"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcached_behavior_set",
          "args": [
            "memc_ptr",
            "MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT",
            "400000"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "memcached_behavior_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/behavior.cc",
          "lines": "48-282",
          "snippet": "memcached_return_t memcached_behavior_set(memcached_st *shell, const memcached_behavior_t flag,\n                                          uint64_t data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    ptr->number_of_replicas = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    ptr->io_msg_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    ptr->io_bytes_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    ptr->io_key_prefetch = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    ptr->snd_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    ptr->rcv_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    if (data == 0) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT requires a value greater then zero.\"));\n    }\n    ptr->server_failure_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    ptr->server_timeout_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    if (data) {\n      ptr->flags.verify_key = false;\n    }\n    ptr->flags.binary_protocol = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    ptr->flags.support_cas = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    ptr->flags.no_block = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    if (memcached_is_udp(ptr)) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS cannot be set while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    ptr->flags.buffer_requests = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    ptr->flags.use_udp = bool(data);\n    if (bool(data)) {\n      ptr->flags.reply = false;\n      ptr->flags.buffer_requests = false;\n    } else {\n      ptr->flags.reply = true;\n    }\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    ptr->flags.tcp_nodelay = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    ptr->flags.tcp_keepalive = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return memcached_behavior_set_distribution(ptr, (memcached_server_distribution_t) data);\n\n  case MEMCACHED_BEHAVIOR_KETAMA: {\n    if (data) // Turn on\n    {\n      return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    }\n\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_MODULA);\n  }\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED: {\n    if (bool(data) == false) {\n      return memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_KETAMA, true);\n    }\n\n    (void) memcached_behavior_set_key_hash(ptr, MEMCACHED_HASH_MD5);\n    (void) memcached_behavior_set_distribution_hash(ptr, MEMCACHED_HASH_MD5);\n    /**\n      @note We try to keep the same distribution going. This should be deprecated and rewritten.\n    */\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED);\n  }\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return memcached_behavior_set_key_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return memcached_behavior_set_distribution_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS has been deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    if (ptr->flags.binary_protocol) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_VERIFY_KEY if the binary protocol has been enabled.\"));\n    }\n    ptr->flags.verify_key = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS: {\n    ptr->flags.use_sort_hosts = bool(data);\n    return run_distribution(ptr);\n  }\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    ptr->poll_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    ptr->connect_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    ptr->retry_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    ptr->dead_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE:\n    ptr->send_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE:\n    ptr->recv_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    ptr->tcp_keepidle = (uint32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    return memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                               memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    ptr->flags.hash_with_namespace = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    if (memcached_is_udp(ptr) and bool(data) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_NOREPLY cannot be disabled while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    // We reverse the logic here to make it easier to understand throughout the\n    // code.\n    ptr->flags.reply = bool(data) ? false : true;\n    break;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    srandom((uint32_t) time(NULL));\n    ptr->flags.randomize_replica_read = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_CORK is now incorporated into the driver by default.\"));\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_LOAD_FROM_FILE can not be set with memcached_behavior_set()\"));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    /* Shouldn't get here */\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_set()\");\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid behavior passed to memcached_behavior_set()\"));\n  }\n\n  return MEMCACHED_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <ctime>",
            "#include \"p9y/random.hpp\"",
            "#include \"libmemcached/virtual_bucket.h\"",
            "#include \"libmemcached/options.hpp\"",
            "#include \"libmemcached/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <ctime>\n#include \"p9y/random.hpp\"\n#include \"libmemcached/virtual_bucket.h\"\n#include \"libmemcached/options.hpp\"\n#include \"libmemcached/common.h\"\n\nmemcached_return_t memcached_behavior_set(memcached_st *shell, const memcached_behavior_t flag,\n                                          uint64_t data) {\n  Memcached *ptr = memcached2Memcached(shell);\n  if (ptr == NULL) {\n    return MEMCACHED_INVALID_ARGUMENTS;\n  }\n\n  switch (flag) {\n  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:\n    ptr->number_of_replicas = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:\n    ptr->io_msg_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:\n    ptr->io_bytes_watermark = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH:\n    ptr->io_key_prefetch = (uint32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_SND_TIMEOUT:\n    ptr->snd_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:\n    ptr->rcv_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:\n    if (data == 0) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT requires a value greater then zero.\"));\n    }\n    ptr->server_failure_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SERVER_TIMEOUT_LIMIT:\n    ptr->server_timeout_limit = uint32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    if (data) {\n      ptr->flags.verify_key = false;\n    }\n    ptr->flags.binary_protocol = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SUPPORT_CAS:\n    ptr->flags.support_cas = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NO_BLOCK:\n    ptr->flags.no_block = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_BUFFER_REQUESTS:\n    if (memcached_is_udp(ptr)) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_BUFFER_REQUESTS cannot be set while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    ptr->flags.buffer_requests = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USE_UDP:\n    send_quit(\n        ptr); // We need t shutdown all of the connections to make sure we do the correct protocol\n    ptr->flags.use_udp = bool(data);\n    if (bool(data)) {\n      ptr->flags.reply = false;\n      ptr->flags.buffer_requests = false;\n    } else {\n      ptr->flags.reply = true;\n    }\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_NODELAY:\n    ptr->flags.tcp_nodelay = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPALIVE:\n    ptr->flags.tcp_keepalive = bool(data);\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DISTRIBUTION:\n    return memcached_behavior_set_distribution(ptr, (memcached_server_distribution_t) data);\n\n  case MEMCACHED_BEHAVIOR_KETAMA: {\n    if (data) // Turn on\n    {\n      return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA);\n    }\n\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_MODULA);\n  }\n\n  case MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED: {\n    if (bool(data) == false) {\n      return memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_KETAMA, true);\n    }\n\n    (void) memcached_behavior_set_key_hash(ptr, MEMCACHED_HASH_MD5);\n    (void) memcached_behavior_set_distribution_hash(ptr, MEMCACHED_HASH_MD5);\n    /**\n      @note We try to keep the same distribution going. This should be deprecated and rewritten.\n    */\n    return memcached_behavior_set_distribution(ptr, MEMCACHED_DISTRIBUTION_CONSISTENT_WEIGHTED);\n  }\n\n  case MEMCACHED_BEHAVIOR_HASH:\n    return memcached_behavior_set_key_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_KETAMA_HASH:\n    return memcached_behavior_set_distribution_hash(ptr, (memcached_hash_t)(data));\n\n  case MEMCACHED_BEHAVIOR_CACHE_LOOKUPS:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\"MEMCACHED_BEHAVIOR_CACHE_LOOKUPS has been deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_VERIFY_KEY:\n    if (ptr->flags.binary_protocol) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\n              \"MEMCACHED_BEHAVIOR_VERIFY_KEY if the binary protocol has been enabled.\"));\n    }\n    ptr->flags.verify_key = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SORT_HOSTS: {\n    ptr->flags.use_sort_hosts = bool(data);\n    return run_distribution(ptr);\n  }\n\n  case MEMCACHED_BEHAVIOR_POLL_TIMEOUT:\n    ptr->poll_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT:\n    ptr->connect_timeout = (int32_t) data;\n    break;\n\n  case MEMCACHED_BEHAVIOR_RETRY_TIMEOUT:\n    ptr->retry_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_DEAD_TIMEOUT:\n    ptr->dead_timeout = int32_t(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE:\n    ptr->send_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE:\n    ptr->recv_size = (int32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_TCP_KEEPIDLE:\n    ptr->tcp_keepidle = (uint32_t) data;\n    send_quit(ptr);\n    break;\n\n  case MEMCACHED_BEHAVIOR_USER_DATA:\n    return memcached_set_error(*ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n                               memcached_literal_param(\"MEMCACHED_BEHAVIOR_USER_DATA deprecated.\"));\n\n  case MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY:\n    ptr->flags.hash_with_namespace = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_NOREPLY:\n    if (memcached_is_udp(ptr) and bool(data) == false) {\n      return memcached_set_error(\n          *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n          memcached_literal_param(\"MEMCACHED_BEHAVIOR_NOREPLY cannot be disabled while \"\n                                  \"MEMCACHED_BEHAVIOR_USE_UDP is enabled.\"));\n    }\n    // We reverse the logic here to make it easier to understand throughout the\n    // code.\n    ptr->flags.reply = bool(data) ? false : true;\n    break;\n\n  case MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS:\n    ptr->flags.auto_eject_hosts = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ:\n    srandom((uint32_t) time(NULL));\n    ptr->flags.randomize_replica_read = bool(data);\n    break;\n\n  case MEMCACHED_BEHAVIOR_CORK:\n    return memcached_set_error(\n        *ptr, MEMCACHED_DEPRECATED, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_CORK is now incorporated into the driver by default.\"));\n\n  case MEMCACHED_BEHAVIOR_LOAD_FROM_FILE:\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\n            \"MEMCACHED_BEHAVIOR_LOAD_FROM_FILE can not be set with memcached_behavior_set()\"));\n\n  case MEMCACHED_BEHAVIOR_MAX:\n  default:\n    /* Shouldn't get here */\n    assert_msg(0, \"Invalid behavior passed to memcached_behavior_set()\");\n    return memcached_set_error(\n        *ptr, MEMCACHED_INVALID_ARGUMENTS, MEMCACHED_AT,\n        memcached_literal_param(\"Invalid behavior passed to memcached_behavior_set()\"));\n  }\n\n  return MEMCACHED_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcached_create",
          "args": [
            "NULL"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"libmemcachedutil/common.h\"\n\nbool libmemcached_util_ping(const char *hostname, in_port_t port, memcached_return_t *ret) {\n  memcached_return_t unused;\n  if (ret == NULL) {\n    ret = &unused;\n  }\n\n  memcached_st *memc_ptr = memcached_create(NULL);\n  if (memc_ptr == NULL) {\n    *ret = MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n    return false;\n  }\n\n  if (memcached_success(\n          (*ret = memcached_behavior_set(memc_ptr, MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT, 400000))))\n  {\n    memcached_return_t rc = memcached_server_add(memc_ptr, hostname, port);\n    if (memcached_success(rc)) {\n      rc = memcached_version(memc_ptr);\n    }\n\n    if (memcached_failed(rc) and rc == MEMCACHED_SOME_ERRORS) {\n      const memcached_instance_st *instance = memcached_server_instance_by_position(memc_ptr, 0);\n\n      assert_msg(instance and memcached_server_error(instance), \" \");\n      if (instance and memcached_server_error(instance)) {\n        rc = memcached_server_error_return(instance);\n      }\n    }\n\n    *ret = rc;\n  }\n  memcached_free(memc_ptr);\n\n  return memcached_success(*ret);\n}"
  }
]