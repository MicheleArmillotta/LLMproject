[
  {
    "function_name": "ntlm_unpack_auth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/ntlmauth/ntlmauth.cc",
    "lines": "235-273",
    "snippet": "int\nntlm_unpack_auth(const ntlm_authenticate *auth, char *user, char *domain, const int32_t size)\n{\n    lstring rv;\n\n    if (ntlm_validate_packet(&auth->hdr, NTLM_AUTHENTICATE)) {\n        fprintf(stderr, \"ntlm_unpack_auth: header check fails\\n\");\n        return NTLM_ERR_PROTOCOL;\n    }\n    debug(\"ntlm_unpack_auth: size of %d\\n\", size);\n    debug(\"ntlm_unpack_auth: flg %08x\\n\", auth->flags);\n    debug(\"ntlm_unpack_auth: lmr o(%d) l(%d)\\n\", le32toh(auth->lmresponse.offset), auth->lmresponse.len);\n    debug(\"ntlm_unpack_auth: ntr o(%d) l(%d)\\n\", le32toh(auth->ntresponse.offset), auth->ntresponse.len);\n    debug(\"ntlm_unpack_auth: dom o(%d) l(%d)\\n\", le32toh(auth->domain.offset), auth->domain.len);\n    debug(\"ntlm_unpack_auth: usr o(%d) l(%d)\\n\", le32toh(auth->user.offset), auth->user.len);\n    debug(\"ntlm_unpack_auth: wst o(%d) l(%d)\\n\", le32toh(auth->workstation.offset), auth->workstation.len);\n    debug(\"ntlm_unpack_auth: key o(%d) l(%d)\\n\", le32toh(auth->sessionkey.offset), auth->sessionkey.len);\n\n    rv = ntlm_fetch_string(&auth->hdr, size, &auth->domain, auth->flags);\n    if (rv.l > 0) {\n        memcpy(domain, rv.str, rv.l);\n        domain[rv.l] = '\\0';\n        debug(\"ntlm_unpack_auth: Domain '%s' (len=%d).\\n\", domain, rv.l);\n    }\n    if (rv.l >= size) {\n        debug(\"ntlm_unpack_auth: Domain length %d too big for %d byte packet.\\n\", rv.l , size);\n        return NTLM_ERR_BLOB;\n    }\n\n    rv = ntlm_fetch_string(&auth->hdr, size, &auth->user, auth->flags);\n    if (rv.l > 0) {\n        memcpy(user, rv.str, rv.l);\n        user[rv.l] = '\\0';\n        debug(\"ntlm_unpack_auth: Username '%s' (len=%d).\\n\", user, rv.l);\n    } else\n        return NTLM_ERR_LOGON;\n\n    return NTLM_ERR_NONE;\n}",
    "includes": [
      "#include \"util.h\"       /* for base64-related stuff */",
      "#include \"ntlmauth/ntlmauth.h\"",
      "#include <strings.h>",
      "#include <random>",
      "#include <cstring>",
      "#include \"squid.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"ntlm_unpack_auth: Username '%s' (len=%d).\\n\"",
            "user",
            "rv.l"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "user",
            "rv.str",
            "rv.l"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntlm_fetch_string",
          "args": [
            "&auth->hdr",
            "size",
            "&auth->user",
            "auth->flags"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "ntlm_fetch_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/ntlmauth/ntlmauth.cc",
          "lines": "96-145",
          "snippet": "lstring\nntlm_fetch_string(const ntlmhdr *packet, const int32_t packet_size, const strhdr * str, const uint32_t flags)\n{\n    static char buf[NTLM_MAX_FIELD_LENGTH];\n    lstring rv;\n    char *d;\n\n    rv.str = NULL;\n    rv.l = -1;\n\n    int16_t l = le16toh(str->len);\n    int32_t o = le32toh(str->offset);\n    // debug(\"ntlm_fetch_string(plength=%d,l=%d,o=%d)\\n\",packet_size,l,o);\n\n    if (l < 0 || l > NTLM_MAX_FIELD_LENGTH || o + l > packet_size || o == 0) {\n        debug(\"ntlm_fetch_string: insane data (pkt-sz: %d, fetch len: %d, offset: %d)\\n\", packet_size,l,o);\n        return rv;\n    }\n    rv.str = (char *)packet + o;\n    rv.l = 0;\n    if ((flags & NTLM_NEGOTIATE_ASCII) == 0) {\n        /* UNICODE string */\n        unsigned short *s = (unsigned short *)rv.str;\n        rv.str = d = buf;\n\n        for (uint32_t len = (l>>1); len; ++s, --len) {\n            uint16_t c = le16toh(*s);\n            if (c > 254 || c == '\\0') {\n                fprintf(stderr, \"ntlmssp: bad unicode: %04x\\n\", c);\n                return rv;\n            }\n            *d = static_cast<char>(c&0xFF);\n            ++d;\n            ++rv.l;\n        }\n    } else {\n        /* ASCII/OEM string */\n        char *sc = rv.str;\n\n        for (; l>=0; ++sc, --l) {\n            if (*sc == '\\0' || !xisprint(*sc)) {\n                fprintf(stderr, \"ntlmssp: bad ascii: %04x\\n\", *sc);\n                return rv;\n            }\n            ++rv.l;\n        }\n    }\n\n    return rv;\n}",
          "includes": [
            "#include \"util.h\"       /* for base64-related stuff */",
            "#include \"ntlmauth/ntlmauth.h\"",
            "#include <strings.h>",
            "#include <random>",
            "#include <cstring>",
            "#include \"squid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"       /* for base64-related stuff */\n#include \"ntlmauth/ntlmauth.h\"\n#include <strings.h>\n#include <random>\n#include <cstring>\n#include \"squid.h\"\n\nlstring\nntlm_fetch_string(const ntlmhdr *packet, const int32_t packet_size, const strhdr * str, const uint32_t flags)\n{\n    static char buf[NTLM_MAX_FIELD_LENGTH];\n    lstring rv;\n    char *d;\n\n    rv.str = NULL;\n    rv.l = -1;\n\n    int16_t l = le16toh(str->len);\n    int32_t o = le32toh(str->offset);\n    // debug(\"ntlm_fetch_string(plength=%d,l=%d,o=%d)\\n\",packet_size,l,o);\n\n    if (l < 0 || l > NTLM_MAX_FIELD_LENGTH || o + l > packet_size || o == 0) {\n        debug(\"ntlm_fetch_string: insane data (pkt-sz: %d, fetch len: %d, offset: %d)\\n\", packet_size,l,o);\n        return rv;\n    }\n    rv.str = (char *)packet + o;\n    rv.l = 0;\n    if ((flags & NTLM_NEGOTIATE_ASCII) == 0) {\n        /* UNICODE string */\n        unsigned short *s = (unsigned short *)rv.str;\n        rv.str = d = buf;\n\n        for (uint32_t len = (l>>1); len; ++s, --len) {\n            uint16_t c = le16toh(*s);\n            if (c > 254 || c == '\\0') {\n                fprintf(stderr, \"ntlmssp: bad unicode: %04x\\n\", c);\n                return rv;\n            }\n            *d = static_cast<char>(c&0xFF);\n            ++d;\n            ++rv.l;\n        }\n    } else {\n        /* ASCII/OEM string */\n        char *sc = rv.str;\n\n        for (; l>=0; ++sc, --l) {\n            if (*sc == '\\0' || !xisprint(*sc)) {\n                fprintf(stderr, \"ntlmssp: bad ascii: %04x\\n\", *sc);\n                return rv;\n            }\n            ++rv.l;\n        }\n    }\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"ntlm_unpack_auth: Domain length %d too big for %d byte packet.\\n\"",
            "rv.l",
            "size"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"ntlm_unpack_auth: Domain '%s' (len=%d).\\n\"",
            "domain",
            "rv.l"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "domain",
            "rv.str",
            "rv.l"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"ntlm_unpack_auth: key o(%d) l(%d)\\n\"",
            "le32toh(auth->sessionkey.offset)",
            "auth->sessionkey.len"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "auth->sessionkey.offset"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"ntlm_unpack_auth: wst o(%d) l(%d)\\n\"",
            "le32toh(auth->workstation.offset)",
            "auth->workstation.len"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "auth->workstation.offset"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"ntlm_unpack_auth: usr o(%d) l(%d)\\n\"",
            "le32toh(auth->user.offset)",
            "auth->user.len"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "auth->user.offset"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"ntlm_unpack_auth: dom o(%d) l(%d)\\n\"",
            "le32toh(auth->domain.offset)",
            "auth->domain.len"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "auth->domain.offset"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"ntlm_unpack_auth: ntr o(%d) l(%d)\\n\"",
            "le32toh(auth->ntresponse.offset)",
            "auth->ntresponse.len"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "auth->ntresponse.offset"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"ntlm_unpack_auth: lmr o(%d) l(%d)\\n\"",
            "le32toh(auth->lmresponse.offset)",
            "auth->lmresponse.len"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "auth->lmresponse.offset"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"ntlm_unpack_auth: flg %08x\\n\"",
            "auth->flags"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"ntlm_unpack_auth: size of %d\\n\"",
            "size"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ntlm_unpack_auth: header check fails\\n\""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntlm_validate_packet",
          "args": [
            "&auth->hdr",
            "NTLM_AUTHENTICATE"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ntlm_validate_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/ntlmauth/ntlmauth.cc",
          "lines": "65-85",
          "snippet": "int\nntlm_validate_packet(const ntlmhdr * hdr, const int32_t type)\n{\n    /*\n     * Must be the correct security package and request type.\n     * The 8 bytes compared includes the ASCII 'NUL'.\n     */\n    if (memcmp(hdr->signature, \"NTLMSSP\", 8) != 0) {\n        fprintf(stderr, \"ntlmCheckHeader: bad header signature\\n\");\n        return NTLM_ERR_BLOB;\n    }\n    if (type == NTLM_ANY)\n        return NTLM_ERR_NONE;\n\n    if ((int32_t)le32toh(hdr->type) != type) {\n        /* don't report this error - it's ok as we do a if() around this function */\n        debug(\"ntlm_validate_packet: type is %d, wanted %d\\n\", le32toh(hdr->type), type);\n        return NTLM_ERR_PROTOCOL;\n    }\n    return NTLM_ERR_NONE;\n}",
          "includes": [
            "#include \"util.h\"       /* for base64-related stuff */",
            "#include \"ntlmauth/ntlmauth.h\"",
            "#include <strings.h>",
            "#include <random>",
            "#include <cstring>",
            "#include \"squid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"       /* for base64-related stuff */\n#include \"ntlmauth/ntlmauth.h\"\n#include <strings.h>\n#include <random>\n#include <cstring>\n#include \"squid.h\"\n\nint\nntlm_validate_packet(const ntlmhdr * hdr, const int32_t type)\n{\n    /*\n     * Must be the correct security package and request type.\n     * The 8 bytes compared includes the ASCII 'NUL'.\n     */\n    if (memcmp(hdr->signature, \"NTLMSSP\", 8) != 0) {\n        fprintf(stderr, \"ntlmCheckHeader: bad header signature\\n\");\n        return NTLM_ERR_BLOB;\n    }\n    if (type == NTLM_ANY)\n        return NTLM_ERR_NONE;\n\n    if ((int32_t)le32toh(hdr->type) != type) {\n        /* don't report this error - it's ok as we do a if() around this function */\n        debug(\"ntlm_validate_packet: type is %d, wanted %d\\n\", le32toh(hdr->type), type);\n        return NTLM_ERR_PROTOCOL;\n    }\n    return NTLM_ERR_NONE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"       /* for base64-related stuff */\n#include \"ntlmauth/ntlmauth.h\"\n#include <strings.h>\n#include <random>\n#include <cstring>\n#include \"squid.h\"\n\nint\nntlm_unpack_auth(const ntlm_authenticate *auth, char *user, char *domain, const int32_t size)\n{\n    lstring rv;\n\n    if (ntlm_validate_packet(&auth->hdr, NTLM_AUTHENTICATE)) {\n        fprintf(stderr, \"ntlm_unpack_auth: header check fails\\n\");\n        return NTLM_ERR_PROTOCOL;\n    }\n    debug(\"ntlm_unpack_auth: size of %d\\n\", size);\n    debug(\"ntlm_unpack_auth: flg %08x\\n\", auth->flags);\n    debug(\"ntlm_unpack_auth: lmr o(%d) l(%d)\\n\", le32toh(auth->lmresponse.offset), auth->lmresponse.len);\n    debug(\"ntlm_unpack_auth: ntr o(%d) l(%d)\\n\", le32toh(auth->ntresponse.offset), auth->ntresponse.len);\n    debug(\"ntlm_unpack_auth: dom o(%d) l(%d)\\n\", le32toh(auth->domain.offset), auth->domain.len);\n    debug(\"ntlm_unpack_auth: usr o(%d) l(%d)\\n\", le32toh(auth->user.offset), auth->user.len);\n    debug(\"ntlm_unpack_auth: wst o(%d) l(%d)\\n\", le32toh(auth->workstation.offset), auth->workstation.len);\n    debug(\"ntlm_unpack_auth: key o(%d) l(%d)\\n\", le32toh(auth->sessionkey.offset), auth->sessionkey.len);\n\n    rv = ntlm_fetch_string(&auth->hdr, size, &auth->domain, auth->flags);\n    if (rv.l > 0) {\n        memcpy(domain, rv.str, rv.l);\n        domain[rv.l] = '\\0';\n        debug(\"ntlm_unpack_auth: Domain '%s' (len=%d).\\n\", domain, rv.l);\n    }\n    if (rv.l >= size) {\n        debug(\"ntlm_unpack_auth: Domain length %d too big for %d byte packet.\\n\", rv.l , size);\n        return NTLM_ERR_BLOB;\n    }\n\n    rv = ntlm_fetch_string(&auth->hdr, size, &auth->user, auth->flags);\n    if (rv.l > 0) {\n        memcpy(user, rv.str, rv.l);\n        user[rv.l] = '\\0';\n        debug(\"ntlm_unpack_auth: Username '%s' (len=%d).\\n\", user, rv.l);\n    } else\n        return NTLM_ERR_LOGON;\n\n    return NTLM_ERR_NONE;\n}"
  },
  {
    "function_name": "ntlm_make_challenge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/ntlmauth/ntlmauth.cc",
    "lines": "198-218",
    "snippet": "void\nntlm_make_challenge(ntlm_challenge *ch,\n                    const char *domain, const char *,\n                    const char *challenge_nonce, const int challenge_nonce_len,\n                    const uint32_t flags)\n{\n    int pl = 0;\n    memset(ch, 0, sizeof(ntlm_challenge));  /* reset */\n    memcpy(ch->hdr.signature, \"NTLMSSP\", 8);        /* set the signature */\n    ch->hdr.type = htole32(NTLM_CHALLENGE); /* this is a challenge */\n    if (domain != NULL) {\n        // silently truncate the domain if it exceeds 2^16-1 bytes.\n        // NTLM packets normally expect 2^8 bytes of domain.\n        const uint16_t dlen = strlen(domain) & 0xFFFF;\n        ntlm_add_to_payload(&ch->hdr, ch->payload, &pl, &ch->target, domain, dlen);\n    }\n    ch->flags = htole32(flags);\n    ch->context_low = 0;        /* check this out */\n    ch->context_high = 0;\n    memcpy(ch->challenge, challenge_nonce, challenge_nonce_len);\n}",
    "includes": [
      "#include \"util.h\"       /* for base64-related stuff */",
      "#include \"ntlmauth/ntlmauth.h\"",
      "#include <strings.h>",
      "#include <random>",
      "#include <cstring>",
      "#include \"squid.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ch->challenge",
            "challenge_nonce",
            "challenge_nonce_len"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "flags"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntlm_add_to_payload",
          "args": [
            "&ch->hdr",
            "ch->payload",
            "&pl",
            "&ch->target",
            "domain",
            "dlen"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "ntlm_add_to_payload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/ntlmauth/ntlmauth.cc",
          "lines": "153-169",
          "snippet": "void\nntlm_add_to_payload(const ntlmhdr *packet_hdr,\n                    char *payload,\n                    int *payload_length,\n                    strhdr * hdr,\n                    const char *toadd,\n                    const uint16_t toadd_length)\n{\n    int l = (*payload_length);\n    memcpy(payload + l, toadd, toadd_length);\n\n    hdr->len = htole16(toadd_length);\n    hdr->maxlen = htole16(toadd_length);\n    const off_t o = l + reinterpret_cast<const ntlmhdr *>(payload) - packet_hdr;\n    hdr->offset = htole32(o & 0xFFFFFFFF);\n    (*payload_length) += toadd_length;\n}",
          "includes": [
            "#include \"util.h\"       /* for base64-related stuff */",
            "#include \"ntlmauth/ntlmauth.h\"",
            "#include <strings.h>",
            "#include <random>",
            "#include <cstring>",
            "#include \"squid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"       /* for base64-related stuff */\n#include \"ntlmauth/ntlmauth.h\"\n#include <strings.h>\n#include <random>\n#include <cstring>\n#include \"squid.h\"\n\nvoid\nntlm_add_to_payload(const ntlmhdr *packet_hdr,\n                    char *payload,\n                    int *payload_length,\n                    strhdr * hdr,\n                    const char *toadd,\n                    const uint16_t toadd_length)\n{\n    int l = (*payload_length);\n    memcpy(payload + l, toadd, toadd_length);\n\n    hdr->len = htole16(toadd_length);\n    hdr->maxlen = htole16(toadd_length);\n    const off_t o = l + reinterpret_cast<const ntlmhdr *>(payload) - packet_hdr;\n    hdr->offset = htole32(o & 0xFFFFFFFF);\n    (*payload_length) += toadd_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "domain"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "NTLM_CHALLENGE"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ch->hdr.signature",
            "\"NTLMSSP\"",
            "8"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ch",
            "0",
            "sizeof(ntlm_challenge)"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"       /* for base64-related stuff */\n#include \"ntlmauth/ntlmauth.h\"\n#include <strings.h>\n#include <random>\n#include <cstring>\n#include \"squid.h\"\n\nvoid\nntlm_make_challenge(ntlm_challenge *ch,\n                    const char *domain, const char *,\n                    const char *challenge_nonce, const int challenge_nonce_len,\n                    const uint32_t flags)\n{\n    int pl = 0;\n    memset(ch, 0, sizeof(ntlm_challenge));  /* reset */\n    memcpy(ch->hdr.signature, \"NTLMSSP\", 8);        /* set the signature */\n    ch->hdr.type = htole32(NTLM_CHALLENGE); /* this is a challenge */\n    if (domain != NULL) {\n        // silently truncate the domain if it exceeds 2^16-1 bytes.\n        // NTLM packets normally expect 2^8 bytes of domain.\n        const uint16_t dlen = strlen(domain) & 0xFFFF;\n        ntlm_add_to_payload(&ch->hdr, ch->payload, &pl, &ch->target, domain, dlen);\n    }\n    ch->flags = htole32(flags);\n    ch->context_low = 0;        /* check this out */\n    ch->context_high = 0;\n    memcpy(ch->challenge, challenge_nonce, challenge_nonce_len);\n}"
  },
  {
    "function_name": "ntlm_make_nonce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/ntlmauth/ntlmauth.cc",
    "lines": "184-192",
    "snippet": "void\nntlm_make_nonce(char *nonce)\n{\n    static std::mt19937 mt(time(0));\n    static xuniform_int_distribution<uint8_t> dist;\n\n    for (int i = 0; i < NTLM_NONCE_LEN; ++i)\n        nonce[i] = static_cast<char>(dist(mt) & 0xFF);\n}",
    "includes": [
      "#include \"util.h\"       /* for base64-related stuff */",
      "#include \"ntlmauth/ntlmauth.h\"",
      "#include <strings.h>",
      "#include <random>",
      "#include <cstring>",
      "#include \"squid.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<char>",
          "args": [
            "dist(mt) & 0xFF"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dist",
          "args": [
            "mt"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "0"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"       /* for base64-related stuff */\n#include \"ntlmauth/ntlmauth.h\"\n#include <strings.h>\n#include <random>\n#include <cstring>\n#include \"squid.h\"\n\nvoid\nntlm_make_nonce(char *nonce)\n{\n    static std::mt19937 mt(time(0));\n    static xuniform_int_distribution<uint8_t> dist;\n\n    for (int i = 0; i < NTLM_NONCE_LEN; ++i)\n        nonce[i] = static_cast<char>(dist(mt) & 0xFF);\n}"
  },
  {
    "function_name": "ntlm_add_to_payload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/ntlmauth/ntlmauth.cc",
    "lines": "153-169",
    "snippet": "void\nntlm_add_to_payload(const ntlmhdr *packet_hdr,\n                    char *payload,\n                    int *payload_length,\n                    strhdr * hdr,\n                    const char *toadd,\n                    const uint16_t toadd_length)\n{\n    int l = (*payload_length);\n    memcpy(payload + l, toadd, toadd_length);\n\n    hdr->len = htole16(toadd_length);\n    hdr->maxlen = htole16(toadd_length);\n    const off_t o = l + reinterpret_cast<const ntlmhdr *>(payload) - packet_hdr;\n    hdr->offset = htole32(o & 0xFFFFFFFF);\n    (*payload_length) += toadd_length;\n}",
    "includes": [
      "#include \"util.h\"       /* for base64-related stuff */",
      "#include \"ntlmauth/ntlmauth.h\"",
      "#include <strings.h>",
      "#include <random>",
      "#include <cstring>",
      "#include \"squid.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "o & 0xFFFFFFFF"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const ntlmhdr *>",
          "args": [
            "payload"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole16",
          "args": [
            "toadd_length"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole16",
          "args": [
            "toadd_length"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "payload + l",
            "toadd",
            "toadd_length"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"       /* for base64-related stuff */\n#include \"ntlmauth/ntlmauth.h\"\n#include <strings.h>\n#include <random>\n#include <cstring>\n#include \"squid.h\"\n\nvoid\nntlm_add_to_payload(const ntlmhdr *packet_hdr,\n                    char *payload,\n                    int *payload_length,\n                    strhdr * hdr,\n                    const char *toadd,\n                    const uint16_t toadd_length)\n{\n    int l = (*payload_length);\n    memcpy(payload + l, toadd, toadd_length);\n\n    hdr->len = htole16(toadd_length);\n    hdr->maxlen = htole16(toadd_length);\n    const off_t o = l + reinterpret_cast<const ntlmhdr *>(payload) - packet_hdr;\n    hdr->offset = htole32(o & 0xFFFFFFFF);\n    (*payload_length) += toadd_length;\n}"
  },
  {
    "function_name": "ntlm_fetch_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/ntlmauth/ntlmauth.cc",
    "lines": "96-145",
    "snippet": "lstring\nntlm_fetch_string(const ntlmhdr *packet, const int32_t packet_size, const strhdr * str, const uint32_t flags)\n{\n    static char buf[NTLM_MAX_FIELD_LENGTH];\n    lstring rv;\n    char *d;\n\n    rv.str = NULL;\n    rv.l = -1;\n\n    int16_t l = le16toh(str->len);\n    int32_t o = le32toh(str->offset);\n    // debug(\"ntlm_fetch_string(plength=%d,l=%d,o=%d)\\n\",packet_size,l,o);\n\n    if (l < 0 || l > NTLM_MAX_FIELD_LENGTH || o + l > packet_size || o == 0) {\n        debug(\"ntlm_fetch_string: insane data (pkt-sz: %d, fetch len: %d, offset: %d)\\n\", packet_size,l,o);\n        return rv;\n    }\n    rv.str = (char *)packet + o;\n    rv.l = 0;\n    if ((flags & NTLM_NEGOTIATE_ASCII) == 0) {\n        /* UNICODE string */\n        unsigned short *s = (unsigned short *)rv.str;\n        rv.str = d = buf;\n\n        for (uint32_t len = (l>>1); len; ++s, --len) {\n            uint16_t c = le16toh(*s);\n            if (c > 254 || c == '\\0') {\n                fprintf(stderr, \"ntlmssp: bad unicode: %04x\\n\", c);\n                return rv;\n            }\n            *d = static_cast<char>(c&0xFF);\n            ++d;\n            ++rv.l;\n        }\n    } else {\n        /* ASCII/OEM string */\n        char *sc = rv.str;\n\n        for (; l>=0; ++sc, --l) {\n            if (*sc == '\\0' || !xisprint(*sc)) {\n                fprintf(stderr, \"ntlmssp: bad ascii: %04x\\n\", *sc);\n                return rv;\n            }\n            ++rv.l;\n        }\n    }\n\n    return rv;\n}",
    "includes": [
      "#include \"util.h\"       /* for base64-related stuff */",
      "#include \"ntlmauth/ntlmauth.h\"",
      "#include <strings.h>",
      "#include <random>",
      "#include <cstring>",
      "#include \"squid.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ntlmssp: bad ascii: %04x\\n\"",
            "*sc"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xisprint",
          "args": [
            "*sc"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<char>",
          "args": [
            "c&0xFF"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ntlmssp: bad unicode: %04x\\n\"",
            "c"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16toh",
          "args": [
            "*s"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"ntlm_fetch_string: insane data (pkt-sz: %d, fetch len: %d, offset: %d)\\n\"",
            "packet_size",
            "l",
            "o"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "str->offset"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16toh",
          "args": [
            "str->len"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"       /* for base64-related stuff */\n#include \"ntlmauth/ntlmauth.h\"\n#include <strings.h>\n#include <random>\n#include <cstring>\n#include \"squid.h\"\n\nlstring\nntlm_fetch_string(const ntlmhdr *packet, const int32_t packet_size, const strhdr * str, const uint32_t flags)\n{\n    static char buf[NTLM_MAX_FIELD_LENGTH];\n    lstring rv;\n    char *d;\n\n    rv.str = NULL;\n    rv.l = -1;\n\n    int16_t l = le16toh(str->len);\n    int32_t o = le32toh(str->offset);\n    // debug(\"ntlm_fetch_string(plength=%d,l=%d,o=%d)\\n\",packet_size,l,o);\n\n    if (l < 0 || l > NTLM_MAX_FIELD_LENGTH || o + l > packet_size || o == 0) {\n        debug(\"ntlm_fetch_string: insane data (pkt-sz: %d, fetch len: %d, offset: %d)\\n\", packet_size,l,o);\n        return rv;\n    }\n    rv.str = (char *)packet + o;\n    rv.l = 0;\n    if ((flags & NTLM_NEGOTIATE_ASCII) == 0) {\n        /* UNICODE string */\n        unsigned short *s = (unsigned short *)rv.str;\n        rv.str = d = buf;\n\n        for (uint32_t len = (l>>1); len; ++s, --len) {\n            uint16_t c = le16toh(*s);\n            if (c > 254 || c == '\\0') {\n                fprintf(stderr, \"ntlmssp: bad unicode: %04x\\n\", c);\n                return rv;\n            }\n            *d = static_cast<char>(c&0xFF);\n            ++d;\n            ++rv.l;\n        }\n    } else {\n        /* ASCII/OEM string */\n        char *sc = rv.str;\n\n        for (; l>=0; ++sc, --l) {\n            if (*sc == '\\0' || !xisprint(*sc)) {\n                fprintf(stderr, \"ntlmssp: bad ascii: %04x\\n\", *sc);\n                return rv;\n            }\n            ++rv.l;\n        }\n    }\n\n    return rv;\n}"
  },
  {
    "function_name": "ntlm_validate_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/ntlmauth/ntlmauth.cc",
    "lines": "65-85",
    "snippet": "int\nntlm_validate_packet(const ntlmhdr * hdr, const int32_t type)\n{\n    /*\n     * Must be the correct security package and request type.\n     * The 8 bytes compared includes the ASCII 'NUL'.\n     */\n    if (memcmp(hdr->signature, \"NTLMSSP\", 8) != 0) {\n        fprintf(stderr, \"ntlmCheckHeader: bad header signature\\n\");\n        return NTLM_ERR_BLOB;\n    }\n    if (type == NTLM_ANY)\n        return NTLM_ERR_NONE;\n\n    if ((int32_t)le32toh(hdr->type) != type) {\n        /* don't report this error - it's ok as we do a if() around this function */\n        debug(\"ntlm_validate_packet: type is %d, wanted %d\\n\", le32toh(hdr->type), type);\n        return NTLM_ERR_PROTOCOL;\n    }\n    return NTLM_ERR_NONE;\n}",
    "includes": [
      "#include \"util.h\"       /* for base64-related stuff */",
      "#include \"ntlmauth/ntlmauth.h\"",
      "#include <strings.h>",
      "#include <random>",
      "#include <cstring>",
      "#include \"squid.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"ntlm_validate_packet: type is %d, wanted %d\\n\"",
            "le32toh(hdr->type)",
            "type"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "hdr->type"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "hdr->type"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ntlmCheckHeader: bad header signature\\n\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "hdr->signature",
            "\"NTLMSSP\"",
            "8"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"       /* for base64-related stuff */\n#include \"ntlmauth/ntlmauth.h\"\n#include <strings.h>\n#include <random>\n#include <cstring>\n#include \"squid.h\"\n\nint\nntlm_validate_packet(const ntlmhdr * hdr, const int32_t type)\n{\n    /*\n     * Must be the correct security package and request type.\n     * The 8 bytes compared includes the ASCII 'NUL'.\n     */\n    if (memcmp(hdr->signature, \"NTLMSSP\", 8) != 0) {\n        fprintf(stderr, \"ntlmCheckHeader: bad header signature\\n\");\n        return NTLM_ERR_BLOB;\n    }\n    if (type == NTLM_ANY)\n        return NTLM_ERR_NONE;\n\n    if ((int32_t)le32toh(hdr->type) != type) {\n        /* don't report this error - it's ok as we do a if() around this function */\n        debug(\"ntlm_validate_packet: type is %d, wanted %d\\n\", le32toh(hdr->type), type);\n        return NTLM_ERR_PROTOCOL;\n    }\n    return NTLM_ERR_NONE;\n}"
  },
  {
    "function_name": "ntlm_dump_ntlmssp_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/ntlmauth/ntlmauth.cc",
    "lines": "28-52",
    "snippet": "void\nntlm_dump_ntlmssp_flags(uint32_t flags)\n{\n    fprintf(stderr, \"flags: %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\\n\",\n            (flags & NTLM_NEGOTIATE_UNICODE ? \"Unicode \" : \"\"),\n            (flags & NTLM_NEGOTIATE_ASCII ? \"ASCII \" : \"\"),\n            (flags & NTLM_NEGOTIATE_REQUEST_TARGET ? \"ReqTgt \" : \"\"),\n            (flags & NTLM_NEGOTIATE_REQUEST_SIGN ? \"ReqSign \" : \"\"),\n            (flags & NTLM_NEGOTIATE_REQUEST_SEAL ? \"ReqSeal \" : \"\"),\n            (flags & NTLM_NEGOTIATE_DATAGRAM_STYLE ? \"Dgram \" : \"\"),\n            (flags & NTLM_NEGOTIATE_USE_LM ? \"UseLM \" : \"\"),\n            (flags & NTLM_NEGOTIATE_USE_NETWARE ? \"UseNW \" : \"\"),\n            (flags & NTLM_NEGOTIATE_USE_NTLM ? \"UseNTLM \" : \"\"),\n            (flags & NTLM_NEGOTIATE_DOMAIN_SUPPLIED ? \"HaveDomain \" : \"\"),\n            (flags & NTLM_NEGOTIATE_WORKSTATION_SUPPLIED ? \"HaveWKS \" : \"\"),\n            (flags & NTLM_NEGOTIATE_THIS_IS_LOCAL_CALL ? \"LocalCall \" : \"\"),\n            (flags & NTLM_NEGOTIATE_ALWAYS_SIGN ? \"AlwaysSign \" : \"\"),\n            (flags & NTLM_CHALLENGE_TARGET_IS_DOMAIN ? \"Tgt_is_domain\" : \"\"),\n            (flags & NTLM_CHALLENGE_TARGET_IS_SERVER ? \"Tgt_is_server \" : \"\"),\n            (flags & NTLM_CHALLENGE_TARGET_IS_SHARE ? \"Tgt_is_share \" : \"\"),\n            (flags & NTLM_REQUEST_INIT_RESPONSE ? \"Req_init_response \" : \"\"),\n            (flags & NTLM_REQUEST_ACCEPT_RESPONSE ? \"Req_accept_response \" : \"\"),\n            (flags & NTLM_REQUEST_NON_NT_SESSION_KEY ? \"Req_nonnt_sesskey \" : \"\")\n           );\n}",
    "includes": [
      "#include \"util.h\"       /* for base64-related stuff */",
      "#include \"ntlmauth/ntlmauth.h\"",
      "#include <strings.h>",
      "#include <random>",
      "#include <cstring>",
      "#include \"squid.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"flags: %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\\n\"",
            "(flags & NTLM_NEGOTIATE_UNICODE ? \"Unicode \" : \"\")",
            "(flags & NTLM_NEGOTIATE_ASCII ? \"ASCII \" : \"\")",
            "(flags & NTLM_NEGOTIATE_REQUEST_TARGET ? \"ReqTgt \" : \"\")",
            "(flags & NTLM_NEGOTIATE_REQUEST_SIGN ? \"ReqSign \" : \"\")",
            "(flags & NTLM_NEGOTIATE_REQUEST_SEAL ? \"ReqSeal \" : \"\")",
            "(flags & NTLM_NEGOTIATE_DATAGRAM_STYLE ? \"Dgram \" : \"\")",
            "(flags & NTLM_NEGOTIATE_USE_LM ? \"UseLM \" : \"\")",
            "(flags & NTLM_NEGOTIATE_USE_NETWARE ? \"UseNW \" : \"\")",
            "(flags & NTLM_NEGOTIATE_USE_NTLM ? \"UseNTLM \" : \"\")",
            "(flags & NTLM_NEGOTIATE_DOMAIN_SUPPLIED ? \"HaveDomain \" : \"\")",
            "(flags & NTLM_NEGOTIATE_WORKSTATION_SUPPLIED ? \"HaveWKS \" : \"\")",
            "(flags & NTLM_NEGOTIATE_THIS_IS_LOCAL_CALL ? \"LocalCall \" : \"\")",
            "(flags & NTLM_NEGOTIATE_ALWAYS_SIGN ? \"AlwaysSign \" : \"\")",
            "(flags & NTLM_CHALLENGE_TARGET_IS_DOMAIN ? \"Tgt_is_domain\" : \"\")",
            "(flags & NTLM_CHALLENGE_TARGET_IS_SERVER ? \"Tgt_is_server \" : \"\")",
            "(flags & NTLM_CHALLENGE_TARGET_IS_SHARE ? \"Tgt_is_share \" : \"\")",
            "(flags & NTLM_REQUEST_INIT_RESPONSE ? \"Req_init_response \" : \"\")",
            "(flags & NTLM_REQUEST_ACCEPT_RESPONSE ? \"Req_accept_response \" : \"\")",
            "(flags & NTLM_REQUEST_NON_NT_SESSION_KEY ? \"Req_nonnt_sesskey \" : \"\")"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"       /* for base64-related stuff */\n#include \"ntlmauth/ntlmauth.h\"\n#include <strings.h>\n#include <random>\n#include <cstring>\n#include \"squid.h\"\n\nvoid\nntlm_dump_ntlmssp_flags(uint32_t flags)\n{\n    fprintf(stderr, \"flags: %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\\n\",\n            (flags & NTLM_NEGOTIATE_UNICODE ? \"Unicode \" : \"\"),\n            (flags & NTLM_NEGOTIATE_ASCII ? \"ASCII \" : \"\"),\n            (flags & NTLM_NEGOTIATE_REQUEST_TARGET ? \"ReqTgt \" : \"\"),\n            (flags & NTLM_NEGOTIATE_REQUEST_SIGN ? \"ReqSign \" : \"\"),\n            (flags & NTLM_NEGOTIATE_REQUEST_SEAL ? \"ReqSeal \" : \"\"),\n            (flags & NTLM_NEGOTIATE_DATAGRAM_STYLE ? \"Dgram \" : \"\"),\n            (flags & NTLM_NEGOTIATE_USE_LM ? \"UseLM \" : \"\"),\n            (flags & NTLM_NEGOTIATE_USE_NETWARE ? \"UseNW \" : \"\"),\n            (flags & NTLM_NEGOTIATE_USE_NTLM ? \"UseNTLM \" : \"\"),\n            (flags & NTLM_NEGOTIATE_DOMAIN_SUPPLIED ? \"HaveDomain \" : \"\"),\n            (flags & NTLM_NEGOTIATE_WORKSTATION_SUPPLIED ? \"HaveWKS \" : \"\"),\n            (flags & NTLM_NEGOTIATE_THIS_IS_LOCAL_CALL ? \"LocalCall \" : \"\"),\n            (flags & NTLM_NEGOTIATE_ALWAYS_SIGN ? \"AlwaysSign \" : \"\"),\n            (flags & NTLM_CHALLENGE_TARGET_IS_DOMAIN ? \"Tgt_is_domain\" : \"\"),\n            (flags & NTLM_CHALLENGE_TARGET_IS_SERVER ? \"Tgt_is_server \" : \"\"),\n            (flags & NTLM_CHALLENGE_TARGET_IS_SHARE ? \"Tgt_is_share \" : \"\"),\n            (flags & NTLM_REQUEST_INIT_RESPONSE ? \"Req_init_response \" : \"\"),\n            (flags & NTLM_REQUEST_ACCEPT_RESPONSE ? \"Req_accept_response \" : \"\"),\n            (flags & NTLM_REQUEST_NON_NT_SESSION_KEY ? \"Req_nonnt_sesskey \" : \"\")\n           );\n}"
  }
]