[
  {
    "function_name": "SSP_ValidateNTLMCredentials",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/sspwin32.cc",
    "lines": "505-528",
    "snippet": "BOOL WINAPI SSP_ValidateNTLMCredentials(PVOID PAutenticateBuf, int AutenticateLen, char * credentials)\n{\n    BOOL        fDone      = FALSE;\n    BOOL        fResult    = FALSE;\n    DWORD       cbOut      = 0;\n    DWORD       cbIn       = 0;\n\n    memcpy(pClientBuf, PAutenticateBuf, AutenticateLen);\n    ZeroMemory(pServerBuf, cbMaxToken);\n    do {\n        if (!hModule)\n            break;\n\n        /* Prepare server message (authentication) */\n        cbIn = AutenticateLen;\n        cbOut = cbMaxToken;\n        if (!GenServerContext(&NTLM_asServer, pClientBuf, cbIn, pServerBuf, &cbOut,\n                              &fDone, credentials))\n            break;\n        fResult = TRUE;\n    } while (0);\n\n    return fResult;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sspwin32.h\"",
      "#include \"ntlmauth/ntlmauth.h\"",
      "#include \"base64.h\"",
      "#include \"squid.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HMODULE hModule;",
      "static DWORD cbMaxToken = 0;",
      "static uint8_t * pClientBuf = NULL;",
      "static uint8_t * pServerBuf = NULL;",
      "static AUTH_SEQ NTLM_asServer = {0};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GenServerContext",
          "args": [
            "&NTLM_asServer",
            "pClientBuf",
            "cbIn",
            "pServerBuf",
            "&cbOut",
            "&fDone",
            "credentials"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "GenServerContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/sspwin32.cc",
          "lines": "278-381",
          "snippet": "BOOL GenServerContext(PAUTH_SEQ pAS, PVOID pIn, DWORD cbIn, PVOID pOut,\n                      PDWORD pcbOut, PBOOL pfDone, char * credentials)\n{\n    /*\n     *   Routine Description:\n     *\n     *   Takes an input buffer coming from the client and returns a buffer\n     *   to be sent to the client.  Also returns an indication of whether or\n     *   not the context is complete.\n     *\n     *   Return Value:\n     *\n     *   Returns TRUE if successful; otherwise FALSE.\n     */\n\n    SecBufferDesc   sbdOut;\n    SecBuffer       sbOut;\n    SecBufferDesc   sbdIn;\n    SecBuffer       sbIn;\n    ULONG           fContextAttr;\n    SecPkgContext_Names namebuffer;\n\n    if (!pAS->fInitialized)  {\n        SecurityStatus = _AcquireCredentialsHandle(NULL, (SEC_CHAR*) _T(SSP_Package_InUse),\n                         SECPKG_CRED_INBOUND, NULL, NULL, NULL, NULL, &pAS->hcred,\n                         &pAS->hcredLifeTime);\n#if SSP_DEBUG\n        fprintf(stderr, \"AcquireCredentialsHandle returned: %x\\n\", SecurityStatus);\n#endif\n        if (SecurityStatus < 0) {\n#if SSP_DEBUG\n            fprintf(stderr, \"AcquireCredentialsHandle failed: %x\\n\", SecurityStatus);\n#endif\n            return FALSE;\n        }\n        pAS->fHaveCredHandle = TRUE;\n    }\n\n    /* Prepare output buffer */\n    sbdOut.ulVersion = 0;\n    sbdOut.cBuffers = 1;\n    sbdOut.pBuffers = &sbOut;\n    sbOut.cbBuffer = *pcbOut;\n    sbOut.BufferType = SECBUFFER_TOKEN;\n    sbOut.pvBuffer = pOut;\n\n    /* Prepare input buffer */\n    sbdIn.ulVersion = 0;\n    sbdIn.cBuffers = 1;\n    sbdIn.pBuffers = &sbIn;\n    sbIn.cbBuffer = cbIn;\n    sbIn.BufferType = SECBUFFER_TOKEN;\n    sbIn.pvBuffer = pIn;\n    SecurityStatus = _AcceptSecurityContext(&pAS->hcred,\n                                            pAS->fInitialized ? &pAS->hctxt : NULL, &sbdIn, (NTLM_mode == SSP_NTLM) ? ASC_REQ_DELEGATE : 0,\n                                            SECURITY_NATIVE_DREP, &pAS->hctxt, &sbdOut, &fContextAttr,\n                                            &pAS->hctxtLifeTime);\n#if SSP_DEBUG\n    fprintf(stderr, \"AcceptSecurityContext returned: %x\\n\", SecurityStatus);\n#endif\n    if (SecurityStatus < 0) {\n#if SSP_DEBUG\n        fprintf(stderr, \"AcceptSecurityContext failed: %x\\n\", SecurityStatus);\n#endif\n        return FALSE;\n    }\n    pAS->fHaveCtxtHandle = TRUE;\n\n    /* If necessary, complete token */\n    if (SecurityStatus == SEC_I_COMPLETE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE) {\n        SecurityStatus = _CompleteAuthToken(&pAS->hctxt, &sbdOut);\n#if SSP_DEBUG\n        fprintf(stderr, \"CompleteAuthToken returned: %x\\n\", SecurityStatus);\n#endif\n        if (SecurityStatus < 0) {\n#if SSP_DEBUG\n            fprintf(stderr, \"CompleteAuthToken failed: %x\\n\", SecurityStatus);\n#endif\n            return FALSE;\n        }\n    }\n\n    if ((credentials != NULL) &&\n            !(SecurityStatus == SEC_I_CONTINUE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE)) {\n        SecurityStatus = _QueryContextAttributes(&pAS->hctxt, SECPKG_ATTR_NAMES, &namebuffer);\n#if SSP_DEBUG\n        fprintf(stderr, \"QueryContextAttributes returned: %x\\n\", SecurityStatus);\n#endif\n        if (SecurityStatus < 0) {\n#if SSP_DEBUG\n            fprintf(stderr, \"QueryContextAttributes failed: %x\\n\", SecurityStatus);\n#endif\n            return FALSE;\n        }\n        strncpy(credentials, namebuffer.sUserName, SSP_MAX_CRED_LEN);\n    }\n\n    *pcbOut = sbOut.cbBuffer;\n    if (!pAS->fInitialized)\n        pAS->fInitialized = TRUE;\n    *pfDone = !(SecurityStatus == SEC_I_CONTINUE_NEEDED\n                || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE);\n    return TRUE;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sspwin32.h\"",
            "#include \"ntlmauth/ntlmauth.h\"",
            "#include \"base64.h\"",
            "#include \"squid.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "BOOL GenClientContext(PAUTH_SEQ, PSEC_WINNT_AUTH_IDENTITY, PVOID, DWORD, PVOID, PDWORD, PBOOL);",
            "BOOL GenServerContext(PAUTH_SEQ, PVOID, DWORD, PVOID, PDWORD, PBOOL, char *);",
            "static int NTLM_mode = SSP_BASIC;",
            "static char * SSP_Package_InUse;",
            "SECURITY_STATUS SecurityStatus = SEC_E_OK;",
            "ACCEPT_SECURITY_CONTEXT_FN _AcceptSecurityContext = NULL;",
            "ACQUIRE_CREDENTIALS_HANDLE_FN _AcquireCredentialsHandle = NULL;",
            "COMPLETE_AUTH_TOKEN_FN _CompleteAuthToken = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sspwin32.h\"\n#include \"ntlmauth/ntlmauth.h\"\n#include \"base64.h\"\n#include \"squid.h\"\n\nBOOL GenClientContext(PAUTH_SEQ, PSEC_WINNT_AUTH_IDENTITY, PVOID, DWORD, PVOID, PDWORD, PBOOL);\nBOOL GenServerContext(PAUTH_SEQ, PVOID, DWORD, PVOID, PDWORD, PBOOL, char *);\nstatic int NTLM_mode = SSP_BASIC;\nstatic char * SSP_Package_InUse;\nSECURITY_STATUS SecurityStatus = SEC_E_OK;\nACCEPT_SECURITY_CONTEXT_FN _AcceptSecurityContext = NULL;\nACQUIRE_CREDENTIALS_HANDLE_FN _AcquireCredentialsHandle = NULL;\nCOMPLETE_AUTH_TOKEN_FN _CompleteAuthToken = NULL;\n\nBOOL GenServerContext(PAUTH_SEQ pAS, PVOID pIn, DWORD cbIn, PVOID pOut,\n                      PDWORD pcbOut, PBOOL pfDone, char * credentials)\n{\n    /*\n     *   Routine Description:\n     *\n     *   Takes an input buffer coming from the client and returns a buffer\n     *   to be sent to the client.  Also returns an indication of whether or\n     *   not the context is complete.\n     *\n     *   Return Value:\n     *\n     *   Returns TRUE if successful; otherwise FALSE.\n     */\n\n    SecBufferDesc   sbdOut;\n    SecBuffer       sbOut;\n    SecBufferDesc   sbdIn;\n    SecBuffer       sbIn;\n    ULONG           fContextAttr;\n    SecPkgContext_Names namebuffer;\n\n    if (!pAS->fInitialized)  {\n        SecurityStatus = _AcquireCredentialsHandle(NULL, (SEC_CHAR*) _T(SSP_Package_InUse),\n                         SECPKG_CRED_INBOUND, NULL, NULL, NULL, NULL, &pAS->hcred,\n                         &pAS->hcredLifeTime);\n#if SSP_DEBUG\n        fprintf(stderr, \"AcquireCredentialsHandle returned: %x\\n\", SecurityStatus);\n#endif\n        if (SecurityStatus < 0) {\n#if SSP_DEBUG\n            fprintf(stderr, \"AcquireCredentialsHandle failed: %x\\n\", SecurityStatus);\n#endif\n            return FALSE;\n        }\n        pAS->fHaveCredHandle = TRUE;\n    }\n\n    /* Prepare output buffer */\n    sbdOut.ulVersion = 0;\n    sbdOut.cBuffers = 1;\n    sbdOut.pBuffers = &sbOut;\n    sbOut.cbBuffer = *pcbOut;\n    sbOut.BufferType = SECBUFFER_TOKEN;\n    sbOut.pvBuffer = pOut;\n\n    /* Prepare input buffer */\n    sbdIn.ulVersion = 0;\n    sbdIn.cBuffers = 1;\n    sbdIn.pBuffers = &sbIn;\n    sbIn.cbBuffer = cbIn;\n    sbIn.BufferType = SECBUFFER_TOKEN;\n    sbIn.pvBuffer = pIn;\n    SecurityStatus = _AcceptSecurityContext(&pAS->hcred,\n                                            pAS->fInitialized ? &pAS->hctxt : NULL, &sbdIn, (NTLM_mode == SSP_NTLM) ? ASC_REQ_DELEGATE : 0,\n                                            SECURITY_NATIVE_DREP, &pAS->hctxt, &sbdOut, &fContextAttr,\n                                            &pAS->hctxtLifeTime);\n#if SSP_DEBUG\n    fprintf(stderr, \"AcceptSecurityContext returned: %x\\n\", SecurityStatus);\n#endif\n    if (SecurityStatus < 0) {\n#if SSP_DEBUG\n        fprintf(stderr, \"AcceptSecurityContext failed: %x\\n\", SecurityStatus);\n#endif\n        return FALSE;\n    }\n    pAS->fHaveCtxtHandle = TRUE;\n\n    /* If necessary, complete token */\n    if (SecurityStatus == SEC_I_COMPLETE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE) {\n        SecurityStatus = _CompleteAuthToken(&pAS->hctxt, &sbdOut);\n#if SSP_DEBUG\n        fprintf(stderr, \"CompleteAuthToken returned: %x\\n\", SecurityStatus);\n#endif\n        if (SecurityStatus < 0) {\n#if SSP_DEBUG\n            fprintf(stderr, \"CompleteAuthToken failed: %x\\n\", SecurityStatus);\n#endif\n            return FALSE;\n        }\n    }\n\n    if ((credentials != NULL) &&\n            !(SecurityStatus == SEC_I_CONTINUE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE)) {\n        SecurityStatus = _QueryContextAttributes(&pAS->hctxt, SECPKG_ATTR_NAMES, &namebuffer);\n#if SSP_DEBUG\n        fprintf(stderr, \"QueryContextAttributes returned: %x\\n\", SecurityStatus);\n#endif\n        if (SecurityStatus < 0) {\n#if SSP_DEBUG\n            fprintf(stderr, \"QueryContextAttributes failed: %x\\n\", SecurityStatus);\n#endif\n            return FALSE;\n        }\n        strncpy(credentials, namebuffer.sUserName, SSP_MAX_CRED_LEN);\n    }\n\n    *pcbOut = sbOut.cbBuffer;\n    if (!pAS->fInitialized)\n        pAS->fInitialized = TRUE;\n    *pfDone = !(SecurityStatus == SEC_I_CONTINUE_NEEDED\n                || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE);\n    return TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ZeroMemory",
          "args": [
            "pServerBuf",
            "cbMaxToken"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pClientBuf",
            "PAutenticateBuf",
            "AutenticateLen"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sspwin32.h\"\n#include \"ntlmauth/ntlmauth.h\"\n#include \"base64.h\"\n#include \"squid.h\"\n\nstatic HMODULE hModule;\nstatic DWORD cbMaxToken = 0;\nstatic uint8_t * pClientBuf = NULL;\nstatic uint8_t * pServerBuf = NULL;\nstatic AUTH_SEQ NTLM_asServer = {0};\n\nBOOL WINAPI SSP_ValidateNTLMCredentials(PVOID PAutenticateBuf, int AutenticateLen, char * credentials)\n{\n    BOOL        fDone      = FALSE;\n    BOOL        fResult    = FALSE;\n    DWORD       cbOut      = 0;\n    DWORD       cbIn       = 0;\n\n    memcpy(pClientBuf, PAutenticateBuf, AutenticateLen);\n    ZeroMemory(pServerBuf, cbMaxToken);\n    do {\n        if (!hModule)\n            break;\n\n        /* Prepare server message (authentication) */\n        cbIn = AutenticateLen;\n        cbOut = cbMaxToken;\n        if (!GenServerContext(&NTLM_asServer, pClientBuf, cbIn, pServerBuf, &cbOut,\n                              &fDone, credentials))\n            break;\n        fResult = TRUE;\n    } while (0);\n\n    return fResult;\n}"
  },
  {
    "function_name": "SSP_LogonUser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/sspwin32.cc",
    "lines": "383-456",
    "snippet": "BOOL WINAPI SSP_LogonUser(PTSTR szUser, PTSTR szPassword, PTSTR szDomain)\n{\n    AUTH_SEQ    asServer   = {0};\n    AUTH_SEQ    asClient   = {0};\n    BOOL        fDone      = FALSE;\n    BOOL        fResult    = FALSE;\n    DWORD       cbOut      = 0;\n    DWORD       cbIn       = 0;\n\n    SEC_WINNT_AUTH_IDENTITY ai;\n\n    do {\n        if (!hModule)\n            break;\n\n        /* Initialize auth identity structure */\n        ZeroMemory(&ai, sizeof(ai));\n        ai.Domain = (unsigned char *)szDomain;\n        ai.DomainLength = lstrlen(szDomain);\n        ai.User = (unsigned char *)szUser;\n        ai.UserLength = lstrlen(szUser);\n        ai.Password = (unsigned char *)szPassword;\n        ai.PasswordLength = lstrlen(szPassword);\n#if defined(UNICODE) || defined(_UNICODE)\n        ai.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n#else\n        ai.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;\n#endif\n\n        /* Prepare client message (negotiate) */\n        cbOut = cbMaxToken;\n        if (!GenClientContext(&asClient, &ai, NULL, 0, pClientBuf, &cbOut, &fDone))\n            break;\n\n        /* Prepare server message (challenge) */\n        cbIn = cbOut;\n        cbOut = cbMaxToken;\n        if (!GenServerContext(&asServer, pClientBuf, cbIn, pServerBuf, &cbOut,\n                              &fDone, NULL))\n            break;\n        /* Most likely failure: AcceptServerContext fails with SEC_E_LOGON_DENIED\n         * in the case of bad szUser or szPassword.\n         * Unexpected Result: Logon will succeed if you pass in a bad szUser and\n         * the guest account is enabled in the specified domain.\n         */\n\n        /* Prepare client message (authenticate) */\n        cbIn = cbOut;\n        cbOut = cbMaxToken;\n        if (!GenClientContext(&asClient, &ai, pServerBuf, cbIn, pClientBuf, &cbOut,\n                              &fDone))\n            break;\n\n        /* Prepare server message (authentication) */\n        cbIn = cbOut;\n        cbOut = cbMaxToken;\n        if (!GenServerContext(&asServer, pClientBuf, cbIn, pServerBuf, &cbOut,\n                              &fDone, NULL))\n            break;\n        fResult = TRUE;\n    } while (0);\n\n    /* Clean up resources */\n    if (asClient.fHaveCtxtHandle)\n        _DeleteSecurityContext(&asClient.hctxt);\n    if (asClient.fHaveCredHandle)\n        _FreeCredentialsHandle(&asClient.hcred);\n    if (asServer.fHaveCtxtHandle)\n        _DeleteSecurityContext(&asServer.hctxt);\n    if (asServer.fHaveCredHandle)\n        _FreeCredentialsHandle(&asServer.hcred);\n\n    return fResult;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sspwin32.h\"",
      "#include \"ntlmauth/ntlmauth.h\"",
      "#include \"base64.h\"",
      "#include \"squid.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HMODULE hModule;",
      "static DWORD cbMaxToken = 0;",
      "static uint8_t * pClientBuf = NULL;",
      "static uint8_t * pServerBuf = NULL;",
      "DELETE_SECURITY_CONTEXT_FN _DeleteSecurityContext = NULL;",
      "FREE_CREDENTIALS_HANDLE_FN _FreeCredentialsHandle = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_FreeCredentialsHandle",
          "args": [
            "&asServer.hcred"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_DeleteSecurityContext",
          "args": [
            "&asServer.hctxt"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_FreeCredentialsHandle",
          "args": [
            "&asClient.hcred"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_DeleteSecurityContext",
          "args": [
            "&asClient.hctxt"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenServerContext",
          "args": [
            "&asServer",
            "pClientBuf",
            "cbIn",
            "pServerBuf",
            "&cbOut",
            "&fDone",
            "NULL"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "GenServerContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/sspwin32.cc",
          "lines": "278-381",
          "snippet": "BOOL GenServerContext(PAUTH_SEQ pAS, PVOID pIn, DWORD cbIn, PVOID pOut,\n                      PDWORD pcbOut, PBOOL pfDone, char * credentials)\n{\n    /*\n     *   Routine Description:\n     *\n     *   Takes an input buffer coming from the client and returns a buffer\n     *   to be sent to the client.  Also returns an indication of whether or\n     *   not the context is complete.\n     *\n     *   Return Value:\n     *\n     *   Returns TRUE if successful; otherwise FALSE.\n     */\n\n    SecBufferDesc   sbdOut;\n    SecBuffer       sbOut;\n    SecBufferDesc   sbdIn;\n    SecBuffer       sbIn;\n    ULONG           fContextAttr;\n    SecPkgContext_Names namebuffer;\n\n    if (!pAS->fInitialized)  {\n        SecurityStatus = _AcquireCredentialsHandle(NULL, (SEC_CHAR*) _T(SSP_Package_InUse),\n                         SECPKG_CRED_INBOUND, NULL, NULL, NULL, NULL, &pAS->hcred,\n                         &pAS->hcredLifeTime);\n#if SSP_DEBUG\n        fprintf(stderr, \"AcquireCredentialsHandle returned: %x\\n\", SecurityStatus);\n#endif\n        if (SecurityStatus < 0) {\n#if SSP_DEBUG\n            fprintf(stderr, \"AcquireCredentialsHandle failed: %x\\n\", SecurityStatus);\n#endif\n            return FALSE;\n        }\n        pAS->fHaveCredHandle = TRUE;\n    }\n\n    /* Prepare output buffer */\n    sbdOut.ulVersion = 0;\n    sbdOut.cBuffers = 1;\n    sbdOut.pBuffers = &sbOut;\n    sbOut.cbBuffer = *pcbOut;\n    sbOut.BufferType = SECBUFFER_TOKEN;\n    sbOut.pvBuffer = pOut;\n\n    /* Prepare input buffer */\n    sbdIn.ulVersion = 0;\n    sbdIn.cBuffers = 1;\n    sbdIn.pBuffers = &sbIn;\n    sbIn.cbBuffer = cbIn;\n    sbIn.BufferType = SECBUFFER_TOKEN;\n    sbIn.pvBuffer = pIn;\n    SecurityStatus = _AcceptSecurityContext(&pAS->hcred,\n                                            pAS->fInitialized ? &pAS->hctxt : NULL, &sbdIn, (NTLM_mode == SSP_NTLM) ? ASC_REQ_DELEGATE : 0,\n                                            SECURITY_NATIVE_DREP, &pAS->hctxt, &sbdOut, &fContextAttr,\n                                            &pAS->hctxtLifeTime);\n#if SSP_DEBUG\n    fprintf(stderr, \"AcceptSecurityContext returned: %x\\n\", SecurityStatus);\n#endif\n    if (SecurityStatus < 0) {\n#if SSP_DEBUG\n        fprintf(stderr, \"AcceptSecurityContext failed: %x\\n\", SecurityStatus);\n#endif\n        return FALSE;\n    }\n    pAS->fHaveCtxtHandle = TRUE;\n\n    /* If necessary, complete token */\n    if (SecurityStatus == SEC_I_COMPLETE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE) {\n        SecurityStatus = _CompleteAuthToken(&pAS->hctxt, &sbdOut);\n#if SSP_DEBUG\n        fprintf(stderr, \"CompleteAuthToken returned: %x\\n\", SecurityStatus);\n#endif\n        if (SecurityStatus < 0) {\n#if SSP_DEBUG\n            fprintf(stderr, \"CompleteAuthToken failed: %x\\n\", SecurityStatus);\n#endif\n            return FALSE;\n        }\n    }\n\n    if ((credentials != NULL) &&\n            !(SecurityStatus == SEC_I_CONTINUE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE)) {\n        SecurityStatus = _QueryContextAttributes(&pAS->hctxt, SECPKG_ATTR_NAMES, &namebuffer);\n#if SSP_DEBUG\n        fprintf(stderr, \"QueryContextAttributes returned: %x\\n\", SecurityStatus);\n#endif\n        if (SecurityStatus < 0) {\n#if SSP_DEBUG\n            fprintf(stderr, \"QueryContextAttributes failed: %x\\n\", SecurityStatus);\n#endif\n            return FALSE;\n        }\n        strncpy(credentials, namebuffer.sUserName, SSP_MAX_CRED_LEN);\n    }\n\n    *pcbOut = sbOut.cbBuffer;\n    if (!pAS->fInitialized)\n        pAS->fInitialized = TRUE;\n    *pfDone = !(SecurityStatus == SEC_I_CONTINUE_NEEDED\n                || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE);\n    return TRUE;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sspwin32.h\"",
            "#include \"ntlmauth/ntlmauth.h\"",
            "#include \"base64.h\"",
            "#include \"squid.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "BOOL GenClientContext(PAUTH_SEQ, PSEC_WINNT_AUTH_IDENTITY, PVOID, DWORD, PVOID, PDWORD, PBOOL);",
            "BOOL GenServerContext(PAUTH_SEQ, PVOID, DWORD, PVOID, PDWORD, PBOOL, char *);",
            "static int NTLM_mode = SSP_BASIC;",
            "static char * SSP_Package_InUse;",
            "SECURITY_STATUS SecurityStatus = SEC_E_OK;",
            "ACCEPT_SECURITY_CONTEXT_FN _AcceptSecurityContext = NULL;",
            "ACQUIRE_CREDENTIALS_HANDLE_FN _AcquireCredentialsHandle = NULL;",
            "COMPLETE_AUTH_TOKEN_FN _CompleteAuthToken = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sspwin32.h\"\n#include \"ntlmauth/ntlmauth.h\"\n#include \"base64.h\"\n#include \"squid.h\"\n\nBOOL GenClientContext(PAUTH_SEQ, PSEC_WINNT_AUTH_IDENTITY, PVOID, DWORD, PVOID, PDWORD, PBOOL);\nBOOL GenServerContext(PAUTH_SEQ, PVOID, DWORD, PVOID, PDWORD, PBOOL, char *);\nstatic int NTLM_mode = SSP_BASIC;\nstatic char * SSP_Package_InUse;\nSECURITY_STATUS SecurityStatus = SEC_E_OK;\nACCEPT_SECURITY_CONTEXT_FN _AcceptSecurityContext = NULL;\nACQUIRE_CREDENTIALS_HANDLE_FN _AcquireCredentialsHandle = NULL;\nCOMPLETE_AUTH_TOKEN_FN _CompleteAuthToken = NULL;\n\nBOOL GenServerContext(PAUTH_SEQ pAS, PVOID pIn, DWORD cbIn, PVOID pOut,\n                      PDWORD pcbOut, PBOOL pfDone, char * credentials)\n{\n    /*\n     *   Routine Description:\n     *\n     *   Takes an input buffer coming from the client and returns a buffer\n     *   to be sent to the client.  Also returns an indication of whether or\n     *   not the context is complete.\n     *\n     *   Return Value:\n     *\n     *   Returns TRUE if successful; otherwise FALSE.\n     */\n\n    SecBufferDesc   sbdOut;\n    SecBuffer       sbOut;\n    SecBufferDesc   sbdIn;\n    SecBuffer       sbIn;\n    ULONG           fContextAttr;\n    SecPkgContext_Names namebuffer;\n\n    if (!pAS->fInitialized)  {\n        SecurityStatus = _AcquireCredentialsHandle(NULL, (SEC_CHAR*) _T(SSP_Package_InUse),\n                         SECPKG_CRED_INBOUND, NULL, NULL, NULL, NULL, &pAS->hcred,\n                         &pAS->hcredLifeTime);\n#if SSP_DEBUG\n        fprintf(stderr, \"AcquireCredentialsHandle returned: %x\\n\", SecurityStatus);\n#endif\n        if (SecurityStatus < 0) {\n#if SSP_DEBUG\n            fprintf(stderr, \"AcquireCredentialsHandle failed: %x\\n\", SecurityStatus);\n#endif\n            return FALSE;\n        }\n        pAS->fHaveCredHandle = TRUE;\n    }\n\n    /* Prepare output buffer */\n    sbdOut.ulVersion = 0;\n    sbdOut.cBuffers = 1;\n    sbdOut.pBuffers = &sbOut;\n    sbOut.cbBuffer = *pcbOut;\n    sbOut.BufferType = SECBUFFER_TOKEN;\n    sbOut.pvBuffer = pOut;\n\n    /* Prepare input buffer */\n    sbdIn.ulVersion = 0;\n    sbdIn.cBuffers = 1;\n    sbdIn.pBuffers = &sbIn;\n    sbIn.cbBuffer = cbIn;\n    sbIn.BufferType = SECBUFFER_TOKEN;\n    sbIn.pvBuffer = pIn;\n    SecurityStatus = _AcceptSecurityContext(&pAS->hcred,\n                                            pAS->fInitialized ? &pAS->hctxt : NULL, &sbdIn, (NTLM_mode == SSP_NTLM) ? ASC_REQ_DELEGATE : 0,\n                                            SECURITY_NATIVE_DREP, &pAS->hctxt, &sbdOut, &fContextAttr,\n                                            &pAS->hctxtLifeTime);\n#if SSP_DEBUG\n    fprintf(stderr, \"AcceptSecurityContext returned: %x\\n\", SecurityStatus);\n#endif\n    if (SecurityStatus < 0) {\n#if SSP_DEBUG\n        fprintf(stderr, \"AcceptSecurityContext failed: %x\\n\", SecurityStatus);\n#endif\n        return FALSE;\n    }\n    pAS->fHaveCtxtHandle = TRUE;\n\n    /* If necessary, complete token */\n    if (SecurityStatus == SEC_I_COMPLETE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE) {\n        SecurityStatus = _CompleteAuthToken(&pAS->hctxt, &sbdOut);\n#if SSP_DEBUG\n        fprintf(stderr, \"CompleteAuthToken returned: %x\\n\", SecurityStatus);\n#endif\n        if (SecurityStatus < 0) {\n#if SSP_DEBUG\n            fprintf(stderr, \"CompleteAuthToken failed: %x\\n\", SecurityStatus);\n#endif\n            return FALSE;\n        }\n    }\n\n    if ((credentials != NULL) &&\n            !(SecurityStatus == SEC_I_CONTINUE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE)) {\n        SecurityStatus = _QueryContextAttributes(&pAS->hctxt, SECPKG_ATTR_NAMES, &namebuffer);\n#if SSP_DEBUG\n        fprintf(stderr, \"QueryContextAttributes returned: %x\\n\", SecurityStatus);\n#endif\n        if (SecurityStatus < 0) {\n#if SSP_DEBUG\n            fprintf(stderr, \"QueryContextAttributes failed: %x\\n\", SecurityStatus);\n#endif\n            return FALSE;\n        }\n        strncpy(credentials, namebuffer.sUserName, SSP_MAX_CRED_LEN);\n    }\n\n    *pcbOut = sbOut.cbBuffer;\n    if (!pAS->fInitialized)\n        pAS->fInitialized = TRUE;\n    *pfDone = !(SecurityStatus == SEC_I_CONTINUE_NEEDED\n                || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE);\n    return TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GenClientContext",
          "args": [
            "&asClient",
            "&ai",
            "pServerBuf",
            "cbIn",
            "pClientBuf",
            "&cbOut",
            "&fDone"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "GenClientContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/sspwin32.cc",
          "lines": "210-276",
          "snippet": "BOOL GenClientContext(PAUTH_SEQ pAS, PSEC_WINNT_AUTH_IDENTITY pAuthIdentity,\n                      PVOID pIn, DWORD cbIn, PVOID pOut, PDWORD pcbOut, PBOOL pfDone)\n{\n    /*\n     *  Routine Description:\n     *\n     *  Optionally takes an input buffer coming from the server and returns\n     *  a buffer of information to send back to the server. Also returns\n     *  an indication of whether or not the context is complete.\n     *\n     *  Return Value:\n     *  Returns TRUE if successful; otherwise FALSE.\n     */\n    TimeStamp       tsExpiry;\n    SecBufferDesc   sbdOut;\n    SecBuffer       sbOut;\n    SecBufferDesc   sbdIn;\n    SecBuffer       sbIn;\n    ULONG           fContextAttr;\n\n    if (!pAS->fInitialized) {\n        SecurityStatus = _AcquireCredentialsHandle(NULL, (SEC_CHAR*) _T(SSP_Package_InUse),\n                         SECPKG_CRED_OUTBOUND, NULL, (NTLM_mode == SSP_NTLM) ? NULL : pAuthIdentity, NULL, NULL,\n                         &pAS->hcred, &tsExpiry);\n        if (SecurityStatus < 0)\n            return FALSE;\n        pAS->fHaveCredHandle = TRUE;\n    }\n\n    /* Prepare output buffer */\n    sbdOut.ulVersion = 0;\n    sbdOut.cBuffers = 1;\n    sbdOut.pBuffers = &sbOut;\n    sbOut.cbBuffer = *pcbOut;\n    sbOut.BufferType = SECBUFFER_TOKEN;\n    sbOut.pvBuffer = pOut;\n\n    /* Prepare input buffer */\n    if (pAS->fInitialized)  {\n        sbdIn.ulVersion = 0;\n        sbdIn.cBuffers = 1;\n        sbdIn.pBuffers = &sbIn;\n        sbIn.cbBuffer = cbIn;\n        sbIn.BufferType = SECBUFFER_TOKEN;\n        sbIn.pvBuffer = pIn;\n    }\n    SecurityStatus = _InitializeSecurityContext(&pAS->hcred,\n                     pAS->fInitialized ? &pAS->hctxt : NULL, NULL, 0, 0,\n                     SECURITY_NATIVE_DREP, pAS->fInitialized ? &sbdIn : NULL,\n                     0, &pAS->hctxt, &sbdOut, &fContextAttr, &tsExpiry);\n    if (SecurityStatus < 0)\n        return FALSE;\n    pAS->fHaveCtxtHandle = TRUE;\n\n    /* If necessary, complete token */\n    if (SecurityStatus == SEC_I_COMPLETE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE) {\n        SecurityStatus = _CompleteAuthToken(&pAS->hctxt, &sbdOut);\n        if (SecurityStatus < 0)\n            return FALSE;\n    }\n    *pcbOut = sbOut.cbBuffer;\n    if (!pAS->fInitialized)\n        pAS->fInitialized = TRUE;\n    *pfDone = !(SecurityStatus == SEC_I_CONTINUE_NEEDED\n                || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE );\n    return TRUE;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sspwin32.h\"",
            "#include \"ntlmauth/ntlmauth.h\"",
            "#include \"base64.h\"",
            "#include \"squid.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "BOOL GenClientContext(PAUTH_SEQ, PSEC_WINNT_AUTH_IDENTITY, PVOID, DWORD, PVOID, PDWORD, PBOOL);",
            "BOOL GenServerContext(PAUTH_SEQ, PVOID, DWORD, PVOID, PDWORD, PBOOL, char *);",
            "static int NTLM_mode = SSP_BASIC;",
            "static char * SSP_Package_InUse;",
            "SECURITY_STATUS SecurityStatus = SEC_E_OK;",
            "ACQUIRE_CREDENTIALS_HANDLE_FN _AcquireCredentialsHandle = NULL;",
            "COMPLETE_AUTH_TOKEN_FN _CompleteAuthToken = NULL;",
            "INITIALIZE_SECURITY_CONTEXT_FN _InitializeSecurityContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sspwin32.h\"\n#include \"ntlmauth/ntlmauth.h\"\n#include \"base64.h\"\n#include \"squid.h\"\n\nBOOL GenClientContext(PAUTH_SEQ, PSEC_WINNT_AUTH_IDENTITY, PVOID, DWORD, PVOID, PDWORD, PBOOL);\nBOOL GenServerContext(PAUTH_SEQ, PVOID, DWORD, PVOID, PDWORD, PBOOL, char *);\nstatic int NTLM_mode = SSP_BASIC;\nstatic char * SSP_Package_InUse;\nSECURITY_STATUS SecurityStatus = SEC_E_OK;\nACQUIRE_CREDENTIALS_HANDLE_FN _AcquireCredentialsHandle = NULL;\nCOMPLETE_AUTH_TOKEN_FN _CompleteAuthToken = NULL;\nINITIALIZE_SECURITY_CONTEXT_FN _InitializeSecurityContext = NULL;\n\nBOOL GenClientContext(PAUTH_SEQ pAS, PSEC_WINNT_AUTH_IDENTITY pAuthIdentity,\n                      PVOID pIn, DWORD cbIn, PVOID pOut, PDWORD pcbOut, PBOOL pfDone)\n{\n    /*\n     *  Routine Description:\n     *\n     *  Optionally takes an input buffer coming from the server and returns\n     *  a buffer of information to send back to the server. Also returns\n     *  an indication of whether or not the context is complete.\n     *\n     *  Return Value:\n     *  Returns TRUE if successful; otherwise FALSE.\n     */\n    TimeStamp       tsExpiry;\n    SecBufferDesc   sbdOut;\n    SecBuffer       sbOut;\n    SecBufferDesc   sbdIn;\n    SecBuffer       sbIn;\n    ULONG           fContextAttr;\n\n    if (!pAS->fInitialized) {\n        SecurityStatus = _AcquireCredentialsHandle(NULL, (SEC_CHAR*) _T(SSP_Package_InUse),\n                         SECPKG_CRED_OUTBOUND, NULL, (NTLM_mode == SSP_NTLM) ? NULL : pAuthIdentity, NULL, NULL,\n                         &pAS->hcred, &tsExpiry);\n        if (SecurityStatus < 0)\n            return FALSE;\n        pAS->fHaveCredHandle = TRUE;\n    }\n\n    /* Prepare output buffer */\n    sbdOut.ulVersion = 0;\n    sbdOut.cBuffers = 1;\n    sbdOut.pBuffers = &sbOut;\n    sbOut.cbBuffer = *pcbOut;\n    sbOut.BufferType = SECBUFFER_TOKEN;\n    sbOut.pvBuffer = pOut;\n\n    /* Prepare input buffer */\n    if (pAS->fInitialized)  {\n        sbdIn.ulVersion = 0;\n        sbdIn.cBuffers = 1;\n        sbdIn.pBuffers = &sbIn;\n        sbIn.cbBuffer = cbIn;\n        sbIn.BufferType = SECBUFFER_TOKEN;\n        sbIn.pvBuffer = pIn;\n    }\n    SecurityStatus = _InitializeSecurityContext(&pAS->hcred,\n                     pAS->fInitialized ? &pAS->hctxt : NULL, NULL, 0, 0,\n                     SECURITY_NATIVE_DREP, pAS->fInitialized ? &sbdIn : NULL,\n                     0, &pAS->hctxt, &sbdOut, &fContextAttr, &tsExpiry);\n    if (SecurityStatus < 0)\n        return FALSE;\n    pAS->fHaveCtxtHandle = TRUE;\n\n    /* If necessary, complete token */\n    if (SecurityStatus == SEC_I_COMPLETE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE) {\n        SecurityStatus = _CompleteAuthToken(&pAS->hctxt, &sbdOut);\n        if (SecurityStatus < 0)\n            return FALSE;\n    }\n    *pcbOut = sbOut.cbBuffer;\n    if (!pAS->fInitialized)\n        pAS->fInitialized = TRUE;\n    *pfDone = !(SecurityStatus == SEC_I_CONTINUE_NEEDED\n                || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE );\n    return TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lstrlen",
          "args": [
            "szPassword"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstrlen",
          "args": [
            "szUser"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstrlen",
          "args": [
            "szDomain"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZeroMemory",
          "args": [
            "&ai",
            "sizeof(ai)"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sspwin32.h\"\n#include \"ntlmauth/ntlmauth.h\"\n#include \"base64.h\"\n#include \"squid.h\"\n\nstatic HMODULE hModule;\nstatic DWORD cbMaxToken = 0;\nstatic uint8_t * pClientBuf = NULL;\nstatic uint8_t * pServerBuf = NULL;\nDELETE_SECURITY_CONTEXT_FN _DeleteSecurityContext = NULL;\nFREE_CREDENTIALS_HANDLE_FN _FreeCredentialsHandle = NULL;\n\nBOOL WINAPI SSP_LogonUser(PTSTR szUser, PTSTR szPassword, PTSTR szDomain)\n{\n    AUTH_SEQ    asServer   = {0};\n    AUTH_SEQ    asClient   = {0};\n    BOOL        fDone      = FALSE;\n    BOOL        fResult    = FALSE;\n    DWORD       cbOut      = 0;\n    DWORD       cbIn       = 0;\n\n    SEC_WINNT_AUTH_IDENTITY ai;\n\n    do {\n        if (!hModule)\n            break;\n\n        /* Initialize auth identity structure */\n        ZeroMemory(&ai, sizeof(ai));\n        ai.Domain = (unsigned char *)szDomain;\n        ai.DomainLength = lstrlen(szDomain);\n        ai.User = (unsigned char *)szUser;\n        ai.UserLength = lstrlen(szUser);\n        ai.Password = (unsigned char *)szPassword;\n        ai.PasswordLength = lstrlen(szPassword);\n#if defined(UNICODE) || defined(_UNICODE)\n        ai.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n#else\n        ai.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;\n#endif\n\n        /* Prepare client message (negotiate) */\n        cbOut = cbMaxToken;\n        if (!GenClientContext(&asClient, &ai, NULL, 0, pClientBuf, &cbOut, &fDone))\n            break;\n\n        /* Prepare server message (challenge) */\n        cbIn = cbOut;\n        cbOut = cbMaxToken;\n        if (!GenServerContext(&asServer, pClientBuf, cbIn, pServerBuf, &cbOut,\n                              &fDone, NULL))\n            break;\n        /* Most likely failure: AcceptServerContext fails with SEC_E_LOGON_DENIED\n         * in the case of bad szUser or szPassword.\n         * Unexpected Result: Logon will succeed if you pass in a bad szUser and\n         * the guest account is enabled in the specified domain.\n         */\n\n        /* Prepare client message (authenticate) */\n        cbIn = cbOut;\n        cbOut = cbMaxToken;\n        if (!GenClientContext(&asClient, &ai, pServerBuf, cbIn, pClientBuf, &cbOut,\n                              &fDone))\n            break;\n\n        /* Prepare server message (authentication) */\n        cbIn = cbOut;\n        cbOut = cbMaxToken;\n        if (!GenServerContext(&asServer, pClientBuf, cbIn, pServerBuf, &cbOut,\n                              &fDone, NULL))\n            break;\n        fResult = TRUE;\n    } while (0);\n\n    /* Clean up resources */\n    if (asClient.fHaveCtxtHandle)\n        _DeleteSecurityContext(&asClient.hctxt);\n    if (asClient.fHaveCredHandle)\n        _FreeCredentialsHandle(&asClient.hcred);\n    if (asServer.fHaveCtxtHandle)\n        _DeleteSecurityContext(&asServer.hctxt);\n    if (asServer.fHaveCredHandle)\n        _FreeCredentialsHandle(&asServer.hcred);\n\n    return fResult;\n}"
  },
  {
    "function_name": "GenServerContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/sspwin32.cc",
    "lines": "278-381",
    "snippet": "BOOL GenServerContext(PAUTH_SEQ pAS, PVOID pIn, DWORD cbIn, PVOID pOut,\n                      PDWORD pcbOut, PBOOL pfDone, char * credentials)\n{\n    /*\n     *   Routine Description:\n     *\n     *   Takes an input buffer coming from the client and returns a buffer\n     *   to be sent to the client.  Also returns an indication of whether or\n     *   not the context is complete.\n     *\n     *   Return Value:\n     *\n     *   Returns TRUE if successful; otherwise FALSE.\n     */\n\n    SecBufferDesc   sbdOut;\n    SecBuffer       sbOut;\n    SecBufferDesc   sbdIn;\n    SecBuffer       sbIn;\n    ULONG           fContextAttr;\n    SecPkgContext_Names namebuffer;\n\n    if (!pAS->fInitialized)  {\n        SecurityStatus = _AcquireCredentialsHandle(NULL, (SEC_CHAR*) _T(SSP_Package_InUse),\n                         SECPKG_CRED_INBOUND, NULL, NULL, NULL, NULL, &pAS->hcred,\n                         &pAS->hcredLifeTime);\n#if SSP_DEBUG\n        fprintf(stderr, \"AcquireCredentialsHandle returned: %x\\n\", SecurityStatus);\n#endif\n        if (SecurityStatus < 0) {\n#if SSP_DEBUG\n            fprintf(stderr, \"AcquireCredentialsHandle failed: %x\\n\", SecurityStatus);\n#endif\n            return FALSE;\n        }\n        pAS->fHaveCredHandle = TRUE;\n    }\n\n    /* Prepare output buffer */\n    sbdOut.ulVersion = 0;\n    sbdOut.cBuffers = 1;\n    sbdOut.pBuffers = &sbOut;\n    sbOut.cbBuffer = *pcbOut;\n    sbOut.BufferType = SECBUFFER_TOKEN;\n    sbOut.pvBuffer = pOut;\n\n    /* Prepare input buffer */\n    sbdIn.ulVersion = 0;\n    sbdIn.cBuffers = 1;\n    sbdIn.pBuffers = &sbIn;\n    sbIn.cbBuffer = cbIn;\n    sbIn.BufferType = SECBUFFER_TOKEN;\n    sbIn.pvBuffer = pIn;\n    SecurityStatus = _AcceptSecurityContext(&pAS->hcred,\n                                            pAS->fInitialized ? &pAS->hctxt : NULL, &sbdIn, (NTLM_mode == SSP_NTLM) ? ASC_REQ_DELEGATE : 0,\n                                            SECURITY_NATIVE_DREP, &pAS->hctxt, &sbdOut, &fContextAttr,\n                                            &pAS->hctxtLifeTime);\n#if SSP_DEBUG\n    fprintf(stderr, \"AcceptSecurityContext returned: %x\\n\", SecurityStatus);\n#endif\n    if (SecurityStatus < 0) {\n#if SSP_DEBUG\n        fprintf(stderr, \"AcceptSecurityContext failed: %x\\n\", SecurityStatus);\n#endif\n        return FALSE;\n    }\n    pAS->fHaveCtxtHandle = TRUE;\n\n    /* If necessary, complete token */\n    if (SecurityStatus == SEC_I_COMPLETE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE) {\n        SecurityStatus = _CompleteAuthToken(&pAS->hctxt, &sbdOut);\n#if SSP_DEBUG\n        fprintf(stderr, \"CompleteAuthToken returned: %x\\n\", SecurityStatus);\n#endif\n        if (SecurityStatus < 0) {\n#if SSP_DEBUG\n            fprintf(stderr, \"CompleteAuthToken failed: %x\\n\", SecurityStatus);\n#endif\n            return FALSE;\n        }\n    }\n\n    if ((credentials != NULL) &&\n            !(SecurityStatus == SEC_I_CONTINUE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE)) {\n        SecurityStatus = _QueryContextAttributes(&pAS->hctxt, SECPKG_ATTR_NAMES, &namebuffer);\n#if SSP_DEBUG\n        fprintf(stderr, \"QueryContextAttributes returned: %x\\n\", SecurityStatus);\n#endif\n        if (SecurityStatus < 0) {\n#if SSP_DEBUG\n            fprintf(stderr, \"QueryContextAttributes failed: %x\\n\", SecurityStatus);\n#endif\n            return FALSE;\n        }\n        strncpy(credentials, namebuffer.sUserName, SSP_MAX_CRED_LEN);\n    }\n\n    *pcbOut = sbOut.cbBuffer;\n    if (!pAS->fInitialized)\n        pAS->fInitialized = TRUE;\n    *pfDone = !(SecurityStatus == SEC_I_CONTINUE_NEEDED\n                || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE);\n    return TRUE;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sspwin32.h\"",
      "#include \"ntlmauth/ntlmauth.h\"",
      "#include \"base64.h\"",
      "#include \"squid.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "BOOL GenClientContext(PAUTH_SEQ, PSEC_WINNT_AUTH_IDENTITY, PVOID, DWORD, PVOID, PDWORD, PBOOL);",
      "BOOL GenServerContext(PAUTH_SEQ, PVOID, DWORD, PVOID, PDWORD, PBOOL, char *);",
      "static int NTLM_mode = SSP_BASIC;",
      "static char * SSP_Package_InUse;",
      "SECURITY_STATUS SecurityStatus = SEC_E_OK;",
      "ACCEPT_SECURITY_CONTEXT_FN _AcceptSecurityContext = NULL;",
      "ACQUIRE_CREDENTIALS_HANDLE_FN _AcquireCredentialsHandle = NULL;",
      "COMPLETE_AUTH_TOKEN_FN _CompleteAuthToken = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "credentials",
            "namebuffer.sUserName",
            "SSP_MAX_CRED_LEN"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"QueryContextAttributes failed: %x\\n\"",
            "SecurityStatus"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"QueryContextAttributes returned: %x\\n\"",
            "SecurityStatus"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_QueryContextAttributes",
          "args": [
            "&pAS->hctxt",
            "SECPKG_ATTR_NAMES",
            "&namebuffer"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"CompleteAuthToken failed: %x\\n\"",
            "SecurityStatus"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"CompleteAuthToken returned: %x\\n\"",
            "SecurityStatus"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_CompleteAuthToken",
          "args": [
            "&pAS->hctxt",
            "&sbdOut"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"AcceptSecurityContext failed: %x\\n\"",
            "SecurityStatus"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"AcceptSecurityContext returned: %x\\n\"",
            "SecurityStatus"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_AcceptSecurityContext",
          "args": [
            "&pAS->hcred",
            "pAS->fInitialized ? &pAS->hctxt : NULL",
            "&sbdIn",
            "(NTLM_mode == SSP_NTLM) ? ASC_REQ_DELEGATE : 0",
            "SECURITY_NATIVE_DREP",
            "&pAS->hctxt",
            "&sbdOut",
            "&fContextAttr",
            "&pAS->hctxtLifeTime"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"AcquireCredentialsHandle failed: %x\\n\"",
            "SecurityStatus"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"AcquireCredentialsHandle returned: %x\\n\"",
            "SecurityStatus"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_AcquireCredentialsHandle",
          "args": [
            "NULL",
            "(SEC_CHAR*) _T(SSP_Package_InUse)",
            "SECPKG_CRED_INBOUND",
            "NULL",
            "NULL",
            "NULL",
            "NULL",
            "&pAS->hcred",
            "&pAS->hcredLifeTime"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_T",
          "args": [
            "SSP_Package_InUse"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sspwin32.h\"\n#include \"ntlmauth/ntlmauth.h\"\n#include \"base64.h\"\n#include \"squid.h\"\n\nBOOL GenClientContext(PAUTH_SEQ, PSEC_WINNT_AUTH_IDENTITY, PVOID, DWORD, PVOID, PDWORD, PBOOL);\nBOOL GenServerContext(PAUTH_SEQ, PVOID, DWORD, PVOID, PDWORD, PBOOL, char *);\nstatic int NTLM_mode = SSP_BASIC;\nstatic char * SSP_Package_InUse;\nSECURITY_STATUS SecurityStatus = SEC_E_OK;\nACCEPT_SECURITY_CONTEXT_FN _AcceptSecurityContext = NULL;\nACQUIRE_CREDENTIALS_HANDLE_FN _AcquireCredentialsHandle = NULL;\nCOMPLETE_AUTH_TOKEN_FN _CompleteAuthToken = NULL;\n\nBOOL GenServerContext(PAUTH_SEQ pAS, PVOID pIn, DWORD cbIn, PVOID pOut,\n                      PDWORD pcbOut, PBOOL pfDone, char * credentials)\n{\n    /*\n     *   Routine Description:\n     *\n     *   Takes an input buffer coming from the client and returns a buffer\n     *   to be sent to the client.  Also returns an indication of whether or\n     *   not the context is complete.\n     *\n     *   Return Value:\n     *\n     *   Returns TRUE if successful; otherwise FALSE.\n     */\n\n    SecBufferDesc   sbdOut;\n    SecBuffer       sbOut;\n    SecBufferDesc   sbdIn;\n    SecBuffer       sbIn;\n    ULONG           fContextAttr;\n    SecPkgContext_Names namebuffer;\n\n    if (!pAS->fInitialized)  {\n        SecurityStatus = _AcquireCredentialsHandle(NULL, (SEC_CHAR*) _T(SSP_Package_InUse),\n                         SECPKG_CRED_INBOUND, NULL, NULL, NULL, NULL, &pAS->hcred,\n                         &pAS->hcredLifeTime);\n#if SSP_DEBUG\n        fprintf(stderr, \"AcquireCredentialsHandle returned: %x\\n\", SecurityStatus);\n#endif\n        if (SecurityStatus < 0) {\n#if SSP_DEBUG\n            fprintf(stderr, \"AcquireCredentialsHandle failed: %x\\n\", SecurityStatus);\n#endif\n            return FALSE;\n        }\n        pAS->fHaveCredHandle = TRUE;\n    }\n\n    /* Prepare output buffer */\n    sbdOut.ulVersion = 0;\n    sbdOut.cBuffers = 1;\n    sbdOut.pBuffers = &sbOut;\n    sbOut.cbBuffer = *pcbOut;\n    sbOut.BufferType = SECBUFFER_TOKEN;\n    sbOut.pvBuffer = pOut;\n\n    /* Prepare input buffer */\n    sbdIn.ulVersion = 0;\n    sbdIn.cBuffers = 1;\n    sbdIn.pBuffers = &sbIn;\n    sbIn.cbBuffer = cbIn;\n    sbIn.BufferType = SECBUFFER_TOKEN;\n    sbIn.pvBuffer = pIn;\n    SecurityStatus = _AcceptSecurityContext(&pAS->hcred,\n                                            pAS->fInitialized ? &pAS->hctxt : NULL, &sbdIn, (NTLM_mode == SSP_NTLM) ? ASC_REQ_DELEGATE : 0,\n                                            SECURITY_NATIVE_DREP, &pAS->hctxt, &sbdOut, &fContextAttr,\n                                            &pAS->hctxtLifeTime);\n#if SSP_DEBUG\n    fprintf(stderr, \"AcceptSecurityContext returned: %x\\n\", SecurityStatus);\n#endif\n    if (SecurityStatus < 0) {\n#if SSP_DEBUG\n        fprintf(stderr, \"AcceptSecurityContext failed: %x\\n\", SecurityStatus);\n#endif\n        return FALSE;\n    }\n    pAS->fHaveCtxtHandle = TRUE;\n\n    /* If necessary, complete token */\n    if (SecurityStatus == SEC_I_COMPLETE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE) {\n        SecurityStatus = _CompleteAuthToken(&pAS->hctxt, &sbdOut);\n#if SSP_DEBUG\n        fprintf(stderr, \"CompleteAuthToken returned: %x\\n\", SecurityStatus);\n#endif\n        if (SecurityStatus < 0) {\n#if SSP_DEBUG\n            fprintf(stderr, \"CompleteAuthToken failed: %x\\n\", SecurityStatus);\n#endif\n            return FALSE;\n        }\n    }\n\n    if ((credentials != NULL) &&\n            !(SecurityStatus == SEC_I_CONTINUE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE)) {\n        SecurityStatus = _QueryContextAttributes(&pAS->hctxt, SECPKG_ATTR_NAMES, &namebuffer);\n#if SSP_DEBUG\n        fprintf(stderr, \"QueryContextAttributes returned: %x\\n\", SecurityStatus);\n#endif\n        if (SecurityStatus < 0) {\n#if SSP_DEBUG\n            fprintf(stderr, \"QueryContextAttributes failed: %x\\n\", SecurityStatus);\n#endif\n            return FALSE;\n        }\n        strncpy(credentials, namebuffer.sUserName, SSP_MAX_CRED_LEN);\n    }\n\n    *pcbOut = sbOut.cbBuffer;\n    if (!pAS->fInitialized)\n        pAS->fInitialized = TRUE;\n    *pfDone = !(SecurityStatus == SEC_I_CONTINUE_NEEDED\n                || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE);\n    return TRUE;\n}"
  },
  {
    "function_name": "GenClientContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/sspwin32.cc",
    "lines": "210-276",
    "snippet": "BOOL GenClientContext(PAUTH_SEQ pAS, PSEC_WINNT_AUTH_IDENTITY pAuthIdentity,\n                      PVOID pIn, DWORD cbIn, PVOID pOut, PDWORD pcbOut, PBOOL pfDone)\n{\n    /*\n     *  Routine Description:\n     *\n     *  Optionally takes an input buffer coming from the server and returns\n     *  a buffer of information to send back to the server. Also returns\n     *  an indication of whether or not the context is complete.\n     *\n     *  Return Value:\n     *  Returns TRUE if successful; otherwise FALSE.\n     */\n    TimeStamp       tsExpiry;\n    SecBufferDesc   sbdOut;\n    SecBuffer       sbOut;\n    SecBufferDesc   sbdIn;\n    SecBuffer       sbIn;\n    ULONG           fContextAttr;\n\n    if (!pAS->fInitialized) {\n        SecurityStatus = _AcquireCredentialsHandle(NULL, (SEC_CHAR*) _T(SSP_Package_InUse),\n                         SECPKG_CRED_OUTBOUND, NULL, (NTLM_mode == SSP_NTLM) ? NULL : pAuthIdentity, NULL, NULL,\n                         &pAS->hcred, &tsExpiry);\n        if (SecurityStatus < 0)\n            return FALSE;\n        pAS->fHaveCredHandle = TRUE;\n    }\n\n    /* Prepare output buffer */\n    sbdOut.ulVersion = 0;\n    sbdOut.cBuffers = 1;\n    sbdOut.pBuffers = &sbOut;\n    sbOut.cbBuffer = *pcbOut;\n    sbOut.BufferType = SECBUFFER_TOKEN;\n    sbOut.pvBuffer = pOut;\n\n    /* Prepare input buffer */\n    if (pAS->fInitialized)  {\n        sbdIn.ulVersion = 0;\n        sbdIn.cBuffers = 1;\n        sbdIn.pBuffers = &sbIn;\n        sbIn.cbBuffer = cbIn;\n        sbIn.BufferType = SECBUFFER_TOKEN;\n        sbIn.pvBuffer = pIn;\n    }\n    SecurityStatus = _InitializeSecurityContext(&pAS->hcred,\n                     pAS->fInitialized ? &pAS->hctxt : NULL, NULL, 0, 0,\n                     SECURITY_NATIVE_DREP, pAS->fInitialized ? &sbdIn : NULL,\n                     0, &pAS->hctxt, &sbdOut, &fContextAttr, &tsExpiry);\n    if (SecurityStatus < 0)\n        return FALSE;\n    pAS->fHaveCtxtHandle = TRUE;\n\n    /* If necessary, complete token */\n    if (SecurityStatus == SEC_I_COMPLETE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE) {\n        SecurityStatus = _CompleteAuthToken(&pAS->hctxt, &sbdOut);\n        if (SecurityStatus < 0)\n            return FALSE;\n    }\n    *pcbOut = sbOut.cbBuffer;\n    if (!pAS->fInitialized)\n        pAS->fInitialized = TRUE;\n    *pfDone = !(SecurityStatus == SEC_I_CONTINUE_NEEDED\n                || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE );\n    return TRUE;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sspwin32.h\"",
      "#include \"ntlmauth/ntlmauth.h\"",
      "#include \"base64.h\"",
      "#include \"squid.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "BOOL GenClientContext(PAUTH_SEQ, PSEC_WINNT_AUTH_IDENTITY, PVOID, DWORD, PVOID, PDWORD, PBOOL);",
      "BOOL GenServerContext(PAUTH_SEQ, PVOID, DWORD, PVOID, PDWORD, PBOOL, char *);",
      "static int NTLM_mode = SSP_BASIC;",
      "static char * SSP_Package_InUse;",
      "SECURITY_STATUS SecurityStatus = SEC_E_OK;",
      "ACQUIRE_CREDENTIALS_HANDLE_FN _AcquireCredentialsHandle = NULL;",
      "COMPLETE_AUTH_TOKEN_FN _CompleteAuthToken = NULL;",
      "INITIALIZE_SECURITY_CONTEXT_FN _InitializeSecurityContext = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_CompleteAuthToken",
          "args": [
            "&pAS->hctxt",
            "&sbdOut"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_InitializeSecurityContext",
          "args": [
            "&pAS->hcred",
            "pAS->fInitialized ? &pAS->hctxt : NULL",
            "NULL",
            "0",
            "0",
            "SECURITY_NATIVE_DREP",
            "pAS->fInitialized ? &sbdIn : NULL",
            "0",
            "&pAS->hctxt",
            "&sbdOut",
            "&fContextAttr",
            "&tsExpiry"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_AcquireCredentialsHandle",
          "args": [
            "NULL",
            "(SEC_CHAR*) _T(SSP_Package_InUse)",
            "SECPKG_CRED_OUTBOUND",
            "NULL",
            "(NTLM_mode == SSP_NTLM) ? NULL : pAuthIdentity",
            "NULL",
            "NULL",
            "&pAS->hcred",
            "&tsExpiry"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_T",
          "args": [
            "SSP_Package_InUse"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sspwin32.h\"\n#include \"ntlmauth/ntlmauth.h\"\n#include \"base64.h\"\n#include \"squid.h\"\n\nBOOL GenClientContext(PAUTH_SEQ, PSEC_WINNT_AUTH_IDENTITY, PVOID, DWORD, PVOID, PDWORD, PBOOL);\nBOOL GenServerContext(PAUTH_SEQ, PVOID, DWORD, PVOID, PDWORD, PBOOL, char *);\nstatic int NTLM_mode = SSP_BASIC;\nstatic char * SSP_Package_InUse;\nSECURITY_STATUS SecurityStatus = SEC_E_OK;\nACQUIRE_CREDENTIALS_HANDLE_FN _AcquireCredentialsHandle = NULL;\nCOMPLETE_AUTH_TOKEN_FN _CompleteAuthToken = NULL;\nINITIALIZE_SECURITY_CONTEXT_FN _InitializeSecurityContext = NULL;\n\nBOOL GenClientContext(PAUTH_SEQ pAS, PSEC_WINNT_AUTH_IDENTITY pAuthIdentity,\n                      PVOID pIn, DWORD cbIn, PVOID pOut, PDWORD pcbOut, PBOOL pfDone)\n{\n    /*\n     *  Routine Description:\n     *\n     *  Optionally takes an input buffer coming from the server and returns\n     *  a buffer of information to send back to the server. Also returns\n     *  an indication of whether or not the context is complete.\n     *\n     *  Return Value:\n     *  Returns TRUE if successful; otherwise FALSE.\n     */\n    TimeStamp       tsExpiry;\n    SecBufferDesc   sbdOut;\n    SecBuffer       sbOut;\n    SecBufferDesc   sbdIn;\n    SecBuffer       sbIn;\n    ULONG           fContextAttr;\n\n    if (!pAS->fInitialized) {\n        SecurityStatus = _AcquireCredentialsHandle(NULL, (SEC_CHAR*) _T(SSP_Package_InUse),\n                         SECPKG_CRED_OUTBOUND, NULL, (NTLM_mode == SSP_NTLM) ? NULL : pAuthIdentity, NULL, NULL,\n                         &pAS->hcred, &tsExpiry);\n        if (SecurityStatus < 0)\n            return FALSE;\n        pAS->fHaveCredHandle = TRUE;\n    }\n\n    /* Prepare output buffer */\n    sbdOut.ulVersion = 0;\n    sbdOut.cBuffers = 1;\n    sbdOut.pBuffers = &sbOut;\n    sbOut.cbBuffer = *pcbOut;\n    sbOut.BufferType = SECBUFFER_TOKEN;\n    sbOut.pvBuffer = pOut;\n\n    /* Prepare input buffer */\n    if (pAS->fInitialized)  {\n        sbdIn.ulVersion = 0;\n        sbdIn.cBuffers = 1;\n        sbdIn.pBuffers = &sbIn;\n        sbIn.cbBuffer = cbIn;\n        sbIn.BufferType = SECBUFFER_TOKEN;\n        sbIn.pvBuffer = pIn;\n    }\n    SecurityStatus = _InitializeSecurityContext(&pAS->hcred,\n                     pAS->fInitialized ? &pAS->hctxt : NULL, NULL, 0, 0,\n                     SECURITY_NATIVE_DREP, pAS->fInitialized ? &sbdIn : NULL,\n                     0, &pAS->hctxt, &sbdOut, &fContextAttr, &tsExpiry);\n    if (SecurityStatus < 0)\n        return FALSE;\n    pAS->fHaveCtxtHandle = TRUE;\n\n    /* If necessary, complete token */\n    if (SecurityStatus == SEC_I_COMPLETE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE) {\n        SecurityStatus = _CompleteAuthToken(&pAS->hctxt, &sbdOut);\n        if (SecurityStatus < 0)\n            return FALSE;\n    }\n    *pcbOut = sbOut.cbBuffer;\n    if (!pAS->fInitialized)\n        pAS->fInitialized = TRUE;\n    *pfDone = !(SecurityStatus == SEC_I_CONTINUE_NEEDED\n                || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE );\n    return TRUE;\n}"
  },
  {
    "function_name": "LoadSecurityDll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/sspwin32.cc",
    "lines": "84-208",
    "snippet": "HMODULE LoadSecurityDll(int mode, const char * SSP_Package)\n{\n    TCHAR lpszDLL[MAX_PATH];\n    OSVERSIONINFO VerInfo;\n    PSecPkgInfo pSPI       = NULL;\n\n    /*\n    *  Find out which security DLL to use, depending on\n    *  whether we are on NT or 2000 or XP or 2003 Server\n    *  We have to use security.dll on Windows NT 4.0.\n    *  All other operating systems, we have to use Secur32.dll\n    */\n    hModule = NULL;\n    if ((mode != SSP_BASIC) && (mode != SSP_NTLM))\n        return hModule;\n    NTLM_mode = mode;\n    VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);\n    if (!GetVersionEx (&VerInfo)) {   /* If this fails, something has gone wrong */\n        return hModule;\n    }\n    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&\n            VerInfo.dwMajorVersion == 4 &&\n            VerInfo.dwMinorVersion == 0) {\n        lstrcpy (lpszDLL, _T(WINNT_SECURITY_DLL));\n    } else {\n        lstrcpy (lpszDLL, _T(WIN2K_SECURITY_DLL));\n    }\n    hModule = LoadLibrary(lpszDLL);\n    if (!hModule)\n        return hModule;\n    _AcceptSecurityContext = (ACCEPT_SECURITY_CONTEXT_FN)\n                             GetProcAddress(hModule, \"AcceptSecurityContext\");\n    if (!_AcceptSecurityContext) {\n        UnloadSecurityDll();\n        hModule = NULL;\n        return hModule;\n    }\n#ifdef UNICODE\n    _AcquireCredentialsHandle = (ACQUIRE_CREDENTIALS_HANDLE_FN)\n                                GetProcAddress(hModule, \"AcquireCredentialsHandleW\");\n#else\n    _AcquireCredentialsHandle = (ACQUIRE_CREDENTIALS_HANDLE_FN)\n                                GetProcAddress(hModule, \"AcquireCredentialsHandleA\");\n#endif\n    if (!_AcquireCredentialsHandle) {\n        UnloadSecurityDll();\n        hModule = NULL;\n        return hModule;\n    }\n    _CompleteAuthToken = (COMPLETE_AUTH_TOKEN_FN)\n                         GetProcAddress(hModule, \"CompleteAuthToken\");\n    if (!_CompleteAuthToken) {\n        UnloadSecurityDll();\n        hModule = NULL;\n        return hModule;\n    }\n    _DeleteSecurityContext = (DELETE_SECURITY_CONTEXT_FN)\n                             GetProcAddress(hModule, \"DeleteSecurityContext\");\n    if (!_DeleteSecurityContext) {\n        UnloadSecurityDll();\n        hModule = NULL;\n        return hModule;\n    }\n    _FreeContextBuffer = (FREE_CONTEXT_BUFFER_FN)\n                         GetProcAddress(hModule, \"FreeContextBuffer\");\n    if (!_FreeContextBuffer) {\n        UnloadSecurityDll();\n        hModule = NULL;\n        return hModule;\n    }\n    _FreeCredentialsHandle = (FREE_CREDENTIALS_HANDLE_FN)\n                             GetProcAddress(hModule, \"FreeCredentialsHandle\");\n    if (!_FreeCredentialsHandle) {\n        UnloadSecurityDll();\n        hModule = NULL;\n        return hModule;\n    }\n#ifdef UNICODE\n    _InitializeSecurityContext = (INITIALIZE_SECURITY_CONTEXT_FN)\n                                 GetProcAddress(hModule, \"InitializeSecurityContextW\");\n#else\n    _InitializeSecurityContext = (INITIALIZE_SECURITY_CONTEXT_FN)\n                                 GetProcAddress(hModule, \"InitializeSecurityContextA\");\n#endif\n    if (!_InitializeSecurityContext) {\n        UnloadSecurityDll();\n        hModule = NULL;\n        return hModule;\n    }\n#ifdef UNICODE\n    _QuerySecurityPackageInfo = (QUERY_SECURITY_PACKAGE_INFO_FN)\n                                GetProcAddress(hModule, \"QuerySecurityPackageInfoW\");\n#else\n    _QuerySecurityPackageInfo = (QUERY_SECURITY_PACKAGE_INFO_FN)\n                                GetProcAddress(hModule, \"QuerySecurityPackageInfoA\");\n#endif\n    if (!_QuerySecurityPackageInfo) {\n        UnloadSecurityDll();\n        hModule = NULL;\n    }\n\n#ifdef UNICODE\n    _QueryContextAttributes = (QUERY_CONTEXT_ATTRIBUTES_FN_W)\n                              GetProcAddress(hModule, \"QueryContextAttributesW\");\n#else\n    _QueryContextAttributes = (QUERY_CONTEXT_ATTRIBUTES_FN_A)\n                              GetProcAddress(hModule, \"QueryContextAttributesA\");\n#endif\n    if (!_QueryContextAttributes) {\n        UnloadSecurityDll();\n        hModule = NULL;\n    }\n\n    /* Get max token size */\n    _QuerySecurityPackageInfo((SEC_CHAR*)_T(SSP_Package), &pSPI);\n    cbMaxToken = pSPI->cbMaxToken;\n    _FreeContextBuffer(pSPI);\n\n    /* Allocate buffers for client and server messages */\n    pClientBuf = static_cast<uint8_t *>(xcalloc(cbMaxToken, sizeof(char)));\n    pServerBuf = static_cast<uint8_t *>(xcalloc(cbMaxToken, sizeof(char)));\n    SSP_Package_InUse = xstrdup(SSP_Package);\n\n    return hModule;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sspwin32.h\"",
      "#include \"ntlmauth/ntlmauth.h\"",
      "#include \"base64.h\"",
      "#include \"squid.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HMODULE hModule;",
      "static int NTLM_mode = SSP_BASIC;",
      "static char * SSP_Package_InUse;",
      "static DWORD cbMaxToken = 0;",
      "static uint8_t * pClientBuf = NULL;",
      "static uint8_t * pServerBuf = NULL;",
      "ACCEPT_SECURITY_CONTEXT_FN _AcceptSecurityContext = NULL;",
      "ACQUIRE_CREDENTIALS_HANDLE_FN _AcquireCredentialsHandle = NULL;",
      "COMPLETE_AUTH_TOKEN_FN _CompleteAuthToken = NULL;",
      "DELETE_SECURITY_CONTEXT_FN _DeleteSecurityContext = NULL;",
      "FREE_CONTEXT_BUFFER_FN _FreeContextBuffer = NULL;",
      "FREE_CREDENTIALS_HANDLE_FN _FreeCredentialsHandle = NULL;",
      "INITIALIZE_SECURITY_CONTEXT_FN _InitializeSecurityContext = NULL;",
      "QUERY_SECURITY_PACKAGE_INFO_FN _QuerySecurityPackageInfo = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "SSP_Package"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint8_t *>",
          "args": [
            "xcalloc(cbMaxToken, sizeof(char))"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "cbMaxToken",
            "sizeof(char)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint8_t *>",
          "args": [
            "xcalloc(cbMaxToken, sizeof(char))"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "cbMaxToken",
            "sizeof(char)"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_FreeContextBuffer",
          "args": [
            "pSPI"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_QuerySecurityPackageInfo",
          "args": [
            "(SEC_CHAR*)_T(SSP_Package)",
            "&pSPI"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_T",
          "args": [
            "SSP_Package"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnloadSecurityDll",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"QueryContextAttributesA\""
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"QueryContextAttributesW\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnloadSecurityDll",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"QuerySecurityPackageInfoA\""
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"QuerySecurityPackageInfoW\""
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnloadSecurityDll",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"InitializeSecurityContextA\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"InitializeSecurityContextW\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnloadSecurityDll",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"FreeCredentialsHandle\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnloadSecurityDll",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"FreeContextBuffer\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnloadSecurityDll",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"DeleteSecurityContext\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnloadSecurityDll",
          "args": [],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"CompleteAuthToken\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnloadSecurityDll",
          "args": [],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"AcquireCredentialsHandleA\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"AcquireCredentialsHandleW\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnloadSecurityDll",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"AcceptSecurityContext\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LoadLibrary",
          "args": [
            "lpszDLL"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstrcpy",
          "args": [
            "lpszDLL",
            "_T(WIN2K_SECURITY_DLL)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_T",
          "args": [
            "WIN2K_SECURITY_DLL"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstrcpy",
          "args": [
            "lpszDLL",
            "_T(WINNT_SECURITY_DLL)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_T",
          "args": [
            "WINNT_SECURITY_DLL"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetVersionEx",
          "args": [
            "&VerInfo"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sspwin32.h\"\n#include \"ntlmauth/ntlmauth.h\"\n#include \"base64.h\"\n#include \"squid.h\"\n\nstatic HMODULE hModule;\nstatic int NTLM_mode = SSP_BASIC;\nstatic char * SSP_Package_InUse;\nstatic DWORD cbMaxToken = 0;\nstatic uint8_t * pClientBuf = NULL;\nstatic uint8_t * pServerBuf = NULL;\nACCEPT_SECURITY_CONTEXT_FN _AcceptSecurityContext = NULL;\nACQUIRE_CREDENTIALS_HANDLE_FN _AcquireCredentialsHandle = NULL;\nCOMPLETE_AUTH_TOKEN_FN _CompleteAuthToken = NULL;\nDELETE_SECURITY_CONTEXT_FN _DeleteSecurityContext = NULL;\nFREE_CONTEXT_BUFFER_FN _FreeContextBuffer = NULL;\nFREE_CREDENTIALS_HANDLE_FN _FreeCredentialsHandle = NULL;\nINITIALIZE_SECURITY_CONTEXT_FN _InitializeSecurityContext = NULL;\nQUERY_SECURITY_PACKAGE_INFO_FN _QuerySecurityPackageInfo = NULL;\n\nHMODULE LoadSecurityDll(int mode, const char * SSP_Package)\n{\n    TCHAR lpszDLL[MAX_PATH];\n    OSVERSIONINFO VerInfo;\n    PSecPkgInfo pSPI       = NULL;\n\n    /*\n    *  Find out which security DLL to use, depending on\n    *  whether we are on NT or 2000 or XP or 2003 Server\n    *  We have to use security.dll on Windows NT 4.0.\n    *  All other operating systems, we have to use Secur32.dll\n    */\n    hModule = NULL;\n    if ((mode != SSP_BASIC) && (mode != SSP_NTLM))\n        return hModule;\n    NTLM_mode = mode;\n    VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);\n    if (!GetVersionEx (&VerInfo)) {   /* If this fails, something has gone wrong */\n        return hModule;\n    }\n    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&\n            VerInfo.dwMajorVersion == 4 &&\n            VerInfo.dwMinorVersion == 0) {\n        lstrcpy (lpszDLL, _T(WINNT_SECURITY_DLL));\n    } else {\n        lstrcpy (lpszDLL, _T(WIN2K_SECURITY_DLL));\n    }\n    hModule = LoadLibrary(lpszDLL);\n    if (!hModule)\n        return hModule;\n    _AcceptSecurityContext = (ACCEPT_SECURITY_CONTEXT_FN)\n                             GetProcAddress(hModule, \"AcceptSecurityContext\");\n    if (!_AcceptSecurityContext) {\n        UnloadSecurityDll();\n        hModule = NULL;\n        return hModule;\n    }\n#ifdef UNICODE\n    _AcquireCredentialsHandle = (ACQUIRE_CREDENTIALS_HANDLE_FN)\n                                GetProcAddress(hModule, \"AcquireCredentialsHandleW\");\n#else\n    _AcquireCredentialsHandle = (ACQUIRE_CREDENTIALS_HANDLE_FN)\n                                GetProcAddress(hModule, \"AcquireCredentialsHandleA\");\n#endif\n    if (!_AcquireCredentialsHandle) {\n        UnloadSecurityDll();\n        hModule = NULL;\n        return hModule;\n    }\n    _CompleteAuthToken = (COMPLETE_AUTH_TOKEN_FN)\n                         GetProcAddress(hModule, \"CompleteAuthToken\");\n    if (!_CompleteAuthToken) {\n        UnloadSecurityDll();\n        hModule = NULL;\n        return hModule;\n    }\n    _DeleteSecurityContext = (DELETE_SECURITY_CONTEXT_FN)\n                             GetProcAddress(hModule, \"DeleteSecurityContext\");\n    if (!_DeleteSecurityContext) {\n        UnloadSecurityDll();\n        hModule = NULL;\n        return hModule;\n    }\n    _FreeContextBuffer = (FREE_CONTEXT_BUFFER_FN)\n                         GetProcAddress(hModule, \"FreeContextBuffer\");\n    if (!_FreeContextBuffer) {\n        UnloadSecurityDll();\n        hModule = NULL;\n        return hModule;\n    }\n    _FreeCredentialsHandle = (FREE_CREDENTIALS_HANDLE_FN)\n                             GetProcAddress(hModule, \"FreeCredentialsHandle\");\n    if (!_FreeCredentialsHandle) {\n        UnloadSecurityDll();\n        hModule = NULL;\n        return hModule;\n    }\n#ifdef UNICODE\n    _InitializeSecurityContext = (INITIALIZE_SECURITY_CONTEXT_FN)\n                                 GetProcAddress(hModule, \"InitializeSecurityContextW\");\n#else\n    _InitializeSecurityContext = (INITIALIZE_SECURITY_CONTEXT_FN)\n                                 GetProcAddress(hModule, \"InitializeSecurityContextA\");\n#endif\n    if (!_InitializeSecurityContext) {\n        UnloadSecurityDll();\n        hModule = NULL;\n        return hModule;\n    }\n#ifdef UNICODE\n    _QuerySecurityPackageInfo = (QUERY_SECURITY_PACKAGE_INFO_FN)\n                                GetProcAddress(hModule, \"QuerySecurityPackageInfoW\");\n#else\n    _QuerySecurityPackageInfo = (QUERY_SECURITY_PACKAGE_INFO_FN)\n                                GetProcAddress(hModule, \"QuerySecurityPackageInfoA\");\n#endif\n    if (!_QuerySecurityPackageInfo) {\n        UnloadSecurityDll();\n        hModule = NULL;\n    }\n\n#ifdef UNICODE\n    _QueryContextAttributes = (QUERY_CONTEXT_ATTRIBUTES_FN_W)\n                              GetProcAddress(hModule, \"QueryContextAttributesW\");\n#else\n    _QueryContextAttributes = (QUERY_CONTEXT_ATTRIBUTES_FN_A)\n                              GetProcAddress(hModule, \"QueryContextAttributesA\");\n#endif\n    if (!_QueryContextAttributes) {\n        UnloadSecurityDll();\n        hModule = NULL;\n    }\n\n    /* Get max token size */\n    _QuerySecurityPackageInfo((SEC_CHAR*)_T(SSP_Package), &pSPI);\n    cbMaxToken = pSPI->cbMaxToken;\n    _FreeContextBuffer(pSPI);\n\n    /* Allocate buffers for client and server messages */\n    pClientBuf = static_cast<uint8_t *>(xcalloc(cbMaxToken, sizeof(char)));\n    pServerBuf = static_cast<uint8_t *>(xcalloc(cbMaxToken, sizeof(char)));\n    SSP_Package_InUse = xstrdup(SSP_Package);\n\n    return hModule;\n}"
  },
  {
    "function_name": "UnloadSecurityDll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2019-12529/repo/lib/sspwin32.cc",
    "lines": "57-82",
    "snippet": "void UnloadSecurityDll(void)\n{\n    if (NTLM_asServer.fHaveCtxtHandle)\n        _DeleteSecurityContext(&NTLM_asServer.hctxt);\n    if (NTLM_asServer.fHaveCredHandle)\n        _FreeCredentialsHandle(&NTLM_asServer.hcred);\n\n    if (hModule)\n        FreeLibrary(hModule);\n\n    xfree(SSP_Package_InUse);\n    xfree(pClientBuf);\n    xfree(pServerBuf);\n\n    _AcceptSecurityContext      = NULL;\n    _AcquireCredentialsHandle   = NULL;\n    _CompleteAuthToken          = NULL;\n    _DeleteSecurityContext      = NULL;\n    _FreeContextBuffer          = NULL;\n    _FreeCredentialsHandle      = NULL;\n    _InitializeSecurityContext  = NULL;\n    _QuerySecurityPackageInfo   = NULL;\n    _QueryContextAttributes     = NULL;\n\n    hModule = NULL;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sspwin32.h\"",
      "#include \"ntlmauth/ntlmauth.h\"",
      "#include \"base64.h\"",
      "#include \"squid.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HMODULE hModule;",
      "static char * SSP_Package_InUse;",
      "static uint8_t * pClientBuf = NULL;",
      "static uint8_t * pServerBuf = NULL;",
      "static AUTH_SEQ NTLM_asServer = {0};",
      "ACCEPT_SECURITY_CONTEXT_FN _AcceptSecurityContext = NULL;",
      "ACQUIRE_CREDENTIALS_HANDLE_FN _AcquireCredentialsHandle = NULL;",
      "COMPLETE_AUTH_TOKEN_FN _CompleteAuthToken = NULL;",
      "DELETE_SECURITY_CONTEXT_FN _DeleteSecurityContext = NULL;",
      "FREE_CONTEXT_BUFFER_FN _FreeContextBuffer = NULL;",
      "FREE_CREDENTIALS_HANDLE_FN _FreeCredentialsHandle = NULL;",
      "INITIALIZE_SECURITY_CONTEXT_FN _InitializeSecurityContext = NULL;",
      "QUERY_SECURITY_PACKAGE_INFO_FN _QuerySecurityPackageInfo = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "pServerBuf"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "pClientBuf"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "SSP_Package_InUse"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeLibrary",
          "args": [
            "hModule"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_FreeCredentialsHandle",
          "args": [
            "&NTLM_asServer.hcred"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_DeleteSecurityContext",
          "args": [
            "&NTLM_asServer.hctxt"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sspwin32.h\"\n#include \"ntlmauth/ntlmauth.h\"\n#include \"base64.h\"\n#include \"squid.h\"\n\nstatic HMODULE hModule;\nstatic char * SSP_Package_InUse;\nstatic uint8_t * pClientBuf = NULL;\nstatic uint8_t * pServerBuf = NULL;\nstatic AUTH_SEQ NTLM_asServer = {0};\nACCEPT_SECURITY_CONTEXT_FN _AcceptSecurityContext = NULL;\nACQUIRE_CREDENTIALS_HANDLE_FN _AcquireCredentialsHandle = NULL;\nCOMPLETE_AUTH_TOKEN_FN _CompleteAuthToken = NULL;\nDELETE_SECURITY_CONTEXT_FN _DeleteSecurityContext = NULL;\nFREE_CONTEXT_BUFFER_FN _FreeContextBuffer = NULL;\nFREE_CREDENTIALS_HANDLE_FN _FreeCredentialsHandle = NULL;\nINITIALIZE_SECURITY_CONTEXT_FN _InitializeSecurityContext = NULL;\nQUERY_SECURITY_PACKAGE_INFO_FN _QuerySecurityPackageInfo = NULL;\n\nvoid UnloadSecurityDll(void)\n{\n    if (NTLM_asServer.fHaveCtxtHandle)\n        _DeleteSecurityContext(&NTLM_asServer.hctxt);\n    if (NTLM_asServer.fHaveCredHandle)\n        _FreeCredentialsHandle(&NTLM_asServer.hcred);\n\n    if (hModule)\n        FreeLibrary(hModule);\n\n    xfree(SSP_Package_InUse);\n    xfree(pClientBuf);\n    xfree(pServerBuf);\n\n    _AcceptSecurityContext      = NULL;\n    _AcquireCredentialsHandle   = NULL;\n    _CompleteAuthToken          = NULL;\n    _DeleteSecurityContext      = NULL;\n    _FreeContextBuffer          = NULL;\n    _FreeCredentialsHandle      = NULL;\n    _InitializeSecurityContext  = NULL;\n    _QuerySecurityPackageInfo   = NULL;\n    _QueryContextAttributes     = NULL;\n\n    hModule = NULL;\n}"
  }
]