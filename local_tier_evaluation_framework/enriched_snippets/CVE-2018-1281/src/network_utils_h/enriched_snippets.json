[
  {
    "function_name": "GetAvailablePort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/network_utils.h",
    "lines": "226-255",
    "snippet": "int GetAvailablePort() {\n  struct sockaddr_in addr;\n  addr.sin_port = htons(0);  // have system pick up a random port available for me\n  addr.sin_family = AF_INET;  // IPV4\n  addr.sin_addr.s_addr = htonl(INADDR_ANY);  // set our addr to any interface\n\n  int sock = socket(AF_INET, SOCK_STREAM, 0);\n  if (0 != bind(sock, (struct sockaddr*)&addr, sizeof(struct sockaddr_in))) {\n    perror(\"bind():\");\n    return 0;\n  }\n#ifdef _MSC_VER\n  int addr_len = sizeof(struct sockaddr_in);\n#else\n  socklen_t addr_len = sizeof(struct sockaddr_in);\n#endif\n\n  if (0 != getsockname(sock, (struct sockaddr*)&addr, &addr_len)) {\n    perror(\"getsockname():\");\n    return 0;\n  }\n\n  int ret_port = ntohs(addr.sin_port);\n#ifdef  _MSC_VER\n  closesocket(sock);\n#else\n  close(sock);\n#endif\n  return ret_port;\n}",
    "includes": [
      "#include <string>",
      "#include <netinet/in.h>",
      "#include <ifaddrs.h>",
      "#include <arpa/inet.h>",
      "#include <net/if.h>",
      "#include <iphlpapi.h>",
      "#include <windows.h>",
      "#include <winsock2.h>",
      "#include <tchar.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "sock"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "addr.sin_port"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"getsockname():\""
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "sock",
            "(struct sockaddr*)&addr",
            "&addr_len"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"bind():\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "sock",
            "(struct sockaddr*)&addr",
            "sizeof(struct sockaddr_in)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_STREAM",
            "0"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_ANY"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "0"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string>\n#include <netinet/in.h>\n#include <ifaddrs.h>\n#include <arpa/inet.h>\n#include <net/if.h>\n#include <iphlpapi.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <tchar.h>\n#include <unistd.h>\n\nint GetAvailablePort() {\n  struct sockaddr_in addr;\n  addr.sin_port = htons(0);  // have system pick up a random port available for me\n  addr.sin_family = AF_INET;  // IPV4\n  addr.sin_addr.s_addr = htonl(INADDR_ANY);  // set our addr to any interface\n\n  int sock = socket(AF_INET, SOCK_STREAM, 0);\n  if (0 != bind(sock, (struct sockaddr*)&addr, sizeof(struct sockaddr_in))) {\n    perror(\"bind():\");\n    return 0;\n  }\n#ifdef _MSC_VER\n  int addr_len = sizeof(struct sockaddr_in);\n#else\n  socklen_t addr_len = sizeof(struct sockaddr_in);\n#endif\n\n  if (0 != getsockname(sock, (struct sockaddr*)&addr, &addr_len)) {\n    perror(\"getsockname():\");\n    return 0;\n  }\n\n  int ret_port = ntohs(addr.sin_port);\n#ifdef  _MSC_VER\n  closesocket(sock);\n#else\n  close(sock);\n#endif\n  return ret_port;\n}"
  },
  {
    "function_name": "GetAvailableInterfaceAndIP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/network_utils.h",
    "lines": "121-218",
    "snippet": "void GetAvailableInterfaceAndIP(\n    std::string* interface, std::string* ip) {\n#ifdef _MSC_VER\n  typedef std::basic_string<TCHAR> tstring;\n  IP_ADAPTER_INFO * pAdapterInfo = NULL;\n  {\n    ULONG bufLen = 0;\n    for (int i = 0; i < 5; i++) {\n      DWORD apRet = GetAdaptersInfo(pAdapterInfo, &bufLen);\n      if (apRet == ERROR_BUFFER_OVERFLOW) {\n        free(pAdapterInfo);  // in case we had previously allocated it\n        pAdapterInfo = static_cast<IP_ADAPTER_INFO*>(malloc(bufLen));\n      } else if (apRet == ERROR_SUCCESS) {\n        break;\n      } else {\n        free(pAdapterInfo);\n        pAdapterInfo = NULL;\n        break;\n      }\n    }\n  }\n  if (pAdapterInfo) {\n    tstring keybase = _T(\n        \"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Network\\\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\\\\");\n    tstring connection = _T(\"\\\\Connection\");\n\n    IP_ADAPTER_INFO *curpAdapterInfo = pAdapterInfo;\n    HKEY hKEY = NULL;\n    while (curpAdapterInfo) {\n      std::string curip(curpAdapterInfo->IpAddressList.IpAddress.String);\n      if (curip == \"127.0.0.1\") {\n        curpAdapterInfo = curpAdapterInfo->Next;\n        continue;\n      }\n      if (curip == \"0.0.0.0\") {\n        curpAdapterInfo = curpAdapterInfo->Next;\n        continue;\n      }\n\n      std::string AdapterName = curpAdapterInfo->AdapterName;\n      // GUID only ascii\n      tstring key_set = keybase + tstring(AdapterName.begin(), AdapterName.end()) + connection;\n      LPCTSTR data_Set = key_set.c_str();\n      LPCTSTR dwValue = NULL;\n      if (ERROR_SUCCESS ==\n          ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, data_Set, 0, KEY_READ, &hKEY)) {\n        DWORD dwSize = 0;\n        DWORD dwType = REG_SZ;\n        if (ERROR_SUCCESS ==\n            ::RegQueryValueEx(hKEY, _T(\"Name\"), 0, &dwType, (LPBYTE)dwValue, &dwSize)) {\n          dwValue = new TCHAR[dwSize];\n          if (ERROR_SUCCESS ==\n              ::RegQueryValueEx(hKEY, _T(\"Name\"), 0, &dwType, (LPBYTE)dwValue, &dwSize)) {\n            // interface name must only ascii\n            tstring tstr = dwValue;\n            std::string s(tstr.begin(), tstr.end());\n\n            *interface = s;\n            *ip = curip;\n            break;\n          }\n        }\n        ::RegCloseKey(hKEY);\n        hKEY = NULL;\n      }\n      curpAdapterInfo = curpAdapterInfo->Next;\n    }\n    if (hKEY != NULL) {\n      ::RegCloseKey(hKEY);\n    }\n    free(pAdapterInfo);\n  }\n#else\n  struct ifaddrs * ifAddrStruct = nullptr;\n  struct ifaddrs * ifa = nullptr;\n\n  interface->clear();\n  ip->clear();\n  getifaddrs(&ifAddrStruct);\n  for (ifa = ifAddrStruct; ifa != nullptr; ifa = ifa->ifa_next) {\n    if (nullptr == ifa->ifa_addr) continue;\n\n    if (AF_INET == ifa->ifa_addr->sa_family &&\n        0 == (ifa->ifa_flags & IFF_LOOPBACK)) {\n      char address_buffer[INET_ADDRSTRLEN];\n      void* sin_addr_ptr = &(reinterpret_cast<struct sockaddr_in*>(ifa->ifa_addr))->sin_addr;\n      inet_ntop(AF_INET, sin_addr_ptr, address_buffer, INET_ADDRSTRLEN);\n\n      *ip = address_buffer;\n      *interface = ifa->ifa_name;\n\n      break;\n    }\n  }\n  if (nullptr != ifAddrStruct) freeifaddrs(ifAddrStruct);\n  return;\n#endif\n}",
    "includes": [
      "#include <string>",
      "#include <netinet/in.h>",
      "#include <ifaddrs.h>",
      "#include <arpa/inet.h>",
      "#include <net/if.h>",
      "#include <iphlpapi.h>",
      "#include <windows.h>",
      "#include <winsock2.h>",
      "#include <tchar.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeifaddrs",
          "args": [
            "ifAddrStruct"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntop",
          "args": [
            "AF_INET",
            "sin_addr_ptr",
            "address_buffer",
            "INET_ADDRSTRLEN"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<struct sockaddr_in*>",
          "args": [
            "ifa->ifa_addr"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getifaddrs",
          "args": [
            "&ifAddrStruct"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip->clear",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interface->clear",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pAdapterInfo"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::RegCloseKey",
          "args": [
            "hKEY"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::RegCloseKey",
          "args": [
            "hKEY"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tstr.end",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tstr.begin",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::RegQueryValueEx",
          "args": [
            "hKEY",
            "_T(\"Name\")",
            "0",
            "&dwType",
            "(LPBYTE)dwValue",
            "&dwSize"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_T",
          "args": [
            "\"Name\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::RegQueryValueEx",
          "args": [
            "hKEY",
            "_T(\"Name\")",
            "0",
            "&dwType",
            "(LPBYTE)dwValue",
            "&dwSize"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_T",
          "args": [
            "\"Name\""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::RegOpenKeyEx",
          "args": [
            "HKEY_LOCAL_MACHINE",
            "data_Set",
            "0",
            "KEY_READ",
            "&hKEY"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_set.c_str",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tstring",
          "args": [
            "AdapterName.begin()",
            "AdapterName.end()"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdapterName.end",
          "args": [],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdapterName.begin",
          "args": [],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_T",
          "args": [
            "\"\\\\Connection\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_T",
          "args": [
            "\"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Network\\\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\\\\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pAdapterInfo"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<IP_ADAPTER_INFO*>",
          "args": [
            "malloc(bufLen)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "bufLen"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pAdapterInfo"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAdaptersInfo",
          "args": [
            "pAdapterInfo",
            "&bufLen"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string>\n#include <netinet/in.h>\n#include <ifaddrs.h>\n#include <arpa/inet.h>\n#include <net/if.h>\n#include <iphlpapi.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <tchar.h>\n#include <unistd.h>\n\nvoid GetAvailableInterfaceAndIP(\n    std::string* interface, std::string* ip) {\n#ifdef _MSC_VER\n  typedef std::basic_string<TCHAR> tstring;\n  IP_ADAPTER_INFO * pAdapterInfo = NULL;\n  {\n    ULONG bufLen = 0;\n    for (int i = 0; i < 5; i++) {\n      DWORD apRet = GetAdaptersInfo(pAdapterInfo, &bufLen);\n      if (apRet == ERROR_BUFFER_OVERFLOW) {\n        free(pAdapterInfo);  // in case we had previously allocated it\n        pAdapterInfo = static_cast<IP_ADAPTER_INFO*>(malloc(bufLen));\n      } else if (apRet == ERROR_SUCCESS) {\n        break;\n      } else {\n        free(pAdapterInfo);\n        pAdapterInfo = NULL;\n        break;\n      }\n    }\n  }\n  if (pAdapterInfo) {\n    tstring keybase = _T(\n        \"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Network\\\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\\\\");\n    tstring connection = _T(\"\\\\Connection\");\n\n    IP_ADAPTER_INFO *curpAdapterInfo = pAdapterInfo;\n    HKEY hKEY = NULL;\n    while (curpAdapterInfo) {\n      std::string curip(curpAdapterInfo->IpAddressList.IpAddress.String);\n      if (curip == \"127.0.0.1\") {\n        curpAdapterInfo = curpAdapterInfo->Next;\n        continue;\n      }\n      if (curip == \"0.0.0.0\") {\n        curpAdapterInfo = curpAdapterInfo->Next;\n        continue;\n      }\n\n      std::string AdapterName = curpAdapterInfo->AdapterName;\n      // GUID only ascii\n      tstring key_set = keybase + tstring(AdapterName.begin(), AdapterName.end()) + connection;\n      LPCTSTR data_Set = key_set.c_str();\n      LPCTSTR dwValue = NULL;\n      if (ERROR_SUCCESS ==\n          ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, data_Set, 0, KEY_READ, &hKEY)) {\n        DWORD dwSize = 0;\n        DWORD dwType = REG_SZ;\n        if (ERROR_SUCCESS ==\n            ::RegQueryValueEx(hKEY, _T(\"Name\"), 0, &dwType, (LPBYTE)dwValue, &dwSize)) {\n          dwValue = new TCHAR[dwSize];\n          if (ERROR_SUCCESS ==\n              ::RegQueryValueEx(hKEY, _T(\"Name\"), 0, &dwType, (LPBYTE)dwValue, &dwSize)) {\n            // interface name must only ascii\n            tstring tstr = dwValue;\n            std::string s(tstr.begin(), tstr.end());\n\n            *interface = s;\n            *ip = curip;\n            break;\n          }\n        }\n        ::RegCloseKey(hKEY);\n        hKEY = NULL;\n      }\n      curpAdapterInfo = curpAdapterInfo->Next;\n    }\n    if (hKEY != NULL) {\n      ::RegCloseKey(hKEY);\n    }\n    free(pAdapterInfo);\n  }\n#else\n  struct ifaddrs * ifAddrStruct = nullptr;\n  struct ifaddrs * ifa = nullptr;\n\n  interface->clear();\n  ip->clear();\n  getifaddrs(&ifAddrStruct);\n  for (ifa = ifAddrStruct; ifa != nullptr; ifa = ifa->ifa_next) {\n    if (nullptr == ifa->ifa_addr) continue;\n\n    if (AF_INET == ifa->ifa_addr->sa_family &&\n        0 == (ifa->ifa_flags & IFF_LOOPBACK)) {\n      char address_buffer[INET_ADDRSTRLEN];\n      void* sin_addr_ptr = &(reinterpret_cast<struct sockaddr_in*>(ifa->ifa_addr))->sin_addr;\n      inet_ntop(AF_INET, sin_addr_ptr, address_buffer, INET_ADDRSTRLEN);\n\n      *ip = address_buffer;\n      *interface = ifa->ifa_name;\n\n      break;\n    }\n  }\n  if (nullptr != ifAddrStruct) freeifaddrs(ifAddrStruct);\n  return;\n#endif\n}"
  },
  {
    "function_name": "GetIP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/network_utils.h",
    "lines": "28-112",
    "snippet": "void GetIP(const std::string& interface, std::string* ip) {\n#ifdef _MSC_VER\n  typedef std::basic_string<TCHAR> tstring;\n  // Try to get the Adapters-info table, so we can given useful names to the IP\n  // addresses we are returning.  Gotta call GetAdaptersInfo() up to 5 times to handle\n  // the potential race condition between the size-query call and the get-data call.\n  // I love a well-designed API :^P\n  IP_ADAPTER_INFO * pAdapterInfo = NULL;\n  {\n    ULONG bufLen = 0;\n    for (int i = 0; i < 5; i++) {\n      DWORD apRet = GetAdaptersInfo(pAdapterInfo, &bufLen);\n      if (apRet == ERROR_BUFFER_OVERFLOW) {\n        free(pAdapterInfo);  // in case we had previously allocated it\n        pAdapterInfo = static_cast<IP_ADAPTER_INFO*>(malloc(bufLen));\n      } else if (apRet == ERROR_SUCCESS) {\n        break;\n      } else {\n        free(pAdapterInfo);\n        pAdapterInfo = NULL;\n        break;\n      }\n    }\n  }\n  if (pAdapterInfo) {\n    tstring keybase = _T(\n        \"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Network\\\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\\\\");\n    tstring connection = _T(\"\\\\Connection\");\n\n    IP_ADAPTER_INFO *curpAdapterInfo = pAdapterInfo;\n    while (curpAdapterInfo) {\n      HKEY hKEY;\n      std::string AdapterName = curpAdapterInfo->AdapterName;\n      // GUID only ascii\n      tstring key_set = keybase + tstring(AdapterName.begin(), AdapterName.end()) + connection;\n      LPCTSTR data_Set = key_set.c_str();\n      LPCTSTR dwValue = NULL;\n      if (ERROR_SUCCESS ==\n          ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, data_Set, 0, KEY_READ, &hKEY)) {\n        DWORD dwSize = 0;\n        DWORD dwType = REG_SZ;\n        if (ERROR_SUCCESS ==\n            ::RegQueryValueEx(hKEY, _T(\"Name\"), 0, &dwType, (LPBYTE)dwValue, &dwSize)) {\n          dwValue = new TCHAR[dwSize];\n          if (ERROR_SUCCESS ==\n              ::RegQueryValueEx(hKEY, _T(\"Name\"), 0, &dwType, (LPBYTE)dwValue, &dwSize)) {\n            // interface name must only ascii\n            tstring tstr = dwValue;\n            std::string s(tstr.begin(), tstr.end());\n            if (s == interface) {\n              *ip = curpAdapterInfo->IpAddressList.IpAddress.String;\n              break;\n            }\n          }\n        }\n        ::RegCloseKey(hKEY);\n      }\n      curpAdapterInfo = curpAdapterInfo->Next;\n    }\n    free(pAdapterInfo);\n  }\n#else\n  struct ifaddrs * ifAddrStruct = NULL;\n  struct ifaddrs * ifa = NULL;\n  void * tmpAddrPtr = NULL;\n\n  getifaddrs(&ifAddrStruct);\n  for (ifa = ifAddrStruct; ifa != NULL; ifa = ifa->ifa_next) {\n    if (ifa->ifa_addr == NULL) continue;\n    if (ifa->ifa_addr->sa_family == AF_INET) {\n      // is a valid IP4 Address\n      tmpAddrPtr = &(reinterpret_cast<struct sockaddr_in*>(ifa->ifa_addr))->sin_addr;\n      char addressBuffer[INET_ADDRSTRLEN];\n      inet_ntop(AF_INET, tmpAddrPtr, addressBuffer, INET_ADDRSTRLEN);\n      if (strncmp(ifa->ifa_name,\n                  interface.c_str(),\n                  interface.size()) == 0) {\n        *ip = addressBuffer;\n        break;\n      }\n    }\n  }\n  if (ifAddrStruct != NULL) freeifaddrs(ifAddrStruct);\n#endif\n}",
    "includes": [
      "#include <string>",
      "#include <netinet/in.h>",
      "#include <ifaddrs.h>",
      "#include <arpa/inet.h>",
      "#include <net/if.h>",
      "#include <iphlpapi.h>",
      "#include <windows.h>",
      "#include <winsock2.h>",
      "#include <tchar.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeifaddrs",
          "args": [
            "ifAddrStruct"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ifa->ifa_name",
            "interface.c_str()",
            "interface.size()"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interface.size",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interface.c_str",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntop",
          "args": [
            "AF_INET",
            "tmpAddrPtr",
            "addressBuffer",
            "INET_ADDRSTRLEN"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<struct sockaddr_in*>",
          "args": [
            "ifa->ifa_addr"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getifaddrs",
          "args": [
            "&ifAddrStruct"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pAdapterInfo"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::RegCloseKey",
          "args": [
            "hKEY"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tstr.end",
          "args": [],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tstr.begin",
          "args": [],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::RegQueryValueEx",
          "args": [
            "hKEY",
            "_T(\"Name\")",
            "0",
            "&dwType",
            "(LPBYTE)dwValue",
            "&dwSize"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_T",
          "args": [
            "\"Name\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::RegQueryValueEx",
          "args": [
            "hKEY",
            "_T(\"Name\")",
            "0",
            "&dwType",
            "(LPBYTE)dwValue",
            "&dwSize"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_T",
          "args": [
            "\"Name\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::RegOpenKeyEx",
          "args": [
            "HKEY_LOCAL_MACHINE",
            "data_Set",
            "0",
            "KEY_READ",
            "&hKEY"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_set.c_str",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tstring",
          "args": [
            "AdapterName.begin()",
            "AdapterName.end()"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdapterName.end",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdapterName.begin",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_T",
          "args": [
            "\"\\\\Connection\""
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_T",
          "args": [
            "\"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Network\\\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\\\\""
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pAdapterInfo"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<IP_ADAPTER_INFO*>",
          "args": [
            "malloc(bufLen)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "bufLen"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pAdapterInfo"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAdaptersInfo",
          "args": [
            "pAdapterInfo",
            "&bufLen"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string>\n#include <netinet/in.h>\n#include <ifaddrs.h>\n#include <arpa/inet.h>\n#include <net/if.h>\n#include <iphlpapi.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <tchar.h>\n#include <unistd.h>\n\nvoid GetIP(const std::string& interface, std::string* ip) {\n#ifdef _MSC_VER\n  typedef std::basic_string<TCHAR> tstring;\n  // Try to get the Adapters-info table, so we can given useful names to the IP\n  // addresses we are returning.  Gotta call GetAdaptersInfo() up to 5 times to handle\n  // the potential race condition between the size-query call and the get-data call.\n  // I love a well-designed API :^P\n  IP_ADAPTER_INFO * pAdapterInfo = NULL;\n  {\n    ULONG bufLen = 0;\n    for (int i = 0; i < 5; i++) {\n      DWORD apRet = GetAdaptersInfo(pAdapterInfo, &bufLen);\n      if (apRet == ERROR_BUFFER_OVERFLOW) {\n        free(pAdapterInfo);  // in case we had previously allocated it\n        pAdapterInfo = static_cast<IP_ADAPTER_INFO*>(malloc(bufLen));\n      } else if (apRet == ERROR_SUCCESS) {\n        break;\n      } else {\n        free(pAdapterInfo);\n        pAdapterInfo = NULL;\n        break;\n      }\n    }\n  }\n  if (pAdapterInfo) {\n    tstring keybase = _T(\n        \"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Network\\\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\\\\");\n    tstring connection = _T(\"\\\\Connection\");\n\n    IP_ADAPTER_INFO *curpAdapterInfo = pAdapterInfo;\n    while (curpAdapterInfo) {\n      HKEY hKEY;\n      std::string AdapterName = curpAdapterInfo->AdapterName;\n      // GUID only ascii\n      tstring key_set = keybase + tstring(AdapterName.begin(), AdapterName.end()) + connection;\n      LPCTSTR data_Set = key_set.c_str();\n      LPCTSTR dwValue = NULL;\n      if (ERROR_SUCCESS ==\n          ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, data_Set, 0, KEY_READ, &hKEY)) {\n        DWORD dwSize = 0;\n        DWORD dwType = REG_SZ;\n        if (ERROR_SUCCESS ==\n            ::RegQueryValueEx(hKEY, _T(\"Name\"), 0, &dwType, (LPBYTE)dwValue, &dwSize)) {\n          dwValue = new TCHAR[dwSize];\n          if (ERROR_SUCCESS ==\n              ::RegQueryValueEx(hKEY, _T(\"Name\"), 0, &dwType, (LPBYTE)dwValue, &dwSize)) {\n            // interface name must only ascii\n            tstring tstr = dwValue;\n            std::string s(tstr.begin(), tstr.end());\n            if (s == interface) {\n              *ip = curpAdapterInfo->IpAddressList.IpAddress.String;\n              break;\n            }\n          }\n        }\n        ::RegCloseKey(hKEY);\n      }\n      curpAdapterInfo = curpAdapterInfo->Next;\n    }\n    free(pAdapterInfo);\n  }\n#else\n  struct ifaddrs * ifAddrStruct = NULL;\n  struct ifaddrs * ifa = NULL;\n  void * tmpAddrPtr = NULL;\n\n  getifaddrs(&ifAddrStruct);\n  for (ifa = ifAddrStruct; ifa != NULL; ifa = ifa->ifa_next) {\n    if (ifa->ifa_addr == NULL) continue;\n    if (ifa->ifa_addr->sa_family == AF_INET) {\n      // is a valid IP4 Address\n      tmpAddrPtr = &(reinterpret_cast<struct sockaddr_in*>(ifa->ifa_addr))->sin_addr;\n      char addressBuffer[INET_ADDRSTRLEN];\n      inet_ntop(AF_INET, tmpAddrPtr, addressBuffer, INET_ADDRSTRLEN);\n      if (strncmp(ifa->ifa_name,\n                  interface.c_str(),\n                  interface.size()) == 0) {\n        *ip = addressBuffer;\n        break;\n      }\n    }\n  }\n  if (ifAddrStruct != NULL) freeifaddrs(ifAddrStruct);\n#endif\n}"
  }
]