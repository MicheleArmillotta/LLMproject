[
  {
    "function_name": "Heartbeat",
    "container": "Van",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/van.cc",
    "lines": "409-421",
    "snippet": "void Van::Heartbeat() {\n  const char* val = Environment::Get()->find(\"PS_HEARTBEAT_INTERVAL\");\n  const int interval = val ? atoi(val) : kDefaultHeartbeatInterval;\n  while (interval > 0 && ready_) {\n    std::this_thread::sleep_for(std::chrono::seconds(interval));\n    Message msg;\n    msg.meta.recver = kScheduler;\n    msg.meta.control.cmd = Control::HEARTBEAT;\n    msg.meta.control.node.push_back(my_node_);\n    msg.meta.timestamp = timestamp_++;\n    Send(msg);\n  }\n}",
    "includes": [
      "#include \"./resender.h\"",
      "#include \"./zmq_van.h\"",
      "#include \"./meta.pb.h\"",
      "#include \"./network_utils.h\"",
      "#include \"ps/internal/customer.h\"",
      "#include \"ps/internal/postoffice.h\"",
      "#include \"ps/sarray.h\"",
      "#include \"ps/base.h\"",
      "#include <chrono>",
      "#include <thread>",
      "#include \"ps/internal/van.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Send",
          "args": [
            "msg"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "Send",
          "container": "Van",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/van.cc",
          "lines": "130-139",
          "snippet": "int Van::Send(const Message& msg) {\n  int send_bytes = SendMsg(msg);\n  CHECK_NE(send_bytes, -1);\n  send_bytes_ += send_bytes;\n  if (resender_) resender_->AddOutgoing(msg);\n  if (Postoffice::Get()->verbose() >= 2) {\n    PS_VLOG(2) << msg.DebugString();\n  }\n  return send_bytes;\n}",
          "includes": [
            "#include \"./resender.h\"",
            "#include \"./zmq_van.h\"",
            "#include \"./meta.pb.h\"",
            "#include \"./network_utils.h\"",
            "#include \"ps/internal/customer.h\"",
            "#include \"ps/internal/postoffice.h\"",
            "#include \"ps/sarray.h\"",
            "#include \"ps/base.h\"",
            "#include <chrono>",
            "#include <thread>",
            "#include \"ps/internal/van.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"./resender.h\"\n#include \"./zmq_van.h\"\n#include \"./meta.pb.h\"\n#include \"./network_utils.h\"\n#include \"ps/internal/customer.h\"\n#include \"ps/internal/postoffice.h\"\n#include \"ps/sarray.h\"\n#include \"ps/base.h\"\n#include <chrono>\n#include <thread>\n#include \"ps/internal/van.h\"\n\nVan {\n  int Van::Send(const Message& msg) {\n    int send_bytes = SendMsg(msg);\n    CHECK_NE(send_bytes, -1);\n    send_bytes_ += send_bytes;\n    if (resender_) resender_->AddOutgoing(msg);\n    if (Postoffice::Get()->verbose() >= 2) {\n      PS_VLOG(2) << msg.DebugString();\n    }\n    return send_bytes;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "msg.meta.control.node.push_back",
          "args": [
            "my_node_"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::this_thread::sleep_for",
          "args": [
            "std::chrono::seconds(interval)"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::chrono::seconds",
          "args": [
            "interval"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "val"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [
            "\"PS_HEARTBEAT_INTERVAL\""
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"./resender.h\"\n#include \"./zmq_van.h\"\n#include \"./meta.pb.h\"\n#include \"./network_utils.h\"\n#include \"ps/internal/customer.h\"\n#include \"ps/internal/postoffice.h\"\n#include \"ps/sarray.h\"\n#include \"ps/base.h\"\n#include <chrono>\n#include <thread>\n#include \"ps/internal/van.h\"\n\nVan {\n  void Van::Heartbeat() {\n    const char* val = Environment::Get()->find(\"PS_HEARTBEAT_INTERVAL\");\n    const int interval = val ? atoi(val) : kDefaultHeartbeatInterval;\n    while (interval > 0 && ready_) {\n      std::this_thread::sleep_for(std::chrono::seconds(interval));\n      Message msg;\n      msg.meta.recver = kScheduler;\n      msg.meta.control.cmd = Control::HEARTBEAT;\n      msg.meta.control.node.push_back(my_node_);\n      msg.meta.timestamp = timestamp_++;\n      Send(msg);\n    }\n  }\n}"
  },
  {
    "function_name": "UnpackMeta",
    "container": "Van",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/van.cc",
    "lines": "371-407",
    "snippet": "void Van::UnpackMeta(const char* meta_buf, int buf_size, Meta* meta) {\n  // to protobuf\n  PBMeta pb;\n  CHECK(pb.ParseFromArray(meta_buf, buf_size))\n      << \"failed to parse string into protobuf\";\n\n  // to meta\n  meta->head = pb.head();\n  meta->customer_id = pb.has_customer_id() ? pb.customer_id() : Meta::kEmpty;\n  meta->timestamp = pb.has_timestamp() ? pb.timestamp() : Meta::kEmpty;\n  meta->request = pb.request();\n  meta->push = pb.push();\n  meta->simple_app = pb.simple_app();\n  meta->body = pb.body();\n  meta->data_type.resize(pb.data_type_size());\n  for (int i = 0; i < pb.data_type_size(); ++i) {\n    meta->data_type[i] = static_cast<DataType>(pb.data_type(i));\n  }\n  if (pb.has_control()) {\n    const auto& ctrl = pb.control();\n    meta->control.cmd = static_cast<Control::Command>(ctrl.cmd());\n    meta->control.barrier_group = ctrl.barrier_group();\n    meta->control.msg_sig = ctrl.msg_sig();\n    for (int i = 0; i < ctrl.node_size(); ++i) {\n      const auto& p = ctrl.node(i);\n      Node n;\n      n.role = static_cast<Node::Role>(p.role());\n      n.port = p.port();\n      n.hostname = p.hostname();\n      n.id = p.has_id() ? p.id() : Node::kEmpty;\n      n.is_recovery = p.is_recovery();\n      meta->control.node.push_back(n);\n    }\n  } else {\n    meta->control.cmd = Control::EMPTY;\n  }\n}",
    "includes": [
      "#include \"./resender.h\"",
      "#include \"./zmq_van.h\"",
      "#include \"./meta.pb.h\"",
      "#include \"./network_utils.h\"",
      "#include \"ps/internal/customer.h\"",
      "#include \"ps/internal/postoffice.h\"",
      "#include \"ps/sarray.h\"",
      "#include \"ps/base.h\"",
      "#include <chrono>",
      "#include <thread>",
      "#include \"ps/internal/van.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "meta->control.node.push_back",
          "args": [
            "n"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.is_recovery",
          "args": [],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.id",
          "args": [],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.has_id",
          "args": [],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.hostname",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.port",
          "args": [],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<Node::Role>",
          "args": [
            "p.role()"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.role",
          "args": [],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctrl.node",
          "args": [
            "i"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctrl.node_size",
          "args": [],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctrl.msg_sig",
          "args": [],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctrl.barrier_group",
          "args": [],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<Control::Command>",
          "args": [
            "ctrl.cmd()"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctrl.cmd",
          "args": [],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.control",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.has_control",
          "args": [],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<DataType>",
          "args": [
            "pb.data_type(i)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.data_type",
          "args": [
            "i"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.data_type_size",
          "args": [],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "meta->data_type.resize",
          "args": [
            "pb.data_type_size()"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.data_type_size",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.body",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.simple_app",
          "args": [],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.push",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.request",
          "args": [],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.timestamp",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.has_timestamp",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.customer_id",
          "args": [],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.has_customer_id",
          "args": [],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.head",
          "args": [],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "pb.ParseFromArray(meta_buf, buf_size)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.ParseFromArray",
          "args": [
            "meta_buf",
            "buf_size"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"./resender.h\"\n#include \"./zmq_van.h\"\n#include \"./meta.pb.h\"\n#include \"./network_utils.h\"\n#include \"ps/internal/customer.h\"\n#include \"ps/internal/postoffice.h\"\n#include \"ps/sarray.h\"\n#include \"ps/base.h\"\n#include <chrono>\n#include <thread>\n#include \"ps/internal/van.h\"\n\nVan {\n  void Van::UnpackMeta(const char* meta_buf, int buf_size, Meta* meta) {\n    // to protobuf\n    PBMeta pb;\n    CHECK(pb.ParseFromArray(meta_buf, buf_size))\n        << \"failed to parse string into protobuf\";\n  \n    // to meta\n    meta->head = pb.head();\n    meta->customer_id = pb.has_customer_id() ? pb.customer_id() : Meta::kEmpty;\n    meta->timestamp = pb.has_timestamp() ? pb.timestamp() : Meta::kEmpty;\n    meta->request = pb.request();\n    meta->push = pb.push();\n    meta->simple_app = pb.simple_app();\n    meta->body = pb.body();\n    meta->data_type.resize(pb.data_type_size());\n    for (int i = 0; i < pb.data_type_size(); ++i) {\n      meta->data_type[i] = static_cast<DataType>(pb.data_type(i));\n    }\n    if (pb.has_control()) {\n      const auto& ctrl = pb.control();\n      meta->control.cmd = static_cast<Control::Command>(ctrl.cmd());\n      meta->control.barrier_group = ctrl.barrier_group();\n      meta->control.msg_sig = ctrl.msg_sig();\n      for (int i = 0; i < ctrl.node_size(); ++i) {\n        const auto& p = ctrl.node(i);\n        Node n;\n        n.role = static_cast<Node::Role>(p.role());\n        n.port = p.port();\n        n.hostname = p.hostname();\n        n.id = p.has_id() ? p.id() : Node::kEmpty;\n        n.is_recovery = p.is_recovery();\n        meta->control.node.push_back(n);\n      }\n    } else {\n      meta->control.cmd = Control::EMPTY;\n    }\n  }\n}"
  },
  {
    "function_name": "PackMeta",
    "container": "Van",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/van.cc",
    "lines": "335-369",
    "snippet": "void Van::PackMeta(const Meta& meta, char** meta_buf, int* buf_size) {\n  // convert into protobuf\n  PBMeta pb;\n  pb.set_head(meta.head);\n  if (meta.customer_id != Meta::kEmpty) pb.set_customer_id(meta.customer_id);\n  if (meta.timestamp != Meta::kEmpty) pb.set_timestamp(meta.timestamp);\n  if (meta.body.size()) pb.set_body(meta.body);\n  pb.set_push(meta.push);\n  pb.set_request(meta.request);\n  pb.set_simple_app(meta.simple_app);\n  for (auto d : meta.data_type) pb.add_data_type(d);\n  if (!meta.control.empty()) {\n    auto ctrl = pb.mutable_control();\n    ctrl->set_cmd(meta.control.cmd);\n    if (meta.control.cmd == Control::BARRIER) {\n      ctrl->set_barrier_group(meta.control.barrier_group);\n    } else if (meta.control.cmd == Control::ACK) {\n      ctrl->set_msg_sig(meta.control.msg_sig);\n    }\n    for (const auto& n : meta.control.node) {\n      auto p = ctrl->add_node();\n      p->set_id(n.id);\n      p->set_role(n.role);\n      p->set_port(n.port);\n      p->set_hostname(n.hostname);\n      p->set_is_recovery(n.is_recovery);\n    }\n  }\n\n  // to string\n  *buf_size = pb.ByteSize();\n  *meta_buf = new char[*buf_size+1];\n  CHECK(pb.SerializeToArray(*meta_buf, *buf_size))\n      << \"failed to serialize protbuf\";\n}",
    "includes": [
      "#include \"./resender.h\"",
      "#include \"./zmq_van.h\"",
      "#include \"./meta.pb.h\"",
      "#include \"./network_utils.h\"",
      "#include \"ps/internal/customer.h\"",
      "#include \"ps/internal/postoffice.h\"",
      "#include \"ps/sarray.h\"",
      "#include \"ps/base.h\"",
      "#include <chrono>",
      "#include <thread>",
      "#include \"ps/internal/van.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "pb.SerializeToArray(*meta_buf, *buf_size)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.SerializeToArray",
          "args": [
            "*meta_buf",
            "*buf_size"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.ByteSize",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->set_is_recovery",
          "args": [
            "n.is_recovery"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->set_hostname",
          "args": [
            "n.hostname"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->set_port",
          "args": [
            "n.port"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->set_role",
          "args": [
            "n.role"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->set_id",
          "args": [
            "n.id"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctrl->add_node",
          "args": [],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctrl->set_msg_sig",
          "args": [
            "meta.control.msg_sig"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctrl->set_barrier_group",
          "args": [
            "meta.control.barrier_group"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctrl->set_cmd",
          "args": [
            "meta.control.cmd"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.mutable_control",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "meta.control.empty",
          "args": [],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.add_data_type",
          "args": [
            "d"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.set_simple_app",
          "args": [
            "meta.simple_app"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.set_request",
          "args": [
            "meta.request"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.set_push",
          "args": [
            "meta.push"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.set_body",
          "args": [
            "meta.body"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "meta.body.size",
          "args": [],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.set_timestamp",
          "args": [
            "meta.timestamp"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.set_customer_id",
          "args": [
            "meta.customer_id"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pb.set_head",
          "args": [
            "meta.head"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"./resender.h\"\n#include \"./zmq_van.h\"\n#include \"./meta.pb.h\"\n#include \"./network_utils.h\"\n#include \"ps/internal/customer.h\"\n#include \"ps/internal/postoffice.h\"\n#include \"ps/sarray.h\"\n#include \"ps/base.h\"\n#include <chrono>\n#include <thread>\n#include \"ps/internal/van.h\"\n\nVan {\n  void Van::PackMeta(const Meta& meta, char** meta_buf, int* buf_size) {\n    // convert into protobuf\n    PBMeta pb;\n    pb.set_head(meta.head);\n    if (meta.customer_id != Meta::kEmpty) pb.set_customer_id(meta.customer_id);\n    if (meta.timestamp != Meta::kEmpty) pb.set_timestamp(meta.timestamp);\n    if (meta.body.size()) pb.set_body(meta.body);\n    pb.set_push(meta.push);\n    pb.set_request(meta.request);\n    pb.set_simple_app(meta.simple_app);\n    for (auto d : meta.data_type) pb.add_data_type(d);\n    if (!meta.control.empty()) {\n      auto ctrl = pb.mutable_control();\n      ctrl->set_cmd(meta.control.cmd);\n      if (meta.control.cmd == Control::BARRIER) {\n        ctrl->set_barrier_group(meta.control.barrier_group);\n      } else if (meta.control.cmd == Control::ACK) {\n        ctrl->set_msg_sig(meta.control.msg_sig);\n      }\n      for (const auto& n : meta.control.node) {\n        auto p = ctrl->add_node();\n        p->set_id(n.id);\n        p->set_role(n.role);\n        p->set_port(n.port);\n        p->set_hostname(n.hostname);\n        p->set_is_recovery(n.is_recovery);\n      }\n    }\n  \n    // to string\n    *buf_size = pb.ByteSize();\n    *meta_buf = new char[*buf_size+1];\n    CHECK(pb.SerializeToArray(*meta_buf, *buf_size))\n        << \"failed to serialize protbuf\";\n  }\n}"
  },
  {
    "function_name": "Receiving",
    "container": "Van",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/van.cc",
    "lines": "141-333",
    "snippet": "void Van::Receiving() {\n  const char* heartbeat_timeout_val = Environment::Get()->find(\"PS_HEARTBEAT_TIMEOUT\");\n  const int heartbeat_timeout\n      = heartbeat_timeout_val ? atoi(heartbeat_timeout_val) : kDefaultHeartbeatInterval;\n  Meta nodes;  // for scheduler usage\n  while (true) {\n    Message msg;\n    int recv_bytes = RecvMsg(&msg);\n\n    // For debug, drop received message\n    if (ready_ && drop_rate_ > 0) {\n      unsigned seed = time(NULL) + my_node_.id;\n      if (rand_r(&seed) % 100 < drop_rate_) {\n        LOG(WARNING) << \"Drop message \" << msg.DebugString();\n        continue;\n      }\n    }\n\n    CHECK_NE(recv_bytes, -1);\n    recv_bytes_ += recv_bytes;\n    if (Postoffice::Get()->verbose() >= 2) {\n      PS_VLOG(2) << msg.DebugString();\n    }\n    // duplicated message\n    if (resender_ && resender_->AddIncomming(msg)) continue;\n\n    if (!msg.meta.control.empty()) {\n      // do some management\n      auto& ctrl = msg.meta.control;\n      if (ctrl.cmd == Control::TERMINATE) {\n        PS_VLOG(1) << my_node_.ShortDebugString() << \" is stopped\";\n        ready_ = false;\n        break;\n      } else if (ctrl.cmd == Control::ADD_NODE) {\n        size_t num_nodes = Postoffice::Get()->num_servers() +\n                           Postoffice::Get()->num_workers();\n        auto dead_nodes = Postoffice::Get()->GetDeadNodes(heartbeat_timeout);\n        std::unordered_set<int> dead_set(dead_nodes.begin(), dead_nodes.end());\n        Meta recovery_nodes;  // store recovery nodes\n        recovery_nodes.control.cmd = Control::ADD_NODE;\n        // assign an id\n        if (msg.meta.sender == Meta::kEmpty) {\n          CHECK(is_scheduler_);\n          CHECK_EQ(ctrl.node.size(), 1);\n          if (nodes.control.node.size() < num_nodes) {\n            nodes.control.node.push_back(ctrl.node[0]);\n          } else {\n            // some node dies and restarts\n            CHECK(ready_);\n            for (size_t i = 0; i < nodes.control.node.size() - 1; ++i) {\n              const auto& node = nodes.control.node[i];\n              if (dead_set.find(node.id) != dead_set.end() && node.role == ctrl.node[0].role) {\n                auto& recovery_node = ctrl.node[0];\n                // assign previous node id\n                recovery_node.id = node.id;\n                recovery_node.is_recovery = true;\n                PS_VLOG(1) << \"replace dead node \" << node.DebugString()\n                           << \" by node \" << recovery_node.DebugString();\n                nodes.control.node[i] = recovery_node;\n                recovery_nodes.control.node.push_back(recovery_node);\n                break;\n              }\n            }\n          }\n        }\n\n        // update my id\n        for (size_t i = 0; i < ctrl.node.size(); ++i) {\n          const auto& node = ctrl.node[i];\n          if (my_node_.hostname == node.hostname &&\n              my_node_.port == node.port) {\n            my_node_ = node;\n            std::string rank = std::to_string(Postoffice::IDtoRank(node.id));\n#ifdef _MSC_VER\n            _putenv_s(\"DMLC_RANK\", rank.c_str());\n#else\n            setenv(\"DMLC_RANK\", rank.c_str(), true);\n#endif\n          }\n        }\n\n        if (is_scheduler_) {\n          time_t t = time(NULL);\n          if (nodes.control.node.size() == num_nodes) {\n            // sort the nodes according their ip and port,\n            std::sort(nodes.control.node.begin(), nodes.control.node.end(),\n                      [](const Node& a, const Node& b) {\n                        return (a.hostname.compare(b.hostname) | (a.port < b.port)) > 0;\n                      });\n            // assign node rank\n            for (auto& node : nodes.control.node) {\n              CHECK_EQ(node.id, Node::kEmpty);\n              int id = node.role == Node::SERVER ?\n                       Postoffice::ServerRankToID(num_servers_) :\n                       Postoffice::WorkerRankToID(num_workers_);\n              PS_VLOG(1) << \"assign rank=\" << id << \" to node \" << node.DebugString();\n              node.id = id;\n              Connect(node);\n              if (node.role == Node::SERVER) ++num_servers_;\n              if (node.role == Node::WORKER) ++num_workers_;\n              Postoffice::Get()->UpdateHeartbeat(node.id, t);\n            }\n            nodes.control.node.push_back(my_node_);\n            nodes.control.cmd = Control::ADD_NODE;\n            Message back; back.meta = nodes;\n            for (int r : Postoffice::Get()->GetNodeIDs(\n                     kWorkerGroup + kServerGroup)) {\n              back.meta.recver = r;\n              back.meta.timestamp = timestamp_++;\n              Send(back);\n            }\n            PS_VLOG(1) << \"the scheduler is connected to \"\n                    << num_workers_ << \" workers and \" << num_servers_ << \" servers\";\n            ready_ = true;\n          } else if (recovery_nodes.control.node.size() > 0) {\n            // send back the recovery node\n            CHECK_EQ(recovery_nodes.control.node.size(), 1);\n            Connect(recovery_nodes.control.node[0]);\n            Postoffice::Get()->UpdateHeartbeat(recovery_nodes.control.node[0].id, t);\n            Message back;\n            for (int r : Postoffice::Get()->GetNodeIDs(\n                     kWorkerGroup + kServerGroup)) {\n              if (r != recovery_nodes.control.node[0].id\n                    && dead_set.find(r) != dead_set.end()) {\n                // do not try to send anything to dead node\n                continue;\n              }\n              // only send recovery_node to nodes already exist\n              // but send all nodes to the recovery_node\n              back.meta = (r == recovery_nodes.control.node[0].id) ? nodes : recovery_nodes;\n              back.meta.recver = r;\n              back.meta.timestamp = timestamp_++;\n              Send(back);\n            }\n          }\n        } else {\n          for (const auto& node : ctrl.node) {\n            Connect(node);\n            if (!node.is_recovery && node.role == Node::SERVER) ++num_servers_;\n            if (!node.is_recovery && node.role == Node::WORKER) ++num_workers_;\n          }\n          PS_VLOG(1) << my_node_.ShortDebugString() << \" is connected to others\";\n          ready_ = true;\n        }\n      } else if (ctrl.cmd == Control::BARRIER) {\n        if (msg.meta.request) {\n          if (barrier_count_.empty()) {\n            barrier_count_.resize(8, 0);\n          }\n          int group = ctrl.barrier_group;\n          ++barrier_count_[group];\n          PS_VLOG(1) << \"Barrier count for \" << group << \" : \" << barrier_count_[group];\n          if (barrier_count_[group] ==\n              static_cast<int>(Postoffice::Get()->GetNodeIDs(group).size())) {\n            barrier_count_[group] = 0;\n            Message res;\n            res.meta.request = false;\n            res.meta.control.cmd = Control::BARRIER;\n            for (int r : Postoffice::Get()->GetNodeIDs(group)) {\n              res.meta.recver = r;\n              res.meta.timestamp = timestamp_++;\n              CHECK_GT(Send(res), 0);\n            }\n          }\n        } else {\n          Postoffice::Get()->Manage(msg);\n        }\n      } else if (ctrl.cmd == Control::HEARTBEAT) {\n        time_t t = time(NULL);\n        for (auto &node : ctrl.node) {\n          Postoffice::Get()->UpdateHeartbeat(node.id, t);\n          if (is_scheduler_) {\n            Message heartbeat_ack;\n            heartbeat_ack.meta.recver = node.id;\n            heartbeat_ack.meta.control.cmd = Control::HEARTBEAT;\n            heartbeat_ack.meta.control.node.push_back(my_node_);\n            heartbeat_ack.meta.timestamp = timestamp_++;\n            // send back heartbeat\n            Send(heartbeat_ack);\n          }\n        }\n      }\n    } else {\n      CHECK_NE(msg.meta.sender, Meta::kEmpty);\n      CHECK_NE(msg.meta.recver, Meta::kEmpty);\n      CHECK_NE(msg.meta.customer_id, Meta::kEmpty);\n      int id = msg.meta.customer_id;\n      auto* obj = Postoffice::Get()->GetCustomer(id, 5);\n      CHECK(obj) << \"timeout (5 sec) to wait App \" << id << \" ready\";\n      obj->Accept(msg);\n    }\n  }\n}",
    "includes": [
      "#include \"./resender.h\"",
      "#include \"./zmq_van.h\"",
      "#include \"./meta.pb.h\"",
      "#include \"./network_utils.h\"",
      "#include \"ps/internal/customer.h\"",
      "#include \"ps/internal/postoffice.h\"",
      "#include \"ps/sarray.h\"",
      "#include \"ps/base.h\"",
      "#include <chrono>",
      "#include <thread>",
      "#include \"ps/internal/van.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "obj->Accept",
          "args": [
            "msg"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "obj"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [
            "id",
            "5"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_NE",
          "args": [
            "msg.meta.customer_id",
            "Meta::kEmpty"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_NE",
          "args": [
            "msg.meta.recver",
            "Meta::kEmpty"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_NE",
          "args": [
            "msg.meta.sender",
            "Meta::kEmpty"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Send",
          "args": [
            "heartbeat_ack"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "Send",
          "container": "Van",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/van.cc",
          "lines": "130-139",
          "snippet": "int Van::Send(const Message& msg) {\n  int send_bytes = SendMsg(msg);\n  CHECK_NE(send_bytes, -1);\n  send_bytes_ += send_bytes;\n  if (resender_) resender_->AddOutgoing(msg);\n  if (Postoffice::Get()->verbose() >= 2) {\n    PS_VLOG(2) << msg.DebugString();\n  }\n  return send_bytes;\n}",
          "includes": [
            "#include \"./resender.h\"",
            "#include \"./zmq_van.h\"",
            "#include \"./meta.pb.h\"",
            "#include \"./network_utils.h\"",
            "#include \"ps/internal/customer.h\"",
            "#include \"ps/internal/postoffice.h\"",
            "#include \"ps/sarray.h\"",
            "#include \"ps/base.h\"",
            "#include <chrono>",
            "#include <thread>",
            "#include \"ps/internal/van.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"./resender.h\"\n#include \"./zmq_van.h\"\n#include \"./meta.pb.h\"\n#include \"./network_utils.h\"\n#include \"ps/internal/customer.h\"\n#include \"ps/internal/postoffice.h\"\n#include \"ps/sarray.h\"\n#include \"ps/base.h\"\n#include <chrono>\n#include <thread>\n#include \"ps/internal/van.h\"\n\nVan {\n  int Van::Send(const Message& msg) {\n    int send_bytes = SendMsg(msg);\n    CHECK_NE(send_bytes, -1);\n    send_bytes_ += send_bytes;\n    if (resender_) resender_->AddOutgoing(msg);\n    if (Postoffice::Get()->verbose() >= 2) {\n      PS_VLOG(2) << msg.DebugString();\n    }\n    return send_bytes;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "heartbeat_ack.meta.control.node.push_back",
          "args": [
            "my_node_"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [
            "node.id",
            "t"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [
            "msg"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "GetDeadNodes",
          "container": "Postoffice",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/postoffice.cc",
          "lines": "156-175",
          "snippet": "std::vector<int> Postoffice::GetDeadNodes(int t) {\n  std::vector<int> dead_nodes;\n  if (!van_->IsReady() || t == 0) return dead_nodes;\n\n  time_t curr_time = time(NULL);\n  const auto& nodes = is_scheduler_\n    ? GetNodeIDs(kWorkerGroup + kServerGroup)\n    : GetNodeIDs(kScheduler);\n  {\n    std::lock_guard<std::mutex> lk(heartbeat_mu_);\n    for (int r : nodes) {\n      auto it = heartbeats_.find(r);\n      if ((it == heartbeats_.end() || it->second + t < curr_time)\n            && start_time_ + t < curr_time) {\n        dead_nodes.push_back(r);\n      }\n    }\n  }\n  return dead_nodes;\n}",
          "includes": [
            "#include \"ps/base.h\"",
            "#include \"ps/internal/message.h\"",
            "#include \"ps/internal/postoffice.h\"",
            "#include <chrono>",
            "#include <thread>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ps/base.h\"\n#include \"ps/internal/message.h\"\n#include \"ps/internal/postoffice.h\"\n#include <chrono>\n#include <thread>\n#include <unistd.h>\n\nPostoffice {\n  std::vector<int> Postoffice::GetDeadNodes(int t) {\n    std::vector<int> dead_nodes;\n    if (!van_->IsReady() || t == 0) return dead_nodes;\n  \n    time_t curr_time = time(NULL);\n    const auto& nodes = is_scheduler_\n      ? GetNodeIDs(kWorkerGroup + kServerGroup)\n      : GetNodeIDs(kScheduler);\n    {\n      std::lock_guard<std::mutex> lk(heartbeat_mu_);\n      for (int r : nodes) {\n        auto it = heartbeats_.find(r);\n        if ((it == heartbeats_.end() || it->second + t < curr_time)\n              && start_time_ + t < curr_time) {\n          dead_nodes.push_back(r);\n        }\n      }\n    }\n    return dead_nodes;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_GT",
          "args": [
            "Send(res)",
            "0"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<int>",
          "args": [
            "Postoffice::Get()->GetNodeIDs(group).size()"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PS_VLOG",
          "args": [
            "1"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier_count_.resize",
          "args": [
            "8",
            "0"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier_count_.empty",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_node_.ShortDebugString",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PS_VLOG",
          "args": [
            "1"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Connect",
          "args": [
            "node"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "Connect",
          "container": "ZMQVan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
          "lines": "81-113",
          "snippet": "void Connect(const Node& node) override {\n    CHECK_NE(node.id, node.kEmpty);\n    CHECK_NE(node.port, node.kEmpty);\n    CHECK(node.hostname.size());\n    int id = node.id;\n    auto it = senders_.find(id);\n    if (it != senders_.end()) {\n      zmq_close(it->second);\n    }\n    // worker doesn't need to connect to the other workers. same for server\n    if ((node.role == my_node_.role) &&\n        (node.id != my_node_.id)) {\n      return;\n    }\n    void *sender = zmq_socket(context_, ZMQ_DEALER);\n    CHECK(sender != NULL)\n        << zmq_strerror(errno)\n        << \". it often can be solved by \\\"sudo ulimit -n 65536\\\"\"\n        << \" or edit /etc/security/limits.conf\";\n    if (my_node_.id != Node::kEmpty) {\n      std::string my_id = \"ps\" + std::to_string(my_node_.id);\n      zmq_setsockopt(sender, ZMQ_IDENTITY, my_id.data(), my_id.size());\n    }\n    // connect\n    std::string addr = \"tcp://\" + node.hostname + \":\" + std::to_string(node.port);\n    if (GetEnv(\"DMLC_LOCAL\", 0)) {\n      addr = \"ipc:///tmp/\" + std::to_string(node.port);\n    }\n    if (zmq_connect(sender, addr.c_str()) != 0) {\n      LOG(FATAL) <<  \"connect to \" + addr + \" failed: \" + zmq_strerror(errno);\n    }\n    senders_[id] = sender;\n  }",
          "includes": [
            "#include \"ps/internal/van.h\"",
            "#include <string>",
            "#include <thread>",
            "#include <stdlib.h>",
            "#include <zmq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ps/internal/van.h\"\n#include <string>\n#include <thread>\n#include <stdlib.h>\n#include <zmq.h>\n\nZMQVan {\n  void Connect(const Node& node) override {\n      CHECK_NE(node.id, node.kEmpty);\n      CHECK_NE(node.port, node.kEmpty);\n      CHECK(node.hostname.size());\n      int id = node.id;\n      auto it = senders_.find(id);\n      if (it != senders_.end()) {\n        zmq_close(it->second);\n      }\n      // worker doesn't need to connect to the other workers. same for server\n      if ((node.role == my_node_.role) &&\n          (node.id != my_node_.id)) {\n        return;\n      }\n      void *sender = zmq_socket(context_, ZMQ_DEALER);\n      CHECK(sender != NULL)\n          << zmq_strerror(errno)\n          << \". it often can be solved by \\\"sudo ulimit -n 65536\\\"\"\n          << \" or edit /etc/security/limits.conf\";\n      if (my_node_.id != Node::kEmpty) {\n        std::string my_id = \"ps\" + std::to_string(my_node_.id);\n        zmq_setsockopt(sender, ZMQ_IDENTITY, my_id.data(), my_id.size());\n      }\n      // connect\n      std::string addr = \"tcp://\" + node.hostname + \":\" + std::to_string(node.port);\n      if (GetEnv(\"DMLC_LOCAL\", 0)) {\n        addr = \"ipc:///tmp/\" + std::to_string(node.port);\n      }\n      if (zmq_connect(sender, addr.c_str()) != 0) {\n        LOG(FATAL) <<  \"connect to \" + addr + \" failed: \" + zmq_strerror(errno);\n      }\n      senders_[id] = sender;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dead_set.end",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dead_set.find",
          "args": [
            "r"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [
            "recovery_nodes.control.node[0].id",
            "t"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_EQ",
          "args": [
            "recovery_nodes.control.node.size()",
            "1"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recovery_nodes.control.node.size",
          "args": [],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recovery_nodes.control.node.size",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PS_VLOG",
          "args": [
            "1"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes.control.node.push_back",
          "args": [
            "my_node_"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [
            "node.id",
            "t"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.DebugString",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PS_VLOG",
          "args": [
            "1"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::WorkerRankToID",
          "args": [
            "num_workers_"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::ServerRankToID",
          "args": [
            "num_servers_"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_EQ",
          "args": [
            "node.id",
            "Node::kEmpty"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::sort",
          "args": [
            "nodes.control.node.begin()",
            "nodes.control.node.end()",
            "[](const Node& a, const Node& b) {\n                        return (a.hostname.compare(b.hostname) | (a.port < b.port)) > 0;\n                      }"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a.hostname.compare",
          "args": [
            "b.hostname"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes.control.node.end",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes.control.node.begin",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes.control.node.size",
          "args": [],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"DMLC_RANK\"",
            "rank.c_str()",
            "true"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rank.c_str",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_putenv_s",
          "args": [
            "\"DMLC_RANK\"",
            "rank.c_str()"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rank.c_str",
          "args": [],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::to_string",
          "args": [
            "Postoffice::IDtoRank(node.id)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::IDtoRank",
          "args": [
            "node.id"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctrl.node.size",
          "args": [],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recovery_nodes.control.node.push_back",
          "args": [
            "recovery_node"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recovery_node.DebugString",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.DebugString",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PS_VLOG",
          "args": [
            "1"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dead_set.end",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dead_set.find",
          "args": [
            "node.id"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes.control.node.size",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "ready_"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes.control.node.push_back",
          "args": [
            "ctrl.node[0]"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes.control.node.size",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_EQ",
          "args": [
            "ctrl.node.size()",
            "1"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctrl.node.size",
          "args": [],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "is_scheduler_"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dead_nodes.end",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dead_nodes.begin",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_node_.ShortDebugString",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PS_VLOG",
          "args": [
            "1"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msg.meta.control.empty",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resender_->AddIncomming",
          "args": [
            "msg"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "AddIncomming",
          "container": "Resender",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/resender.h",
          "lines": "54-83",
          "snippet": "bool AddIncomming(const Message& msg) {\n    // a message can be received by multiple times\n    if (msg.meta.control.cmd == Control::TERMINATE) {\n      return false;\n    } else if (msg.meta.control.cmd == Control::ACK) {\n      mu_.lock();\n      auto key = msg.meta.control.msg_sig;\n      auto it = send_buff_.find(key);\n      if (it != send_buff_.end()) send_buff_.erase(it);\n      mu_.unlock();\n      return true;\n    } else {\n      mu_.lock();\n      auto key = GetKey(msg);\n      auto it = acked_.find(key);\n      bool duplicated = it != acked_.end();\n      if (!duplicated) acked_.insert(key);\n      mu_.unlock();\n      // send back ack message (even if it is duplicated)\n      Message ack;\n      ack.meta.recver = msg.meta.sender;\n      ack.meta.sender = msg.meta.recver;\n      ack.meta.control.cmd = Control::ACK;\n      ack.meta.control.msg_sig = key;\n      van_->Send(ack);\n      // warning\n      if (duplicated) LOG(WARNING) << \"Duplicated message: \" << msg.DebugString();\n      return duplicated;\n    }\n  }",
          "includes": [
            "#include <unordered_map>",
            "#include <unordered_set>",
            "#include <vector>",
            "#include <chrono>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <chrono>\n\nResender {\n  bool AddIncomming(const Message& msg) {\n      // a message can be received by multiple times\n      if (msg.meta.control.cmd == Control::TERMINATE) {\n        return false;\n      } else if (msg.meta.control.cmd == Control::ACK) {\n        mu_.lock();\n        auto key = msg.meta.control.msg_sig;\n        auto it = send_buff_.find(key);\n        if (it != send_buff_.end()) send_buff_.erase(it);\n        mu_.unlock();\n        return true;\n      } else {\n        mu_.lock();\n        auto key = GetKey(msg);\n        auto it = acked_.find(key);\n        bool duplicated = it != acked_.end();\n        if (!duplicated) acked_.insert(key);\n        mu_.unlock();\n        // send back ack message (even if it is duplicated)\n        Message ack;\n        ack.meta.recver = msg.meta.sender;\n        ack.meta.sender = msg.meta.recver;\n        ack.meta.control.cmd = Control::ACK;\n        ack.meta.control.msg_sig = key;\n        van_->Send(ack);\n        // warning\n        if (duplicated) LOG(WARNING) << \"Duplicated message: \" << msg.DebugString();\n        return duplicated;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "msg.DebugString",
          "args": [],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PS_VLOG",
          "args": [
            "2"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_NE",
          "args": [
            "recv_bytes",
            "-1"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msg.DebugString",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOG",
          "args": [
            "WARNING"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rand_r",
          "args": [
            "&seed"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RecvMsg",
          "args": [
            "&msg"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "RecvMsg",
          "container": "ZMQVan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
          "lines": "166-209",
          "snippet": "int RecvMsg(Message* msg) override {\n    msg->data.clear();\n    size_t recv_bytes = 0;\n    for (int i = 0; ; ++i) {\n      zmq_msg_t* zmsg = new zmq_msg_t;\n      CHECK(zmq_msg_init(zmsg) == 0) << zmq_strerror(errno);\n      while (true) {\n        if (zmq_msg_recv(zmsg, receiver_, 0) != -1) break;\n        if (errno == EINTR) continue;\n        LOG(WARNING) << \"failed to receive message. errno: \"\n                     << errno << \" \" << zmq_strerror(errno);\n        return -1;\n      }\n      char* buf = CHECK_NOTNULL((char *)zmq_msg_data(zmsg));\n      size_t size = zmq_msg_size(zmsg);\n      recv_bytes += size;\n\n      if (i == 0) {\n        // identify\n        msg->meta.sender = GetNodeID(buf, size);\n        msg->meta.recver = my_node_.id;\n        CHECK(zmq_msg_more(zmsg));\n        zmq_msg_close(zmsg);\n        delete zmsg;\n      } else if (i == 1) {\n        // task\n        UnpackMeta(buf, size, &(msg->meta));\n        zmq_msg_close(zmsg);\n        bool more = zmq_msg_more(zmsg);\n        delete zmsg;\n        if (!more) break;\n      } else {\n        // zero-copy\n        SArray<char> data;\n        data.reset(buf, size, [zmsg, size](char* buf) {\n            zmq_msg_close(zmsg);\n            delete zmsg;\n          });\n        msg->data.push_back(data);\n        if (!zmq_msg_more(zmsg)) { break; }\n      }\n    }\n    return recv_bytes;\n  }",
          "includes": [
            "#include \"ps/internal/van.h\"",
            "#include <string>",
            "#include <thread>",
            "#include <stdlib.h>",
            "#include <zmq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ps/internal/van.h\"\n#include <string>\n#include <thread>\n#include <stdlib.h>\n#include <zmq.h>\n\nZMQVan {\n  int RecvMsg(Message* msg) override {\n      msg->data.clear();\n      size_t recv_bytes = 0;\n      for (int i = 0; ; ++i) {\n        zmq_msg_t* zmsg = new zmq_msg_t;\n        CHECK(zmq_msg_init(zmsg) == 0) << zmq_strerror(errno);\n        while (true) {\n          if (zmq_msg_recv(zmsg, receiver_, 0) != -1) break;\n          if (errno == EINTR) continue;\n          LOG(WARNING) << \"failed to receive message. errno: \"\n                       << errno << \" \" << zmq_strerror(errno);\n          return -1;\n        }\n        char* buf = CHECK_NOTNULL((char *)zmq_msg_data(zmsg));\n        size_t size = zmq_msg_size(zmsg);\n        recv_bytes += size;\n  \n        if (i == 0) {\n          // identify\n          msg->meta.sender = GetNodeID(buf, size);\n          msg->meta.recver = my_node_.id;\n          CHECK(zmq_msg_more(zmsg));\n          zmq_msg_close(zmsg);\n          delete zmsg;\n        } else if (i == 1) {\n          // task\n          UnpackMeta(buf, size, &(msg->meta));\n          zmq_msg_close(zmsg);\n          bool more = zmq_msg_more(zmsg);\n          delete zmsg;\n          if (!more) break;\n        } else {\n          // zero-copy\n          SArray<char> data;\n          data.reset(buf, size, [zmsg, size](char* buf) {\n              zmq_msg_close(zmsg);\n              delete zmsg;\n            });\n          msg->data.push_back(data);\n          if (!zmq_msg_more(zmsg)) { break; }\n        }\n      }\n      return recv_bytes;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "heartbeat_timeout_val"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [
            "\"PS_HEARTBEAT_TIMEOUT\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"./resender.h\"\n#include \"./zmq_van.h\"\n#include \"./meta.pb.h\"\n#include \"./network_utils.h\"\n#include \"ps/internal/customer.h\"\n#include \"ps/internal/postoffice.h\"\n#include \"ps/sarray.h\"\n#include \"ps/base.h\"\n#include <chrono>\n#include <thread>\n#include \"ps/internal/van.h\"\n\nVan {\n  void Van::Receiving() {\n    const char* heartbeat_timeout_val = Environment::Get()->find(\"PS_HEARTBEAT_TIMEOUT\");\n    const int heartbeat_timeout\n        = heartbeat_timeout_val ? atoi(heartbeat_timeout_val) : kDefaultHeartbeatInterval;\n    Meta nodes;  // for scheduler usage\n    while (true) {\n      Message msg;\n      int recv_bytes = RecvMsg(&msg);\n  \n      // For debug, drop received message\n      if (ready_ && drop_rate_ > 0) {\n        unsigned seed = time(NULL) + my_node_.id;\n        if (rand_r(&seed) % 100 < drop_rate_) {\n          LOG(WARNING) << \"Drop message \" << msg.DebugString();\n          continue;\n        }\n      }\n  \n      CHECK_NE(recv_bytes, -1);\n      recv_bytes_ += recv_bytes;\n      if (Postoffice::Get()->verbose() >= 2) {\n        PS_VLOG(2) << msg.DebugString();\n      }\n      // duplicated message\n      if (resender_ && resender_->AddIncomming(msg)) continue;\n  \n      if (!msg.meta.control.empty()) {\n        // do some management\n        auto& ctrl = msg.meta.control;\n        if (ctrl.cmd == Control::TERMINATE) {\n          PS_VLOG(1) << my_node_.ShortDebugString() << \" is stopped\";\n          ready_ = false;\n          break;\n        } else if (ctrl.cmd == Control::ADD_NODE) {\n          size_t num_nodes = Postoffice::Get()->num_servers() +\n                             Postoffice::Get()->num_workers();\n          auto dead_nodes = Postoffice::Get()->GetDeadNodes(heartbeat_timeout);\n          std::unordered_set<int> dead_set(dead_nodes.begin(), dead_nodes.end());\n          Meta recovery_nodes;  // store recovery nodes\n          recovery_nodes.control.cmd = Control::ADD_NODE;\n          // assign an id\n          if (msg.meta.sender == Meta::kEmpty) {\n            CHECK(is_scheduler_);\n            CHECK_EQ(ctrl.node.size(), 1);\n            if (nodes.control.node.size() < num_nodes) {\n              nodes.control.node.push_back(ctrl.node[0]);\n            } else {\n              // some node dies and restarts\n              CHECK(ready_);\n              for (size_t i = 0; i < nodes.control.node.size() - 1; ++i) {\n                const auto& node = nodes.control.node[i];\n                if (dead_set.find(node.id) != dead_set.end() && node.role == ctrl.node[0].role) {\n                  auto& recovery_node = ctrl.node[0];\n                  // assign previous node id\n                  recovery_node.id = node.id;\n                  recovery_node.is_recovery = true;\n                  PS_VLOG(1) << \"replace dead node \" << node.DebugString()\n                             << \" by node \" << recovery_node.DebugString();\n                  nodes.control.node[i] = recovery_node;\n                  recovery_nodes.control.node.push_back(recovery_node);\n                  break;\n                }\n              }\n            }\n          }\n  \n          // update my id\n          for (size_t i = 0; i < ctrl.node.size(); ++i) {\n            const auto& node = ctrl.node[i];\n            if (my_node_.hostname == node.hostname &&\n                my_node_.port == node.port) {\n              my_node_ = node;\n              std::string rank = std::to_string(Postoffice::IDtoRank(node.id));\n  #ifdef _MSC_VER\n              _putenv_s(\"DMLC_RANK\", rank.c_str());\n  #else\n              setenv(\"DMLC_RANK\", rank.c_str(), true);\n  #endif\n            }\n          }\n  \n          if (is_scheduler_) {\n            time_t t = time(NULL);\n            if (nodes.control.node.size() == num_nodes) {\n              // sort the nodes according their ip and port,\n              std::sort(nodes.control.node.begin(), nodes.control.node.end(),\n                        [](const Node& a, const Node& b) {\n                          return (a.hostname.compare(b.hostname) | (a.port < b.port)) > 0;\n                        });\n              // assign node rank\n              for (auto& node : nodes.control.node) {\n                CHECK_EQ(node.id, Node::kEmpty);\n                int id = node.role == Node::SERVER ?\n                         Postoffice::ServerRankToID(num_servers_) :\n                         Postoffice::WorkerRankToID(num_workers_);\n                PS_VLOG(1) << \"assign rank=\" << id << \" to node \" << node.DebugString();\n                node.id = id;\n                Connect(node);\n                if (node.role == Node::SERVER) ++num_servers_;\n                if (node.role == Node::WORKER) ++num_workers_;\n                Postoffice::Get()->UpdateHeartbeat(node.id, t);\n              }\n              nodes.control.node.push_back(my_node_);\n              nodes.control.cmd = Control::ADD_NODE;\n              Message back; back.meta = nodes;\n              for (int r : Postoffice::Get()->GetNodeIDs(\n                       kWorkerGroup + kServerGroup)) {\n                back.meta.recver = r;\n                back.meta.timestamp = timestamp_++;\n                Send(back);\n              }\n              PS_VLOG(1) << \"the scheduler is connected to \"\n                      << num_workers_ << \" workers and \" << num_servers_ << \" servers\";\n              ready_ = true;\n            } else if (recovery_nodes.control.node.size() > 0) {\n              // send back the recovery node\n              CHECK_EQ(recovery_nodes.control.node.size(), 1);\n              Connect(recovery_nodes.control.node[0]);\n              Postoffice::Get()->UpdateHeartbeat(recovery_nodes.control.node[0].id, t);\n              Message back;\n              for (int r : Postoffice::Get()->GetNodeIDs(\n                       kWorkerGroup + kServerGroup)) {\n                if (r != recovery_nodes.control.node[0].id\n                      && dead_set.find(r) != dead_set.end()) {\n                  // do not try to send anything to dead node\n                  continue;\n                }\n                // only send recovery_node to nodes already exist\n                // but send all nodes to the recovery_node\n                back.meta = (r == recovery_nodes.control.node[0].id) ? nodes : recovery_nodes;\n                back.meta.recver = r;\n                back.meta.timestamp = timestamp_++;\n                Send(back);\n              }\n            }\n          } else {\n            for (const auto& node : ctrl.node) {\n              Connect(node);\n              if (!node.is_recovery && node.role == Node::SERVER) ++num_servers_;\n              if (!node.is_recovery && node.role == Node::WORKER) ++num_workers_;\n            }\n            PS_VLOG(1) << my_node_.ShortDebugString() << \" is connected to others\";\n            ready_ = true;\n          }\n        } else if (ctrl.cmd == Control::BARRIER) {\n          if (msg.meta.request) {\n            if (barrier_count_.empty()) {\n              barrier_count_.resize(8, 0);\n            }\n            int group = ctrl.barrier_group;\n            ++barrier_count_[group];\n            PS_VLOG(1) << \"Barrier count for \" << group << \" : \" << barrier_count_[group];\n            if (barrier_count_[group] ==\n                static_cast<int>(Postoffice::Get()->GetNodeIDs(group).size())) {\n              barrier_count_[group] = 0;\n              Message res;\n              res.meta.request = false;\n              res.meta.control.cmd = Control::BARRIER;\n              for (int r : Postoffice::Get()->GetNodeIDs(group)) {\n                res.meta.recver = r;\n                res.meta.timestamp = timestamp_++;\n                CHECK_GT(Send(res), 0);\n              }\n            }\n          } else {\n            Postoffice::Get()->Manage(msg);\n          }\n        } else if (ctrl.cmd == Control::HEARTBEAT) {\n          time_t t = time(NULL);\n          for (auto &node : ctrl.node) {\n            Postoffice::Get()->UpdateHeartbeat(node.id, t);\n            if (is_scheduler_) {\n              Message heartbeat_ack;\n              heartbeat_ack.meta.recver = node.id;\n              heartbeat_ack.meta.control.cmd = Control::HEARTBEAT;\n              heartbeat_ack.meta.control.node.push_back(my_node_);\n              heartbeat_ack.meta.timestamp = timestamp_++;\n              // send back heartbeat\n              Send(heartbeat_ack);\n            }\n          }\n        }\n      } else {\n        CHECK_NE(msg.meta.sender, Meta::kEmpty);\n        CHECK_NE(msg.meta.recver, Meta::kEmpty);\n        CHECK_NE(msg.meta.customer_id, Meta::kEmpty);\n        int id = msg.meta.customer_id;\n        auto* obj = Postoffice::Get()->GetCustomer(id, 5);\n        CHECK(obj) << \"timeout (5 sec) to wait App \" << id << \" ready\";\n        obj->Accept(msg);\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "Send",
    "container": "Van",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/van.cc",
    "lines": "130-139",
    "snippet": "int Van::Send(const Message& msg) {\n  int send_bytes = SendMsg(msg);\n  CHECK_NE(send_bytes, -1);\n  send_bytes_ += send_bytes;\n  if (resender_) resender_->AddOutgoing(msg);\n  if (Postoffice::Get()->verbose() >= 2) {\n    PS_VLOG(2) << msg.DebugString();\n  }\n  return send_bytes;\n}",
    "includes": [
      "#include \"./resender.h\"",
      "#include \"./zmq_van.h\"",
      "#include \"./meta.pb.h\"",
      "#include \"./network_utils.h\"",
      "#include \"ps/internal/customer.h\"",
      "#include \"ps/internal/postoffice.h\"",
      "#include \"ps/sarray.h\"",
      "#include \"ps/base.h\"",
      "#include <chrono>",
      "#include <thread>",
      "#include \"ps/internal/van.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "msg.DebugString",
          "args": [],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PS_VLOG",
          "args": [
            "2"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resender_->AddOutgoing",
          "args": [
            "msg"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "AddOutgoing",
          "container": "Resender",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/resender.h",
          "lines": "36-48",
          "snippet": "void AddOutgoing(const Message& msg) {\n    if (msg.meta.control.cmd == Control::ACK) return;\n    CHECK_NE(msg.meta.timestamp, Meta::kEmpty) << msg.DebugString();\n    auto key = GetKey(msg);\n    std::lock_guard<std::mutex> lk(mu_);\n    // already buffered, which often due to call Send by the monitor thread\n    if (send_buff_.find(key) != send_buff_.end()) return;\n\n    auto& ent = send_buff_[key];\n    ent.msg = msg;\n    ent.send = Now();\n    ent.num_retry = 0;\n  }",
          "includes": [
            "#include <unordered_map>",
            "#include <unordered_set>",
            "#include <vector>",
            "#include <chrono>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <chrono>\n\nResender {\n  void AddOutgoing(const Message& msg) {\n      if (msg.meta.control.cmd == Control::ACK) return;\n      CHECK_NE(msg.meta.timestamp, Meta::kEmpty) << msg.DebugString();\n      auto key = GetKey(msg);\n      std::lock_guard<std::mutex> lk(mu_);\n      // already buffered, which often due to call Send by the monitor thread\n      if (send_buff_.find(key) != send_buff_.end()) return;\n  \n      auto& ent = send_buff_[key];\n      ent.msg = msg;\n      ent.send = Now();\n      ent.num_retry = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_NE",
          "args": [
            "send_bytes",
            "-1"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendMsg",
          "args": [
            "msg"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "SendMsg",
          "container": "ZMQVan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
          "lines": "115-164",
          "snippet": "int SendMsg(const Message& msg) override {\n    std::lock_guard<std::mutex> lk(mu_);\n    // find the socket\n    int id = msg.meta.recver;\n    CHECK_NE(id, Meta::kEmpty);\n    auto it = senders_.find(id);\n    if (it == senders_.end()) {\n      LOG(WARNING) << \"there is no socket to node \" << id;\n      return -1;\n    }\n    void *socket = it->second;\n\n    // send meta\n    int meta_size; char* meta_buf;\n    PackMeta(msg.meta, &meta_buf, &meta_size);\n    int tag = ZMQ_SNDMORE;\n    int n = msg.data.size();\n    if (n == 0) tag = 0;\n    zmq_msg_t meta_msg;\n    zmq_msg_init_data(&meta_msg, meta_buf, meta_size, FreeData, NULL);\n    while (true) {\n      if (zmq_msg_send(&meta_msg, socket, tag) == meta_size) break;\n      if (errno == EINTR) continue;\n      LOG(WARNING) << \"failed to send message to node [\" << id\n                   << \"] errno: \" << errno << \" \" << zmq_strerror(errno);\n      return -1;\n    }\n    zmq_msg_close(&meta_msg);\n    int send_bytes = meta_size;\n\n    // send data\n    for (int i = 0; i < n; ++i) {\n      zmq_msg_t data_msg;\n      SArray<char>* data = new SArray<char>(msg.data[i]);\n      int data_size = data->size();\n      zmq_msg_init_data(&data_msg, data->data(), data->size(), FreeData, data);\n      if (i == n - 1) tag = 0;\n      while (true) {\n        if (zmq_msg_send(&data_msg, socket, tag) == data_size) break;\n        if (errno == EINTR) continue;\n        LOG(WARNING) << \"failed to send message to node [\" << id\n                     << \"] errno: \" << errno << \" \" << zmq_strerror(errno)\n                     << \". \" << i << \"/\" << n;\n        return -1;\n      }\n      zmq_msg_close(&data_msg);\n      send_bytes += data_size;\n    }\n    return send_bytes;\n  }",
          "includes": [
            "#include \"ps/internal/van.h\"",
            "#include <string>",
            "#include <thread>",
            "#include <stdlib.h>",
            "#include <zmq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ps/internal/van.h\"\n#include <string>\n#include <thread>\n#include <stdlib.h>\n#include <zmq.h>\n\nZMQVan {\n  int SendMsg(const Message& msg) override {\n      std::lock_guard<std::mutex> lk(mu_);\n      // find the socket\n      int id = msg.meta.recver;\n      CHECK_NE(id, Meta::kEmpty);\n      auto it = senders_.find(id);\n      if (it == senders_.end()) {\n        LOG(WARNING) << \"there is no socket to node \" << id;\n        return -1;\n      }\n      void *socket = it->second;\n  \n      // send meta\n      int meta_size; char* meta_buf;\n      PackMeta(msg.meta, &meta_buf, &meta_size);\n      int tag = ZMQ_SNDMORE;\n      int n = msg.data.size();\n      if (n == 0) tag = 0;\n      zmq_msg_t meta_msg;\n      zmq_msg_init_data(&meta_msg, meta_buf, meta_size, FreeData, NULL);\n      while (true) {\n        if (zmq_msg_send(&meta_msg, socket, tag) == meta_size) break;\n        if (errno == EINTR) continue;\n        LOG(WARNING) << \"failed to send message to node [\" << id\n                     << \"] errno: \" << errno << \" \" << zmq_strerror(errno);\n        return -1;\n      }\n      zmq_msg_close(&meta_msg);\n      int send_bytes = meta_size;\n  \n      // send data\n      for (int i = 0; i < n; ++i) {\n        zmq_msg_t data_msg;\n        SArray<char>* data = new SArray<char>(msg.data[i]);\n        int data_size = data->size();\n        zmq_msg_init_data(&data_msg, data->data(), data->size(), FreeData, data);\n        if (i == n - 1) tag = 0;\n        while (true) {\n          if (zmq_msg_send(&data_msg, socket, tag) == data_size) break;\n          if (errno == EINTR) continue;\n          LOG(WARNING) << \"failed to send message to node [\" << id\n                       << \"] errno: \" << errno << \" \" << zmq_strerror(errno)\n                       << \". \" << i << \"/\" << n;\n          return -1;\n        }\n        zmq_msg_close(&data_msg);\n        send_bytes += data_size;\n      }\n      return send_bytes;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"./resender.h\"\n#include \"./zmq_van.h\"\n#include \"./meta.pb.h\"\n#include \"./network_utils.h\"\n#include \"ps/internal/customer.h\"\n#include \"ps/internal/postoffice.h\"\n#include \"ps/sarray.h\"\n#include \"ps/base.h\"\n#include <chrono>\n#include <thread>\n#include \"ps/internal/van.h\"\n\nVan {\n  int Van::Send(const Message& msg) {\n    int send_bytes = SendMsg(msg);\n    CHECK_NE(send_bytes, -1);\n    send_bytes_ += send_bytes;\n    if (resender_) resender_->AddOutgoing(msg);\n    if (Postoffice::Get()->verbose() >= 2) {\n      PS_VLOG(2) << msg.DebugString();\n    }\n    return send_bytes;\n  }\n}"
  },
  {
    "function_name": "Stop",
    "container": "Van",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/van.cc",
    "lines": "119-128",
    "snippet": "void Van::Stop() {\n  // stop threads\n  Message exit;\n  exit.meta.control.cmd = Control::TERMINATE;\n  exit.meta.recver = my_node_.id;\n  SendMsg(exit);\n  receiver_thread_->join();\n  if (!is_scheduler_) heartbeat_thread_->join();\n  if (resender_) delete resender_;\n}",
    "includes": [
      "#include \"./resender.h\"",
      "#include \"./zmq_van.h\"",
      "#include \"./meta.pb.h\"",
      "#include \"./network_utils.h\"",
      "#include \"ps/internal/customer.h\"",
      "#include \"ps/internal/postoffice.h\"",
      "#include \"ps/sarray.h\"",
      "#include \"ps/base.h\"",
      "#include <chrono>",
      "#include <thread>",
      "#include \"ps/internal/van.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heartbeat_thread_->join",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiver_thread_->join",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendMsg",
          "args": [
            "exit"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "SendMsg",
          "container": "ZMQVan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
          "lines": "115-164",
          "snippet": "int SendMsg(const Message& msg) override {\n    std::lock_guard<std::mutex> lk(mu_);\n    // find the socket\n    int id = msg.meta.recver;\n    CHECK_NE(id, Meta::kEmpty);\n    auto it = senders_.find(id);\n    if (it == senders_.end()) {\n      LOG(WARNING) << \"there is no socket to node \" << id;\n      return -1;\n    }\n    void *socket = it->second;\n\n    // send meta\n    int meta_size; char* meta_buf;\n    PackMeta(msg.meta, &meta_buf, &meta_size);\n    int tag = ZMQ_SNDMORE;\n    int n = msg.data.size();\n    if (n == 0) tag = 0;\n    zmq_msg_t meta_msg;\n    zmq_msg_init_data(&meta_msg, meta_buf, meta_size, FreeData, NULL);\n    while (true) {\n      if (zmq_msg_send(&meta_msg, socket, tag) == meta_size) break;\n      if (errno == EINTR) continue;\n      LOG(WARNING) << \"failed to send message to node [\" << id\n                   << \"] errno: \" << errno << \" \" << zmq_strerror(errno);\n      return -1;\n    }\n    zmq_msg_close(&meta_msg);\n    int send_bytes = meta_size;\n\n    // send data\n    for (int i = 0; i < n; ++i) {\n      zmq_msg_t data_msg;\n      SArray<char>* data = new SArray<char>(msg.data[i]);\n      int data_size = data->size();\n      zmq_msg_init_data(&data_msg, data->data(), data->size(), FreeData, data);\n      if (i == n - 1) tag = 0;\n      while (true) {\n        if (zmq_msg_send(&data_msg, socket, tag) == data_size) break;\n        if (errno == EINTR) continue;\n        LOG(WARNING) << \"failed to send message to node [\" << id\n                     << \"] errno: \" << errno << \" \" << zmq_strerror(errno)\n                     << \". \" << i << \"/\" << n;\n        return -1;\n      }\n      zmq_msg_close(&data_msg);\n      send_bytes += data_size;\n    }\n    return send_bytes;\n  }",
          "includes": [
            "#include \"ps/internal/van.h\"",
            "#include <string>",
            "#include <thread>",
            "#include <stdlib.h>",
            "#include <zmq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ps/internal/van.h\"\n#include <string>\n#include <thread>\n#include <stdlib.h>\n#include <zmq.h>\n\nZMQVan {\n  int SendMsg(const Message& msg) override {\n      std::lock_guard<std::mutex> lk(mu_);\n      // find the socket\n      int id = msg.meta.recver;\n      CHECK_NE(id, Meta::kEmpty);\n      auto it = senders_.find(id);\n      if (it == senders_.end()) {\n        LOG(WARNING) << \"there is no socket to node \" << id;\n        return -1;\n      }\n      void *socket = it->second;\n  \n      // send meta\n      int meta_size; char* meta_buf;\n      PackMeta(msg.meta, &meta_buf, &meta_size);\n      int tag = ZMQ_SNDMORE;\n      int n = msg.data.size();\n      if (n == 0) tag = 0;\n      zmq_msg_t meta_msg;\n      zmq_msg_init_data(&meta_msg, meta_buf, meta_size, FreeData, NULL);\n      while (true) {\n        if (zmq_msg_send(&meta_msg, socket, tag) == meta_size) break;\n        if (errno == EINTR) continue;\n        LOG(WARNING) << \"failed to send message to node [\" << id\n                     << \"] errno: \" << errno << \" \" << zmq_strerror(errno);\n        return -1;\n      }\n      zmq_msg_close(&meta_msg);\n      int send_bytes = meta_size;\n  \n      // send data\n      for (int i = 0; i < n; ++i) {\n        zmq_msg_t data_msg;\n        SArray<char>* data = new SArray<char>(msg.data[i]);\n        int data_size = data->size();\n        zmq_msg_init_data(&data_msg, data->data(), data->size(), FreeData, data);\n        if (i == n - 1) tag = 0;\n        while (true) {\n          if (zmq_msg_send(&data_msg, socket, tag) == data_size) break;\n          if (errno == EINTR) continue;\n          LOG(WARNING) << \"failed to send message to node [\" << id\n                       << \"] errno: \" << errno << \" \" << zmq_strerror(errno)\n                       << \". \" << i << \"/\" << n;\n          return -1;\n        }\n        zmq_msg_close(&data_msg);\n        send_bytes += data_size;\n      }\n      return send_bytes;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"./resender.h\"\n#include \"./zmq_van.h\"\n#include \"./meta.pb.h\"\n#include \"./network_utils.h\"\n#include \"ps/internal/customer.h\"\n#include \"ps/internal/postoffice.h\"\n#include \"ps/sarray.h\"\n#include \"ps/base.h\"\n#include <chrono>\n#include <thread>\n#include \"ps/internal/van.h\"\n\nVan {\n  void Van::Stop() {\n    // stop threads\n    Message exit;\n    exit.meta.control.cmd = Control::TERMINATE;\n    exit.meta.recver = my_node_.id;\n    SendMsg(exit);\n    receiver_thread_->join();\n    if (!is_scheduler_) heartbeat_thread_->join();\n    if (resender_) delete resender_;\n  }\n}"
  },
  {
    "function_name": "Start",
    "container": "Van",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/van.cc",
    "lines": "32-117",
    "snippet": "void Van::Start() {\n  // get scheduler info\n  scheduler_.hostname = std::string(CHECK_NOTNULL(Environment::Get()->find(\"DMLC_PS_ROOT_URI\")));\n  scheduler_.port     = atoi(CHECK_NOTNULL(Environment::Get()->find(\"DMLC_PS_ROOT_PORT\")));\n  scheduler_.role     = Node::SCHEDULER;\n  scheduler_.id       = kScheduler;\n  is_scheduler_       = Postoffice::Get()->is_scheduler();\n\n  // get my node info\n  if (is_scheduler_) {\n    my_node_ = scheduler_;\n  } else {\n    auto role = is_scheduler_ ? Node::SCHEDULER :\n                (Postoffice::Get()->is_worker() ? Node::WORKER : Node::SERVER);\n    const char* nhost = Environment::Get()->find(\"DMLC_NODE_HOST\");\n    std::string ip;\n    if (nhost) ip = std::string(nhost);\n    if (ip.empty()) {\n      const char*  itf = Environment::Get()->find(\"DMLC_INTERFACE\");\n      std::string interface;\n      if (itf) interface = std::string(itf);\n      if (interface.size()) {\n        GetIP(interface, &ip);\n      } else {\n        GetAvailableInterfaceAndIP(&interface, &ip);\n      }\n      CHECK(!interface.empty()) << \"failed to get the interface\";\n    }\n    int port = GetAvailablePort();\n    const char* pstr = Environment::Get()->find(\"PORT\");\n    if (pstr) port = atoi(pstr);\n    CHECK(!ip.empty()) << \"failed to get ip\";\n    CHECK(port) << \"failed to get a port\";\n    my_node_.hostname = ip;\n    my_node_.role     = role;\n    my_node_.port     = port;\n    // cannot determine my id now, the scheduler will assign it later\n    // set it explicitly to make re-register within a same process possible\n    my_node_.id = Node::kEmpty;\n  }\n\n  // bind.\n  my_node_.port = Bind(my_node_, is_scheduler_ ? 0 : 40);\n  PS_VLOG(1) << \"Bind to \" << my_node_.DebugString();\n  CHECK_NE(my_node_.port, -1) << \"bind failed\";\n\n  // connect to the scheduler\n  Connect(scheduler_);\n\n  // for debug use\n  if (Environment::Get()->find(\"PS_DROP_MSG\")) {\n    drop_rate_ = atoi(Environment::Get()->find(\"PS_DROP_MSG\"));\n  }\n  // start receiver\n  receiver_thread_ = std::unique_ptr<std::thread>(\n      new std::thread(&Van::Receiving, this));\n\n  if (!is_scheduler_) {\n    // let the scheduler know myself\n    Message msg;\n    msg.meta.recver = kScheduler;\n    msg.meta.control.cmd = Control::ADD_NODE;\n    msg.meta.control.node.push_back(my_node_);\n    msg.meta.timestamp = timestamp_++;\n    Send(msg);\n  }\n  // wait until ready\n  while (!ready_) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n  }\n\n  // resender\n  if (Environment::Get()->find(\"PS_RESEND\") && atoi(Environment::Get()->find(\"PS_RESEND\")) != 0) {\n    int timeout = 1000;\n    if (Environment::Get()->find(\"PS_RESEND_TIMEOUT\")) {\n      timeout = atoi(Environment::Get()->find(\"PS_RESEND_TIMEOUT\"));\n    }\n    resender_ = new Resender(timeout, 10, this);\n  }\n\n  if (!is_scheduler_) {\n    // start heartbeat thread\n    heartbeat_thread_ = std::unique_ptr<std::thread>(\n      new std::thread(&Van::Heartbeat, this));\n  }\n}",
    "includes": [
      "#include \"./resender.h\"",
      "#include \"./zmq_van.h\"",
      "#include \"./meta.pb.h\"",
      "#include \"./network_utils.h\"",
      "#include \"ps/internal/customer.h\"",
      "#include \"ps/internal/postoffice.h\"",
      "#include \"ps/sarray.h\"",
      "#include \"ps/base.h\"",
      "#include <chrono>",
      "#include <thread>",
      "#include \"ps/internal/van.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::unique_ptr<std::thread>",
          "args": [
            "new std::thread(&Van::Heartbeat, this)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "Environment::Get()->find(\"PS_RESEND_TIMEOUT\")"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [
            "\"PS_RESEND_TIMEOUT\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [
            "\"PS_RESEND_TIMEOUT\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "Environment::Get()->find(\"PS_RESEND\")"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [
            "\"PS_RESEND\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [
            "\"PS_RESEND\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::this_thread::sleep_for",
          "args": [
            "std::chrono::milliseconds(1)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::chrono::milliseconds",
          "args": [
            "1"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Send",
          "args": [
            "msg"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "Send",
          "container": "Van",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/van.cc",
          "lines": "130-139",
          "snippet": "int Van::Send(const Message& msg) {\n  int send_bytes = SendMsg(msg);\n  CHECK_NE(send_bytes, -1);\n  send_bytes_ += send_bytes;\n  if (resender_) resender_->AddOutgoing(msg);\n  if (Postoffice::Get()->verbose() >= 2) {\n    PS_VLOG(2) << msg.DebugString();\n  }\n  return send_bytes;\n}",
          "includes": [
            "#include \"./resender.h\"",
            "#include \"./zmq_van.h\"",
            "#include \"./meta.pb.h\"",
            "#include \"./network_utils.h\"",
            "#include \"ps/internal/customer.h\"",
            "#include \"ps/internal/postoffice.h\"",
            "#include \"ps/sarray.h\"",
            "#include \"ps/base.h\"",
            "#include <chrono>",
            "#include <thread>",
            "#include \"ps/internal/van.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"./resender.h\"\n#include \"./zmq_van.h\"\n#include \"./meta.pb.h\"\n#include \"./network_utils.h\"\n#include \"ps/internal/customer.h\"\n#include \"ps/internal/postoffice.h\"\n#include \"ps/sarray.h\"\n#include \"ps/base.h\"\n#include <chrono>\n#include <thread>\n#include \"ps/internal/van.h\"\n\nVan {\n  int Van::Send(const Message& msg) {\n    int send_bytes = SendMsg(msg);\n    CHECK_NE(send_bytes, -1);\n    send_bytes_ += send_bytes;\n    if (resender_) resender_->AddOutgoing(msg);\n    if (Postoffice::Get()->verbose() >= 2) {\n      PS_VLOG(2) << msg.DebugString();\n    }\n    return send_bytes;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "msg.meta.control.node.push_back",
          "args": [
            "my_node_"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::unique_ptr<std::thread>",
          "args": [
            "new std::thread(&Van::Receiving, this)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "Environment::Get()->find(\"PS_DROP_MSG\")"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [
            "\"PS_DROP_MSG\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [
            "\"PS_DROP_MSG\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Connect",
          "args": [
            "scheduler_"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "Connect",
          "container": "ZMQVan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
          "lines": "81-113",
          "snippet": "void Connect(const Node& node) override {\n    CHECK_NE(node.id, node.kEmpty);\n    CHECK_NE(node.port, node.kEmpty);\n    CHECK(node.hostname.size());\n    int id = node.id;\n    auto it = senders_.find(id);\n    if (it != senders_.end()) {\n      zmq_close(it->second);\n    }\n    // worker doesn't need to connect to the other workers. same for server\n    if ((node.role == my_node_.role) &&\n        (node.id != my_node_.id)) {\n      return;\n    }\n    void *sender = zmq_socket(context_, ZMQ_DEALER);\n    CHECK(sender != NULL)\n        << zmq_strerror(errno)\n        << \". it often can be solved by \\\"sudo ulimit -n 65536\\\"\"\n        << \" or edit /etc/security/limits.conf\";\n    if (my_node_.id != Node::kEmpty) {\n      std::string my_id = \"ps\" + std::to_string(my_node_.id);\n      zmq_setsockopt(sender, ZMQ_IDENTITY, my_id.data(), my_id.size());\n    }\n    // connect\n    std::string addr = \"tcp://\" + node.hostname + \":\" + std::to_string(node.port);\n    if (GetEnv(\"DMLC_LOCAL\", 0)) {\n      addr = \"ipc:///tmp/\" + std::to_string(node.port);\n    }\n    if (zmq_connect(sender, addr.c_str()) != 0) {\n      LOG(FATAL) <<  \"connect to \" + addr + \" failed: \" + zmq_strerror(errno);\n    }\n    senders_[id] = sender;\n  }",
          "includes": [
            "#include \"ps/internal/van.h\"",
            "#include <string>",
            "#include <thread>",
            "#include <stdlib.h>",
            "#include <zmq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ps/internal/van.h\"\n#include <string>\n#include <thread>\n#include <stdlib.h>\n#include <zmq.h>\n\nZMQVan {\n  void Connect(const Node& node) override {\n      CHECK_NE(node.id, node.kEmpty);\n      CHECK_NE(node.port, node.kEmpty);\n      CHECK(node.hostname.size());\n      int id = node.id;\n      auto it = senders_.find(id);\n      if (it != senders_.end()) {\n        zmq_close(it->second);\n      }\n      // worker doesn't need to connect to the other workers. same for server\n      if ((node.role == my_node_.role) &&\n          (node.id != my_node_.id)) {\n        return;\n      }\n      void *sender = zmq_socket(context_, ZMQ_DEALER);\n      CHECK(sender != NULL)\n          << zmq_strerror(errno)\n          << \". it often can be solved by \\\"sudo ulimit -n 65536\\\"\"\n          << \" or edit /etc/security/limits.conf\";\n      if (my_node_.id != Node::kEmpty) {\n        std::string my_id = \"ps\" + std::to_string(my_node_.id);\n        zmq_setsockopt(sender, ZMQ_IDENTITY, my_id.data(), my_id.size());\n      }\n      // connect\n      std::string addr = \"tcp://\" + node.hostname + \":\" + std::to_string(node.port);\n      if (GetEnv(\"DMLC_LOCAL\", 0)) {\n        addr = \"ipc:///tmp/\" + std::to_string(node.port);\n      }\n      if (zmq_connect(sender, addr.c_str()) != 0) {\n        LOG(FATAL) <<  \"connect to \" + addr + \" failed: \" + zmq_strerror(errno);\n      }\n      senders_[id] = sender;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_NE",
          "args": [
            "my_node_.port",
            "-1"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_node_.DebugString",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PS_VLOG",
          "args": [
            "1"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bind",
          "args": [
            "my_node_",
            "is_scheduler_ ? 0 : 40"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "Bind",
          "container": "ZMQVan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
          "lines": "61-79",
          "snippet": "int Bind(const Node& node, int max_retry) override {\n    receiver_ = zmq_socket(context_, ZMQ_ROUTER);\n    CHECK(receiver_ != NULL)\n        << \"create receiver socket failed: \" << zmq_strerror(errno);\n    int local = GetEnv(\"DMLC_LOCAL\", 0);\n    std::string addr = local ? \"ipc:///tmp/\" : \"tcp://*:\";\n    int port = node.port;\n    unsigned seed = static_cast<unsigned>(time(NULL)+port);\n    for (int i = 0; i < max_retry+1; ++i) {\n      auto address = addr + std::to_string(port);\n      if (zmq_bind(receiver_, address.c_str()) == 0) break;\n      if (i == max_retry) {\n        port = -1;\n      } else {\n        port = 10000 + rand_r(&seed) % 40000;\n      }\n    }\n    return port;\n  }",
          "includes": [
            "#include \"ps/internal/van.h\"",
            "#include <string>",
            "#include <thread>",
            "#include <stdlib.h>",
            "#include <zmq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ps/internal/van.h\"\n#include <string>\n#include <thread>\n#include <stdlib.h>\n#include <zmq.h>\n\nZMQVan {\n  int Bind(const Node& node, int max_retry) override {\n      receiver_ = zmq_socket(context_, ZMQ_ROUTER);\n      CHECK(receiver_ != NULL)\n          << \"create receiver socket failed: \" << zmq_strerror(errno);\n      int local = GetEnv(\"DMLC_LOCAL\", 0);\n      std::string addr = local ? \"ipc:///tmp/\" : \"tcp://*:\";\n      int port = node.port;\n      unsigned seed = static_cast<unsigned>(time(NULL)+port);\n      for (int i = 0; i < max_retry+1; ++i) {\n        auto address = addr + std::to_string(port);\n        if (zmq_bind(receiver_, address.c_str()) == 0) break;\n        if (i == max_retry) {\n          port = -1;\n        } else {\n          port = 10000 + rand_r(&seed) % 40000;\n        }\n      }\n      return port;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "port"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "!ip.empty()"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip.empty",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "pstr"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [
            "\"PORT\""
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAvailablePort",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "GetAvailablePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/network_utils.h",
          "lines": "226-255",
          "snippet": "int GetAvailablePort() {\n  struct sockaddr_in addr;\n  addr.sin_port = htons(0);  // have system pick up a random port available for me\n  addr.sin_family = AF_INET;  // IPV4\n  addr.sin_addr.s_addr = htonl(INADDR_ANY);  // set our addr to any interface\n\n  int sock = socket(AF_INET, SOCK_STREAM, 0);\n  if (0 != bind(sock, (struct sockaddr*)&addr, sizeof(struct sockaddr_in))) {\n    perror(\"bind():\");\n    return 0;\n  }\n#ifdef _MSC_VER\n  int addr_len = sizeof(struct sockaddr_in);\n#else\n  socklen_t addr_len = sizeof(struct sockaddr_in);\n#endif\n\n  if (0 != getsockname(sock, (struct sockaddr*)&addr, &addr_len)) {\n    perror(\"getsockname():\");\n    return 0;\n  }\n\n  int ret_port = ntohs(addr.sin_port);\n#ifdef  _MSC_VER\n  closesocket(sock);\n#else\n  close(sock);\n#endif\n  return ret_port;\n}",
          "includes": [
            "#include <string>",
            "#include <netinet/in.h>",
            "#include <ifaddrs.h>",
            "#include <arpa/inet.h>",
            "#include <net/if.h>",
            "#include <iphlpapi.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <tchar.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <netinet/in.h>\n#include <ifaddrs.h>\n#include <arpa/inet.h>\n#include <net/if.h>\n#include <iphlpapi.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <tchar.h>\n#include <unistd.h>\n\nint GetAvailablePort() {\n  struct sockaddr_in addr;\n  addr.sin_port = htons(0);  // have system pick up a random port available for me\n  addr.sin_family = AF_INET;  // IPV4\n  addr.sin_addr.s_addr = htonl(INADDR_ANY);  // set our addr to any interface\n\n  int sock = socket(AF_INET, SOCK_STREAM, 0);\n  if (0 != bind(sock, (struct sockaddr*)&addr, sizeof(struct sockaddr_in))) {\n    perror(\"bind():\");\n    return 0;\n  }\n#ifdef _MSC_VER\n  int addr_len = sizeof(struct sockaddr_in);\n#else\n  socklen_t addr_len = sizeof(struct sockaddr_in);\n#endif\n\n  if (0 != getsockname(sock, (struct sockaddr*)&addr, &addr_len)) {\n    perror(\"getsockname():\");\n    return 0;\n  }\n\n  int ret_port = ntohs(addr.sin_port);\n#ifdef  _MSC_VER\n  closesocket(sock);\n#else\n  close(sock);\n#endif\n  return ret_port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "!interface.empty()"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interface.empty",
          "args": [],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAvailableInterfaceAndIP",
          "args": [
            "&interface",
            "&ip"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "GetAvailableInterfaceAndIP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/network_utils.h",
          "lines": "121-218",
          "snippet": "void GetAvailableInterfaceAndIP(\n    std::string* interface, std::string* ip) {\n#ifdef _MSC_VER\n  typedef std::basic_string<TCHAR> tstring;\n  IP_ADAPTER_INFO * pAdapterInfo = NULL;\n  {\n    ULONG bufLen = 0;\n    for (int i = 0; i < 5; i++) {\n      DWORD apRet = GetAdaptersInfo(pAdapterInfo, &bufLen);\n      if (apRet == ERROR_BUFFER_OVERFLOW) {\n        free(pAdapterInfo);  // in case we had previously allocated it\n        pAdapterInfo = static_cast<IP_ADAPTER_INFO*>(malloc(bufLen));\n      } else if (apRet == ERROR_SUCCESS) {\n        break;\n      } else {\n        free(pAdapterInfo);\n        pAdapterInfo = NULL;\n        break;\n      }\n    }\n  }\n  if (pAdapterInfo) {\n    tstring keybase = _T(\n        \"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Network\\\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\\\\");\n    tstring connection = _T(\"\\\\Connection\");\n\n    IP_ADAPTER_INFO *curpAdapterInfo = pAdapterInfo;\n    HKEY hKEY = NULL;\n    while (curpAdapterInfo) {\n      std::string curip(curpAdapterInfo->IpAddressList.IpAddress.String);\n      if (curip == \"127.0.0.1\") {\n        curpAdapterInfo = curpAdapterInfo->Next;\n        continue;\n      }\n      if (curip == \"0.0.0.0\") {\n        curpAdapterInfo = curpAdapterInfo->Next;\n        continue;\n      }\n\n      std::string AdapterName = curpAdapterInfo->AdapterName;\n      // GUID only ascii\n      tstring key_set = keybase + tstring(AdapterName.begin(), AdapterName.end()) + connection;\n      LPCTSTR data_Set = key_set.c_str();\n      LPCTSTR dwValue = NULL;\n      if (ERROR_SUCCESS ==\n          ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, data_Set, 0, KEY_READ, &hKEY)) {\n        DWORD dwSize = 0;\n        DWORD dwType = REG_SZ;\n        if (ERROR_SUCCESS ==\n            ::RegQueryValueEx(hKEY, _T(\"Name\"), 0, &dwType, (LPBYTE)dwValue, &dwSize)) {\n          dwValue = new TCHAR[dwSize];\n          if (ERROR_SUCCESS ==\n              ::RegQueryValueEx(hKEY, _T(\"Name\"), 0, &dwType, (LPBYTE)dwValue, &dwSize)) {\n            // interface name must only ascii\n            tstring tstr = dwValue;\n            std::string s(tstr.begin(), tstr.end());\n\n            *interface = s;\n            *ip = curip;\n            break;\n          }\n        }\n        ::RegCloseKey(hKEY);\n        hKEY = NULL;\n      }\n      curpAdapterInfo = curpAdapterInfo->Next;\n    }\n    if (hKEY != NULL) {\n      ::RegCloseKey(hKEY);\n    }\n    free(pAdapterInfo);\n  }\n#else\n  struct ifaddrs * ifAddrStruct = nullptr;\n  struct ifaddrs * ifa = nullptr;\n\n  interface->clear();\n  ip->clear();\n  getifaddrs(&ifAddrStruct);\n  for (ifa = ifAddrStruct; ifa != nullptr; ifa = ifa->ifa_next) {\n    if (nullptr == ifa->ifa_addr) continue;\n\n    if (AF_INET == ifa->ifa_addr->sa_family &&\n        0 == (ifa->ifa_flags & IFF_LOOPBACK)) {\n      char address_buffer[INET_ADDRSTRLEN];\n      void* sin_addr_ptr = &(reinterpret_cast<struct sockaddr_in*>(ifa->ifa_addr))->sin_addr;\n      inet_ntop(AF_INET, sin_addr_ptr, address_buffer, INET_ADDRSTRLEN);\n\n      *ip = address_buffer;\n      *interface = ifa->ifa_name;\n\n      break;\n    }\n  }\n  if (nullptr != ifAddrStruct) freeifaddrs(ifAddrStruct);\n  return;\n#endif\n}",
          "includes": [
            "#include <string>",
            "#include <netinet/in.h>",
            "#include <ifaddrs.h>",
            "#include <arpa/inet.h>",
            "#include <net/if.h>",
            "#include <iphlpapi.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <tchar.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <netinet/in.h>\n#include <ifaddrs.h>\n#include <arpa/inet.h>\n#include <net/if.h>\n#include <iphlpapi.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <tchar.h>\n#include <unistd.h>\n\nvoid GetAvailableInterfaceAndIP(\n    std::string* interface, std::string* ip) {\n#ifdef _MSC_VER\n  typedef std::basic_string<TCHAR> tstring;\n  IP_ADAPTER_INFO * pAdapterInfo = NULL;\n  {\n    ULONG bufLen = 0;\n    for (int i = 0; i < 5; i++) {\n      DWORD apRet = GetAdaptersInfo(pAdapterInfo, &bufLen);\n      if (apRet == ERROR_BUFFER_OVERFLOW) {\n        free(pAdapterInfo);  // in case we had previously allocated it\n        pAdapterInfo = static_cast<IP_ADAPTER_INFO*>(malloc(bufLen));\n      } else if (apRet == ERROR_SUCCESS) {\n        break;\n      } else {\n        free(pAdapterInfo);\n        pAdapterInfo = NULL;\n        break;\n      }\n    }\n  }\n  if (pAdapterInfo) {\n    tstring keybase = _T(\n        \"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Network\\\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\\\\");\n    tstring connection = _T(\"\\\\Connection\");\n\n    IP_ADAPTER_INFO *curpAdapterInfo = pAdapterInfo;\n    HKEY hKEY = NULL;\n    while (curpAdapterInfo) {\n      std::string curip(curpAdapterInfo->IpAddressList.IpAddress.String);\n      if (curip == \"127.0.0.1\") {\n        curpAdapterInfo = curpAdapterInfo->Next;\n        continue;\n      }\n      if (curip == \"0.0.0.0\") {\n        curpAdapterInfo = curpAdapterInfo->Next;\n        continue;\n      }\n\n      std::string AdapterName = curpAdapterInfo->AdapterName;\n      // GUID only ascii\n      tstring key_set = keybase + tstring(AdapterName.begin(), AdapterName.end()) + connection;\n      LPCTSTR data_Set = key_set.c_str();\n      LPCTSTR dwValue = NULL;\n      if (ERROR_SUCCESS ==\n          ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, data_Set, 0, KEY_READ, &hKEY)) {\n        DWORD dwSize = 0;\n        DWORD dwType = REG_SZ;\n        if (ERROR_SUCCESS ==\n            ::RegQueryValueEx(hKEY, _T(\"Name\"), 0, &dwType, (LPBYTE)dwValue, &dwSize)) {\n          dwValue = new TCHAR[dwSize];\n          if (ERROR_SUCCESS ==\n              ::RegQueryValueEx(hKEY, _T(\"Name\"), 0, &dwType, (LPBYTE)dwValue, &dwSize)) {\n            // interface name must only ascii\n            tstring tstr = dwValue;\n            std::string s(tstr.begin(), tstr.end());\n\n            *interface = s;\n            *ip = curip;\n            break;\n          }\n        }\n        ::RegCloseKey(hKEY);\n        hKEY = NULL;\n      }\n      curpAdapterInfo = curpAdapterInfo->Next;\n    }\n    if (hKEY != NULL) {\n      ::RegCloseKey(hKEY);\n    }\n    free(pAdapterInfo);\n  }\n#else\n  struct ifaddrs * ifAddrStruct = nullptr;\n  struct ifaddrs * ifa = nullptr;\n\n  interface->clear();\n  ip->clear();\n  getifaddrs(&ifAddrStruct);\n  for (ifa = ifAddrStruct; ifa != nullptr; ifa = ifa->ifa_next) {\n    if (nullptr == ifa->ifa_addr) continue;\n\n    if (AF_INET == ifa->ifa_addr->sa_family &&\n        0 == (ifa->ifa_flags & IFF_LOOPBACK)) {\n      char address_buffer[INET_ADDRSTRLEN];\n      void* sin_addr_ptr = &(reinterpret_cast<struct sockaddr_in*>(ifa->ifa_addr))->sin_addr;\n      inet_ntop(AF_INET, sin_addr_ptr, address_buffer, INET_ADDRSTRLEN);\n\n      *ip = address_buffer;\n      *interface = ifa->ifa_name;\n\n      break;\n    }\n  }\n  if (nullptr != ifAddrStruct) freeifaddrs(ifAddrStruct);\n  return;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetIP",
          "args": [
            "interface",
            "&ip"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "GetIP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/network_utils.h",
          "lines": "28-112",
          "snippet": "void GetIP(const std::string& interface, std::string* ip) {\n#ifdef _MSC_VER\n  typedef std::basic_string<TCHAR> tstring;\n  // Try to get the Adapters-info table, so we can given useful names to the IP\n  // addresses we are returning.  Gotta call GetAdaptersInfo() up to 5 times to handle\n  // the potential race condition between the size-query call and the get-data call.\n  // I love a well-designed API :^P\n  IP_ADAPTER_INFO * pAdapterInfo = NULL;\n  {\n    ULONG bufLen = 0;\n    for (int i = 0; i < 5; i++) {\n      DWORD apRet = GetAdaptersInfo(pAdapterInfo, &bufLen);\n      if (apRet == ERROR_BUFFER_OVERFLOW) {\n        free(pAdapterInfo);  // in case we had previously allocated it\n        pAdapterInfo = static_cast<IP_ADAPTER_INFO*>(malloc(bufLen));\n      } else if (apRet == ERROR_SUCCESS) {\n        break;\n      } else {\n        free(pAdapterInfo);\n        pAdapterInfo = NULL;\n        break;\n      }\n    }\n  }\n  if (pAdapterInfo) {\n    tstring keybase = _T(\n        \"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Network\\\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\\\\");\n    tstring connection = _T(\"\\\\Connection\");\n\n    IP_ADAPTER_INFO *curpAdapterInfo = pAdapterInfo;\n    while (curpAdapterInfo) {\n      HKEY hKEY;\n      std::string AdapterName = curpAdapterInfo->AdapterName;\n      // GUID only ascii\n      tstring key_set = keybase + tstring(AdapterName.begin(), AdapterName.end()) + connection;\n      LPCTSTR data_Set = key_set.c_str();\n      LPCTSTR dwValue = NULL;\n      if (ERROR_SUCCESS ==\n          ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, data_Set, 0, KEY_READ, &hKEY)) {\n        DWORD dwSize = 0;\n        DWORD dwType = REG_SZ;\n        if (ERROR_SUCCESS ==\n            ::RegQueryValueEx(hKEY, _T(\"Name\"), 0, &dwType, (LPBYTE)dwValue, &dwSize)) {\n          dwValue = new TCHAR[dwSize];\n          if (ERROR_SUCCESS ==\n              ::RegQueryValueEx(hKEY, _T(\"Name\"), 0, &dwType, (LPBYTE)dwValue, &dwSize)) {\n            // interface name must only ascii\n            tstring tstr = dwValue;\n            std::string s(tstr.begin(), tstr.end());\n            if (s == interface) {\n              *ip = curpAdapterInfo->IpAddressList.IpAddress.String;\n              break;\n            }\n          }\n        }\n        ::RegCloseKey(hKEY);\n      }\n      curpAdapterInfo = curpAdapterInfo->Next;\n    }\n    free(pAdapterInfo);\n  }\n#else\n  struct ifaddrs * ifAddrStruct = NULL;\n  struct ifaddrs * ifa = NULL;\n  void * tmpAddrPtr = NULL;\n\n  getifaddrs(&ifAddrStruct);\n  for (ifa = ifAddrStruct; ifa != NULL; ifa = ifa->ifa_next) {\n    if (ifa->ifa_addr == NULL) continue;\n    if (ifa->ifa_addr->sa_family == AF_INET) {\n      // is a valid IP4 Address\n      tmpAddrPtr = &(reinterpret_cast<struct sockaddr_in*>(ifa->ifa_addr))->sin_addr;\n      char addressBuffer[INET_ADDRSTRLEN];\n      inet_ntop(AF_INET, tmpAddrPtr, addressBuffer, INET_ADDRSTRLEN);\n      if (strncmp(ifa->ifa_name,\n                  interface.c_str(),\n                  interface.size()) == 0) {\n        *ip = addressBuffer;\n        break;\n      }\n    }\n  }\n  if (ifAddrStruct != NULL) freeifaddrs(ifAddrStruct);\n#endif\n}",
          "includes": [
            "#include <string>",
            "#include <netinet/in.h>",
            "#include <ifaddrs.h>",
            "#include <arpa/inet.h>",
            "#include <net/if.h>",
            "#include <iphlpapi.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <tchar.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <netinet/in.h>\n#include <ifaddrs.h>\n#include <arpa/inet.h>\n#include <net/if.h>\n#include <iphlpapi.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <tchar.h>\n#include <unistd.h>\n\nvoid GetIP(const std::string& interface, std::string* ip) {\n#ifdef _MSC_VER\n  typedef std::basic_string<TCHAR> tstring;\n  // Try to get the Adapters-info table, so we can given useful names to the IP\n  // addresses we are returning.  Gotta call GetAdaptersInfo() up to 5 times to handle\n  // the potential race condition between the size-query call and the get-data call.\n  // I love a well-designed API :^P\n  IP_ADAPTER_INFO * pAdapterInfo = NULL;\n  {\n    ULONG bufLen = 0;\n    for (int i = 0; i < 5; i++) {\n      DWORD apRet = GetAdaptersInfo(pAdapterInfo, &bufLen);\n      if (apRet == ERROR_BUFFER_OVERFLOW) {\n        free(pAdapterInfo);  // in case we had previously allocated it\n        pAdapterInfo = static_cast<IP_ADAPTER_INFO*>(malloc(bufLen));\n      } else if (apRet == ERROR_SUCCESS) {\n        break;\n      } else {\n        free(pAdapterInfo);\n        pAdapterInfo = NULL;\n        break;\n      }\n    }\n  }\n  if (pAdapterInfo) {\n    tstring keybase = _T(\n        \"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Network\\\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\\\\");\n    tstring connection = _T(\"\\\\Connection\");\n\n    IP_ADAPTER_INFO *curpAdapterInfo = pAdapterInfo;\n    while (curpAdapterInfo) {\n      HKEY hKEY;\n      std::string AdapterName = curpAdapterInfo->AdapterName;\n      // GUID only ascii\n      tstring key_set = keybase + tstring(AdapterName.begin(), AdapterName.end()) + connection;\n      LPCTSTR data_Set = key_set.c_str();\n      LPCTSTR dwValue = NULL;\n      if (ERROR_SUCCESS ==\n          ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, data_Set, 0, KEY_READ, &hKEY)) {\n        DWORD dwSize = 0;\n        DWORD dwType = REG_SZ;\n        if (ERROR_SUCCESS ==\n            ::RegQueryValueEx(hKEY, _T(\"Name\"), 0, &dwType, (LPBYTE)dwValue, &dwSize)) {\n          dwValue = new TCHAR[dwSize];\n          if (ERROR_SUCCESS ==\n              ::RegQueryValueEx(hKEY, _T(\"Name\"), 0, &dwType, (LPBYTE)dwValue, &dwSize)) {\n            // interface name must only ascii\n            tstring tstr = dwValue;\n            std::string s(tstr.begin(), tstr.end());\n            if (s == interface) {\n              *ip = curpAdapterInfo->IpAddressList.IpAddress.String;\n              break;\n            }\n          }\n        }\n        ::RegCloseKey(hKEY);\n      }\n      curpAdapterInfo = curpAdapterInfo->Next;\n    }\n    free(pAdapterInfo);\n  }\n#else\n  struct ifaddrs * ifAddrStruct = NULL;\n  struct ifaddrs * ifa = NULL;\n  void * tmpAddrPtr = NULL;\n\n  getifaddrs(&ifAddrStruct);\n  for (ifa = ifAddrStruct; ifa != NULL; ifa = ifa->ifa_next) {\n    if (ifa->ifa_addr == NULL) continue;\n    if (ifa->ifa_addr->sa_family == AF_INET) {\n      // is a valid IP4 Address\n      tmpAddrPtr = &(reinterpret_cast<struct sockaddr_in*>(ifa->ifa_addr))->sin_addr;\n      char addressBuffer[INET_ADDRSTRLEN];\n      inet_ntop(AF_INET, tmpAddrPtr, addressBuffer, INET_ADDRSTRLEN);\n      if (strncmp(ifa->ifa_name,\n                  interface.c_str(),\n                  interface.size()) == 0) {\n        *ip = addressBuffer;\n        break;\n      }\n    }\n  }\n  if (ifAddrStruct != NULL) freeifaddrs(ifAddrStruct);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "interface.size",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "itf"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [
            "\"DMLC_INTERFACE\""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip.empty",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "nhost"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [
            "\"DMLC_NODE_HOST\""
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Postoffice::Get",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "CHECK_NOTNULL(Environment::Get()->find(\"DMLC_PS_ROOT_PORT\"))"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_NOTNULL",
          "args": [
            "Environment::Get()->find(\"DMLC_PS_ROOT_PORT\")"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [
            "\"DMLC_PS_ROOT_PORT\""
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "CHECK_NOTNULL(Environment::Get()->find(\"DMLC_PS_ROOT_URI\"))"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_NOTNULL",
          "args": [
            "Environment::Get()->find(\"DMLC_PS_ROOT_URI\")"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [
            "\"DMLC_PS_ROOT_URI\""
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"./resender.h\"\n#include \"./zmq_van.h\"\n#include \"./meta.pb.h\"\n#include \"./network_utils.h\"\n#include \"ps/internal/customer.h\"\n#include \"ps/internal/postoffice.h\"\n#include \"ps/sarray.h\"\n#include \"ps/base.h\"\n#include <chrono>\n#include <thread>\n#include \"ps/internal/van.h\"\n\nVan {\n  void Van::Start() {\n    // get scheduler info\n    scheduler_.hostname = std::string(CHECK_NOTNULL(Environment::Get()->find(\"DMLC_PS_ROOT_URI\")));\n    scheduler_.port     = atoi(CHECK_NOTNULL(Environment::Get()->find(\"DMLC_PS_ROOT_PORT\")));\n    scheduler_.role     = Node::SCHEDULER;\n    scheduler_.id       = kScheduler;\n    is_scheduler_       = Postoffice::Get()->is_scheduler();\n  \n    // get my node info\n    if (is_scheduler_) {\n      my_node_ = scheduler_;\n    } else {\n      auto role = is_scheduler_ ? Node::SCHEDULER :\n                  (Postoffice::Get()->is_worker() ? Node::WORKER : Node::SERVER);\n      const char* nhost = Environment::Get()->find(\"DMLC_NODE_HOST\");\n      std::string ip;\n      if (nhost) ip = std::string(nhost);\n      if (ip.empty()) {\n        const char*  itf = Environment::Get()->find(\"DMLC_INTERFACE\");\n        std::string interface;\n        if (itf) interface = std::string(itf);\n        if (interface.size()) {\n          GetIP(interface, &ip);\n        } else {\n          GetAvailableInterfaceAndIP(&interface, &ip);\n        }\n        CHECK(!interface.empty()) << \"failed to get the interface\";\n      }\n      int port = GetAvailablePort();\n      const char* pstr = Environment::Get()->find(\"PORT\");\n      if (pstr) port = atoi(pstr);\n      CHECK(!ip.empty()) << \"failed to get ip\";\n      CHECK(port) << \"failed to get a port\";\n      my_node_.hostname = ip;\n      my_node_.role     = role;\n      my_node_.port     = port;\n      // cannot determine my id now, the scheduler will assign it later\n      // set it explicitly to make re-register within a same process possible\n      my_node_.id = Node::kEmpty;\n    }\n  \n    // bind.\n    my_node_.port = Bind(my_node_, is_scheduler_ ? 0 : 40);\n    PS_VLOG(1) << \"Bind to \" << my_node_.DebugString();\n    CHECK_NE(my_node_.port, -1) << \"bind failed\";\n  \n    // connect to the scheduler\n    Connect(scheduler_);\n  \n    // for debug use\n    if (Environment::Get()->find(\"PS_DROP_MSG\")) {\n      drop_rate_ = atoi(Environment::Get()->find(\"PS_DROP_MSG\"));\n    }\n    // start receiver\n    receiver_thread_ = std::unique_ptr<std::thread>(\n        new std::thread(&Van::Receiving, this));\n  \n    if (!is_scheduler_) {\n      // let the scheduler know myself\n      Message msg;\n      msg.meta.recver = kScheduler;\n      msg.meta.control.cmd = Control::ADD_NODE;\n      msg.meta.control.node.push_back(my_node_);\n      msg.meta.timestamp = timestamp_++;\n      Send(msg);\n    }\n    // wait until ready\n    while (!ready_) {\n      std::this_thread::sleep_for(std::chrono::milliseconds(1));\n    }\n  \n    // resender\n    if (Environment::Get()->find(\"PS_RESEND\") && atoi(Environment::Get()->find(\"PS_RESEND\")) != 0) {\n      int timeout = 1000;\n      if (Environment::Get()->find(\"PS_RESEND_TIMEOUT\")) {\n        timeout = atoi(Environment::Get()->find(\"PS_RESEND_TIMEOUT\"));\n      }\n      resender_ = new Resender(timeout, 10, this);\n    }\n  \n    if (!is_scheduler_) {\n      // start heartbeat thread\n      heartbeat_thread_ = std::unique_ptr<std::thread>(\n        new std::thread(&Van::Heartbeat, this));\n    }\n  }\n}"
  }
]