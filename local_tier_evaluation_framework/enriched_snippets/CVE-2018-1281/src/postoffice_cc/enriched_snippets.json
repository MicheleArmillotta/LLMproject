[
  {
    "function_name": "GetDeadNodes",
    "container": "Postoffice",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/postoffice.cc",
    "lines": "156-175",
    "snippet": "std::vector<int> Postoffice::GetDeadNodes(int t) {\n  std::vector<int> dead_nodes;\n  if (!van_->IsReady() || t == 0) return dead_nodes;\n\n  time_t curr_time = time(NULL);\n  const auto& nodes = is_scheduler_\n    ? GetNodeIDs(kWorkerGroup + kServerGroup)\n    : GetNodeIDs(kScheduler);\n  {\n    std::lock_guard<std::mutex> lk(heartbeat_mu_);\n    for (int r : nodes) {\n      auto it = heartbeats_.find(r);\n      if ((it == heartbeats_.end() || it->second + t < curr_time)\n            && start_time_ + t < curr_time) {\n        dead_nodes.push_back(r);\n      }\n    }\n  }\n  return dead_nodes;\n}",
    "includes": [
      "#include \"ps/base.h\"",
      "#include \"ps/internal/message.h\"",
      "#include \"ps/internal/postoffice.h\"",
      "#include <chrono>",
      "#include <thread>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dead_nodes.push_back",
          "args": [
            "r"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heartbeats_.end",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heartbeats_.find",
          "args": [
            "r"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetNodeIDs",
          "args": [
            "kScheduler"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetNodeIDs",
          "args": [
            "kWorkerGroup + kServerGroup"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "van_->IsReady",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ps/base.h\"\n#include \"ps/internal/message.h\"\n#include \"ps/internal/postoffice.h\"\n#include <chrono>\n#include <thread>\n#include <unistd.h>\n\nPostoffice {\n  std::vector<int> Postoffice::GetDeadNodes(int t) {\n    std::vector<int> dead_nodes;\n    if (!van_->IsReady() || t == 0) return dead_nodes;\n  \n    time_t curr_time = time(NULL);\n    const auto& nodes = is_scheduler_\n      ? GetNodeIDs(kWorkerGroup + kServerGroup)\n      : GetNodeIDs(kScheduler);\n    {\n      std::lock_guard<std::mutex> lk(heartbeat_mu_);\n      for (int r : nodes) {\n        auto it = heartbeats_.find(r);\n        if ((it == heartbeats_.end() || it->second + t < curr_time)\n              && start_time_ + t < curr_time) {\n          dead_nodes.push_back(r);\n        }\n      }\n    }\n    return dead_nodes;\n  }\n}"
  },
  {
    "function_name": "Manage",
    "container": "Postoffice",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/postoffice.cc",
    "lines": "145-154",
    "snippet": "void Postoffice::Manage(const Message& recv) {\n  CHECK(!recv.meta.control.empty());\n  const auto& ctrl = recv.meta.control;\n  if (ctrl.cmd == Control::BARRIER && !recv.meta.request) {\n    barrier_mu_.lock();\n    barrier_done_ = true;\n    barrier_mu_.unlock();\n    barrier_cond_.notify_all();\n  }\n}",
    "includes": [
      "#include \"ps/base.h\"",
      "#include \"ps/internal/message.h\"",
      "#include \"ps/internal/postoffice.h\"",
      "#include <chrono>",
      "#include <thread>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "barrier_cond_.notify_all",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier_mu_.unlock",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier_mu_.lock",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "!recv.meta.control.empty()"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv.meta.control.empty",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ps/base.h\"\n#include \"ps/internal/message.h\"\n#include \"ps/internal/postoffice.h\"\n#include <chrono>\n#include <thread>\n#include <unistd.h>\n\nPostoffice {\n  void Postoffice::Manage(const Message& recv) {\n    CHECK(!recv.meta.control.empty());\n    const auto& ctrl = recv.meta.control;\n    if (ctrl.cmd == Control::BARRIER && !recv.meta.request) {\n      barrier_mu_.lock();\n      barrier_done_ = true;\n      barrier_mu_.unlock();\n      barrier_cond_.notify_all();\n    }\n  }\n}"
  },
  {
    "function_name": "Barrier",
    "container": "Postoffice",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/postoffice.cc",
    "lines": "108-132",
    "snippet": "void Postoffice::Barrier(int node_group) {\n  if (GetNodeIDs(node_group).size() <= 1) return;\n  auto role = van_->my_node().role;\n  if (role == Node::SCHEDULER) {\n    CHECK(node_group & kScheduler);\n  } else if (role == Node::WORKER) {\n    CHECK(node_group & kWorkerGroup);\n  } else if (role == Node::SERVER) {\n    CHECK(node_group & kServerGroup);\n  }\n\n  std::unique_lock<std::mutex> ulk(barrier_mu_);\n  barrier_done_ = false;\n  Message req;\n  req.meta.recver = kScheduler;\n  req.meta.request = true;\n  req.meta.control.cmd = Control::BARRIER;\n  req.meta.control.barrier_group = node_group;\n  req.meta.timestamp = van_->GetTimestamp();\n  CHECK_GT(van_->Send(req), 0);\n\n  barrier_cond_.wait(ulk, [this] {\n      return barrier_done_;\n    });\n}",
    "includes": [
      "#include \"ps/base.h\"",
      "#include \"ps/internal/message.h\"",
      "#include \"ps/internal/postoffice.h\"",
      "#include <chrono>",
      "#include <thread>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "barrier_cond_.wait",
          "args": [
            "ulk",
            "[this] {\n      return barrier_done_;\n    }"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_GT",
          "args": [
            "van_->Send(req)",
            "0"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "van_->Send",
          "args": [
            "req"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "Send",
          "container": "Van",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/van.cc",
          "lines": "130-139",
          "snippet": "int Van::Send(const Message& msg) {\n  int send_bytes = SendMsg(msg);\n  CHECK_NE(send_bytes, -1);\n  send_bytes_ += send_bytes;\n  if (resender_) resender_->AddOutgoing(msg);\n  if (Postoffice::Get()->verbose() >= 2) {\n    PS_VLOG(2) << msg.DebugString();\n  }\n  return send_bytes;\n}",
          "includes": [
            "#include \"./resender.h\"",
            "#include \"./zmq_van.h\"",
            "#include \"./meta.pb.h\"",
            "#include \"./network_utils.h\"",
            "#include \"ps/internal/customer.h\"",
            "#include \"ps/internal/postoffice.h\"",
            "#include \"ps/sarray.h\"",
            "#include \"ps/base.h\"",
            "#include <chrono>",
            "#include <thread>",
            "#include \"ps/internal/van.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"./resender.h\"\n#include \"./zmq_van.h\"\n#include \"./meta.pb.h\"\n#include \"./network_utils.h\"\n#include \"ps/internal/customer.h\"\n#include \"ps/internal/postoffice.h\"\n#include \"ps/sarray.h\"\n#include \"ps/base.h\"\n#include <chrono>\n#include <thread>\n#include \"ps/internal/van.h\"\n\nVan {\n  int Van::Send(const Message& msg) {\n    int send_bytes = SendMsg(msg);\n    CHECK_NE(send_bytes, -1);\n    send_bytes_ += send_bytes;\n    if (resender_) resender_->AddOutgoing(msg);\n    if (Postoffice::Get()->verbose() >= 2) {\n      PS_VLOG(2) << msg.DebugString();\n    }\n    return send_bytes;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "van_->GetTimestamp",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "node_group & kServerGroup"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "node_group & kWorkerGroup"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "node_group & kScheduler"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "van_->my_node",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetNodeIDs",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetNodeIDs",
          "args": [
            "node_group"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ps/base.h\"\n#include \"ps/internal/message.h\"\n#include \"ps/internal/postoffice.h\"\n#include <chrono>\n#include <thread>\n#include <unistd.h>\n\nPostoffice {\n  void Postoffice::Barrier(int node_group) {\n    if (GetNodeIDs(node_group).size() <= 1) return;\n    auto role = van_->my_node().role;\n    if (role == Node::SCHEDULER) {\n      CHECK(node_group & kScheduler);\n    } else if (role == Node::WORKER) {\n      CHECK(node_group & kWorkerGroup);\n    } else if (role == Node::SERVER) {\n      CHECK(node_group & kServerGroup);\n    }\n  \n    std::unique_lock<std::mutex> ulk(barrier_mu_);\n    barrier_done_ = false;\n    Message req;\n    req.meta.recver = kScheduler;\n    req.meta.request = true;\n    req.meta.control.cmd = Control::BARRIER;\n    req.meta.control.barrier_group = node_group;\n    req.meta.timestamp = van_->GetTimestamp();\n    CHECK_GT(van_->Send(req), 0);\n  \n    barrier_cond_.wait(ulk, [this] {\n        return barrier_done_;\n      });\n  }\n}"
  },
  {
    "function_name": "RemoveCustomer",
    "container": "Postoffice",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/postoffice.cc",
    "lines": "85-89",
    "snippet": "void Postoffice::RemoveCustomer(Customer* customer) {\n  std::lock_guard<std::mutex> lk(mu_);\n  int id = CHECK_NOTNULL(customer)->id();\n  customers_.erase(id);\n}",
    "includes": [
      "#include \"ps/base.h\"",
      "#include \"ps/internal/message.h\"",
      "#include \"ps/internal/postoffice.h\"",
      "#include <chrono>",
      "#include <thread>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "customers_.erase",
          "args": [
            "id"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_NOTNULL",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_NOTNULL",
          "args": [
            "customer"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ps/base.h\"\n#include \"ps/internal/message.h\"\n#include \"ps/internal/postoffice.h\"\n#include <chrono>\n#include <thread>\n#include <unistd.h>\n\nPostoffice {\n  void Postoffice::RemoveCustomer(Customer* customer) {\n    std::lock_guard<std::mutex> lk(mu_);\n    int id = CHECK_NOTNULL(customer)->id();\n    customers_.erase(id);\n  }\n}"
  },
  {
    "function_name": "AddCustomer",
    "container": "Postoffice",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/postoffice.cc",
    "lines": "77-82",
    "snippet": "void Postoffice::AddCustomer(Customer* customer) {\n  std::lock_guard<std::mutex> lk(mu_);\n  int id = CHECK_NOTNULL(customer)->id();\n  CHECK_EQ(customers_.count(id), (size_t)0) << \"id \" << id << \" already exists\";\n  customers_[id] = customer;\n}",
    "includes": [
      "#include \"ps/base.h\"",
      "#include \"ps/internal/message.h\"",
      "#include \"ps/internal/postoffice.h\"",
      "#include <chrono>",
      "#include <thread>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK_EQ",
          "args": [
            "customers_.count(id)",
            "(size_t)0"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "customers_.count",
          "args": [
            "id"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_NOTNULL",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_NOTNULL",
          "args": [
            "customer"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ps/base.h\"\n#include \"ps/internal/message.h\"\n#include \"ps/internal/postoffice.h\"\n#include <chrono>\n#include <thread>\n#include <unistd.h>\n\nPostoffice {\n  void Postoffice::AddCustomer(Customer* customer) {\n    std::lock_guard<std::mutex> lk(mu_);\n    int id = CHECK_NOTNULL(customer)->id();\n    CHECK_EQ(customers_.count(id), (size_t)0) << \"id \" << id << \" already exists\";\n    customers_[id] = customer;\n  }\n}"
  },
  {
    "function_name": "Finalize",
    "container": "Postoffice",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/postoffice.cc",
    "lines": "70-74",
    "snippet": "void Postoffice::Finalize(const bool do_barrier) {\n  if (do_barrier) Barrier(kWorkerGroup + kServerGroup + kScheduler);\n  van_->Stop();\n  if (exit_callback_) exit_callback_();\n}",
    "includes": [
      "#include \"ps/base.h\"",
      "#include \"ps/internal/message.h\"",
      "#include \"ps/internal/postoffice.h\"",
      "#include <chrono>",
      "#include <thread>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit_callback_",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "van_->Stop",
          "args": [],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "Stop",
          "container": "ZMQVan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
          "lines": "45-59",
          "snippet": "void Stop() override {\n    PS_VLOG(1) << my_node_.ShortDebugString() << \" is stopping\";\n    Van::Stop();\n    // close sockets\n    int linger = 0;\n    int rc = zmq_setsockopt(receiver_, ZMQ_LINGER, &linger, sizeof(linger));\n    CHECK(rc == 0 || errno == ETERM);\n    CHECK_EQ(zmq_close(receiver_), 0);\n    for (auto& it : senders_) {\n      int rc = zmq_setsockopt(it.second, ZMQ_LINGER, &linger, sizeof(linger));\n      CHECK(rc == 0 || errno == ETERM);\n      CHECK_EQ(zmq_close(it.second), 0);\n    }\n    zmq_ctx_destroy(context_);\n  }",
          "includes": [
            "#include \"ps/internal/van.h\"",
            "#include <string>",
            "#include <thread>",
            "#include <stdlib.h>",
            "#include <zmq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ps/internal/van.h\"\n#include <string>\n#include <thread>\n#include <stdlib.h>\n#include <zmq.h>\n\nZMQVan {\n  void Stop() override {\n      PS_VLOG(1) << my_node_.ShortDebugString() << \" is stopping\";\n      Van::Stop();\n      // close sockets\n      int linger = 0;\n      int rc = zmq_setsockopt(receiver_, ZMQ_LINGER, &linger, sizeof(linger));\n      CHECK(rc == 0 || errno == ETERM);\n      CHECK_EQ(zmq_close(receiver_), 0);\n      for (auto& it : senders_) {\n        int rc = zmq_setsockopt(it.second, ZMQ_LINGER, &linger, sizeof(linger));\n        CHECK(rc == 0 || errno == ETERM);\n        CHECK_EQ(zmq_close(it.second), 0);\n      }\n      zmq_ctx_destroy(context_);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Barrier",
          "args": [
            "kWorkerGroup + kServerGroup + kScheduler"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "Barrier",
          "container": "Postoffice",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/postoffice.cc",
          "lines": "108-132",
          "snippet": "void Postoffice::Barrier(int node_group) {\n  if (GetNodeIDs(node_group).size() <= 1) return;\n  auto role = van_->my_node().role;\n  if (role == Node::SCHEDULER) {\n    CHECK(node_group & kScheduler);\n  } else if (role == Node::WORKER) {\n    CHECK(node_group & kWorkerGroup);\n  } else if (role == Node::SERVER) {\n    CHECK(node_group & kServerGroup);\n  }\n\n  std::unique_lock<std::mutex> ulk(barrier_mu_);\n  barrier_done_ = false;\n  Message req;\n  req.meta.recver = kScheduler;\n  req.meta.request = true;\n  req.meta.control.cmd = Control::BARRIER;\n  req.meta.control.barrier_group = node_group;\n  req.meta.timestamp = van_->GetTimestamp();\n  CHECK_GT(van_->Send(req), 0);\n\n  barrier_cond_.wait(ulk, [this] {\n      return barrier_done_;\n    });\n}",
          "includes": [
            "#include \"ps/base.h\"",
            "#include \"ps/internal/message.h\"",
            "#include \"ps/internal/postoffice.h\"",
            "#include <chrono>",
            "#include <thread>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ps/base.h\"\n#include \"ps/internal/message.h\"\n#include \"ps/internal/postoffice.h\"\n#include <chrono>\n#include <thread>\n#include <unistd.h>\n\nPostoffice {\n  void Postoffice::Barrier(int node_group) {\n    if (GetNodeIDs(node_group).size() <= 1) return;\n    auto role = van_->my_node().role;\n    if (role == Node::SCHEDULER) {\n      CHECK(node_group & kScheduler);\n    } else if (role == Node::WORKER) {\n      CHECK(node_group & kWorkerGroup);\n    } else if (role == Node::SERVER) {\n      CHECK(node_group & kServerGroup);\n    }\n  \n    std::unique_lock<std::mutex> ulk(barrier_mu_);\n    barrier_done_ = false;\n    Message req;\n    req.meta.recver = kScheduler;\n    req.meta.request = true;\n    req.meta.control.cmd = Control::BARRIER;\n    req.meta.control.barrier_group = node_group;\n    req.meta.timestamp = van_->GetTimestamp();\n    CHECK_GT(van_->Send(req), 0);\n  \n    barrier_cond_.wait(ulk, [this] {\n        return barrier_done_;\n      });\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ps/base.h\"\n#include \"ps/internal/message.h\"\n#include \"ps/internal/postoffice.h\"\n#include <chrono>\n#include <thread>\n#include <unistd.h>\n\nPostoffice {\n  void Postoffice::Finalize(const bool do_barrier) {\n    if (do_barrier) Barrier(kWorkerGroup + kServerGroup + kScheduler);\n    van_->Stop();\n    if (exit_callback_) exit_callback_();\n  }\n}"
  },
  {
    "function_name": "Start",
    "container": "Postoffice",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/postoffice.cc",
    "lines": "28-68",
    "snippet": "void Postoffice::Start(const char* argv0, const bool do_barrier) {\n  // init glog\n  if (argv0) {\n    dmlc::InitLogging(argv0);\n  } else {\n    dmlc::InitLogging(\"ps-lite\\0\");\n  }\n\n  // init node info.\n  for (int i = 0; i < num_workers_; ++i) {\n    int id = WorkerRankToID(i);\n    for (int g : {id, kWorkerGroup, kWorkerGroup + kServerGroup,\n            kWorkerGroup + kScheduler,\n            kWorkerGroup + kServerGroup + kScheduler}) {\n      node_ids_[g].push_back(id);\n    }\n  }\n\n  for (int i = 0; i < num_servers_; ++i) {\n    int id = ServerRankToID(i);\n    for (int g : {id, kServerGroup, kWorkerGroup + kServerGroup,\n            kServerGroup + kScheduler,\n            kWorkerGroup + kServerGroup + kScheduler}) {\n      node_ids_[g].push_back(id);\n    }\n  }\n\n  for (int g : {kScheduler, kScheduler + kServerGroup + kWorkerGroup,\n          kScheduler + kWorkerGroup, kScheduler + kServerGroup}) {\n    node_ids_[g].push_back(kScheduler);\n  }\n\n  // start van\n  van_->Start();\n\n  // record start time\n  start_time_ = time(NULL);\n\n  // do a barrier here\n  if (do_barrier) Barrier(kWorkerGroup + kServerGroup + kScheduler);\n}",
    "includes": [
      "#include \"ps/base.h\"",
      "#include \"ps/internal/message.h\"",
      "#include \"ps/internal/postoffice.h\"",
      "#include <chrono>",
      "#include <thread>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Barrier",
          "args": [
            "kWorkerGroup + kServerGroup + kScheduler"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "Barrier",
          "container": "Postoffice",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/postoffice.cc",
          "lines": "108-132",
          "snippet": "void Postoffice::Barrier(int node_group) {\n  if (GetNodeIDs(node_group).size() <= 1) return;\n  auto role = van_->my_node().role;\n  if (role == Node::SCHEDULER) {\n    CHECK(node_group & kScheduler);\n  } else if (role == Node::WORKER) {\n    CHECK(node_group & kWorkerGroup);\n  } else if (role == Node::SERVER) {\n    CHECK(node_group & kServerGroup);\n  }\n\n  std::unique_lock<std::mutex> ulk(barrier_mu_);\n  barrier_done_ = false;\n  Message req;\n  req.meta.recver = kScheduler;\n  req.meta.request = true;\n  req.meta.control.cmd = Control::BARRIER;\n  req.meta.control.barrier_group = node_group;\n  req.meta.timestamp = van_->GetTimestamp();\n  CHECK_GT(van_->Send(req), 0);\n\n  barrier_cond_.wait(ulk, [this] {\n      return barrier_done_;\n    });\n}",
          "includes": [
            "#include \"ps/base.h\"",
            "#include \"ps/internal/message.h\"",
            "#include \"ps/internal/postoffice.h\"",
            "#include <chrono>",
            "#include <thread>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ps/base.h\"\n#include \"ps/internal/message.h\"\n#include \"ps/internal/postoffice.h\"\n#include <chrono>\n#include <thread>\n#include <unistd.h>\n\nPostoffice {\n  void Postoffice::Barrier(int node_group) {\n    if (GetNodeIDs(node_group).size() <= 1) return;\n    auto role = van_->my_node().role;\n    if (role == Node::SCHEDULER) {\n      CHECK(node_group & kScheduler);\n    } else if (role == Node::WORKER) {\n      CHECK(node_group & kWorkerGroup);\n    } else if (role == Node::SERVER) {\n      CHECK(node_group & kServerGroup);\n    }\n  \n    std::unique_lock<std::mutex> ulk(barrier_mu_);\n    barrier_done_ = false;\n    Message req;\n    req.meta.recver = kScheduler;\n    req.meta.request = true;\n    req.meta.control.cmd = Control::BARRIER;\n    req.meta.control.barrier_group = node_group;\n    req.meta.timestamp = van_->GetTimestamp();\n    CHECK_GT(van_->Send(req), 0);\n  \n    barrier_cond_.wait(ulk, [this] {\n        return barrier_done_;\n      });\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "van_->Start",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "Start",
          "container": "ZMQVan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
          "lines": "36-43",
          "snippet": "void Start() override {\n    // start zmq\n    context_ = zmq_ctx_new();\n    CHECK(context_ != NULL) << \"create 0mq context failed\";\n    zmq_ctx_set(context_, ZMQ_MAX_SOCKETS, 65536);\n    // zmq_ctx_set(context_, ZMQ_IO_THREADS, 4);\n    Van::Start();\n  }",
          "includes": [
            "#include \"ps/internal/van.h\"",
            "#include <string>",
            "#include <thread>",
            "#include <stdlib.h>",
            "#include <zmq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ps/internal/van.h\"\n#include <string>\n#include <thread>\n#include <stdlib.h>\n#include <zmq.h>\n\nZMQVan {\n  void Start() override {\n      // start zmq\n      context_ = zmq_ctx_new();\n      CHECK(context_ != NULL) << \"create 0mq context failed\";\n      zmq_ctx_set(context_, ZMQ_MAX_SOCKETS, 65536);\n      // zmq_ctx_set(context_, ZMQ_IO_THREADS, 4);\n      Van::Start();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_ids_[g].push_back",
          "args": [
            "kScheduler"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_ids_[g].push_back",
          "args": [
            "id"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ServerRankToID",
          "args": [
            "i"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_ids_[g].push_back",
          "args": [
            "id"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WorkerRankToID",
          "args": [
            "i"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dmlc::InitLogging",
          "args": [
            "\"ps-lite\\0\""
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dmlc::InitLogging",
          "args": [
            "argv0"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ps/base.h\"\n#include \"ps/internal/message.h\"\n#include \"ps/internal/postoffice.h\"\n#include <chrono>\n#include <thread>\n#include <unistd.h>\n\nPostoffice {\n  void Postoffice::Start(const char* argv0, const bool do_barrier) {\n    // init glog\n    if (argv0) {\n      dmlc::InitLogging(argv0);\n    } else {\n      dmlc::InitLogging(\"ps-lite\\0\");\n    }\n  \n    // init node info.\n    for (int i = 0; i < num_workers_; ++i) {\n      int id = WorkerRankToID(i);\n      for (int g : {id, kWorkerGroup, kWorkerGroup + kServerGroup,\n              kWorkerGroup + kScheduler,\n              kWorkerGroup + kServerGroup + kScheduler}) {\n        node_ids_[g].push_back(id);\n      }\n    }\n  \n    for (int i = 0; i < num_servers_; ++i) {\n      int id = ServerRankToID(i);\n      for (int g : {id, kServerGroup, kWorkerGroup + kServerGroup,\n              kServerGroup + kScheduler,\n              kWorkerGroup + kServerGroup + kScheduler}) {\n        node_ids_[g].push_back(id);\n      }\n    }\n  \n    for (int g : {kScheduler, kScheduler + kServerGroup + kWorkerGroup,\n            kScheduler + kWorkerGroup, kScheduler + kServerGroup}) {\n      node_ids_[g].push_back(kScheduler);\n    }\n  \n    // start van\n    van_->Start();\n  \n    // record start time\n    start_time_ = time(NULL);\n  \n    // do a barrier here\n    if (do_barrier) Barrier(kWorkerGroup + kServerGroup + kScheduler);\n  }\n}"
  },
  {
    "function_name": "Postoffice",
    "container": "Postoffice",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/postoffice.cc",
    "lines": "12-26",
    "snippet": "Postoffice::Postoffice() {\n  van_ = Van::Create(\"zmq\");\n  env_ref_ = Environment::_GetSharedRef();\n  const char* val = NULL;\n  val = CHECK_NOTNULL(Environment::Get()->find(\"DMLC_NUM_WORKER\"));\n  num_workers_ = atoi(val);\n  val =  CHECK_NOTNULL(Environment::Get()->find(\"DMLC_NUM_SERVER\"));\n  num_servers_ = atoi(val);\n  val = CHECK_NOTNULL(Environment::Get()->find(\"DMLC_ROLE\"));\n  std::string role(val);\n  is_worker_ = role == \"worker\";\n  is_server_ = role == \"server\";\n  is_scheduler_ = role == \"scheduler\";\n  verbose_ = GetEnv(\"PS_VERBOSE\", 0);\n}",
    "includes": [
      "#include \"ps/base.h\"",
      "#include \"ps/internal/message.h\"",
      "#include \"ps/internal/postoffice.h\"",
      "#include <chrono>",
      "#include <thread>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetEnv",
          "args": [
            "\"PS_VERBOSE\"",
            "0"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_NOTNULL",
          "args": [
            "Environment::Get()->find(\"DMLC_ROLE\")"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [
            "\"DMLC_ROLE\""
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "val"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_NOTNULL",
          "args": [
            "Environment::Get()->find(\"DMLC_NUM_SERVER\")"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [
            "\"DMLC_NUM_SERVER\""
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "val"
          ],
          "line": 17
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_NOTNULL",
          "args": [
            "Environment::Get()->find(\"DMLC_NUM_WORKER\")"
          ],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [
            "\"DMLC_NUM_WORKER\""
          ],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::Get",
          "args": [],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Environment::_GetSharedRef",
          "args": [],
          "line": 14
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Van::Create",
          "args": [
            "\"zmq\""
          ],
          "line": 13
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ps/base.h\"\n#include \"ps/internal/message.h\"\n#include \"ps/internal/postoffice.h\"\n#include <chrono>\n#include <thread>\n#include <unistd.h>\n\nPostoffice {\n  Postoffice::Postoffice() {\n    van_ = Van::Create(\"zmq\");\n    env_ref_ = Environment::_GetSharedRef();\n    const char* val = NULL;\n    val = CHECK_NOTNULL(Environment::Get()->find(\"DMLC_NUM_WORKER\"));\n    num_workers_ = atoi(val);\n    val =  CHECK_NOTNULL(Environment::Get()->find(\"DMLC_NUM_SERVER\"));\n    num_servers_ = atoi(val);\n    val = CHECK_NOTNULL(Environment::Get()->find(\"DMLC_ROLE\"));\n    std::string role(val);\n    is_worker_ = role == \"worker\";\n    is_server_ = role == \"server\";\n    is_scheduler_ = role == \"scheduler\";\n    verbose_ = GetEnv(\"PS_VERBOSE\", 0);\n  }\n}"
  }
]