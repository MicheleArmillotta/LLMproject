[
  {
    "function_name": "GetNodeID",
    "container": "ZMQVan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
    "lines": "216-230",
    "snippet": "int GetNodeID(const char* buf, size_t size) {\n    if (size > 2 && buf[0] == 'p' && buf[1] == 's') {\n      int id = 0;\n      size_t i = 2;\n      for (; i < size; ++i) {\n        if (buf[i] >= '0' && buf[i] <= '9') {\n          id = id * 10 + buf[i] - '0';\n        } else {\n          break;\n        }\n      }\n      if (i == size) return id;\n    }\n    return Meta::kEmpty;\n  }",
    "includes": [
      "#include \"ps/internal/van.h\"",
      "#include <string>",
      "#include <thread>",
      "#include <stdlib.h>",
      "#include <zmq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ps/internal/van.h\"\n#include <string>\n#include <thread>\n#include <stdlib.h>\n#include <zmq.h>\n\nZMQVan {\n  int GetNodeID(const char* buf, size_t size) {\n      if (size > 2 && buf[0] == 'p' && buf[1] == 's') {\n        int id = 0;\n        size_t i = 2;\n        for (; i < size; ++i) {\n          if (buf[i] >= '0' && buf[i] <= '9') {\n            id = id * 10 + buf[i] - '0';\n          } else {\n            break;\n          }\n        }\n        if (i == size) return id;\n      }\n      return Meta::kEmpty;\n    }\n}"
  },
  {
    "function_name": "RecvMsg",
    "container": "ZMQVan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
    "lines": "166-209",
    "snippet": "int RecvMsg(Message* msg) override {\n    msg->data.clear();\n    size_t recv_bytes = 0;\n    for (int i = 0; ; ++i) {\n      zmq_msg_t* zmsg = new zmq_msg_t;\n      CHECK(zmq_msg_init(zmsg) == 0) << zmq_strerror(errno);\n      while (true) {\n        if (zmq_msg_recv(zmsg, receiver_, 0) != -1) break;\n        if (errno == EINTR) continue;\n        LOG(WARNING) << \"failed to receive message. errno: \"\n                     << errno << \" \" << zmq_strerror(errno);\n        return -1;\n      }\n      char* buf = CHECK_NOTNULL((char *)zmq_msg_data(zmsg));\n      size_t size = zmq_msg_size(zmsg);\n      recv_bytes += size;\n\n      if (i == 0) {\n        // identify\n        msg->meta.sender = GetNodeID(buf, size);\n        msg->meta.recver = my_node_.id;\n        CHECK(zmq_msg_more(zmsg));\n        zmq_msg_close(zmsg);\n        delete zmsg;\n      } else if (i == 1) {\n        // task\n        UnpackMeta(buf, size, &(msg->meta));\n        zmq_msg_close(zmsg);\n        bool more = zmq_msg_more(zmsg);\n        delete zmsg;\n        if (!more) break;\n      } else {\n        // zero-copy\n        SArray<char> data;\n        data.reset(buf, size, [zmsg, size](char* buf) {\n            zmq_msg_close(zmsg);\n            delete zmsg;\n          });\n        msg->data.push_back(data);\n        if (!zmq_msg_more(zmsg)) { break; }\n      }\n    }\n    return recv_bytes;\n  }",
    "includes": [
      "#include \"ps/internal/van.h\"",
      "#include <string>",
      "#include <thread>",
      "#include <stdlib.h>",
      "#include <zmq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zmq_msg_more",
          "args": [
            "zmsg"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msg->data.push_back",
          "args": [
            "data"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.reset",
          "args": [
            "buf",
            "size",
            "[zmsg, size](char* buf) {\n            zmq_msg_close(zmsg);\n            delete zmsg;\n          }"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_msg_close",
          "args": [
            "zmsg"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_msg_more",
          "args": [
            "zmsg"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_msg_close",
          "args": [
            "zmsg"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnpackMeta",
          "args": [
            "buf",
            "size",
            "&(msg->meta)"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "UnpackMeta",
          "container": "Van",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/van.cc",
          "lines": "371-407",
          "snippet": "void Van::UnpackMeta(const char* meta_buf, int buf_size, Meta* meta) {\n  // to protobuf\n  PBMeta pb;\n  CHECK(pb.ParseFromArray(meta_buf, buf_size))\n      << \"failed to parse string into protobuf\";\n\n  // to meta\n  meta->head = pb.head();\n  meta->customer_id = pb.has_customer_id() ? pb.customer_id() : Meta::kEmpty;\n  meta->timestamp = pb.has_timestamp() ? pb.timestamp() : Meta::kEmpty;\n  meta->request = pb.request();\n  meta->push = pb.push();\n  meta->simple_app = pb.simple_app();\n  meta->body = pb.body();\n  meta->data_type.resize(pb.data_type_size());\n  for (int i = 0; i < pb.data_type_size(); ++i) {\n    meta->data_type[i] = static_cast<DataType>(pb.data_type(i));\n  }\n  if (pb.has_control()) {\n    const auto& ctrl = pb.control();\n    meta->control.cmd = static_cast<Control::Command>(ctrl.cmd());\n    meta->control.barrier_group = ctrl.barrier_group();\n    meta->control.msg_sig = ctrl.msg_sig();\n    for (int i = 0; i < ctrl.node_size(); ++i) {\n      const auto& p = ctrl.node(i);\n      Node n;\n      n.role = static_cast<Node::Role>(p.role());\n      n.port = p.port();\n      n.hostname = p.hostname();\n      n.id = p.has_id() ? p.id() : Node::kEmpty;\n      n.is_recovery = p.is_recovery();\n      meta->control.node.push_back(n);\n    }\n  } else {\n    meta->control.cmd = Control::EMPTY;\n  }\n}",
          "includes": [
            "#include \"./resender.h\"",
            "#include \"./zmq_van.h\"",
            "#include \"./meta.pb.h\"",
            "#include \"./network_utils.h\"",
            "#include \"ps/internal/customer.h\"",
            "#include \"ps/internal/postoffice.h\"",
            "#include \"ps/sarray.h\"",
            "#include \"ps/base.h\"",
            "#include <chrono>",
            "#include <thread>",
            "#include \"ps/internal/van.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"./resender.h\"\n#include \"./zmq_van.h\"\n#include \"./meta.pb.h\"\n#include \"./network_utils.h\"\n#include \"ps/internal/customer.h\"\n#include \"ps/internal/postoffice.h\"\n#include \"ps/sarray.h\"\n#include \"ps/base.h\"\n#include <chrono>\n#include <thread>\n#include \"ps/internal/van.h\"\n\nVan {\n  void Van::UnpackMeta(const char* meta_buf, int buf_size, Meta* meta) {\n    // to protobuf\n    PBMeta pb;\n    CHECK(pb.ParseFromArray(meta_buf, buf_size))\n        << \"failed to parse string into protobuf\";\n  \n    // to meta\n    meta->head = pb.head();\n    meta->customer_id = pb.has_customer_id() ? pb.customer_id() : Meta::kEmpty;\n    meta->timestamp = pb.has_timestamp() ? pb.timestamp() : Meta::kEmpty;\n    meta->request = pb.request();\n    meta->push = pb.push();\n    meta->simple_app = pb.simple_app();\n    meta->body = pb.body();\n    meta->data_type.resize(pb.data_type_size());\n    for (int i = 0; i < pb.data_type_size(); ++i) {\n      meta->data_type[i] = static_cast<DataType>(pb.data_type(i));\n    }\n    if (pb.has_control()) {\n      const auto& ctrl = pb.control();\n      meta->control.cmd = static_cast<Control::Command>(ctrl.cmd());\n      meta->control.barrier_group = ctrl.barrier_group();\n      meta->control.msg_sig = ctrl.msg_sig();\n      for (int i = 0; i < ctrl.node_size(); ++i) {\n        const auto& p = ctrl.node(i);\n        Node n;\n        n.role = static_cast<Node::Role>(p.role());\n        n.port = p.port();\n        n.hostname = p.hostname();\n        n.id = p.has_id() ? p.id() : Node::kEmpty;\n        n.is_recovery = p.is_recovery();\n        meta->control.node.push_back(n);\n      }\n    } else {\n      meta->control.cmd = Control::EMPTY;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "zmq_msg_close",
          "args": [
            "zmsg"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "zmq_msg_more(zmsg)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_msg_more",
          "args": [
            "zmsg"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetNodeID",
          "args": [
            "buf",
            "size"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "GetNodeID",
          "container": "ZMQVan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
          "lines": "216-230",
          "snippet": "int GetNodeID(const char* buf, size_t size) {\n    if (size > 2 && buf[0] == 'p' && buf[1] == 's') {\n      int id = 0;\n      size_t i = 2;\n      for (; i < size; ++i) {\n        if (buf[i] >= '0' && buf[i] <= '9') {\n          id = id * 10 + buf[i] - '0';\n        } else {\n          break;\n        }\n      }\n      if (i == size) return id;\n    }\n    return Meta::kEmpty;\n  }",
          "includes": [
            "#include \"ps/internal/van.h\"",
            "#include <string>",
            "#include <thread>",
            "#include <stdlib.h>",
            "#include <zmq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ps/internal/van.h\"\n#include <string>\n#include <thread>\n#include <stdlib.h>\n#include <zmq.h>\n\nZMQVan {\n  int GetNodeID(const char* buf, size_t size) {\n      if (size > 2 && buf[0] == 'p' && buf[1] == 's') {\n        int id = 0;\n        size_t i = 2;\n        for (; i < size; ++i) {\n          if (buf[i] >= '0' && buf[i] <= '9') {\n            id = id * 10 + buf[i] - '0';\n          } else {\n            break;\n          }\n        }\n        if (i == size) return id;\n      }\n      return Meta::kEmpty;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "zmq_msg_size",
          "args": [
            "zmsg"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_NOTNULL",
          "args": [
            "(char *)zmq_msg_data(zmsg)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_msg_data",
          "args": [
            "zmsg"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_strerror",
          "args": [
            "errno"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOG",
          "args": [
            "WARNING"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_msg_recv",
          "args": [
            "zmsg",
            "receiver_",
            "0"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_strerror",
          "args": [
            "errno"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "zmq_msg_init(zmsg) == 0"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_msg_init",
          "args": [
            "zmsg"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msg->data.clear",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ps/internal/van.h\"\n#include <string>\n#include <thread>\n#include <stdlib.h>\n#include <zmq.h>\n\nZMQVan {\n  int RecvMsg(Message* msg) override {\n      msg->data.clear();\n      size_t recv_bytes = 0;\n      for (int i = 0; ; ++i) {\n        zmq_msg_t* zmsg = new zmq_msg_t;\n        CHECK(zmq_msg_init(zmsg) == 0) << zmq_strerror(errno);\n        while (true) {\n          if (zmq_msg_recv(zmsg, receiver_, 0) != -1) break;\n          if (errno == EINTR) continue;\n          LOG(WARNING) << \"failed to receive message. errno: \"\n                       << errno << \" \" << zmq_strerror(errno);\n          return -1;\n        }\n        char* buf = CHECK_NOTNULL((char *)zmq_msg_data(zmsg));\n        size_t size = zmq_msg_size(zmsg);\n        recv_bytes += size;\n  \n        if (i == 0) {\n          // identify\n          msg->meta.sender = GetNodeID(buf, size);\n          msg->meta.recver = my_node_.id;\n          CHECK(zmq_msg_more(zmsg));\n          zmq_msg_close(zmsg);\n          delete zmsg;\n        } else if (i == 1) {\n          // task\n          UnpackMeta(buf, size, &(msg->meta));\n          zmq_msg_close(zmsg);\n          bool more = zmq_msg_more(zmsg);\n          delete zmsg;\n          if (!more) break;\n        } else {\n          // zero-copy\n          SArray<char> data;\n          data.reset(buf, size, [zmsg, size](char* buf) {\n              zmq_msg_close(zmsg);\n              delete zmsg;\n            });\n          msg->data.push_back(data);\n          if (!zmq_msg_more(zmsg)) { break; }\n        }\n      }\n      return recv_bytes;\n    }\n}"
  },
  {
    "function_name": "SendMsg",
    "container": "ZMQVan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
    "lines": "115-164",
    "snippet": "int SendMsg(const Message& msg) override {\n    std::lock_guard<std::mutex> lk(mu_);\n    // find the socket\n    int id = msg.meta.recver;\n    CHECK_NE(id, Meta::kEmpty);\n    auto it = senders_.find(id);\n    if (it == senders_.end()) {\n      LOG(WARNING) << \"there is no socket to node \" << id;\n      return -1;\n    }\n    void *socket = it->second;\n\n    // send meta\n    int meta_size; char* meta_buf;\n    PackMeta(msg.meta, &meta_buf, &meta_size);\n    int tag = ZMQ_SNDMORE;\n    int n = msg.data.size();\n    if (n == 0) tag = 0;\n    zmq_msg_t meta_msg;\n    zmq_msg_init_data(&meta_msg, meta_buf, meta_size, FreeData, NULL);\n    while (true) {\n      if (zmq_msg_send(&meta_msg, socket, tag) == meta_size) break;\n      if (errno == EINTR) continue;\n      LOG(WARNING) << \"failed to send message to node [\" << id\n                   << \"] errno: \" << errno << \" \" << zmq_strerror(errno);\n      return -1;\n    }\n    zmq_msg_close(&meta_msg);\n    int send_bytes = meta_size;\n\n    // send data\n    for (int i = 0; i < n; ++i) {\n      zmq_msg_t data_msg;\n      SArray<char>* data = new SArray<char>(msg.data[i]);\n      int data_size = data->size();\n      zmq_msg_init_data(&data_msg, data->data(), data->size(), FreeData, data);\n      if (i == n - 1) tag = 0;\n      while (true) {\n        if (zmq_msg_send(&data_msg, socket, tag) == data_size) break;\n        if (errno == EINTR) continue;\n        LOG(WARNING) << \"failed to send message to node [\" << id\n                     << \"] errno: \" << errno << \" \" << zmq_strerror(errno)\n                     << \". \" << i << \"/\" << n;\n        return -1;\n      }\n      zmq_msg_close(&data_msg);\n      send_bytes += data_size;\n    }\n    return send_bytes;\n  }",
    "includes": [
      "#include \"ps/internal/van.h\"",
      "#include <string>",
      "#include <thread>",
      "#include <stdlib.h>",
      "#include <zmq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zmq_msg_close",
          "args": [
            "&data_msg"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_strerror",
          "args": [
            "errno"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOG",
          "args": [
            "WARNING"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_msg_send",
          "args": [
            "&data_msg",
            "socket",
            "tag"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_msg_init_data",
          "args": [
            "&data_msg",
            "data->data()",
            "data->size()",
            "FreeData",
            "data"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data->size",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data->data",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data->size",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_msg_close",
          "args": [
            "&meta_msg"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_strerror",
          "args": [
            "errno"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOG",
          "args": [
            "WARNING"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_msg_send",
          "args": [
            "&meta_msg",
            "socket",
            "tag"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_msg_init_data",
          "args": [
            "&meta_msg",
            "meta_buf",
            "meta_size",
            "FreeData",
            "NULL"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msg.data.size",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PackMeta",
          "args": [
            "msg.meta",
            "&meta_buf",
            "&meta_size"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "PackMeta",
          "container": "Van",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/van.cc",
          "lines": "335-369",
          "snippet": "void Van::PackMeta(const Meta& meta, char** meta_buf, int* buf_size) {\n  // convert into protobuf\n  PBMeta pb;\n  pb.set_head(meta.head);\n  if (meta.customer_id != Meta::kEmpty) pb.set_customer_id(meta.customer_id);\n  if (meta.timestamp != Meta::kEmpty) pb.set_timestamp(meta.timestamp);\n  if (meta.body.size()) pb.set_body(meta.body);\n  pb.set_push(meta.push);\n  pb.set_request(meta.request);\n  pb.set_simple_app(meta.simple_app);\n  for (auto d : meta.data_type) pb.add_data_type(d);\n  if (!meta.control.empty()) {\n    auto ctrl = pb.mutable_control();\n    ctrl->set_cmd(meta.control.cmd);\n    if (meta.control.cmd == Control::BARRIER) {\n      ctrl->set_barrier_group(meta.control.barrier_group);\n    } else if (meta.control.cmd == Control::ACK) {\n      ctrl->set_msg_sig(meta.control.msg_sig);\n    }\n    for (const auto& n : meta.control.node) {\n      auto p = ctrl->add_node();\n      p->set_id(n.id);\n      p->set_role(n.role);\n      p->set_port(n.port);\n      p->set_hostname(n.hostname);\n      p->set_is_recovery(n.is_recovery);\n    }\n  }\n\n  // to string\n  *buf_size = pb.ByteSize();\n  *meta_buf = new char[*buf_size+1];\n  CHECK(pb.SerializeToArray(*meta_buf, *buf_size))\n      << \"failed to serialize protbuf\";\n}",
          "includes": [
            "#include \"./resender.h\"",
            "#include \"./zmq_van.h\"",
            "#include \"./meta.pb.h\"",
            "#include \"./network_utils.h\"",
            "#include \"ps/internal/customer.h\"",
            "#include \"ps/internal/postoffice.h\"",
            "#include \"ps/sarray.h\"",
            "#include \"ps/base.h\"",
            "#include <chrono>",
            "#include <thread>",
            "#include \"ps/internal/van.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"./resender.h\"\n#include \"./zmq_van.h\"\n#include \"./meta.pb.h\"\n#include \"./network_utils.h\"\n#include \"ps/internal/customer.h\"\n#include \"ps/internal/postoffice.h\"\n#include \"ps/sarray.h\"\n#include \"ps/base.h\"\n#include <chrono>\n#include <thread>\n#include \"ps/internal/van.h\"\n\nVan {\n  void Van::PackMeta(const Meta& meta, char** meta_buf, int* buf_size) {\n    // convert into protobuf\n    PBMeta pb;\n    pb.set_head(meta.head);\n    if (meta.customer_id != Meta::kEmpty) pb.set_customer_id(meta.customer_id);\n    if (meta.timestamp != Meta::kEmpty) pb.set_timestamp(meta.timestamp);\n    if (meta.body.size()) pb.set_body(meta.body);\n    pb.set_push(meta.push);\n    pb.set_request(meta.request);\n    pb.set_simple_app(meta.simple_app);\n    for (auto d : meta.data_type) pb.add_data_type(d);\n    if (!meta.control.empty()) {\n      auto ctrl = pb.mutable_control();\n      ctrl->set_cmd(meta.control.cmd);\n      if (meta.control.cmd == Control::BARRIER) {\n        ctrl->set_barrier_group(meta.control.barrier_group);\n      } else if (meta.control.cmd == Control::ACK) {\n        ctrl->set_msg_sig(meta.control.msg_sig);\n      }\n      for (const auto& n : meta.control.node) {\n        auto p = ctrl->add_node();\n        p->set_id(n.id);\n        p->set_role(n.role);\n        p->set_port(n.port);\n        p->set_hostname(n.hostname);\n        p->set_is_recovery(n.is_recovery);\n      }\n    }\n  \n    // to string\n    *buf_size = pb.ByteSize();\n    *meta_buf = new char[*buf_size+1];\n    CHECK(pb.SerializeToArray(*meta_buf, *buf_size))\n        << \"failed to serialize protbuf\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOG",
          "args": [
            "WARNING"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "senders_.end",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "senders_.find",
          "args": [
            "id"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_NE",
          "args": [
            "id",
            "Meta::kEmpty"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ps/internal/van.h\"\n#include <string>\n#include <thread>\n#include <stdlib.h>\n#include <zmq.h>\n\nZMQVan {\n  int SendMsg(const Message& msg) override {\n      std::lock_guard<std::mutex> lk(mu_);\n      // find the socket\n      int id = msg.meta.recver;\n      CHECK_NE(id, Meta::kEmpty);\n      auto it = senders_.find(id);\n      if (it == senders_.end()) {\n        LOG(WARNING) << \"there is no socket to node \" << id;\n        return -1;\n      }\n      void *socket = it->second;\n  \n      // send meta\n      int meta_size; char* meta_buf;\n      PackMeta(msg.meta, &meta_buf, &meta_size);\n      int tag = ZMQ_SNDMORE;\n      int n = msg.data.size();\n      if (n == 0) tag = 0;\n      zmq_msg_t meta_msg;\n      zmq_msg_init_data(&meta_msg, meta_buf, meta_size, FreeData, NULL);\n      while (true) {\n        if (zmq_msg_send(&meta_msg, socket, tag) == meta_size) break;\n        if (errno == EINTR) continue;\n        LOG(WARNING) << \"failed to send message to node [\" << id\n                     << \"] errno: \" << errno << \" \" << zmq_strerror(errno);\n        return -1;\n      }\n      zmq_msg_close(&meta_msg);\n      int send_bytes = meta_size;\n  \n      // send data\n      for (int i = 0; i < n; ++i) {\n        zmq_msg_t data_msg;\n        SArray<char>* data = new SArray<char>(msg.data[i]);\n        int data_size = data->size();\n        zmq_msg_init_data(&data_msg, data->data(), data->size(), FreeData, data);\n        if (i == n - 1) tag = 0;\n        while (true) {\n          if (zmq_msg_send(&data_msg, socket, tag) == data_size) break;\n          if (errno == EINTR) continue;\n          LOG(WARNING) << \"failed to send message to node [\" << id\n                       << \"] errno: \" << errno << \" \" << zmq_strerror(errno)\n                       << \". \" << i << \"/\" << n;\n          return -1;\n        }\n        zmq_msg_close(&data_msg);\n        send_bytes += data_size;\n      }\n      return send_bytes;\n    }\n}"
  },
  {
    "function_name": "Connect",
    "container": "ZMQVan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
    "lines": "81-113",
    "snippet": "void Connect(const Node& node) override {\n    CHECK_NE(node.id, node.kEmpty);\n    CHECK_NE(node.port, node.kEmpty);\n    CHECK(node.hostname.size());\n    int id = node.id;\n    auto it = senders_.find(id);\n    if (it != senders_.end()) {\n      zmq_close(it->second);\n    }\n    // worker doesn't need to connect to the other workers. same for server\n    if ((node.role == my_node_.role) &&\n        (node.id != my_node_.id)) {\n      return;\n    }\n    void *sender = zmq_socket(context_, ZMQ_DEALER);\n    CHECK(sender != NULL)\n        << zmq_strerror(errno)\n        << \". it often can be solved by \\\"sudo ulimit -n 65536\\\"\"\n        << \" or edit /etc/security/limits.conf\";\n    if (my_node_.id != Node::kEmpty) {\n      std::string my_id = \"ps\" + std::to_string(my_node_.id);\n      zmq_setsockopt(sender, ZMQ_IDENTITY, my_id.data(), my_id.size());\n    }\n    // connect\n    std::string addr = \"tcp://\" + node.hostname + \":\" + std::to_string(node.port);\n    if (GetEnv(\"DMLC_LOCAL\", 0)) {\n      addr = \"ipc:///tmp/\" + std::to_string(node.port);\n    }\n    if (zmq_connect(sender, addr.c_str()) != 0) {\n      LOG(FATAL) <<  \"connect to \" + addr + \" failed: \" + zmq_strerror(errno);\n    }\n    senders_[id] = sender;\n  }",
    "includes": [
      "#include \"ps/internal/van.h\"",
      "#include <string>",
      "#include <thread>",
      "#include <stdlib.h>",
      "#include <zmq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zmq_strerror",
          "args": [
            "errno"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOG",
          "args": [
            "FATAL"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_connect",
          "args": [
            "sender",
            "addr.c_str()"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr.c_str",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::to_string",
          "args": [
            "node.port"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetEnv",
          "args": [
            "\"DMLC_LOCAL\"",
            "0"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::to_string",
          "args": [
            "node.port"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_setsockopt",
          "args": [
            "sender",
            "ZMQ_IDENTITY",
            "my_id.data()",
            "my_id.size()"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_id.size",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_id.data",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::to_string",
          "args": [
            "my_node_.id"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_strerror",
          "args": [
            "errno"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "sender != NULL"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_socket",
          "args": [
            "context_",
            "ZMQ_DEALER"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_close",
          "args": [
            "it->second"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "senders_.end",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "senders_.find",
          "args": [
            "id"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "node.hostname.size()"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.hostname.size",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_NE",
          "args": [
            "node.port",
            "node.kEmpty"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_NE",
          "args": [
            "node.id",
            "node.kEmpty"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ps/internal/van.h\"\n#include <string>\n#include <thread>\n#include <stdlib.h>\n#include <zmq.h>\n\nZMQVan {\n  void Connect(const Node& node) override {\n      CHECK_NE(node.id, node.kEmpty);\n      CHECK_NE(node.port, node.kEmpty);\n      CHECK(node.hostname.size());\n      int id = node.id;\n      auto it = senders_.find(id);\n      if (it != senders_.end()) {\n        zmq_close(it->second);\n      }\n      // worker doesn't need to connect to the other workers. same for server\n      if ((node.role == my_node_.role) &&\n          (node.id != my_node_.id)) {\n        return;\n      }\n      void *sender = zmq_socket(context_, ZMQ_DEALER);\n      CHECK(sender != NULL)\n          << zmq_strerror(errno)\n          << \". it often can be solved by \\\"sudo ulimit -n 65536\\\"\"\n          << \" or edit /etc/security/limits.conf\";\n      if (my_node_.id != Node::kEmpty) {\n        std::string my_id = \"ps\" + std::to_string(my_node_.id);\n        zmq_setsockopt(sender, ZMQ_IDENTITY, my_id.data(), my_id.size());\n      }\n      // connect\n      std::string addr = \"tcp://\" + node.hostname + \":\" + std::to_string(node.port);\n      if (GetEnv(\"DMLC_LOCAL\", 0)) {\n        addr = \"ipc:///tmp/\" + std::to_string(node.port);\n      }\n      if (zmq_connect(sender, addr.c_str()) != 0) {\n        LOG(FATAL) <<  \"connect to \" + addr + \" failed: \" + zmq_strerror(errno);\n      }\n      senders_[id] = sender;\n    }\n}"
  },
  {
    "function_name": "Bind",
    "container": "ZMQVan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
    "lines": "61-79",
    "snippet": "int Bind(const Node& node, int max_retry) override {\n    receiver_ = zmq_socket(context_, ZMQ_ROUTER);\n    CHECK(receiver_ != NULL)\n        << \"create receiver socket failed: \" << zmq_strerror(errno);\n    int local = GetEnv(\"DMLC_LOCAL\", 0);\n    std::string addr = local ? \"ipc:///tmp/\" : \"tcp://*:\";\n    int port = node.port;\n    unsigned seed = static_cast<unsigned>(time(NULL)+port);\n    for (int i = 0; i < max_retry+1; ++i) {\n      auto address = addr + std::to_string(port);\n      if (zmq_bind(receiver_, address.c_str()) == 0) break;\n      if (i == max_retry) {\n        port = -1;\n      } else {\n        port = 10000 + rand_r(&seed) % 40000;\n      }\n    }\n    return port;\n  }",
    "includes": [
      "#include \"ps/internal/van.h\"",
      "#include <string>",
      "#include <thread>",
      "#include <stdlib.h>",
      "#include <zmq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rand_r",
          "args": [
            "&seed"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_bind",
          "args": [
            "receiver_",
            "address.c_str()"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "address.c_str",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::to_string",
          "args": [
            "port"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<unsigned>",
          "args": [
            "time(NULL)+port"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetEnv",
          "args": [
            "\"DMLC_LOCAL\"",
            "0"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_strerror",
          "args": [
            "errno"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "receiver_ != NULL"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_socket",
          "args": [
            "context_",
            "ZMQ_ROUTER"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ps/internal/van.h\"\n#include <string>\n#include <thread>\n#include <stdlib.h>\n#include <zmq.h>\n\nZMQVan {\n  int Bind(const Node& node, int max_retry) override {\n      receiver_ = zmq_socket(context_, ZMQ_ROUTER);\n      CHECK(receiver_ != NULL)\n          << \"create receiver socket failed: \" << zmq_strerror(errno);\n      int local = GetEnv(\"DMLC_LOCAL\", 0);\n      std::string addr = local ? \"ipc:///tmp/\" : \"tcp://*:\";\n      int port = node.port;\n      unsigned seed = static_cast<unsigned>(time(NULL)+port);\n      for (int i = 0; i < max_retry+1; ++i) {\n        auto address = addr + std::to_string(port);\n        if (zmq_bind(receiver_, address.c_str()) == 0) break;\n        if (i == max_retry) {\n          port = -1;\n        } else {\n          port = 10000 + rand_r(&seed) % 40000;\n        }\n      }\n      return port;\n    }\n}"
  },
  {
    "function_name": "Stop",
    "container": "ZMQVan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
    "lines": "45-59",
    "snippet": "void Stop() override {\n    PS_VLOG(1) << my_node_.ShortDebugString() << \" is stopping\";\n    Van::Stop();\n    // close sockets\n    int linger = 0;\n    int rc = zmq_setsockopt(receiver_, ZMQ_LINGER, &linger, sizeof(linger));\n    CHECK(rc == 0 || errno == ETERM);\n    CHECK_EQ(zmq_close(receiver_), 0);\n    for (auto& it : senders_) {\n      int rc = zmq_setsockopt(it.second, ZMQ_LINGER, &linger, sizeof(linger));\n      CHECK(rc == 0 || errno == ETERM);\n      CHECK_EQ(zmq_close(it.second), 0);\n    }\n    zmq_ctx_destroy(context_);\n  }",
    "includes": [
      "#include \"ps/internal/van.h\"",
      "#include <string>",
      "#include <thread>",
      "#include <stdlib.h>",
      "#include <zmq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zmq_ctx_destroy",
          "args": [
            "context_"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_EQ",
          "args": [
            "zmq_close(it.second)",
            "0"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_close",
          "args": [
            "it.second"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "rc == 0 || errno == ETERM"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_setsockopt",
          "args": [
            "it.second",
            "ZMQ_LINGER",
            "&linger",
            "sizeof(linger)"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_EQ",
          "args": [
            "zmq_close(receiver_)",
            "0"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_close",
          "args": [
            "receiver_"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "rc == 0 || errno == ETERM"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_setsockopt",
          "args": [
            "receiver_",
            "ZMQ_LINGER",
            "&linger",
            "sizeof(linger)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Van::Stop",
          "args": [],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "Stop",
          "container": "ZMQVan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
          "lines": "45-59",
          "snippet": "void Stop() override {\n    PS_VLOG(1) << my_node_.ShortDebugString() << \" is stopping\";\n    Van::Stop();\n    // close sockets\n    int linger = 0;\n    int rc = zmq_setsockopt(receiver_, ZMQ_LINGER, &linger, sizeof(linger));\n    CHECK(rc == 0 || errno == ETERM);\n    CHECK_EQ(zmq_close(receiver_), 0);\n    for (auto& it : senders_) {\n      int rc = zmq_setsockopt(it.second, ZMQ_LINGER, &linger, sizeof(linger));\n      CHECK(rc == 0 || errno == ETERM);\n      CHECK_EQ(zmq_close(it.second), 0);\n    }\n    zmq_ctx_destroy(context_);\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "my_node_.ShortDebugString",
          "args": [],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PS_VLOG",
          "args": [
            "1"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ps/internal/van.h\"\n#include <string>\n#include <thread>\n#include <stdlib.h>\n#include <zmq.h>\n\nZMQVan {\n  void Stop() override {\n      PS_VLOG(1) << my_node_.ShortDebugString() << \" is stopping\";\n      Van::Stop();\n      // close sockets\n      int linger = 0;\n      int rc = zmq_setsockopt(receiver_, ZMQ_LINGER, &linger, sizeof(linger));\n      CHECK(rc == 0 || errno == ETERM);\n      CHECK_EQ(zmq_close(receiver_), 0);\n      for (auto& it : senders_) {\n        int rc = zmq_setsockopt(it.second, ZMQ_LINGER, &linger, sizeof(linger));\n        CHECK(rc == 0 || errno == ETERM);\n        CHECK_EQ(zmq_close(it.second), 0);\n      }\n      zmq_ctx_destroy(context_);\n    }\n}"
  },
  {
    "function_name": "Start",
    "container": "ZMQVan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
    "lines": "36-43",
    "snippet": "void Start() override {\n    // start zmq\n    context_ = zmq_ctx_new();\n    CHECK(context_ != NULL) << \"create 0mq context failed\";\n    zmq_ctx_set(context_, ZMQ_MAX_SOCKETS, 65536);\n    // zmq_ctx_set(context_, ZMQ_IO_THREADS, 4);\n    Van::Start();\n  }",
    "includes": [
      "#include \"ps/internal/van.h\"",
      "#include <string>",
      "#include <thread>",
      "#include <stdlib.h>",
      "#include <zmq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Van::Start",
          "args": [],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "Start",
          "container": "ZMQVan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
          "lines": "36-43",
          "snippet": "void Start() override {\n    // start zmq\n    context_ = zmq_ctx_new();\n    CHECK(context_ != NULL) << \"create 0mq context failed\";\n    zmq_ctx_set(context_, ZMQ_MAX_SOCKETS, 65536);\n    // zmq_ctx_set(context_, ZMQ_IO_THREADS, 4);\n    Van::Start();\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "zmq_ctx_set",
          "args": [
            "context_",
            "ZMQ_MAX_SOCKETS",
            "65536"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "context_ != NULL"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zmq_ctx_new",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ps/internal/van.h\"\n#include <string>\n#include <thread>\n#include <stdlib.h>\n#include <zmq.h>\n\nZMQVan {\n  void Start() override {\n      // start zmq\n      context_ = zmq_ctx_new();\n      CHECK(context_ != NULL) << \"create 0mq context failed\";\n      zmq_ctx_set(context_, ZMQ_MAX_SOCKETS, 65536);\n      // zmq_ctx_set(context_, ZMQ_IO_THREADS, 4);\n      Van::Start();\n    }\n}"
  },
  {
    "function_name": "ZMQVan",
    "container": "ZMQVan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
    "lines": "32-32",
    "snippet": "ZMQVan() { }",
    "includes": [
      "#include \"ps/internal/van.h\"",
      "#include <string>",
      "#include <thread>",
      "#include <stdlib.h>",
      "#include <zmq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ps/internal/van.h\"\n#include <string>\n#include <thread>\n#include <stdlib.h>\n#include <zmq.h>\n\nZMQVan {\n  ZMQVan() { }\n}"
  },
  {
    "function_name": "FreeData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2018-1281/repo/src/zmq_van.h",
    "lines": "19-25",
    "snippet": "inline void FreeData(void *data, void *hint) {\n  if (hint == NULL) {\n    delete [] static_cast<char*>(data);\n  } else {\n    delete static_cast<SArray<char>*>(hint);\n  }\n}",
    "includes": [
      "#include \"ps/internal/van.h\"",
      "#include <string>",
      "#include <thread>",
      "#include <stdlib.h>",
      "#include <zmq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<SArray<char>*>",
          "args": [
            "hint"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<char*>",
          "args": [
            "data"
          ],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ps/internal/van.h\"\n#include <string>\n#include <thread>\n#include <stdlib.h>\n#include <zmq.h>\n\ninline void FreeData(void *data, void *hint) {\n  if (hint == NULL) {\n    delete [] static_cast<char*>(data);\n  } else {\n    delete static_cast<SArray<char>*>(hint);\n  }\n}"
  }
]