[
  {
    "function_name": "dbusWaitForFinish",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
    "lines": "434-440",
    "snippet": "void Benchmark::dbusWaitForFinish(QDBusPendingCall pcall)\n{\n    QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(pcall, this);\n    QEventLoop loop;\n    connect(watcher, &QDBusPendingCallWatcher::finished, [&] (QDBusPendingCallWatcher *watcher) { loop.exit(); });\n    loop.exec();\n}",
    "includes": [
      "#include \"helper_interface.h\"",
      "#include \"global.h\"",
      "#include \"benchmark.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "loop.exec",
          "args": [],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "watcher",
            "&QDBusPendingCallWatcher::finished",
            "[&] (QDBusPendingCallWatcher *watcher) { loop.exit(); }"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loop.exit",
          "args": [],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  void Benchmark::dbusWaitForFinish(QDBusPendingCall pcall)\n  {\n      QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(pcall, this);\n      QEventLoop loop;\n      connect(watcher, &QDBusPendingCallWatcher::finished, [&] (QDBusPendingCallWatcher *watcher) { loop.exit(); });\n      loop.exec();\n  }\n}"
  },
  {
    "function_name": "prepareFile",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
    "lines": "398-432",
    "snippet": "bool Benchmark::prepareFile(const QString &benchmarkFile, int fileSize)\n{\n    bool prepared = true;\n\n    auto interface = helperInterface();\n    if (!interface) return false;\n\n    QDBusPendingCall pcall = interface->prepareBenchmarkFile(benchmarkFile, fileSize, AppSettings().getBenchmarkTestData() == Global::BenchmarkTestData::Zeros);\n\n    QEventLoop loop;\n\n    auto exitLoop = [&] (bool success, QString output, QString errorOutput) {\n        loop.exit();\n\n        if (!success) {\n            prepared = false;\n            if (!errorOutput.isEmpty()) {\n                setRunning(false);\n                emit failed(errorOutput);\n            }\n        }\n\n        if (m_running) {\n            parseResult(output, errorOutput);\n        }\n    };\n\n    auto conn = QObject::connect(interface, &DevJonmagonKdiskmarkHelperInterface::taskFinished, exitLoop);\n\n    loop.exec();\n\n    QObject::disconnect(conn);\n\n    return prepared && !pcall.isError();\n}",
    "includes": [
      "#include \"helper_interface.h\"",
      "#include \"global.h\"",
      "#include \"benchmark.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcall.isError",
          "args": [],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QObject::disconnect",
          "args": [
            "conn"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loop.exec",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QObject::connect",
          "args": [
            "interface",
            "&DevJonmagonKdiskmarkHelperInterface::taskFinished",
            "exitLoop"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseResult",
          "args": [
            "output",
            "errorOutput"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "parseResult",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
          "lines": "149-190",
          "snippet": "Benchmark::ParsedJob Benchmark::parseResult(const QString &output, const QString &errorOutput)\n{\n    QJsonDocument jsonResponse = QJsonDocument::fromJson(output.toUtf8());\n    QJsonObject jsonObject = jsonResponse.object();\n    QJsonArray jobs = jsonObject[\"jobs\"].toArray();\n\n    ParsedJob parsedJob {{0, 0, 0}, {0, 0, 0}};\n\n    int jobsCount = jobs.count();\n\n    if (jobsCount == 0 && !errorOutput.isEmpty()) {\n        setRunning(false);\n        emit failed(errorOutput);\n    }\n    else if (jobsCount == 0) {\n        setRunning(false);\n        emit failed(\"Bad FIO output.\");\n    }\n    else {\n        for (int i = 0; i < jobsCount; i++) {\n            QJsonObject job = jobs.takeAt(i).toObject();\n\n            if (job[\"error\"].toInt() == 0) {\n                QJsonObject jobRead = job[\"read\"].toObject();\n                parsedJob.read.Bandwidth += jobRead.value(\"bw\").toInt() / 1000.0; // to mb\n                parsedJob.read.IOPS += jobRead.value(\"iops\").toDouble();\n                parsedJob.read.Latency += jobRead[\"lat_ns\"].toObject().value(\"mean\").toDouble() / 1000.0 / jobsCount; // to usec\n\n                QJsonObject jobWrite = job[\"write\"].toObject();\n                parsedJob.write.Bandwidth += jobWrite.value(\"bw\").toInt() / 1000.0; // to mb\n                parsedJob.write.IOPS += jobWrite.value(\"iops\").toDouble();\n                parsedJob.write.Latency += jobWrite[\"lat_ns\"].toObject().value(\"mean\").toDouble() / 1000.0 / jobsCount; // to usec\n            }\n            else {\n                setRunning(false);\n                emit failed(errorOutput/*.mid(errorOutput.simplified().lastIndexOf(\"=\") + 1)*/);\n            }\n        }\n    }\n\n    return parsedJob;\n}",
          "includes": [
            "#include \"helper_interface.h\"",
            "#include \"global.h\"",
            "#include \"benchmark.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  Benchmark::ParsedJob Benchmark::parseResult(const QString &output, const QString &errorOutput)\n  {\n      QJsonDocument jsonResponse = QJsonDocument::fromJson(output.toUtf8());\n      QJsonObject jsonObject = jsonResponse.object();\n      QJsonArray jobs = jsonObject[\"jobs\"].toArray();\n  \n      ParsedJob parsedJob {{0, 0, 0}, {0, 0, 0}};\n  \n      int jobsCount = jobs.count();\n  \n      if (jobsCount == 0 && !errorOutput.isEmpty()) {\n          setRunning(false);\n          emit failed(errorOutput);\n      }\n      else if (jobsCount == 0) {\n          setRunning(false);\n          emit failed(\"Bad FIO output.\");\n      }\n      else {\n          for (int i = 0; i < jobsCount; i++) {\n              QJsonObject job = jobs.takeAt(i).toObject();\n  \n              if (job[\"error\"].toInt() == 0) {\n                  QJsonObject jobRead = job[\"read\"].toObject();\n                  parsedJob.read.Bandwidth += jobRead.value(\"bw\").toInt() / 1000.0; // to mb\n                  parsedJob.read.IOPS += jobRead.value(\"iops\").toDouble();\n                  parsedJob.read.Latency += jobRead[\"lat_ns\"].toObject().value(\"mean\").toDouble() / 1000.0 / jobsCount; // to usec\n  \n                  QJsonObject jobWrite = job[\"write\"].toObject();\n                  parsedJob.write.Bandwidth += jobWrite.value(\"bw\").toInt() / 1000.0; // to mb\n                  parsedJob.write.IOPS += jobWrite.value(\"iops\").toDouble();\n                  parsedJob.write.Latency += jobWrite[\"lat_ns\"].toObject().value(\"mean\").toDouble() / 1000.0 / jobsCount; // to usec\n              }\n              else {\n                  setRunning(false);\n                  emit failed(errorOutput/*.mid(errorOutput.simplified().lastIndexOf(\"=\") + 1)*/);\n              }\n          }\n      }\n  \n      return parsedJob;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setRunning",
          "args": [
            "false"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "setRunning",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
          "lines": "192-206",
          "snippet": "void Benchmark::setRunning(bool state)\n{\n    if (m_running == state)\n        return;\n\n    m_running = state;\n\n    if (!m_running) {\n        auto interface = helperInterface();\n        if (interface)\n            dbusWaitForFinish(interface->stopCurrentTask());\n    }\n\n    emit runningStateChanged(state);\n}",
          "includes": [
            "#include \"helper_interface.h\"",
            "#include \"global.h\"",
            "#include \"benchmark.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  void Benchmark::setRunning(bool state)\n  {\n      if (m_running == state)\n          return;\n  \n      m_running = state;\n  \n      if (!m_running) {\n          auto interface = helperInterface();\n          if (interface)\n              dbusWaitForFinish(interface->stopCurrentTask());\n      }\n  \n      emit runningStateChanged(state);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "errorOutput.isEmpty",
          "args": [],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loop.exit",
          "args": [],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interface->prepareBenchmarkFile",
          "args": [
            "benchmarkFile",
            "fileSize",
            "AppSettings().getBenchmarkTestData() == Global::BenchmarkTestData::Zeros"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "prepareBenchmarkFile",
          "container": "Helper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
          "lines": "116-148",
          "snippet": "void Helper::prepareBenchmarkFile(const QString &benchmarkFile, int fileSize, bool fillZeros)\n{\n    if (!isCallerAuthorized()) {\n        return;\n    }\n\n    // If benchmarking has been done, but removeBenchmarkFile has not been called,\n    // and benchmarking on a new file is called, then reject the request. The *previous* file must be removed first.\n    if (!m_benchmarkFile.isEmpty()) {\n        qWarning() << \"The previous benchmarking was not completed correctly.\";\n        return;\n    }\n\n    if (!testFilePath(benchmarkFile)) {\n        return;\n    }\n\n    m_benchmarkFile = benchmarkFile;\n\n    m_process = new QProcess();\n    m_process->start(\"fio\", QStringList()\n                     << QStringLiteral(\"--output-format=json\")\n                     << QStringLiteral(\"--create_only=1\")\n                     << QStringLiteral(\"--filename=%1\").arg(m_benchmarkFile)\n                     << QStringLiteral(\"--size=%1m\").arg(fileSize)\n                     << QStringLiteral(\"--zero_buffers=%1\").arg(fillZeros)\n                     << QStringLiteral(\"--name=prepare\"));\n\n    connect(m_process, static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n            [=] (int exitCode, QProcess::ExitStatus exitStatus) {\n        emit taskFinished(exitStatus == QProcess::NormalExit, QString(m_process->readAllStandardOutput()), QString(m_process->readAllStandardError()));\n    });\n}",
          "includes": [
            "#include <signal.h>",
            "#include <PolkitQt1/Subject>",
            "#include <PolkitQt1/Authority>",
            "#include <QFile>",
            "#include <QtDBus>",
            "#include <QCoreApplication>",
            "#include \"helper.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  void Helper::prepareBenchmarkFile(const QString &benchmarkFile, int fileSize, bool fillZeros)\n  {\n      if (!isCallerAuthorized()) {\n          return;\n      }\n  \n      // If benchmarking has been done, but removeBenchmarkFile has not been called,\n      // and benchmarking on a new file is called, then reject the request. The *previous* file must be removed first.\n      if (!m_benchmarkFile.isEmpty()) {\n          qWarning() << \"The previous benchmarking was not completed correctly.\";\n          return;\n      }\n  \n      if (!testFilePath(benchmarkFile)) {\n          return;\n      }\n  \n      m_benchmarkFile = benchmarkFile;\n  \n      m_process = new QProcess();\n      m_process->start(\"fio\", QStringList()\n                       << QStringLiteral(\"--output-format=json\")\n                       << QStringLiteral(\"--create_only=1\")\n                       << QStringLiteral(\"--filename=%1\").arg(m_benchmarkFile)\n                       << QStringLiteral(\"--size=%1m\").arg(fileSize)\n                       << QStringLiteral(\"--zero_buffers=%1\").arg(fillZeros)\n                       << QStringLiteral(\"--name=prepare\"));\n  \n      connect(m_process, static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n              [=] (int exitCode, QProcess::ExitStatus exitStatus) {\n          emit taskFinished(exitStatus == QProcess::NormalExit, QString(m_process->readAllStandardOutput()), QString(m_process->readAllStandardError()));\n      });\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AppSettings",
          "args": [],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "defaultTheme",
          "container": "AppSettings",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/appsettings.cpp",
          "lines": "244-247",
          "snippet": "Global::Theme AppSettings::defaultTheme()\n{\n    return Global::Theme::UseFusion;\n}",
          "includes": [
            "#include <QMetaEnum>",
            "#include <QSettings>",
            "#include <QLibraryInfo>",
            "#include <QStandardPaths>",
            "#include <QTranslator>",
            "#include <QCoreApplication>",
            "#include \"cmake.h\"",
            "#include \"appsettings.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QMetaEnum>\n#include <QSettings>\n#include <QLibraryInfo>\n#include <QStandardPaths>\n#include <QTranslator>\n#include <QCoreApplication>\n#include \"cmake.h\"\n#include \"appsettings.h\"\n\nAppSettings {\n  Global::Theme AppSettings::defaultTheme()\n  {\n      return Global::Theme::UseFusion;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "helperInterface",
          "args": [],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  bool Benchmark::prepareFile(const QString &benchmarkFile, int fileSize)\n  {\n      bool prepared = true;\n  \n      auto interface = helperInterface();\n      if (!interface) return false;\n  \n      QDBusPendingCall pcall = interface->prepareBenchmarkFile(benchmarkFile, fileSize, AppSettings().getBenchmarkTestData() == Global::BenchmarkTestData::Zeros);\n  \n      QEventLoop loop;\n  \n      auto exitLoop = [&] (bool success, QString output, QString errorOutput) {\n          loop.exit();\n  \n          if (!success) {\n              prepared = false;\n              if (!errorOutput.isEmpty()) {\n                  setRunning(false);\n                  emit failed(errorOutput);\n              }\n          }\n  \n          if (m_running) {\n              parseResult(output, errorOutput);\n          }\n      };\n  \n      auto conn = QObject::connect(interface, &DevJonmagonKdiskmarkHelperInterface::taskFinished, exitLoop);\n  \n      loop.exec();\n  \n      QObject::disconnect(conn);\n  \n      return prepared && !pcall.isError();\n  }\n}"
  },
  {
    "function_name": "flushPageCache",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
    "lines": "360-396",
    "snippet": "bool Benchmark::flushPageCache()\n{\n    bool flushed = true;\n\n    auto interface = helperInterface();\n    if (!interface) return false;\n\n    QDBusPendingCall pcall = interface->flushPageCache();\n\n    QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(pcall, this);\n    QEventLoop loop;\n\n    auto exitLoop = [&] (QDBusPendingCallWatcher *watcher) {\n        loop.exit();\n\n        if (watcher->isError())\n            qWarning() << watcher->error();\n        else {\n            QDBusPendingReply<QVariantMap> reply = *watcher;\n\n            QVariantMap replyContent = reply.value();\n            if (!replyContent[QStringLiteral(\"success\")].toBool()) {\n                flushed = false;\n                QString error = replyContent[QStringLiteral(\"error\")].toString();\n                if (!error.isEmpty()) {\n                    setRunning(false);\n                    emit failed(error);\n                }\n            }\n        }\n    };\n\n    connect(watcher, &QDBusPendingCallWatcher::finished, exitLoop);\n    loop.exec();\n\n    return flushed && !watcher->isError();;\n}",
    "includes": [
      "#include \"helper_interface.h\"",
      "#include \"global.h\"",
      "#include \"benchmark.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "watcher->isError",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loop.exec",
          "args": [],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "watcher",
            "&QDBusPendingCallWatcher::finished",
            "exitLoop"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setRunning",
          "args": [
            "false"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "setRunning",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
          "lines": "192-206",
          "snippet": "void Benchmark::setRunning(bool state)\n{\n    if (m_running == state)\n        return;\n\n    m_running = state;\n\n    if (!m_running) {\n        auto interface = helperInterface();\n        if (interface)\n            dbusWaitForFinish(interface->stopCurrentTask());\n    }\n\n    emit runningStateChanged(state);\n}",
          "includes": [
            "#include \"helper_interface.h\"",
            "#include \"global.h\"",
            "#include \"benchmark.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  void Benchmark::setRunning(bool state)\n  {\n      if (m_running == state)\n          return;\n  \n      m_running = state;\n  \n      if (!m_running) {\n          auto interface = helperInterface();\n          if (interface)\n              dbusWaitForFinish(interface->stopCurrentTask());\n      }\n  \n      emit runningStateChanged(state);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error.isEmpty",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replyContent[QStringLiteral",
          "args": [],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"error\""
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replyContent[QStringLiteral",
          "args": [],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"success\""
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reply.value",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watcher->error",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qWarning",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watcher->isError",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loop.exit",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interface->flushPageCache",
          "args": [],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "flushPageCache",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
          "lines": "360-396",
          "snippet": "bool Benchmark::flushPageCache()\n{\n    bool flushed = true;\n\n    auto interface = helperInterface();\n    if (!interface) return false;\n\n    QDBusPendingCall pcall = interface->flushPageCache();\n\n    QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(pcall, this);\n    QEventLoop loop;\n\n    auto exitLoop = [&] (QDBusPendingCallWatcher *watcher) {\n        loop.exit();\n\n        if (watcher->isError())\n            qWarning() << watcher->error();\n        else {\n            QDBusPendingReply<QVariantMap> reply = *watcher;\n\n            QVariantMap replyContent = reply.value();\n            if (!replyContent[QStringLiteral(\"success\")].toBool()) {\n                flushed = false;\n                QString error = replyContent[QStringLiteral(\"error\")].toString();\n                if (!error.isEmpty()) {\n                    setRunning(false);\n                    emit failed(error);\n                }\n            }\n        }\n    };\n\n    connect(watcher, &QDBusPendingCallWatcher::finished, exitLoop);\n    loop.exec();\n\n    return flushed && !watcher->isError();;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "helperInterface",
          "args": [],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  bool Benchmark::flushPageCache()\n  {\n      bool flushed = true;\n  \n      auto interface = helperInterface();\n      if (!interface) return false;\n  \n      QDBusPendingCall pcall = interface->flushPageCache();\n  \n      QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(pcall, this);\n      QEventLoop loop;\n  \n      auto exitLoop = [&] (QDBusPendingCallWatcher *watcher) {\n          loop.exit();\n  \n          if (watcher->isError())\n              qWarning() << watcher->error();\n          else {\n              QDBusPendingReply<QVariantMap> reply = *watcher;\n  \n              QVariantMap replyContent = reply.value();\n              if (!replyContent[QStringLiteral(\"success\")].toBool()) {\n                  flushed = false;\n                  QString error = replyContent[QStringLiteral(\"error\")].toString();\n                  if (!error.isEmpty()) {\n                      setRunning(false);\n                      emit failed(error);\n                  }\n              }\n          }\n      };\n  \n      connect(watcher, &QDBusPendingCallWatcher::finished, exitLoop);\n      loop.exec();\n  \n      return flushed && !watcher->isError();;\n  }\n}"
  },
  {
    "function_name": "listStorages",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
    "lines": "321-358",
    "snippet": "bool Benchmark::listStorages()\n{\n    auto interface = helperInterface();\n    if (!interface) return false;\n\n    QDBusPendingCall pcall = interface->listStorages();\n\n    QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(pcall, this);\n    QEventLoop loop;\n\n    auto exitLoop = [&] (QDBusPendingCallWatcher *watcher) {\n        loop.exit();\n\n        if (watcher->isError())\n            qWarning() << watcher->error();\n        else {\n            QDBusPendingReply<QVariantMap> reply = *watcher;\n\n            QVariantMap replyContent = reply.value();\n\n            QVector<Global::Storage> storages;\n\n            for (auto pathStorage : replyContent.keys()) {\n                QDBusVariant dbusVariant = qvariant_cast<QDBusVariant>(replyContent.value(pathStorage));\n                QVector<qlonglong> storageStats;\n                dbusVariant.variant().value<QDBusArgument>() >> storageStats;\n                storages.append({ pathStorage, storageStats[0], storageStats[0] - storageStats[1] });\n            }\n\n            emit mountPointsListReady(storages);\n        }\n    };\n\n    connect(watcher, &QDBusPendingCallWatcher::finished, exitLoop);\n    loop.exec();\n\n    return !watcher->isError();\n}",
    "includes": [
      "#include \"helper_interface.h\"",
      "#include \"global.h\"",
      "#include \"benchmark.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "watcher->isError",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loop.exec",
          "args": [],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "watcher",
            "&QDBusPendingCallWatcher::finished",
            "exitLoop"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storages.append",
          "args": [
            "{ pathStorage, storageStats[0], storageStats[0] - storageStats[1] }"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbusVariant.variant",
          "args": [],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbusVariant.variant",
          "args": [],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qvariant_cast<QDBusVariant>",
          "args": [
            "replyContent.value(pathStorage)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replyContent.value",
          "args": [
            "pathStorage"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replyContent.keys",
          "args": [],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reply.value",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watcher->error",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qWarning",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watcher->isError",
          "args": [],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loop.exit",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interface->listStorages",
          "args": [],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "listStorages",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
          "lines": "321-358",
          "snippet": "bool Benchmark::listStorages()\n{\n    auto interface = helperInterface();\n    if (!interface) return false;\n\n    QDBusPendingCall pcall = interface->listStorages();\n\n    QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(pcall, this);\n    QEventLoop loop;\n\n    auto exitLoop = [&] (QDBusPendingCallWatcher *watcher) {\n        loop.exit();\n\n        if (watcher->isError())\n            qWarning() << watcher->error();\n        else {\n            QDBusPendingReply<QVariantMap> reply = *watcher;\n\n            QVariantMap replyContent = reply.value();\n\n            QVector<Global::Storage> storages;\n\n            for (auto pathStorage : replyContent.keys()) {\n                QDBusVariant dbusVariant = qvariant_cast<QDBusVariant>(replyContent.value(pathStorage));\n                QVector<qlonglong> storageStats;\n                dbusVariant.variant().value<QDBusArgument>() >> storageStats;\n                storages.append({ pathStorage, storageStats[0], storageStats[0] - storageStats[1] });\n            }\n\n            emit mountPointsListReady(storages);\n        }\n    };\n\n    connect(watcher, &QDBusPendingCallWatcher::finished, exitLoop);\n    loop.exec();\n\n    return !watcher->isError();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "helperInterface",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  bool Benchmark::listStorages()\n  {\n      auto interface = helperInterface();\n      if (!interface) return false;\n  \n      QDBusPendingCall pcall = interface->listStorages();\n  \n      QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(pcall, this);\n      QEventLoop loop;\n  \n      auto exitLoop = [&] (QDBusPendingCallWatcher *watcher) {\n          loop.exit();\n  \n          if (watcher->isError())\n              qWarning() << watcher->error();\n          else {\n              QDBusPendingReply<QVariantMap> reply = *watcher;\n  \n              QVariantMap replyContent = reply.value();\n  \n              QVector<Global::Storage> storages;\n  \n              for (auto pathStorage : replyContent.keys()) {\n                  QDBusVariant dbusVariant = qvariant_cast<QDBusVariant>(replyContent.value(pathStorage));\n                  QVector<qlonglong> storageStats;\n                  dbusVariant.variant().value<QDBusArgument>() >> storageStats;\n                  storages.append({ pathStorage, storageStats[0], storageStats[0] - storageStats[1] });\n              }\n  \n              emit mountPointsListReady(storages);\n          }\n      };\n  \n      connect(watcher, &QDBusPendingCallWatcher::finished, exitLoop);\n      loop.exec();\n  \n      return !watcher->isError();\n  }\n}"
  },
  {
    "function_name": "runBenchmark",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
    "lines": "213-305",
    "snippet": "void Benchmark::runBenchmark(QList<QPair<QPair<Global::BenchmarkTest, Global::BenchmarkIOReadWrite>, QVector<QProgressBar*>>> tests)\n{\n    setRunning(true);\n\n    const AppSettings settings;\n\n    QPair<QPair<Global::BenchmarkTest, Global::BenchmarkIOReadWrite>, QVector<QProgressBar*>> item;\n\n    QMutableListIterator<QPair<QPair<Global::BenchmarkTest, Global::BenchmarkIOReadWrite>, QVector<QProgressBar*>>> iter(tests);\n    // Set to 0 all the progressbars for current tests\n    while (iter.hasNext()) {\n        item = iter.next();\n        if (item.first.second == Global::BenchmarkIOReadWrite::Read && settings.getBenchmarkMode() == Global::BenchmarkMode::WriteMix) { iter.remove(); continue; }\n        if (item.first.second == Global::BenchmarkIOReadWrite::Write && settings.getBenchmarkMode() == Global::BenchmarkMode::ReadMix) { iter.remove(); continue; }\n        auto progressBars = item.second;\n        for (auto obj : progressBars) {\n            emit resultReady(obj, PerformanceResult());\n        }\n    }\n\n    iter.toFront();\n\n    // If there are no tests in the queue\n    if (!iter.hasNext()) {\n        setRunning(false);\n        return;\n    }\n\n    emit benchmarkStatusUpdate(tr(\"Preparing...\"));\n\n    if (!prepareFile(getBenchmarkFile(), settings.getFileSize())) {\n        setRunning(false);\n        return;\n    }\n\n    while (iter.hasNext() && m_running) {\n        item = iter.next();\n\n        m_progressBars = item.second;\n\n        Global::BenchmarkParams params = settings.getBenchmarkParams(item.first.first, settings.getPerformanceProfile());\n\n        switch (item.first.second)\n        {\n        case Global::BenchmarkIOReadWrite::Read:\n            if (params.Pattern == Global::BenchmarkIOPattern::SEQ) {\n                startTest(params.BlockSize, params.Queues, params.Threads,\n                          Global::getRWSequentialRead(), tr(\"Sequential Read %1/%2\"));\n            }\n            else {\n                startTest(params.BlockSize, params.Queues, params.Threads,\n                          Global::getRWRandomRead(), tr(\"Random Read %1/%2\"));\n            }\n            break;\n        case Global::BenchmarkIOReadWrite::Write:\n            if (params.Pattern == Global::BenchmarkIOPattern::SEQ) {\n                startTest(params.BlockSize, params.Queues, params.Threads,\n                          Global::getRWSequentialWrite(), tr(\"Sequential Write %1/%2\"));\n            }\n            else {\n                startTest(params.BlockSize, params.Queues, params.Threads,\n                          Global::getRWRandomWrite(), tr(\"Random Write %1/%2\"));\n            }\n            break;\n        case Global::BenchmarkIOReadWrite::Mix:\n            if (params.Pattern == Global::BenchmarkIOPattern::SEQ) {\n                startTest(params.BlockSize, params.Queues, params.Threads,\n                          Global::getRWSequentialMix(), tr(\"Sequential Mix %1/%2\"));\n            }\n            else {\n                startTest(params.BlockSize, params.Queues, params.Threads,\n                          Global::getRWRandomMix(), tr(\"Random Mix %1/%2\"));\n            }\n            break;\n        }\n\n        if (iter.hasNext()) {\n            for (int i = 0, intervalTime = settings.getIntervalTime(); i < intervalTime && m_running; i++) {\n                emit benchmarkStatusUpdate(tr(\"Interval Time %1/%2 sec\").arg(i).arg(intervalTime));\n                QEventLoop loop;\n                QTimer::singleShot(1000, &loop, SLOT(quit()));\n                loop.exec();\n            }\n        }\n    }\n\n    auto interface = helperInterface();\n    if (interface)\n        dbusWaitForFinish(interface->removeBenchmarkFile());\n\n    setRunning(false);\n    emit finished(); // Only needed when closing the app during a running benchmarking\n}",
    "includes": [
      "#include \"helper_interface.h\"",
      "#include \"global.h\"",
      "#include \"benchmark.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setRunning",
          "args": [
            "false"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "setRunning",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
          "lines": "192-206",
          "snippet": "void Benchmark::setRunning(bool state)\n{\n    if (m_running == state)\n        return;\n\n    m_running = state;\n\n    if (!m_running) {\n        auto interface = helperInterface();\n        if (interface)\n            dbusWaitForFinish(interface->stopCurrentTask());\n    }\n\n    emit runningStateChanged(state);\n}",
          "includes": [
            "#include \"helper_interface.h\"",
            "#include \"global.h\"",
            "#include \"benchmark.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  void Benchmark::setRunning(bool state)\n  {\n      if (m_running == state)\n          return;\n  \n      m_running = state;\n  \n      if (!m_running) {\n          auto interface = helperInterface();\n          if (interface)\n              dbusWaitForFinish(interface->stopCurrentTask());\n      }\n  \n      emit runningStateChanged(state);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbusWaitForFinish",
          "args": [
            "interface->removeBenchmarkFile()"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "dbusWaitForFinish",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
          "lines": "434-440",
          "snippet": "void Benchmark::dbusWaitForFinish(QDBusPendingCall pcall)\n{\n    QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(pcall, this);\n    QEventLoop loop;\n    connect(watcher, &QDBusPendingCallWatcher::finished, [&] (QDBusPendingCallWatcher *watcher) { loop.exit(); });\n    loop.exec();\n}",
          "includes": [
            "#include \"helper_interface.h\"",
            "#include \"global.h\"",
            "#include \"benchmark.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  void Benchmark::dbusWaitForFinish(QDBusPendingCall pcall)\n  {\n      QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(pcall, this);\n      QEventLoop loop;\n      connect(watcher, &QDBusPendingCallWatcher::finished, [&] (QDBusPendingCallWatcher *watcher) { loop.exit(); });\n      loop.exec();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "interface->removeBenchmarkFile",
          "args": [],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "removeBenchmarkFile",
          "container": "Helper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
          "lines": "215-229",
          "snippet": "bool Helper::removeBenchmarkFile()\n{\n    if (!isCallerAuthorized()) {\n        return false;\n    }\n\n    if (m_benchmarkFile.isEmpty()) {\n        return false;\n    }\n\n    bool deletionState = QFile(m_benchmarkFile).remove();\n    m_benchmarkFile.clear();\n\n    return deletionState;\n}",
          "includes": [
            "#include <signal.h>",
            "#include <PolkitQt1/Subject>",
            "#include <PolkitQt1/Authority>",
            "#include <QFile>",
            "#include <QtDBus>",
            "#include <QCoreApplication>",
            "#include \"helper.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  bool Helper::removeBenchmarkFile()\n  {\n      if (!isCallerAuthorized()) {\n          return false;\n      }\n  \n      if (m_benchmarkFile.isEmpty()) {\n          return false;\n      }\n  \n      bool deletionState = QFile(m_benchmarkFile).remove();\n      m_benchmarkFile.clear();\n  \n      return deletionState;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "helperInterface",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loop.exec",
          "args": [],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QTimer::singleShot",
          "args": [
            "1000",
            "&loop",
            "SLOT(quit())"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLOT",
          "args": [
            "quit()"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quit",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr",
          "args": [
            "intervalTime"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "on_actionFlush_Pagecache_triggered",
          "container": "MainWindow",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/mainwindow.cpp",
          "lines": "391-394",
          "snippet": "void MainWindow::on_actionFlush_Pagecache_triggered(bool checked)\n{\n    AppSettings().setFlushingCacheState(checked);\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"storageitemdelegate.h\"",
            "#include \"diskdriveinfo.h\"",
            "#include \"settings.h\"",
            "#include \"about.h\"",
            "#include \"math.h\"",
            "#include <QTimer>",
            "#include <QStyleFactory>",
            "#include <QAbstractItemView>",
            "#include <QTextStream>",
            "#include <QFileDialog>",
            "#include <QDate>",
            "#include <QClipboard>",
            "#include <QMetaEnum>",
            "#include <QStorageInfo>",
            "#include <QMessageBox>",
            "#include \"ui_mainwindow.h\"",
            "#include \"mainwindow.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"storageitemdelegate.h\"\n#include \"diskdriveinfo.h\"\n#include \"settings.h\"\n#include \"about.h\"\n#include \"math.h\"\n#include <QTimer>\n#include <QStyleFactory>\n#include <QAbstractItemView>\n#include <QTextStream>\n#include <QFileDialog>\n#include <QDate>\n#include <QClipboard>\n#include <QMetaEnum>\n#include <QStorageInfo>\n#include <QMessageBox>\n#include \"ui_mainwindow.h\"\n#include \"mainwindow.h\"\n\nMainWindow {\n  void MainWindow::on_actionFlush_Pagecache_triggered(bool checked)\n  {\n      AppSettings().setFlushingCacheState(checked);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "settings.getIntervalTime",
          "args": [],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "getIntervalTime",
          "container": "AppSettings",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/appsettings.cpp",
          "lines": "159-162",
          "snippet": "int AppSettings::getIntervalTime() const\n{\n    return m_settings->value(QStringLiteral(\"Benchmark/IntervalTime\"), defaultIntervalTime()).toInt();\n}",
          "includes": [
            "#include <QMetaEnum>",
            "#include <QSettings>",
            "#include <QLibraryInfo>",
            "#include <QStandardPaths>",
            "#include <QTranslator>",
            "#include <QCoreApplication>",
            "#include \"cmake.h\"",
            "#include \"appsettings.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QMetaEnum>\n#include <QSettings>\n#include <QLibraryInfo>\n#include <QStandardPaths>\n#include <QTranslator>\n#include <QCoreApplication>\n#include \"cmake.h\"\n#include \"appsettings.h\"\n\nAppSettings {\n  int AppSettings::getIntervalTime() const\n  {\n      return m_settings->value(QStringLiteral(\"Benchmark/IntervalTime\"), defaultIntervalTime()).toInt();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter.hasNext",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "startTest",
          "args": [
            "params.BlockSize",
            "params.Queues",
            "params.Threads",
            "Global::getRWRandomMix()",
            "tr(\"Random Mix %1/%2\")"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "startTest",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
          "lines": "50-132",
          "snippet": "void Benchmark::startTest(int blockSize, int queueDepth, int threads, const QString &rw, const QString &statusMessage)\n{\n    const AppSettings settings;\n\n    PerformanceResult totalRead { 0, 0, 0 }, totalWrite { 0, 0, 0 };\n\n    unsigned int index = 0;\n\n    for (int i = 0; i < settings.getLoopsCount(); i++) {\n        if (!m_running) break;\n\n        emit benchmarkStatusUpdate(statusMessage.arg(index + 1).arg(settings.getLoopsCount()));\n\n        if (settings.getFlusingCacheState() && !flushPageCache()) {\n            setRunning(false);\n            return;\n        }\n\n        auto interface = helperInterface();\n        if (!interface) {\n            setRunning(false);\n            emit failed(\"Inteface is null\");\n            return;\n        }\n\n        QDBusPendingCall pcall = interface->startBenchmarkTest(settings.getMeasuringTime(),\n                                                               settings.getFileSize(),\n                                                               settings.getRandomReadPercentage(),\n                                                               settings.getBenchmarkTestData() == Global::BenchmarkTestData::Zeros,\n                                                               settings.getCacheBypassState(),\n                                                               blockSize, queueDepth, threads, rw);\n        QEventLoop loop;\n\n        auto exitLoop = [&] (bool success, QString output, QString errorOutput) {\n            loop.exit();\n\n            if (!success) {\n                setRunning(false);\n            }\n\n            if (m_running) {\n                index++;\n\n                auto result = parseResult(output, errorOutput);\n\n                switch (settings.getPerformanceProfile())\n                {\n                    case Global::PerformanceProfile::Default:\n                        totalRead  += result.read;\n                        totalWrite += result.write;\n                    break;\n                    case Global::PerformanceProfile::Peak:\n                    case Global::PerformanceProfile::RealWorld:\n                    case Global::PerformanceProfile::Demo:\n                        totalRead.updateWithBetterValues(result.read);\n                        totalWrite.updateWithBetterValues(result.write);\n                    break;\n                }\n            }\n\n            if (rw.contains(\"read\")) {\n                sendResult(totalRead, index);\n            }\n            else if (rw.contains(\"write\")) {\n                sendResult(totalWrite, index);\n            }\n            else if (rw.contains(\"rw\")) {\n                float p = settings.getRandomReadPercentage();\n                sendResult((totalRead * p + totalWrite * (100.f - p)) / 100.f, index);\n            }\n        };\n\n        auto conn = QObject::connect(interface, &DevJonmagonKdiskmarkHelperInterface::taskFinished, exitLoop);\n\n        loop.exec();\n\n        QObject::disconnect(conn);\n\n        if (pcall.isError()) {\n            setRunning(false);\n        }\n    }\n}",
          "includes": [
            "#include \"helper_interface.h\"",
            "#include \"global.h\"",
            "#include \"benchmark.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  void Benchmark::startTest(int blockSize, int queueDepth, int threads, const QString &rw, const QString &statusMessage)\n  {\n      const AppSettings settings;\n  \n      PerformanceResult totalRead { 0, 0, 0 }, totalWrite { 0, 0, 0 };\n  \n      unsigned int index = 0;\n  \n      for (int i = 0; i < settings.getLoopsCount(); i++) {\n          if (!m_running) break;\n  \n          emit benchmarkStatusUpdate(statusMessage.arg(index + 1).arg(settings.getLoopsCount()));\n  \n          if (settings.getFlusingCacheState() && !flushPageCache()) {\n              setRunning(false);\n              return;\n          }\n  \n          auto interface = helperInterface();\n          if (!interface) {\n              setRunning(false);\n              emit failed(\"Inteface is null\");\n              return;\n          }\n  \n          QDBusPendingCall pcall = interface->startBenchmarkTest(settings.getMeasuringTime(),\n                                                                 settings.getFileSize(),\n                                                                 settings.getRandomReadPercentage(),\n                                                                 settings.getBenchmarkTestData() == Global::BenchmarkTestData::Zeros,\n                                                                 settings.getCacheBypassState(),\n                                                                 blockSize, queueDepth, threads, rw);\n          QEventLoop loop;\n  \n          auto exitLoop = [&] (bool success, QString output, QString errorOutput) {\n              loop.exit();\n  \n              if (!success) {\n                  setRunning(false);\n              }\n  \n              if (m_running) {\n                  index++;\n  \n                  auto result = parseResult(output, errorOutput);\n  \n                  switch (settings.getPerformanceProfile())\n                  {\n                      case Global::PerformanceProfile::Default:\n                          totalRead  += result.read;\n                          totalWrite += result.write;\n                      break;\n                      case Global::PerformanceProfile::Peak:\n                      case Global::PerformanceProfile::RealWorld:\n                      case Global::PerformanceProfile::Demo:\n                          totalRead.updateWithBetterValues(result.read);\n                          totalWrite.updateWithBetterValues(result.write);\n                      break;\n                  }\n              }\n  \n              if (rw.contains(\"read\")) {\n                  sendResult(totalRead, index);\n              }\n              else if (rw.contains(\"write\")) {\n                  sendResult(totalWrite, index);\n              }\n              else if (rw.contains(\"rw\")) {\n                  float p = settings.getRandomReadPercentage();\n                  sendResult((totalRead * p + totalWrite * (100.f - p)) / 100.f, index);\n              }\n          };\n  \n          auto conn = QObject::connect(interface, &DevJonmagonKdiskmarkHelperInterface::taskFinished, exitLoop);\n  \n          loop.exec();\n  \n          QObject::disconnect(conn);\n  \n          if (pcall.isError()) {\n              setRunning(false);\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Global::getRWRandomMix",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Global::getRWSequentialMix",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Global::getRWRandomWrite",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Global::getRWSequentialWrite",
          "args": [],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Global::getRWRandomRead",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Global::getRWSequentialRead",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "settings.getBenchmarkParams",
          "args": [
            "item.first.first",
            "settings.getPerformanceProfile()"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "getBenchmarkParams",
          "container": "AppSettings",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/appsettings.cpp",
          "lines": "249-264",
          "snippet": "Global::BenchmarkParams AppSettings::getBenchmarkParams(Global::BenchmarkTest test, Global::PerformanceProfile profile) const\n{\n    Global::BenchmarkParams defaultSet = defaultBenchmarkParams(test, profile, Global::BenchmarkPreset::Standard);\n    if (profile == Global::PerformanceProfile::RealWorld) return defaultSet;\n\n    QString settingKey = QStringLiteral(\"Benchmark/Params/%1/%2/%3\")\n            .arg(QMetaEnum::fromType<Global::PerformanceProfile>().valueToKey(profile))\n            .arg(QMetaEnum::fromType<Global::BenchmarkTest>().valueToKey(test));\n\n    return {\n        (Global::BenchmarkIOPattern)m_settings->value(settingKey.arg(\"Pattern\"), defaultSet.Pattern).toInt(),\n        m_settings->value(settingKey.arg(\"BlockSize\"), defaultSet.BlockSize).toInt(),\n        m_settings->value(settingKey.arg(\"Queues\"), defaultSet.Queues).toInt(),\n        m_settings->value(settingKey.arg(\"Threads\"), defaultSet.Threads).toInt()\n    };\n}",
          "includes": [
            "#include <QMetaEnum>",
            "#include <QSettings>",
            "#include <QLibraryInfo>",
            "#include <QStandardPaths>",
            "#include <QTranslator>",
            "#include <QCoreApplication>",
            "#include \"cmake.h\"",
            "#include \"appsettings.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QMetaEnum>\n#include <QSettings>\n#include <QLibraryInfo>\n#include <QStandardPaths>\n#include <QTranslator>\n#include <QCoreApplication>\n#include \"cmake.h\"\n#include \"appsettings.h\"\n\nAppSettings {\n  Global::BenchmarkParams AppSettings::getBenchmarkParams(Global::BenchmarkTest test, Global::PerformanceProfile profile) const\n  {\n      Global::BenchmarkParams defaultSet = defaultBenchmarkParams(test, profile, Global::BenchmarkPreset::Standard);\n      if (profile == Global::PerformanceProfile::RealWorld) return defaultSet;\n  \n      QString settingKey = QStringLiteral(\"Benchmark/Params/%1/%2/%3\")\n              .arg(QMetaEnum::fromType<Global::PerformanceProfile>().valueToKey(profile))\n              .arg(QMetaEnum::fromType<Global::BenchmarkTest>().valueToKey(test));\n  \n      return {\n          (Global::BenchmarkIOPattern)m_settings->value(settingKey.arg(\"Pattern\"), defaultSet.Pattern).toInt(),\n          m_settings->value(settingKey.arg(\"BlockSize\"), defaultSet.BlockSize).toInt(),\n          m_settings->value(settingKey.arg(\"Queues\"), defaultSet.Queues).toInt(),\n          m_settings->value(settingKey.arg(\"Threads\"), defaultSet.Threads).toInt()\n      };\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "settings.getPerformanceProfile",
          "args": [],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "getPerformanceProfile",
          "container": "AppSettings",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/appsettings.cpp",
          "lines": "54-57",
          "snippet": "Global::PerformanceProfile AppSettings::getPerformanceProfile() const\n{\n    return (Global::PerformanceProfile)m_settings->value(QStringLiteral(\"Benchmark/PerformanceProfile\"), defaultPerformanceProfile()).toInt();\n}",
          "includes": [
            "#include <QMetaEnum>",
            "#include <QSettings>",
            "#include <QLibraryInfo>",
            "#include <QStandardPaths>",
            "#include <QTranslator>",
            "#include <QCoreApplication>",
            "#include \"cmake.h\"",
            "#include \"appsettings.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QMetaEnum>\n#include <QSettings>\n#include <QLibraryInfo>\n#include <QStandardPaths>\n#include <QTranslator>\n#include <QCoreApplication>\n#include \"cmake.h\"\n#include \"appsettings.h\"\n\nAppSettings {\n  Global::PerformanceProfile AppSettings::getPerformanceProfile() const\n  {\n      return (Global::PerformanceProfile)m_settings->value(QStringLiteral(\"Benchmark/PerformanceProfile\"), defaultPerformanceProfile()).toInt();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter.next",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter.hasNext",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepareFile",
          "args": [
            "getBenchmarkFile()",
            "settings.getFileSize()"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "prepareFile",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
          "lines": "398-432",
          "snippet": "bool Benchmark::prepareFile(const QString &benchmarkFile, int fileSize)\n{\n    bool prepared = true;\n\n    auto interface = helperInterface();\n    if (!interface) return false;\n\n    QDBusPendingCall pcall = interface->prepareBenchmarkFile(benchmarkFile, fileSize, AppSettings().getBenchmarkTestData() == Global::BenchmarkTestData::Zeros);\n\n    QEventLoop loop;\n\n    auto exitLoop = [&] (bool success, QString output, QString errorOutput) {\n        loop.exit();\n\n        if (!success) {\n            prepared = false;\n            if (!errorOutput.isEmpty()) {\n                setRunning(false);\n                emit failed(errorOutput);\n            }\n        }\n\n        if (m_running) {\n            parseResult(output, errorOutput);\n        }\n    };\n\n    auto conn = QObject::connect(interface, &DevJonmagonKdiskmarkHelperInterface::taskFinished, exitLoop);\n\n    loop.exec();\n\n    QObject::disconnect(conn);\n\n    return prepared && !pcall.isError();\n}",
          "includes": [
            "#include \"helper_interface.h\"",
            "#include \"global.h\"",
            "#include \"benchmark.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  bool Benchmark::prepareFile(const QString &benchmarkFile, int fileSize)\n  {\n      bool prepared = true;\n  \n      auto interface = helperInterface();\n      if (!interface) return false;\n  \n      QDBusPendingCall pcall = interface->prepareBenchmarkFile(benchmarkFile, fileSize, AppSettings().getBenchmarkTestData() == Global::BenchmarkTestData::Zeros);\n  \n      QEventLoop loop;\n  \n      auto exitLoop = [&] (bool success, QString output, QString errorOutput) {\n          loop.exit();\n  \n          if (!success) {\n              prepared = false;\n              if (!errorOutput.isEmpty()) {\n                  setRunning(false);\n                  emit failed(errorOutput);\n              }\n          }\n  \n          if (m_running) {\n              parseResult(output, errorOutput);\n          }\n      };\n  \n      auto conn = QObject::connect(interface, &DevJonmagonKdiskmarkHelperInterface::taskFinished, exitLoop);\n  \n      loop.exec();\n  \n      QObject::disconnect(conn);\n  \n      return prepared && !pcall.isError();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "settings.getFileSize",
          "args": [],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "getFileSize",
          "container": "AppSettings",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/appsettings.cpp",
          "lines": "129-132",
          "snippet": "int AppSettings::getFileSize() const\n{\n    return m_settings->value(QStringLiteral(\"Benchmark/FileSize\"), defaultFileSize()).toInt();\n}",
          "includes": [
            "#include <QMetaEnum>",
            "#include <QSettings>",
            "#include <QLibraryInfo>",
            "#include <QStandardPaths>",
            "#include <QTranslator>",
            "#include <QCoreApplication>",
            "#include \"cmake.h\"",
            "#include \"appsettings.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QMetaEnum>\n#include <QSettings>\n#include <QLibraryInfo>\n#include <QStandardPaths>\n#include <QTranslator>\n#include <QCoreApplication>\n#include \"cmake.h\"\n#include \"appsettings.h\"\n\nAppSettings {\n  int AppSettings::getFileSize() const\n  {\n      return m_settings->value(QStringLiteral(\"Benchmark/FileSize\"), defaultFileSize()).toInt();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getBenchmarkFile",
          "args": [],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "getBenchmarkFile",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
          "lines": "37-48",
          "snippet": "QString Benchmark::getBenchmarkFile()\n{\n    if (m_dir.isNull())\n        return QString();\n\n    if (m_dir.endsWith(\"/\")) {\n        return m_dir + \".kdiskmark.tmp\";\n    }\n    else {\n        return m_dir + \"/.kdiskmark.tmp\";\n    }\n}",
          "includes": [
            "#include \"helper_interface.h\"",
            "#include \"global.h\"",
            "#include \"benchmark.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  QString Benchmark::getBenchmarkFile()\n  {\n      if (m_dir.isNull())\n          return QString();\n  \n      if (m_dir.endsWith(\"/\")) {\n          return m_dir + \".kdiskmark.tmp\";\n      }\n      else {\n          return m_dir + \"/.kdiskmark.tmp\";\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter.hasNext",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter.toFront",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter.remove",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "settings.getBenchmarkMode",
          "args": [],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "getBenchmarkMode",
          "container": "AppSettings",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/appsettings.cpp",
          "lines": "84-87",
          "snippet": "Global::BenchmarkMode AppSettings::getBenchmarkMode() const\n{\n    return (Global::BenchmarkMode)m_settings->value(QStringLiteral(\"Benchmark/Mode\"), defaultBenchmarkMode()).toInt();\n}",
          "includes": [
            "#include <QMetaEnum>",
            "#include <QSettings>",
            "#include <QLibraryInfo>",
            "#include <QStandardPaths>",
            "#include <QTranslator>",
            "#include <QCoreApplication>",
            "#include \"cmake.h\"",
            "#include \"appsettings.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QMetaEnum>\n#include <QSettings>\n#include <QLibraryInfo>\n#include <QStandardPaths>\n#include <QTranslator>\n#include <QCoreApplication>\n#include \"cmake.h\"\n#include \"appsettings.h\"\n\nAppSettings {\n  Global::BenchmarkMode AppSettings::getBenchmarkMode() const\n  {\n      return (Global::BenchmarkMode)m_settings->value(QStringLiteral(\"Benchmark/Mode\"), defaultBenchmarkMode()).toInt();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter.remove",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter.next",
          "args": [],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter.hasNext",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  void Benchmark::runBenchmark(QList<QPair<QPair<Global::BenchmarkTest, Global::BenchmarkIOReadWrite>, QVector<QProgressBar*>>> tests)\n  {\n      setRunning(true);\n  \n      const AppSettings settings;\n  \n      QPair<QPair<Global::BenchmarkTest, Global::BenchmarkIOReadWrite>, QVector<QProgressBar*>> item;\n  \n      QMutableListIterator<QPair<QPair<Global::BenchmarkTest, Global::BenchmarkIOReadWrite>, QVector<QProgressBar*>>> iter(tests);\n      // Set to 0 all the progressbars for current tests\n      while (iter.hasNext()) {\n          item = iter.next();\n          if (item.first.second == Global::BenchmarkIOReadWrite::Read && settings.getBenchmarkMode() == Global::BenchmarkMode::WriteMix) { iter.remove(); continue; }\n          if (item.first.second == Global::BenchmarkIOReadWrite::Write && settings.getBenchmarkMode() == Global::BenchmarkMode::ReadMix) { iter.remove(); continue; }\n          auto progressBars = item.second;\n          for (auto obj : progressBars) {\n              emit resultReady(obj, PerformanceResult());\n          }\n      }\n  \n      iter.toFront();\n  \n      // If there are no tests in the queue\n      if (!iter.hasNext()) {\n          setRunning(false);\n          return;\n      }\n  \n      emit benchmarkStatusUpdate(tr(\"Preparing...\"));\n  \n      if (!prepareFile(getBenchmarkFile(), settings.getFileSize())) {\n          setRunning(false);\n          return;\n      }\n  \n      while (iter.hasNext() && m_running) {\n          item = iter.next();\n  \n          m_progressBars = item.second;\n  \n          Global::BenchmarkParams params = settings.getBenchmarkParams(item.first.first, settings.getPerformanceProfile());\n  \n          switch (item.first.second)\n          {\n          case Global::BenchmarkIOReadWrite::Read:\n              if (params.Pattern == Global::BenchmarkIOPattern::SEQ) {\n                  startTest(params.BlockSize, params.Queues, params.Threads,\n                            Global::getRWSequentialRead(), tr(\"Sequential Read %1/%2\"));\n              }\n              else {\n                  startTest(params.BlockSize, params.Queues, params.Threads,\n                            Global::getRWRandomRead(), tr(\"Random Read %1/%2\"));\n              }\n              break;\n          case Global::BenchmarkIOReadWrite::Write:\n              if (params.Pattern == Global::BenchmarkIOPattern::SEQ) {\n                  startTest(params.BlockSize, params.Queues, params.Threads,\n                            Global::getRWSequentialWrite(), tr(\"Sequential Write %1/%2\"));\n              }\n              else {\n                  startTest(params.BlockSize, params.Queues, params.Threads,\n                            Global::getRWRandomWrite(), tr(\"Random Write %1/%2\"));\n              }\n              break;\n          case Global::BenchmarkIOReadWrite::Mix:\n              if (params.Pattern == Global::BenchmarkIOPattern::SEQ) {\n                  startTest(params.BlockSize, params.Queues, params.Threads,\n                            Global::getRWSequentialMix(), tr(\"Sequential Mix %1/%2\"));\n              }\n              else {\n                  startTest(params.BlockSize, params.Queues, params.Threads,\n                            Global::getRWRandomMix(), tr(\"Random Mix %1/%2\"));\n              }\n              break;\n          }\n  \n          if (iter.hasNext()) {\n              for (int i = 0, intervalTime = settings.getIntervalTime(); i < intervalTime && m_running; i++) {\n                  emit benchmarkStatusUpdate(tr(\"Interval Time %1/%2 sec\").arg(i).arg(intervalTime));\n                  QEventLoop loop;\n                  QTimer::singleShot(1000, &loop, SLOT(quit()));\n                  loop.exec();\n              }\n          }\n      }\n  \n      auto interface = helperInterface();\n      if (interface)\n          dbusWaitForFinish(interface->removeBenchmarkFile());\n  \n      setRunning(false);\n      emit finished(); // Only needed when closing the app during a running benchmarking\n  }\n}"
  },
  {
    "function_name": "isRunning",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
    "lines": "208-211",
    "snippet": "bool Benchmark::isRunning()\n{\n    return m_running;\n}",
    "includes": [
      "#include \"helper_interface.h\"",
      "#include \"global.h\"",
      "#include \"benchmark.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  bool Benchmark::isRunning()\n  {\n      return m_running;\n  }\n}"
  },
  {
    "function_name": "setRunning",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
    "lines": "192-206",
    "snippet": "void Benchmark::setRunning(bool state)\n{\n    if (m_running == state)\n        return;\n\n    m_running = state;\n\n    if (!m_running) {\n        auto interface = helperInterface();\n        if (interface)\n            dbusWaitForFinish(interface->stopCurrentTask());\n    }\n\n    emit runningStateChanged(state);\n}",
    "includes": [
      "#include \"helper_interface.h\"",
      "#include \"global.h\"",
      "#include \"benchmark.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbusWaitForFinish",
          "args": [
            "interface->stopCurrentTask()"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "dbusWaitForFinish",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
          "lines": "434-440",
          "snippet": "void Benchmark::dbusWaitForFinish(QDBusPendingCall pcall)\n{\n    QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(pcall, this);\n    QEventLoop loop;\n    connect(watcher, &QDBusPendingCallWatcher::finished, [&] (QDBusPendingCallWatcher *watcher) { loop.exit(); });\n    loop.exec();\n}",
          "includes": [
            "#include \"helper_interface.h\"",
            "#include \"global.h\"",
            "#include \"benchmark.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  void Benchmark::dbusWaitForFinish(QDBusPendingCall pcall)\n  {\n      QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(pcall, this);\n      QEventLoop loop;\n      connect(watcher, &QDBusPendingCallWatcher::finished, [&] (QDBusPendingCallWatcher *watcher) { loop.exit(); });\n      loop.exec();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "interface->stopCurrentTask",
          "args": [],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "stopCurrentTask",
          "container": "Helper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
          "lines": "231-245",
          "snippet": "void Helper::stopCurrentTask()\n{\n    if (!isCallerAuthorized()) {\n        return;\n    }\n\n    if (!m_process) return;\n\n    if (m_process->state() == QProcess::Running || m_process->state() == QProcess::Starting) {\n        m_process->terminate();\n        m_process->waitForFinished(-1);\n    }\n\n    delete m_process;\n}",
          "includes": [
            "#include <signal.h>",
            "#include <PolkitQt1/Subject>",
            "#include <PolkitQt1/Authority>",
            "#include <QFile>",
            "#include <QtDBus>",
            "#include <QCoreApplication>",
            "#include \"helper.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  void Helper::stopCurrentTask()\n  {\n      if (!isCallerAuthorized()) {\n          return;\n      }\n  \n      if (!m_process) return;\n  \n      if (m_process->state() == QProcess::Running || m_process->state() == QProcess::Starting) {\n          m_process->terminate();\n          m_process->waitForFinished(-1);\n      }\n  \n      delete m_process;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "helperInterface",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  void Benchmark::setRunning(bool state)\n  {\n      if (m_running == state)\n          return;\n  \n      m_running = state;\n  \n      if (!m_running) {\n          auto interface = helperInterface();\n          if (interface)\n              dbusWaitForFinish(interface->stopCurrentTask());\n      }\n  \n      emit runningStateChanged(state);\n  }\n}"
  },
  {
    "function_name": "parseResult",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
    "lines": "149-190",
    "snippet": "Benchmark::ParsedJob Benchmark::parseResult(const QString &output, const QString &errorOutput)\n{\n    QJsonDocument jsonResponse = QJsonDocument::fromJson(output.toUtf8());\n    QJsonObject jsonObject = jsonResponse.object();\n    QJsonArray jobs = jsonObject[\"jobs\"].toArray();\n\n    ParsedJob parsedJob {{0, 0, 0}, {0, 0, 0}};\n\n    int jobsCount = jobs.count();\n\n    if (jobsCount == 0 && !errorOutput.isEmpty()) {\n        setRunning(false);\n        emit failed(errorOutput);\n    }\n    else if (jobsCount == 0) {\n        setRunning(false);\n        emit failed(\"Bad FIO output.\");\n    }\n    else {\n        for (int i = 0; i < jobsCount; i++) {\n            QJsonObject job = jobs.takeAt(i).toObject();\n\n            if (job[\"error\"].toInt() == 0) {\n                QJsonObject jobRead = job[\"read\"].toObject();\n                parsedJob.read.Bandwidth += jobRead.value(\"bw\").toInt() / 1000.0; // to mb\n                parsedJob.read.IOPS += jobRead.value(\"iops\").toDouble();\n                parsedJob.read.Latency += jobRead[\"lat_ns\"].toObject().value(\"mean\").toDouble() / 1000.0 / jobsCount; // to usec\n\n                QJsonObject jobWrite = job[\"write\"].toObject();\n                parsedJob.write.Bandwidth += jobWrite.value(\"bw\").toInt() / 1000.0; // to mb\n                parsedJob.write.IOPS += jobWrite.value(\"iops\").toDouble();\n                parsedJob.write.Latency += jobWrite[\"lat_ns\"].toObject().value(\"mean\").toDouble() / 1000.0 / jobsCount; // to usec\n            }\n            else {\n                setRunning(false);\n                emit failed(errorOutput/*.mid(errorOutput.simplified().lastIndexOf(\"=\") + 1)*/);\n            }\n        }\n    }\n\n    return parsedJob;\n}",
    "includes": [
      "#include \"helper_interface.h\"",
      "#include \"global.h\"",
      "#include \"benchmark.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setRunning",
          "args": [
            "false"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "setRunning",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
          "lines": "192-206",
          "snippet": "void Benchmark::setRunning(bool state)\n{\n    if (m_running == state)\n        return;\n\n    m_running = state;\n\n    if (!m_running) {\n        auto interface = helperInterface();\n        if (interface)\n            dbusWaitForFinish(interface->stopCurrentTask());\n    }\n\n    emit runningStateChanged(state);\n}",
          "includes": [
            "#include \"helper_interface.h\"",
            "#include \"global.h\"",
            "#include \"benchmark.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  void Benchmark::setRunning(bool state)\n  {\n      if (m_running == state)\n          return;\n  \n      m_running = state;\n  \n      if (!m_running) {\n          auto interface = helperInterface();\n          if (interface)\n              dbusWaitForFinish(interface->stopCurrentTask());\n      }\n  \n      emit runningStateChanged(state);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "jobWrite[\"lat_ns\"].toObject",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobWrite[\"lat_ns\"].toObject",
          "args": [
            "\"mean\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobWrite[\"lat_ns\"].toObject",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobWrite.value",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobWrite.value",
          "args": [
            "\"iops\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobWrite.value",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobWrite.value",
          "args": [
            "\"bw\""
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "job[\"write\"].toObject",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobRead[\"lat_ns\"].toObject",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobRead[\"lat_ns\"].toObject",
          "args": [
            "\"mean\""
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobRead[\"lat_ns\"].toObject",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobRead.value",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobRead.value",
          "args": [
            "\"iops\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobRead.value",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobRead.value",
          "args": [
            "\"bw\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "job[\"read\"].toObject",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "job[\"error\"].toInt",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobs.takeAt",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobs.takeAt",
          "args": [
            "i"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errorOutput.isEmpty",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobs.count",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jsonObject[\"jobs\"].toArray",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jsonResponse.object",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QJsonDocument::fromJson",
          "args": [
            "output.toUtf8()"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.toUtf8",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  Benchmark::ParsedJob Benchmark::parseResult(const QString &output, const QString &errorOutput)\n  {\n      QJsonDocument jsonResponse = QJsonDocument::fromJson(output.toUtf8());\n      QJsonObject jsonObject = jsonResponse.object();\n      QJsonArray jobs = jsonObject[\"jobs\"].toArray();\n  \n      ParsedJob parsedJob {{0, 0, 0}, {0, 0, 0}};\n  \n      int jobsCount = jobs.count();\n  \n      if (jobsCount == 0 && !errorOutput.isEmpty()) {\n          setRunning(false);\n          emit failed(errorOutput);\n      }\n      else if (jobsCount == 0) {\n          setRunning(false);\n          emit failed(\"Bad FIO output.\");\n      }\n      else {\n          for (int i = 0; i < jobsCount; i++) {\n              QJsonObject job = jobs.takeAt(i).toObject();\n  \n              if (job[\"error\"].toInt() == 0) {\n                  QJsonObject jobRead = job[\"read\"].toObject();\n                  parsedJob.read.Bandwidth += jobRead.value(\"bw\").toInt() / 1000.0; // to mb\n                  parsedJob.read.IOPS += jobRead.value(\"iops\").toDouble();\n                  parsedJob.read.Latency += jobRead[\"lat_ns\"].toObject().value(\"mean\").toDouble() / 1000.0 / jobsCount; // to usec\n  \n                  QJsonObject jobWrite = job[\"write\"].toObject();\n                  parsedJob.write.Bandwidth += jobWrite.value(\"bw\").toInt() / 1000.0; // to mb\n                  parsedJob.write.IOPS += jobWrite.value(\"iops\").toDouble();\n                  parsedJob.write.Latency += jobWrite[\"lat_ns\"].toObject().value(\"mean\").toDouble() / 1000.0 / jobsCount; // to usec\n              }\n              else {\n                  setRunning(false);\n                  emit failed(errorOutput/*.mid(errorOutput.simplified().lastIndexOf(\"=\") + 1)*/);\n              }\n          }\n      }\n  \n      return parsedJob;\n  }\n}"
  },
  {
    "function_name": "sendResult",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
    "lines": "134-147",
    "snippet": "void Benchmark::sendResult(const Benchmark::PerformanceResult &result, const int index)\n{\n    const AppSettings settings;\n    if (settings.getPerformanceProfile() == Global::PerformanceProfile::Default) {\n        for (auto progressBar : m_progressBars) {\n            emit resultReady(progressBar, result / index);\n        }\n    }\n    else {\n        for (auto progressBar : m_progressBars) {\n            emit resultReady(progressBar, result);\n        }\n    }\n}",
    "includes": [
      "#include \"helper_interface.h\"",
      "#include \"global.h\"",
      "#include \"benchmark.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "settings.getPerformanceProfile",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "getPerformanceProfile",
          "container": "AppSettings",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/appsettings.cpp",
          "lines": "54-57",
          "snippet": "Global::PerformanceProfile AppSettings::getPerformanceProfile() const\n{\n    return (Global::PerformanceProfile)m_settings->value(QStringLiteral(\"Benchmark/PerformanceProfile\"), defaultPerformanceProfile()).toInt();\n}",
          "includes": [
            "#include <QMetaEnum>",
            "#include <QSettings>",
            "#include <QLibraryInfo>",
            "#include <QStandardPaths>",
            "#include <QTranslator>",
            "#include <QCoreApplication>",
            "#include \"cmake.h\"",
            "#include \"appsettings.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QMetaEnum>\n#include <QSettings>\n#include <QLibraryInfo>\n#include <QStandardPaths>\n#include <QTranslator>\n#include <QCoreApplication>\n#include \"cmake.h\"\n#include \"appsettings.h\"\n\nAppSettings {\n  Global::PerformanceProfile AppSettings::getPerformanceProfile() const\n  {\n      return (Global::PerformanceProfile)m_settings->value(QStringLiteral(\"Benchmark/PerformanceProfile\"), defaultPerformanceProfile()).toInt();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  void Benchmark::sendResult(const Benchmark::PerformanceResult &result, const int index)\n  {\n      const AppSettings settings;\n      if (settings.getPerformanceProfile() == Global::PerformanceProfile::Default) {\n          for (auto progressBar : m_progressBars) {\n              emit resultReady(progressBar, result / index);\n          }\n      }\n      else {\n          for (auto progressBar : m_progressBars) {\n              emit resultReady(progressBar, result);\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "startTest",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
    "lines": "50-132",
    "snippet": "void Benchmark::startTest(int blockSize, int queueDepth, int threads, const QString &rw, const QString &statusMessage)\n{\n    const AppSettings settings;\n\n    PerformanceResult totalRead { 0, 0, 0 }, totalWrite { 0, 0, 0 };\n\n    unsigned int index = 0;\n\n    for (int i = 0; i < settings.getLoopsCount(); i++) {\n        if (!m_running) break;\n\n        emit benchmarkStatusUpdate(statusMessage.arg(index + 1).arg(settings.getLoopsCount()));\n\n        if (settings.getFlusingCacheState() && !flushPageCache()) {\n            setRunning(false);\n            return;\n        }\n\n        auto interface = helperInterface();\n        if (!interface) {\n            setRunning(false);\n            emit failed(\"Inteface is null\");\n            return;\n        }\n\n        QDBusPendingCall pcall = interface->startBenchmarkTest(settings.getMeasuringTime(),\n                                                               settings.getFileSize(),\n                                                               settings.getRandomReadPercentage(),\n                                                               settings.getBenchmarkTestData() == Global::BenchmarkTestData::Zeros,\n                                                               settings.getCacheBypassState(),\n                                                               blockSize, queueDepth, threads, rw);\n        QEventLoop loop;\n\n        auto exitLoop = [&] (bool success, QString output, QString errorOutput) {\n            loop.exit();\n\n            if (!success) {\n                setRunning(false);\n            }\n\n            if (m_running) {\n                index++;\n\n                auto result = parseResult(output, errorOutput);\n\n                switch (settings.getPerformanceProfile())\n                {\n                    case Global::PerformanceProfile::Default:\n                        totalRead  += result.read;\n                        totalWrite += result.write;\n                    break;\n                    case Global::PerformanceProfile::Peak:\n                    case Global::PerformanceProfile::RealWorld:\n                    case Global::PerformanceProfile::Demo:\n                        totalRead.updateWithBetterValues(result.read);\n                        totalWrite.updateWithBetterValues(result.write);\n                    break;\n                }\n            }\n\n            if (rw.contains(\"read\")) {\n                sendResult(totalRead, index);\n            }\n            else if (rw.contains(\"write\")) {\n                sendResult(totalWrite, index);\n            }\n            else if (rw.contains(\"rw\")) {\n                float p = settings.getRandomReadPercentage();\n                sendResult((totalRead * p + totalWrite * (100.f - p)) / 100.f, index);\n            }\n        };\n\n        auto conn = QObject::connect(interface, &DevJonmagonKdiskmarkHelperInterface::taskFinished, exitLoop);\n\n        loop.exec();\n\n        QObject::disconnect(conn);\n\n        if (pcall.isError()) {\n            setRunning(false);\n        }\n    }\n}",
    "includes": [
      "#include \"helper_interface.h\"",
      "#include \"global.h\"",
      "#include \"benchmark.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setRunning",
          "args": [
            "false"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "setRunning",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
          "lines": "192-206",
          "snippet": "void Benchmark::setRunning(bool state)\n{\n    if (m_running == state)\n        return;\n\n    m_running = state;\n\n    if (!m_running) {\n        auto interface = helperInterface();\n        if (interface)\n            dbusWaitForFinish(interface->stopCurrentTask());\n    }\n\n    emit runningStateChanged(state);\n}",
          "includes": [
            "#include \"helper_interface.h\"",
            "#include \"global.h\"",
            "#include \"benchmark.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  void Benchmark::setRunning(bool state)\n  {\n      if (m_running == state)\n          return;\n  \n      m_running = state;\n  \n      if (!m_running) {\n          auto interface = helperInterface();\n          if (interface)\n              dbusWaitForFinish(interface->stopCurrentTask());\n      }\n  \n      emit runningStateChanged(state);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcall.isError",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QObject::disconnect",
          "args": [
            "conn"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loop.exec",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QObject::connect",
          "args": [
            "interface",
            "&DevJonmagonKdiskmarkHelperInterface::taskFinished",
            "exitLoop"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendResult",
          "args": [
            "(totalRead * p + totalWrite * (100.f - p)) / 100.f",
            "index"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "sendResult",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
          "lines": "134-147",
          "snippet": "void Benchmark::sendResult(const Benchmark::PerformanceResult &result, const int index)\n{\n    const AppSettings settings;\n    if (settings.getPerformanceProfile() == Global::PerformanceProfile::Default) {\n        for (auto progressBar : m_progressBars) {\n            emit resultReady(progressBar, result / index);\n        }\n    }\n    else {\n        for (auto progressBar : m_progressBars) {\n            emit resultReady(progressBar, result);\n        }\n    }\n}",
          "includes": [
            "#include \"helper_interface.h\"",
            "#include \"global.h\"",
            "#include \"benchmark.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  void Benchmark::sendResult(const Benchmark::PerformanceResult &result, const int index)\n  {\n      const AppSettings settings;\n      if (settings.getPerformanceProfile() == Global::PerformanceProfile::Default) {\n          for (auto progressBar : m_progressBars) {\n              emit resultReady(progressBar, result / index);\n          }\n      }\n      else {\n          for (auto progressBar : m_progressBars) {\n              emit resultReady(progressBar, result);\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "settings.getRandomReadPercentage",
          "args": [],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "getRandomReadPercentage",
          "container": "AppSettings",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/appsettings.cpp",
          "lines": "174-177",
          "snippet": "int AppSettings::getRandomReadPercentage() const\n{\n    return m_settings->value(QStringLiteral(\"Benchmark/RandomReadPercentage\"), defaultRandomReadPercentage()).toInt();\n}",
          "includes": [
            "#include <QMetaEnum>",
            "#include <QSettings>",
            "#include <QLibraryInfo>",
            "#include <QStandardPaths>",
            "#include <QTranslator>",
            "#include <QCoreApplication>",
            "#include \"cmake.h\"",
            "#include \"appsettings.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QMetaEnum>\n#include <QSettings>\n#include <QLibraryInfo>\n#include <QStandardPaths>\n#include <QTranslator>\n#include <QCoreApplication>\n#include \"cmake.h\"\n#include \"appsettings.h\"\n\nAppSettings {\n  int AppSettings::getRandomReadPercentage() const\n  {\n      return m_settings->value(QStringLiteral(\"Benchmark/RandomReadPercentage\"), defaultRandomReadPercentage()).toInt();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rw.contains",
          "args": [
            "\"rw\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rw.contains",
          "args": [
            "\"write\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rw.contains",
          "args": [
            "\"read\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "totalWrite.updateWithBetterValues",
          "args": [
            "result.write"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "updateWithBetterValues",
          "container": "Benchmark::PerformanceResult",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.h",
          "lines": "70-75",
          "snippet": "void updateWithBetterValues(const PerformanceResult& result) {\n            Bandwidth = Bandwidth < result.Bandwidth ? result.Bandwidth : Bandwidth;\n            IOPS = IOPS < result.IOPS ? result.IOPS : IOPS;\n            if (Latency == 0) Latency = result.Latency;\n            Latency = Latency > result.Latency ? result.Latency : Latency;\n        }",
          "includes": [
            "#include \"appsettings.h\"",
            "#include <memory>",
            "#include <QObject>",
            "#include <QProgressBar>",
            "#include <QString>",
            "#include <QStringList>",
            "#include <QProcess>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"appsettings.h\"\n#include <memory>\n#include <QObject>\n#include <QProgressBar>\n#include <QString>\n#include <QStringList>\n#include <QProcess>\n\nBenchmark {\n  PerformanceResult {\n    void updateWithBetterValues(const PerformanceResult& result) {\n                Bandwidth = Bandwidth < result.Bandwidth ? result.Bandwidth : Bandwidth;\n                IOPS = IOPS < result.IOPS ? result.IOPS : IOPS;\n                if (Latency == 0) Latency = result.Latency;\n                Latency = Latency > result.Latency ? result.Latency : Latency;\n            }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "settings.getPerformanceProfile",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "getPerformanceProfile",
          "container": "AppSettings",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/appsettings.cpp",
          "lines": "54-57",
          "snippet": "Global::PerformanceProfile AppSettings::getPerformanceProfile() const\n{\n    return (Global::PerformanceProfile)m_settings->value(QStringLiteral(\"Benchmark/PerformanceProfile\"), defaultPerformanceProfile()).toInt();\n}",
          "includes": [
            "#include <QMetaEnum>",
            "#include <QSettings>",
            "#include <QLibraryInfo>",
            "#include <QStandardPaths>",
            "#include <QTranslator>",
            "#include <QCoreApplication>",
            "#include \"cmake.h\"",
            "#include \"appsettings.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QMetaEnum>\n#include <QSettings>\n#include <QLibraryInfo>\n#include <QStandardPaths>\n#include <QTranslator>\n#include <QCoreApplication>\n#include \"cmake.h\"\n#include \"appsettings.h\"\n\nAppSettings {\n  Global::PerformanceProfile AppSettings::getPerformanceProfile() const\n  {\n      return (Global::PerformanceProfile)m_settings->value(QStringLiteral(\"Benchmark/PerformanceProfile\"), defaultPerformanceProfile()).toInt();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseResult",
          "args": [
            "output",
            "errorOutput"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "parseResult",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
          "lines": "149-190",
          "snippet": "Benchmark::ParsedJob Benchmark::parseResult(const QString &output, const QString &errorOutput)\n{\n    QJsonDocument jsonResponse = QJsonDocument::fromJson(output.toUtf8());\n    QJsonObject jsonObject = jsonResponse.object();\n    QJsonArray jobs = jsonObject[\"jobs\"].toArray();\n\n    ParsedJob parsedJob {{0, 0, 0}, {0, 0, 0}};\n\n    int jobsCount = jobs.count();\n\n    if (jobsCount == 0 && !errorOutput.isEmpty()) {\n        setRunning(false);\n        emit failed(errorOutput);\n    }\n    else if (jobsCount == 0) {\n        setRunning(false);\n        emit failed(\"Bad FIO output.\");\n    }\n    else {\n        for (int i = 0; i < jobsCount; i++) {\n            QJsonObject job = jobs.takeAt(i).toObject();\n\n            if (job[\"error\"].toInt() == 0) {\n                QJsonObject jobRead = job[\"read\"].toObject();\n                parsedJob.read.Bandwidth += jobRead.value(\"bw\").toInt() / 1000.0; // to mb\n                parsedJob.read.IOPS += jobRead.value(\"iops\").toDouble();\n                parsedJob.read.Latency += jobRead[\"lat_ns\"].toObject().value(\"mean\").toDouble() / 1000.0 / jobsCount; // to usec\n\n                QJsonObject jobWrite = job[\"write\"].toObject();\n                parsedJob.write.Bandwidth += jobWrite.value(\"bw\").toInt() / 1000.0; // to mb\n                parsedJob.write.IOPS += jobWrite.value(\"iops\").toDouble();\n                parsedJob.write.Latency += jobWrite[\"lat_ns\"].toObject().value(\"mean\").toDouble() / 1000.0 / jobsCount; // to usec\n            }\n            else {\n                setRunning(false);\n                emit failed(errorOutput/*.mid(errorOutput.simplified().lastIndexOf(\"=\") + 1)*/);\n            }\n        }\n    }\n\n    return parsedJob;\n}",
          "includes": [
            "#include \"helper_interface.h\"",
            "#include \"global.h\"",
            "#include \"benchmark.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  Benchmark::ParsedJob Benchmark::parseResult(const QString &output, const QString &errorOutput)\n  {\n      QJsonDocument jsonResponse = QJsonDocument::fromJson(output.toUtf8());\n      QJsonObject jsonObject = jsonResponse.object();\n      QJsonArray jobs = jsonObject[\"jobs\"].toArray();\n  \n      ParsedJob parsedJob {{0, 0, 0}, {0, 0, 0}};\n  \n      int jobsCount = jobs.count();\n  \n      if (jobsCount == 0 && !errorOutput.isEmpty()) {\n          setRunning(false);\n          emit failed(errorOutput);\n      }\n      else if (jobsCount == 0) {\n          setRunning(false);\n          emit failed(\"Bad FIO output.\");\n      }\n      else {\n          for (int i = 0; i < jobsCount; i++) {\n              QJsonObject job = jobs.takeAt(i).toObject();\n  \n              if (job[\"error\"].toInt() == 0) {\n                  QJsonObject jobRead = job[\"read\"].toObject();\n                  parsedJob.read.Bandwidth += jobRead.value(\"bw\").toInt() / 1000.0; // to mb\n                  parsedJob.read.IOPS += jobRead.value(\"iops\").toDouble();\n                  parsedJob.read.Latency += jobRead[\"lat_ns\"].toObject().value(\"mean\").toDouble() / 1000.0 / jobsCount; // to usec\n  \n                  QJsonObject jobWrite = job[\"write\"].toObject();\n                  parsedJob.write.Bandwidth += jobWrite.value(\"bw\").toInt() / 1000.0; // to mb\n                  parsedJob.write.IOPS += jobWrite.value(\"iops\").toDouble();\n                  parsedJob.write.Latency += jobWrite[\"lat_ns\"].toObject().value(\"mean\").toDouble() / 1000.0 / jobsCount; // to usec\n              }\n              else {\n                  setRunning(false);\n                  emit failed(errorOutput/*.mid(errorOutput.simplified().lastIndexOf(\"=\") + 1)*/);\n              }\n          }\n      }\n  \n      return parsedJob;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "loop.exit",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interface->startBenchmarkTest",
          "args": [
            "settings.getMeasuringTime()",
            "settings.getFileSize()",
            "settings.getRandomReadPercentage()",
            "settings.getBenchmarkTestData() == Global::BenchmarkTestData::Zeros",
            "settings.getCacheBypassState()",
            "blockSize",
            "queueDepth",
            "threads",
            "rw"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "startBenchmarkTest",
          "container": "Helper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
          "lines": "150-189",
          "snippet": "void Helper::startBenchmarkTest(int measuringTime, int fileSize, int randomReadPercentage, bool fillZeros, bool cacheBypass,\n                                int blockSize, int queueDepth, int threads, const QString &rw)\n{\n    if (!isCallerAuthorized()) {\n        return;\n    }\n\n    if (m_benchmarkFile.isEmpty()) {\n        return;\n    }\n\n    if (!QFile(m_benchmarkFile).exists()) {\n        qWarning() << \"The benchmark file was not pre-created.\";\n        return;\n    }\n\n    m_process = new QProcess();\n    m_process->start(\"fio\", QStringList()\n                     << QStringLiteral(\"--output-format=json\")\n                     << QStringLiteral(\"--ioengine=libaio\")\n                     << QStringLiteral(\"--randrepeat=0\")\n                     << QStringLiteral(\"--refill_buffers\")\n                     << QStringLiteral(\"--end_fsync=1\")\n                     << QStringLiteral(\"--direct=%1\").arg(cacheBypass)\n                     << QStringLiteral(\"--rwmixread=%1\").arg(randomReadPercentage)\n                     << QStringLiteral(\"--filename=%1\").arg(m_benchmarkFile)\n                     << QStringLiteral(\"--name=%1\").arg(rw)\n                     << QStringLiteral(\"--size=%1m\").arg(fileSize)\n                     << QStringLiteral(\"--zero_buffers=%1\").arg(fillZeros)\n                     << QStringLiteral(\"--bs=%1k\").arg(blockSize)\n                     << QStringLiteral(\"--runtime=%1\").arg(measuringTime)\n                     << QStringLiteral(\"--rw=%1\").arg(rw)\n                     << QStringLiteral(\"--iodepth=%1\").arg(queueDepth)\n                     << QStringLiteral(\"--numjobs=%1\").arg(threads));\n\n    connect(m_process, static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n            [=] (int exitCode, QProcess::ExitStatus exitStatus) {\n        emit taskFinished(exitStatus == QProcess::NormalExit, QString(m_process->readAllStandardOutput()), QString(m_process->readAllStandardError()));\n    });\n}",
          "includes": [
            "#include <signal.h>",
            "#include <PolkitQt1/Subject>",
            "#include <PolkitQt1/Authority>",
            "#include <QFile>",
            "#include <QtDBus>",
            "#include <QCoreApplication>",
            "#include \"helper.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  void Helper::startBenchmarkTest(int measuringTime, int fileSize, int randomReadPercentage, bool fillZeros, bool cacheBypass,\n                                  int blockSize, int queueDepth, int threads, const QString &rw)\n  {\n      if (!isCallerAuthorized()) {\n          return;\n      }\n  \n      if (m_benchmarkFile.isEmpty()) {\n          return;\n      }\n  \n      if (!QFile(m_benchmarkFile).exists()) {\n          qWarning() << \"The benchmark file was not pre-created.\";\n          return;\n      }\n  \n      m_process = new QProcess();\n      m_process->start(\"fio\", QStringList()\n                       << QStringLiteral(\"--output-format=json\")\n                       << QStringLiteral(\"--ioengine=libaio\")\n                       << QStringLiteral(\"--randrepeat=0\")\n                       << QStringLiteral(\"--refill_buffers\")\n                       << QStringLiteral(\"--end_fsync=1\")\n                       << QStringLiteral(\"--direct=%1\").arg(cacheBypass)\n                       << QStringLiteral(\"--rwmixread=%1\").arg(randomReadPercentage)\n                       << QStringLiteral(\"--filename=%1\").arg(m_benchmarkFile)\n                       << QStringLiteral(\"--name=%1\").arg(rw)\n                       << QStringLiteral(\"--size=%1m\").arg(fileSize)\n                       << QStringLiteral(\"--zero_buffers=%1\").arg(fillZeros)\n                       << QStringLiteral(\"--bs=%1k\").arg(blockSize)\n                       << QStringLiteral(\"--runtime=%1\").arg(measuringTime)\n                       << QStringLiteral(\"--rw=%1\").arg(rw)\n                       << QStringLiteral(\"--iodepth=%1\").arg(queueDepth)\n                       << QStringLiteral(\"--numjobs=%1\").arg(threads));\n  \n      connect(m_process, static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n              [=] (int exitCode, QProcess::ExitStatus exitStatus) {\n          emit taskFinished(exitStatus == QProcess::NormalExit, QString(m_process->readAllStandardOutput()), QString(m_process->readAllStandardError()));\n      });\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "settings.getCacheBypassState",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "getCacheBypassState",
          "container": "AppSettings",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/appsettings.cpp",
          "lines": "189-192",
          "snippet": "bool AppSettings::getCacheBypassState() const\n{\n    return m_settings->value(QStringLiteral(\"Benchmark/BypassCache\"), defaultCacheBypassState()).toBool();\n}",
          "includes": [
            "#include <QMetaEnum>",
            "#include <QSettings>",
            "#include <QLibraryInfo>",
            "#include <QStandardPaths>",
            "#include <QTranslator>",
            "#include <QCoreApplication>",
            "#include \"cmake.h\"",
            "#include \"appsettings.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QMetaEnum>\n#include <QSettings>\n#include <QLibraryInfo>\n#include <QStandardPaths>\n#include <QTranslator>\n#include <QCoreApplication>\n#include \"cmake.h\"\n#include \"appsettings.h\"\n\nAppSettings {\n  bool AppSettings::getCacheBypassState() const\n  {\n      return m_settings->value(QStringLiteral(\"Benchmark/BypassCache\"), defaultCacheBypassState()).toBool();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "settings.getBenchmarkTestData",
          "args": [],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "getBenchmarkTestData",
          "container": "AppSettings",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/appsettings.cpp",
          "lines": "99-102",
          "snippet": "Global::BenchmarkTestData AppSettings::getBenchmarkTestData() const\n{\n    return (Global::BenchmarkTestData)m_settings->value(QStringLiteral(\"Benchmark/TestData\"), defaultBenchmarkTestData()).toInt();\n}",
          "includes": [
            "#include <QMetaEnum>",
            "#include <QSettings>",
            "#include <QLibraryInfo>",
            "#include <QStandardPaths>",
            "#include <QTranslator>",
            "#include <QCoreApplication>",
            "#include \"cmake.h\"",
            "#include \"appsettings.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QMetaEnum>\n#include <QSettings>\n#include <QLibraryInfo>\n#include <QStandardPaths>\n#include <QTranslator>\n#include <QCoreApplication>\n#include \"cmake.h\"\n#include \"appsettings.h\"\n\nAppSettings {\n  Global::BenchmarkTestData AppSettings::getBenchmarkTestData() const\n  {\n      return (Global::BenchmarkTestData)m_settings->value(QStringLiteral(\"Benchmark/TestData\"), defaultBenchmarkTestData()).toInt();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "settings.getFileSize",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "getFileSize",
          "container": "AppSettings",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/appsettings.cpp",
          "lines": "129-132",
          "snippet": "int AppSettings::getFileSize() const\n{\n    return m_settings->value(QStringLiteral(\"Benchmark/FileSize\"), defaultFileSize()).toInt();\n}",
          "includes": [
            "#include <QMetaEnum>",
            "#include <QSettings>",
            "#include <QLibraryInfo>",
            "#include <QStandardPaths>",
            "#include <QTranslator>",
            "#include <QCoreApplication>",
            "#include \"cmake.h\"",
            "#include \"appsettings.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QMetaEnum>\n#include <QSettings>\n#include <QLibraryInfo>\n#include <QStandardPaths>\n#include <QTranslator>\n#include <QCoreApplication>\n#include \"cmake.h\"\n#include \"appsettings.h\"\n\nAppSettings {\n  int AppSettings::getFileSize() const\n  {\n      return m_settings->value(QStringLiteral(\"Benchmark/FileSize\"), defaultFileSize()).toInt();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "settings.getMeasuringTime",
          "args": [],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "getMeasuringTime",
          "container": "AppSettings",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/appsettings.cpp",
          "lines": "144-147",
          "snippet": "int AppSettings::getMeasuringTime() const\n{\n    return m_settings->value(QStringLiteral(\"Benchmark/MeasuringTime\"), defaultMeasuringTime()).toInt();\n}",
          "includes": [
            "#include <QMetaEnum>",
            "#include <QSettings>",
            "#include <QLibraryInfo>",
            "#include <QStandardPaths>",
            "#include <QTranslator>",
            "#include <QCoreApplication>",
            "#include \"cmake.h\"",
            "#include \"appsettings.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QMetaEnum>\n#include <QSettings>\n#include <QLibraryInfo>\n#include <QStandardPaths>\n#include <QTranslator>\n#include <QCoreApplication>\n#include \"cmake.h\"\n#include \"appsettings.h\"\n\nAppSettings {\n  int AppSettings::getMeasuringTime() const\n  {\n      return m_settings->value(QStringLiteral(\"Benchmark/MeasuringTime\"), defaultMeasuringTime()).toInt();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "helperInterface",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flushPageCache",
          "args": [],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "flushPageCache",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
          "lines": "360-396",
          "snippet": "bool Benchmark::flushPageCache()\n{\n    bool flushed = true;\n\n    auto interface = helperInterface();\n    if (!interface) return false;\n\n    QDBusPendingCall pcall = interface->flushPageCache();\n\n    QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(pcall, this);\n    QEventLoop loop;\n\n    auto exitLoop = [&] (QDBusPendingCallWatcher *watcher) {\n        loop.exit();\n\n        if (watcher->isError())\n            qWarning() << watcher->error();\n        else {\n            QDBusPendingReply<QVariantMap> reply = *watcher;\n\n            QVariantMap replyContent = reply.value();\n            if (!replyContent[QStringLiteral(\"success\")].toBool()) {\n                flushed = false;\n                QString error = replyContent[QStringLiteral(\"error\")].toString();\n                if (!error.isEmpty()) {\n                    setRunning(false);\n                    emit failed(error);\n                }\n            }\n        }\n    };\n\n    connect(watcher, &QDBusPendingCallWatcher::finished, exitLoop);\n    loop.exec();\n\n    return flushed && !watcher->isError();;\n}",
          "includes": [
            "#include \"helper_interface.h\"",
            "#include \"global.h\"",
            "#include \"benchmark.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  bool Benchmark::flushPageCache()\n  {\n      bool flushed = true;\n  \n      auto interface = helperInterface();\n      if (!interface) return false;\n  \n      QDBusPendingCall pcall = interface->flushPageCache();\n  \n      QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(pcall, this);\n      QEventLoop loop;\n  \n      auto exitLoop = [&] (QDBusPendingCallWatcher *watcher) {\n          loop.exit();\n  \n          if (watcher->isError())\n              qWarning() << watcher->error();\n          else {\n              QDBusPendingReply<QVariantMap> reply = *watcher;\n  \n              QVariantMap replyContent = reply.value();\n              if (!replyContent[QStringLiteral(\"success\")].toBool()) {\n                  flushed = false;\n                  QString error = replyContent[QStringLiteral(\"error\")].toString();\n                  if (!error.isEmpty()) {\n                      setRunning(false);\n                      emit failed(error);\n                  }\n              }\n          }\n      };\n  \n      connect(watcher, &QDBusPendingCallWatcher::finished, exitLoop);\n      loop.exec();\n  \n      return flushed && !watcher->isError();;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "settings.getFlusingCacheState",
          "args": [],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "getFlusingCacheState",
          "container": "AppSettings",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/appsettings.cpp",
          "lines": "204-207",
          "snippet": "bool AppSettings::getFlusingCacheState() const\n{\n    return m_settings->value(QStringLiteral(\"Benchmark/FlushingCache\"), defaultFlushingCacheState()).toBool();\n}",
          "includes": [
            "#include <QMetaEnum>",
            "#include <QSettings>",
            "#include <QLibraryInfo>",
            "#include <QStandardPaths>",
            "#include <QTranslator>",
            "#include <QCoreApplication>",
            "#include \"cmake.h\"",
            "#include \"appsettings.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QMetaEnum>\n#include <QSettings>\n#include <QLibraryInfo>\n#include <QStandardPaths>\n#include <QTranslator>\n#include <QCoreApplication>\n#include \"cmake.h\"\n#include \"appsettings.h\"\n\nAppSettings {\n  bool AppSettings::getFlusingCacheState() const\n  {\n      return m_settings->value(QStringLiteral(\"Benchmark/FlushingCache\"), defaultFlushingCacheState()).toBool();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "statusMessage.arg",
          "args": [
            "settings.getLoopsCount()"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "settings.getLoopsCount",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "getLoopsCount",
          "container": "AppSettings",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/appsettings.cpp",
          "lines": "114-117",
          "snippet": "int AppSettings::getLoopsCount() const\n{\n    return m_settings->value(QStringLiteral(\"Benchmark/LoopsCount\"), defaultLoopsCount()).toInt();\n}",
          "includes": [
            "#include <QMetaEnum>",
            "#include <QSettings>",
            "#include <QLibraryInfo>",
            "#include <QStandardPaths>",
            "#include <QTranslator>",
            "#include <QCoreApplication>",
            "#include \"cmake.h\"",
            "#include \"appsettings.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QMetaEnum>\n#include <QSettings>\n#include <QLibraryInfo>\n#include <QStandardPaths>\n#include <QTranslator>\n#include <QCoreApplication>\n#include \"cmake.h\"\n#include \"appsettings.h\"\n\nAppSettings {\n  int AppSettings::getLoopsCount() const\n  {\n      return m_settings->value(QStringLiteral(\"Benchmark/LoopsCount\"), defaultLoopsCount()).toInt();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "statusMessage.arg",
          "args": [
            "index + 1"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  void Benchmark::startTest(int blockSize, int queueDepth, int threads, const QString &rw, const QString &statusMessage)\n  {\n      const AppSettings settings;\n  \n      PerformanceResult totalRead { 0, 0, 0 }, totalWrite { 0, 0, 0 };\n  \n      unsigned int index = 0;\n  \n      for (int i = 0; i < settings.getLoopsCount(); i++) {\n          if (!m_running) break;\n  \n          emit benchmarkStatusUpdate(statusMessage.arg(index + 1).arg(settings.getLoopsCount()));\n  \n          if (settings.getFlusingCacheState() && !flushPageCache()) {\n              setRunning(false);\n              return;\n          }\n  \n          auto interface = helperInterface();\n          if (!interface) {\n              setRunning(false);\n              emit failed(\"Inteface is null\");\n              return;\n          }\n  \n          QDBusPendingCall pcall = interface->startBenchmarkTest(settings.getMeasuringTime(),\n                                                                 settings.getFileSize(),\n                                                                 settings.getRandomReadPercentage(),\n                                                                 settings.getBenchmarkTestData() == Global::BenchmarkTestData::Zeros,\n                                                                 settings.getCacheBypassState(),\n                                                                 blockSize, queueDepth, threads, rw);\n          QEventLoop loop;\n  \n          auto exitLoop = [&] (bool success, QString output, QString errorOutput) {\n              loop.exit();\n  \n              if (!success) {\n                  setRunning(false);\n              }\n  \n              if (m_running) {\n                  index++;\n  \n                  auto result = parseResult(output, errorOutput);\n  \n                  switch (settings.getPerformanceProfile())\n                  {\n                      case Global::PerformanceProfile::Default:\n                          totalRead  += result.read;\n                          totalWrite += result.write;\n                      break;\n                      case Global::PerformanceProfile::Peak:\n                      case Global::PerformanceProfile::RealWorld:\n                      case Global::PerformanceProfile::Demo:\n                          totalRead.updateWithBetterValues(result.read);\n                          totalWrite.updateWithBetterValues(result.write);\n                      break;\n                  }\n              }\n  \n              if (rw.contains(\"read\")) {\n                  sendResult(totalRead, index);\n              }\n              else if (rw.contains(\"write\")) {\n                  sendResult(totalWrite, index);\n              }\n              else if (rw.contains(\"rw\")) {\n                  float p = settings.getRandomReadPercentage();\n                  sendResult((totalRead * p + totalWrite * (100.f - p)) / 100.f, index);\n              }\n          };\n  \n          auto conn = QObject::connect(interface, &DevJonmagonKdiskmarkHelperInterface::taskFinished, exitLoop);\n  \n          loop.exec();\n  \n          QObject::disconnect(conn);\n  \n          if (pcall.isError()) {\n              setRunning(false);\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "getBenchmarkFile",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
    "lines": "37-48",
    "snippet": "QString Benchmark::getBenchmarkFile()\n{\n    if (m_dir.isNull())\n        return QString();\n\n    if (m_dir.endsWith(\"/\")) {\n        return m_dir + \".kdiskmark.tmp\";\n    }\n    else {\n        return m_dir + \"/.kdiskmark.tmp\";\n    }\n}",
    "includes": [
      "#include \"helper_interface.h\"",
      "#include \"global.h\"",
      "#include \"benchmark.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_dir.endsWith",
          "args": [
            "\"/\""
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_dir.isNull",
          "args": [],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  QString Benchmark::getBenchmarkFile()\n  {\n      if (m_dir.isNull())\n          return QString();\n  \n      if (m_dir.endsWith(\"/\")) {\n          return m_dir + \".kdiskmark.tmp\";\n      }\n      else {\n          return m_dir + \"/.kdiskmark.tmp\";\n      }\n  }\n}"
  },
  {
    "function_name": "setDir",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
    "lines": "32-35",
    "snippet": "void Benchmark::setDir(const QString &dir)\n{\n    m_dir = dir;\n}",
    "includes": [
      "#include \"helper_interface.h\"",
      "#include \"global.h\"",
      "#include \"benchmark.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  void Benchmark::setDir(const QString &dir)\n  {\n      m_dir = dir;\n  }\n}"
  },
  {
    "function_name": "isFIODetected",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
    "lines": "27-30",
    "snippet": "bool Benchmark::isFIODetected()\n{\n    return m_FIOVersion.indexOf(\"fio-\") == 0;\n}",
    "includes": [
      "#include \"helper_interface.h\"",
      "#include \"global.h\"",
      "#include \"benchmark.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_FIOVersion.indexOf",
          "args": [
            "\"fio-\""
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  bool Benchmark::isFIODetected()\n  {\n      return m_FIOVersion.indexOf(\"fio-\") == 0;\n  }\n}"
  },
  {
    "function_name": "getFIOVersion",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
    "lines": "22-25",
    "snippet": "QString Benchmark::getFIOVersion()\n{\n    return m_FIOVersion;\n}",
    "includes": [
      "#include \"helper_interface.h\"",
      "#include \"global.h\"",
      "#include \"benchmark.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  QString Benchmark::getFIOVersion()\n  {\n      return m_FIOVersion;\n  }\n}"
  },
  {
    "function_name": "~Benchmark",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
    "lines": "20-20",
    "snippet": "Benchmark::~Benchmark() {}",
    "includes": [
      "#include \"helper_interface.h\"",
      "#include \"global.h\"",
      "#include \"benchmark.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  Benchmark::~Benchmark() {}\n}"
  },
  {
    "function_name": "Benchmark",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/benchmark.cpp",
    "lines": "7-18",
    "snippet": "Benchmark::Benchmark()\n{\n    m_running = false;\n\n    QProcess process;\n    process.start(\"fio\", {\"--version\"});\n    process.waitForFinished();\n\n    m_FIOVersion = process.readAllStandardOutput().simplified();\n\n    process.close();\n}",
    "includes": [
      "#include \"helper_interface.h\"",
      "#include \"global.h\"",
      "#include \"benchmark.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process.close",
          "args": [],
          "line": 17
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process.readAllStandardOutput",
          "args": [],
          "line": 15
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process.readAllStandardOutput",
          "args": [],
          "line": 15
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process.waitForFinished",
          "args": [],
          "line": 13
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process.start",
          "args": [
            "\"fio\"",
            "{\"--version\"}"
          ],
          "line": 12
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"helper_interface.h\"\n#include \"global.h\"\n#include \"benchmark.h\"\n\nBenchmark {\n  Benchmark::Benchmark()\n  {\n      m_running = false;\n  \n      QProcess process;\n      process.start(\"fio\", {\"--version\"});\n      process.waitForFinished();\n  \n      m_FIOVersion = process.readAllStandardOutput().simplified();\n  \n      process.close();\n  }\n}"
  }
]