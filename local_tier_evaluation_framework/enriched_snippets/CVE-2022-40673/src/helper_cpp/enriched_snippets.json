[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
    "lines": "293-298",
    "snippet": "int main(int argc, char *argv[])\n{\n    QCoreApplication a(argc, argv);\n    Helper helper;\n    a.exec();\n}",
    "includes": [
      "#include <signal.h>",
      "#include <PolkitQt1/Subject>",
      "#include <PolkitQt1/Authority>",
      "#include <QFile>",
      "#include <QtDBus>",
      "#include <QCoreApplication>",
      "#include \"helper.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "a.exec",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nint main(int argc, char *argv[])\n{\n    QCoreApplication a(argc, argv);\n    Helper helper;\n    a.exec();\n}"
  },
  {
    "function_name": "isCallerAuthorized",
    "container": "Helper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
    "lines": "247-291",
    "snippet": "bool Helper::isCallerAuthorized()\n{\n    if (!calledFromDBus()) {\n        return false;\n    }\n\n    if (m_serviceWatcher->watchedServices().contains(message().service())) {\n        return true;\n    }\n\n    if (!m_serviceWatcher->watchedServices().isEmpty()) {\n        qDebug() << \"There are already registered DBus connections.\";\n        return false;\n    }\n\n    PolkitQt1::SystemBusNameSubject subject(message().service());\n    PolkitQt1::Authority *authority = PolkitQt1::Authority::instance();\n\n    PolkitQt1::Authority::Result result;\n    QEventLoop e;\n    connect(authority, &PolkitQt1::Authority::checkAuthorizationFinished, &e, [&e, &result](PolkitQt1::Authority::Result _result) {\n        result = _result;\n        e.quit();\n    });\n\n    authority->checkAuthorization(QStringLiteral(\"dev.jonmagon.kdiskmark.helper.init\"), subject, PolkitQt1::Authority::AllowUserInteraction);\n    e.exec();\n\n    if (authority->hasError()) {\n        qDebug() << \"Encountered error while checking authorization, error code: \" << authority->lastError() << authority->errorDetails();\n        authority->clearError();\n    }\n\n    switch (result) {\n    case PolkitQt1::Authority::Yes:\n        // track who called into us so we can close when all callers have gone away\n        m_serviceWatcher->addWatchedService(message().service());\n        return true;\n    default:\n        sendErrorReply(QDBusError::AccessDenied);\n        if (m_serviceWatcher->watchedServices().isEmpty())\n            qApp->quit();\n        return false;\n    }\n}",
    "includes": [
      "#include <signal.h>",
      "#include <PolkitQt1/Subject>",
      "#include <PolkitQt1/Authority>",
      "#include <QFile>",
      "#include <QtDBus>",
      "#include <QCoreApplication>",
      "#include \"helper.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qApp->quit",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_serviceWatcher->watchedServices",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_serviceWatcher->watchedServices",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendErrorReply",
          "args": [
            "QDBusError::AccessDenied"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_serviceWatcher->addWatchedService",
          "args": [
            "message().service()"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "authority->clearError",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "authority->errorDetails",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "authority->lastError",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qDebug",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "authority->hasError",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.exec",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "authority->checkAuthorization",
          "args": [
            "QStringLiteral(\"dev.jonmagon.kdiskmark.helper.init\")",
            "subject",
            "PolkitQt1::Authority::AllowUserInteraction"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"dev.jonmagon.kdiskmark.helper.init\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "authority",
            "&PolkitQt1::Authority::checkAuthorizationFinished",
            "&e",
            "[&e, &result](PolkitQt1::Authority::Result _result) {\n        result = _result;\n        e.quit();\n    }"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.quit",
          "args": [],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PolkitQt1::Authority::instance",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message",
          "args": [],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message",
          "args": [],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qDebug",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_serviceWatcher->watchedServices",
          "args": [],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_serviceWatcher->watchedServices",
          "args": [],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_serviceWatcher->watchedServices",
          "args": [
            "message().service()"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_serviceWatcher->watchedServices",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calledFromDBus",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  bool Helper::isCallerAuthorized()\n  {\n      if (!calledFromDBus()) {\n          return false;\n      }\n  \n      if (m_serviceWatcher->watchedServices().contains(message().service())) {\n          return true;\n      }\n  \n      if (!m_serviceWatcher->watchedServices().isEmpty()) {\n          qDebug() << \"There are already registered DBus connections.\";\n          return false;\n      }\n  \n      PolkitQt1::SystemBusNameSubject subject(message().service());\n      PolkitQt1::Authority *authority = PolkitQt1::Authority::instance();\n  \n      PolkitQt1::Authority::Result result;\n      QEventLoop e;\n      connect(authority, &PolkitQt1::Authority::checkAuthorizationFinished, &e, [&e, &result](PolkitQt1::Authority::Result _result) {\n          result = _result;\n          e.quit();\n      });\n  \n      authority->checkAuthorization(QStringLiteral(\"dev.jonmagon.kdiskmark.helper.init\"), subject, PolkitQt1::Authority::AllowUserInteraction);\n      e.exec();\n  \n      if (authority->hasError()) {\n          qDebug() << \"Encountered error while checking authorization, error code: \" << authority->lastError() << authority->errorDetails();\n          authority->clearError();\n      }\n  \n      switch (result) {\n      case PolkitQt1::Authority::Yes:\n          // track who called into us so we can close when all callers have gone away\n          m_serviceWatcher->addWatchedService(message().service());\n          return true;\n      default:\n          sendErrorReply(QDBusError::AccessDenied);\n          if (m_serviceWatcher->watchedServices().isEmpty())\n              qApp->quit();\n          return false;\n      }\n  }\n}"
  },
  {
    "function_name": "stopCurrentTask",
    "container": "Helper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
    "lines": "231-245",
    "snippet": "void Helper::stopCurrentTask()\n{\n    if (!isCallerAuthorized()) {\n        return;\n    }\n\n    if (!m_process) return;\n\n    if (m_process->state() == QProcess::Running || m_process->state() == QProcess::Starting) {\n        m_process->terminate();\n        m_process->waitForFinished(-1);\n    }\n\n    delete m_process;\n}",
    "includes": [
      "#include <signal.h>",
      "#include <PolkitQt1/Subject>",
      "#include <PolkitQt1/Authority>",
      "#include <QFile>",
      "#include <QtDBus>",
      "#include <QCoreApplication>",
      "#include \"helper.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_process->waitForFinished",
          "args": [
            "-1"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_process->terminate",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_process->state",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_process->state",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isCallerAuthorized",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "isCallerAuthorized",
          "container": "Helper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
          "lines": "247-291",
          "snippet": "bool Helper::isCallerAuthorized()\n{\n    if (!calledFromDBus()) {\n        return false;\n    }\n\n    if (m_serviceWatcher->watchedServices().contains(message().service())) {\n        return true;\n    }\n\n    if (!m_serviceWatcher->watchedServices().isEmpty()) {\n        qDebug() << \"There are already registered DBus connections.\";\n        return false;\n    }\n\n    PolkitQt1::SystemBusNameSubject subject(message().service());\n    PolkitQt1::Authority *authority = PolkitQt1::Authority::instance();\n\n    PolkitQt1::Authority::Result result;\n    QEventLoop e;\n    connect(authority, &PolkitQt1::Authority::checkAuthorizationFinished, &e, [&e, &result](PolkitQt1::Authority::Result _result) {\n        result = _result;\n        e.quit();\n    });\n\n    authority->checkAuthorization(QStringLiteral(\"dev.jonmagon.kdiskmark.helper.init\"), subject, PolkitQt1::Authority::AllowUserInteraction);\n    e.exec();\n\n    if (authority->hasError()) {\n        qDebug() << \"Encountered error while checking authorization, error code: \" << authority->lastError() << authority->errorDetails();\n        authority->clearError();\n    }\n\n    switch (result) {\n    case PolkitQt1::Authority::Yes:\n        // track who called into us so we can close when all callers have gone away\n        m_serviceWatcher->addWatchedService(message().service());\n        return true;\n    default:\n        sendErrorReply(QDBusError::AccessDenied);\n        if (m_serviceWatcher->watchedServices().isEmpty())\n            qApp->quit();\n        return false;\n    }\n}",
          "includes": [
            "#include <signal.h>",
            "#include <PolkitQt1/Subject>",
            "#include <PolkitQt1/Authority>",
            "#include <QFile>",
            "#include <QtDBus>",
            "#include <QCoreApplication>",
            "#include \"helper.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  bool Helper::isCallerAuthorized()\n  {\n      if (!calledFromDBus()) {\n          return false;\n      }\n  \n      if (m_serviceWatcher->watchedServices().contains(message().service())) {\n          return true;\n      }\n  \n      if (!m_serviceWatcher->watchedServices().isEmpty()) {\n          qDebug() << \"There are already registered DBus connections.\";\n          return false;\n      }\n  \n      PolkitQt1::SystemBusNameSubject subject(message().service());\n      PolkitQt1::Authority *authority = PolkitQt1::Authority::instance();\n  \n      PolkitQt1::Authority::Result result;\n      QEventLoop e;\n      connect(authority, &PolkitQt1::Authority::checkAuthorizationFinished, &e, [&e, &result](PolkitQt1::Authority::Result _result) {\n          result = _result;\n          e.quit();\n      });\n  \n      authority->checkAuthorization(QStringLiteral(\"dev.jonmagon.kdiskmark.helper.init\"), subject, PolkitQt1::Authority::AllowUserInteraction);\n      e.exec();\n  \n      if (authority->hasError()) {\n          qDebug() << \"Encountered error while checking authorization, error code: \" << authority->lastError() << authority->errorDetails();\n          authority->clearError();\n      }\n  \n      switch (result) {\n      case PolkitQt1::Authority::Yes:\n          // track who called into us so we can close when all callers have gone away\n          m_serviceWatcher->addWatchedService(message().service());\n          return true;\n      default:\n          sendErrorReply(QDBusError::AccessDenied);\n          if (m_serviceWatcher->watchedServices().isEmpty())\n              qApp->quit();\n          return false;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  void Helper::stopCurrentTask()\n  {\n      if (!isCallerAuthorized()) {\n          return;\n      }\n  \n      if (!m_process) return;\n  \n      if (m_process->state() == QProcess::Running || m_process->state() == QProcess::Starting) {\n          m_process->terminate();\n          m_process->waitForFinished(-1);\n      }\n  \n      delete m_process;\n  }\n}"
  },
  {
    "function_name": "removeBenchmarkFile",
    "container": "Helper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
    "lines": "215-229",
    "snippet": "bool Helper::removeBenchmarkFile()\n{\n    if (!isCallerAuthorized()) {\n        return false;\n    }\n\n    if (m_benchmarkFile.isEmpty()) {\n        return false;\n    }\n\n    bool deletionState = QFile(m_benchmarkFile).remove();\n    m_benchmarkFile.clear();\n\n    return deletionState;\n}",
    "includes": [
      "#include <signal.h>",
      "#include <PolkitQt1/Subject>",
      "#include <PolkitQt1/Authority>",
      "#include <QFile>",
      "#include <QtDBus>",
      "#include <QCoreApplication>",
      "#include \"helper.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_benchmarkFile.clear",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QFile",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QFile",
          "args": [
            "m_benchmarkFile"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_benchmarkFile.isEmpty",
          "args": [],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isCallerAuthorized",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "isCallerAuthorized",
          "container": "Helper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
          "lines": "247-291",
          "snippet": "bool Helper::isCallerAuthorized()\n{\n    if (!calledFromDBus()) {\n        return false;\n    }\n\n    if (m_serviceWatcher->watchedServices().contains(message().service())) {\n        return true;\n    }\n\n    if (!m_serviceWatcher->watchedServices().isEmpty()) {\n        qDebug() << \"There are already registered DBus connections.\";\n        return false;\n    }\n\n    PolkitQt1::SystemBusNameSubject subject(message().service());\n    PolkitQt1::Authority *authority = PolkitQt1::Authority::instance();\n\n    PolkitQt1::Authority::Result result;\n    QEventLoop e;\n    connect(authority, &PolkitQt1::Authority::checkAuthorizationFinished, &e, [&e, &result](PolkitQt1::Authority::Result _result) {\n        result = _result;\n        e.quit();\n    });\n\n    authority->checkAuthorization(QStringLiteral(\"dev.jonmagon.kdiskmark.helper.init\"), subject, PolkitQt1::Authority::AllowUserInteraction);\n    e.exec();\n\n    if (authority->hasError()) {\n        qDebug() << \"Encountered error while checking authorization, error code: \" << authority->lastError() << authority->errorDetails();\n        authority->clearError();\n    }\n\n    switch (result) {\n    case PolkitQt1::Authority::Yes:\n        // track who called into us so we can close when all callers have gone away\n        m_serviceWatcher->addWatchedService(message().service());\n        return true;\n    default:\n        sendErrorReply(QDBusError::AccessDenied);\n        if (m_serviceWatcher->watchedServices().isEmpty())\n            qApp->quit();\n        return false;\n    }\n}",
          "includes": [
            "#include <signal.h>",
            "#include <PolkitQt1/Subject>",
            "#include <PolkitQt1/Authority>",
            "#include <QFile>",
            "#include <QtDBus>",
            "#include <QCoreApplication>",
            "#include \"helper.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  bool Helper::isCallerAuthorized()\n  {\n      if (!calledFromDBus()) {\n          return false;\n      }\n  \n      if (m_serviceWatcher->watchedServices().contains(message().service())) {\n          return true;\n      }\n  \n      if (!m_serviceWatcher->watchedServices().isEmpty()) {\n          qDebug() << \"There are already registered DBus connections.\";\n          return false;\n      }\n  \n      PolkitQt1::SystemBusNameSubject subject(message().service());\n      PolkitQt1::Authority *authority = PolkitQt1::Authority::instance();\n  \n      PolkitQt1::Authority::Result result;\n      QEventLoop e;\n      connect(authority, &PolkitQt1::Authority::checkAuthorizationFinished, &e, [&e, &result](PolkitQt1::Authority::Result _result) {\n          result = _result;\n          e.quit();\n      });\n  \n      authority->checkAuthorization(QStringLiteral(\"dev.jonmagon.kdiskmark.helper.init\"), subject, PolkitQt1::Authority::AllowUserInteraction);\n      e.exec();\n  \n      if (authority->hasError()) {\n          qDebug() << \"Encountered error while checking authorization, error code: \" << authority->lastError() << authority->errorDetails();\n          authority->clearError();\n      }\n  \n      switch (result) {\n      case PolkitQt1::Authority::Yes:\n          // track who called into us so we can close when all callers have gone away\n          m_serviceWatcher->addWatchedService(message().service());\n          return true;\n      default:\n          sendErrorReply(QDBusError::AccessDenied);\n          if (m_serviceWatcher->watchedServices().isEmpty())\n              qApp->quit();\n          return false;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  bool Helper::removeBenchmarkFile()\n  {\n      if (!isCallerAuthorized()) {\n          return false;\n      }\n  \n      if (m_benchmarkFile.isEmpty()) {\n          return false;\n      }\n  \n      bool deletionState = QFile(m_benchmarkFile).remove();\n      m_benchmarkFile.clear();\n  \n      return deletionState;\n  }\n}"
  },
  {
    "function_name": "flushPageCache",
    "container": "Helper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
    "lines": "191-213",
    "snippet": "QVariantMap Helper::flushPageCache()\n{\n    QVariantMap reply;\n    reply[QStringLiteral(\"success\")] = true;\n\n    if (!isCallerAuthorized()) {\n        reply[QStringLiteral(\"success\")] = false;\n        return reply;\n    }\n\n    QFile file(\"/proc/sys/vm/drop_caches\");\n\n    if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {\n        file.write(\"1\");\n        file.close();\n    }\n    else {\n        reply[QStringLiteral(\"success\")] = false;\n        reply[QStringLiteral(\"error\")] = file.errorString();\n    }\n\n    return reply;\n}",
    "includes": [
      "#include <signal.h>",
      "#include <PolkitQt1/Subject>",
      "#include <PolkitQt1/Authority>",
      "#include <QFile>",
      "#include <QtDBus>",
      "#include <QCoreApplication>",
      "#include \"helper.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file.errorString",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"error\""
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"success\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.close",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.write",
          "args": [
            "\"1\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.open",
          "args": [
            "QIODevice::WriteOnly | QIODevice::Text"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"success\""
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isCallerAuthorized",
          "args": [],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "isCallerAuthorized",
          "container": "Helper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
          "lines": "247-291",
          "snippet": "bool Helper::isCallerAuthorized()\n{\n    if (!calledFromDBus()) {\n        return false;\n    }\n\n    if (m_serviceWatcher->watchedServices().contains(message().service())) {\n        return true;\n    }\n\n    if (!m_serviceWatcher->watchedServices().isEmpty()) {\n        qDebug() << \"There are already registered DBus connections.\";\n        return false;\n    }\n\n    PolkitQt1::SystemBusNameSubject subject(message().service());\n    PolkitQt1::Authority *authority = PolkitQt1::Authority::instance();\n\n    PolkitQt1::Authority::Result result;\n    QEventLoop e;\n    connect(authority, &PolkitQt1::Authority::checkAuthorizationFinished, &e, [&e, &result](PolkitQt1::Authority::Result _result) {\n        result = _result;\n        e.quit();\n    });\n\n    authority->checkAuthorization(QStringLiteral(\"dev.jonmagon.kdiskmark.helper.init\"), subject, PolkitQt1::Authority::AllowUserInteraction);\n    e.exec();\n\n    if (authority->hasError()) {\n        qDebug() << \"Encountered error while checking authorization, error code: \" << authority->lastError() << authority->errorDetails();\n        authority->clearError();\n    }\n\n    switch (result) {\n    case PolkitQt1::Authority::Yes:\n        // track who called into us so we can close when all callers have gone away\n        m_serviceWatcher->addWatchedService(message().service());\n        return true;\n    default:\n        sendErrorReply(QDBusError::AccessDenied);\n        if (m_serviceWatcher->watchedServices().isEmpty())\n            qApp->quit();\n        return false;\n    }\n}",
          "includes": [
            "#include <signal.h>",
            "#include <PolkitQt1/Subject>",
            "#include <PolkitQt1/Authority>",
            "#include <QFile>",
            "#include <QtDBus>",
            "#include <QCoreApplication>",
            "#include \"helper.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  bool Helper::isCallerAuthorized()\n  {\n      if (!calledFromDBus()) {\n          return false;\n      }\n  \n      if (m_serviceWatcher->watchedServices().contains(message().service())) {\n          return true;\n      }\n  \n      if (!m_serviceWatcher->watchedServices().isEmpty()) {\n          qDebug() << \"There are already registered DBus connections.\";\n          return false;\n      }\n  \n      PolkitQt1::SystemBusNameSubject subject(message().service());\n      PolkitQt1::Authority *authority = PolkitQt1::Authority::instance();\n  \n      PolkitQt1::Authority::Result result;\n      QEventLoop e;\n      connect(authority, &PolkitQt1::Authority::checkAuthorizationFinished, &e, [&e, &result](PolkitQt1::Authority::Result _result) {\n          result = _result;\n          e.quit();\n      });\n  \n      authority->checkAuthorization(QStringLiteral(\"dev.jonmagon.kdiskmark.helper.init\"), subject, PolkitQt1::Authority::AllowUserInteraction);\n      e.exec();\n  \n      if (authority->hasError()) {\n          qDebug() << \"Encountered error while checking authorization, error code: \" << authority->lastError() << authority->errorDetails();\n          authority->clearError();\n      }\n  \n      switch (result) {\n      case PolkitQt1::Authority::Yes:\n          // track who called into us so we can close when all callers have gone away\n          m_serviceWatcher->addWatchedService(message().service());\n          return true;\n      default:\n          sendErrorReply(QDBusError::AccessDenied);\n          if (m_serviceWatcher->watchedServices().isEmpty())\n              qApp->quit();\n          return false;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"success\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  QVariantMap Helper::flushPageCache()\n  {\n      QVariantMap reply;\n      reply[QStringLiteral(\"success\")] = true;\n  \n      if (!isCallerAuthorized()) {\n          reply[QStringLiteral(\"success\")] = false;\n          return reply;\n      }\n  \n      QFile file(\"/proc/sys/vm/drop_caches\");\n  \n      if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {\n          file.write(\"1\");\n          file.close();\n      }\n      else {\n          reply[QStringLiteral(\"success\")] = false;\n          reply[QStringLiteral(\"error\")] = file.errorString();\n      }\n  \n      return reply;\n  }\n}"
  },
  {
    "function_name": "startBenchmarkTest",
    "container": "Helper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
    "lines": "150-189",
    "snippet": "void Helper::startBenchmarkTest(int measuringTime, int fileSize, int randomReadPercentage, bool fillZeros, bool cacheBypass,\n                                int blockSize, int queueDepth, int threads, const QString &rw)\n{\n    if (!isCallerAuthorized()) {\n        return;\n    }\n\n    if (m_benchmarkFile.isEmpty()) {\n        return;\n    }\n\n    if (!QFile(m_benchmarkFile).exists()) {\n        qWarning() << \"The benchmark file was not pre-created.\";\n        return;\n    }\n\n    m_process = new QProcess();\n    m_process->start(\"fio\", QStringList()\n                     << QStringLiteral(\"--output-format=json\")\n                     << QStringLiteral(\"--ioengine=libaio\")\n                     << QStringLiteral(\"--randrepeat=0\")\n                     << QStringLiteral(\"--refill_buffers\")\n                     << QStringLiteral(\"--end_fsync=1\")\n                     << QStringLiteral(\"--direct=%1\").arg(cacheBypass)\n                     << QStringLiteral(\"--rwmixread=%1\").arg(randomReadPercentage)\n                     << QStringLiteral(\"--filename=%1\").arg(m_benchmarkFile)\n                     << QStringLiteral(\"--name=%1\").arg(rw)\n                     << QStringLiteral(\"--size=%1m\").arg(fileSize)\n                     << QStringLiteral(\"--zero_buffers=%1\").arg(fillZeros)\n                     << QStringLiteral(\"--bs=%1k\").arg(blockSize)\n                     << QStringLiteral(\"--runtime=%1\").arg(measuringTime)\n                     << QStringLiteral(\"--rw=%1\").arg(rw)\n                     << QStringLiteral(\"--iodepth=%1\").arg(queueDepth)\n                     << QStringLiteral(\"--numjobs=%1\").arg(threads));\n\n    connect(m_process, static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n            [=] (int exitCode, QProcess::ExitStatus exitStatus) {\n        emit taskFinished(exitStatus == QProcess::NormalExit, QString(m_process->readAllStandardOutput()), QString(m_process->readAllStandardError()));\n    });\n}",
    "includes": [
      "#include <signal.h>",
      "#include <PolkitQt1/Subject>",
      "#include <PolkitQt1/Authority>",
      "#include <QFile>",
      "#include <QtDBus>",
      "#include <QCoreApplication>",
      "#include \"helper.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "m_process",
            "static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished)",
            "[=] (int exitCode, QProcess::ExitStatus exitStatus) {\n        emit taskFinished(exitStatus == QProcess::NormalExit, QString(m_process->readAllStandardOutput()), QString(m_process->readAllStandardError()));\n    }"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "m_process->readAllStandardError()"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_process->readAllStandardError",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "m_process->readAllStandardOutput()"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_process->readAllStandardOutput",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<void",
          "args": [
            "&QProcess::finished"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "void",
          "args": [
            "int,QProcess::ExitStatus"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "void",
          "args": [
            "QProcess::*"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_process->start",
          "args": [
            "\"fio\"",
            "QStringList()\n                     << QStringLiteral(\"--output-format=json\")\n                     << QStringLiteral(\"--ioengine=libaio\")\n                     << QStringLiteral(\"--randrepeat=0\")\n                     << QStringLiteral(\"--refill_buffers\")\n                     << QStringLiteral(\"--end_fsync=1\")\n                     << QStringLiteral(\"--direct=%1\").arg(cacheBypass)\n                     << QStringLiteral(\"--rwmixread=%1\").arg(randomReadPercentage)\n                     << QStringLiteral(\"--filename=%1\").arg(m_benchmarkFile)\n                     << QStringLiteral(\"--name=%1\").arg(rw)\n                     << QStringLiteral(\"--size=%1m\").arg(fileSize)\n                     << QStringLiteral(\"--zero_buffers=%1\").arg(fillZeros)\n                     << QStringLiteral(\"--bs=%1k\").arg(blockSize)\n                     << QStringLiteral(\"--runtime=%1\").arg(measuringTime)\n                     << QStringLiteral(\"--rw=%1\").arg(rw)\n                     << QStringLiteral(\"--iodepth=%1\").arg(queueDepth)\n                     << QStringLiteral(\"--numjobs=%1\").arg(threads)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "threads"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--numjobs=%1\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "queueDepth"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--iodepth=%1\""
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "rw"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--rw=%1\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "measuringTime"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--runtime=%1\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "blockSize"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--bs=%1k\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "fillZeros"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--zero_buffers=%1\""
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "fileSize"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--size=%1m\""
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "rw"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--name=%1\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "m_benchmarkFile"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--filename=%1\""
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "randomReadPercentage"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--rwmixread=%1\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "cacheBypass"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--direct=%1\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--end_fsync=1\""
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--refill_buffers\""
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--randrepeat=0\""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--ioengine=libaio\""
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--output-format=json\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringList",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qWarning",
          "args": [],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QFile",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QFile",
          "args": [
            "m_benchmarkFile"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_benchmarkFile.isEmpty",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isCallerAuthorized",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "isCallerAuthorized",
          "container": "Helper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
          "lines": "247-291",
          "snippet": "bool Helper::isCallerAuthorized()\n{\n    if (!calledFromDBus()) {\n        return false;\n    }\n\n    if (m_serviceWatcher->watchedServices().contains(message().service())) {\n        return true;\n    }\n\n    if (!m_serviceWatcher->watchedServices().isEmpty()) {\n        qDebug() << \"There are already registered DBus connections.\";\n        return false;\n    }\n\n    PolkitQt1::SystemBusNameSubject subject(message().service());\n    PolkitQt1::Authority *authority = PolkitQt1::Authority::instance();\n\n    PolkitQt1::Authority::Result result;\n    QEventLoop e;\n    connect(authority, &PolkitQt1::Authority::checkAuthorizationFinished, &e, [&e, &result](PolkitQt1::Authority::Result _result) {\n        result = _result;\n        e.quit();\n    });\n\n    authority->checkAuthorization(QStringLiteral(\"dev.jonmagon.kdiskmark.helper.init\"), subject, PolkitQt1::Authority::AllowUserInteraction);\n    e.exec();\n\n    if (authority->hasError()) {\n        qDebug() << \"Encountered error while checking authorization, error code: \" << authority->lastError() << authority->errorDetails();\n        authority->clearError();\n    }\n\n    switch (result) {\n    case PolkitQt1::Authority::Yes:\n        // track who called into us so we can close when all callers have gone away\n        m_serviceWatcher->addWatchedService(message().service());\n        return true;\n    default:\n        sendErrorReply(QDBusError::AccessDenied);\n        if (m_serviceWatcher->watchedServices().isEmpty())\n            qApp->quit();\n        return false;\n    }\n}",
          "includes": [
            "#include <signal.h>",
            "#include <PolkitQt1/Subject>",
            "#include <PolkitQt1/Authority>",
            "#include <QFile>",
            "#include <QtDBus>",
            "#include <QCoreApplication>",
            "#include \"helper.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  bool Helper::isCallerAuthorized()\n  {\n      if (!calledFromDBus()) {\n          return false;\n      }\n  \n      if (m_serviceWatcher->watchedServices().contains(message().service())) {\n          return true;\n      }\n  \n      if (!m_serviceWatcher->watchedServices().isEmpty()) {\n          qDebug() << \"There are already registered DBus connections.\";\n          return false;\n      }\n  \n      PolkitQt1::SystemBusNameSubject subject(message().service());\n      PolkitQt1::Authority *authority = PolkitQt1::Authority::instance();\n  \n      PolkitQt1::Authority::Result result;\n      QEventLoop e;\n      connect(authority, &PolkitQt1::Authority::checkAuthorizationFinished, &e, [&e, &result](PolkitQt1::Authority::Result _result) {\n          result = _result;\n          e.quit();\n      });\n  \n      authority->checkAuthorization(QStringLiteral(\"dev.jonmagon.kdiskmark.helper.init\"), subject, PolkitQt1::Authority::AllowUserInteraction);\n      e.exec();\n  \n      if (authority->hasError()) {\n          qDebug() << \"Encountered error while checking authorization, error code: \" << authority->lastError() << authority->errorDetails();\n          authority->clearError();\n      }\n  \n      switch (result) {\n      case PolkitQt1::Authority::Yes:\n          // track who called into us so we can close when all callers have gone away\n          m_serviceWatcher->addWatchedService(message().service());\n          return true;\n      default:\n          sendErrorReply(QDBusError::AccessDenied);\n          if (m_serviceWatcher->watchedServices().isEmpty())\n              qApp->quit();\n          return false;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  void Helper::startBenchmarkTest(int measuringTime, int fileSize, int randomReadPercentage, bool fillZeros, bool cacheBypass,\n                                  int blockSize, int queueDepth, int threads, const QString &rw)\n  {\n      if (!isCallerAuthorized()) {\n          return;\n      }\n  \n      if (m_benchmarkFile.isEmpty()) {\n          return;\n      }\n  \n      if (!QFile(m_benchmarkFile).exists()) {\n          qWarning() << \"The benchmark file was not pre-created.\";\n          return;\n      }\n  \n      m_process = new QProcess();\n      m_process->start(\"fio\", QStringList()\n                       << QStringLiteral(\"--output-format=json\")\n                       << QStringLiteral(\"--ioengine=libaio\")\n                       << QStringLiteral(\"--randrepeat=0\")\n                       << QStringLiteral(\"--refill_buffers\")\n                       << QStringLiteral(\"--end_fsync=1\")\n                       << QStringLiteral(\"--direct=%1\").arg(cacheBypass)\n                       << QStringLiteral(\"--rwmixread=%1\").arg(randomReadPercentage)\n                       << QStringLiteral(\"--filename=%1\").arg(m_benchmarkFile)\n                       << QStringLiteral(\"--name=%1\").arg(rw)\n                       << QStringLiteral(\"--size=%1m\").arg(fileSize)\n                       << QStringLiteral(\"--zero_buffers=%1\").arg(fillZeros)\n                       << QStringLiteral(\"--bs=%1k\").arg(blockSize)\n                       << QStringLiteral(\"--runtime=%1\").arg(measuringTime)\n                       << QStringLiteral(\"--rw=%1\").arg(rw)\n                       << QStringLiteral(\"--iodepth=%1\").arg(queueDepth)\n                       << QStringLiteral(\"--numjobs=%1\").arg(threads));\n  \n      connect(m_process, static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n              [=] (int exitCode, QProcess::ExitStatus exitStatus) {\n          emit taskFinished(exitStatus == QProcess::NormalExit, QString(m_process->readAllStandardOutput()), QString(m_process->readAllStandardError()));\n      });\n  }\n}"
  },
  {
    "function_name": "prepareBenchmarkFile",
    "container": "Helper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
    "lines": "116-148",
    "snippet": "void Helper::prepareBenchmarkFile(const QString &benchmarkFile, int fileSize, bool fillZeros)\n{\n    if (!isCallerAuthorized()) {\n        return;\n    }\n\n    // If benchmarking has been done, but removeBenchmarkFile has not been called,\n    // and benchmarking on a new file is called, then reject the request. The *previous* file must be removed first.\n    if (!m_benchmarkFile.isEmpty()) {\n        qWarning() << \"The previous benchmarking was not completed correctly.\";\n        return;\n    }\n\n    if (!testFilePath(benchmarkFile)) {\n        return;\n    }\n\n    m_benchmarkFile = benchmarkFile;\n\n    m_process = new QProcess();\n    m_process->start(\"fio\", QStringList()\n                     << QStringLiteral(\"--output-format=json\")\n                     << QStringLiteral(\"--create_only=1\")\n                     << QStringLiteral(\"--filename=%1\").arg(m_benchmarkFile)\n                     << QStringLiteral(\"--size=%1m\").arg(fileSize)\n                     << QStringLiteral(\"--zero_buffers=%1\").arg(fillZeros)\n                     << QStringLiteral(\"--name=prepare\"));\n\n    connect(m_process, static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n            [=] (int exitCode, QProcess::ExitStatus exitStatus) {\n        emit taskFinished(exitStatus == QProcess::NormalExit, QString(m_process->readAllStandardOutput()), QString(m_process->readAllStandardError()));\n    });\n}",
    "includes": [
      "#include <signal.h>",
      "#include <PolkitQt1/Subject>",
      "#include <PolkitQt1/Authority>",
      "#include <QFile>",
      "#include <QtDBus>",
      "#include <QCoreApplication>",
      "#include \"helper.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "m_process",
            "static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished)",
            "[=] (int exitCode, QProcess::ExitStatus exitStatus) {\n        emit taskFinished(exitStatus == QProcess::NormalExit, QString(m_process->readAllStandardOutput()), QString(m_process->readAllStandardError()));\n    }"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "m_process->readAllStandardError()"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_process->readAllStandardError",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "m_process->readAllStandardOutput()"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_process->readAllStandardOutput",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<void",
          "args": [
            "&QProcess::finished"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "void",
          "args": [
            "int,QProcess::ExitStatus"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "void",
          "args": [
            "QProcess::*"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_process->start",
          "args": [
            "\"fio\"",
            "QStringList()\n                     << QStringLiteral(\"--output-format=json\")\n                     << QStringLiteral(\"--create_only=1\")\n                     << QStringLiteral(\"--filename=%1\").arg(m_benchmarkFile)\n                     << QStringLiteral(\"--size=%1m\").arg(fileSize)\n                     << QStringLiteral(\"--zero_buffers=%1\").arg(fillZeros)\n                     << QStringLiteral(\"--name=prepare\")"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--name=prepare\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "fillZeros"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--zero_buffers=%1\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "fileSize"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--size=%1m\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "m_benchmarkFile"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--filename=%1\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--create_only=1\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"--output-format=json\""
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringList",
          "args": [],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "testFilePath",
          "args": [
            "benchmarkFile"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qWarning",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_benchmarkFile.isEmpty",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isCallerAuthorized",
          "args": [],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "isCallerAuthorized",
          "container": "Helper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
          "lines": "247-291",
          "snippet": "bool Helper::isCallerAuthorized()\n{\n    if (!calledFromDBus()) {\n        return false;\n    }\n\n    if (m_serviceWatcher->watchedServices().contains(message().service())) {\n        return true;\n    }\n\n    if (!m_serviceWatcher->watchedServices().isEmpty()) {\n        qDebug() << \"There are already registered DBus connections.\";\n        return false;\n    }\n\n    PolkitQt1::SystemBusNameSubject subject(message().service());\n    PolkitQt1::Authority *authority = PolkitQt1::Authority::instance();\n\n    PolkitQt1::Authority::Result result;\n    QEventLoop e;\n    connect(authority, &PolkitQt1::Authority::checkAuthorizationFinished, &e, [&e, &result](PolkitQt1::Authority::Result _result) {\n        result = _result;\n        e.quit();\n    });\n\n    authority->checkAuthorization(QStringLiteral(\"dev.jonmagon.kdiskmark.helper.init\"), subject, PolkitQt1::Authority::AllowUserInteraction);\n    e.exec();\n\n    if (authority->hasError()) {\n        qDebug() << \"Encountered error while checking authorization, error code: \" << authority->lastError() << authority->errorDetails();\n        authority->clearError();\n    }\n\n    switch (result) {\n    case PolkitQt1::Authority::Yes:\n        // track who called into us so we can close when all callers have gone away\n        m_serviceWatcher->addWatchedService(message().service());\n        return true;\n    default:\n        sendErrorReply(QDBusError::AccessDenied);\n        if (m_serviceWatcher->watchedServices().isEmpty())\n            qApp->quit();\n        return false;\n    }\n}",
          "includes": [
            "#include <signal.h>",
            "#include <PolkitQt1/Subject>",
            "#include <PolkitQt1/Authority>",
            "#include <QFile>",
            "#include <QtDBus>",
            "#include <QCoreApplication>",
            "#include \"helper.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  bool Helper::isCallerAuthorized()\n  {\n      if (!calledFromDBus()) {\n          return false;\n      }\n  \n      if (m_serviceWatcher->watchedServices().contains(message().service())) {\n          return true;\n      }\n  \n      if (!m_serviceWatcher->watchedServices().isEmpty()) {\n          qDebug() << \"There are already registered DBus connections.\";\n          return false;\n      }\n  \n      PolkitQt1::SystemBusNameSubject subject(message().service());\n      PolkitQt1::Authority *authority = PolkitQt1::Authority::instance();\n  \n      PolkitQt1::Authority::Result result;\n      QEventLoop e;\n      connect(authority, &PolkitQt1::Authority::checkAuthorizationFinished, &e, [&e, &result](PolkitQt1::Authority::Result _result) {\n          result = _result;\n          e.quit();\n      });\n  \n      authority->checkAuthorization(QStringLiteral(\"dev.jonmagon.kdiskmark.helper.init\"), subject, PolkitQt1::Authority::AllowUserInteraction);\n      e.exec();\n  \n      if (authority->hasError()) {\n          qDebug() << \"Encountered error while checking authorization, error code: \" << authority->lastError() << authority->errorDetails();\n          authority->clearError();\n      }\n  \n      switch (result) {\n      case PolkitQt1::Authority::Yes:\n          // track who called into us so we can close when all callers have gone away\n          m_serviceWatcher->addWatchedService(message().service());\n          return true;\n      default:\n          sendErrorReply(QDBusError::AccessDenied);\n          if (m_serviceWatcher->watchedServices().isEmpty())\n              qApp->quit();\n          return false;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  void Helper::prepareBenchmarkFile(const QString &benchmarkFile, int fileSize, bool fillZeros)\n  {\n      if (!isCallerAuthorized()) {\n          return;\n      }\n  \n      // If benchmarking has been done, but removeBenchmarkFile has not been called,\n      // and benchmarking on a new file is called, then reject the request. The *previous* file must be removed first.\n      if (!m_benchmarkFile.isEmpty()) {\n          qWarning() << \"The previous benchmarking was not completed correctly.\";\n          return;\n      }\n  \n      if (!testFilePath(benchmarkFile)) {\n          return;\n      }\n  \n      m_benchmarkFile = benchmarkFile;\n  \n      m_process = new QProcess();\n      m_process->start(\"fio\", QStringList()\n                       << QStringLiteral(\"--output-format=json\")\n                       << QStringLiteral(\"--create_only=1\")\n                       << QStringLiteral(\"--filename=%1\").arg(m_benchmarkFile)\n                       << QStringLiteral(\"--size=%1m\").arg(fileSize)\n                       << QStringLiteral(\"--zero_buffers=%1\").arg(fillZeros)\n                       << QStringLiteral(\"--name=prepare\"));\n  \n      connect(m_process, static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n              [=] (int exitCode, QProcess::ExitStatus exitStatus) {\n          emit taskFinished(exitStatus == QProcess::NormalExit, QString(m_process->readAllStandardOutput()), QString(m_process->readAllStandardError()));\n      });\n  }\n}"
  },
  {
    "function_name": "listStorages",
    "container": "Helper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
    "lines": "97-114",
    "snippet": "QVariantMap Helper::listStorages()\n{\n    if (!isCallerAuthorized()) {\n        return {};\n    }\n\n    QVariantMap reply;\n    foreach (const QStorageInfo &storage, QStorageInfo::mountedVolumes()) {\n        if (storage.isValid() && storage.isReady() && !storage.isReadOnly()) {\n            if (storage.device().indexOf(\"/dev\") != -1) {\n                reply[storage.rootPath()] =\n                        QVariant::fromValue(QDBusVariant(QVariant::fromValue(QVector<qlonglong> { storage.bytesTotal(), storage.bytesAvailable() })));\n            }\n        }\n    }\n\n    return reply;\n}",
    "includes": [
      "#include <signal.h>",
      "#include <PolkitQt1/Subject>",
      "#include <PolkitQt1/Authority>",
      "#include <QFile>",
      "#include <QtDBus>",
      "#include <QCoreApplication>",
      "#include \"helper.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QVariant::fromValue",
          "args": [
            "QDBusVariant(QVariant::fromValue(QVector<qlonglong> { storage.bytesTotal(), storage.bytesAvailable() }))"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QDBusVariant",
          "args": [
            "QVariant::fromValue(QVector<qlonglong> { storage.bytesTotal(), storage.bytesAvailable() })"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QVariant::fromValue",
          "args": [
            "QVector<qlonglong> { storage.bytesTotal(), storage.bytesAvailable() }"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storage.bytesAvailable",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storage.bytesTotal",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storage.rootPath",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storage.device",
          "args": [
            "\"/dev\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storage.device",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storage.isReadOnly",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storage.isReady",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "storage.isValid",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isCallerAuthorized",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "isCallerAuthorized",
          "container": "Helper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
          "lines": "247-291",
          "snippet": "bool Helper::isCallerAuthorized()\n{\n    if (!calledFromDBus()) {\n        return false;\n    }\n\n    if (m_serviceWatcher->watchedServices().contains(message().service())) {\n        return true;\n    }\n\n    if (!m_serviceWatcher->watchedServices().isEmpty()) {\n        qDebug() << \"There are already registered DBus connections.\";\n        return false;\n    }\n\n    PolkitQt1::SystemBusNameSubject subject(message().service());\n    PolkitQt1::Authority *authority = PolkitQt1::Authority::instance();\n\n    PolkitQt1::Authority::Result result;\n    QEventLoop e;\n    connect(authority, &PolkitQt1::Authority::checkAuthorizationFinished, &e, [&e, &result](PolkitQt1::Authority::Result _result) {\n        result = _result;\n        e.quit();\n    });\n\n    authority->checkAuthorization(QStringLiteral(\"dev.jonmagon.kdiskmark.helper.init\"), subject, PolkitQt1::Authority::AllowUserInteraction);\n    e.exec();\n\n    if (authority->hasError()) {\n        qDebug() << \"Encountered error while checking authorization, error code: \" << authority->lastError() << authority->errorDetails();\n        authority->clearError();\n    }\n\n    switch (result) {\n    case PolkitQt1::Authority::Yes:\n        // track who called into us so we can close when all callers have gone away\n        m_serviceWatcher->addWatchedService(message().service());\n        return true;\n    default:\n        sendErrorReply(QDBusError::AccessDenied);\n        if (m_serviceWatcher->watchedServices().isEmpty())\n            qApp->quit();\n        return false;\n    }\n}",
          "includes": [
            "#include <signal.h>",
            "#include <PolkitQt1/Subject>",
            "#include <PolkitQt1/Authority>",
            "#include <QFile>",
            "#include <QtDBus>",
            "#include <QCoreApplication>",
            "#include \"helper.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  bool Helper::isCallerAuthorized()\n  {\n      if (!calledFromDBus()) {\n          return false;\n      }\n  \n      if (m_serviceWatcher->watchedServices().contains(message().service())) {\n          return true;\n      }\n  \n      if (!m_serviceWatcher->watchedServices().isEmpty()) {\n          qDebug() << \"There are already registered DBus connections.\";\n          return false;\n      }\n  \n      PolkitQt1::SystemBusNameSubject subject(message().service());\n      PolkitQt1::Authority *authority = PolkitQt1::Authority::instance();\n  \n      PolkitQt1::Authority::Result result;\n      QEventLoop e;\n      connect(authority, &PolkitQt1::Authority::checkAuthorizationFinished, &e, [&e, &result](PolkitQt1::Authority::Result _result) {\n          result = _result;\n          e.quit();\n      });\n  \n      authority->checkAuthorization(QStringLiteral(\"dev.jonmagon.kdiskmark.helper.init\"), subject, PolkitQt1::Authority::AllowUserInteraction);\n      e.exec();\n  \n      if (authority->hasError()) {\n          qDebug() << \"Encountered error while checking authorization, error code: \" << authority->lastError() << authority->errorDetails();\n          authority->clearError();\n      }\n  \n      switch (result) {\n      case PolkitQt1::Authority::Yes:\n          // track who called into us so we can close when all callers have gone away\n          m_serviceWatcher->addWatchedService(message().service());\n          return true;\n      default:\n          sendErrorReply(QDBusError::AccessDenied);\n          if (m_serviceWatcher->watchedServices().isEmpty())\n              qApp->quit();\n          return false;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  QVariantMap Helper::listStorages()\n  {\n      if (!isCallerAuthorized()) {\n          return {};\n      }\n  \n      QVariantMap reply;\n      foreach (const QStorageInfo &storage, QStorageInfo::mountedVolumes()) {\n          if (storage.isValid() && storage.isReady() && !storage.isReadOnly()) {\n              if (storage.device().indexOf(\"/dev\") != -1) {\n                  reply[storage.rootPath()] =\n                          QVariant::fromValue(QDBusVariant(QVariant::fromValue(QVector<qlonglong> { storage.bytesTotal(), storage.bytesAvailable() })));\n              }\n          }\n      }\n  \n      return reply;\n  }\n}"
  },
  {
    "function_name": "Helper",
    "container": "Helper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
    "lines": "48-68",
    "snippet": "Helper::Helper() : m_helperAdaptor(new HelperAdaptor(this))\n{\n    if (!QDBusConnection::systemBus().isConnected() || !QDBusConnection::systemBus().registerService(QStringLiteral(\"dev.jonmagon.kdiskmark.helperinterface\")) ||\n        !QDBusConnection::systemBus().registerObject(QStringLiteral(\"/Helper\"), this)) {\n        qWarning() << QDBusConnection::systemBus().lastError().message();\n        qApp->quit();\n    }\n\n    m_serviceWatcher = new QDBusServiceWatcher(this);\n    m_serviceWatcher->setConnection(QDBusConnection ::systemBus());\n    m_serviceWatcher->setWatchMode(QDBusServiceWatcher::WatchForUnregistration);\n\n    connect(m_serviceWatcher, &QDBusServiceWatcher::serviceUnregistered, qApp, [this](const QString &service) {\n        m_serviceWatcher->removeWatchedService(service);\n        if (m_serviceWatcher->watchedServices().isEmpty()) {\n            qApp->quit();\n        }\n    });\n\n    QObject::connect(this, &Helper::taskFinished, m_helperAdaptor, &HelperAdaptor::taskFinished);\n}",
    "includes": [
      "#include <signal.h>",
      "#include <PolkitQt1/Subject>",
      "#include <PolkitQt1/Authority>",
      "#include <QFile>",
      "#include <QtDBus>",
      "#include <QCoreApplication>",
      "#include \"helper.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QObject::connect",
          "args": [
            "this",
            "&Helper::taskFinished",
            "m_helperAdaptor",
            "&HelperAdaptor::taskFinished"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "m_serviceWatcher",
            "&QDBusServiceWatcher::serviceUnregistered",
            "qApp",
            "[this](const QString &service) {\n        m_serviceWatcher->removeWatchedService(service);\n        if (m_serviceWatcher->watchedServices().isEmpty()) {\n            qApp->quit();\n        }\n    }"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qApp->quit",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_serviceWatcher->watchedServices",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_serviceWatcher->watchedServices",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_serviceWatcher->removeWatchedService",
          "args": [
            "service"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_serviceWatcher->setWatchMode",
          "args": [
            "QDBusServiceWatcher::WatchForUnregistration"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_serviceWatcher->setConnection",
          "args": [
            "QDBusConnection ::systemBus()"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QDBusConnection ::systemBus",
          "args": [],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qApp->quit",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QDBusConnection::systemBus",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QDBusConnection::systemBus",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QDBusConnection::systemBus",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qWarning",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QDBusConnection::systemBus",
          "args": [
            "QStringLiteral(\"/Helper\")",
            "this"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"/Helper\""
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QDBusConnection::systemBus",
          "args": [],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QDBusConnection::systemBus",
          "args": [
            "QStringLiteral(\"dev.jonmagon.kdiskmark.helperinterface\")"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringLiteral",
          "args": [
            "\"dev.jonmagon.kdiskmark.helperinterface\""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QDBusConnection::systemBus",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QDBusConnection::systemBus",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QDBusConnection::systemBus",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  Helper::Helper() : m_helperAdaptor(new HelperAdaptor(this))\n  {\n      if (!QDBusConnection::systemBus().isConnected() || !QDBusConnection::systemBus().registerService(QStringLiteral(\"dev.jonmagon.kdiskmark.helperinterface\")) ||\n          !QDBusConnection::systemBus().registerObject(QStringLiteral(\"/Helper\"), this)) {\n          qWarning() << QDBusConnection::systemBus().lastError().message();\n          qApp->quit();\n      }\n  \n      m_serviceWatcher = new QDBusServiceWatcher(this);\n      m_serviceWatcher->setConnection(QDBusConnection ::systemBus());\n      m_serviceWatcher->setWatchMode(QDBusServiceWatcher::WatchForUnregistration);\n  \n      connect(m_serviceWatcher, &QDBusServiceWatcher::serviceUnregistered, qApp, [this](const QString &service) {\n          m_serviceWatcher->removeWatchedService(service);\n          if (m_serviceWatcher->watchedServices().isEmpty()) {\n              qApp->quit();\n          }\n      });\n  \n      QObject::connect(this, &Helper::taskFinished, m_helperAdaptor, &HelperAdaptor::taskFinished);\n  }\n}"
  },
  {
    "function_name": "stopCurrentTask",
    "container": "HelperAdaptor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
    "lines": "43-46",
    "snippet": "void HelperAdaptor::stopCurrentTask()\n{\n    m_parentHelper->stopCurrentTask();\n}",
    "includes": [
      "#include <signal.h>",
      "#include <PolkitQt1/Subject>",
      "#include <PolkitQt1/Authority>",
      "#include <QFile>",
      "#include <QtDBus>",
      "#include <QCoreApplication>",
      "#include \"helper.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_parentHelper->stopCurrentTask",
          "args": [],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "stopCurrentTask",
          "container": "Helper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
          "lines": "231-245",
          "snippet": "void Helper::stopCurrentTask()\n{\n    if (!isCallerAuthorized()) {\n        return;\n    }\n\n    if (!m_process) return;\n\n    if (m_process->state() == QProcess::Running || m_process->state() == QProcess::Starting) {\n        m_process->terminate();\n        m_process->waitForFinished(-1);\n    }\n\n    delete m_process;\n}",
          "includes": [
            "#include <signal.h>",
            "#include <PolkitQt1/Subject>",
            "#include <PolkitQt1/Authority>",
            "#include <QFile>",
            "#include <QtDBus>",
            "#include <QCoreApplication>",
            "#include \"helper.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  void Helper::stopCurrentTask()\n  {\n      if (!isCallerAuthorized()) {\n          return;\n      }\n  \n      if (!m_process) return;\n  \n      if (m_process->state() == QProcess::Running || m_process->state() == QProcess::Starting) {\n          m_process->terminate();\n          m_process->waitForFinished(-1);\n      }\n  \n      delete m_process;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelperAdaptor {\n  void HelperAdaptor::stopCurrentTask()\n  {\n      m_parentHelper->stopCurrentTask();\n  }\n}"
  },
  {
    "function_name": "removeBenchmarkFile",
    "container": "HelperAdaptor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
    "lines": "38-41",
    "snippet": "bool HelperAdaptor::removeBenchmarkFile()\n{\n    return m_parentHelper->removeBenchmarkFile();\n}",
    "includes": [
      "#include <signal.h>",
      "#include <PolkitQt1/Subject>",
      "#include <PolkitQt1/Authority>",
      "#include <QFile>",
      "#include <QtDBus>",
      "#include <QCoreApplication>",
      "#include \"helper.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_parentHelper->removeBenchmarkFile",
          "args": [],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "removeBenchmarkFile",
          "container": "Helper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
          "lines": "215-229",
          "snippet": "bool Helper::removeBenchmarkFile()\n{\n    if (!isCallerAuthorized()) {\n        return false;\n    }\n\n    if (m_benchmarkFile.isEmpty()) {\n        return false;\n    }\n\n    bool deletionState = QFile(m_benchmarkFile).remove();\n    m_benchmarkFile.clear();\n\n    return deletionState;\n}",
          "includes": [
            "#include <signal.h>",
            "#include <PolkitQt1/Subject>",
            "#include <PolkitQt1/Authority>",
            "#include <QFile>",
            "#include <QtDBus>",
            "#include <QCoreApplication>",
            "#include \"helper.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  bool Helper::removeBenchmarkFile()\n  {\n      if (!isCallerAuthorized()) {\n          return false;\n      }\n  \n      if (m_benchmarkFile.isEmpty()) {\n          return false;\n      }\n  \n      bool deletionState = QFile(m_benchmarkFile).remove();\n      m_benchmarkFile.clear();\n  \n      return deletionState;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelperAdaptor {\n  bool HelperAdaptor::removeBenchmarkFile()\n  {\n      return m_parentHelper->removeBenchmarkFile();\n  }\n}"
  },
  {
    "function_name": "flushPageCache",
    "container": "HelperAdaptor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
    "lines": "33-36",
    "snippet": "QVariantMap HelperAdaptor::flushPageCache()\n{\n    return m_parentHelper->flushPageCache();\n}",
    "includes": [
      "#include <signal.h>",
      "#include <PolkitQt1/Subject>",
      "#include <PolkitQt1/Authority>",
      "#include <QFile>",
      "#include <QtDBus>",
      "#include <QCoreApplication>",
      "#include \"helper.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_parentHelper->flushPageCache",
          "args": [],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "flushPageCache",
          "container": "Helper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
          "lines": "191-213",
          "snippet": "QVariantMap Helper::flushPageCache()\n{\n    QVariantMap reply;\n    reply[QStringLiteral(\"success\")] = true;\n\n    if (!isCallerAuthorized()) {\n        reply[QStringLiteral(\"success\")] = false;\n        return reply;\n    }\n\n    QFile file(\"/proc/sys/vm/drop_caches\");\n\n    if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {\n        file.write(\"1\");\n        file.close();\n    }\n    else {\n        reply[QStringLiteral(\"success\")] = false;\n        reply[QStringLiteral(\"error\")] = file.errorString();\n    }\n\n    return reply;\n}",
          "includes": [
            "#include <signal.h>",
            "#include <PolkitQt1/Subject>",
            "#include <PolkitQt1/Authority>",
            "#include <QFile>",
            "#include <QtDBus>",
            "#include <QCoreApplication>",
            "#include \"helper.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  QVariantMap Helper::flushPageCache()\n  {\n      QVariantMap reply;\n      reply[QStringLiteral(\"success\")] = true;\n  \n      if (!isCallerAuthorized()) {\n          reply[QStringLiteral(\"success\")] = false;\n          return reply;\n      }\n  \n      QFile file(\"/proc/sys/vm/drop_caches\");\n  \n      if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {\n          file.write(\"1\");\n          file.close();\n      }\n      else {\n          reply[QStringLiteral(\"success\")] = false;\n          reply[QStringLiteral(\"error\")] = file.errorString();\n      }\n  \n      return reply;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelperAdaptor {\n  QVariantMap HelperAdaptor::flushPageCache()\n  {\n      return m_parentHelper->flushPageCache();\n  }\n}"
  },
  {
    "function_name": "startBenchmarkTest",
    "container": "HelperAdaptor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
    "lines": "27-31",
    "snippet": "void HelperAdaptor::startBenchmarkTest(int measuringTime, int fileSize, int randomReadPercentage, bool fillZeros, bool cacheBypass,\n                                       int blockSize, int queueDepth, int threads, const QString &rw)\n{\n    m_parentHelper->startBenchmarkTest(measuringTime, fileSize, randomReadPercentage, fillZeros, cacheBypass, blockSize, queueDepth, threads, rw);\n}",
    "includes": [
      "#include <signal.h>",
      "#include <PolkitQt1/Subject>",
      "#include <PolkitQt1/Authority>",
      "#include <QFile>",
      "#include <QtDBus>",
      "#include <QCoreApplication>",
      "#include \"helper.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_parentHelper->startBenchmarkTest",
          "args": [
            "measuringTime",
            "fileSize",
            "randomReadPercentage",
            "fillZeros",
            "cacheBypass",
            "blockSize",
            "queueDepth",
            "threads",
            "rw"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "startBenchmarkTest",
          "container": "Helper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
          "lines": "150-189",
          "snippet": "void Helper::startBenchmarkTest(int measuringTime, int fileSize, int randomReadPercentage, bool fillZeros, bool cacheBypass,\n                                int blockSize, int queueDepth, int threads, const QString &rw)\n{\n    if (!isCallerAuthorized()) {\n        return;\n    }\n\n    if (m_benchmarkFile.isEmpty()) {\n        return;\n    }\n\n    if (!QFile(m_benchmarkFile).exists()) {\n        qWarning() << \"The benchmark file was not pre-created.\";\n        return;\n    }\n\n    m_process = new QProcess();\n    m_process->start(\"fio\", QStringList()\n                     << QStringLiteral(\"--output-format=json\")\n                     << QStringLiteral(\"--ioengine=libaio\")\n                     << QStringLiteral(\"--randrepeat=0\")\n                     << QStringLiteral(\"--refill_buffers\")\n                     << QStringLiteral(\"--end_fsync=1\")\n                     << QStringLiteral(\"--direct=%1\").arg(cacheBypass)\n                     << QStringLiteral(\"--rwmixread=%1\").arg(randomReadPercentage)\n                     << QStringLiteral(\"--filename=%1\").arg(m_benchmarkFile)\n                     << QStringLiteral(\"--name=%1\").arg(rw)\n                     << QStringLiteral(\"--size=%1m\").arg(fileSize)\n                     << QStringLiteral(\"--zero_buffers=%1\").arg(fillZeros)\n                     << QStringLiteral(\"--bs=%1k\").arg(blockSize)\n                     << QStringLiteral(\"--runtime=%1\").arg(measuringTime)\n                     << QStringLiteral(\"--rw=%1\").arg(rw)\n                     << QStringLiteral(\"--iodepth=%1\").arg(queueDepth)\n                     << QStringLiteral(\"--numjobs=%1\").arg(threads));\n\n    connect(m_process, static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n            [=] (int exitCode, QProcess::ExitStatus exitStatus) {\n        emit taskFinished(exitStatus == QProcess::NormalExit, QString(m_process->readAllStandardOutput()), QString(m_process->readAllStandardError()));\n    });\n}",
          "includes": [
            "#include <signal.h>",
            "#include <PolkitQt1/Subject>",
            "#include <PolkitQt1/Authority>",
            "#include <QFile>",
            "#include <QtDBus>",
            "#include <QCoreApplication>",
            "#include \"helper.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  void Helper::startBenchmarkTest(int measuringTime, int fileSize, int randomReadPercentage, bool fillZeros, bool cacheBypass,\n                                  int blockSize, int queueDepth, int threads, const QString &rw)\n  {\n      if (!isCallerAuthorized()) {\n          return;\n      }\n  \n      if (m_benchmarkFile.isEmpty()) {\n          return;\n      }\n  \n      if (!QFile(m_benchmarkFile).exists()) {\n          qWarning() << \"The benchmark file was not pre-created.\";\n          return;\n      }\n  \n      m_process = new QProcess();\n      m_process->start(\"fio\", QStringList()\n                       << QStringLiteral(\"--output-format=json\")\n                       << QStringLiteral(\"--ioengine=libaio\")\n                       << QStringLiteral(\"--randrepeat=0\")\n                       << QStringLiteral(\"--refill_buffers\")\n                       << QStringLiteral(\"--end_fsync=1\")\n                       << QStringLiteral(\"--direct=%1\").arg(cacheBypass)\n                       << QStringLiteral(\"--rwmixread=%1\").arg(randomReadPercentage)\n                       << QStringLiteral(\"--filename=%1\").arg(m_benchmarkFile)\n                       << QStringLiteral(\"--name=%1\").arg(rw)\n                       << QStringLiteral(\"--size=%1m\").arg(fileSize)\n                       << QStringLiteral(\"--zero_buffers=%1\").arg(fillZeros)\n                       << QStringLiteral(\"--bs=%1k\").arg(blockSize)\n                       << QStringLiteral(\"--runtime=%1\").arg(measuringTime)\n                       << QStringLiteral(\"--rw=%1\").arg(rw)\n                       << QStringLiteral(\"--iodepth=%1\").arg(queueDepth)\n                       << QStringLiteral(\"--numjobs=%1\").arg(threads));\n  \n      connect(m_process, static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n              [=] (int exitCode, QProcess::ExitStatus exitStatus) {\n          emit taskFinished(exitStatus == QProcess::NormalExit, QString(m_process->readAllStandardOutput()), QString(m_process->readAllStandardError()));\n      });\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelperAdaptor {\n  void HelperAdaptor::startBenchmarkTest(int measuringTime, int fileSize, int randomReadPercentage, bool fillZeros, bool cacheBypass,\n                                         int blockSize, int queueDepth, int threads, const QString &rw)\n  {\n      m_parentHelper->startBenchmarkTest(measuringTime, fileSize, randomReadPercentage, fillZeros, cacheBypass, blockSize, queueDepth, threads, rw);\n  }\n}"
  },
  {
    "function_name": "prepareBenchmarkFile",
    "container": "HelperAdaptor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
    "lines": "22-25",
    "snippet": "void HelperAdaptor::prepareBenchmarkFile(const QString &benchmarkFile, int fileSize, bool fillZeros)\n{\n    return m_parentHelper->prepareBenchmarkFile(benchmarkFile, fileSize, fillZeros);\n}",
    "includes": [
      "#include <signal.h>",
      "#include <PolkitQt1/Subject>",
      "#include <PolkitQt1/Authority>",
      "#include <QFile>",
      "#include <QtDBus>",
      "#include <QCoreApplication>",
      "#include \"helper.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_parentHelper->prepareBenchmarkFile",
          "args": [
            "benchmarkFile",
            "fileSize",
            "fillZeros"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "prepareBenchmarkFile",
          "container": "Helper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
          "lines": "116-148",
          "snippet": "void Helper::prepareBenchmarkFile(const QString &benchmarkFile, int fileSize, bool fillZeros)\n{\n    if (!isCallerAuthorized()) {\n        return;\n    }\n\n    // If benchmarking has been done, but removeBenchmarkFile has not been called,\n    // and benchmarking on a new file is called, then reject the request. The *previous* file must be removed first.\n    if (!m_benchmarkFile.isEmpty()) {\n        qWarning() << \"The previous benchmarking was not completed correctly.\";\n        return;\n    }\n\n    if (!testFilePath(benchmarkFile)) {\n        return;\n    }\n\n    m_benchmarkFile = benchmarkFile;\n\n    m_process = new QProcess();\n    m_process->start(\"fio\", QStringList()\n                     << QStringLiteral(\"--output-format=json\")\n                     << QStringLiteral(\"--create_only=1\")\n                     << QStringLiteral(\"--filename=%1\").arg(m_benchmarkFile)\n                     << QStringLiteral(\"--size=%1m\").arg(fileSize)\n                     << QStringLiteral(\"--zero_buffers=%1\").arg(fillZeros)\n                     << QStringLiteral(\"--name=prepare\"));\n\n    connect(m_process, static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n            [=] (int exitCode, QProcess::ExitStatus exitStatus) {\n        emit taskFinished(exitStatus == QProcess::NormalExit, QString(m_process->readAllStandardOutput()), QString(m_process->readAllStandardError()));\n    });\n}",
          "includes": [
            "#include <signal.h>",
            "#include <PolkitQt1/Subject>",
            "#include <PolkitQt1/Authority>",
            "#include <QFile>",
            "#include <QtDBus>",
            "#include <QCoreApplication>",
            "#include \"helper.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  void Helper::prepareBenchmarkFile(const QString &benchmarkFile, int fileSize, bool fillZeros)\n  {\n      if (!isCallerAuthorized()) {\n          return;\n      }\n  \n      // If benchmarking has been done, but removeBenchmarkFile has not been called,\n      // and benchmarking on a new file is called, then reject the request. The *previous* file must be removed first.\n      if (!m_benchmarkFile.isEmpty()) {\n          qWarning() << \"The previous benchmarking was not completed correctly.\";\n          return;\n      }\n  \n      if (!testFilePath(benchmarkFile)) {\n          return;\n      }\n  \n      m_benchmarkFile = benchmarkFile;\n  \n      m_process = new QProcess();\n      m_process->start(\"fio\", QStringList()\n                       << QStringLiteral(\"--output-format=json\")\n                       << QStringLiteral(\"--create_only=1\")\n                       << QStringLiteral(\"--filename=%1\").arg(m_benchmarkFile)\n                       << QStringLiteral(\"--size=%1m\").arg(fileSize)\n                       << QStringLiteral(\"--zero_buffers=%1\").arg(fillZeros)\n                       << QStringLiteral(\"--name=prepare\"));\n  \n      connect(m_process, static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n              [=] (int exitCode, QProcess::ExitStatus exitStatus) {\n          emit taskFinished(exitStatus == QProcess::NormalExit, QString(m_process->readAllStandardOutput()), QString(m_process->readAllStandardError()));\n      });\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelperAdaptor {\n  void HelperAdaptor::prepareBenchmarkFile(const QString &benchmarkFile, int fileSize, bool fillZeros)\n  {\n      return m_parentHelper->prepareBenchmarkFile(benchmarkFile, fileSize, fillZeros);\n  }\n}"
  },
  {
    "function_name": "listStorages",
    "container": "HelperAdaptor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
    "lines": "17-20",
    "snippet": "QVariantMap HelperAdaptor::listStorages()\n{\n    return m_parentHelper->listStorages();\n}",
    "includes": [
      "#include <signal.h>",
      "#include <PolkitQt1/Subject>",
      "#include <PolkitQt1/Authority>",
      "#include <QFile>",
      "#include <QtDBus>",
      "#include <QCoreApplication>",
      "#include \"helper.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_parentHelper->listStorages",
          "args": [],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "listStorages",
          "container": "Helper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
          "lines": "97-114",
          "snippet": "QVariantMap Helper::listStorages()\n{\n    if (!isCallerAuthorized()) {\n        return {};\n    }\n\n    QVariantMap reply;\n    foreach (const QStorageInfo &storage, QStorageInfo::mountedVolumes()) {\n        if (storage.isValid() && storage.isReady() && !storage.isReadOnly()) {\n            if (storage.device().indexOf(\"/dev\") != -1) {\n                reply[storage.rootPath()] =\n                        QVariant::fromValue(QDBusVariant(QVariant::fromValue(QVector<qlonglong> { storage.bytesTotal(), storage.bytesAvailable() })));\n            }\n        }\n    }\n\n    return reply;\n}",
          "includes": [
            "#include <signal.h>",
            "#include <PolkitQt1/Subject>",
            "#include <PolkitQt1/Authority>",
            "#include <QFile>",
            "#include <QtDBus>",
            "#include <QCoreApplication>",
            "#include \"helper.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelper {\n  QVariantMap Helper::listStorages()\n  {\n      if (!isCallerAuthorized()) {\n          return {};\n      }\n  \n      QVariantMap reply;\n      foreach (const QStorageInfo &storage, QStorageInfo::mountedVolumes()) {\n          if (storage.isValid() && storage.isReady() && !storage.isReadOnly()) {\n              if (storage.device().indexOf(\"/dev\") != -1) {\n                  reply[storage.rootPath()] =\n                          QVariant::fromValue(QDBusVariant(QVariant::fromValue(QVector<qlonglong> { storage.bytesTotal(), storage.bytesAvailable() })));\n              }\n          }\n      }\n  \n      return reply;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelperAdaptor {\n  QVariantMap HelperAdaptor::listStorages()\n  {\n      return m_parentHelper->listStorages();\n  }\n}"
  },
  {
    "function_name": "HelperAdaptor",
    "container": "HelperAdaptor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2022-40673/repo/src/helper.cpp",
    "lines": "11-15",
    "snippet": "HelperAdaptor::HelperAdaptor(Helper *parent) :\n    QDBusAbstractAdaptor(parent)\n{\n    m_parentHelper = parent;\n}",
    "includes": [
      "#include <signal.h>",
      "#include <PolkitQt1/Subject>",
      "#include <PolkitQt1/Authority>",
      "#include <QFile>",
      "#include <QtDBus>",
      "#include <QCoreApplication>",
      "#include \"helper.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <signal.h>\n#include <PolkitQt1/Subject>\n#include <PolkitQt1/Authority>\n#include <QFile>\n#include <QtDBus>\n#include <QCoreApplication>\n#include \"helper.h\"\n\nHelperAdaptor {\n  HelperAdaptor::HelperAdaptor(Helper *parent) :\n      QDBusAbstractAdaptor(parent)\n  {\n      m_parentHelper = parent;\n  }\n}"
  }
]