[
  {
    "function_name": "_af_ms_adpcm_format_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
    "lines": "455-479",
    "snippet": "bool _af_ms_adpcm_format_ok (AudioFormat *f)\n{\n\tif (f->channelCount != 1 && f->channelCount != 2)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"MS ADPCM compression requires 1 or 2 channels\");\n\t\treturn false;\n\t}\n\n\tif (f->sampleFormat != AF_SAMPFMT_TWOSCOMP || f->sampleWidth != 16)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"MS ADPCM compression requires 16-bit signed integer format\");\n\t\treturn false;\n\t}\n\n\tif (f->byteOrder != _AF_BYTEORDER_NATIVE)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"MS ADPCM compression requires native byte order\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <string.h>",
      "#include <limits>",
      "#include <cstdlib>",
      "#include <assert.h>",
      "#include \"MSADPCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_COMPRESSION",
            "\"MS ADPCM compression requires native byte order\""
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_COMPRESSION",
            "\"MS ADPCM compression requires 16-bit signed integer format\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_COMPRESSION",
            "\"MS ADPCM compression requires 1 or 2 channels\""
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nbool _af_ms_adpcm_format_ok (AudioFormat *f)\n{\n\tif (f->channelCount != 1 && f->channelCount != 2)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"MS ADPCM compression requires 1 or 2 channels\");\n\t\treturn false;\n\t}\n\n\tif (f->sampleFormat != AF_SAMPFMT_TWOSCOMP || f->sampleWidth != 16)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"MS ADPCM compression requires 16-bit signed integer format\");\n\t\treturn false;\n\t}\n\n\tif (f->byteOrder != _AF_BYTEORDER_NATIVE)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"MS ADPCM compression requires native byte order\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "initializeCoefficients",
    "container": "MSADPCM",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
    "lines": "390-417",
    "snippet": "bool MSADPCM::initializeCoefficients()\n{\n\tAUpvlist pv = m_track->f.compressionParams;\n\n\tlong l;\n\tif (_af_pv_getlong(pv, _AF_MS_ADPCM_NUM_COEFFICIENTS, &l))\n\t{\n\t\tm_numCoefficients = l;\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"number of coefficients not set\");\n\t\treturn false;\n\t}\n\n\tvoid *v;\n\tif (_af_pv_getptr(pv, _AF_MS_ADPCM_COEFFICIENTS, &v))\n\t{\n\t\tmemcpy(m_coefficients, v, m_numCoefficients * 2 * sizeof (int16_t));\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"coefficient array not set\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <string.h>",
      "#include <limits>",
      "#include <cstdlib>",
      "#include <assert.h>",
      "#include \"MSADPCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_CODEC_CONFIG",
            "\"coefficient array not set\""
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_coefficients",
            "v",
            "m_numCoefficients * 2 * sizeof (int16_t)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_pv_getptr",
          "args": [
            "pv",
            "_AF_MS_ADPCM_COEFFICIENTS",
            "&v"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "_af_pv_getptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "239-261",
          "snippet": "bool _af_pv_getptr (AUpvlist pvlist, int param, void **v)\n{\n\tfor (int i=0; i<AUpvgetmaxitems(pvlist); i++)\n\t{\n\t\tint\tp, t;\n\n\t\tAUpvgetparam(pvlist, i, &p);\n\n\t\tif (p != param)\n\t\t\tcontinue;\n\n\t\tAUpvgetvaltype(pvlist, i, &t);\n\n\t\t/* Ensure that this parameter is of type AU_PVTYPE_PTR. */\n\t\tif (t != AU_PVTYPE_PTR)\n\t\t\treturn false;\n\n\t\tAUpvgetval(pvlist, i, v);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nbool _af_pv_getptr (AUpvlist pvlist, int param, void **v)\n{\n\tfor (int i=0; i<AUpvgetmaxitems(pvlist); i++)\n\t{\n\t\tint\tp, t;\n\n\t\tAUpvgetparam(pvlist, i, &p);\n\n\t\tif (p != param)\n\t\t\tcontinue;\n\n\t\tAUpvgetvaltype(pvlist, i, &t);\n\n\t\t/* Ensure that this parameter is of type AU_PVTYPE_PTR. */\n\t\tif (t != AU_PVTYPE_PTR)\n\t\t\treturn false;\n\n\t\tAUpvgetval(pvlist, i, v);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_CODEC_CONFIG",
            "\"number of coefficients not set\""
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_pv_getlong",
          "args": [
            "pv",
            "_AF_MS_ADPCM_NUM_COEFFICIENTS",
            "&l"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "_af_pv_getlong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "191-213",
          "snippet": "bool _af_pv_getlong (AUpvlist pvlist, int param, long *l)\n{\n\tfor (int i=0; i<AUpvgetmaxitems(pvlist); i++)\n\t{\n\t\tint\tp, t;\n\n\t\tAUpvgetparam(pvlist, i, &p);\n\n\t\tif (p != param)\n\t\t\tcontinue;\n\n\t\tAUpvgetvaltype(pvlist, i, &t);\n\n\t\t/* Ensure that this parameter is of type AU_PVTYPE_LONG. */\n\t\tif (t != AU_PVTYPE_LONG)\n\t\t\treturn false;\n\n\t\tAUpvgetval(pvlist, i, l);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nbool _af_pv_getlong (AUpvlist pvlist, int param, long *l)\n{\n\tfor (int i=0; i<AUpvgetmaxitems(pvlist); i++)\n\t{\n\t\tint\tp, t;\n\n\t\tAUpvgetparam(pvlist, i, &p);\n\n\t\tif (p != param)\n\t\t\tcontinue;\n\n\t\tAUpvgetvaltype(pvlist, i, &t);\n\n\t\t/* Ensure that this parameter is of type AU_PVTYPE_LONG. */\n\t\tif (t != AU_PVTYPE_LONG)\n\t\t\treturn false;\n\n\t\tAUpvgetval(pvlist, i, l);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nMSADPCM {\n  bool MSADPCM::initializeCoefficients()\n  {\n  \tAUpvlist pv = m_track->f.compressionParams;\n  \n  \tlong l;\n  \tif (_af_pv_getlong(pv, _AF_MS_ADPCM_NUM_COEFFICIENTS, &l))\n  \t{\n  \t\tm_numCoefficients = l;\n  \t}\n  \telse\n  \t{\n  \t\t_af_error(AF_BAD_CODEC_CONFIG, \"number of coefficients not set\");\n  \t\treturn false;\n  \t}\n  \n  \tvoid *v;\n  \tif (_af_pv_getptr(pv, _AF_MS_ADPCM_COEFFICIENTS, &v))\n  \t{\n  \t\tmemcpy(m_coefficients, v, m_numCoefficients * 2 * sizeof (int16_t));\n  \t}\n  \telse\n  \t{\n  \t\t_af_error(AF_BAD_CODEC_CONFIG, \"coefficient array not set\");\n  \t\treturn false;\n  \t}\n  \n  \treturn true;\n  }\n}"
  },
  {
    "function_name": "~MSADPCM",
    "container": "MSADPCM",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
    "lines": "385-388",
    "snippet": "MSADPCM::~MSADPCM()\n{\n\tdelete [] m_state;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <string.h>",
      "#include <limits>",
      "#include <cstdlib>",
      "#include <assert.h>",
      "#include \"MSADPCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nMSADPCM {\n  MSADPCM::~MSADPCM()\n  {\n  \tdelete [] m_state;\n  }\n}"
  },
  {
    "function_name": "MSADPCM",
    "container": "MSADPCM",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
    "lines": "377-383",
    "snippet": "MSADPCM::MSADPCM(Mode mode, Track *track, File *fh, bool canSeek) :\n\tBlockCodec(mode, track, fh, canSeek),\n\tm_numCoefficients(0),\n\tm_state(NULL)\n{\n\tm_state = new ms_adpcm_state[m_track->f.channelCount];\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <string.h>",
      "#include <limits>",
      "#include <cstdlib>",
      "#include <assert.h>",
      "#include \"MSADPCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nMSADPCM {\n  MSADPCM::MSADPCM(Mode mode, Track *track, File *fh, bool canSeek) :\n  \tBlockCodec(mode, track, fh, canSeek),\n  \tm_numCoefficients(0),\n  \tm_state(NULL)\n  {\n  \tm_state = new ms_adpcm_state[m_track->f.channelCount];\n  }\n}"
  },
  {
    "function_name": "describe",
    "container": "MSADPCM",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
    "lines": "370-375",
    "snippet": "void MSADPCM::describe()\n{\n\tm_outChunk->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\tm_outChunk->f.compressionType = AF_COMPRESSION_NONE;\n\tm_outChunk->f.compressionParams = AU_NULL_PVLIST;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <string.h>",
      "#include <limits>",
      "#include <cstdlib>",
      "#include <assert.h>",
      "#include \"MSADPCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nMSADPCM {\n  void MSADPCM::describe()\n  {\n  \tm_outChunk->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \tm_outChunk->f.compressionType = AF_COMPRESSION_NONE;\n  \tm_outChunk->f.compressionParams = AU_NULL_PVLIST;\n  }\n}"
  },
  {
    "function_name": "choosePredictorForBlock",
    "container": "MSADPCM",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
    "lines": "326-368",
    "snippet": "void MSADPCM::choosePredictorForBlock(const int16_t *decoded)\n{\n\tconst int kPredictorSampleLength = 3;\n\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tint bestPredictorIndex = 0;\n\t\tint bestPredictorError = std::numeric_limits<int>::max();\n\t\tfor (int k=0; k<m_numCoefficients; k++)\n\t\t{\n\t\t\tint a0 = m_coefficients[k][0];\n\t\t\tint a1 = m_coefficients[k][1];\n\n\t\t\tint currentPredictorError = 0;\n\t\t\tfor (int i=2; i<2+kPredictorSampleLength; i++)\n\t\t\t{\n\t\t\t\tint error = std::abs(decoded[i*channelCount + c] -\n\t\t\t\t\t((a0 * decoded[(i-1)*channelCount + c] +\n\t\t\t\t\ta1 * decoded[(i-2)*channelCount + c]) >> 8));\n\t\t\t\tcurrentPredictorError += error;\n\t\t\t}\n\n\t\t\tcurrentPredictorError /= 4 * kPredictorSampleLength;\n\n\t\t\tif (currentPredictorError < bestPredictorError)\n\t\t\t{\n\t\t\t\tbestPredictorError = currentPredictorError;\n\t\t\t\tbestPredictorIndex = k;\n\t\t\t}\n\n\t\t\tif (!currentPredictorError)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (bestPredictorError < 16)\n\t\t\tbestPredictorError = 16;\n\n\t\tm_state[c].predictorIndex = bestPredictorIndex;\n\t\tm_state[c].delta = bestPredictorError;\n\t}\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <string.h>",
      "#include <limits>",
      "#include <cstdlib>",
      "#include <assert.h>",
      "#include \"MSADPCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::abs",
          "args": [
            "decoded[i*channelCount + c] -\n\t\t\t\t\t((a0 * decoded[(i-1)*channelCount + c] +\n\t\t\t\t\ta1 * decoded[(i-2)*channelCount + c]) >> 8)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::numeric_limits<int>::max",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nMSADPCM {\n  void MSADPCM::choosePredictorForBlock(const int16_t *decoded)\n  {\n  \tconst int kPredictorSampleLength = 3;\n  \n  \tint channelCount = m_track->f.channelCount;\n  \n  \tfor (int c=0; c<channelCount; c++)\n  \t{\n  \t\tint bestPredictorIndex = 0;\n  \t\tint bestPredictorError = std::numeric_limits<int>::max();\n  \t\tfor (int k=0; k<m_numCoefficients; k++)\n  \t\t{\n  \t\t\tint a0 = m_coefficients[k][0];\n  \t\t\tint a1 = m_coefficients[k][1];\n  \n  \t\t\tint currentPredictorError = 0;\n  \t\t\tfor (int i=2; i<2+kPredictorSampleLength; i++)\n  \t\t\t{\n  \t\t\t\tint error = std::abs(decoded[i*channelCount + c] -\n  \t\t\t\t\t((a0 * decoded[(i-1)*channelCount + c] +\n  \t\t\t\t\ta1 * decoded[(i-2)*channelCount + c]) >> 8));\n  \t\t\t\tcurrentPredictorError += error;\n  \t\t\t}\n  \n  \t\t\tcurrentPredictorError /= 4 * kPredictorSampleLength;\n  \n  \t\t\tif (currentPredictorError < bestPredictorError)\n  \t\t\t{\n  \t\t\t\tbestPredictorError = currentPredictorError;\n  \t\t\t\tbestPredictorIndex = k;\n  \t\t\t}\n  \n  \t\t\tif (!currentPredictorError)\n  \t\t\t\tbreak;\n  \t\t}\n  \n  \t\tif (bestPredictorError < 16)\n  \t\t\tbestPredictorError = 16;\n  \n  \t\tm_state[c].predictorIndex = bestPredictorIndex;\n  \t\tm_state[c].delta = bestPredictorError;\n  \t}\n  }\n}"
  },
  {
    "function_name": "encodeBlock",
    "container": "MSADPCM",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
    "lines": "270-324",
    "snippet": "int MSADPCM::encodeBlock(const int16_t *decoded, uint8_t *encoded)\n{\n\tchoosePredictorForBlock(decoded);\n\n\tint channelCount = m_track->f.channelCount;\n\n\t// Encode predictor.\n\tfor (int c=0; c<channelCount; c++)\n\t\t*encoded++ = m_state[c].predictorIndex;\n\n\t// Encode delta.\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\t*encoded++ = m_state[c].delta & 0xff;\n\t\t*encoded++ = m_state[c].delta >> 8;\n\t}\n\n\t// Enccode first two samples.\n\tfor (int c=0; c<channelCount; c++)\n\t\tm_state[c].sample2 = *decoded++;\n\n\tfor (int c=0; c<channelCount; c++)\n\t\tm_state[c].sample1 = *decoded++;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\t*encoded++ = m_state[c].sample1 & 0xff;\n\t\t*encoded++ = m_state[c].sample1 >> 8;\n\t}\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\t*encoded++ = m_state[c].sample2 & 0xff;\n\t\t*encoded++ = m_state[c].sample2 >> 8;\n\t}\n\n\tms_adpcm_state *state[2] = { &m_state[0], &m_state[channelCount - 1] };\n\tconst int16_t *coefficient[2] =\n\t{\n\t\tm_coefficients[state[0]->predictorIndex],\n\t\tm_coefficients[state[1]->predictorIndex]\n\t};\n\n\tint samplesRemaining = (m_framesPerPacket - 2) * m_track->f.channelCount;\n\twhile (samplesRemaining > 0)\n\t{\n\t\tuint8_t code1 = encodeSample(*state[0], *decoded++, coefficient[0]);\n\t\tuint8_t code2 = encodeSample(*state[1], *decoded++, coefficient[1]);\n\n\t\t*encoded++ = (code1 << 4) | code2;\n\t\tsamplesRemaining -= 2;\n\t}\n\n\treturn m_bytesPerPacket;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <string.h>",
      "#include <limits>",
      "#include <cstdlib>",
      "#include <assert.h>",
      "#include \"MSADPCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encodeSample",
          "args": [
            "*state[1]",
            "*decoded++",
            "coefficient[1]"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "encodeSample",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
          "lines": "163-183",
          "snippet": "static uint8_t encodeSample(ms_adpcm_state &state, int16_t sample,\n\tconst int16_t *coefficient)\n{\n\tint predictor = (state.sample1 * coefficient[0] +\n\t\tstate.sample2 * coefficient[1]) >> 8;\n\tint code = sample - predictor;\n\tint bias = state.delta / 2;\n\tif (code < 0)\n\t\tbias = -bias;\n\tcode = (code + bias) / state.delta;\n\tcode = clamp(code, -8, 7) & 0xf;\n\n\tpredictor += ((code & 0x8) ? (code - 0x10) : code) * state.delta;\n\n\tstate.sample2 = state.sample1;\n\tstate.sample1 = clamp(predictor, MIN_INT16, MAX_INT16);\n\tstate.delta = (adaptationTable[code] * state.delta) >> 8;\n\tif (state.delta < 16)\n\t\tstate.delta = 16;\n\treturn code;\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <string.h>",
            "#include <limits>",
            "#include <cstdlib>",
            "#include <assert.h>",
            "#include \"MSADPCM.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const int16_t adaptationTable[] =\n{\n\t230, 230, 230, 230, 307, 409, 512, 614,\n\t768, 614, 512, 409, 307, 230, 230, 230\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nstatic const int16_t adaptationTable[] =\n{\n\t230, 230, 230, 230, 307, 409, 512, 614,\n\t768, 614, 512, 409, 307, 230, 230, 230\n};\n\nstatic uint8_t encodeSample(ms_adpcm_state &state, int16_t sample,\n\tconst int16_t *coefficient)\n{\n\tint predictor = (state.sample1 * coefficient[0] +\n\t\tstate.sample2 * coefficient[1]) >> 8;\n\tint code = sample - predictor;\n\tint bias = state.delta / 2;\n\tif (code < 0)\n\t\tbias = -bias;\n\tcode = (code + bias) / state.delta;\n\tcode = clamp(code, -8, 7) & 0xf;\n\n\tpredictor += ((code & 0x8) ? (code - 0x10) : code) * state.delta;\n\n\tstate.sample2 = state.sample1;\n\tstate.sample1 = clamp(predictor, MIN_INT16, MAX_INT16);\n\tstate.delta = (adaptationTable[code] * state.delta) >> 8;\n\tif (state.delta < 16)\n\t\tstate.delta = 16;\n\treturn code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "choosePredictorForBlock",
          "args": [
            "decoded"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "choosePredictorForBlock",
          "container": "MSADPCM",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
          "lines": "326-368",
          "snippet": "void MSADPCM::choosePredictorForBlock(const int16_t *decoded)\n{\n\tconst int kPredictorSampleLength = 3;\n\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tint bestPredictorIndex = 0;\n\t\tint bestPredictorError = std::numeric_limits<int>::max();\n\t\tfor (int k=0; k<m_numCoefficients; k++)\n\t\t{\n\t\t\tint a0 = m_coefficients[k][0];\n\t\t\tint a1 = m_coefficients[k][1];\n\n\t\t\tint currentPredictorError = 0;\n\t\t\tfor (int i=2; i<2+kPredictorSampleLength; i++)\n\t\t\t{\n\t\t\t\tint error = std::abs(decoded[i*channelCount + c] -\n\t\t\t\t\t((a0 * decoded[(i-1)*channelCount + c] +\n\t\t\t\t\ta1 * decoded[(i-2)*channelCount + c]) >> 8));\n\t\t\t\tcurrentPredictorError += error;\n\t\t\t}\n\n\t\t\tcurrentPredictorError /= 4 * kPredictorSampleLength;\n\n\t\t\tif (currentPredictorError < bestPredictorError)\n\t\t\t{\n\t\t\t\tbestPredictorError = currentPredictorError;\n\t\t\t\tbestPredictorIndex = k;\n\t\t\t}\n\n\t\t\tif (!currentPredictorError)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (bestPredictorError < 16)\n\t\t\tbestPredictorError = 16;\n\n\t\tm_state[c].predictorIndex = bestPredictorIndex;\n\t\tm_state[c].delta = bestPredictorError;\n\t}\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <string.h>",
            "#include <limits>",
            "#include <cstdlib>",
            "#include <assert.h>",
            "#include \"MSADPCM.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nMSADPCM {\n  void MSADPCM::choosePredictorForBlock(const int16_t *decoded)\n  {\n  \tconst int kPredictorSampleLength = 3;\n  \n  \tint channelCount = m_track->f.channelCount;\n  \n  \tfor (int c=0; c<channelCount; c++)\n  \t{\n  \t\tint bestPredictorIndex = 0;\n  \t\tint bestPredictorError = std::numeric_limits<int>::max();\n  \t\tfor (int k=0; k<m_numCoefficients; k++)\n  \t\t{\n  \t\t\tint a0 = m_coefficients[k][0];\n  \t\t\tint a1 = m_coefficients[k][1];\n  \n  \t\t\tint currentPredictorError = 0;\n  \t\t\tfor (int i=2; i<2+kPredictorSampleLength; i++)\n  \t\t\t{\n  \t\t\t\tint error = std::abs(decoded[i*channelCount + c] -\n  \t\t\t\t\t((a0 * decoded[(i-1)*channelCount + c] +\n  \t\t\t\t\ta1 * decoded[(i-2)*channelCount + c]) >> 8));\n  \t\t\t\tcurrentPredictorError += error;\n  \t\t\t}\n  \n  \t\t\tcurrentPredictorError /= 4 * kPredictorSampleLength;\n  \n  \t\t\tif (currentPredictorError < bestPredictorError)\n  \t\t\t{\n  \t\t\t\tbestPredictorError = currentPredictorError;\n  \t\t\t\tbestPredictorIndex = k;\n  \t\t\t}\n  \n  \t\t\tif (!currentPredictorError)\n  \t\t\t\tbreak;\n  \t\t}\n  \n  \t\tif (bestPredictorError < 16)\n  \t\t\tbestPredictorError = 16;\n  \n  \t\tm_state[c].predictorIndex = bestPredictorIndex;\n  \t\tm_state[c].delta = bestPredictorError;\n  \t}\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nMSADPCM {\n  int MSADPCM::encodeBlock(const int16_t *decoded, uint8_t *encoded)\n  {\n  \tchoosePredictorForBlock(decoded);\n  \n  \tint channelCount = m_track->f.channelCount;\n  \n  \t// Encode predictor.\n  \tfor (int c=0; c<channelCount; c++)\n  \t\t*encoded++ = m_state[c].predictorIndex;\n  \n  \t// Encode delta.\n  \tfor (int c=0; c<channelCount; c++)\n  \t{\n  \t\t*encoded++ = m_state[c].delta & 0xff;\n  \t\t*encoded++ = m_state[c].delta >> 8;\n  \t}\n  \n  \t// Enccode first two samples.\n  \tfor (int c=0; c<channelCount; c++)\n  \t\tm_state[c].sample2 = *decoded++;\n  \n  \tfor (int c=0; c<channelCount; c++)\n  \t\tm_state[c].sample1 = *decoded++;\n  \n  \tfor (int c=0; c<channelCount; c++)\n  \t{\n  \t\t*encoded++ = m_state[c].sample1 & 0xff;\n  \t\t*encoded++ = m_state[c].sample1 >> 8;\n  \t}\n  \n  \tfor (int c=0; c<channelCount; c++)\n  \t{\n  \t\t*encoded++ = m_state[c].sample2 & 0xff;\n  \t\t*encoded++ = m_state[c].sample2 >> 8;\n  \t}\n  \n  \tms_adpcm_state *state[2] = { &m_state[0], &m_state[channelCount - 1] };\n  \tconst int16_t *coefficient[2] =\n  \t{\n  \t\tm_coefficients[state[0]->predictorIndex],\n  \t\tm_coefficients[state[1]->predictorIndex]\n  \t};\n  \n  \tint samplesRemaining = (m_framesPerPacket - 2) * m_track->f.channelCount;\n  \twhile (samplesRemaining > 0)\n  \t{\n  \t\tuint8_t code1 = encodeSample(*state[0], *decoded++, coefficient[0]);\n  \t\tuint8_t code2 = encodeSample(*state[1], *decoded++, coefficient[1]);\n  \n  \t\t*encoded++ = (code1 << 4) | code2;\n  \t\tsamplesRemaining -= 2;\n  \t}\n  \n  \treturn m_bytesPerPacket;\n  }\n}"
  },
  {
    "function_name": "decodeBlock",
    "container": "MSADPCM",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
    "lines": "186-268",
    "snippet": "int MSADPCM::decodeBlock(const uint8_t *encoded, int16_t *decoded)\n{\n\tms_adpcm_state decoderState[2];\n\tms_adpcm_state *state[2];\n\n\tint channelCount = m_track->f.channelCount;\n\n\t// Calculate the number of bytes needed for decoded data.\n\tint outputLength = m_framesPerPacket * sizeof (int16_t) * channelCount;\n\n\tstate[0] = &decoderState[0];\n\tif (channelCount == 2)\n\t\tstate[1] = &decoderState[1];\n\telse\n\t\tstate[1] = &decoderState[0];\n\n\t// Initialize block predictor.\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->predictorIndex = *encoded++;\n\t\tassert(state[i]->predictorIndex < m_numCoefficients);\n\t}\n\n\t// Initialize delta.\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->delta = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\t// Initialize first two samples.\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample1 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample2 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\tconst int16_t *coefficient[2] =\n\t{\n\t\tm_coefficients[state[0]->predictorIndex],\n\t\tm_coefficients[state[1]->predictorIndex]\n\t};\n\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample2;\n\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample1;\n\n\t/*\n\t\tThe first two samples have already been 'decoded' in\n\t\tthe block header.\n\t*/\n\tint samplesRemaining = (m_framesPerPacket - 2) * m_track->f.channelCount;\n\n\twhile (samplesRemaining > 0)\n\t{\n\t\tuint8_t code;\n\t\tint16_t newSample;\n\t\tbool ok;\n\n\t\tcode = *encoded >> 4;\n\t\tnewSample = decodeSample(*state[0], code, coefficient[0], &ok);\n\t\tif (!ok) return 0;\n\t\t*decoded++ = newSample;\n\n\t\tcode = *encoded & 0x0f;\n\t\tnewSample = decodeSample(*state[1], code, coefficient[1], &ok);\n\t\tif (!ok) return 0;\n\t\t*decoded++ = newSample;\n\n\t\tencoded++;\n\t\tsamplesRemaining -= 2;\n\t}\n\n\treturn outputLength;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <string.h>",
      "#include <limits>",
      "#include <cstdlib>",
      "#include <assert.h>",
      "#include \"MSADPCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "decodeSample",
          "args": [
            "*state[1]",
            "code",
            "coefficient[1]",
            "&ok"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decodeSample",
          "args": [
            "*state[0]",
            "code",
            "coefficient[0]",
            "&ok"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "state[i]->predictorIndex < m_numCoefficients"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nMSADPCM {\n  int MSADPCM::decodeBlock(const uint8_t *encoded, int16_t *decoded)\n  {\n  \tms_adpcm_state decoderState[2];\n  \tms_adpcm_state *state[2];\n  \n  \tint channelCount = m_track->f.channelCount;\n  \n  \t// Calculate the number of bytes needed for decoded data.\n  \tint outputLength = m_framesPerPacket * sizeof (int16_t) * channelCount;\n  \n  \tstate[0] = &decoderState[0];\n  \tif (channelCount == 2)\n  \t\tstate[1] = &decoderState[1];\n  \telse\n  \t\tstate[1] = &decoderState[0];\n  \n  \t// Initialize block predictor.\n  \tfor (int i=0; i<channelCount; i++)\n  \t{\n  \t\tstate[i]->predictorIndex = *encoded++;\n  \t\tassert(state[i]->predictorIndex < m_numCoefficients);\n  \t}\n  \n  \t// Initialize delta.\n  \tfor (int i=0; i<channelCount; i++)\n  \t{\n  \t\tstate[i]->delta = (encoded[1]<<8) | encoded[0];\n  \t\tencoded += sizeof (uint16_t);\n  \t}\n  \n  \t// Initialize first two samples.\n  \tfor (int i=0; i<channelCount; i++)\n  \t{\n  \t\tstate[i]->sample1 = (encoded[1]<<8) | encoded[0];\n  \t\tencoded += sizeof (uint16_t);\n  \t}\n  \n  \tfor (int i=0; i<channelCount; i++)\n  \t{\n  \t\tstate[i]->sample2 = (encoded[1]<<8) | encoded[0];\n  \t\tencoded += sizeof (uint16_t);\n  \t}\n  \n  \tconst int16_t *coefficient[2] =\n  \t{\n  \t\tm_coefficients[state[0]->predictorIndex],\n  \t\tm_coefficients[state[1]->predictorIndex]\n  \t};\n  \n  \tfor (int i=0; i<channelCount; i++)\n  \t\t*decoded++ = state[i]->sample2;\n  \n  \tfor (int i=0; i<channelCount; i++)\n  \t\t*decoded++ = state[i]->sample1;\n  \n  \t/*\n  \t\tThe first two samples have already been 'decoded' in\n  \t\tthe block header.\n  \t*/\n  \tint samplesRemaining = (m_framesPerPacket - 2) * m_track->f.channelCount;\n  \n  \twhile (samplesRemaining > 0)\n  \t{\n  \t\tuint8_t code;\n  \t\tint16_t newSample;\n  \t\tbool ok;\n  \n  \t\tcode = *encoded >> 4;\n  \t\tnewSample = decodeSample(*state[0], code, coefficient[0], &ok);\n  \t\tif (!ok) return 0;\n  \t\t*decoded++ = newSample;\n  \n  \t\tcode = *encoded & 0x0f;\n  \t\tnewSample = decodeSample(*state[1], code, coefficient[1], &ok);\n  \t\tif (!ok) return 0;\n  \t\t*decoded++ = newSample;\n  \n  \t\tencoded++;\n  \t\tsamplesRemaining -= 2;\n  \t}\n  \n  \treturn outputLength;\n  }\n}"
  },
  {
    "function_name": "encodeSample",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
    "lines": "163-183",
    "snippet": "static uint8_t encodeSample(ms_adpcm_state &state, int16_t sample,\n\tconst int16_t *coefficient)\n{\n\tint predictor = (state.sample1 * coefficient[0] +\n\t\tstate.sample2 * coefficient[1]) >> 8;\n\tint code = sample - predictor;\n\tint bias = state.delta / 2;\n\tif (code < 0)\n\t\tbias = -bias;\n\tcode = (code + bias) / state.delta;\n\tcode = clamp(code, -8, 7) & 0xf;\n\n\tpredictor += ((code & 0x8) ? (code - 0x10) : code) * state.delta;\n\n\tstate.sample2 = state.sample1;\n\tstate.sample1 = clamp(predictor, MIN_INT16, MAX_INT16);\n\tstate.delta = (adaptationTable[code] * state.delta) >> 8;\n\tif (state.delta < 16)\n\t\tstate.delta = 16;\n\treturn code;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <string.h>",
      "#include <limits>",
      "#include <cstdlib>",
      "#include <assert.h>",
      "#include \"MSADPCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const int16_t adaptationTable[] =\n{\n\t230, 230, 230, 230, 307, 409, 512, 614,\n\t768, 614, 512, 409, 307, 230, 230, 230\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "predictor",
            "MIN_INT16",
            "MAX_INT16"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "clamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
          "lines": "91-96",
          "snippet": "static inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <string.h>",
            "#include <limits>",
            "#include <cstdlib>",
            "#include <assert.h>",
            "#include \"MSADPCM.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nstatic inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nstatic const int16_t adaptationTable[] =\n{\n\t230, 230, 230, 230, 307, 409, 512, 614,\n\t768, 614, 512, 409, 307, 230, 230, 230\n};\n\nstatic uint8_t encodeSample(ms_adpcm_state &state, int16_t sample,\n\tconst int16_t *coefficient)\n{\n\tint predictor = (state.sample1 * coefficient[0] +\n\t\tstate.sample2 * coefficient[1]) >> 8;\n\tint code = sample - predictor;\n\tint bias = state.delta / 2;\n\tif (code < 0)\n\t\tbias = -bias;\n\tcode = (code + bias) / state.delta;\n\tcode = clamp(code, -8, 7) & 0xf;\n\n\tpredictor += ((code & 0x8) ? (code - 0x10) : code) * state.delta;\n\n\tstate.sample2 = state.sample1;\n\tstate.sample1 = clamp(predictor, MIN_INT16, MAX_INT16);\n\tstate.delta = (adaptationTable[code] * state.delta) >> 8;\n\tif (state.delta < 16)\n\t\tstate.delta = 16;\n\treturn code;\n}"
  },
  {
    "function_name": "decodeSample",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
    "lines": "133-160",
    "snippet": "static int16_t decodeSample(ms_adpcm_state &state,\n\tuint8_t code, const int16_t *coefficient, bool *ok=NULL)\n{\n\tint linearSample = (state.sample1 * coefficient[0] +\n\t\tstate.sample2 * coefficient[1]) >> 8;\n\tint delta;\n\n\tlinearSample += ((code & 0x08) ? (code - 0x10) : code) * state.delta;\n\n\tlinearSample = clamp(linearSample, MIN_INT16, MAX_INT16);\n\n\tif (multiplyCheckOverflow(state.delta, adaptationTable[code], &delta))\n\t{\n                if (ok) *ok=false;\n\t\t_af_error(AF_BAD_COMPRESSION, \"Error decoding sample\");\n\t\treturn 0;\n\t}\n\tdelta >>= 8;\n\tif (delta < 16)\n\t\tdelta = 16;\n\n\tstate.delta = delta;\n\tstate.sample2 = state.sample1;\n\tstate.sample1 = linearSample;\n\tif (ok) *ok=true;\n\n\treturn static_cast<int16_t>(linearSample);\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <string.h>",
      "#include <limits>",
      "#include <cstdlib>",
      "#include <assert.h>",
      "#include \"MSADPCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const int16_t adaptationTable[] =\n{\n\t230, 230, 230, 230, 307, 409, 512, 614,\n\t768, 614, 512, 409, 307, 230, 230, 230\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<int16_t>",
          "args": [
            "linearSample"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_COMPRESSION",
            "\"Error decoding sample\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "multiplyCheckOverflow",
          "args": [
            "state.delta",
            "adaptationTable[code]",
            "&delta"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "multiplyCheckOverflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
          "lines": "119-129",
          "snippet": "int multiplyCheckOverflow(int a, int b, int *result)\n{\n#if (defined __GNUC__ && __GNUC__ >= 5) || ( __clang__ && __has_builtin(__builtin_mul_overflow))\n\treturn __builtin_mul_overflow(a, b, result);\n#else\n\tif (firstBitSet(a)+firstBitSet(b)>31) // int is signed, so we can't use 32 bits\n\t\treturn true;\n\t*result = a * b;\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <string.h>",
            "#include <limits>",
            "#include <cstdlib>",
            "#include <assert.h>",
            "#include \"MSADPCM.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nint multiplyCheckOverflow(int a, int b, int *result)\n{\n#if (defined __GNUC__ && __GNUC__ >= 5) || ( __clang__ && __has_builtin(__builtin_mul_overflow))\n\treturn __builtin_mul_overflow(a, b, result);\n#else\n\tif (firstBitSet(a)+firstBitSet(b)>31) // int is signed, so we can't use 32 bits\n\t\treturn true;\n\t*result = a * b;\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "linearSample",
            "MIN_INT16",
            "MAX_INT16"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "clamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
          "lines": "91-96",
          "snippet": "static inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <string.h>",
            "#include <limits>",
            "#include <cstdlib>",
            "#include <assert.h>",
            "#include \"MSADPCM.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nstatic inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nstatic const int16_t adaptationTable[] =\n{\n\t230, 230, 230, 230, 307, 409, 512, 614,\n\t768, 614, 512, 409, 307, 230, 230, 230\n};\n\nstatic int16_t decodeSample(ms_adpcm_state &state,\n\tuint8_t code, const int16_t *coefficient, bool *ok=NULL)\n{\n\tint linearSample = (state.sample1 * coefficient[0] +\n\t\tstate.sample2 * coefficient[1]) >> 8;\n\tint delta;\n\n\tlinearSample += ((code & 0x08) ? (code - 0x10) : code) * state.delta;\n\n\tlinearSample = clamp(linearSample, MIN_INT16, MAX_INT16);\n\n\tif (multiplyCheckOverflow(state.delta, adaptationTable[code], &delta))\n\t{\n                if (ok) *ok=false;\n\t\t_af_error(AF_BAD_COMPRESSION, \"Error decoding sample\");\n\t\treturn 0;\n\t}\n\tdelta >>= 8;\n\tif (delta < 16)\n\t\tdelta = 16;\n\n\tstate.delta = delta;\n\tstate.sample2 = state.sample1;\n\tstate.sample1 = linearSample;\n\tif (ok) *ok=true;\n\n\treturn static_cast<int16_t>(linearSample);\n}"
  },
  {
    "function_name": "multiplyCheckOverflow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
    "lines": "119-129",
    "snippet": "int multiplyCheckOverflow(int a, int b, int *result)\n{\n#if (defined __GNUC__ && __GNUC__ >= 5) || ( __clang__ && __has_builtin(__builtin_mul_overflow))\n\treturn __builtin_mul_overflow(a, b, result);\n#else\n\tif (firstBitSet(a)+firstBitSet(b)>31) // int is signed, so we can't use 32 bits\n\t\treturn true;\n\t*result = a * b;\n\treturn false;\n#endif\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <string.h>",
      "#include <limits>",
      "#include <cstdlib>",
      "#include <assert.h>",
      "#include \"MSADPCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "firstBitSet",
          "args": [
            "b"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "firstBitSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
          "lines": "104-113",
          "snippet": "int firstBitSet(int x)\n{\n        int position=0;\n        while (x!=0)\n        {\n                x>>=1;\n                ++position;\n        }\n        return position;\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <string.h>",
            "#include <limits>",
            "#include <cstdlib>",
            "#include <assert.h>",
            "#include \"MSADPCM.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nint firstBitSet(int x)\n{\n        int position=0;\n        while (x!=0)\n        {\n                x>>=1;\n                ++position;\n        }\n        return position;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__builtin_mul_overflow",
          "args": [
            "a",
            "b",
            "result"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__has_builtin",
          "args": [
            "__builtin_mul_overflow"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nint multiplyCheckOverflow(int a, int b, int *result)\n{\n#if (defined __GNUC__ && __GNUC__ >= 5) || ( __clang__ && __has_builtin(__builtin_mul_overflow))\n\treturn __builtin_mul_overflow(a, b, result);\n#else\n\tif (firstBitSet(a)+firstBitSet(b)>31) // int is signed, so we can't use 32 bits\n\t\treturn true;\n\t*result = a * b;\n\treturn false;\n#endif\n}"
  },
  {
    "function_name": "firstBitSet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
    "lines": "104-113",
    "snippet": "int firstBitSet(int x)\n{\n        int position=0;\n        while (x!=0)\n        {\n                x>>=1;\n                ++position;\n        }\n        return position;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <string.h>",
      "#include <limits>",
      "#include <cstdlib>",
      "#include <assert.h>",
      "#include \"MSADPCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nint firstBitSet(int x)\n{\n        int position=0;\n        while (x!=0)\n        {\n                x>>=1;\n                ++position;\n        }\n        return position;\n}"
  },
  {
    "function_name": "clamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
    "lines": "91-96",
    "snippet": "static inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <string.h>",
      "#include <limits>",
      "#include <cstdlib>",
      "#include <assert.h>",
      "#include \"MSADPCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nstatic inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}"
  },
  {
    "function_name": "ms_adpcm_state",
    "container": "ms_adpcm_state",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
    "lines": "50-56",
    "snippet": "ms_adpcm_state()\n\t{\n\t\tpredictorIndex = 0;\n\t\tdelta = 16;\n\t\tsample1 = 0;\n\t\tsample2 = 0;\n\t}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <string.h>",
      "#include <limits>",
      "#include <cstdlib>",
      "#include <assert.h>",
      "#include \"MSADPCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nms_adpcm_state {\n  ms_adpcm_state()\n  \t{\n  \t\tpredictorIndex = 0;\n  \t\tdelta = 16;\n  \t\tsample1 = 0;\n  \t\tsample2 = 0;\n  \t}\n}"
  }
]