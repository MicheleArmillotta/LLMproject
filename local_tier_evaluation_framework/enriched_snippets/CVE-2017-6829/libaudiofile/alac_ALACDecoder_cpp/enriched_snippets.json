[
  {
    "function_name": "Zero32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACDecoder.cpp",
    "lines": "715-726",
    "snippet": "static void Zero32( int32_t * buffer, uint32_t numItems, uint32_t stride )\n{\n\tif ( stride == 1 )\n\t{\n\t\tmemset( buffer, 0, numItems * sizeof(int32_t) );\n\t}\n\telse\n\t{\n\t\tfor ( uint32_t index = 0; index < (numItems * stride); index += stride )\n\t\t\tbuffer[index] = 0;\n\t}\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"aglib.h\"",
      "#include \"dplib.h\"",
      "#include \"ALACDecoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void Zero16( int16_t * buffer, uint32_t numItems, uint32_t stride );",
      "static void Zero24( uint8_t * buffer, uint32_t numItems, uint32_t stride );",
      "static void Zero32( int32_t * buffer, uint32_t numItems, uint32_t stride );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buffer",
            "0",
            "numItems * sizeof(int32_t)"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"aglib.h\"\n#include \"dplib.h\"\n#include \"ALACDecoder.h\"\n#include <string.h>\n#include <stdlib.h>\n\nstatic void Zero16( int16_t * buffer, uint32_t numItems, uint32_t stride );\nstatic void Zero24( uint8_t * buffer, uint32_t numItems, uint32_t stride );\nstatic void Zero32( int32_t * buffer, uint32_t numItems, uint32_t stride );\n\nstatic void Zero32( int32_t * buffer, uint32_t numItems, uint32_t stride )\n{\n\tif ( stride == 1 )\n\t{\n\t\tmemset( buffer, 0, numItems * sizeof(int32_t) );\n\t}\n\telse\n\t{\n\t\tfor ( uint32_t index = 0; index < (numItems * stride); index += stride )\n\t\t\tbuffer[index] = 0;\n\t}\n}"
  },
  {
    "function_name": "Zero24",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACDecoder.cpp",
    "lines": "698-713",
    "snippet": "static void Zero24( uint8_t * buffer, uint32_t numItems, uint32_t stride )\n{\n\tif ( stride == 1 )\n\t{\n\t\tmemset( buffer, 0, numItems * 3 );\n\t}\n\telse\n\t{\n\t\tfor ( uint32_t index = 0; index < (numItems * stride * 3); index += (stride * 3) )\n\t\t{\n\t\t\tbuffer[index + 0] = 0;\n\t\t\tbuffer[index + 1] = 0;\n\t\t\tbuffer[index + 2] = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"aglib.h\"",
      "#include \"dplib.h\"",
      "#include \"ALACDecoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void Zero16( int16_t * buffer, uint32_t numItems, uint32_t stride );",
      "static void Zero24( uint8_t * buffer, uint32_t numItems, uint32_t stride );",
      "static void Zero32( int32_t * buffer, uint32_t numItems, uint32_t stride );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buffer",
            "0",
            "numItems * 3"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"aglib.h\"\n#include \"dplib.h\"\n#include \"ALACDecoder.h\"\n#include <string.h>\n#include <stdlib.h>\n\nstatic void Zero16( int16_t * buffer, uint32_t numItems, uint32_t stride );\nstatic void Zero24( uint8_t * buffer, uint32_t numItems, uint32_t stride );\nstatic void Zero32( int32_t * buffer, uint32_t numItems, uint32_t stride );\n\nstatic void Zero24( uint8_t * buffer, uint32_t numItems, uint32_t stride )\n{\n\tif ( stride == 1 )\n\t{\n\t\tmemset( buffer, 0, numItems * 3 );\n\t}\n\telse\n\t{\n\t\tfor ( uint32_t index = 0; index < (numItems * stride * 3); index += (stride * 3) )\n\t\t{\n\t\t\tbuffer[index + 0] = 0;\n\t\t\tbuffer[index + 1] = 0;\n\t\t\tbuffer[index + 2] = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "Zero16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACDecoder.cpp",
    "lines": "685-696",
    "snippet": "static void Zero16( int16_t * buffer, uint32_t numItems, uint32_t stride )\n{\n\tif ( stride == 1 )\n\t{\n\t\tmemset( buffer, 0, numItems * sizeof(int16_t) );\n\t}\n\telse\n\t{\n\t\tfor ( uint32_t index = 0; index < (numItems * stride); index += stride )\n\t\t\tbuffer[index] = 0;\n\t}\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"aglib.h\"",
      "#include \"dplib.h\"",
      "#include \"ALACDecoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void Zero16( int16_t * buffer, uint32_t numItems, uint32_t stride );",
      "static void Zero24( uint8_t * buffer, uint32_t numItems, uint32_t stride );",
      "static void Zero32( int32_t * buffer, uint32_t numItems, uint32_t stride );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buffer",
            "0",
            "numItems * sizeof(int16_t)"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"aglib.h\"\n#include \"dplib.h\"\n#include \"ALACDecoder.h\"\n#include <string.h>\n#include <stdlib.h>\n\nstatic void Zero16( int16_t * buffer, uint32_t numItems, uint32_t stride );\nstatic void Zero24( uint8_t * buffer, uint32_t numItems, uint32_t stride );\nstatic void Zero32( int32_t * buffer, uint32_t numItems, uint32_t stride );\n\nstatic void Zero16( int16_t * buffer, uint32_t numItems, uint32_t stride )\n{\n\tif ( stride == 1 )\n\t{\n\t\tmemset( buffer, 0, numItems * sizeof(int16_t) );\n\t}\n\telse\n\t{\n\t\tfor ( uint32_t index = 0; index < (numItems * stride); index += stride )\n\t\t\tbuffer[index] = 0;\n\t}\n}"
  },
  {
    "function_name": "DataStreamElement",
    "container": "ALACDecoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACDecoder.cpp",
    "lines": "653-679",
    "snippet": "int32_t ALACDecoder::DataStreamElement( BitBuffer * bits )\n{\n\tuint8_t\t\telement_instance_tag;\n\tint32_t\t\tdata_byte_align_flag;\n\tuint16_t\t\tcount;\n\t\n\t// the tag associates this data stream element with a given audio element\n\telement_instance_tag = BitBufferReadSmall( bits, 4 );\n\t\n\tdata_byte_align_flag = BitBufferReadOne( bits );\n\n\t// 8-bit count or (8-bit + 8-bit count) if 8-bit count == 255\n\tcount = BitBufferReadSmall( bits, 8 );\n\tif ( count == 255 )\n\t\tcount += BitBufferReadSmall( bits, 8 );\n\n\t// the align flag means the bitstream should be byte-aligned before reading the following data bytes\n\tif ( data_byte_align_flag )\n\t\tBitBufferByteAlign( bits, false );\n\n\t// skip the data bytes\n\tBitBufferAdvance( bits, count * 8 );\n\n\tRequireAction( bits->cur <= bits->end, return kALAC_ParamError; );\n\n\treturn ALAC_noErr;\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"aglib.h\"",
      "#include \"dplib.h\"",
      "#include \"ALACDecoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RequireAction",
          "args": [
            "bits->cur <= bits->end",
            "returnkALAC_ParamError;"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferAdvance",
          "args": [
            "bits",
            "count * 8"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferByteAlign",
          "args": [
            "bits",
            "false"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferReadSmall",
          "args": [
            "bits",
            "8"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferReadSmall",
          "args": [
            "bits",
            "8"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferReadOne",
          "args": [
            "bits"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferReadSmall",
          "args": [
            "bits",
            "4"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"aglib.h\"\n#include \"dplib.h\"\n#include \"ALACDecoder.h\"\n#include <string.h>\n#include <stdlib.h>\n\nALACDecoder {\n  int32_t ALACDecoder::DataStreamElement( BitBuffer * bits )\n  {\n  \tuint8_t\t\telement_instance_tag;\n  \tint32_t\t\tdata_byte_align_flag;\n  \tuint16_t\t\tcount;\n  \t\n  \t// the tag associates this data stream element with a given audio element\n  \telement_instance_tag = BitBufferReadSmall( bits, 4 );\n  \t\n  \tdata_byte_align_flag = BitBufferReadOne( bits );\n  \n  \t// 8-bit count or (8-bit + 8-bit count) if 8-bit count == 255\n  \tcount = BitBufferReadSmall( bits, 8 );\n  \tif ( count == 255 )\n  \t\tcount += BitBufferReadSmall( bits, 8 );\n  \n  \t// the align flag means the bitstream should be byte-aligned before reading the following data bytes\n  \tif ( data_byte_align_flag )\n  \t\tBitBufferByteAlign( bits, false );\n  \n  \t// skip the data bytes\n  \tBitBufferAdvance( bits, count * 8 );\n  \n  \tRequireAction( bits->cur <= bits->end, return kALAC_ParamError; );\n  \n  \treturn ALAC_noErr;\n  }\n}"
  },
  {
    "function_name": "FillElement",
    "container": "ALACDecoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACDecoder.cpp",
    "lines": "632-647",
    "snippet": "int32_t ALACDecoder::FillElement( BitBuffer * bits )\n{\n\tint16_t\t\tcount;\n\t\n\t// 4-bit count or (4-bit + 8-bit count) if 4-bit count == 15\n\t// - plus this weird -1 thing I still don't fully understand\n\tcount = BitBufferReadSmall( bits, 4 );\n\tif ( count == 15 )\n\t\tcount += (int16_t) BitBufferReadSmall( bits, 8 ) - 1;\n\n\tBitBufferAdvance( bits, count * 8 );\n\n\tRequireAction( bits->cur <= bits->end, return kALAC_ParamError; );\n\n\treturn ALAC_noErr;\t\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"aglib.h\"",
      "#include \"dplib.h\"",
      "#include \"ALACDecoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RequireAction",
          "args": [
            "bits->cur <= bits->end",
            "returnkALAC_ParamError;"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferAdvance",
          "args": [
            "bits",
            "count * 8"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferReadSmall",
          "args": [
            "bits",
            "8"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferReadSmall",
          "args": [
            "bits",
            "4"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"aglib.h\"\n#include \"dplib.h\"\n#include \"ALACDecoder.h\"\n#include <string.h>\n#include <stdlib.h>\n\nALACDecoder {\n  int32_t ALACDecoder::FillElement( BitBuffer * bits )\n  {\n  \tint16_t\t\tcount;\n  \t\n  \t// 4-bit count or (4-bit + 8-bit count) if 4-bit count == 15\n  \t// - plus this weird -1 thing I still don't fully understand\n  \tcount = BitBufferReadSmall( bits, 4 );\n  \tif ( count == 15 )\n  \t\tcount += (int16_t) BitBufferReadSmall( bits, 8 ) - 1;\n  \n  \tBitBufferAdvance( bits, count * 8 );\n  \n  \tRequireAction( bits->cur <= bits->end, return kALAC_ParamError; );\n  \n  \treturn ALAC_noErr;\t\n  }\n}"
  },
  {
    "function_name": "Decode",
    "container": "ALACDecoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACDecoder.cpp",
    "lines": "163-622",
    "snippet": "int32_t ALACDecoder::Decode( BitBuffer * bits, uint8_t * sampleBuffer, uint32_t numSamples, uint32_t numChannels, uint32_t * outNumSamples )\n{\n\tBitBuffer\t\t\tshiftBits;\n\tuint32_t            bits1, bits2;\n\tuint8_t\t\t\t\ttag;\n\tuint8_t\t\t\t\telementInstanceTag;\n\tAGParamRec\t\t\tagParams;\n\tuint32_t\t\t\t\tchannelIndex;\n\tint16_t\t\t\t\tcoefsU[32];\t\t// max possible size is 32 although NUMCOEPAIRS is the current limit\n\tint16_t\t\t\t\tcoefsV[32];\n\tuint8_t\t\t\t\tnumU, numV;\n\tuint8_t\t\t\t\tmixBits;\n\tint8_t\t\t\t\tmixRes;\n\tuint16_t\t\t\tunusedHeader;\n\tuint8_t\t\t\t\tescapeFlag;\n\tuint32_t\t\t\tchanBits;\n\tuint8_t\t\t\t\tbytesShifted;\n\tuint32_t\t\t\tshift;\n\tuint8_t\t\t\t\tmodeU, modeV;\n\tuint32_t\t\t\tdenShiftU, denShiftV;\n\tuint16_t\t\t\tpbFactorU, pbFactorV;\n\tuint16_t\t\t\tpb;\n\tint16_t *\t\t\tsamples;\n\tint16_t *\t\t\tout16;\n\tuint8_t *\t\t\tout20;\n\tuint8_t *\t\t\tout24;\n\tint32_t *\t\t\tout32;\n\tuint8_t\t\t\t\theaderByte;\n\tuint8_t\t\t\t\tpartialFrame;\n\tuint32_t\t\t\textraBits;\n\tint32_t\t\t\t\tval;\n\tuint32_t\t\t\ti, j;\n\tint32_t             status;\n\t\n\tRequireAction( (bits != nil) && (sampleBuffer != nil) && (outNumSamples != nil), return kALAC_ParamError; );\n\tRequireAction( numChannels > 0, return kALAC_ParamError; );\n\n\tmActiveElements = 0;\n\tchannelIndex\t= 0;\n\t\n\tsamples = (int16_t *) sampleBuffer;\n\n\tstatus = ALAC_noErr;\n\t*outNumSamples = numSamples;\n\n\twhile ( status == ALAC_noErr )\n\t{\n\t\t// bail if we ran off the end of the buffer\n    \tRequireAction( bits->cur < bits->end, status = kALAC_ParamError; goto Exit; );\n\n\t\t// copy global decode params for this element\n\t\tpb = mConfig.pb;\n\n\t\t// read element tag\n\t\ttag = BitBufferReadSmall( bits, 3 );\n\t\tswitch ( tag )\n\t\t{\n\t\t\tcase ID_SCE:\n\t\t\tcase ID_LFE:\n\t\t\t{\n\t\t\t\t// mono/LFE channel\n\t\t\t\telementInstanceTag = BitBufferReadSmall( bits, 4 );\n\t\t\t\tmActiveElements |= (1u << elementInstanceTag);\n\n\t\t\t\t// read the 12 unused header bits\n\t\t\t\tunusedHeader = (uint16_t) BitBufferRead( bits, 12 );\n\t\t\t\tRequireAction( unusedHeader == 0, status = kALAC_ParamError; goto Exit; );\n\n\t\t\t\t// read the 1-bit \"partial frame\" flag, 2-bit \"shift-off\" flag & 1-bit \"escape\" flag\n\t\t\t\theaderByte = (uint8_t) BitBufferRead( bits, 4 );\n\t\t\t\t\n\t\t\t\tpartialFrame = headerByte >> 3;\n\t\t\t\t\n\t\t\t\tbytesShifted = (headerByte >> 1) & 0x3u;\n\t\t\t\tRequireAction( bytesShifted != 3, status = kALAC_ParamError; goto Exit; );\n\n\t\t\t\tshift = bytesShifted * 8;\n\n\t\t\t\tescapeFlag = headerByte & 0x1;\n\n\t\t\t\tchanBits = mConfig.bitDepth - (bytesShifted * 8);\n\t\t\t\t\n\t\t\t\t// check for partial frame to override requested numSamples\n\t\t\t\tif ( partialFrame != 0 )\n\t\t\t\t{\n\t\t\t\t\tnumSamples  = BitBufferRead( bits, 16 ) << 16;\n\t\t\t\t\tnumSamples |= BitBufferRead( bits, 16 );\n\t\t\t\t}\n\n\t\t\t\tif ( escapeFlag == 0 )\n\t\t\t\t{\n\t\t\t\t\t// compressed frame, read rest of parameters\n\t\t\t\t\tmixBits\t= (uint8_t) BitBufferRead( bits, 8 );\n\t\t\t\t\tmixRes\t= (int8_t) BitBufferRead( bits, 8 );\n\t\t\t\t\t//Assert( (mixBits == 0) && (mixRes == 0) );\t\t// no mixing for mono\n\n\t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n\t\t\t\t\tmodeU\t\t= headerByte >> 4;\n\t\t\t\t\tdenShiftU\t= headerByte & 0xfu;\n\t\t\t\t\t\n\t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n\t\t\t\t\tpbFactorU\t= headerByte >> 5;\n\t\t\t\t\tnumU\t\t= headerByte & 0x1fu;\n\n\t\t\t\t\tfor ( i = 0; i < numU; i++ )\n\t\t\t\t\t\tcoefsU[i] = (int16_t) BitBufferRead( bits, 16 );\n\t\t\t\t\t\n\t\t\t\t\t// if shift active, skip the the shift buffer but remember where it starts\n\t\t\t\t\tif ( bytesShifted != 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tshiftBits = *bits;\n\t\t\t\t\t\tBitBufferAdvance( bits, (bytesShifted * 8) * numSamples ); \n\t\t\t\t\t}\n\n\t\t\t\t\t// decompress\n\t\t\t\t\tset_ag_params( &agParams, mConfig.mb, (pb * pbFactorU) / 4, mConfig.kb, numSamples, numSamples, mConfig.maxRun );\n\t\t\t\t\tstatus = dyn_decomp( &agParams, bits, mPredictor, numSamples, chanBits, &bits1 );\n\t\t\t\t\tRequireNoErr( status, goto Exit; );\n\n\t\t\t\t\tif ( modeU == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tunpc_block( mPredictor, mMixBufferU, numSamples, &coefsU[0], numU, chanBits, denShiftU );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// the special \"numActive == 31\" mode can be done in-place\n\t\t\t\t\t\tunpc_block( mPredictor, mPredictor, numSamples, nil, 31, chanBits, 0 );\n\t\t\t\t\t\tunpc_block( mPredictor, mMixBufferU, numSamples, &coefsU[0], numU, chanBits, denShiftU );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//Assert( bytesShifted == 0 );\n\n\t\t\t\t\t// uncompressed frame, copy data into the mix buffer to use common output code\n\t\t\t\t\tshift = 32 - chanBits;\n\t\t\t\t\tif ( chanBits <= 16 )\n\t\t\t\t\t{\n\t\t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, (uint8_t) chanBits );\n\t\t\t\t\t\t\tval = (val << shift) >> shift;\n\t\t\t\t\t\t\tmMixBufferU[i] = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// BitBufferRead() can't read more than 16 bits at a time so break up the reads\n\t\t\t\t\t\textraBits = chanBits - 16;\n\t\t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, 16 );\n\t\t\t\t\t\t\tval = (val << 16) >> shift;\n\t\t\t\t\t\t\tmMixBufferU[i] = val | BitBufferRead( bits, (uint8_t) extraBits );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tmixBits = mixRes = 0;\n\t\t\t\t\tbits1 = chanBits * numSamples;\n\t\t\t\t\tbytesShifted = 0;\n\t\t\t\t}\n\n\t\t\t\t// now read the shifted values into the shift buffer\n\t\t\t\tif ( bytesShifted != 0 )\n\t\t\t\t{\n\t\t\t\t\tshift = bytesShifted * 8;\n\t\t\t\t\t//Assert( shift <= 16 );\n\n\t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n\t\t\t\t\t\tmShiftBuffer[i] = (uint16_t) BitBufferRead( &shiftBits, (uint8_t) shift );\n\t\t\t\t}\n\n\t\t\t\t// convert 32-bit integers into output buffer\n\t\t\t\tswitch ( mConfig.bitDepth )\n\t\t\t\t{\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\tout16 = &((int16_t *)sampleBuffer)[channelIndex];\n\t\t\t\t\t\tfor ( i = 0, j = 0; i < numSamples; i++, j += numChannels )\n\t\t\t\t\t\t\tout16[j] = (int16_t) mMixBufferU[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 20:\n\t\t\t\t\t\tout20 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n\t\t\t\t\t\tcopyPredictorTo20( mMixBufferU, out20, numChannels, numSamples );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 24:\n\t\t\t\t\t\tout24 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n\t\t\t\t\t\tif ( bytesShifted != 0 )\n\t\t\t\t\t\t\tcopyPredictorTo24Shift( mMixBufferU, mShiftBuffer, out24, numChannels, numSamples, bytesShifted );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcopyPredictorTo24( mMixBufferU, out24, numChannels, numSamples );\t\t\t\t\t\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\tout32 = &((int32_t *)sampleBuffer)[channelIndex];\n\t\t\t\t\t\tif ( bytesShifted != 0 )\n\t\t\t\t\t\t\tcopyPredictorTo32Shift( mMixBufferU, mShiftBuffer, out32, numChannels, numSamples, bytesShifted );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcopyPredictorTo32( mMixBufferU, out32, numChannels, numSamples);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchannelIndex += 1;\n\t\t\t\t*outNumSamples = numSamples;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase ID_CPE:\n\t\t\t{\n\t\t\t\t// if decoding this pair would take us over the max channels limit, bail\n\t\t\t\tif ( (channelIndex + 2) > numChannels )\n\t\t\t\t\tgoto NoMoreChannels;\n\n\t\t\t\t// stereo channel pair\n\t\t\t\telementInstanceTag = BitBufferReadSmall( bits, 4 );\n\t\t\t\tmActiveElements |= (1u << elementInstanceTag);\n\n\t\t\t\t// read the 12 unused header bits\n\t\t\t\tunusedHeader = (uint16_t) BitBufferRead( bits, 12 );\n\t\t\t\tRequireAction( unusedHeader == 0, status = kALAC_ParamError; goto Exit; );\n\n\t\t\t\t// read the 1-bit \"partial frame\" flag, 2-bit \"shift-off\" flag & 1-bit \"escape\" flag\n\t\t\t\theaderByte = (uint8_t) BitBufferRead( bits, 4 );\n\t\t\t\t\n\t\t\t\tpartialFrame = headerByte >> 3;\n\t\t\t\t\n\t\t\t\tbytesShifted = (headerByte >> 1) & 0x3u;\n\t\t\t\tRequireAction( bytesShifted != 3, status = kALAC_ParamError; goto Exit; );\n\n\t\t\t\tshift = bytesShifted * 8;\n\n\t\t\t\tescapeFlag = headerByte & 0x1;\n\n\t\t\t\tchanBits = mConfig.bitDepth - (bytesShifted * 8) + 1;\n\t\t\t\t\n\t\t\t\t// check for partial frame length to override requested numSamples\n\t\t\t\tif ( partialFrame != 0 )\n\t\t\t\t{\n\t\t\t\t\tnumSamples  = BitBufferRead( bits, 16 ) << 16;\n\t\t\t\t\tnumSamples |= BitBufferRead( bits, 16 );\n\t\t\t\t}\n\n\t\t\t\tif ( escapeFlag == 0 )\n\t\t\t\t{\n\t\t\t\t\t// compressed frame, read rest of parameters\n\t\t\t\t\tmixBits\t\t= (uint8_t) BitBufferRead( bits, 8 );\n\t\t\t\t\tmixRes\t\t= (int8_t) BitBufferRead( bits, 8 );\n\n\t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n\t\t\t\t\tmodeU\t\t= headerByte >> 4;\n\t\t\t\t\tdenShiftU\t= headerByte & 0xfu;\n\t\t\t\t\t\n\t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n\t\t\t\t\tpbFactorU\t= headerByte >> 5;\n\t\t\t\t\tnumU\t\t= headerByte & 0x1fu;\n\t\t\t\t\tfor ( i = 0; i < numU; i++ )\n\t\t\t\t\t\tcoefsU[i] = (int16_t) BitBufferRead( bits, 16 );\n\n\t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n\t\t\t\t\tmodeV\t\t= headerByte >> 4;\n\t\t\t\t\tdenShiftV\t= headerByte & 0xfu;\n\t\t\t\t\t\n\t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n\t\t\t\t\tpbFactorV\t= headerByte >> 5;\n\t\t\t\t\tnumV\t\t= headerByte & 0x1fu;\n\t\t\t\t\tfor ( i = 0; i < numV; i++ )\n\t\t\t\t\t\tcoefsV[i] = (int16_t) BitBufferRead( bits, 16 );\n\n\t\t\t\t\t// if shift active, skip the interleaved shifted values but remember where they start\n\t\t\t\t\tif ( bytesShifted != 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tshiftBits = *bits;\n\t\t\t\t\t\tBitBufferAdvance( bits, (bytesShifted * 8) * 2 * numSamples );\n\t\t\t\t\t}\n\n\t\t\t\t\t// decompress and run predictor for \"left\" channel\n\t\t\t\t\tset_ag_params( &agParams, mConfig.mb, (pb * pbFactorU) / 4, mConfig.kb, numSamples, numSamples, mConfig.maxRun );\n\t\t\t\t\tstatus = dyn_decomp( &agParams, bits, mPredictor, numSamples, chanBits, &bits1 );\n\t\t\t\t\tRequireNoErr( status, goto Exit; );\n\n\t\t\t\t\tif ( modeU == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tunpc_block( mPredictor, mMixBufferU, numSamples, &coefsU[0], numU, chanBits, denShiftU );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// the special \"numActive == 31\" mode can be done in-place\n\t\t\t\t\t\tunpc_block( mPredictor, mPredictor, numSamples, nil, 31, chanBits, 0 );\n\t\t\t\t\t\tunpc_block( mPredictor, mMixBufferU, numSamples, &coefsU[0], numU, chanBits, denShiftU );\n\t\t\t\t\t}\n\n\t\t\t\t\t// decompress and run predictor for \"right\" channel\n\t\t\t\t\tset_ag_params( &agParams, mConfig.mb, (pb * pbFactorV) / 4, mConfig.kb, numSamples, numSamples, mConfig.maxRun );\n\t\t\t\t\tstatus = dyn_decomp( &agParams, bits, mPredictor, numSamples, chanBits, &bits2 );\n\t\t\t\t\tRequireNoErr( status, goto Exit; );\n\n\t\t\t\t\tif ( modeV == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tunpc_block( mPredictor, mMixBufferV, numSamples, &coefsV[0], numV, chanBits, denShiftV );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// the special \"numActive == 31\" mode can be done in-place\n\t\t\t\t\t\tunpc_block( mPredictor, mPredictor, numSamples, nil, 31, chanBits, 0 );\n\t\t\t\t\t\tunpc_block( mPredictor, mMixBufferV, numSamples, &coefsV[0], numV, chanBits, denShiftV );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//Assert( bytesShifted == 0 );\n\n\t\t\t\t\t// uncompressed frame, copy data into the mix buffers to use common output code\n\t\t\t\t\tchanBits = mConfig.bitDepth;\n\t\t\t\t\tshift = 32 - chanBits;\n\t\t\t\t\tif ( chanBits <= 16 )\n\t\t\t\t\t{\n\t\t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, (uint8_t) chanBits );\n\t\t\t\t\t\t\tval = (val << shift) >> shift;\n\t\t\t\t\t\t\tmMixBufferU[i] = val;\n\n\t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, (uint8_t) chanBits );\n\t\t\t\t\t\t\tval = (val << shift) >> shift;\n\t\t\t\t\t\t\tmMixBufferV[i] = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// BitBufferRead() can't read more than 16 bits at a time so break up the reads\n\t\t\t\t\t\textraBits = chanBits - 16;\n\t\t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, 16 );\n\t\t\t\t\t\t\tval = (val << 16) >> shift;\n\t\t\t\t\t\t\tmMixBufferU[i] = val | BitBufferRead( bits, (uint8_t)extraBits );\n\n\t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, 16 );\n\t\t\t\t\t\t\tval = (val << 16) >> shift;\n\t\t\t\t\t\t\tmMixBufferV[i] = val | BitBufferRead( bits, (uint8_t)extraBits );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbits1 = chanBits * numSamples;\n\t\t\t\t\tbits2 = chanBits * numSamples;\n\t\t\t\t\tmixBits = mixRes = 0;\n\t\t\t\t\tbytesShifted = 0;\n\t\t\t\t}\n\n\t\t\t\t// now read the shifted values into the shift buffer\n\t\t\t\tif ( bytesShifted != 0 )\n\t\t\t\t{\n\t\t\t\t\tshift = bytesShifted * 8;\n\t\t\t\t\t//Assert( shift <= 16 );\n\n\t\t\t\t\tfor ( i = 0; i < (numSamples * 2); i += 2 )\n\t\t\t\t\t{\n\t\t\t\t\t\tmShiftBuffer[i + 0] = (uint16_t) BitBufferRead( &shiftBits, (uint8_t) shift );\n\t\t\t\t\t\tmShiftBuffer[i + 1] = (uint16_t) BitBufferRead( &shiftBits, (uint8_t) shift );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// un-mix the data and convert to output format\n\t\t\t\t// - note that mixRes = 0 means just interleave so we use that path for uncompressed frames\n\t\t\t\tswitch ( mConfig.bitDepth )\n\t\t\t\t{\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\tout16 = &((int16_t *)sampleBuffer)[channelIndex];\n\t\t\t\t\t\tunmix16( mMixBufferU, mMixBufferV, out16, numChannels, numSamples, mixBits, mixRes );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 20:\n\t\t\t\t\t\tout20 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n\t\t\t\t\t\tunmix20( mMixBufferU, mMixBufferV, out20, numChannels, numSamples, mixBits, mixRes );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 24:\n\t\t\t\t\t\tout24 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n\t\t\t\t\t\tunmix24( mMixBufferU, mMixBufferV, out24, numChannels, numSamples,\n\t\t\t\t\t\t\t\t\tmixBits, mixRes, mShiftBuffer, bytesShifted );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\tout32 = &((int32_t *)sampleBuffer)[channelIndex];\n\t\t\t\t\t\tunmix32( mMixBufferU, mMixBufferV, out32, numChannels, numSamples,\n\t\t\t\t\t\t\t\t\tmixBits, mixRes, mShiftBuffer, bytesShifted );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchannelIndex += 2;\n\t\t\t\t*outNumSamples = numSamples;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase ID_CCE:\n\t\t\tcase ID_PCE:\n\t\t\t{\n\t\t\t\t// unsupported element, bail\n\t\t\t\t//AssertNoErr( tag );\n\t\t\t\tstatus = kALAC_ParamError;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase ID_DSE:\n\t\t\t{\n\t\t\t\t// data stream element -- parse but ignore\n\t\t\t\tstatus = this->DataStreamElement( bits );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcase ID_FIL:\n\t\t\t{\n\t\t\t\t// fill element -- parse but ignore\n\t\t\t\tstatus = this->FillElement( bits );\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase ID_END:\n\t\t\t{\n\t\t\t\t// frame end, all done so byte align the frame and check for overruns\n\t\t\t\tBitBufferByteAlign( bits, false );\n\t\t\t\t//Assert( bits->cur == bits->end );\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\n#if ! DEBUG\n\t\t// if we've decoded all of our channels, bail (but not in debug b/c we want to know if we're seeing bad bits)\n\t\t// - this also protects us if the config does not match the bitstream or crap data bits follow the audio bits\n\t\tif ( channelIndex >= numChannels )\n\t\t\tbreak;\n#endif\n\t}\n\nNoMoreChannels:\n\n\t// if we get here and haven't decoded all of the requested channels, fill the remaining channels with zeros\n\tfor ( ; channelIndex < numChannels; channelIndex++ )\n\t{\n\t\tswitch ( mConfig.bitDepth )\n\t\t{\n\t\t\tcase 16:\n\t\t\t{\n\t\t\t\tint16_t *\tfill16 = &((int16_t *)sampleBuffer)[channelIndex];\n\t\t\t\tZero16( fill16, numSamples, numChannels );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 24:\n\t\t\t{\n\t\t\t\tuint8_t *\tfill24 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n\t\t\t\tZero24( fill24, numSamples, numChannels );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 32:\n\t\t\t{\n\t\t\t\tint32_t *\tfill32 = &((int32_t *)sampleBuffer)[channelIndex];\n\t\t\t\tZero32( fill32, numSamples, numChannels );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nExit:\n\treturn status;\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"aglib.h\"",
      "#include \"dplib.h\"",
      "#include \"ALACDecoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Zero32",
          "args": [
            "fill32",
            "numSamples",
            "numChannels"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "Zero32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACDecoder.cpp",
          "lines": "715-726",
          "snippet": "static void Zero32( int32_t * buffer, uint32_t numItems, uint32_t stride )\n{\n\tif ( stride == 1 )\n\t{\n\t\tmemset( buffer, 0, numItems * sizeof(int32_t) );\n\t}\n\telse\n\t{\n\t\tfor ( uint32_t index = 0; index < (numItems * stride); index += stride )\n\t\t\tbuffer[index] = 0;\n\t}\n}",
          "includes": [
            "#include \"EndianPortable.h\"",
            "#include \"ALACBitUtilities.h\"",
            "#include \"matrixlib.h\"",
            "#include \"aglib.h\"",
            "#include \"dplib.h\"",
            "#include \"ALACDecoder.h\"",
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void Zero16( int16_t * buffer, uint32_t numItems, uint32_t stride );",
            "static void Zero24( uint8_t * buffer, uint32_t numItems, uint32_t stride );",
            "static void Zero32( int32_t * buffer, uint32_t numItems, uint32_t stride );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"aglib.h\"\n#include \"dplib.h\"\n#include \"ALACDecoder.h\"\n#include <string.h>\n#include <stdlib.h>\n\nstatic void Zero16( int16_t * buffer, uint32_t numItems, uint32_t stride );\nstatic void Zero24( uint8_t * buffer, uint32_t numItems, uint32_t stride );\nstatic void Zero32( int32_t * buffer, uint32_t numItems, uint32_t stride );\n\nstatic void Zero32( int32_t * buffer, uint32_t numItems, uint32_t stride )\n{\n\tif ( stride == 1 )\n\t{\n\t\tmemset( buffer, 0, numItems * sizeof(int32_t) );\n\t}\n\telse\n\t{\n\t\tfor ( uint32_t index = 0; index < (numItems * stride); index += stride )\n\t\t\tbuffer[index] = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Zero24",
          "args": [
            "fill24",
            "numSamples",
            "numChannels"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "Zero24",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACDecoder.cpp",
          "lines": "698-713",
          "snippet": "static void Zero24( uint8_t * buffer, uint32_t numItems, uint32_t stride )\n{\n\tif ( stride == 1 )\n\t{\n\t\tmemset( buffer, 0, numItems * 3 );\n\t}\n\telse\n\t{\n\t\tfor ( uint32_t index = 0; index < (numItems * stride * 3); index += (stride * 3) )\n\t\t{\n\t\t\tbuffer[index + 0] = 0;\n\t\t\tbuffer[index + 1] = 0;\n\t\t\tbuffer[index + 2] = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"EndianPortable.h\"",
            "#include \"ALACBitUtilities.h\"",
            "#include \"matrixlib.h\"",
            "#include \"aglib.h\"",
            "#include \"dplib.h\"",
            "#include \"ALACDecoder.h\"",
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void Zero16( int16_t * buffer, uint32_t numItems, uint32_t stride );",
            "static void Zero24( uint8_t * buffer, uint32_t numItems, uint32_t stride );",
            "static void Zero32( int32_t * buffer, uint32_t numItems, uint32_t stride );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"aglib.h\"\n#include \"dplib.h\"\n#include \"ALACDecoder.h\"\n#include <string.h>\n#include <stdlib.h>\n\nstatic void Zero16( int16_t * buffer, uint32_t numItems, uint32_t stride );\nstatic void Zero24( uint8_t * buffer, uint32_t numItems, uint32_t stride );\nstatic void Zero32( int32_t * buffer, uint32_t numItems, uint32_t stride );\n\nstatic void Zero24( uint8_t * buffer, uint32_t numItems, uint32_t stride )\n{\n\tif ( stride == 1 )\n\t{\n\t\tmemset( buffer, 0, numItems * 3 );\n\t}\n\telse\n\t{\n\t\tfor ( uint32_t index = 0; index < (numItems * stride * 3); index += (stride * 3) )\n\t\t{\n\t\t\tbuffer[index + 0] = 0;\n\t\t\tbuffer[index + 1] = 0;\n\t\t\tbuffer[index + 2] = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Zero16",
          "args": [
            "fill16",
            "numSamples",
            "numChannels"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "Zero16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACDecoder.cpp",
          "lines": "685-696",
          "snippet": "static void Zero16( int16_t * buffer, uint32_t numItems, uint32_t stride )\n{\n\tif ( stride == 1 )\n\t{\n\t\tmemset( buffer, 0, numItems * sizeof(int16_t) );\n\t}\n\telse\n\t{\n\t\tfor ( uint32_t index = 0; index < (numItems * stride); index += stride )\n\t\t\tbuffer[index] = 0;\n\t}\n}",
          "includes": [
            "#include \"EndianPortable.h\"",
            "#include \"ALACBitUtilities.h\"",
            "#include \"matrixlib.h\"",
            "#include \"aglib.h\"",
            "#include \"dplib.h\"",
            "#include \"ALACDecoder.h\"",
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void Zero16( int16_t * buffer, uint32_t numItems, uint32_t stride );",
            "static void Zero24( uint8_t * buffer, uint32_t numItems, uint32_t stride );",
            "static void Zero32( int32_t * buffer, uint32_t numItems, uint32_t stride );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"aglib.h\"\n#include \"dplib.h\"\n#include \"ALACDecoder.h\"\n#include <string.h>\n#include <stdlib.h>\n\nstatic void Zero16( int16_t * buffer, uint32_t numItems, uint32_t stride );\nstatic void Zero24( uint8_t * buffer, uint32_t numItems, uint32_t stride );\nstatic void Zero32( int32_t * buffer, uint32_t numItems, uint32_t stride );\n\nstatic void Zero16( int16_t * buffer, uint32_t numItems, uint32_t stride )\n{\n\tif ( stride == 1 )\n\t{\n\t\tmemset( buffer, 0, numItems * sizeof(int16_t) );\n\t}\n\telse\n\t{\n\t\tfor ( uint32_t index = 0; index < (numItems * stride); index += stride )\n\t\t\tbuffer[index] = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BitBufferByteAlign",
          "args": [
            "bits",
            "false"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->FillElement",
          "args": [
            "bits"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "FillElement",
          "container": "ALACDecoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACDecoder.cpp",
          "lines": "632-647",
          "snippet": "int32_t ALACDecoder::FillElement( BitBuffer * bits )\n{\n\tint16_t\t\tcount;\n\t\n\t// 4-bit count or (4-bit + 8-bit count) if 4-bit count == 15\n\t// - plus this weird -1 thing I still don't fully understand\n\tcount = BitBufferReadSmall( bits, 4 );\n\tif ( count == 15 )\n\t\tcount += (int16_t) BitBufferReadSmall( bits, 8 ) - 1;\n\n\tBitBufferAdvance( bits, count * 8 );\n\n\tRequireAction( bits->cur <= bits->end, return kALAC_ParamError; );\n\n\treturn ALAC_noErr;\t\n}",
          "includes": [
            "#include \"EndianPortable.h\"",
            "#include \"ALACBitUtilities.h\"",
            "#include \"matrixlib.h\"",
            "#include \"aglib.h\"",
            "#include \"dplib.h\"",
            "#include \"ALACDecoder.h\"",
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"aglib.h\"\n#include \"dplib.h\"\n#include \"ALACDecoder.h\"\n#include <string.h>\n#include <stdlib.h>\n\nALACDecoder {\n  int32_t ALACDecoder::FillElement( BitBuffer * bits )\n  {\n  \tint16_t\t\tcount;\n  \t\n  \t// 4-bit count or (4-bit + 8-bit count) if 4-bit count == 15\n  \t// - plus this weird -1 thing I still don't fully understand\n  \tcount = BitBufferReadSmall( bits, 4 );\n  \tif ( count == 15 )\n  \t\tcount += (int16_t) BitBufferReadSmall( bits, 8 ) - 1;\n  \n  \tBitBufferAdvance( bits, count * 8 );\n  \n  \tRequireAction( bits->cur <= bits->end, return kALAC_ParamError; );\n  \n  \treturn ALAC_noErr;\t\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->DataStreamElement",
          "args": [
            "bits"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "DataStreamElement",
          "container": "ALACDecoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACDecoder.cpp",
          "lines": "653-679",
          "snippet": "int32_t ALACDecoder::DataStreamElement( BitBuffer * bits )\n{\n\tuint8_t\t\telement_instance_tag;\n\tint32_t\t\tdata_byte_align_flag;\n\tuint16_t\t\tcount;\n\t\n\t// the tag associates this data stream element with a given audio element\n\telement_instance_tag = BitBufferReadSmall( bits, 4 );\n\t\n\tdata_byte_align_flag = BitBufferReadOne( bits );\n\n\t// 8-bit count or (8-bit + 8-bit count) if 8-bit count == 255\n\tcount = BitBufferReadSmall( bits, 8 );\n\tif ( count == 255 )\n\t\tcount += BitBufferReadSmall( bits, 8 );\n\n\t// the align flag means the bitstream should be byte-aligned before reading the following data bytes\n\tif ( data_byte_align_flag )\n\t\tBitBufferByteAlign( bits, false );\n\n\t// skip the data bytes\n\tBitBufferAdvance( bits, count * 8 );\n\n\tRequireAction( bits->cur <= bits->end, return kALAC_ParamError; );\n\n\treturn ALAC_noErr;\n}",
          "includes": [
            "#include \"EndianPortable.h\"",
            "#include \"ALACBitUtilities.h\"",
            "#include \"matrixlib.h\"",
            "#include \"aglib.h\"",
            "#include \"dplib.h\"",
            "#include \"ALACDecoder.h\"",
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"aglib.h\"\n#include \"dplib.h\"\n#include \"ALACDecoder.h\"\n#include <string.h>\n#include <stdlib.h>\n\nALACDecoder {\n  int32_t ALACDecoder::DataStreamElement( BitBuffer * bits )\n  {\n  \tuint8_t\t\telement_instance_tag;\n  \tint32_t\t\tdata_byte_align_flag;\n  \tuint16_t\t\tcount;\n  \t\n  \t// the tag associates this data stream element with a given audio element\n  \telement_instance_tag = BitBufferReadSmall( bits, 4 );\n  \t\n  \tdata_byte_align_flag = BitBufferReadOne( bits );\n  \n  \t// 8-bit count or (8-bit + 8-bit count) if 8-bit count == 255\n  \tcount = BitBufferReadSmall( bits, 8 );\n  \tif ( count == 255 )\n  \t\tcount += BitBufferReadSmall( bits, 8 );\n  \n  \t// the align flag means the bitstream should be byte-aligned before reading the following data bytes\n  \tif ( data_byte_align_flag )\n  \t\tBitBufferByteAlign( bits, false );\n  \n  \t// skip the data bytes\n  \tBitBufferAdvance( bits, count * 8 );\n  \n  \tRequireAction( bits->cur <= bits->end, return kALAC_ParamError; );\n  \n  \treturn ALAC_noErr;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmix32",
          "args": [
            "mMixBufferU",
            "mMixBufferV",
            "out32",
            "numChannels",
            "numSamples",
            "mixBits",
            "mixRes",
            "mShiftBuffer",
            "bytesShifted"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmix24",
          "args": [
            "mMixBufferU",
            "mMixBufferV",
            "out24",
            "numChannels",
            "numSamples",
            "mixBits",
            "mixRes",
            "mShiftBuffer",
            "bytesShifted"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmix20",
          "args": [
            "mMixBufferU",
            "mMixBufferV",
            "out20",
            "numChannels",
            "numSamples",
            "mixBits",
            "mixRes"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmix16",
          "args": [
            "mMixBufferU",
            "mMixBufferV",
            "out16",
            "numChannels",
            "numSamples",
            "mixBits",
            "mixRes"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "&shiftBits",
            "(uint8_t) shift"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "&shiftBits",
            "(uint8_t) shift"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "(uint8_t)extraBits"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "16"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "(uint8_t)extraBits"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "16"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "(uint8_t) chanBits"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "(uint8_t) chanBits"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpc_block",
          "args": [
            "mPredictor",
            "mMixBufferV",
            "numSamples",
            "&coefsV[0]",
            "numV",
            "chanBits",
            "denShiftV"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpc_block",
          "args": [
            "mPredictor",
            "mPredictor",
            "numSamples",
            "nil",
            "31",
            "chanBits",
            "0"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpc_block",
          "args": [
            "mPredictor",
            "mMixBufferV",
            "numSamples",
            "&coefsV[0]",
            "numV",
            "chanBits",
            "denShiftV"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dyn_decomp",
          "args": [
            "&agParams",
            "bits",
            "mPredictor",
            "numSamples",
            "chanBits",
            "&bits2"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ag_params",
          "args": [
            "&agParams",
            "mConfig.mb",
            "(pb * pbFactorV) / 4",
            "mConfig.kb",
            "numSamples",
            "numSamples",
            "mConfig.maxRun"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpc_block",
          "args": [
            "mPredictor",
            "mMixBufferU",
            "numSamples",
            "&coefsU[0]",
            "numU",
            "chanBits",
            "denShiftU"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpc_block",
          "args": [
            "mPredictor",
            "mPredictor",
            "numSamples",
            "nil",
            "31",
            "chanBits",
            "0"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpc_block",
          "args": [
            "mPredictor",
            "mMixBufferU",
            "numSamples",
            "&coefsU[0]",
            "numU",
            "chanBits",
            "denShiftU"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dyn_decomp",
          "args": [
            "&agParams",
            "bits",
            "mPredictor",
            "numSamples",
            "chanBits",
            "&bits1"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ag_params",
          "args": [
            "&agParams",
            "mConfig.mb",
            "(pb * pbFactorU) / 4",
            "mConfig.kb",
            "numSamples",
            "numSamples",
            "mConfig.maxRun"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferAdvance",
          "args": [
            "bits",
            "(bytesShifted * 8) * 2 * numSamples"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "16"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "8"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "8"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "16"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "8"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "8"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "8"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "8"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "16"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "16"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RequireAction",
          "args": [
            "bytesShifted != 3",
            "status = kALAC_ParamError"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "4"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RequireAction",
          "args": [
            "unusedHeader == 0",
            "status = kALAC_ParamError"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "12"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferReadSmall",
          "args": [
            "bits",
            "4"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyPredictorTo32",
          "args": [
            "mMixBufferU",
            "out32",
            "numChannels",
            "numSamples"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyPredictorTo32Shift",
          "args": [
            "mMixBufferU",
            "mShiftBuffer",
            "out32",
            "numChannels",
            "numSamples",
            "bytesShifted"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyPredictorTo24",
          "args": [
            "mMixBufferU",
            "out24",
            "numChannels",
            "numSamples"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyPredictorTo24Shift",
          "args": [
            "mMixBufferU",
            "mShiftBuffer",
            "out24",
            "numChannels",
            "numSamples",
            "bytesShifted"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyPredictorTo20",
          "args": [
            "mMixBufferU",
            "out20",
            "numChannels",
            "numSamples"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "&shiftBits",
            "(uint8_t) shift"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "(uint8_t) extraBits"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "16"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "(uint8_t) chanBits"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpc_block",
          "args": [
            "mPredictor",
            "mMixBufferU",
            "numSamples",
            "&coefsU[0]",
            "numU",
            "chanBits",
            "denShiftU"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpc_block",
          "args": [
            "mPredictor",
            "mPredictor",
            "numSamples",
            "nil",
            "31",
            "chanBits",
            "0"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpc_block",
          "args": [
            "mPredictor",
            "mMixBufferU",
            "numSamples",
            "&coefsU[0]",
            "numU",
            "chanBits",
            "denShiftU"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dyn_decomp",
          "args": [
            "&agParams",
            "bits",
            "mPredictor",
            "numSamples",
            "chanBits",
            "&bits1"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ag_params",
          "args": [
            "&agParams",
            "mConfig.mb",
            "(pb * pbFactorU) / 4",
            "mConfig.kb",
            "numSamples",
            "numSamples",
            "mConfig.maxRun"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferAdvance",
          "args": [
            "bits",
            "(bytesShifted * 8) * numSamples"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "16"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "8"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "8"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "8"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "8"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "16"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "16"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RequireAction",
          "args": [
            "bytesShifted != 3",
            "status = kALAC_ParamError"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "4"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RequireAction",
          "args": [
            "unusedHeader == 0",
            "status = kALAC_ParamError"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferRead",
          "args": [
            "bits",
            "12"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferReadSmall",
          "args": [
            "bits",
            "4"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferReadSmall",
          "args": [
            "bits",
            "3"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RequireAction",
          "args": [
            "bits->cur < bits->end",
            "status = kALAC_ParamError"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RequireAction",
          "args": [
            "numChannels > 0",
            "returnkALAC_ParamError;"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RequireAction",
          "args": [
            "(bits != nil) && (sampleBuffer != nil) && (outNumSamples != nil)",
            "returnkALAC_ParamError;"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"aglib.h\"\n#include \"dplib.h\"\n#include \"ALACDecoder.h\"\n#include <string.h>\n#include <stdlib.h>\n\nALACDecoder {\n  int32_t ALACDecoder::Decode( BitBuffer * bits, uint8_t * sampleBuffer, uint32_t numSamples, uint32_t numChannels, uint32_t * outNumSamples )\n  {\n  \tBitBuffer\t\t\tshiftBits;\n  \tuint32_t            bits1, bits2;\n  \tuint8_t\t\t\t\ttag;\n  \tuint8_t\t\t\t\telementInstanceTag;\n  \tAGParamRec\t\t\tagParams;\n  \tuint32_t\t\t\t\tchannelIndex;\n  \tint16_t\t\t\t\tcoefsU[32];\t\t// max possible size is 32 although NUMCOEPAIRS is the current limit\n  \tint16_t\t\t\t\tcoefsV[32];\n  \tuint8_t\t\t\t\tnumU, numV;\n  \tuint8_t\t\t\t\tmixBits;\n  \tint8_t\t\t\t\tmixRes;\n  \tuint16_t\t\t\tunusedHeader;\n  \tuint8_t\t\t\t\tescapeFlag;\n  \tuint32_t\t\t\tchanBits;\n  \tuint8_t\t\t\t\tbytesShifted;\n  \tuint32_t\t\t\tshift;\n  \tuint8_t\t\t\t\tmodeU, modeV;\n  \tuint32_t\t\t\tdenShiftU, denShiftV;\n  \tuint16_t\t\t\tpbFactorU, pbFactorV;\n  \tuint16_t\t\t\tpb;\n  \tint16_t *\t\t\tsamples;\n  \tint16_t *\t\t\tout16;\n  \tuint8_t *\t\t\tout20;\n  \tuint8_t *\t\t\tout24;\n  \tint32_t *\t\t\tout32;\n  \tuint8_t\t\t\t\theaderByte;\n  \tuint8_t\t\t\t\tpartialFrame;\n  \tuint32_t\t\t\textraBits;\n  \tint32_t\t\t\t\tval;\n  \tuint32_t\t\t\ti, j;\n  \tint32_t             status;\n  \t\n  \tRequireAction( (bits != nil) && (sampleBuffer != nil) && (outNumSamples != nil), return kALAC_ParamError; );\n  \tRequireAction( numChannels > 0, return kALAC_ParamError; );\n  \n  \tmActiveElements = 0;\n  \tchannelIndex\t= 0;\n  \t\n  \tsamples = (int16_t *) sampleBuffer;\n  \n  \tstatus = ALAC_noErr;\n  \t*outNumSamples = numSamples;\n  \n  \twhile ( status == ALAC_noErr )\n  \t{\n  \t\t// bail if we ran off the end of the buffer\n      \tRequireAction( bits->cur < bits->end, status = kALAC_ParamError; goto Exit; );\n  \n  \t\t// copy global decode params for this element\n  \t\tpb = mConfig.pb;\n  \n  \t\t// read element tag\n  \t\ttag = BitBufferReadSmall( bits, 3 );\n  \t\tswitch ( tag )\n  \t\t{\n  \t\t\tcase ID_SCE:\n  \t\t\tcase ID_LFE:\n  \t\t\t{\n  \t\t\t\t// mono/LFE channel\n  \t\t\t\telementInstanceTag = BitBufferReadSmall( bits, 4 );\n  \t\t\t\tmActiveElements |= (1u << elementInstanceTag);\n  \n  \t\t\t\t// read the 12 unused header bits\n  \t\t\t\tunusedHeader = (uint16_t) BitBufferRead( bits, 12 );\n  \t\t\t\tRequireAction( unusedHeader == 0, status = kALAC_ParamError; goto Exit; );\n  \n  \t\t\t\t// read the 1-bit \"partial frame\" flag, 2-bit \"shift-off\" flag & 1-bit \"escape\" flag\n  \t\t\t\theaderByte = (uint8_t) BitBufferRead( bits, 4 );\n  \t\t\t\t\n  \t\t\t\tpartialFrame = headerByte >> 3;\n  \t\t\t\t\n  \t\t\t\tbytesShifted = (headerByte >> 1) & 0x3u;\n  \t\t\t\tRequireAction( bytesShifted != 3, status = kALAC_ParamError; goto Exit; );\n  \n  \t\t\t\tshift = bytesShifted * 8;\n  \n  \t\t\t\tescapeFlag = headerByte & 0x1;\n  \n  \t\t\t\tchanBits = mConfig.bitDepth - (bytesShifted * 8);\n  \t\t\t\t\n  \t\t\t\t// check for partial frame to override requested numSamples\n  \t\t\t\tif ( partialFrame != 0 )\n  \t\t\t\t{\n  \t\t\t\t\tnumSamples  = BitBufferRead( bits, 16 ) << 16;\n  \t\t\t\t\tnumSamples |= BitBufferRead( bits, 16 );\n  \t\t\t\t}\n  \n  \t\t\t\tif ( escapeFlag == 0 )\n  \t\t\t\t{\n  \t\t\t\t\t// compressed frame, read rest of parameters\n  \t\t\t\t\tmixBits\t= (uint8_t) BitBufferRead( bits, 8 );\n  \t\t\t\t\tmixRes\t= (int8_t) BitBufferRead( bits, 8 );\n  \t\t\t\t\t//Assert( (mixBits == 0) && (mixRes == 0) );\t\t// no mixing for mono\n  \n  \t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n  \t\t\t\t\tmodeU\t\t= headerByte >> 4;\n  \t\t\t\t\tdenShiftU\t= headerByte & 0xfu;\n  \t\t\t\t\t\n  \t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n  \t\t\t\t\tpbFactorU\t= headerByte >> 5;\n  \t\t\t\t\tnumU\t\t= headerByte & 0x1fu;\n  \n  \t\t\t\t\tfor ( i = 0; i < numU; i++ )\n  \t\t\t\t\t\tcoefsU[i] = (int16_t) BitBufferRead( bits, 16 );\n  \t\t\t\t\t\n  \t\t\t\t\t// if shift active, skip the the shift buffer but remember where it starts\n  \t\t\t\t\tif ( bytesShifted != 0 )\n  \t\t\t\t\t{\n  \t\t\t\t\t\tshiftBits = *bits;\n  \t\t\t\t\t\tBitBufferAdvance( bits, (bytesShifted * 8) * numSamples ); \n  \t\t\t\t\t}\n  \n  \t\t\t\t\t// decompress\n  \t\t\t\t\tset_ag_params( &agParams, mConfig.mb, (pb * pbFactorU) / 4, mConfig.kb, numSamples, numSamples, mConfig.maxRun );\n  \t\t\t\t\tstatus = dyn_decomp( &agParams, bits, mPredictor, numSamples, chanBits, &bits1 );\n  \t\t\t\t\tRequireNoErr( status, goto Exit; );\n  \n  \t\t\t\t\tif ( modeU == 0 )\n  \t\t\t\t\t{\n  \t\t\t\t\t\tunpc_block( mPredictor, mMixBufferU, numSamples, &coefsU[0], numU, chanBits, denShiftU );\n  \t\t\t\t\t}\n  \t\t\t\t\telse\n  \t\t\t\t\t{\n  \t\t\t\t\t\t// the special \"numActive == 31\" mode can be done in-place\n  \t\t\t\t\t\tunpc_block( mPredictor, mPredictor, numSamples, nil, 31, chanBits, 0 );\n  \t\t\t\t\t\tunpc_block( mPredictor, mMixBufferU, numSamples, &coefsU[0], numU, chanBits, denShiftU );\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t{\n  \t\t\t\t\t//Assert( bytesShifted == 0 );\n  \n  \t\t\t\t\t// uncompressed frame, copy data into the mix buffer to use common output code\n  \t\t\t\t\tshift = 32 - chanBits;\n  \t\t\t\t\tif ( chanBits <= 16 )\n  \t\t\t\t\t{\n  \t\t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n  \t\t\t\t\t\t{\n  \t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, (uint8_t) chanBits );\n  \t\t\t\t\t\t\tval = (val << shift) >> shift;\n  \t\t\t\t\t\t\tmMixBufferU[i] = val;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t\telse\n  \t\t\t\t\t{\n  \t\t\t\t\t\t// BitBufferRead() can't read more than 16 bits at a time so break up the reads\n  \t\t\t\t\t\textraBits = chanBits - 16;\n  \t\t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n  \t\t\t\t\t\t{\n  \t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, 16 );\n  \t\t\t\t\t\t\tval = (val << 16) >> shift;\n  \t\t\t\t\t\t\tmMixBufferU[i] = val | BitBufferRead( bits, (uint8_t) extraBits );\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \n  \t\t\t\t\tmixBits = mixRes = 0;\n  \t\t\t\t\tbits1 = chanBits * numSamples;\n  \t\t\t\t\tbytesShifted = 0;\n  \t\t\t\t}\n  \n  \t\t\t\t// now read the shifted values into the shift buffer\n  \t\t\t\tif ( bytesShifted != 0 )\n  \t\t\t\t{\n  \t\t\t\t\tshift = bytesShifted * 8;\n  \t\t\t\t\t//Assert( shift <= 16 );\n  \n  \t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n  \t\t\t\t\t\tmShiftBuffer[i] = (uint16_t) BitBufferRead( &shiftBits, (uint8_t) shift );\n  \t\t\t\t}\n  \n  \t\t\t\t// convert 32-bit integers into output buffer\n  \t\t\t\tswitch ( mConfig.bitDepth )\n  \t\t\t\t{\n  \t\t\t\t\tcase 16:\n  \t\t\t\t\t\tout16 = &((int16_t *)sampleBuffer)[channelIndex];\n  \t\t\t\t\t\tfor ( i = 0, j = 0; i < numSamples; i++, j += numChannels )\n  \t\t\t\t\t\t\tout16[j] = (int16_t) mMixBufferU[i];\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\tcase 20:\n  \t\t\t\t\t\tout20 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n  \t\t\t\t\t\tcopyPredictorTo20( mMixBufferU, out20, numChannels, numSamples );\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\tcase 24:\n  \t\t\t\t\t\tout24 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n  \t\t\t\t\t\tif ( bytesShifted != 0 )\n  \t\t\t\t\t\t\tcopyPredictorTo24Shift( mMixBufferU, mShiftBuffer, out24, numChannels, numSamples, bytesShifted );\n  \t\t\t\t\t\telse\n  \t\t\t\t\t\t\tcopyPredictorTo24( mMixBufferU, out24, numChannels, numSamples );\t\t\t\t\t\t\t\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\tcase 32:\n  \t\t\t\t\t\tout32 = &((int32_t *)sampleBuffer)[channelIndex];\n  \t\t\t\t\t\tif ( bytesShifted != 0 )\n  \t\t\t\t\t\t\tcopyPredictorTo32Shift( mMixBufferU, mShiftBuffer, out32, numChannels, numSamples, bytesShifted );\n  \t\t\t\t\t\telse\n  \t\t\t\t\t\t\tcopyPredictorTo32( mMixBufferU, out32, numChannels, numSamples);\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t}\n  \n  \t\t\t\tchannelIndex += 1;\n  \t\t\t\t*outNumSamples = numSamples;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \n  \t\t\tcase ID_CPE:\n  \t\t\t{\n  \t\t\t\t// if decoding this pair would take us over the max channels limit, bail\n  \t\t\t\tif ( (channelIndex + 2) > numChannels )\n  \t\t\t\t\tgoto NoMoreChannels;\n  \n  \t\t\t\t// stereo channel pair\n  \t\t\t\telementInstanceTag = BitBufferReadSmall( bits, 4 );\n  \t\t\t\tmActiveElements |= (1u << elementInstanceTag);\n  \n  \t\t\t\t// read the 12 unused header bits\n  \t\t\t\tunusedHeader = (uint16_t) BitBufferRead( bits, 12 );\n  \t\t\t\tRequireAction( unusedHeader == 0, status = kALAC_ParamError; goto Exit; );\n  \n  \t\t\t\t// read the 1-bit \"partial frame\" flag, 2-bit \"shift-off\" flag & 1-bit \"escape\" flag\n  \t\t\t\theaderByte = (uint8_t) BitBufferRead( bits, 4 );\n  \t\t\t\t\n  \t\t\t\tpartialFrame = headerByte >> 3;\n  \t\t\t\t\n  \t\t\t\tbytesShifted = (headerByte >> 1) & 0x3u;\n  \t\t\t\tRequireAction( bytesShifted != 3, status = kALAC_ParamError; goto Exit; );\n  \n  \t\t\t\tshift = bytesShifted * 8;\n  \n  \t\t\t\tescapeFlag = headerByte & 0x1;\n  \n  \t\t\t\tchanBits = mConfig.bitDepth - (bytesShifted * 8) + 1;\n  \t\t\t\t\n  \t\t\t\t// check for partial frame length to override requested numSamples\n  \t\t\t\tif ( partialFrame != 0 )\n  \t\t\t\t{\n  \t\t\t\t\tnumSamples  = BitBufferRead( bits, 16 ) << 16;\n  \t\t\t\t\tnumSamples |= BitBufferRead( bits, 16 );\n  \t\t\t\t}\n  \n  \t\t\t\tif ( escapeFlag == 0 )\n  \t\t\t\t{\n  \t\t\t\t\t// compressed frame, read rest of parameters\n  \t\t\t\t\tmixBits\t\t= (uint8_t) BitBufferRead( bits, 8 );\n  \t\t\t\t\tmixRes\t\t= (int8_t) BitBufferRead( bits, 8 );\n  \n  \t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n  \t\t\t\t\tmodeU\t\t= headerByte >> 4;\n  \t\t\t\t\tdenShiftU\t= headerByte & 0xfu;\n  \t\t\t\t\t\n  \t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n  \t\t\t\t\tpbFactorU\t= headerByte >> 5;\n  \t\t\t\t\tnumU\t\t= headerByte & 0x1fu;\n  \t\t\t\t\tfor ( i = 0; i < numU; i++ )\n  \t\t\t\t\t\tcoefsU[i] = (int16_t) BitBufferRead( bits, 16 );\n  \n  \t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n  \t\t\t\t\tmodeV\t\t= headerByte >> 4;\n  \t\t\t\t\tdenShiftV\t= headerByte & 0xfu;\n  \t\t\t\t\t\n  \t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n  \t\t\t\t\tpbFactorV\t= headerByte >> 5;\n  \t\t\t\t\tnumV\t\t= headerByte & 0x1fu;\n  \t\t\t\t\tfor ( i = 0; i < numV; i++ )\n  \t\t\t\t\t\tcoefsV[i] = (int16_t) BitBufferRead( bits, 16 );\n  \n  \t\t\t\t\t// if shift active, skip the interleaved shifted values but remember where they start\n  \t\t\t\t\tif ( bytesShifted != 0 )\n  \t\t\t\t\t{\n  \t\t\t\t\t\tshiftBits = *bits;\n  \t\t\t\t\t\tBitBufferAdvance( bits, (bytesShifted * 8) * 2 * numSamples );\n  \t\t\t\t\t}\n  \n  \t\t\t\t\t// decompress and run predictor for \"left\" channel\n  \t\t\t\t\tset_ag_params( &agParams, mConfig.mb, (pb * pbFactorU) / 4, mConfig.kb, numSamples, numSamples, mConfig.maxRun );\n  \t\t\t\t\tstatus = dyn_decomp( &agParams, bits, mPredictor, numSamples, chanBits, &bits1 );\n  \t\t\t\t\tRequireNoErr( status, goto Exit; );\n  \n  \t\t\t\t\tif ( modeU == 0 )\n  \t\t\t\t\t{\n  \t\t\t\t\t\tunpc_block( mPredictor, mMixBufferU, numSamples, &coefsU[0], numU, chanBits, denShiftU );\n  \t\t\t\t\t}\n  \t\t\t\t\telse\n  \t\t\t\t\t{\n  \t\t\t\t\t\t// the special \"numActive == 31\" mode can be done in-place\n  \t\t\t\t\t\tunpc_block( mPredictor, mPredictor, numSamples, nil, 31, chanBits, 0 );\n  \t\t\t\t\t\tunpc_block( mPredictor, mMixBufferU, numSamples, &coefsU[0], numU, chanBits, denShiftU );\n  \t\t\t\t\t}\n  \n  \t\t\t\t\t// decompress and run predictor for \"right\" channel\n  \t\t\t\t\tset_ag_params( &agParams, mConfig.mb, (pb * pbFactorV) / 4, mConfig.kb, numSamples, numSamples, mConfig.maxRun );\n  \t\t\t\t\tstatus = dyn_decomp( &agParams, bits, mPredictor, numSamples, chanBits, &bits2 );\n  \t\t\t\t\tRequireNoErr( status, goto Exit; );\n  \n  \t\t\t\t\tif ( modeV == 0 )\n  \t\t\t\t\t{\n  \t\t\t\t\t\tunpc_block( mPredictor, mMixBufferV, numSamples, &coefsV[0], numV, chanBits, denShiftV );\n  \t\t\t\t\t}\n  \t\t\t\t\telse\n  \t\t\t\t\t{\n  \t\t\t\t\t\t// the special \"numActive == 31\" mode can be done in-place\n  \t\t\t\t\t\tunpc_block( mPredictor, mPredictor, numSamples, nil, 31, chanBits, 0 );\n  \t\t\t\t\t\tunpc_block( mPredictor, mMixBufferV, numSamples, &coefsV[0], numV, chanBits, denShiftV );\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t{\n  \t\t\t\t\t//Assert( bytesShifted == 0 );\n  \n  \t\t\t\t\t// uncompressed frame, copy data into the mix buffers to use common output code\n  \t\t\t\t\tchanBits = mConfig.bitDepth;\n  \t\t\t\t\tshift = 32 - chanBits;\n  \t\t\t\t\tif ( chanBits <= 16 )\n  \t\t\t\t\t{\n  \t\t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n  \t\t\t\t\t\t{\n  \t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, (uint8_t) chanBits );\n  \t\t\t\t\t\t\tval = (val << shift) >> shift;\n  \t\t\t\t\t\t\tmMixBufferU[i] = val;\n  \n  \t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, (uint8_t) chanBits );\n  \t\t\t\t\t\t\tval = (val << shift) >> shift;\n  \t\t\t\t\t\t\tmMixBufferV[i] = val;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t\telse\n  \t\t\t\t\t{\n  \t\t\t\t\t\t// BitBufferRead() can't read more than 16 bits at a time so break up the reads\n  \t\t\t\t\t\textraBits = chanBits - 16;\n  \t\t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n  \t\t\t\t\t\t{\n  \t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, 16 );\n  \t\t\t\t\t\t\tval = (val << 16) >> shift;\n  \t\t\t\t\t\t\tmMixBufferU[i] = val | BitBufferRead( bits, (uint8_t)extraBits );\n  \n  \t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, 16 );\n  \t\t\t\t\t\t\tval = (val << 16) >> shift;\n  \t\t\t\t\t\t\tmMixBufferV[i] = val | BitBufferRead( bits, (uint8_t)extraBits );\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \n  \t\t\t\t\tbits1 = chanBits * numSamples;\n  \t\t\t\t\tbits2 = chanBits * numSamples;\n  \t\t\t\t\tmixBits = mixRes = 0;\n  \t\t\t\t\tbytesShifted = 0;\n  \t\t\t\t}\n  \n  \t\t\t\t// now read the shifted values into the shift buffer\n  \t\t\t\tif ( bytesShifted != 0 )\n  \t\t\t\t{\n  \t\t\t\t\tshift = bytesShifted * 8;\n  \t\t\t\t\t//Assert( shift <= 16 );\n  \n  \t\t\t\t\tfor ( i = 0; i < (numSamples * 2); i += 2 )\n  \t\t\t\t\t{\n  \t\t\t\t\t\tmShiftBuffer[i + 0] = (uint16_t) BitBufferRead( &shiftBits, (uint8_t) shift );\n  \t\t\t\t\t\tmShiftBuffer[i + 1] = (uint16_t) BitBufferRead( &shiftBits, (uint8_t) shift );\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \n  \t\t\t\t// un-mix the data and convert to output format\n  \t\t\t\t// - note that mixRes = 0 means just interleave so we use that path for uncompressed frames\n  \t\t\t\tswitch ( mConfig.bitDepth )\n  \t\t\t\t{\n  \t\t\t\t\tcase 16:\n  \t\t\t\t\t\tout16 = &((int16_t *)sampleBuffer)[channelIndex];\n  \t\t\t\t\t\tunmix16( mMixBufferU, mMixBufferV, out16, numChannels, numSamples, mixBits, mixRes );\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\tcase 20:\n  \t\t\t\t\t\tout20 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n  \t\t\t\t\t\tunmix20( mMixBufferU, mMixBufferV, out20, numChannels, numSamples, mixBits, mixRes );\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\tcase 24:\n  \t\t\t\t\t\tout24 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n  \t\t\t\t\t\tunmix24( mMixBufferU, mMixBufferV, out24, numChannels, numSamples,\n  \t\t\t\t\t\t\t\t\tmixBits, mixRes, mShiftBuffer, bytesShifted );\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\tcase 32:\n  \t\t\t\t\t\tout32 = &((int32_t *)sampleBuffer)[channelIndex];\n  \t\t\t\t\t\tunmix32( mMixBufferU, mMixBufferV, out32, numChannels, numSamples,\n  \t\t\t\t\t\t\t\t\tmixBits, mixRes, mShiftBuffer, bytesShifted );\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t}\n  \n  \t\t\t\tchannelIndex += 2;\n  \t\t\t\t*outNumSamples = numSamples;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \n  \t\t\tcase ID_CCE:\n  \t\t\tcase ID_PCE:\n  \t\t\t{\n  \t\t\t\t// unsupported element, bail\n  \t\t\t\t//AssertNoErr( tag );\n  \t\t\t\tstatus = kALAC_ParamError;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \n  \t\t\tcase ID_DSE:\n  \t\t\t{\n  \t\t\t\t// data stream element -- parse but ignore\n  \t\t\t\tstatus = this->DataStreamElement( bits );\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\t\n  \t\t\tcase ID_FIL:\n  \t\t\t{\n  \t\t\t\t// fill element -- parse but ignore\n  \t\t\t\tstatus = this->FillElement( bits );\n  \t\t\t\tbreak;\n  \t\t\t}\n  \n  \t\t\tcase ID_END:\n  \t\t\t{\n  \t\t\t\t// frame end, all done so byte align the frame and check for overruns\n  \t\t\t\tBitBufferByteAlign( bits, false );\n  \t\t\t\t//Assert( bits->cur == bits->end );\n  \t\t\t\tgoto Exit;\n  \t\t\t}\n  \t\t}\n  \n  #if ! DEBUG\n  \t\t// if we've decoded all of our channels, bail (but not in debug b/c we want to know if we're seeing bad bits)\n  \t\t// - this also protects us if the config does not match the bitstream or crap data bits follow the audio bits\n  \t\tif ( channelIndex >= numChannels )\n  \t\t\tbreak;\n  #endif\n  \t}\n  \n  NoMoreChannels:\n  \n  \t// if we get here and haven't decoded all of the requested channels, fill the remaining channels with zeros\n  \tfor ( ; channelIndex < numChannels; channelIndex++ )\n  \t{\n  \t\tswitch ( mConfig.bitDepth )\n  \t\t{\n  \t\t\tcase 16:\n  \t\t\t{\n  \t\t\t\tint16_t *\tfill16 = &((int16_t *)sampleBuffer)[channelIndex];\n  \t\t\t\tZero16( fill16, numSamples, numChannels );\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tcase 24:\n  \t\t\t{\n  \t\t\t\tuint8_t *\tfill24 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n  \t\t\t\tZero24( fill24, numSamples, numChannels );\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tcase 32:\n  \t\t\t{\n  \t\t\t\tint32_t *\tfill32 = &((int32_t *)sampleBuffer)[channelIndex];\n  \t\t\t\tZero32( fill32, numSamples, numChannels );\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t}\n  \n  Exit:\n  \treturn status;\n  }\n}"
  },
  {
    "function_name": "Init",
    "container": "ALACDecoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACDecoder.cpp",
    "lines": "88-156",
    "snippet": "int32_t ALACDecoder::Init( void * inMagicCookie, uint32_t inMagicCookieSize )\n{\n\tint32_t\t\tstatus = ALAC_noErr;\n    ALACSpecificConfig theConfig;\n    uint8_t * theActualCookie = (uint8_t *)inMagicCookie;\n    uint32_t theCookieBytesRemaining = inMagicCookieSize;\n\n    // For historical reasons the decoder needs to be resilient to magic cookies vended by older encoders.\n    // As specified in the ALACMagicCookieDescription.txt document, there may be additional data encapsulating \n    // the ALACSpecificConfig. This would consist of format ('frma') and 'alac' atoms which precede the\n    // ALACSpecificConfig. \n    // See ALACMagicCookieDescription.txt for additional documentation concerning the 'magic cookie'\n    \n    // skip format ('frma') atom if present\n    if (theActualCookie[4] == 'f' && theActualCookie[5] == 'r' && theActualCookie[6] == 'm' && theActualCookie[7] == 'a')\n    {\n        theActualCookie += 12;\n        theCookieBytesRemaining -= 12;\n    }\n    \n    // skip 'alac' atom header if present\n    if (theActualCookie[4] == 'a' && theActualCookie[5] == 'l' && theActualCookie[6] == 'a' && theActualCookie[7] == 'c')\n    {\n        theActualCookie += 12;\n        theCookieBytesRemaining -= 12;\n    }\n\n    // read the ALACSpecificConfig\n    if (theCookieBytesRemaining >= sizeof(ALACSpecificConfig))\n    {\n        memcpy(&theConfig, theActualCookie, sizeof(ALACSpecificConfig));\n\n        theConfig.frameLength = Swap32BtoN(theConfig.frameLength);\n        theConfig.maxRun = Swap16BtoN(theConfig.maxRun);\n        theConfig.maxFrameBytes = Swap32BtoN(theConfig.maxFrameBytes);\n        theConfig.avgBitRate = Swap32BtoN(theConfig.avgBitRate);\n        theConfig.sampleRate = Swap32BtoN(theConfig.sampleRate);\n\n        mConfig = theConfig;\n        \n        RequireAction( mConfig.compatibleVersion <= kALACVersion, return kALAC_ParamError; );\n\n        // allocate mix buffers\n        mMixBufferU = (int32_t *) calloc( mConfig.frameLength * sizeof(int32_t), 1 );\n        mMixBufferV = (int32_t *) calloc( mConfig.frameLength * sizeof(int32_t), 1 );\n\n        // allocate dynamic predictor buffer\n        mPredictor = (int32_t *) calloc( mConfig.frameLength * sizeof(int32_t), 1 );\n\n        // \"shift off\" buffer shares memory with predictor buffer\n        mShiftBuffer = (uint16_t *) mPredictor;\n        \n        RequireAction( (mMixBufferU != nil) && (mMixBufferV != nil) && (mPredictor != nil),\n                        status = kALAC_MemFullError; goto Exit; );\n     }\n    else\n    {\n        status = kALAC_ParamError;\n    }\n\n    // skip to Channel Layout Info\n    // theActualCookie += sizeof(ALACSpecificConfig);\n    \n    // Currently, the Channel Layout Info portion of the magic cookie (as defined in the \n    // ALACMagicCookieDescription.txt document) is unused by the decoder. \n    \nExit:\n\treturn status;\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"aglib.h\"",
      "#include \"dplib.h\"",
      "#include \"ALACDecoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RequireAction",
          "args": [
            "(mMixBufferU != nil) && (mMixBufferV != nil) && (mPredictor != nil)",
            "status = kALAC_MemFullError"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "mConfig.frameLength * sizeof(int32_t)",
            "1"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "mConfig.frameLength * sizeof(int32_t)",
            "1"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "mConfig.frameLength * sizeof(int32_t)",
            "1"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RequireAction",
          "args": [
            "mConfig.compatibleVersion <= kALACVersion",
            "returnkALAC_ParamError;"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Swap32BtoN",
          "args": [
            "theConfig.sampleRate"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Swap32BtoN",
          "args": [
            "theConfig.avgBitRate"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Swap32BtoN",
          "args": [
            "theConfig.maxFrameBytes"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Swap16BtoN",
          "args": [
            "theConfig.maxRun"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Swap32BtoN",
          "args": [
            "theConfig.frameLength"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&theConfig",
            "theActualCookie",
            "sizeof(ALACSpecificConfig)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"aglib.h\"\n#include \"dplib.h\"\n#include \"ALACDecoder.h\"\n#include <string.h>\n#include <stdlib.h>\n\nALACDecoder {\n  int32_t ALACDecoder::Init( void * inMagicCookie, uint32_t inMagicCookieSize )\n  {\n  \tint32_t\t\tstatus = ALAC_noErr;\n      ALACSpecificConfig theConfig;\n      uint8_t * theActualCookie = (uint8_t *)inMagicCookie;\n      uint32_t theCookieBytesRemaining = inMagicCookieSize;\n  \n      // For historical reasons the decoder needs to be resilient to magic cookies vended by older encoders.\n      // As specified in the ALACMagicCookieDescription.txt document, there may be additional data encapsulating \n      // the ALACSpecificConfig. This would consist of format ('frma') and 'alac' atoms which precede the\n      // ALACSpecificConfig. \n      // See ALACMagicCookieDescription.txt for additional documentation concerning the 'magic cookie'\n      \n      // skip format ('frma') atom if present\n      if (theActualCookie[4] == 'f' && theActualCookie[5] == 'r' && theActualCookie[6] == 'm' && theActualCookie[7] == 'a')\n      {\n          theActualCookie += 12;\n          theCookieBytesRemaining -= 12;\n      }\n      \n      // skip 'alac' atom header if present\n      if (theActualCookie[4] == 'a' && theActualCookie[5] == 'l' && theActualCookie[6] == 'a' && theActualCookie[7] == 'c')\n      {\n          theActualCookie += 12;\n          theCookieBytesRemaining -= 12;\n      }\n  \n      // read the ALACSpecificConfig\n      if (theCookieBytesRemaining >= sizeof(ALACSpecificConfig))\n      {\n          memcpy(&theConfig, theActualCookie, sizeof(ALACSpecificConfig));\n  \n          theConfig.frameLength = Swap32BtoN(theConfig.frameLength);\n          theConfig.maxRun = Swap16BtoN(theConfig.maxRun);\n          theConfig.maxFrameBytes = Swap32BtoN(theConfig.maxFrameBytes);\n          theConfig.avgBitRate = Swap32BtoN(theConfig.avgBitRate);\n          theConfig.sampleRate = Swap32BtoN(theConfig.sampleRate);\n  \n          mConfig = theConfig;\n          \n          RequireAction( mConfig.compatibleVersion <= kALACVersion, return kALAC_ParamError; );\n  \n          // allocate mix buffers\n          mMixBufferU = (int32_t *) calloc( mConfig.frameLength * sizeof(int32_t), 1 );\n          mMixBufferV = (int32_t *) calloc( mConfig.frameLength * sizeof(int32_t), 1 );\n  \n          // allocate dynamic predictor buffer\n          mPredictor = (int32_t *) calloc( mConfig.frameLength * sizeof(int32_t), 1 );\n  \n          // \"shift off\" buffer shares memory with predictor buffer\n          mShiftBuffer = (uint16_t *) mPredictor;\n          \n          RequireAction( (mMixBufferU != nil) && (mMixBufferV != nil) && (mPredictor != nil),\n                          status = kALAC_MemFullError; goto Exit; );\n       }\n      else\n      {\n          status = kALAC_ParamError;\n      }\n  \n      // skip to Channel Layout Info\n      // theActualCookie += sizeof(ALACSpecificConfig);\n      \n      // Currently, the Channel Layout Info portion of the magic cookie (as defined in the \n      // ALACMagicCookieDescription.txt document) is unused by the decoder. \n      \n  Exit:\n  \treturn status;\n  }\n}"
  },
  {
    "function_name": "~ALACDecoder",
    "container": "ALACDecoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACDecoder.cpp",
    "lines": "61-82",
    "snippet": "ALACDecoder::~ALACDecoder()\n{\n\t// delete the matrix mixing buffers\n\tif ( mMixBufferU )\n    {\n\t\tfree(mMixBufferU);\n        mMixBufferU = NULL;\n    }\n\tif ( mMixBufferV )\n    {\n\t\tfree(mMixBufferV);\n        mMixBufferV = NULL;\n    }\n\t\n\t// delete the dynamic predictor's \"corrector\" buffer\n\t// - note: mShiftBuffer shares memory with this buffer\n\tif ( mPredictor )\n    {\n\t\tfree(mPredictor);\n        mPredictor = NULL;\n    }\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"aglib.h\"",
      "#include \"dplib.h\"",
      "#include \"ALACDecoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mPredictor"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "_af_setup_free_instruments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Setup.cpp",
          "lines": "251-263",
          "snippet": "void _af_setup_free_instruments (AFfilesetup setup)\n{\n\tif (setup->instruments)\n\t{\n\t\tfor (int i=0; i < setup->instrumentCount; i++)\n\t\t\tsetup->instruments[i].freeLoops();\n\n\t\tfree(setup->instruments);\n\t}\n\n\tsetup->instruments = NULL;\n\tsetup->instrumentCount = 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"audiofile.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"Setup.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"audiofile.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include <string.h>\n#include <stdlib.h>\n#include \"Setup.h\"\n#include \"config.h\"\n\nvoid _af_setup_free_instruments (AFfilesetup setup)\n{\n\tif (setup->instruments)\n\t{\n\t\tfor (int i=0; i < setup->instrumentCount; i++)\n\t\t\tsetup->instruments[i].freeLoops();\n\n\t\tfree(setup->instruments);\n\t}\n\n\tsetup->instruments = NULL;\n\tsetup->instrumentCount = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"aglib.h\"\n#include \"dplib.h\"\n#include \"ALACDecoder.h\"\n#include <string.h>\n#include <stdlib.h>\n\nALACDecoder {\n  ALACDecoder::~ALACDecoder()\n  {\n  \t// delete the matrix mixing buffers\n  \tif ( mMixBufferU )\n      {\n  \t\tfree(mMixBufferU);\n          mMixBufferU = NULL;\n      }\n  \tif ( mMixBufferV )\n      {\n  \t\tfree(mMixBufferV);\n          mMixBufferV = NULL;\n      }\n  \t\n  \t// delete the dynamic predictor's \"corrector\" buffer\n  \t// - note: mShiftBuffer shares memory with this buffer\n  \tif ( mPredictor )\n      {\n  \t\tfree(mPredictor);\n          mPredictor = NULL;\n      }\n  }\n}"
  },
  {
    "function_name": "ALACDecoder",
    "container": "ALACDecoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACDecoder.cpp",
    "lines": "49-56",
    "snippet": "ALACDecoder::ALACDecoder() :\n\tmMixBufferU( nil ),\n\tmMixBufferV( nil ),\n\tmPredictor( nil ),\n\tmShiftBuffer( nil )\n{\n\tmemset( &mConfig, 0, sizeof(mConfig) );\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"aglib.h\"",
      "#include \"dplib.h\"",
      "#include \"ALACDecoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&mConfig",
            "0",
            "sizeof(mConfig)"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"aglib.h\"\n#include \"dplib.h\"\n#include \"ALACDecoder.h\"\n#include <string.h>\n#include <stdlib.h>\n\nALACDecoder {\n  ALACDecoder::ALACDecoder() :\n  \tmMixBufferU( nil ),\n  \tmMixBufferV( nil ),\n  \tmPredictor( nil ),\n  \tmShiftBuffer( nil )\n  {\n  \tmemset( &mConfig, 0, sizeof(mConfig) );\n  }\n}"
  }
]