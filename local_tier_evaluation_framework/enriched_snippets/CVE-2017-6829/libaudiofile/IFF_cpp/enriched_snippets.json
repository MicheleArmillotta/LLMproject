[
  {
    "function_name": "writeMiscellaneous",
    "container": "IFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
    "lines": "445-491",
    "snippet": "status IFFFile::writeMiscellaneous()\n{\n\tif (m_miscellaneousPosition == 0)\n\t\tm_miscellaneousPosition = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_miscellaneousPosition, File::SeekFromBeginning);\n\n\tfor (int i=0; i<m_miscellaneousCount; i++)\n\t{\n\t\tMiscellaneous *misc = &m_miscellaneous[i];\n\t\tTag chunkType;\n\t\tuint32_t chunkSize;\n\t\tuint8_t padByte = 0;\n\n\t\tswitch (misc->type)\n\t\t{\n\t\t\tcase AF_MISC_NAME:\n\t\t\t\tchunkType = \"NAME\"; break;\n\t\t\tcase AF_MISC_AUTH:\n\t\t\t\tchunkType = \"AUTH\"; break;\n\t\t\tcase AF_MISC_COPY:\n\t\t\t\tchunkType = \"(c) \"; break;\n\t\t\tcase AF_MISC_ANNO:\n\t\t\t\tchunkType = \"ANNO\"; break;\n\t\t}\n\n\t\twriteTag(&chunkType);\n\n\t\tchunkSize = misc->size;\n\t\twriteU32(&chunkSize);\n\n\t\t/*\n\t\t\tWrite the miscellaneous buffer and then a pad byte\n\t\t\tif necessary.  If the buffer is null, skip the space\n\t\t\tfor now.\n\t\t*/\n\t\tif (misc->buffer != NULL)\n\t\t\tm_fh->write(misc->buffer, misc->size);\n\t\telse\n\t\t\tm_fh->seek(misc->size, File::SeekFromCurrent);\n\n\t\tif (misc->size % 2 != 0)\n\t\t\twriteU8(&padByte);\n\t}\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"IFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeU8",
          "args": [
            "&padByte"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "writeU8",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "430-430",
          "snippet": "bool _AFfilehandle::writeU8(const uint8_t *v) { return writeValue(m_fh, v); }",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU8(const uint8_t *v) { return writeValue(m_fh, v); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "misc->size",
            "File::SeekFromCurrent"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "misc->buffer",
            "misc->size"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&chunkSize"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeTag",
          "args": [
            "&chunkType"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "writeTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "484-488",
          "snippet": "bool _AFfilehandle::writeTag(const Tag *t)\n{\n\tuint32_t v = t->value();\n\treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeTag(const Tag *t)\n  {\n  \tuint32_t v = t->value();\n  \treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::writeMiscellaneous()\n  {\n  \tif (m_miscellaneousPosition == 0)\n  \t\tm_miscellaneousPosition = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_miscellaneousPosition, File::SeekFromBeginning);\n  \n  \tfor (int i=0; i<m_miscellaneousCount; i++)\n  \t{\n  \t\tMiscellaneous *misc = &m_miscellaneous[i];\n  \t\tTag chunkType;\n  \t\tuint32_t chunkSize;\n  \t\tuint8_t padByte = 0;\n  \n  \t\tswitch (misc->type)\n  \t\t{\n  \t\t\tcase AF_MISC_NAME:\n  \t\t\t\tchunkType = \"NAME\"; break;\n  \t\t\tcase AF_MISC_AUTH:\n  \t\t\t\tchunkType = \"AUTH\"; break;\n  \t\t\tcase AF_MISC_COPY:\n  \t\t\t\tchunkType = \"(c) \"; break;\n  \t\t\tcase AF_MISC_ANNO:\n  \t\t\t\tchunkType = \"ANNO\"; break;\n  \t\t}\n  \n  \t\twriteTag(&chunkType);\n  \n  \t\tchunkSize = misc->size;\n  \t\twriteU32(&chunkSize);\n  \n  \t\t/*\n  \t\t\tWrite the miscellaneous buffer and then a pad byte\n  \t\t\tif necessary.  If the buffer is null, skip the space\n  \t\t\tfor now.\n  \t\t*/\n  \t\tif (misc->buffer != NULL)\n  \t\t\tm_fh->write(misc->buffer, misc->size);\n  \t\telse\n  \t\t\tm_fh->seek(misc->size, File::SeekFromCurrent);\n  \n  \t\tif (misc->size % 2 != 0)\n  \t\t\twriteU8(&padByte);\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeBODY",
    "container": "IFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
    "lines": "406-439",
    "snippet": "status IFFFile::writeBODY()\n{\n\tuint32_t chunkSize;\n\n\tTrack *track = getTrack();\n\n\tif (m_BODY_offset == 0)\n\t\tm_BODY_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_BODY_offset, File::SeekFromBeginning);\n\n\tm_fh->write(\"BODY\", 4);\n\n\t/*\n\t\tIFF/8SVX supports only one channel, so the number of\n\t\tframes is equal to the number of samples, and each\n\t\tsample is one byte.\n\t*/\n\tchunkSize = track->totalfframes;\n\twriteU32(&chunkSize);\n\n\tif (track->fpos_first_frame == 0)\n\t\ttrack->fpos_first_frame = m_fh->tell();\n\n\t/* Add a pad byte to the end of the chunk if the chunk size is odd. */\n\tif ((chunkSize % 2) == 1)\n\t{\n\t\tuint8_t zero = 0;\n\t\tm_fh->seek(m_BODY_offset + 8 + chunkSize, File::SeekFromBeginning);\n\t\twriteU8(&zero);\n\t}\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"IFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeU8",
          "args": [
            "&zero"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "writeU8",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "430-430",
          "snippet": "bool _AFfilehandle::writeU8(const uint8_t *v) { return writeValue(m_fh, v); }",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU8(const uint8_t *v) { return writeValue(m_fh, v); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "m_BODY_offset + 8 + chunkSize",
            "File::SeekFromBeginning"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&chunkSize"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "\"BODY\"",
            "4"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::writeBODY()\n  {\n  \tuint32_t chunkSize;\n  \n  \tTrack *track = getTrack();\n  \n  \tif (m_BODY_offset == 0)\n  \t\tm_BODY_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_BODY_offset, File::SeekFromBeginning);\n  \n  \tm_fh->write(\"BODY\", 4);\n  \n  \t/*\n  \t\tIFF/8SVX supports only one channel, so the number of\n  \t\tframes is equal to the number of samples, and each\n  \t\tsample is one byte.\n  \t*/\n  \tchunkSize = track->totalfframes;\n  \twriteU32(&chunkSize);\n  \n  \tif (track->fpos_first_frame == 0)\n  \t\ttrack->fpos_first_frame = m_fh->tell();\n  \n  \t/* Add a pad byte to the end of the chunk if the chunk size is odd. */\n  \tif ((chunkSize % 2) == 1)\n  \t{\n  \t\tuint8_t zero = 0;\n  \t\tm_fh->seek(m_BODY_offset + 8 + chunkSize, File::SeekFromBeginning);\n  \t\twriteU8(&zero);\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeVHDR",
    "container": "IFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
    "lines": "356-404",
    "snippet": "status IFFFile::writeVHDR()\n{\n\tuint32_t chunkSize;\n\tuint32_t oneShotSamples, repeatSamples, samplesPerRepeat;\n\tuint16_t sampleRate;\n\tuint8_t octaves, compression;\n\tuint32_t volume;\n\n\t/*\n\t\tIf VHDR_offset hasn't been set yet, set it to the\n\t\tcurrent offset.\n\t*/\n\tif (m_VHDR_offset == 0)\n\t\tm_VHDR_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_VHDR_offset, File::SeekFromBeginning);\n\n\tTrack *track = getTrack();\n\n\tm_fh->write(\"VHDR\", 4);\n\n\tchunkSize = 20;\n\twriteU32(&chunkSize);\n\n\t/*\n\t\tIFF/8SVX files have only one audio channel, so the\n\t\tnumber of samples is equal to the number of frames.\n\t*/\n\toneShotSamples = track->totalfframes;\n\twriteU32(&oneShotSamples);\n\trepeatSamples = 0;\n\twriteU32(&repeatSamples);\n\tsamplesPerRepeat = 0;\n\twriteU32(&samplesPerRepeat);\n\n\tsampleRate = track->f.sampleRate;\n\twriteU16(&sampleRate);\n\n\toctaves = 0;\n\tcompression = 0;\n\twriteU8(&octaves);\n\twriteU8(&compression);\n\n\t/* Volume is in fixed-point notation; 65536 means gain of 1.0. */\n\tvolume = 65536;\n\twriteU32(&volume);\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"IFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&volume"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU8",
          "args": [
            "&compression"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "writeU8",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "430-430",
          "snippet": "bool _AFfilehandle::writeU8(const uint8_t *v) { return writeValue(m_fh, v); }",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU8(const uint8_t *v) { return writeValue(m_fh, v); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU16",
          "args": [
            "&sampleRate"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "writeU16",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "433-436",
          "snippet": "bool _AFfilehandle::writeU16(const uint16_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU16(const uint16_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "\"VHDR\"",
            "4"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "m_VHDR_offset",
            "File::SeekFromBeginning"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::writeVHDR()\n  {\n  \tuint32_t chunkSize;\n  \tuint32_t oneShotSamples, repeatSamples, samplesPerRepeat;\n  \tuint16_t sampleRate;\n  \tuint8_t octaves, compression;\n  \tuint32_t volume;\n  \n  \t/*\n  \t\tIf VHDR_offset hasn't been set yet, set it to the\n  \t\tcurrent offset.\n  \t*/\n  \tif (m_VHDR_offset == 0)\n  \t\tm_VHDR_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_VHDR_offset, File::SeekFromBeginning);\n  \n  \tTrack *track = getTrack();\n  \n  \tm_fh->write(\"VHDR\", 4);\n  \n  \tchunkSize = 20;\n  \twriteU32(&chunkSize);\n  \n  \t/*\n  \t\tIFF/8SVX files have only one audio channel, so the\n  \t\tnumber of samples is equal to the number of frames.\n  \t*/\n  \toneShotSamples = track->totalfframes;\n  \twriteU32(&oneShotSamples);\n  \trepeatSamples = 0;\n  \twriteU32(&repeatSamples);\n  \tsamplesPerRepeat = 0;\n  \twriteU32(&samplesPerRepeat);\n  \n  \tsampleRate = track->f.sampleRate;\n  \twriteU16(&sampleRate);\n  \n  \toctaves = 0;\n  \tcompression = 0;\n  \twriteU8(&octaves);\n  \twriteU8(&compression);\n  \n  \t/* Volume is in fixed-point notation; 65536 means gain of 1.0. */\n  \tvolume = 65536;\n  \twriteU32(&volume);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "update",
    "container": "IFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
    "lines": "337-354",
    "snippet": "status IFFFile::update()\n{\n\tuint32_t length;\n\n\twriteVHDR();\n\twriteMiscellaneous();\n\twriteBODY();\n\n\t/* Get the length of the file. */\n\tlength = m_fh->length();\n\tlength -= 8;\n\n\t/* Set the length of the FORM chunk. */\n\tm_fh->seek(4, File::SeekFromBeginning);\n\twriteU32(&length);\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"IFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&length"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "4",
            "File::SeekFromBeginning"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->length",
          "args": [],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "182-185",
          "snippet": "off_t FileVF::length()\n{\n\treturn m_vf->length(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::length()\n  {\n  \treturn m_vf->length(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeBODY",
          "args": [],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "writeBODY",
          "container": "IFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
          "lines": "406-439",
          "snippet": "status IFFFile::writeBODY()\n{\n\tuint32_t chunkSize;\n\n\tTrack *track = getTrack();\n\n\tif (m_BODY_offset == 0)\n\t\tm_BODY_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_BODY_offset, File::SeekFromBeginning);\n\n\tm_fh->write(\"BODY\", 4);\n\n\t/*\n\t\tIFF/8SVX supports only one channel, so the number of\n\t\tframes is equal to the number of samples, and each\n\t\tsample is one byte.\n\t*/\n\tchunkSize = track->totalfframes;\n\twriteU32(&chunkSize);\n\n\tif (track->fpos_first_frame == 0)\n\t\ttrack->fpos_first_frame = m_fh->tell();\n\n\t/* Add a pad byte to the end of the chunk if the chunk size is odd. */\n\tif ((chunkSize % 2) == 1)\n\t{\n\t\tuint8_t zero = 0;\n\t\tm_fh->seek(m_BODY_offset + 8 + chunkSize, File::SeekFromBeginning);\n\t\twriteU8(&zero);\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"IFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::writeBODY()\n  {\n  \tuint32_t chunkSize;\n  \n  \tTrack *track = getTrack();\n  \n  \tif (m_BODY_offset == 0)\n  \t\tm_BODY_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_BODY_offset, File::SeekFromBeginning);\n  \n  \tm_fh->write(\"BODY\", 4);\n  \n  \t/*\n  \t\tIFF/8SVX supports only one channel, so the number of\n  \t\tframes is equal to the number of samples, and each\n  \t\tsample is one byte.\n  \t*/\n  \tchunkSize = track->totalfframes;\n  \twriteU32(&chunkSize);\n  \n  \tif (track->fpos_first_frame == 0)\n  \t\ttrack->fpos_first_frame = m_fh->tell();\n  \n  \t/* Add a pad byte to the end of the chunk if the chunk size is odd. */\n  \tif ((chunkSize % 2) == 1)\n  \t{\n  \t\tuint8_t zero = 0;\n  \t\tm_fh->seek(m_BODY_offset + 8 + chunkSize, File::SeekFromBeginning);\n  \t\twriteU8(&zero);\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeMiscellaneous",
          "args": [],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "writeMiscellaneous",
          "container": "IFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
          "lines": "445-491",
          "snippet": "status IFFFile::writeMiscellaneous()\n{\n\tif (m_miscellaneousPosition == 0)\n\t\tm_miscellaneousPosition = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_miscellaneousPosition, File::SeekFromBeginning);\n\n\tfor (int i=0; i<m_miscellaneousCount; i++)\n\t{\n\t\tMiscellaneous *misc = &m_miscellaneous[i];\n\t\tTag chunkType;\n\t\tuint32_t chunkSize;\n\t\tuint8_t padByte = 0;\n\n\t\tswitch (misc->type)\n\t\t{\n\t\t\tcase AF_MISC_NAME:\n\t\t\t\tchunkType = \"NAME\"; break;\n\t\t\tcase AF_MISC_AUTH:\n\t\t\t\tchunkType = \"AUTH\"; break;\n\t\t\tcase AF_MISC_COPY:\n\t\t\t\tchunkType = \"(c) \"; break;\n\t\t\tcase AF_MISC_ANNO:\n\t\t\t\tchunkType = \"ANNO\"; break;\n\t\t}\n\n\t\twriteTag(&chunkType);\n\n\t\tchunkSize = misc->size;\n\t\twriteU32(&chunkSize);\n\n\t\t/*\n\t\t\tWrite the miscellaneous buffer and then a pad byte\n\t\t\tif necessary.  If the buffer is null, skip the space\n\t\t\tfor now.\n\t\t*/\n\t\tif (misc->buffer != NULL)\n\t\t\tm_fh->write(misc->buffer, misc->size);\n\t\telse\n\t\t\tm_fh->seek(misc->size, File::SeekFromCurrent);\n\n\t\tif (misc->size % 2 != 0)\n\t\t\twriteU8(&padByte);\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"IFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::writeMiscellaneous()\n  {\n  \tif (m_miscellaneousPosition == 0)\n  \t\tm_miscellaneousPosition = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_miscellaneousPosition, File::SeekFromBeginning);\n  \n  \tfor (int i=0; i<m_miscellaneousCount; i++)\n  \t{\n  \t\tMiscellaneous *misc = &m_miscellaneous[i];\n  \t\tTag chunkType;\n  \t\tuint32_t chunkSize;\n  \t\tuint8_t padByte = 0;\n  \n  \t\tswitch (misc->type)\n  \t\t{\n  \t\t\tcase AF_MISC_NAME:\n  \t\t\t\tchunkType = \"NAME\"; break;\n  \t\t\tcase AF_MISC_AUTH:\n  \t\t\t\tchunkType = \"AUTH\"; break;\n  \t\t\tcase AF_MISC_COPY:\n  \t\t\t\tchunkType = \"(c) \"; break;\n  \t\t\tcase AF_MISC_ANNO:\n  \t\t\t\tchunkType = \"ANNO\"; break;\n  \t\t}\n  \n  \t\twriteTag(&chunkType);\n  \n  \t\tchunkSize = misc->size;\n  \t\twriteU32(&chunkSize);\n  \n  \t\t/*\n  \t\t\tWrite the miscellaneous buffer and then a pad byte\n  \t\t\tif necessary.  If the buffer is null, skip the space\n  \t\t\tfor now.\n  \t\t*/\n  \t\tif (misc->buffer != NULL)\n  \t\t\tm_fh->write(misc->buffer, misc->size);\n  \t\telse\n  \t\t\tm_fh->seek(misc->size, File::SeekFromCurrent);\n  \n  \t\tif (misc->size % 2 != 0)\n  \t\t\twriteU8(&padByte);\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeVHDR",
          "args": [],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "writeVHDR",
          "container": "IFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
          "lines": "356-404",
          "snippet": "status IFFFile::writeVHDR()\n{\n\tuint32_t chunkSize;\n\tuint32_t oneShotSamples, repeatSamples, samplesPerRepeat;\n\tuint16_t sampleRate;\n\tuint8_t octaves, compression;\n\tuint32_t volume;\n\n\t/*\n\t\tIf VHDR_offset hasn't been set yet, set it to the\n\t\tcurrent offset.\n\t*/\n\tif (m_VHDR_offset == 0)\n\t\tm_VHDR_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_VHDR_offset, File::SeekFromBeginning);\n\n\tTrack *track = getTrack();\n\n\tm_fh->write(\"VHDR\", 4);\n\n\tchunkSize = 20;\n\twriteU32(&chunkSize);\n\n\t/*\n\t\tIFF/8SVX files have only one audio channel, so the\n\t\tnumber of samples is equal to the number of frames.\n\t*/\n\toneShotSamples = track->totalfframes;\n\twriteU32(&oneShotSamples);\n\trepeatSamples = 0;\n\twriteU32(&repeatSamples);\n\tsamplesPerRepeat = 0;\n\twriteU32(&samplesPerRepeat);\n\n\tsampleRate = track->f.sampleRate;\n\twriteU16(&sampleRate);\n\n\toctaves = 0;\n\tcompression = 0;\n\twriteU8(&octaves);\n\twriteU8(&compression);\n\n\t/* Volume is in fixed-point notation; 65536 means gain of 1.0. */\n\tvolume = 65536;\n\twriteU32(&volume);\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"IFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::writeVHDR()\n  {\n  \tuint32_t chunkSize;\n  \tuint32_t oneShotSamples, repeatSamples, samplesPerRepeat;\n  \tuint16_t sampleRate;\n  \tuint8_t octaves, compression;\n  \tuint32_t volume;\n  \n  \t/*\n  \t\tIf VHDR_offset hasn't been set yet, set it to the\n  \t\tcurrent offset.\n  \t*/\n  \tif (m_VHDR_offset == 0)\n  \t\tm_VHDR_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_VHDR_offset, File::SeekFromBeginning);\n  \n  \tTrack *track = getTrack();\n  \n  \tm_fh->write(\"VHDR\", 4);\n  \n  \tchunkSize = 20;\n  \twriteU32(&chunkSize);\n  \n  \t/*\n  \t\tIFF/8SVX files have only one audio channel, so the\n  \t\tnumber of samples is equal to the number of frames.\n  \t*/\n  \toneShotSamples = track->totalfframes;\n  \twriteU32(&oneShotSamples);\n  \trepeatSamples = 0;\n  \twriteU32(&repeatSamples);\n  \tsamplesPerRepeat = 0;\n  \twriteU32(&samplesPerRepeat);\n  \n  \tsampleRate = track->f.sampleRate;\n  \twriteU16(&sampleRate);\n  \n  \toctaves = 0;\n  \tcompression = 0;\n  \twriteU8(&octaves);\n  \twriteU8(&compression);\n  \n  \t/* Volume is in fixed-point notation; 65536 means gain of 1.0. */\n  \tvolume = 65536;\n  \twriteU32(&volume);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::update()\n  {\n  \tuint32_t length;\n  \n  \twriteVHDR();\n  \twriteMiscellaneous();\n  \twriteBODY();\n  \n  \t/* Get the length of the file. */\n  \tlength = m_fh->length();\n  \tlength -= 8;\n  \n  \t/* Set the length of the FORM chunk. */\n  \tm_fh->seek(4, File::SeekFromBeginning);\n  \twriteU32(&length);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeInit",
    "container": "IFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
    "lines": "318-335",
    "snippet": "status IFFFile::writeInit(AFfilesetup setup)\n{\n\tif (initFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\n\tuint32_t fileSize = 0;\n\n\tm_fh->write(\"FORM\", 4);\n\twriteU32(&fileSize);\n\n\tm_fh->write(\"8SVX\", 4);\n\n\twriteVHDR();\n\twriteMiscellaneous();\n\twriteBODY();\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"IFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeBODY",
          "args": [],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "writeBODY",
          "container": "IFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
          "lines": "406-439",
          "snippet": "status IFFFile::writeBODY()\n{\n\tuint32_t chunkSize;\n\n\tTrack *track = getTrack();\n\n\tif (m_BODY_offset == 0)\n\t\tm_BODY_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_BODY_offset, File::SeekFromBeginning);\n\n\tm_fh->write(\"BODY\", 4);\n\n\t/*\n\t\tIFF/8SVX supports only one channel, so the number of\n\t\tframes is equal to the number of samples, and each\n\t\tsample is one byte.\n\t*/\n\tchunkSize = track->totalfframes;\n\twriteU32(&chunkSize);\n\n\tif (track->fpos_first_frame == 0)\n\t\ttrack->fpos_first_frame = m_fh->tell();\n\n\t/* Add a pad byte to the end of the chunk if the chunk size is odd. */\n\tif ((chunkSize % 2) == 1)\n\t{\n\t\tuint8_t zero = 0;\n\t\tm_fh->seek(m_BODY_offset + 8 + chunkSize, File::SeekFromBeginning);\n\t\twriteU8(&zero);\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"IFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::writeBODY()\n  {\n  \tuint32_t chunkSize;\n  \n  \tTrack *track = getTrack();\n  \n  \tif (m_BODY_offset == 0)\n  \t\tm_BODY_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_BODY_offset, File::SeekFromBeginning);\n  \n  \tm_fh->write(\"BODY\", 4);\n  \n  \t/*\n  \t\tIFF/8SVX supports only one channel, so the number of\n  \t\tframes is equal to the number of samples, and each\n  \t\tsample is one byte.\n  \t*/\n  \tchunkSize = track->totalfframes;\n  \twriteU32(&chunkSize);\n  \n  \tif (track->fpos_first_frame == 0)\n  \t\ttrack->fpos_first_frame = m_fh->tell();\n  \n  \t/* Add a pad byte to the end of the chunk if the chunk size is odd. */\n  \tif ((chunkSize % 2) == 1)\n  \t{\n  \t\tuint8_t zero = 0;\n  \t\tm_fh->seek(m_BODY_offset + 8 + chunkSize, File::SeekFromBeginning);\n  \t\twriteU8(&zero);\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeMiscellaneous",
          "args": [],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "writeMiscellaneous",
          "container": "IFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
          "lines": "445-491",
          "snippet": "status IFFFile::writeMiscellaneous()\n{\n\tif (m_miscellaneousPosition == 0)\n\t\tm_miscellaneousPosition = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_miscellaneousPosition, File::SeekFromBeginning);\n\n\tfor (int i=0; i<m_miscellaneousCount; i++)\n\t{\n\t\tMiscellaneous *misc = &m_miscellaneous[i];\n\t\tTag chunkType;\n\t\tuint32_t chunkSize;\n\t\tuint8_t padByte = 0;\n\n\t\tswitch (misc->type)\n\t\t{\n\t\t\tcase AF_MISC_NAME:\n\t\t\t\tchunkType = \"NAME\"; break;\n\t\t\tcase AF_MISC_AUTH:\n\t\t\t\tchunkType = \"AUTH\"; break;\n\t\t\tcase AF_MISC_COPY:\n\t\t\t\tchunkType = \"(c) \"; break;\n\t\t\tcase AF_MISC_ANNO:\n\t\t\t\tchunkType = \"ANNO\"; break;\n\t\t}\n\n\t\twriteTag(&chunkType);\n\n\t\tchunkSize = misc->size;\n\t\twriteU32(&chunkSize);\n\n\t\t/*\n\t\t\tWrite the miscellaneous buffer and then a pad byte\n\t\t\tif necessary.  If the buffer is null, skip the space\n\t\t\tfor now.\n\t\t*/\n\t\tif (misc->buffer != NULL)\n\t\t\tm_fh->write(misc->buffer, misc->size);\n\t\telse\n\t\t\tm_fh->seek(misc->size, File::SeekFromCurrent);\n\n\t\tif (misc->size % 2 != 0)\n\t\t\twriteU8(&padByte);\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"IFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::writeMiscellaneous()\n  {\n  \tif (m_miscellaneousPosition == 0)\n  \t\tm_miscellaneousPosition = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_miscellaneousPosition, File::SeekFromBeginning);\n  \n  \tfor (int i=0; i<m_miscellaneousCount; i++)\n  \t{\n  \t\tMiscellaneous *misc = &m_miscellaneous[i];\n  \t\tTag chunkType;\n  \t\tuint32_t chunkSize;\n  \t\tuint8_t padByte = 0;\n  \n  \t\tswitch (misc->type)\n  \t\t{\n  \t\t\tcase AF_MISC_NAME:\n  \t\t\t\tchunkType = \"NAME\"; break;\n  \t\t\tcase AF_MISC_AUTH:\n  \t\t\t\tchunkType = \"AUTH\"; break;\n  \t\t\tcase AF_MISC_COPY:\n  \t\t\t\tchunkType = \"(c) \"; break;\n  \t\t\tcase AF_MISC_ANNO:\n  \t\t\t\tchunkType = \"ANNO\"; break;\n  \t\t}\n  \n  \t\twriteTag(&chunkType);\n  \n  \t\tchunkSize = misc->size;\n  \t\twriteU32(&chunkSize);\n  \n  \t\t/*\n  \t\t\tWrite the miscellaneous buffer and then a pad byte\n  \t\t\tif necessary.  If the buffer is null, skip the space\n  \t\t\tfor now.\n  \t\t*/\n  \t\tif (misc->buffer != NULL)\n  \t\t\tm_fh->write(misc->buffer, misc->size);\n  \t\telse\n  \t\t\tm_fh->seek(misc->size, File::SeekFromCurrent);\n  \n  \t\tif (misc->size % 2 != 0)\n  \t\t\twriteU8(&padByte);\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeVHDR",
          "args": [],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "writeVHDR",
          "container": "IFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
          "lines": "356-404",
          "snippet": "status IFFFile::writeVHDR()\n{\n\tuint32_t chunkSize;\n\tuint32_t oneShotSamples, repeatSamples, samplesPerRepeat;\n\tuint16_t sampleRate;\n\tuint8_t octaves, compression;\n\tuint32_t volume;\n\n\t/*\n\t\tIf VHDR_offset hasn't been set yet, set it to the\n\t\tcurrent offset.\n\t*/\n\tif (m_VHDR_offset == 0)\n\t\tm_VHDR_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_VHDR_offset, File::SeekFromBeginning);\n\n\tTrack *track = getTrack();\n\n\tm_fh->write(\"VHDR\", 4);\n\n\tchunkSize = 20;\n\twriteU32(&chunkSize);\n\n\t/*\n\t\tIFF/8SVX files have only one audio channel, so the\n\t\tnumber of samples is equal to the number of frames.\n\t*/\n\toneShotSamples = track->totalfframes;\n\twriteU32(&oneShotSamples);\n\trepeatSamples = 0;\n\twriteU32(&repeatSamples);\n\tsamplesPerRepeat = 0;\n\twriteU32(&samplesPerRepeat);\n\n\tsampleRate = track->f.sampleRate;\n\twriteU16(&sampleRate);\n\n\toctaves = 0;\n\tcompression = 0;\n\twriteU8(&octaves);\n\twriteU8(&compression);\n\n\t/* Volume is in fixed-point notation; 65536 means gain of 1.0. */\n\tvolume = 65536;\n\twriteU32(&volume);\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"IFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::writeVHDR()\n  {\n  \tuint32_t chunkSize;\n  \tuint32_t oneShotSamples, repeatSamples, samplesPerRepeat;\n  \tuint16_t sampleRate;\n  \tuint8_t octaves, compression;\n  \tuint32_t volume;\n  \n  \t/*\n  \t\tIf VHDR_offset hasn't been set yet, set it to the\n  \t\tcurrent offset.\n  \t*/\n  \tif (m_VHDR_offset == 0)\n  \t\tm_VHDR_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_VHDR_offset, File::SeekFromBeginning);\n  \n  \tTrack *track = getTrack();\n  \n  \tm_fh->write(\"VHDR\", 4);\n  \n  \tchunkSize = 20;\n  \twriteU32(&chunkSize);\n  \n  \t/*\n  \t\tIFF/8SVX files have only one audio channel, so the\n  \t\tnumber of samples is equal to the number of frames.\n  \t*/\n  \toneShotSamples = track->totalfframes;\n  \twriteU32(&oneShotSamples);\n  \trepeatSamples = 0;\n  \twriteU32(&repeatSamples);\n  \tsamplesPerRepeat = 0;\n  \twriteU32(&samplesPerRepeat);\n  \n  \tsampleRate = track->f.sampleRate;\n  \twriteU16(&sampleRate);\n  \n  \toctaves = 0;\n  \tcompression = 0;\n  \twriteU8(&octaves);\n  \twriteU8(&compression);\n  \n  \t/* Volume is in fixed-point notation; 65536 means gain of 1.0. */\n  \tvolume = 65536;\n  \twriteU32(&volume);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "\"8SVX\"",
            "4"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&fileSize"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "initFromSetup",
          "args": [
            "setup"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "initFromSetup",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "222-231",
          "snippet": "status _AFfilehandle::initFromSetup(AFfilesetup setup)\n{\n\tif (copyTracksFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\tif (copyInstrumentsFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\tif (copyMiscellaneousFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  status _AFfilehandle::initFromSetup(AFfilesetup setup)\n  {\n  \tif (copyTracksFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \tif (copyInstrumentsFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \tif (copyMiscellaneousFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \treturn AF_SUCCEED;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::writeInit(AFfilesetup setup)\n  {\n  \tif (initFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \n  \tuint32_t fileSize = 0;\n  \n  \tm_fh->write(\"FORM\", 4);\n  \twriteU32(&fileSize);\n  \n  \tm_fh->write(\"8SVX\", 4);\n  \n  \twriteVHDR();\n  \twriteMiscellaneous();\n  \twriteBODY();\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "completeSetup",
    "container": "IFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
    "lines": "245-316",
    "snippet": "AFfilesetup IFFFile::completeSetup(AFfilesetup setup)\n{\n\tif (setup->trackSet && setup->trackCount != 1)\n\t{\n\t\t_af_error(AF_BAD_NUMTRACKS, \"IFF/8SVX file must have 1 track\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tTrackSetup *track = setup->getTrack();\n\tif (!track)\n\t\treturn AF_NULL_FILESETUP;\n\n\tif (track->sampleFormatSet &&\n\t\ttrack->f.sampleFormat != AF_SAMPFMT_TWOSCOMP)\n\t{\n\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\"IFF/8SVX format supports only two's complement integer data\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->sampleFormatSet && track->f.sampleWidth != 8)\n\t{\n\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\"IFF/8SVX file allows only 8 bits per sample \"\n\t\t\t\"(%d bits requested)\", track->f.sampleWidth);\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->channelCountSet && track->f.channelCount != 1)\n\t{\n\t\t_af_error(AF_BAD_CHANNELS,\n\t\t\t\"invalid channel count (%d) for IFF/8SVX format \"\n\t\t\t\"(only 1 channel supported)\",\n\t\t\ttrack->f.channelCount);\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->f.compressionType != AF_COMPRESSION_NONE)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"IFF/8SVX does not support compression\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\t/* Ignore requested byte order since samples are only one byte. */\n\ttrack->f.byteOrder = AF_BYTEORDER_BIGENDIAN;\n\t/* Either one channel was requested or no request was made. */\n\ttrack->f.channelCount = 1;\n\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, 8);\n\n\tif (track->markersSet && track->markerCount != 0)\n\t{\n\t\t_af_error(AF_BAD_NUMMARKS,\n\t\t\t\"IFF/8SVX format does not support markers\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->aesDataSet)\n\t{\n\t\t_af_error(AF_BAD_FILESETUP, \"IFF/8SVX format does not support AES data\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (setup->instrumentSet && setup->instrumentCount != 0)\n\t{\n\t\t_af_error(AF_BAD_NUMINSTS,\n\t\t\t\"IFF/8SVX format does not support instruments\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\treturn _af_filesetup_copy(setup, &iffDefaultFileSetup, true);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"IFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const _AFfilesetup iffDefaultFileSetup =\n{\n\t_AF_VALID_FILESETUP,\t/* valid */\n\tAF_FILE_IFF_8SVX,\t/* fileFormat */\n\ttrue,\t\t\t/* trackSet */\n\ttrue,\t\t\t/* instrumentSet */\n\ttrue,\t\t\t/* miscellaneousSet */\n\t1,\t\t\t/* trackCount */\n\tNULL,\t\t\t/* tracks */\n\t0,\t\t\t/* instrumentCount */\n\tNULL,\t\t\t/* instruments */\n\t0,\t\t\t/* miscellaneousCount */\n\tNULL\t\t\t/* miscellaneous */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_filesetup_copy",
          "args": [
            "setup",
            "&iffDefaultFileSetup",
            "true"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "_af_filesetup_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Setup.cpp",
          "lines": "440-525",
          "snippet": "AFfilesetup _af_filesetup_copy (const _AFfilesetup *setup,\n\tconst _AFfilesetup *defaultSetup, bool copyMarks)\n{\n\tAFfilesetup newsetup;\n\tint instrumentCount, miscellaneousCount, trackCount;\n\n\tnewsetup = (_AFfilesetup *) _af_malloc(sizeof (_AFfilesetup));\n\tif (newsetup == AF_NULL_FILESETUP)\n\t\treturn AF_NULL_FILESETUP;\n\n\t*newsetup = *defaultSetup;\n\n\tnewsetup->tracks = NULL;\n\tnewsetup->instruments = NULL;\n\tnewsetup->miscellaneous = NULL;\n\n\t/* Copy tracks. */\n\ttrackCount = setup->trackSet ? setup->trackCount :\n\t\tnewsetup->trackSet ? newsetup->trackCount : 0;\n\talloccopy(TrackSetup, trackCount, newsetup->tracks, setup->tracks);\n\tnewsetup->trackCount = trackCount;\n\n\t/* Copy instruments. */\n\tinstrumentCount = setup->instrumentSet ? setup->instrumentCount :\n\t\tnewsetup->instrumentSet ? newsetup->instrumentCount : 0;\n\talloccopy(InstrumentSetup, instrumentCount, newsetup->instruments, setup->instruments);\n\tnewsetup->instrumentCount = instrumentCount;\n\n\t/* Copy miscellaneous information. */\n\tmiscellaneousCount = setup->miscellaneousSet ? setup->miscellaneousCount :\n\t\tnewsetup->miscellaneousSet ? newsetup->miscellaneousCount : 0;\n\talloccopy(MiscellaneousSetup, miscellaneousCount, newsetup->miscellaneous, setup->miscellaneous);\n\tnewsetup->miscellaneousCount = miscellaneousCount;\n\n\tfor (int i=0; i<setup->trackCount; i++)\n\t{\n\t\tTrackSetup\t*track = &newsetup->tracks[i];\n\n\t\t/* XXXmpruett set compression information */\n\n\t\tif (!setup->tracks[i].markersSet && !copyMarks)\n\t\t{\n\t\t\ttrack->markers = NULL;\n\t\t\ttrack->markerCount = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\talloccopy(MarkerSetup, setup->tracks[i].markerCount,\n\t\t\ttrack->markers, setup->tracks[i].markers);\n\t\ttrack->markerCount = setup->tracks[i].markerCount;\n\n\t\tfor (int j=0; j<setup->tracks[i].markerCount; j++)\n\t\t{\n\t\t\ttrack->markers[j].name =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].name);\n\t\t\tif (track->markers[j].name == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\ttrack->markers[j].comment =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].comment);\n\t\t\tif (track->markers[j].comment == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (int i=0; i<newsetup->instrumentCount; i++)\n\t{\n\t\tInstrumentSetup\t*instrument = &newsetup->instruments[i];\n\t\talloccopy(LoopSetup, setup->instruments[i].loopCount,\n\t\t\tinstrument->loops, setup->instruments[i].loops);\n\t}\n\n\treturn newsetup;\n\n\tfail:\n\t\tif (newsetup->miscellaneous)\n\t\t\tfree(newsetup->miscellaneous);\n\t\tif (newsetup->instruments)\n\t\t\tfree(newsetup->instruments);\n\t\tif (newsetup->tracks)\n\t\t\tfree(newsetup->tracks);\n\t\tif (newsetup)\n\t\t\tfree(newsetup);\n\n\treturn AF_NULL_FILESETUP;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"audiofile.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"Setup.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"audiofile.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include <string.h>\n#include <stdlib.h>\n#include \"Setup.h\"\n#include \"config.h\"\n\nAFfilesetup _af_filesetup_copy (const _AFfilesetup *setup,\n\tconst _AFfilesetup *defaultSetup, bool copyMarks)\n{\n\tAFfilesetup newsetup;\n\tint instrumentCount, miscellaneousCount, trackCount;\n\n\tnewsetup = (_AFfilesetup *) _af_malloc(sizeof (_AFfilesetup));\n\tif (newsetup == AF_NULL_FILESETUP)\n\t\treturn AF_NULL_FILESETUP;\n\n\t*newsetup = *defaultSetup;\n\n\tnewsetup->tracks = NULL;\n\tnewsetup->instruments = NULL;\n\tnewsetup->miscellaneous = NULL;\n\n\t/* Copy tracks. */\n\ttrackCount = setup->trackSet ? setup->trackCount :\n\t\tnewsetup->trackSet ? newsetup->trackCount : 0;\n\talloccopy(TrackSetup, trackCount, newsetup->tracks, setup->tracks);\n\tnewsetup->trackCount = trackCount;\n\n\t/* Copy instruments. */\n\tinstrumentCount = setup->instrumentSet ? setup->instrumentCount :\n\t\tnewsetup->instrumentSet ? newsetup->instrumentCount : 0;\n\talloccopy(InstrumentSetup, instrumentCount, newsetup->instruments, setup->instruments);\n\tnewsetup->instrumentCount = instrumentCount;\n\n\t/* Copy miscellaneous information. */\n\tmiscellaneousCount = setup->miscellaneousSet ? setup->miscellaneousCount :\n\t\tnewsetup->miscellaneousSet ? newsetup->miscellaneousCount : 0;\n\talloccopy(MiscellaneousSetup, miscellaneousCount, newsetup->miscellaneous, setup->miscellaneous);\n\tnewsetup->miscellaneousCount = miscellaneousCount;\n\n\tfor (int i=0; i<setup->trackCount; i++)\n\t{\n\t\tTrackSetup\t*track = &newsetup->tracks[i];\n\n\t\t/* XXXmpruett set compression information */\n\n\t\tif (!setup->tracks[i].markersSet && !copyMarks)\n\t\t{\n\t\t\ttrack->markers = NULL;\n\t\t\ttrack->markerCount = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\talloccopy(MarkerSetup, setup->tracks[i].markerCount,\n\t\t\ttrack->markers, setup->tracks[i].markers);\n\t\ttrack->markerCount = setup->tracks[i].markerCount;\n\n\t\tfor (int j=0; j<setup->tracks[i].markerCount; j++)\n\t\t{\n\t\t\ttrack->markers[j].name =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].name);\n\t\t\tif (track->markers[j].name == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\ttrack->markers[j].comment =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].comment);\n\t\t\tif (track->markers[j].comment == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (int i=0; i<newsetup->instrumentCount; i++)\n\t{\n\t\tInstrumentSetup\t*instrument = &newsetup->instruments[i];\n\t\talloccopy(LoopSetup, setup->instruments[i].loopCount,\n\t\t\tinstrument->loops, setup->instruments[i].loops);\n\t}\n\n\treturn newsetup;\n\n\tfail:\n\t\tif (newsetup->miscellaneous)\n\t\t\tfree(newsetup->miscellaneous);\n\t\tif (newsetup->instruments)\n\t\t\tfree(newsetup->instruments);\n\t\tif (newsetup->tracks)\n\t\t\tfree(newsetup->tracks);\n\t\tif (newsetup)\n\t\t\tfree(newsetup);\n\n\treturn AF_NULL_FILESETUP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NUMINSTS",
            "\"IFF/8SVX format does not support instruments\""
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_FILESETUP",
            "\"IFF/8SVX format does not support AES data\""
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NUMMARKS",
            "\"IFF/8SVX format does not support markers\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_set_sample_format",
          "args": [
            "&track->f",
            "AF_SAMPFMT_TWOSCOMP",
            "8"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "_af_set_sample_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "315-361",
          "snippet": "status _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatus _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_COMPRESSION",
            "\"IFF/8SVX does not support compression\""
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_CHANNELS",
            "\"invalid channel count (%d) for IFF/8SVX format \"\n\t\t\t\"(only 1 channel supported)\"",
            "track->f.channelCount"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_WIDTH",
            "\"IFF/8SVX file allows only 8 bits per sample \"\n\t\t\t\"(%d bits requested)\"",
            "track->f.sampleWidth"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_SAMPFMT",
            "\"IFF/8SVX format supports only two's complement integer data\""
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup->getTrack",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NUMTRACKS",
            "\"IFF/8SVX file must have 1 track\""
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nstatic const _AFfilesetup iffDefaultFileSetup =\n{\n\t_AF_VALID_FILESETUP,\t/* valid */\n\tAF_FILE_IFF_8SVX,\t/* fileFormat */\n\ttrue,\t\t\t/* trackSet */\n\ttrue,\t\t\t/* instrumentSet */\n\ttrue,\t\t\t/* miscellaneousSet */\n\t1,\t\t\t/* trackCount */\n\tNULL,\t\t\t/* tracks */\n\t0,\t\t\t/* instrumentCount */\n\tNULL,\t\t\t/* instruments */\n\t0,\t\t\t/* miscellaneousCount */\n\tNULL\t\t\t/* miscellaneous */\n};\n\nIFFFile {\n  AFfilesetup IFFFile::completeSetup(AFfilesetup setup)\n  {\n  \tif (setup->trackSet && setup->trackCount != 1)\n  \t{\n  \t\t_af_error(AF_BAD_NUMTRACKS, \"IFF/8SVX file must have 1 track\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tTrackSetup *track = setup->getTrack();\n  \tif (!track)\n  \t\treturn AF_NULL_FILESETUP;\n  \n  \tif (track->sampleFormatSet &&\n  \t\ttrack->f.sampleFormat != AF_SAMPFMT_TWOSCOMP)\n  \t{\n  \t\t_af_error(AF_BAD_SAMPFMT,\n  \t\t\t\"IFF/8SVX format supports only two's complement integer data\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (track->sampleFormatSet && track->f.sampleWidth != 8)\n  \t{\n  \t\t_af_error(AF_BAD_WIDTH,\n  \t\t\t\"IFF/8SVX file allows only 8 bits per sample \"\n  \t\t\t\"(%d bits requested)\", track->f.sampleWidth);\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (track->channelCountSet && track->f.channelCount != 1)\n  \t{\n  \t\t_af_error(AF_BAD_CHANNELS,\n  \t\t\t\"invalid channel count (%d) for IFF/8SVX format \"\n  \t\t\t\"(only 1 channel supported)\",\n  \t\t\ttrack->f.channelCount);\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (track->f.compressionType != AF_COMPRESSION_NONE)\n  \t{\n  \t\t_af_error(AF_BAD_COMPRESSION,\n  \t\t\t\"IFF/8SVX does not support compression\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \t/* Ignore requested byte order since samples are only one byte. */\n  \ttrack->f.byteOrder = AF_BYTEORDER_BIGENDIAN;\n  \t/* Either one channel was requested or no request was made. */\n  \ttrack->f.channelCount = 1;\n  \t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, 8);\n  \n  \tif (track->markersSet && track->markerCount != 0)\n  \t{\n  \t\t_af_error(AF_BAD_NUMMARKS,\n  \t\t\t\"IFF/8SVX format does not support markers\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (track->aesDataSet)\n  \t{\n  \t\t_af_error(AF_BAD_FILESETUP, \"IFF/8SVX format does not support AES data\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (setup->instrumentSet && setup->instrumentCount != 0)\n  \t{\n  \t\t_af_error(AF_BAD_NUMINSTS,\n  \t\t\t\"IFF/8SVX format does not support instruments\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \treturn _af_filesetup_copy(setup, &iffDefaultFileSetup, true);\n  }\n}"
  },
  {
    "function_name": "readInit",
    "container": "IFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
    "lines": "177-243",
    "snippet": "status IFFFile::readInit(AFfilesetup setup)\n{\n\tm_fh->seek(0, File::SeekFromBeginning);\n\n\tTag type;\n\tuint32_t size;\n\tTag formtype;\n\n\treadTag(&type);\n\treadU32(&size);\n\treadTag(&formtype);\n\n\tif (type != \"FORM\" || formtype != \"8SVX\")\n\t\treturn AF_FAIL;\n\n\t/* IFF/8SVX files have only one track. */\n\tTrack *track = allocateTrack();\n\tif (!track)\n\t\treturn AF_FAIL;\n\n\t/* Set the index to include the form type ('8SVX' in this case). */\n\tsize_t index = 4;\n\twhile (index < size)\n\t{\n\t\tTag chunkid;\n\t\tuint32_t chunksize = 0;\n\t\tstatus result = AF_SUCCEED;\n\n\t\treadTag(&chunkid);\n\t\treadU32(&chunksize);\n\n\t\tif (chunkid == \"VHDR\")\n\t\t{\n\t\t\tresult = parseVHDR(chunkid, chunksize);\n\t\t}\n\t\telse if (chunkid == \"BODY\")\n\t\t{\n\t\t\tresult = parseBODY(chunkid, chunksize);\n\t\t}\n\t\telse if (chunkid == \"NAME\" ||\n\t\t\tchunkid == \"AUTH\" ||\n\t\t\tchunkid == \"(c) \" ||\n\t\t\tchunkid == \"ANNO\")\n\t\t{\n\t\t\tparseMiscellaneous(chunkid, chunksize);\n\t\t}\n\n\t\tif (result == AF_FAIL)\n\t\t\treturn AF_FAIL;\n\n\t\t/*\n\t\t\tIncrement the index by the size of the chunk\n\t\t\tplus the size of the chunk header.\n\t\t*/\n\t\tindex += chunksize + 8;\n\n\t\t/* All chunks must be aligned on an even number of bytes. */\n\t\tif ((index % 2) != 0)\n\t\t\tindex++;\n\n\t\t/* Set the seek position to the beginning of the next chunk. */\n\t\tm_fh->seek(index + 8, File::SeekFromBeginning);\n\t}\n\n\t/* The file has been successfully parsed. */\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"IFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "index + 8",
            "File::SeekFromBeginning"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseMiscellaneous",
          "args": [
            "chunkid",
            "chunksize"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "parseMiscellaneous",
          "container": "IFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
          "lines": "88-120",
          "snippet": "status IFFFile::parseMiscellaneous(const Tag &type, size_t size)\n{\n\tint misctype = AF_MISC_UNRECOGNIZED;\n\n\tassert(type == \"NAME\" || type == \"AUTH\" ||\n\t\ttype == \"(c) \" || type == \"ANNO\");\n\n\t/* Skip zero-length miscellaneous chunks. */\n\tif (size == 0)\n\t\treturn AF_FAIL;\n\n\tm_miscellaneousCount++;\n\tm_miscellaneous = (Miscellaneous *) _af_realloc(m_miscellaneous,\n\t\tm_miscellaneousCount * sizeof (Miscellaneous));\n\n\tif (type == \"NAME\")\n\t\tmisctype = AF_MISC_NAME;\n\telse if (type == \"AUTH\")\n\t\tmisctype = AF_MISC_AUTH;\n\telse if (type == \"(c) \")\n\t\tmisctype = AF_MISC_COPY;\n\telse if (type == \"ANNO\")\n\t\tmisctype = AF_MISC_ANNO;\n\n\tm_miscellaneous[m_miscellaneousCount - 1].id = m_miscellaneousCount;\n\tm_miscellaneous[m_miscellaneousCount - 1].type = misctype;\n\tm_miscellaneous[m_miscellaneousCount - 1].size = size;\n\tm_miscellaneous[m_miscellaneousCount - 1].position = 0;\n\tm_miscellaneous[m_miscellaneousCount - 1].buffer = _af_malloc(size);\n\tm_fh->read(m_miscellaneous[m_miscellaneousCount - 1].buffer, size);\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"IFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::parseMiscellaneous(const Tag &type, size_t size)\n  {\n  \tint misctype = AF_MISC_UNRECOGNIZED;\n  \n  \tassert(type == \"NAME\" || type == \"AUTH\" ||\n  \t\ttype == \"(c) \" || type == \"ANNO\");\n  \n  \t/* Skip zero-length miscellaneous chunks. */\n  \tif (size == 0)\n  \t\treturn AF_FAIL;\n  \n  \tm_miscellaneousCount++;\n  \tm_miscellaneous = (Miscellaneous *) _af_realloc(m_miscellaneous,\n  \t\tm_miscellaneousCount * sizeof (Miscellaneous));\n  \n  \tif (type == \"NAME\")\n  \t\tmisctype = AF_MISC_NAME;\n  \telse if (type == \"AUTH\")\n  \t\tmisctype = AF_MISC_AUTH;\n  \telse if (type == \"(c) \")\n  \t\tmisctype = AF_MISC_COPY;\n  \telse if (type == \"ANNO\")\n  \t\tmisctype = AF_MISC_ANNO;\n  \n  \tm_miscellaneous[m_miscellaneousCount - 1].id = m_miscellaneousCount;\n  \tm_miscellaneous[m_miscellaneousCount - 1].type = misctype;\n  \tm_miscellaneous[m_miscellaneousCount - 1].size = size;\n  \tm_miscellaneous[m_miscellaneousCount - 1].position = 0;\n  \tm_miscellaneous[m_miscellaneousCount - 1].buffer = _af_malloc(size);\n  \tm_fh->read(m_miscellaneous[m_miscellaneousCount - 1].buffer, size);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseBODY",
          "args": [
            "chunkid",
            "chunksize"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "parseBODY",
          "container": "IFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
          "lines": "159-175",
          "snippet": "status IFFFile::parseBODY(const Tag &type, size_t size)\n{\n\tTrack *track = getTrack();\n\n\t/*\n\t\tIFF/8SVX files have only one audio channel with one\n\t\tbyte per sample, so the number of frames is equal to\n\t\tthe number of bytes.\n\t*/\n\ttrack->totalfframes = size;\n\ttrack->data_size = size;\n\n\t/* Sound data follows. */\n\ttrack->fpos_first_frame = m_fh->tell();\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"IFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::parseBODY(const Tag &type, size_t size)\n  {\n  \tTrack *track = getTrack();\n  \n  \t/*\n  \t\tIFF/8SVX files have only one audio channel with one\n  \t\tbyte per sample, so the number of frames is equal to\n  \t\tthe number of bytes.\n  \t*/\n  \ttrack->totalfframes = size;\n  \ttrack->data_size = size;\n  \n  \t/* Sound data follows. */\n  \ttrack->fpos_first_frame = m_fh->tell();\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseVHDR",
          "args": [
            "chunkid",
            "chunksize"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "parseVHDR",
          "container": "IFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
          "lines": "125-157",
          "snippet": "status IFFFile::parseVHDR(const Tag &type, size_t size)\n{\n\tassert(type == \"VHDR\");\n\n\tTrack *track = getTrack();\n\n\tuint32_t oneShotSamples, repeatSamples, samplesPerRepeat;\n\tuint16_t sampleRate;\n\tuint8_t octaves, compression;\n\tuint32_t volume;\n\n\treadU32(&oneShotSamples);\n\treadU32(&repeatSamples);\n\treadU32(&samplesPerRepeat);\n\treadU16(&sampleRate);\n\treadU8(&octaves);\n\treadU8(&compression);\n\treadU32(&volume);\n\n\ttrack->f.sampleWidth = 8; \n\ttrack->f.sampleRate = sampleRate;\n\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\ttrack->f.byteOrder = AF_BYTEORDER_BIGENDIAN;\n\ttrack->f.channelCount = 1;\n\n\ttrack->f.framesPerPacket = 1;\n\ttrack->f.computeBytesPerPacketPCM();\n\n\t_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"IFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::parseVHDR(const Tag &type, size_t size)\n  {\n  \tassert(type == \"VHDR\");\n  \n  \tTrack *track = getTrack();\n  \n  \tuint32_t oneShotSamples, repeatSamples, samplesPerRepeat;\n  \tuint16_t sampleRate;\n  \tuint8_t octaves, compression;\n  \tuint32_t volume;\n  \n  \treadU32(&oneShotSamples);\n  \treadU32(&repeatSamples);\n  \treadU32(&samplesPerRepeat);\n  \treadU16(&sampleRate);\n  \treadU8(&octaves);\n  \treadU8(&compression);\n  \treadU32(&volume);\n  \n  \ttrack->f.sampleWidth = 8; \n  \ttrack->f.sampleRate = sampleRate;\n  \ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \ttrack->f.byteOrder = AF_BYTEORDER_BIGENDIAN;\n  \ttrack->f.channelCount = 1;\n  \n  \ttrack->f.framesPerPacket = 1;\n  \ttrack->f.computeBytesPerPacketPCM();\n  \n  \t_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readU32",
          "args": [
            "&chunksize"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "readU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "400-403",
          "snippet": "bool _AFfilehandle::readU32(uint32_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU32(uint32_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readTag",
          "args": [
            "&chunkid"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "readTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "473-482",
          "snippet": "bool _AFfilehandle::readTag(Tag *t)\n{\n\tuint32_t v;\n\tif (m_fh->read(&v, sizeof (v)) == sizeof (v))\n\t{\n\t\t*t = Tag(v);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readTag(Tag *t)\n  {\n  \tuint32_t v;\n  \tif (m_fh->read(&v, sizeof (v)) == sizeof (v))\n  \t{\n  \t\t*t = Tag(v);\n  \t\treturn true;\n  \t}\n  \treturn false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocateTrack",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::readInit(AFfilesetup setup)\n  {\n  \tm_fh->seek(0, File::SeekFromBeginning);\n  \n  \tTag type;\n  \tuint32_t size;\n  \tTag formtype;\n  \n  \treadTag(&type);\n  \treadU32(&size);\n  \treadTag(&formtype);\n  \n  \tif (type != \"FORM\" || formtype != \"8SVX\")\n  \t\treturn AF_FAIL;\n  \n  \t/* IFF/8SVX files have only one track. */\n  \tTrack *track = allocateTrack();\n  \tif (!track)\n  \t\treturn AF_FAIL;\n  \n  \t/* Set the index to include the form type ('8SVX' in this case). */\n  \tsize_t index = 4;\n  \twhile (index < size)\n  \t{\n  \t\tTag chunkid;\n  \t\tuint32_t chunksize = 0;\n  \t\tstatus result = AF_SUCCEED;\n  \n  \t\treadTag(&chunkid);\n  \t\treadU32(&chunksize);\n  \n  \t\tif (chunkid == \"VHDR\")\n  \t\t{\n  \t\t\tresult = parseVHDR(chunkid, chunksize);\n  \t\t}\n  \t\telse if (chunkid == \"BODY\")\n  \t\t{\n  \t\t\tresult = parseBODY(chunkid, chunksize);\n  \t\t}\n  \t\telse if (chunkid == \"NAME\" ||\n  \t\t\tchunkid == \"AUTH\" ||\n  \t\t\tchunkid == \"(c) \" ||\n  \t\t\tchunkid == \"ANNO\")\n  \t\t{\n  \t\t\tparseMiscellaneous(chunkid, chunksize);\n  \t\t}\n  \n  \t\tif (result == AF_FAIL)\n  \t\t\treturn AF_FAIL;\n  \n  \t\t/*\n  \t\t\tIncrement the index by the size of the chunk\n  \t\t\tplus the size of the chunk header.\n  \t\t*/\n  \t\tindex += chunksize + 8;\n  \n  \t\t/* All chunks must be aligned on an even number of bytes. */\n  \t\tif ((index % 2) != 0)\n  \t\t\tindex++;\n  \n  \t\t/* Set the seek position to the beginning of the next chunk. */\n  \t\tm_fh->seek(index + 8, File::SeekFromBeginning);\n  \t}\n  \n  \t/* The file has been successfully parsed. */\n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseBODY",
    "container": "IFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
    "lines": "159-175",
    "snippet": "status IFFFile::parseBODY(const Tag &type, size_t size)\n{\n\tTrack *track = getTrack();\n\n\t/*\n\t\tIFF/8SVX files have only one audio channel with one\n\t\tbyte per sample, so the number of frames is equal to\n\t\tthe number of bytes.\n\t*/\n\ttrack->totalfframes = size;\n\ttrack->data_size = size;\n\n\t/* Sound data follows. */\n\ttrack->fpos_first_frame = m_fh->tell();\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"IFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::parseBODY(const Tag &type, size_t size)\n  {\n  \tTrack *track = getTrack();\n  \n  \t/*\n  \t\tIFF/8SVX files have only one audio channel with one\n  \t\tbyte per sample, so the number of frames is equal to\n  \t\tthe number of bytes.\n  \t*/\n  \ttrack->totalfframes = size;\n  \ttrack->data_size = size;\n  \n  \t/* Sound data follows. */\n  \ttrack->fpos_first_frame = m_fh->tell();\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseVHDR",
    "container": "IFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
    "lines": "125-157",
    "snippet": "status IFFFile::parseVHDR(const Tag &type, size_t size)\n{\n\tassert(type == \"VHDR\");\n\n\tTrack *track = getTrack();\n\n\tuint32_t oneShotSamples, repeatSamples, samplesPerRepeat;\n\tuint16_t sampleRate;\n\tuint8_t octaves, compression;\n\tuint32_t volume;\n\n\treadU32(&oneShotSamples);\n\treadU32(&repeatSamples);\n\treadU32(&samplesPerRepeat);\n\treadU16(&sampleRate);\n\treadU8(&octaves);\n\treadU8(&compression);\n\treadU32(&volume);\n\n\ttrack->f.sampleWidth = 8; \n\ttrack->f.sampleRate = sampleRate;\n\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\ttrack->f.byteOrder = AF_BYTEORDER_BIGENDIAN;\n\ttrack->f.channelCount = 1;\n\n\ttrack->f.framesPerPacket = 1;\n\ttrack->f.computeBytesPerPacketPCM();\n\n\t_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"IFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_set_sample_format",
          "args": [
            "&track->f",
            "track->f.sampleFormat",
            "track->f.sampleWidth"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "_af_set_sample_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "315-361",
          "snippet": "status _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatus _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->f.computeBytesPerPacketPCM",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "computeBytesPerPacketPCM",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "98-103",
          "snippet": "void AudioFormat::computeBytesPerPacketPCM()\n{\n\tassert(isUncompressed());\n\tint bytesPerSample = (sampleWidth + 7) / 8;\n\tbytesPerPacket = bytesPerSample * channelCount;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  void AudioFormat::computeBytesPerPacketPCM()\n  {\n  \tassert(isUncompressed());\n  \tint bytesPerSample = (sampleWidth + 7) / 8;\n  \tbytesPerPacket = bytesPerSample * channelCount;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readU32",
          "args": [
            "&volume"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "readU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "400-403",
          "snippet": "bool _AFfilehandle::readU32(uint32_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU32(uint32_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readU8",
          "args": [
            "&compression"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "readU8",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "387-387",
          "snippet": "bool _AFfilehandle::readU8(uint8_t *v) { return readValue(m_fh, v); }",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU8(uint8_t *v) { return readValue(m_fh, v); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readU16",
          "args": [
            "&sampleRate"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "readU16",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "390-393",
          "snippet": "bool _AFfilehandle::readU16(uint16_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU16(uint16_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "type == \"VHDR\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::parseVHDR(const Tag &type, size_t size)\n  {\n  \tassert(type == \"VHDR\");\n  \n  \tTrack *track = getTrack();\n  \n  \tuint32_t oneShotSamples, repeatSamples, samplesPerRepeat;\n  \tuint16_t sampleRate;\n  \tuint8_t octaves, compression;\n  \tuint32_t volume;\n  \n  \treadU32(&oneShotSamples);\n  \treadU32(&repeatSamples);\n  \treadU32(&samplesPerRepeat);\n  \treadU16(&sampleRate);\n  \treadU8(&octaves);\n  \treadU8(&compression);\n  \treadU32(&volume);\n  \n  \ttrack->f.sampleWidth = 8; \n  \ttrack->f.sampleRate = sampleRate;\n  \ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \ttrack->f.byteOrder = AF_BYTEORDER_BIGENDIAN;\n  \ttrack->f.channelCount = 1;\n  \n  \ttrack->f.framesPerPacket = 1;\n  \ttrack->f.computeBytesPerPacketPCM();\n  \n  \t_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseMiscellaneous",
    "container": "IFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
    "lines": "88-120",
    "snippet": "status IFFFile::parseMiscellaneous(const Tag &type, size_t size)\n{\n\tint misctype = AF_MISC_UNRECOGNIZED;\n\n\tassert(type == \"NAME\" || type == \"AUTH\" ||\n\t\ttype == \"(c) \" || type == \"ANNO\");\n\n\t/* Skip zero-length miscellaneous chunks. */\n\tif (size == 0)\n\t\treturn AF_FAIL;\n\n\tm_miscellaneousCount++;\n\tm_miscellaneous = (Miscellaneous *) _af_realloc(m_miscellaneous,\n\t\tm_miscellaneousCount * sizeof (Miscellaneous));\n\n\tif (type == \"NAME\")\n\t\tmisctype = AF_MISC_NAME;\n\telse if (type == \"AUTH\")\n\t\tmisctype = AF_MISC_AUTH;\n\telse if (type == \"(c) \")\n\t\tmisctype = AF_MISC_COPY;\n\telse if (type == \"ANNO\")\n\t\tmisctype = AF_MISC_ANNO;\n\n\tm_miscellaneous[m_miscellaneousCount - 1].id = m_miscellaneousCount;\n\tm_miscellaneous[m_miscellaneousCount - 1].type = misctype;\n\tm_miscellaneous[m_miscellaneousCount - 1].size = size;\n\tm_miscellaneous[m_miscellaneousCount - 1].position = 0;\n\tm_miscellaneous[m_miscellaneousCount - 1].buffer = _af_malloc(size);\n\tm_fh->read(m_miscellaneous[m_miscellaneousCount - 1].buffer, size);\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"IFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->read",
          "args": [
            "m_miscellaneous[m_miscellaneousCount - 1].buffer",
            "size"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_malloc",
          "args": [
            "size"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_realloc",
          "args": [
            "m_miscellaneous",
            "m_miscellaneousCount * sizeof (Miscellaneous)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "type == \"NAME\" || type == \"AUTH\" ||\n\t\ttype == \"(c) \" || type == \"ANNO\""
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::parseMiscellaneous(const Tag &type, size_t size)\n  {\n  \tint misctype = AF_MISC_UNRECOGNIZED;\n  \n  \tassert(type == \"NAME\" || type == \"AUTH\" ||\n  \t\ttype == \"(c) \" || type == \"ANNO\");\n  \n  \t/* Skip zero-length miscellaneous chunks. */\n  \tif (size == 0)\n  \t\treturn AF_FAIL;\n  \n  \tm_miscellaneousCount++;\n  \tm_miscellaneous = (Miscellaneous *) _af_realloc(m_miscellaneous,\n  \t\tm_miscellaneousCount * sizeof (Miscellaneous));\n  \n  \tif (type == \"NAME\")\n  \t\tmisctype = AF_MISC_NAME;\n  \telse if (type == \"AUTH\")\n  \t\tmisctype = AF_MISC_AUTH;\n  \telse if (type == \"(c) \")\n  \t\tmisctype = AF_MISC_COPY;\n  \telse if (type == \"ANNO\")\n  \t\tmisctype = AF_MISC_ANNO;\n  \n  \tm_miscellaneous[m_miscellaneousCount - 1].id = m_miscellaneousCount;\n  \tm_miscellaneous[m_miscellaneousCount - 1].type = misctype;\n  \tm_miscellaneous[m_miscellaneousCount - 1].size = size;\n  \tm_miscellaneous[m_miscellaneousCount - 1].position = 0;\n  \tm_miscellaneous[m_miscellaneousCount - 1].buffer = _af_malloc(size);\n  \tm_fh->read(m_miscellaneous[m_miscellaneousCount - 1].buffer, size);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "IFFFile",
    "container": "IFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
    "lines": "75-82",
    "snippet": "IFFFile::IFFFile()\n{\n\tsetFormatByteOrder(AF_BYTEORDER_BIGENDIAN);\n\n\tm_miscellaneousPosition = 0;\n\tm_VHDR_offset = 0;\n\tm_BODY_offset = 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"IFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setFormatByteOrder",
          "args": [
            "AF_BYTEORDER_BIGENDIAN"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "setFormatByteOrder",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.h",
          "lines": "86-86",
          "snippet": "void setFormatByteOrder(int byteOrder) { m_formatByteOrder = byteOrder; }",
          "includes": [
            "#include <stdint.h>",
            "#include \"afinternal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include \"afinternal.h\"\n\n_AFfilehandle {\n  void setFormatByteOrder(int byteOrder) { m_formatByteOrder = byteOrder; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  IFFFile::IFFFile()\n  {\n  \tsetFormatByteOrder(AF_BYTEORDER_BIGENDIAN);\n  \n  \tm_miscellaneousPosition = 0;\n  \tm_VHDR_offset = 0;\n  \tm_BODY_offset = 0;\n  }\n}"
  },
  {
    "function_name": "recognize",
    "container": "IFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
    "lines": "61-73",
    "snippet": "bool IFFFile::recognize(File *fh)\n{\n\tuint8_t buffer[8];\n\n\tfh->seek(0, File::SeekFromBeginning);\n\n\tif (fh->read(buffer, 8) != 8 || memcmp(buffer, \"FORM\", 4) != 0)\n\t\treturn false;\n\tif (fh->read(buffer, 4) != 4 || memcmp(buffer, \"8SVX\", 4) != 0)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"IFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"8SVX\"",
            "4"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh->read",
          "args": [
            "buffer",
            "4"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"FORM\"",
            "4"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh->seek",
          "args": [
            "0",
            "File::SeekFromBeginning"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  bool IFFFile::recognize(File *fh)\n  {\n  \tuint8_t buffer[8];\n  \n  \tfh->seek(0, File::SeekFromBeginning);\n  \n  \tif (fh->read(buffer, 8) != 8 || memcmp(buffer, \"FORM\", 4) != 0)\n  \t\treturn false;\n  \tif (fh->read(buffer, 4) != 4 || memcmp(buffer, \"8SVX\", 4) != 0)\n  \t\treturn false;\n  \n  \treturn true;\n  }\n}"
  }
]