[
  {
    "function_name": "reset2",
    "container": "PCM",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/PCM.cpp",
    "lines": "184-190",
    "snippet": "void PCM::reset2()\n{\n\tm_track->fpos_next_frame = m_track->fpos_first_frame +\n\t\tm_bytesPerFrame * m_track->nextfframe;\n\n\tm_track->frames2ignore = 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"compression.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"FileModule.h\"",
      "#include \"Compiler.h\"",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"PCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"compression.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"FileModule.h\"\n#include \"Compiler.h\"\n#include <math.h>\n#include <assert.h>\n#include \"PCM.h\"\n#include \"config.h\"\n\nPCM {\n  void PCM::reset2()\n  {\n  \tm_track->fpos_next_frame = m_track->fpos_first_frame +\n  \t\tm_bytesPerFrame * m_track->nextfframe;\n  \n  \tm_track->frames2ignore = 0;\n  }\n}"
  },
  {
    "function_name": "runPull",
    "container": "PCM",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/PCM.cpp",
    "lines": "141-182",
    "snippet": "void PCM::runPull()\n{\n\tAFframecount framesToRead = m_outChunk->frameCount;\n\n\t/*\n\t\tWARNING: Due to the optimization explained at the end of\n\t\tarrangemodules(), the pcm file module cannot depend on\n\t\tthe presence of the intermediate working buffer which\n\t\t_AFsetupmodules usually allocates for file modules in\n\t\ttheir input or output chunk (for reading or writing,\n\t\trespectively).\n\n\t\tFortunately, the pcm module has no need for such a buffer.\n\t*/\n\n\t/*\n\t\tLimit the number of frames to be read to the number of\n\t\tframes left in the track.\n\t*/\n\tif (m_track->totalfframes != -1 &&\n\t\tm_track->nextfframe + framesToRead > m_track->totalfframes)\n\t{\n\t\tframesToRead = m_track->totalfframes - m_track->nextfframe;\n\t}\n\n\tssize_t bytesRead = read(m_outChunk->buffer, m_bytesPerFrame * framesToRead);\n\tAFframecount framesRead = bytesRead >= 0 ? bytesRead / m_bytesPerFrame : 0;\n\n\tm_track->nextfframe += framesRead;\n\tassert(!canSeek() || (tell() == m_track->fpos_next_frame));\n\n\t/*\n\t\tIf we got EOF from read, then we return the actual amount read.\n\n\t\tComplain only if there should have been more frames in the file.\n\t*/\n\n\tif (framesRead != framesToRead && m_track->totalfframes != -1)\n\t\treportReadError(framesRead, framesToRead);\n\n\tm_outChunk->frameCount = framesRead;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"compression.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"FileModule.h\"",
      "#include \"Compiler.h\"",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"PCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reportReadError",
          "args": [
            "framesRead",
            "framesToRead"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "reportReadError",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "76-88",
          "snippet": "void FileModule::reportReadError(AFframecount framesRead,\n\tAFframecount framesToRead)\n{\n\t// Report error if we haven't already.\n\tif (!m_track->filemodhappy)\n\t\treturn;\n\n\t_af_error(AF_BAD_READ,\n\t\t\"file missing data -- read %jd frames, should be %jd\",\n\t\tstatic_cast<intmax_t>(m_track->nextfframe),\n\t\tstatic_cast<intmax_t>(m_track->totalfframes));\n\tm_track->filemodhappy = false;\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  void FileModule::reportReadError(AFframecount framesRead,\n  \tAFframecount framesToRead)\n  {\n  \t// Report error if we haven't already.\n  \tif (!m_track->filemodhappy)\n  \t\treturn;\n  \n  \t_af_error(AF_BAD_READ,\n  \t\t\"file missing data -- read %jd frames, should be %jd\",\n  \t\tstatic_cast<intmax_t>(m_track->nextfframe),\n  \t\tstatic_cast<intmax_t>(m_track->totalfframes));\n  \tm_track->filemodhappy = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!canSeek() || (tell() == m_track->fpos_next_frame)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tell",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "66-69",
          "snippet": "off_t FileModule::tell()\n{\n\treturn m_fh->tell();\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  off_t FileModule::tell()\n  {\n  \treturn m_fh->tell();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "canSeek",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "canSeek",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.h",
          "lines": "38-38",
          "snippet": "bool canSeek() const { return m_canSeek; }",
          "includes": [
            "#include \"Module.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Module.h\"\n\nFileModule {\n  bool canSeek() const { return m_canSeek; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "m_outChunk->buffer",
            "m_bytesPerFrame * framesToRead"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "40-48",
          "snippet": "ssize_t FileModule::read(void *data, size_t nbytes)\n{\n\tssize_t bytesRead = m_fh->read(data, nbytes);\n\tif (bytesRead > 0)\n\t{\n\t\tm_track->fpos_next_frame += bytesRead;\n\t}\n\treturn bytesRead;\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  ssize_t FileModule::read(void *data, size_t nbytes)\n  {\n  \tssize_t bytesRead = m_fh->read(data, nbytes);\n  \tif (bytesRead > 0)\n  \t{\n  \t\tm_track->fpos_next_frame += bytesRead;\n  \t}\n  \treturn bytesRead;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"compression.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"FileModule.h\"\n#include \"Compiler.h\"\n#include <math.h>\n#include <assert.h>\n#include \"PCM.h\"\n#include \"config.h\"\n\nPCM {\n  void PCM::runPull()\n  {\n  \tAFframecount framesToRead = m_outChunk->frameCount;\n  \n  \t/*\n  \t\tWARNING: Due to the optimization explained at the end of\n  \t\tarrangemodules(), the pcm file module cannot depend on\n  \t\tthe presence of the intermediate working buffer which\n  \t\t_AFsetupmodules usually allocates for file modules in\n  \t\ttheir input or output chunk (for reading or writing,\n  \t\trespectively).\n  \n  \t\tFortunately, the pcm module has no need for such a buffer.\n  \t*/\n  \n  \t/*\n  \t\tLimit the number of frames to be read to the number of\n  \t\tframes left in the track.\n  \t*/\n  \tif (m_track->totalfframes != -1 &&\n  \t\tm_track->nextfframe + framesToRead > m_track->totalfframes)\n  \t{\n  \t\tframesToRead = m_track->totalfframes - m_track->nextfframe;\n  \t}\n  \n  \tssize_t bytesRead = read(m_outChunk->buffer, m_bytesPerFrame * framesToRead);\n  \tAFframecount framesRead = bytesRead >= 0 ? bytesRead / m_bytesPerFrame : 0;\n  \n  \tm_track->nextfframe += framesRead;\n  \tassert(!canSeek() || (tell() == m_track->fpos_next_frame));\n  \n  \t/*\n  \t\tIf we got EOF from read, then we return the actual amount read.\n  \n  \t\tComplain only if there should have been more frames in the file.\n  \t*/\n  \n  \tif (framesRead != framesToRead && m_track->totalfframes != -1)\n  \t\treportReadError(framesRead, framesToRead);\n  \n  \tm_outChunk->frameCount = framesRead;\n  }\n}"
  },
  {
    "function_name": "sync2",
    "container": "PCM",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/PCM.cpp",
    "lines": "124-133",
    "snippet": "void PCM::sync2()\n{\n\tassert(!canSeek() || (tell() == m_track->fpos_next_frame));\n\n\t/* We can afford to seek because sync2 is rare. */\n\tm_track->fpos_after_data = tell();\n\n\tm_track->fpos_next_frame = m_saved_fpos_next_frame;\n\tm_track->nextfframe = m_saved_nextfframe;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"compression.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"FileModule.h\"",
      "#include \"Compiler.h\"",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"PCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tell",
          "args": [],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "66-69",
          "snippet": "off_t FileModule::tell()\n{\n\treturn m_fh->tell();\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  off_t FileModule::tell()\n  {\n  \treturn m_fh->tell();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!canSeek() || (tell() == m_track->fpos_next_frame)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "canSeek",
          "args": [],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "canSeek",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.h",
          "lines": "38-38",
          "snippet": "bool canSeek() const { return m_canSeek; }",
          "includes": [
            "#include \"Module.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Module.h\"\n\nFileModule {\n  bool canSeek() const { return m_canSeek; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"compression.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"FileModule.h\"\n#include \"Compiler.h\"\n#include <math.h>\n#include <assert.h>\n#include \"PCM.h\"\n#include \"config.h\"\n\nPCM {\n  void PCM::sync2()\n  {\n  \tassert(!canSeek() || (tell() == m_track->fpos_next_frame));\n  \n  \t/* We can afford to seek because sync2 is rare. */\n  \tm_track->fpos_after_data = tell();\n  \n  \tm_track->fpos_next_frame = m_saved_fpos_next_frame;\n  \tm_track->nextfframe = m_saved_nextfframe;\n  }\n}"
  },
  {
    "function_name": "sync1",
    "container": "PCM",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/PCM.cpp",
    "lines": "118-122",
    "snippet": "void PCM::sync1()\n{\n\tm_saved_fpos_next_frame = m_track->fpos_next_frame;\n\tm_saved_nextfframe = m_track->nextfframe;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"compression.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"FileModule.h\"",
      "#include \"Compiler.h\"",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"PCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"compression.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"FileModule.h\"\n#include \"Compiler.h\"\n#include <math.h>\n#include <assert.h>\n#include \"PCM.h\"\n#include \"config.h\"\n\nPCM {\n  void PCM::sync1()\n  {\n  \tm_saved_fpos_next_frame = m_track->fpos_next_frame;\n  \tm_saved_nextfframe = m_track->nextfframe;\n  }\n}"
  },
  {
    "function_name": "runPush",
    "container": "PCM",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/PCM.cpp",
    "lines": "91-116",
    "snippet": "void PCM::runPush()\n{\n\tAFframecount frames2write = m_inChunk->frameCount;\n\tAFframecount n;\n\n\t/*\n\t\tWARNING: due to the optimization explained at the end\n\t\tof arrangemodules(), the pcm file module cannot depend\n\t\ton the presence of the intermediate working buffer\n\t\twhich _AFsetupmodules usually allocates for file\n\t\tmodules in their input or output chunk (for reading or\n\t\twriting, respectively).\n\n\t\tFortunately, the pcm module has no need for such a buffer.\n\t*/\n\n\tssize_t bytesWritten = write(m_inChunk->buffer, m_bytesPerFrame * frames2write);\n\tn = bytesWritten >= 0 ? bytesWritten / m_bytesPerFrame : 0;\n\n\tif (n != frames2write)\n\t\treportWriteError(n, frames2write);\n\n\tm_track->nextfframe += n;\n\tm_track->totalfframes = m_track->nextfframe;\n\tassert(!canSeek() || (tell() == m_track->fpos_next_frame));\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"compression.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"FileModule.h\"",
      "#include \"Compiler.h\"",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"PCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!canSeek() || (tell() == m_track->fpos_next_frame)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tell",
          "args": [],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "66-69",
          "snippet": "off_t FileModule::tell()\n{\n\treturn m_fh->tell();\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  off_t FileModule::tell()\n  {\n  \treturn m_fh->tell();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "canSeek",
          "args": [],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "canSeek",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.h",
          "lines": "38-38",
          "snippet": "bool canSeek() const { return m_canSeek; }",
          "includes": [
            "#include \"Module.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Module.h\"\n\nFileModule {\n  bool canSeek() const { return m_canSeek; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reportWriteError",
          "args": [
            "n",
            "frames2write"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "reportWriteError",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "90-117",
          "snippet": "void FileModule::reportWriteError(AFframecount framesWritten,\n\tAFframecount framesToWrite)\n{\n\t// Report error if we haven't already.\n\tif (!m_track->filemodhappy)\n\t\treturn;\n\n\tif (framesWritten < 0)\n\t{\n\t\t// Signal I/O error.\n\t\t_af_error(AF_BAD_WRITE,\n\t\t\t\"unable to write data (%s) -- wrote %jd out of %jd frames\",\n\t\t\tstrerror(errno),\n\t\t\tstatic_cast<intmax_t>(m_track->nextfframe),\n\t\t\tstatic_cast<intmax_t>(m_track->nextfframe + framesToWrite));\n\t}\n\telse\n\t{\n\t\t// Signal disk full error.\n\t\t_af_error(AF_BAD_WRITE,\n\t\t\t\"unable to write data (disk full) -- \"\n\t\t\t\"wrote %jd out of %jd frames\",\n\t\t\tstatic_cast<intmax_t>(m_track->nextfframe + framesWritten),\n\t\t\tstatic_cast<intmax_t>(m_track->nextfframe + framesToWrite));\n\t}\n\n\tm_track->filemodhappy = false;\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  void FileModule::reportWriteError(AFframecount framesWritten,\n  \tAFframecount framesToWrite)\n  {\n  \t// Report error if we haven't already.\n  \tif (!m_track->filemodhappy)\n  \t\treturn;\n  \n  \tif (framesWritten < 0)\n  \t{\n  \t\t// Signal I/O error.\n  \t\t_af_error(AF_BAD_WRITE,\n  \t\t\t\"unable to write data (%s) -- wrote %jd out of %jd frames\",\n  \t\t\tstrerror(errno),\n  \t\t\tstatic_cast<intmax_t>(m_track->nextfframe),\n  \t\t\tstatic_cast<intmax_t>(m_track->nextfframe + framesToWrite));\n  \t}\n  \telse\n  \t{\n  \t\t// Signal disk full error.\n  \t\t_af_error(AF_BAD_WRITE,\n  \t\t\t\"unable to write data (disk full) -- \"\n  \t\t\t\"wrote %jd out of %jd frames\",\n  \t\t\tstatic_cast<intmax_t>(m_track->nextfframe + framesWritten),\n  \t\t\tstatic_cast<intmax_t>(m_track->nextfframe + framesToWrite));\n  \t}\n  \n  \tm_track->filemodhappy = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "m_inChunk->buffer",
            "m_bytesPerFrame * frames2write"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "50-59",
          "snippet": "ssize_t FileModule::write(const void *data, size_t nbytes)\n{\n\tssize_t bytesWritten = m_fh->write(data, nbytes);\n\tif (bytesWritten > 0)\n\t{\n\t\tm_track->fpos_next_frame += bytesWritten;\n\t\tm_track->data_size += bytesWritten;\n\t}\n\treturn bytesWritten;\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  ssize_t FileModule::write(const void *data, size_t nbytes)\n  {\n  \tssize_t bytesWritten = m_fh->write(data, nbytes);\n  \tif (bytesWritten > 0)\n  \t{\n  \t\tm_track->fpos_next_frame += bytesWritten;\n  \t\tm_track->data_size += bytesWritten;\n  \t}\n  \treturn bytesWritten;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"compression.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"FileModule.h\"\n#include \"Compiler.h\"\n#include <math.h>\n#include <assert.h>\n#include \"PCM.h\"\n#include \"config.h\"\n\nPCM {\n  void PCM::runPush()\n  {\n  \tAFframecount frames2write = m_inChunk->frameCount;\n  \tAFframecount n;\n  \n  \t/*\n  \t\tWARNING: due to the optimization explained at the end\n  \t\tof arrangemodules(), the pcm file module cannot depend\n  \t\ton the presence of the intermediate working buffer\n  \t\twhich _AFsetupmodules usually allocates for file\n  \t\tmodules in their input or output chunk (for reading or\n  \t\twriting, respectively).\n  \n  \t\tFortunately, the pcm module has no need for such a buffer.\n  \t*/\n  \n  \tssize_t bytesWritten = write(m_inChunk->buffer, m_bytesPerFrame * frames2write);\n  \tn = bytesWritten >= 0 ? bytesWritten / m_bytesPerFrame : 0;\n  \n  \tif (n != frames2write)\n  \t\treportWriteError(n, frames2write);\n  \n  \tm_track->nextfframe += n;\n  \tm_track->totalfframes = m_track->nextfframe;\n  \tassert(!canSeek() || (tell() == m_track->fpos_next_frame));\n  }\n}"
  },
  {
    "function_name": "PCM",
    "container": "PCM",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/PCM.cpp",
    "lines": "75-83",
    "snippet": "PCM::PCM(Mode mode, Track *track, File *fh, bool canSeek) :\n\tFileModule(mode, track, fh, canSeek),\n\tm_bytesPerFrame(track->f.bytesPerFrame(false)),\n\tm_saved_fpos_next_frame(-1),\n\tm_saved_nextfframe(-1)\n{\n\tif (mode == Decompress)\n\t\ttrack->f.compressionParams = AU_NULL_PVLIST;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"compression.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"FileModule.h\"",
      "#include \"Compiler.h\"",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"PCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "track->f.bytesPerFrame",
          "args": [
            "false"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "bytesPerFrame",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "51-54",
          "snippet": "size_t AudioFormat::bytesPerFrame(bool stretch3to4) const\n{\n\treturn bytesPerSample(stretch3to4) * channelCount;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  size_t AudioFormat::bytesPerFrame(bool stretch3to4) const\n  {\n  \treturn bytesPerSample(stretch3to4) * channelCount;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"compression.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"FileModule.h\"\n#include \"Compiler.h\"\n#include <math.h>\n#include <assert.h>\n#include \"PCM.h\"\n#include \"config.h\"\n\nPCM {\n  PCM::PCM(Mode mode, Track *track, File *fh, bool canSeek) :\n  \tFileModule(mode, track, fh, canSeek),\n  \tm_bytesPerFrame(track->f.bytesPerFrame(false)),\n  \tm_saved_fpos_next_frame(-1),\n  \tm_saved_nextfframe(-1)\n  {\n  \tif (mode == Decompress)\n  \t\ttrack->f.compressionParams = AU_NULL_PVLIST;\n  }\n}"
  },
  {
    "function_name": "_af_pcm_format_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/PCM.cpp",
    "lines": "40-48",
    "snippet": "bool _af_pcm_format_ok (AudioFormat *f)\n{\n\tassert(!isnan(f->pcm.slope));\n\tassert(!isnan(f->pcm.intercept));\n\tassert(!isnan(f->pcm.minClip));\n\tassert(!isnan(f->pcm.maxClip));\n\n\treturn true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"compression.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"FileModule.h\"",
      "#include \"Compiler.h\"",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"PCM.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!isnan(f->pcm.maxClip)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "f->pcm.maxClip"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!isnan(f->pcm.minClip)"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "f->pcm.minClip"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!isnan(f->pcm.intercept)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "f->pcm.intercept"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!isnan(f->pcm.slope)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "f->pcm.slope"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"compression.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"FileModule.h\"\n#include \"Compiler.h\"\n#include <math.h>\n#include <assert.h>\n#include \"PCM.h\"\n#include \"config.h\"\n\nbool _af_pcm_format_ok (AudioFormat *f)\n{\n\tassert(!isnan(f->pcm.slope));\n\tassert(!isnan(f->pcm.intercept));\n\tassert(!isnan(f->pcm.minClip));\n\tassert(!isnan(f->pcm.maxClip));\n\n\treturn true;\n}"
  }
]