[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "332-336",
    "snippet": "int main(int argc, char **argv)\n{\n\t::testing::InitGoogleTest(&argc, argv);\n\treturn RUN_ALL_TESTS();\n}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RUN_ALL_TESTS",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::testing::InitGoogleTest",
          "args": [
            "&argc",
            "argv"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nint main(int argc, char **argv)\n{\n\t::testing::InitGoogleTest(&argc, argv);\n\treturn RUN_ALL_TESTS();\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "327-330",
    "snippet": "TEST(RebufferModule, VariableToFixed_Multiple)\n{\n\ttestVariableToFixed(true);\n}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "testVariableToFixed",
          "args": [
            "true"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "testVariableToFixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "275-320",
          "snippet": "static void testVariableToFixed(bool multiple)\n{\n\tconst int channels = 2;\n\tAudioFormat f = createAudioFormat(channels);\n\n\tSharedPtr<RebufferModule> rebuffer =\n\t\tnew RebufferModule(RebufferModule::VariableToFixed, f.bytesPerFrame(),\n\t\t\t10, multiple);\n\tSharedPtr<TestSinkModule> sink = new TestSinkModule();\n\trebuffer->setSink(sink.get());\n\n\tSharedPtr<Chunk> variableChunk(new Chunk());\n\tSharedPtr<Chunk> fixedChunk(new Chunk());\n\n\tconst int maxFrameCount = 40;\n\tvariableChunk->f = f;\n\tvariableChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\tfixedChunk->f = f;\n\tfixedChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\trebuffer->setInChunk(variableChunk.get());\n\trebuffer->setOutChunk(fixedChunk.get());\n\n\tsink->setInChunk(fixedChunk.get());\n\n\t// Push 23 frames to the rebuffer module.\n\tvariableChunk->frameCount = 23;\n\tsetChunkData(*variableChunk, 0);\n\tsink->setExpectedRequestLength(multiple ? 20 : 10);\n\trebuffer->runPush();\n\t// Check that 20 frames have been pushed to the sink module.\n\tEXPECT_EQ(sink->startFrame(), 20u);\n\t// Check that the last push contained 20 (multiple) or 10 (single) frames.\n\tEXPECT_EQ(fixedChunk->frameCount, multiple ? 20u : 10u);\n\n\t// Push another 37 frames to the rebuffer module.\n\tvariableChunk->frameCount = 37;\n\tsetChunkData(*variableChunk, 23);\n\tsink->setExpectedRequestLength(multiple ? 40 : 10);\n\trebuffer->runPush();\n\t// Check that 60 frames have been pushed to the sink module.\n\tEXPECT_EQ(sink->startFrame(), 60u);\n\t// Check that the last push contained 40 (multiple) or 10 (single) frames.\n\tEXPECT_EQ(fixedChunk->frameCount, multiple ? 40u : 10u);\n}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic void testVariableToFixed(bool multiple)\n{\n\tconst int channels = 2;\n\tAudioFormat f = createAudioFormat(channels);\n\n\tSharedPtr<RebufferModule> rebuffer =\n\t\tnew RebufferModule(RebufferModule::VariableToFixed, f.bytesPerFrame(),\n\t\t\t10, multiple);\n\tSharedPtr<TestSinkModule> sink = new TestSinkModule();\n\trebuffer->setSink(sink.get());\n\n\tSharedPtr<Chunk> variableChunk(new Chunk());\n\tSharedPtr<Chunk> fixedChunk(new Chunk());\n\n\tconst int maxFrameCount = 40;\n\tvariableChunk->f = f;\n\tvariableChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\tfixedChunk->f = f;\n\tfixedChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\trebuffer->setInChunk(variableChunk.get());\n\trebuffer->setOutChunk(fixedChunk.get());\n\n\tsink->setInChunk(fixedChunk.get());\n\n\t// Push 23 frames to the rebuffer module.\n\tvariableChunk->frameCount = 23;\n\tsetChunkData(*variableChunk, 0);\n\tsink->setExpectedRequestLength(multiple ? 20 : 10);\n\trebuffer->runPush();\n\t// Check that 20 frames have been pushed to the sink module.\n\tEXPECT_EQ(sink->startFrame(), 20u);\n\t// Check that the last push contained 20 (multiple) or 10 (single) frames.\n\tEXPECT_EQ(fixedChunk->frameCount, multiple ? 20u : 10u);\n\n\t// Push another 37 frames to the rebuffer module.\n\tvariableChunk->frameCount = 37;\n\tsetChunkData(*variableChunk, 23);\n\tsink->setExpectedRequestLength(multiple ? 40 : 10);\n\trebuffer->runPush();\n\t// Check that 60 frames have been pushed to the sink module.\n\tEXPECT_EQ(sink->startFrame(), 60u);\n\t// Check that the last push contained 40 (multiple) or 10 (single) frames.\n\tEXPECT_EQ(fixedChunk->frameCount, multiple ? 40u : 10u);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTEST(RebufferModule, VariableToFixed_Multiple)\n{\n\ttestVariableToFixed(true);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "322-325",
    "snippet": "TEST(RebufferModule, VariableToFixed)\n{\n\ttestVariableToFixed(false);\n}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "testVariableToFixed",
          "args": [
            "false"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "testVariableToFixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "275-320",
          "snippet": "static void testVariableToFixed(bool multiple)\n{\n\tconst int channels = 2;\n\tAudioFormat f = createAudioFormat(channels);\n\n\tSharedPtr<RebufferModule> rebuffer =\n\t\tnew RebufferModule(RebufferModule::VariableToFixed, f.bytesPerFrame(),\n\t\t\t10, multiple);\n\tSharedPtr<TestSinkModule> sink = new TestSinkModule();\n\trebuffer->setSink(sink.get());\n\n\tSharedPtr<Chunk> variableChunk(new Chunk());\n\tSharedPtr<Chunk> fixedChunk(new Chunk());\n\n\tconst int maxFrameCount = 40;\n\tvariableChunk->f = f;\n\tvariableChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\tfixedChunk->f = f;\n\tfixedChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\trebuffer->setInChunk(variableChunk.get());\n\trebuffer->setOutChunk(fixedChunk.get());\n\n\tsink->setInChunk(fixedChunk.get());\n\n\t// Push 23 frames to the rebuffer module.\n\tvariableChunk->frameCount = 23;\n\tsetChunkData(*variableChunk, 0);\n\tsink->setExpectedRequestLength(multiple ? 20 : 10);\n\trebuffer->runPush();\n\t// Check that 20 frames have been pushed to the sink module.\n\tEXPECT_EQ(sink->startFrame(), 20u);\n\t// Check that the last push contained 20 (multiple) or 10 (single) frames.\n\tEXPECT_EQ(fixedChunk->frameCount, multiple ? 20u : 10u);\n\n\t// Push another 37 frames to the rebuffer module.\n\tvariableChunk->frameCount = 37;\n\tsetChunkData(*variableChunk, 23);\n\tsink->setExpectedRequestLength(multiple ? 40 : 10);\n\trebuffer->runPush();\n\t// Check that 60 frames have been pushed to the sink module.\n\tEXPECT_EQ(sink->startFrame(), 60u);\n\t// Check that the last push contained 40 (multiple) or 10 (single) frames.\n\tEXPECT_EQ(fixedChunk->frameCount, multiple ? 40u : 10u);\n}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic void testVariableToFixed(bool multiple)\n{\n\tconst int channels = 2;\n\tAudioFormat f = createAudioFormat(channels);\n\n\tSharedPtr<RebufferModule> rebuffer =\n\t\tnew RebufferModule(RebufferModule::VariableToFixed, f.bytesPerFrame(),\n\t\t\t10, multiple);\n\tSharedPtr<TestSinkModule> sink = new TestSinkModule();\n\trebuffer->setSink(sink.get());\n\n\tSharedPtr<Chunk> variableChunk(new Chunk());\n\tSharedPtr<Chunk> fixedChunk(new Chunk());\n\n\tconst int maxFrameCount = 40;\n\tvariableChunk->f = f;\n\tvariableChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\tfixedChunk->f = f;\n\tfixedChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\trebuffer->setInChunk(variableChunk.get());\n\trebuffer->setOutChunk(fixedChunk.get());\n\n\tsink->setInChunk(fixedChunk.get());\n\n\t// Push 23 frames to the rebuffer module.\n\tvariableChunk->frameCount = 23;\n\tsetChunkData(*variableChunk, 0);\n\tsink->setExpectedRequestLength(multiple ? 20 : 10);\n\trebuffer->runPush();\n\t// Check that 20 frames have been pushed to the sink module.\n\tEXPECT_EQ(sink->startFrame(), 20u);\n\t// Check that the last push contained 20 (multiple) or 10 (single) frames.\n\tEXPECT_EQ(fixedChunk->frameCount, multiple ? 20u : 10u);\n\n\t// Push another 37 frames to the rebuffer module.\n\tvariableChunk->frameCount = 37;\n\tsetChunkData(*variableChunk, 23);\n\tsink->setExpectedRequestLength(multiple ? 40 : 10);\n\trebuffer->runPush();\n\t// Check that 60 frames have been pushed to the sink module.\n\tEXPECT_EQ(sink->startFrame(), 60u);\n\t// Check that the last push contained 40 (multiple) or 10 (single) frames.\n\tEXPECT_EQ(fixedChunk->frameCount, multiple ? 40u : 10u);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTEST(RebufferModule, VariableToFixed)\n{\n\ttestVariableToFixed(false);\n}"
  },
  {
    "function_name": "testVariableToFixed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "275-320",
    "snippet": "static void testVariableToFixed(bool multiple)\n{\n\tconst int channels = 2;\n\tAudioFormat f = createAudioFormat(channels);\n\n\tSharedPtr<RebufferModule> rebuffer =\n\t\tnew RebufferModule(RebufferModule::VariableToFixed, f.bytesPerFrame(),\n\t\t\t10, multiple);\n\tSharedPtr<TestSinkModule> sink = new TestSinkModule();\n\trebuffer->setSink(sink.get());\n\n\tSharedPtr<Chunk> variableChunk(new Chunk());\n\tSharedPtr<Chunk> fixedChunk(new Chunk());\n\n\tconst int maxFrameCount = 40;\n\tvariableChunk->f = f;\n\tvariableChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\tfixedChunk->f = f;\n\tfixedChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\trebuffer->setInChunk(variableChunk.get());\n\trebuffer->setOutChunk(fixedChunk.get());\n\n\tsink->setInChunk(fixedChunk.get());\n\n\t// Push 23 frames to the rebuffer module.\n\tvariableChunk->frameCount = 23;\n\tsetChunkData(*variableChunk, 0);\n\tsink->setExpectedRequestLength(multiple ? 20 : 10);\n\trebuffer->runPush();\n\t// Check that 20 frames have been pushed to the sink module.\n\tEXPECT_EQ(sink->startFrame(), 20u);\n\t// Check that the last push contained 20 (multiple) or 10 (single) frames.\n\tEXPECT_EQ(fixedChunk->frameCount, multiple ? 20u : 10u);\n\n\t// Push another 37 frames to the rebuffer module.\n\tvariableChunk->frameCount = 37;\n\tsetChunkData(*variableChunk, 23);\n\tsink->setExpectedRequestLength(multiple ? 40 : 10);\n\trebuffer->runPush();\n\t// Check that 60 frames have been pushed to the sink module.\n\tEXPECT_EQ(sink->startFrame(), 60u);\n\t// Check that the last push contained 40 (multiple) or 10 (single) frames.\n\tEXPECT_EQ(fixedChunk->frameCount, multiple ? 40u : 10u);\n}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "fixedChunk->frameCount",
            "multiple ? 40u : 10u"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "sink->startFrame()",
            "60u"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sink->startFrame",
          "args": [],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "startFrame",
          "container": "TestSinkModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "95-95",
          "snippet": "unsigned startFrame() const { return m_startFrame; }",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSinkModule {\n  unsigned startFrame() const { return m_startFrame; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rebuffer->runPush",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "runPush",
          "container": "TestSinkModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "102-107",
          "snippet": "void runPush()\n\t{\n\t\tEXPECT_EQ(m_inChunk->frameCount, m_expectedRequestLength);\n\t\tvalidateChunkData(*m_inChunk, m_startFrame);\n\t\tm_startFrame += m_inChunk->frameCount;\n\t}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSinkModule {\n  void runPush()\n  \t{\n  \t\tEXPECT_EQ(m_inChunk->frameCount, m_expectedRequestLength);\n  \t\tvalidateChunkData(*m_inChunk, m_startFrame);\n  \t\tm_startFrame += m_inChunk->frameCount;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sink->setExpectedRequestLength",
          "args": [
            "multiple ? 40 : 10"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "setExpectedRequestLength",
          "container": "TestSinkModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "98-101",
          "snippet": "void setExpectedRequestLength(unsigned expectedRequestLength)\n\t{\n\t\tm_expectedRequestLength = expectedRequestLength;\n\t}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSinkModule {\n  void setExpectedRequestLength(unsigned expectedRequestLength)\n  \t{\n  \t\tm_expectedRequestLength = expectedRequestLength;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setChunkData",
          "args": [
            "*variableChunk",
            "23"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "setChunkData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "33-40",
          "snippet": "static void setChunkData(Chunk &chunk, int frameOffset)\n{\n\tint16_t *data = static_cast<int16_t *>(chunk.buffer);\n\tint channels = chunk.f.channelCount;\n\tfor (unsigned i=0; i<chunk.frameCount; i++)\n\t\tfor (int c=0; c<channels; c++)\n\t\t\tdata[i*channels + c] = (frameOffset + i) * channels + c;\n}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic void setChunkData(Chunk &chunk, int frameOffset)\n{\n\tint16_t *data = static_cast<int16_t *>(chunk.buffer);\n\tint channels = chunk.f.channelCount;\n\tfor (unsigned i=0; i<chunk.frameCount; i++)\n\t\tfor (int c=0; c<channels; c++)\n\t\t\tdata[i*channels + c] = (frameOffset + i) * channels + c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "fixedChunk->frameCount",
            "multiple ? 20u : 10u"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "sink->startFrame()",
            "20u"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sink->setInChunk",
          "args": [
            "fixedChunk.get()"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "setInChunk",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.h",
          "lines": "79-79",
          "snippet": "void setInChunk(Chunk *chunk) { m_inChunk = chunk; }",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"AudioFormat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"AudioFormat.h\"\n\nModule {\n  void setInChunk(Chunk *chunk) { m_inChunk = chunk; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixedChunk.get",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rebuffer->setOutChunk",
          "args": [
            "fixedChunk.get()"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "setOutChunk",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.h",
          "lines": "81-81",
          "snippet": "void setOutChunk(Chunk *chunk) { m_outChunk = chunk; }",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"AudioFormat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"AudioFormat.h\"\n\nModule {\n  void setOutChunk(Chunk *chunk) { m_outChunk = chunk; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixedChunk.get",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "variableChunk.get",
          "args": [],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixedChunk->allocate",
          "args": [
            "maxFrameCount * f.bytesPerFrame()"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "allocate",
          "container": "Chunk",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.h",
          "lines": "55-60",
          "snippet": "void allocate(size_t capacity)\n\t{\n\t\tdeallocate();\n\t\townsMemory = true;\n\t\tbuffer = ::operator new(capacity);\n\t}",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"AudioFormat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"AudioFormat.h\"\n\nChunk {\n  void allocate(size_t capacity)\n  \t{\n  \t\tdeallocate();\n  \t\townsMemory = true;\n  \t\tbuffer = ::operator new(capacity);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f.bytesPerFrame",
          "args": [],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "bytesPerFrame",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "61-64",
          "snippet": "size_t AudioFormat::bytesPerFrame() const\n{\n\treturn bytesPerFrame(!isPacked());\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  size_t AudioFormat::bytesPerFrame() const\n  {\n  \treturn bytesPerFrame(!isPacked());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rebuffer->setSink",
          "args": [
            "sink.get()"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "setSink",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.cpp",
          "lines": "41-41",
          "snippet": "void Module::setSink(Module *module) { m_sink = module; }",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"File.h\"",
            "#include \"Module.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"SimpleModule.h\"\n#include \"File.h\"\n#include \"Module.h\"\n#include \"config.h\"\n\nModule {\n  void Module::setSink(Module *module) { m_sink = module; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sink.get",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "createAudioFormat",
          "args": [
            "channels"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "createAudioFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "114-130",
          "snippet": "static AudioFormat createAudioFormat(int channels)\n{\n\tAudioFormat f =\n\t{\n\t\t44100,\n\t\tAF_SAMPFMT_TWOSCOMP,\n\t\t16,\n\t\t_AF_BYTEORDER_NATIVE,\n\t\t{ 0, 0, 0, 0 },\n\t\tchannels,\n\t\tAF_COMPRESSION_NONE,\n\t\tNULL,\n\t\tfalse\n\t};\n\n\treturn f;\n}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic AudioFormat createAudioFormat(int channels)\n{\n\tAudioFormat f =\n\t{\n\t\t44100,\n\t\tAF_SAMPFMT_TWOSCOMP,\n\t\t16,\n\t\t_AF_BYTEORDER_NATIVE,\n\t\t{ 0, 0, 0, 0 },\n\t\tchannels,\n\t\tAF_COMPRESSION_NONE,\n\t\tNULL,\n\t\tfalse\n\t};\n\n\treturn f;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic void testVariableToFixed(bool multiple)\n{\n\tconst int channels = 2;\n\tAudioFormat f = createAudioFormat(channels);\n\n\tSharedPtr<RebufferModule> rebuffer =\n\t\tnew RebufferModule(RebufferModule::VariableToFixed, f.bytesPerFrame(),\n\t\t\t10, multiple);\n\tSharedPtr<TestSinkModule> sink = new TestSinkModule();\n\trebuffer->setSink(sink.get());\n\n\tSharedPtr<Chunk> variableChunk(new Chunk());\n\tSharedPtr<Chunk> fixedChunk(new Chunk());\n\n\tconst int maxFrameCount = 40;\n\tvariableChunk->f = f;\n\tvariableChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\tfixedChunk->f = f;\n\tfixedChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\trebuffer->setInChunk(variableChunk.get());\n\trebuffer->setOutChunk(fixedChunk.get());\n\n\tsink->setInChunk(fixedChunk.get());\n\n\t// Push 23 frames to the rebuffer module.\n\tvariableChunk->frameCount = 23;\n\tsetChunkData(*variableChunk, 0);\n\tsink->setExpectedRequestLength(multiple ? 20 : 10);\n\trebuffer->runPush();\n\t// Check that 20 frames have been pushed to the sink module.\n\tEXPECT_EQ(sink->startFrame(), 20u);\n\t// Check that the last push contained 20 (multiple) or 10 (single) frames.\n\tEXPECT_EQ(fixedChunk->frameCount, multiple ? 20u : 10u);\n\n\t// Push another 37 frames to the rebuffer module.\n\tvariableChunk->frameCount = 37;\n\tsetChunkData(*variableChunk, 23);\n\tsink->setExpectedRequestLength(multiple ? 40 : 10);\n\trebuffer->runPush();\n\t// Check that 60 frames have been pushed to the sink module.\n\tEXPECT_EQ(sink->startFrame(), 60u);\n\t// Check that the last push contained 40 (multiple) or 10 (single) frames.\n\tEXPECT_EQ(fixedChunk->frameCount, multiple ? 40u : 10u);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "270-273",
    "snippet": "TEST(RebufferModule, FixedToVariable_BufferingAfterShortChunk_Multiple)\n{\n\ttestBufferingAfterShortChunk(true);\n}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "testBufferingAfterShortChunk",
          "args": [
            "true"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "testBufferingAfterShortChunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "214-263",
          "snippet": "static void testBufferingAfterShortChunk(bool multiple)\n{\n\tconst int channels = 2;\n\tAudioFormat f = createAudioFormat(channels);\n\n\tSharedPtr<RebufferModule> rebuffer =\n\t\tnew RebufferModule(RebufferModule::FixedToVariable, f.bytesPerFrame(),\n\t\t\t10, multiple);\n\n\tSharedPtr<TestSourceModule> source = new TestSourceModule();\n\trebuffer->setSource(source.get());\n\n\tSharedPtr<Chunk> fixedChunk(new Chunk());\n\tSharedPtr<Chunk> variableChunk(new Chunk());\n\n\tconst int maxFrameCount = 30;\n\tfixedChunk->f = f;\n\tfixedChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\tvariableChunk->f = f;\n\tvariableChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\trebuffer->setInChunk(fixedChunk.get());\n\trebuffer->setOutChunk(variableChunk.get());\n\n\tsource->setOutChunk(fixedChunk.get());\n\n\t// Initialize source to contain 23 frames.\n\tsource->setFrameCount(23);\n\n\t// Request 21 frames from rebuffer module.\n\tvariableChunk->frameCount = 21;\n\tsource->setExpectedRequestLength(multiple ? 30 : 10);\n\trebuffer->runPull();\n\t// Check that all 23 frames have been pulled from source module.\n\tEXPECT_EQ(23u, source->startFrame());\n\t// Check that rebuffer module has fulfilled request of 21 frames.\n\tEXPECT_EQ(21u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 0);\n\n\t// Request 5 frames from rebuffer module.\n\tvariableChunk->frameCount = 5;\n\tsource->setExpectedRequestLength(-1);\n\trebuffer->runPull();\n\t// Check that rebuffer module has delivered remaining 2 frames.\n\tEXPECT_EQ(2u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 21);\n}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic void testBufferingAfterShortChunk(bool multiple)\n{\n\tconst int channels = 2;\n\tAudioFormat f = createAudioFormat(channels);\n\n\tSharedPtr<RebufferModule> rebuffer =\n\t\tnew RebufferModule(RebufferModule::FixedToVariable, f.bytesPerFrame(),\n\t\t\t10, multiple);\n\n\tSharedPtr<TestSourceModule> source = new TestSourceModule();\n\trebuffer->setSource(source.get());\n\n\tSharedPtr<Chunk> fixedChunk(new Chunk());\n\tSharedPtr<Chunk> variableChunk(new Chunk());\n\n\tconst int maxFrameCount = 30;\n\tfixedChunk->f = f;\n\tfixedChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\tvariableChunk->f = f;\n\tvariableChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\trebuffer->setInChunk(fixedChunk.get());\n\trebuffer->setOutChunk(variableChunk.get());\n\n\tsource->setOutChunk(fixedChunk.get());\n\n\t// Initialize source to contain 23 frames.\n\tsource->setFrameCount(23);\n\n\t// Request 21 frames from rebuffer module.\n\tvariableChunk->frameCount = 21;\n\tsource->setExpectedRequestLength(multiple ? 30 : 10);\n\trebuffer->runPull();\n\t// Check that all 23 frames have been pulled from source module.\n\tEXPECT_EQ(23u, source->startFrame());\n\t// Check that rebuffer module has fulfilled request of 21 frames.\n\tEXPECT_EQ(21u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 0);\n\n\t// Request 5 frames from rebuffer module.\n\tvariableChunk->frameCount = 5;\n\tsource->setExpectedRequestLength(-1);\n\trebuffer->runPull();\n\t// Check that rebuffer module has delivered remaining 2 frames.\n\tEXPECT_EQ(2u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 21);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTEST(RebufferModule, FixedToVariable_BufferingAfterShortChunk_Multiple)\n{\n\ttestBufferingAfterShortChunk(true);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "265-268",
    "snippet": "TEST(RebufferModule, FixedToVariable_BufferingAfterShortChunk)\n{\n\ttestBufferingAfterShortChunk(false);\n}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "testBufferingAfterShortChunk",
          "args": [
            "false"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "testBufferingAfterShortChunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "214-263",
          "snippet": "static void testBufferingAfterShortChunk(bool multiple)\n{\n\tconst int channels = 2;\n\tAudioFormat f = createAudioFormat(channels);\n\n\tSharedPtr<RebufferModule> rebuffer =\n\t\tnew RebufferModule(RebufferModule::FixedToVariable, f.bytesPerFrame(),\n\t\t\t10, multiple);\n\n\tSharedPtr<TestSourceModule> source = new TestSourceModule();\n\trebuffer->setSource(source.get());\n\n\tSharedPtr<Chunk> fixedChunk(new Chunk());\n\tSharedPtr<Chunk> variableChunk(new Chunk());\n\n\tconst int maxFrameCount = 30;\n\tfixedChunk->f = f;\n\tfixedChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\tvariableChunk->f = f;\n\tvariableChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\trebuffer->setInChunk(fixedChunk.get());\n\trebuffer->setOutChunk(variableChunk.get());\n\n\tsource->setOutChunk(fixedChunk.get());\n\n\t// Initialize source to contain 23 frames.\n\tsource->setFrameCount(23);\n\n\t// Request 21 frames from rebuffer module.\n\tvariableChunk->frameCount = 21;\n\tsource->setExpectedRequestLength(multiple ? 30 : 10);\n\trebuffer->runPull();\n\t// Check that all 23 frames have been pulled from source module.\n\tEXPECT_EQ(23u, source->startFrame());\n\t// Check that rebuffer module has fulfilled request of 21 frames.\n\tEXPECT_EQ(21u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 0);\n\n\t// Request 5 frames from rebuffer module.\n\tvariableChunk->frameCount = 5;\n\tsource->setExpectedRequestLength(-1);\n\trebuffer->runPull();\n\t// Check that rebuffer module has delivered remaining 2 frames.\n\tEXPECT_EQ(2u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 21);\n}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic void testBufferingAfterShortChunk(bool multiple)\n{\n\tconst int channels = 2;\n\tAudioFormat f = createAudioFormat(channels);\n\n\tSharedPtr<RebufferModule> rebuffer =\n\t\tnew RebufferModule(RebufferModule::FixedToVariable, f.bytesPerFrame(),\n\t\t\t10, multiple);\n\n\tSharedPtr<TestSourceModule> source = new TestSourceModule();\n\trebuffer->setSource(source.get());\n\n\tSharedPtr<Chunk> fixedChunk(new Chunk());\n\tSharedPtr<Chunk> variableChunk(new Chunk());\n\n\tconst int maxFrameCount = 30;\n\tfixedChunk->f = f;\n\tfixedChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\tvariableChunk->f = f;\n\tvariableChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\trebuffer->setInChunk(fixedChunk.get());\n\trebuffer->setOutChunk(variableChunk.get());\n\n\tsource->setOutChunk(fixedChunk.get());\n\n\t// Initialize source to contain 23 frames.\n\tsource->setFrameCount(23);\n\n\t// Request 21 frames from rebuffer module.\n\tvariableChunk->frameCount = 21;\n\tsource->setExpectedRequestLength(multiple ? 30 : 10);\n\trebuffer->runPull();\n\t// Check that all 23 frames have been pulled from source module.\n\tEXPECT_EQ(23u, source->startFrame());\n\t// Check that rebuffer module has fulfilled request of 21 frames.\n\tEXPECT_EQ(21u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 0);\n\n\t// Request 5 frames from rebuffer module.\n\tvariableChunk->frameCount = 5;\n\tsource->setExpectedRequestLength(-1);\n\trebuffer->runPull();\n\t// Check that rebuffer module has delivered remaining 2 frames.\n\tEXPECT_EQ(2u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 21);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTEST(RebufferModule, FixedToVariable_BufferingAfterShortChunk)\n{\n\ttestBufferingAfterShortChunk(false);\n}"
  },
  {
    "function_name": "testBufferingAfterShortChunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "214-263",
    "snippet": "static void testBufferingAfterShortChunk(bool multiple)\n{\n\tconst int channels = 2;\n\tAudioFormat f = createAudioFormat(channels);\n\n\tSharedPtr<RebufferModule> rebuffer =\n\t\tnew RebufferModule(RebufferModule::FixedToVariable, f.bytesPerFrame(),\n\t\t\t10, multiple);\n\n\tSharedPtr<TestSourceModule> source = new TestSourceModule();\n\trebuffer->setSource(source.get());\n\n\tSharedPtr<Chunk> fixedChunk(new Chunk());\n\tSharedPtr<Chunk> variableChunk(new Chunk());\n\n\tconst int maxFrameCount = 30;\n\tfixedChunk->f = f;\n\tfixedChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\tvariableChunk->f = f;\n\tvariableChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\trebuffer->setInChunk(fixedChunk.get());\n\trebuffer->setOutChunk(variableChunk.get());\n\n\tsource->setOutChunk(fixedChunk.get());\n\n\t// Initialize source to contain 23 frames.\n\tsource->setFrameCount(23);\n\n\t// Request 21 frames from rebuffer module.\n\tvariableChunk->frameCount = 21;\n\tsource->setExpectedRequestLength(multiple ? 30 : 10);\n\trebuffer->runPull();\n\t// Check that all 23 frames have been pulled from source module.\n\tEXPECT_EQ(23u, source->startFrame());\n\t// Check that rebuffer module has fulfilled request of 21 frames.\n\tEXPECT_EQ(21u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 0);\n\n\t// Request 5 frames from rebuffer module.\n\tvariableChunk->frameCount = 5;\n\tsource->setExpectedRequestLength(-1);\n\trebuffer->runPull();\n\t// Check that rebuffer module has delivered remaining 2 frames.\n\tEXPECT_EQ(2u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 21);\n}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "validateChunkData",
          "args": [
            "*variableChunk",
            "21"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "validateChunkData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "42-50",
          "snippet": "static void validateChunkData(const Chunk &chunk, int frameOffset)\n{\n\tconst int16_t *data = static_cast<const int16_t *>(chunk.buffer);\n\tint channels = chunk.f.channelCount;\n\tfor (unsigned i=0; i < chunk.frameCount; i++)\n\t\tfor (int c=0; c < channels; c++)\n\t\t\tEXPECT_EQ(data[i * channels + c],\n\t\t\t\tint(frameOffset + i) * channels + c);\n}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic void validateChunkData(const Chunk &chunk, int frameOffset)\n{\n\tconst int16_t *data = static_cast<const int16_t *>(chunk.buffer);\n\tint channels = chunk.f.channelCount;\n\tfor (unsigned i=0; i < chunk.frameCount; i++)\n\t\tfor (int c=0; c < channels; c++)\n\t\t\tEXPECT_EQ(data[i * channels + c],\n\t\t\t\tint(frameOffset + i) * channels + c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2u",
            "variableChunk->frameCount"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rebuffer->runPull",
          "args": [],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "runPull",
          "container": "TestSourceModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "71-79",
          "snippet": "void runPull()\n\t{\n\t\tEXPECT_EQ(m_outChunk->frameCount, m_expectedRequestLength);\n\t\tunsigned frameCount = std::min<unsigned>(m_outChunk->frameCount, m_frameCount);\n\t\tm_outChunk->frameCount = frameCount;\n\t\tsetChunkData(*m_outChunk, m_startFrame);\n\t\tm_startFrame += frameCount;\n\t\tm_frameCount -= frameCount;\n\t}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSourceModule {\n  void runPull()\n  \t{\n  \t\tEXPECT_EQ(m_outChunk->frameCount, m_expectedRequestLength);\n  \t\tunsigned frameCount = std::min<unsigned>(m_outChunk->frameCount, m_frameCount);\n  \t\tm_outChunk->frameCount = frameCount;\n  \t\tsetChunkData(*m_outChunk, m_startFrame);\n  \t\tm_startFrame += frameCount;\n  \t\tm_frameCount -= frameCount;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "source->setExpectedRequestLength",
          "args": [
            "-1"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "setExpectedRequestLength",
          "container": "TestSinkModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "98-101",
          "snippet": "void setExpectedRequestLength(unsigned expectedRequestLength)\n\t{\n\t\tm_expectedRequestLength = expectedRequestLength;\n\t}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSinkModule {\n  void setExpectedRequestLength(unsigned expectedRequestLength)\n  \t{\n  \t\tm_expectedRequestLength = expectedRequestLength;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "21u",
            "variableChunk->frameCount"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "23u",
            "source->startFrame()"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "source->startFrame",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "startFrame",
          "container": "TestSinkModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "95-95",
          "snippet": "unsigned startFrame() const { return m_startFrame; }",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSinkModule {\n  unsigned startFrame() const { return m_startFrame; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "source->setFrameCount",
          "args": [
            "23"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "setFrameCount",
          "container": "TestSourceModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "64-64",
          "snippet": "void setFrameCount(unsigned frameCount) { m_frameCount = frameCount; }",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSourceModule {\n  void setFrameCount(unsigned frameCount) { m_frameCount = frameCount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "source->setOutChunk",
          "args": [
            "fixedChunk.get()"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "setOutChunk",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.h",
          "lines": "81-81",
          "snippet": "void setOutChunk(Chunk *chunk) { m_outChunk = chunk; }",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"AudioFormat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"AudioFormat.h\"\n\nModule {\n  void setOutChunk(Chunk *chunk) { m_outChunk = chunk; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixedChunk.get",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "variableChunk.get",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rebuffer->setInChunk",
          "args": [
            "fixedChunk.get()"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "setInChunk",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.h",
          "lines": "79-79",
          "snippet": "void setInChunk(Chunk *chunk) { m_inChunk = chunk; }",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"AudioFormat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"AudioFormat.h\"\n\nModule {\n  void setInChunk(Chunk *chunk) { m_inChunk = chunk; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixedChunk.get",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "variableChunk->allocate",
          "args": [
            "maxFrameCount * f.bytesPerFrame()"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "allocate",
          "container": "Chunk",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.h",
          "lines": "55-60",
          "snippet": "void allocate(size_t capacity)\n\t{\n\t\tdeallocate();\n\t\townsMemory = true;\n\t\tbuffer = ::operator new(capacity);\n\t}",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"AudioFormat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"AudioFormat.h\"\n\nChunk {\n  void allocate(size_t capacity)\n  \t{\n  \t\tdeallocate();\n  \t\townsMemory = true;\n  \t\tbuffer = ::operator new(capacity);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f.bytesPerFrame",
          "args": [],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "bytesPerFrame",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "61-64",
          "snippet": "size_t AudioFormat::bytesPerFrame() const\n{\n\treturn bytesPerFrame(!isPacked());\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  size_t AudioFormat::bytesPerFrame() const\n  {\n  \treturn bytesPerFrame(!isPacked());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rebuffer->setSource",
          "args": [
            "source.get()"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "setSource",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.cpp",
          "lines": "42-42",
          "snippet": "void Module::setSource(Module *module) { m_source = module; }",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"File.h\"",
            "#include \"Module.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"SimpleModule.h\"\n#include \"File.h\"\n#include \"Module.h\"\n#include \"config.h\"\n\nModule {\n  void Module::setSource(Module *module) { m_source = module; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "source.get",
          "args": [],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "createAudioFormat",
          "args": [
            "channels"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "createAudioFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "114-130",
          "snippet": "static AudioFormat createAudioFormat(int channels)\n{\n\tAudioFormat f =\n\t{\n\t\t44100,\n\t\tAF_SAMPFMT_TWOSCOMP,\n\t\t16,\n\t\t_AF_BYTEORDER_NATIVE,\n\t\t{ 0, 0, 0, 0 },\n\t\tchannels,\n\t\tAF_COMPRESSION_NONE,\n\t\tNULL,\n\t\tfalse\n\t};\n\n\treturn f;\n}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic AudioFormat createAudioFormat(int channels)\n{\n\tAudioFormat f =\n\t{\n\t\t44100,\n\t\tAF_SAMPFMT_TWOSCOMP,\n\t\t16,\n\t\t_AF_BYTEORDER_NATIVE,\n\t\t{ 0, 0, 0, 0 },\n\t\tchannels,\n\t\tAF_COMPRESSION_NONE,\n\t\tNULL,\n\t\tfalse\n\t};\n\n\treturn f;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic void testBufferingAfterShortChunk(bool multiple)\n{\n\tconst int channels = 2;\n\tAudioFormat f = createAudioFormat(channels);\n\n\tSharedPtr<RebufferModule> rebuffer =\n\t\tnew RebufferModule(RebufferModule::FixedToVariable, f.bytesPerFrame(),\n\t\t\t10, multiple);\n\n\tSharedPtr<TestSourceModule> source = new TestSourceModule();\n\trebuffer->setSource(source.get());\n\n\tSharedPtr<Chunk> fixedChunk(new Chunk());\n\tSharedPtr<Chunk> variableChunk(new Chunk());\n\n\tconst int maxFrameCount = 30;\n\tfixedChunk->f = f;\n\tfixedChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\tvariableChunk->f = f;\n\tvariableChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\trebuffer->setInChunk(fixedChunk.get());\n\trebuffer->setOutChunk(variableChunk.get());\n\n\tsource->setOutChunk(fixedChunk.get());\n\n\t// Initialize source to contain 23 frames.\n\tsource->setFrameCount(23);\n\n\t// Request 21 frames from rebuffer module.\n\tvariableChunk->frameCount = 21;\n\tsource->setExpectedRequestLength(multiple ? 30 : 10);\n\trebuffer->runPull();\n\t// Check that all 23 frames have been pulled from source module.\n\tEXPECT_EQ(23u, source->startFrame());\n\t// Check that rebuffer module has fulfilled request of 21 frames.\n\tEXPECT_EQ(21u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 0);\n\n\t// Request 5 frames from rebuffer module.\n\tvariableChunk->frameCount = 5;\n\tsource->setExpectedRequestLength(-1);\n\trebuffer->runPull();\n\t// Check that rebuffer module has delivered remaining 2 frames.\n\tEXPECT_EQ(2u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 21);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "201-204",
    "snippet": "TEST(RebufferModule, FixedToVariable_Multiple)\n{\n\ttestFixedToVariable(true);\n}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "testFixedToVariable",
          "args": [
            "true"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "testFixedToVariable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "132-194",
          "snippet": "static void testFixedToVariable(bool multiple)\n{\n\tconst int channels = 2;\n\tAudioFormat f = createAudioFormat(channels);\n\n\tSharedPtr<RebufferModule> rebuffer =\n\t\tnew RebufferModule(RebufferModule::FixedToVariable, f.bytesPerFrame(),\n\t\t\t10, multiple);\n\n\tSharedPtr<TestSourceModule> source = new TestSourceModule();\n\trebuffer->setSource(source.get());\n\n\tSharedPtr<Chunk> fixedChunk(new Chunk());\n\tSharedPtr<Chunk> variableChunk(new Chunk());\n\n\tconst int maxFrameCount = 50;\n\tfixedChunk->f = f;\n\tfixedChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\tvariableChunk->f = f;\n\tvariableChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\trebuffer->setInChunk(fixedChunk.get());\n\trebuffer->setOutChunk(variableChunk.get());\n\n\tsource->setOutChunk(fixedChunk.get());\n\n\t// Initialize source to contain 100 frames.\n\tsource->setFrameCount(100);\n\n\t// Request 22 frames from rebuffer module.\n\tvariableChunk->frameCount = 22;\n\tsource->setExpectedRequestLength(multiple ? 30 : 10);\n\trebuffer->runPull();\n\t// Check that 30 frames have been pulled from source module.\n\tEXPECT_EQ(30u, source->startFrame());\n\t// Check that rebuffer module has fulfilled request of 22 frames.\n\tEXPECT_EQ(22u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 0);\n\n\t// Request 30 frames from rebuffer module.\n\tvariableChunk->frameCount = 30;\n\tsource->setExpectedRequestLength(multiple ? 30 : 10);\n\trebuffer->runPull();\n\t// Check that 60 frames have been pulled from source module.\n\tEXPECT_EQ(60u, source->startFrame());\n\t// Check that rebuffer module has fulfilled request of 28 frames.\n\tEXPECT_EQ(30u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 22);\n\n\t// Request 50 frames from rebuffer module.\n\tvariableChunk->frameCount = 50;\n\tsource->setExpectedRequestLength(multiple ? 50 : 10);\n\trebuffer->runPull();\n\t// Check that 100 frames have been pulled from source module.\n\tEXPECT_EQ(100u, source->startFrame());\n\t// Check that rebuffer module has filled 48 of 50 frames requested.\n\tEXPECT_EQ(48u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 52);\n}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic void testFixedToVariable(bool multiple)\n{\n\tconst int channels = 2;\n\tAudioFormat f = createAudioFormat(channels);\n\n\tSharedPtr<RebufferModule> rebuffer =\n\t\tnew RebufferModule(RebufferModule::FixedToVariable, f.bytesPerFrame(),\n\t\t\t10, multiple);\n\n\tSharedPtr<TestSourceModule> source = new TestSourceModule();\n\trebuffer->setSource(source.get());\n\n\tSharedPtr<Chunk> fixedChunk(new Chunk());\n\tSharedPtr<Chunk> variableChunk(new Chunk());\n\n\tconst int maxFrameCount = 50;\n\tfixedChunk->f = f;\n\tfixedChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\tvariableChunk->f = f;\n\tvariableChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\trebuffer->setInChunk(fixedChunk.get());\n\trebuffer->setOutChunk(variableChunk.get());\n\n\tsource->setOutChunk(fixedChunk.get());\n\n\t// Initialize source to contain 100 frames.\n\tsource->setFrameCount(100);\n\n\t// Request 22 frames from rebuffer module.\n\tvariableChunk->frameCount = 22;\n\tsource->setExpectedRequestLength(multiple ? 30 : 10);\n\trebuffer->runPull();\n\t// Check that 30 frames have been pulled from source module.\n\tEXPECT_EQ(30u, source->startFrame());\n\t// Check that rebuffer module has fulfilled request of 22 frames.\n\tEXPECT_EQ(22u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 0);\n\n\t// Request 30 frames from rebuffer module.\n\tvariableChunk->frameCount = 30;\n\tsource->setExpectedRequestLength(multiple ? 30 : 10);\n\trebuffer->runPull();\n\t// Check that 60 frames have been pulled from source module.\n\tEXPECT_EQ(60u, source->startFrame());\n\t// Check that rebuffer module has fulfilled request of 28 frames.\n\tEXPECT_EQ(30u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 22);\n\n\t// Request 50 frames from rebuffer module.\n\tvariableChunk->frameCount = 50;\n\tsource->setExpectedRequestLength(multiple ? 50 : 10);\n\trebuffer->runPull();\n\t// Check that 100 frames have been pulled from source module.\n\tEXPECT_EQ(100u, source->startFrame());\n\t// Check that rebuffer module has filled 48 of 50 frames requested.\n\tEXPECT_EQ(48u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 52);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTEST(RebufferModule, FixedToVariable_Multiple)\n{\n\ttestFixedToVariable(true);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "196-199",
    "snippet": "TEST(RebufferModule, FixedToVariable)\n{\n\ttestFixedToVariable(false);\n}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "testFixedToVariable",
          "args": [
            "false"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "testFixedToVariable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "132-194",
          "snippet": "static void testFixedToVariable(bool multiple)\n{\n\tconst int channels = 2;\n\tAudioFormat f = createAudioFormat(channels);\n\n\tSharedPtr<RebufferModule> rebuffer =\n\t\tnew RebufferModule(RebufferModule::FixedToVariable, f.bytesPerFrame(),\n\t\t\t10, multiple);\n\n\tSharedPtr<TestSourceModule> source = new TestSourceModule();\n\trebuffer->setSource(source.get());\n\n\tSharedPtr<Chunk> fixedChunk(new Chunk());\n\tSharedPtr<Chunk> variableChunk(new Chunk());\n\n\tconst int maxFrameCount = 50;\n\tfixedChunk->f = f;\n\tfixedChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\tvariableChunk->f = f;\n\tvariableChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\trebuffer->setInChunk(fixedChunk.get());\n\trebuffer->setOutChunk(variableChunk.get());\n\n\tsource->setOutChunk(fixedChunk.get());\n\n\t// Initialize source to contain 100 frames.\n\tsource->setFrameCount(100);\n\n\t// Request 22 frames from rebuffer module.\n\tvariableChunk->frameCount = 22;\n\tsource->setExpectedRequestLength(multiple ? 30 : 10);\n\trebuffer->runPull();\n\t// Check that 30 frames have been pulled from source module.\n\tEXPECT_EQ(30u, source->startFrame());\n\t// Check that rebuffer module has fulfilled request of 22 frames.\n\tEXPECT_EQ(22u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 0);\n\n\t// Request 30 frames from rebuffer module.\n\tvariableChunk->frameCount = 30;\n\tsource->setExpectedRequestLength(multiple ? 30 : 10);\n\trebuffer->runPull();\n\t// Check that 60 frames have been pulled from source module.\n\tEXPECT_EQ(60u, source->startFrame());\n\t// Check that rebuffer module has fulfilled request of 28 frames.\n\tEXPECT_EQ(30u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 22);\n\n\t// Request 50 frames from rebuffer module.\n\tvariableChunk->frameCount = 50;\n\tsource->setExpectedRequestLength(multiple ? 50 : 10);\n\trebuffer->runPull();\n\t// Check that 100 frames have been pulled from source module.\n\tEXPECT_EQ(100u, source->startFrame());\n\t// Check that rebuffer module has filled 48 of 50 frames requested.\n\tEXPECT_EQ(48u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 52);\n}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic void testFixedToVariable(bool multiple)\n{\n\tconst int channels = 2;\n\tAudioFormat f = createAudioFormat(channels);\n\n\tSharedPtr<RebufferModule> rebuffer =\n\t\tnew RebufferModule(RebufferModule::FixedToVariable, f.bytesPerFrame(),\n\t\t\t10, multiple);\n\n\tSharedPtr<TestSourceModule> source = new TestSourceModule();\n\trebuffer->setSource(source.get());\n\n\tSharedPtr<Chunk> fixedChunk(new Chunk());\n\tSharedPtr<Chunk> variableChunk(new Chunk());\n\n\tconst int maxFrameCount = 50;\n\tfixedChunk->f = f;\n\tfixedChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\tvariableChunk->f = f;\n\tvariableChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\trebuffer->setInChunk(fixedChunk.get());\n\trebuffer->setOutChunk(variableChunk.get());\n\n\tsource->setOutChunk(fixedChunk.get());\n\n\t// Initialize source to contain 100 frames.\n\tsource->setFrameCount(100);\n\n\t// Request 22 frames from rebuffer module.\n\tvariableChunk->frameCount = 22;\n\tsource->setExpectedRequestLength(multiple ? 30 : 10);\n\trebuffer->runPull();\n\t// Check that 30 frames have been pulled from source module.\n\tEXPECT_EQ(30u, source->startFrame());\n\t// Check that rebuffer module has fulfilled request of 22 frames.\n\tEXPECT_EQ(22u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 0);\n\n\t// Request 30 frames from rebuffer module.\n\tvariableChunk->frameCount = 30;\n\tsource->setExpectedRequestLength(multiple ? 30 : 10);\n\trebuffer->runPull();\n\t// Check that 60 frames have been pulled from source module.\n\tEXPECT_EQ(60u, source->startFrame());\n\t// Check that rebuffer module has fulfilled request of 28 frames.\n\tEXPECT_EQ(30u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 22);\n\n\t// Request 50 frames from rebuffer module.\n\tvariableChunk->frameCount = 50;\n\tsource->setExpectedRequestLength(multiple ? 50 : 10);\n\trebuffer->runPull();\n\t// Check that 100 frames have been pulled from source module.\n\tEXPECT_EQ(100u, source->startFrame());\n\t// Check that rebuffer module has filled 48 of 50 frames requested.\n\tEXPECT_EQ(48u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 52);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTEST(RebufferModule, FixedToVariable)\n{\n\ttestFixedToVariable(false);\n}"
  },
  {
    "function_name": "testFixedToVariable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "132-194",
    "snippet": "static void testFixedToVariable(bool multiple)\n{\n\tconst int channels = 2;\n\tAudioFormat f = createAudioFormat(channels);\n\n\tSharedPtr<RebufferModule> rebuffer =\n\t\tnew RebufferModule(RebufferModule::FixedToVariable, f.bytesPerFrame(),\n\t\t\t10, multiple);\n\n\tSharedPtr<TestSourceModule> source = new TestSourceModule();\n\trebuffer->setSource(source.get());\n\n\tSharedPtr<Chunk> fixedChunk(new Chunk());\n\tSharedPtr<Chunk> variableChunk(new Chunk());\n\n\tconst int maxFrameCount = 50;\n\tfixedChunk->f = f;\n\tfixedChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\tvariableChunk->f = f;\n\tvariableChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\trebuffer->setInChunk(fixedChunk.get());\n\trebuffer->setOutChunk(variableChunk.get());\n\n\tsource->setOutChunk(fixedChunk.get());\n\n\t// Initialize source to contain 100 frames.\n\tsource->setFrameCount(100);\n\n\t// Request 22 frames from rebuffer module.\n\tvariableChunk->frameCount = 22;\n\tsource->setExpectedRequestLength(multiple ? 30 : 10);\n\trebuffer->runPull();\n\t// Check that 30 frames have been pulled from source module.\n\tEXPECT_EQ(30u, source->startFrame());\n\t// Check that rebuffer module has fulfilled request of 22 frames.\n\tEXPECT_EQ(22u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 0);\n\n\t// Request 30 frames from rebuffer module.\n\tvariableChunk->frameCount = 30;\n\tsource->setExpectedRequestLength(multiple ? 30 : 10);\n\trebuffer->runPull();\n\t// Check that 60 frames have been pulled from source module.\n\tEXPECT_EQ(60u, source->startFrame());\n\t// Check that rebuffer module has fulfilled request of 28 frames.\n\tEXPECT_EQ(30u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 22);\n\n\t// Request 50 frames from rebuffer module.\n\tvariableChunk->frameCount = 50;\n\tsource->setExpectedRequestLength(multiple ? 50 : 10);\n\trebuffer->runPull();\n\t// Check that 100 frames have been pulled from source module.\n\tEXPECT_EQ(100u, source->startFrame());\n\t// Check that rebuffer module has filled 48 of 50 frames requested.\n\tEXPECT_EQ(48u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 52);\n}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "validateChunkData",
          "args": [
            "*variableChunk",
            "52"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "validateChunkData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "42-50",
          "snippet": "static void validateChunkData(const Chunk &chunk, int frameOffset)\n{\n\tconst int16_t *data = static_cast<const int16_t *>(chunk.buffer);\n\tint channels = chunk.f.channelCount;\n\tfor (unsigned i=0; i < chunk.frameCount; i++)\n\t\tfor (int c=0; c < channels; c++)\n\t\t\tEXPECT_EQ(data[i * channels + c],\n\t\t\t\tint(frameOffset + i) * channels + c);\n}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic void validateChunkData(const Chunk &chunk, int frameOffset)\n{\n\tconst int16_t *data = static_cast<const int16_t *>(chunk.buffer);\n\tint channels = chunk.f.channelCount;\n\tfor (unsigned i=0; i < chunk.frameCount; i++)\n\t\tfor (int c=0; c < channels; c++)\n\t\t\tEXPECT_EQ(data[i * channels + c],\n\t\t\t\tint(frameOffset + i) * channels + c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "48u",
            "variableChunk->frameCount"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "100u",
            "source->startFrame()"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "source->startFrame",
          "args": [],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "startFrame",
          "container": "TestSinkModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "95-95",
          "snippet": "unsigned startFrame() const { return m_startFrame; }",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSinkModule {\n  unsigned startFrame() const { return m_startFrame; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rebuffer->runPull",
          "args": [],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "runPull",
          "container": "TestSourceModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "71-79",
          "snippet": "void runPull()\n\t{\n\t\tEXPECT_EQ(m_outChunk->frameCount, m_expectedRequestLength);\n\t\tunsigned frameCount = std::min<unsigned>(m_outChunk->frameCount, m_frameCount);\n\t\tm_outChunk->frameCount = frameCount;\n\t\tsetChunkData(*m_outChunk, m_startFrame);\n\t\tm_startFrame += frameCount;\n\t\tm_frameCount -= frameCount;\n\t}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSourceModule {\n  void runPull()\n  \t{\n  \t\tEXPECT_EQ(m_outChunk->frameCount, m_expectedRequestLength);\n  \t\tunsigned frameCount = std::min<unsigned>(m_outChunk->frameCount, m_frameCount);\n  \t\tm_outChunk->frameCount = frameCount;\n  \t\tsetChunkData(*m_outChunk, m_startFrame);\n  \t\tm_startFrame += frameCount;\n  \t\tm_frameCount -= frameCount;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "source->setExpectedRequestLength",
          "args": [
            "multiple ? 50 : 10"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "setExpectedRequestLength",
          "container": "TestSinkModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "98-101",
          "snippet": "void setExpectedRequestLength(unsigned expectedRequestLength)\n\t{\n\t\tm_expectedRequestLength = expectedRequestLength;\n\t}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSinkModule {\n  void setExpectedRequestLength(unsigned expectedRequestLength)\n  \t{\n  \t\tm_expectedRequestLength = expectedRequestLength;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "30u",
            "variableChunk->frameCount"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "60u",
            "source->startFrame()"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "22u",
            "variableChunk->frameCount"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "30u",
            "source->startFrame()"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "source->setFrameCount",
          "args": [
            "100"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "setFrameCount",
          "container": "TestSourceModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "64-64",
          "snippet": "void setFrameCount(unsigned frameCount) { m_frameCount = frameCount; }",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSourceModule {\n  void setFrameCount(unsigned frameCount) { m_frameCount = frameCount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "source->setOutChunk",
          "args": [
            "fixedChunk.get()"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "setOutChunk",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.h",
          "lines": "81-81",
          "snippet": "void setOutChunk(Chunk *chunk) { m_outChunk = chunk; }",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"AudioFormat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"AudioFormat.h\"\n\nModule {\n  void setOutChunk(Chunk *chunk) { m_outChunk = chunk; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixedChunk.get",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "variableChunk.get",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rebuffer->setInChunk",
          "args": [
            "fixedChunk.get()"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "setInChunk",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.h",
          "lines": "79-79",
          "snippet": "void setInChunk(Chunk *chunk) { m_inChunk = chunk; }",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"AudioFormat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"AudioFormat.h\"\n\nModule {\n  void setInChunk(Chunk *chunk) { m_inChunk = chunk; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixedChunk.get",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "variableChunk->allocate",
          "args": [
            "maxFrameCount * f.bytesPerFrame()"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "allocate",
          "container": "Chunk",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.h",
          "lines": "55-60",
          "snippet": "void allocate(size_t capacity)\n\t{\n\t\tdeallocate();\n\t\townsMemory = true;\n\t\tbuffer = ::operator new(capacity);\n\t}",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"AudioFormat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"AudioFormat.h\"\n\nChunk {\n  void allocate(size_t capacity)\n  \t{\n  \t\tdeallocate();\n  \t\townsMemory = true;\n  \t\tbuffer = ::operator new(capacity);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f.bytesPerFrame",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "bytesPerFrame",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "61-64",
          "snippet": "size_t AudioFormat::bytesPerFrame() const\n{\n\treturn bytesPerFrame(!isPacked());\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  size_t AudioFormat::bytesPerFrame() const\n  {\n  \treturn bytesPerFrame(!isPacked());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rebuffer->setSource",
          "args": [
            "source.get()"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "setSource",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.cpp",
          "lines": "42-42",
          "snippet": "void Module::setSource(Module *module) { m_source = module; }",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"File.h\"",
            "#include \"Module.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"SimpleModule.h\"\n#include \"File.h\"\n#include \"Module.h\"\n#include \"config.h\"\n\nModule {\n  void Module::setSource(Module *module) { m_source = module; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "source.get",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "createAudioFormat",
          "args": [
            "channels"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "createAudioFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "114-130",
          "snippet": "static AudioFormat createAudioFormat(int channels)\n{\n\tAudioFormat f =\n\t{\n\t\t44100,\n\t\tAF_SAMPFMT_TWOSCOMP,\n\t\t16,\n\t\t_AF_BYTEORDER_NATIVE,\n\t\t{ 0, 0, 0, 0 },\n\t\tchannels,\n\t\tAF_COMPRESSION_NONE,\n\t\tNULL,\n\t\tfalse\n\t};\n\n\treturn f;\n}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic AudioFormat createAudioFormat(int channels)\n{\n\tAudioFormat f =\n\t{\n\t\t44100,\n\t\tAF_SAMPFMT_TWOSCOMP,\n\t\t16,\n\t\t_AF_BYTEORDER_NATIVE,\n\t\t{ 0, 0, 0, 0 },\n\t\tchannels,\n\t\tAF_COMPRESSION_NONE,\n\t\tNULL,\n\t\tfalse\n\t};\n\n\treturn f;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic void testFixedToVariable(bool multiple)\n{\n\tconst int channels = 2;\n\tAudioFormat f = createAudioFormat(channels);\n\n\tSharedPtr<RebufferModule> rebuffer =\n\t\tnew RebufferModule(RebufferModule::FixedToVariable, f.bytesPerFrame(),\n\t\t\t10, multiple);\n\n\tSharedPtr<TestSourceModule> source = new TestSourceModule();\n\trebuffer->setSource(source.get());\n\n\tSharedPtr<Chunk> fixedChunk(new Chunk());\n\tSharedPtr<Chunk> variableChunk(new Chunk());\n\n\tconst int maxFrameCount = 50;\n\tfixedChunk->f = f;\n\tfixedChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\tvariableChunk->f = f;\n\tvariableChunk->allocate(maxFrameCount * f.bytesPerFrame());\n\n\trebuffer->setInChunk(fixedChunk.get());\n\trebuffer->setOutChunk(variableChunk.get());\n\n\tsource->setOutChunk(fixedChunk.get());\n\n\t// Initialize source to contain 100 frames.\n\tsource->setFrameCount(100);\n\n\t// Request 22 frames from rebuffer module.\n\tvariableChunk->frameCount = 22;\n\tsource->setExpectedRequestLength(multiple ? 30 : 10);\n\trebuffer->runPull();\n\t// Check that 30 frames have been pulled from source module.\n\tEXPECT_EQ(30u, source->startFrame());\n\t// Check that rebuffer module has fulfilled request of 22 frames.\n\tEXPECT_EQ(22u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 0);\n\n\t// Request 30 frames from rebuffer module.\n\tvariableChunk->frameCount = 30;\n\tsource->setExpectedRequestLength(multiple ? 30 : 10);\n\trebuffer->runPull();\n\t// Check that 60 frames have been pulled from source module.\n\tEXPECT_EQ(60u, source->startFrame());\n\t// Check that rebuffer module has fulfilled request of 28 frames.\n\tEXPECT_EQ(30u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 22);\n\n\t// Request 50 frames from rebuffer module.\n\tvariableChunk->frameCount = 50;\n\tsource->setExpectedRequestLength(multiple ? 50 : 10);\n\trebuffer->runPull();\n\t// Check that 100 frames have been pulled from source module.\n\tEXPECT_EQ(100u, source->startFrame());\n\t// Check that rebuffer module has filled 48 of 50 frames requested.\n\tEXPECT_EQ(48u, variableChunk->frameCount);\n\t// Validate output data.\n\tvalidateChunkData(*variableChunk, 52);\n}"
  },
  {
    "function_name": "createAudioFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "114-130",
    "snippet": "static AudioFormat createAudioFormat(int channels)\n{\n\tAudioFormat f =\n\t{\n\t\t44100,\n\t\tAF_SAMPFMT_TWOSCOMP,\n\t\t16,\n\t\t_AF_BYTEORDER_NATIVE,\n\t\t{ 0, 0, 0, 0 },\n\t\tchannels,\n\t\tAF_COMPRESSION_NONE,\n\t\tNULL,\n\t\tfalse\n\t};\n\n\treturn f;\n}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic AudioFormat createAudioFormat(int channels)\n{\n\tAudioFormat f =\n\t{\n\t\t44100,\n\t\tAF_SAMPFMT_TWOSCOMP,\n\t\t16,\n\t\t_AF_BYTEORDER_NATIVE,\n\t\t{ 0, 0, 0, 0 },\n\t\tchannels,\n\t\tAF_COMPRESSION_NONE,\n\t\tNULL,\n\t\tfalse\n\t};\n\n\treturn f;\n}"
  },
  {
    "function_name": "runPush",
    "container": "TestSinkModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "102-107",
    "snippet": "void runPush()\n\t{\n\t\tEXPECT_EQ(m_inChunk->frameCount, m_expectedRequestLength);\n\t\tvalidateChunkData(*m_inChunk, m_startFrame);\n\t\tm_startFrame += m_inChunk->frameCount;\n\t}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "validateChunkData",
          "args": [
            "*m_inChunk",
            "m_startFrame"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "validateChunkData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "42-50",
          "snippet": "static void validateChunkData(const Chunk &chunk, int frameOffset)\n{\n\tconst int16_t *data = static_cast<const int16_t *>(chunk.buffer);\n\tint channels = chunk.f.channelCount;\n\tfor (unsigned i=0; i < chunk.frameCount; i++)\n\t\tfor (int c=0; c < channels; c++)\n\t\t\tEXPECT_EQ(data[i * channels + c],\n\t\t\t\tint(frameOffset + i) * channels + c);\n}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic void validateChunkData(const Chunk &chunk, int frameOffset)\n{\n\tconst int16_t *data = static_cast<const int16_t *>(chunk.buffer);\n\tint channels = chunk.f.channelCount;\n\tfor (unsigned i=0; i < chunk.frameCount; i++)\n\t\tfor (int c=0; c < channels; c++)\n\t\t\tEXPECT_EQ(data[i * channels + c],\n\t\t\t\tint(frameOffset + i) * channels + c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "m_inChunk->frameCount",
            "m_expectedRequestLength"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSinkModule {\n  void runPush()\n  \t{\n  \t\tEXPECT_EQ(m_inChunk->frameCount, m_expectedRequestLength);\n  \t\tvalidateChunkData(*m_inChunk, m_startFrame);\n  \t\tm_startFrame += m_inChunk->frameCount;\n  \t}\n}"
  },
  {
    "function_name": "setExpectedRequestLength",
    "container": "TestSinkModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "98-101",
    "snippet": "void setExpectedRequestLength(unsigned expectedRequestLength)\n\t{\n\t\tm_expectedRequestLength = expectedRequestLength;\n\t}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSinkModule {\n  void setExpectedRequestLength(unsigned expectedRequestLength)\n  \t{\n  \t\tm_expectedRequestLength = expectedRequestLength;\n  \t}\n}"
  },
  {
    "function_name": "expectedRequestLength",
    "container": "TestSinkModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "97-97",
    "snippet": "unsigned expectedRequestLength() const { return m_expectedRequestLength; }",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSinkModule {\n  unsigned expectedRequestLength() const { return m_expectedRequestLength; }\n}"
  },
  {
    "function_name": "setStartFrame",
    "container": "TestSinkModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "96-96",
    "snippet": "void setStartFrame(unsigned startFrame) { m_startFrame = startFrame; }",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSinkModule {\n  void setStartFrame(unsigned startFrame) { m_startFrame = startFrame; }\n}"
  },
  {
    "function_name": "startFrame",
    "container": "TestSinkModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "95-95",
    "snippet": "unsigned startFrame() const { return m_startFrame; }",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSinkModule {\n  unsigned startFrame() const { return m_startFrame; }\n}"
  },
  {
    "function_name": "TestSinkModule",
    "container": "TestSinkModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "90-94",
    "snippet": "TestSinkModule() :\n\t\tm_startFrame(0),\n\t\tm_expectedRequestLength(0)\n\t{\n\t}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSinkModule {\n  TestSinkModule() :\n  \t\tm_startFrame(0),\n  \t\tm_expectedRequestLength(0)\n  \t{\n  \t}\n}"
  },
  {
    "function_name": "runPull",
    "container": "TestSourceModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "71-79",
    "snippet": "void runPull()\n\t{\n\t\tEXPECT_EQ(m_outChunk->frameCount, m_expectedRequestLength);\n\t\tunsigned frameCount = std::min<unsigned>(m_outChunk->frameCount, m_frameCount);\n\t\tm_outChunk->frameCount = frameCount;\n\t\tsetChunkData(*m_outChunk, m_startFrame);\n\t\tm_startFrame += frameCount;\n\t\tm_frameCount -= frameCount;\n\t}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setChunkData",
          "args": [
            "*m_outChunk",
            "m_startFrame"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "setChunkData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
          "lines": "33-40",
          "snippet": "static void setChunkData(Chunk &chunk, int frameOffset)\n{\n\tint16_t *data = static_cast<int16_t *>(chunk.buffer);\n\tint channels = chunk.f.channelCount;\n\tfor (unsigned i=0; i<chunk.frameCount; i++)\n\t\tfor (int c=0; c<channels; c++)\n\t\t\tdata[i*channels + c] = (frameOffset + i) * channels + c;\n}",
          "includes": [
            "#include \"RebufferModule.h\"",
            "#include \"byteorder.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <gtest/gtest.h>",
            "#include <audiofile.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic void setChunkData(Chunk &chunk, int frameOffset)\n{\n\tint16_t *data = static_cast<int16_t *>(chunk.buffer);\n\tint channels = chunk.f.channelCount;\n\tfor (unsigned i=0; i<chunk.frameCount; i++)\n\t\tfor (int c=0; c<channels; c++)\n\t\t\tdata[i*channels + c] = (frameOffset + i) * channels + c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::min<unsigned>",
          "args": [
            "m_outChunk->frameCount",
            "m_frameCount"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "m_outChunk->frameCount",
            "m_expectedRequestLength"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSourceModule {\n  void runPull()\n  \t{\n  \t\tEXPECT_EQ(m_outChunk->frameCount, m_expectedRequestLength);\n  \t\tunsigned frameCount = std::min<unsigned>(m_outChunk->frameCount, m_frameCount);\n  \t\tm_outChunk->frameCount = frameCount;\n  \t\tsetChunkData(*m_outChunk, m_startFrame);\n  \t\tm_startFrame += frameCount;\n  \t\tm_frameCount -= frameCount;\n  \t}\n}"
  },
  {
    "function_name": "setExpectedRequestLength",
    "container": "TestSourceModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "66-69",
    "snippet": "void setExpectedRequestLength(unsigned expectedRequestLength)\n\t{\n\t\tm_expectedRequestLength = expectedRequestLength;\n\t}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSourceModule {\n  void setExpectedRequestLength(unsigned expectedRequestLength)\n  \t{\n  \t\tm_expectedRequestLength = expectedRequestLength;\n  \t}\n}"
  },
  {
    "function_name": "expectedRequestLength",
    "container": "TestSourceModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "65-65",
    "snippet": "unsigned expectedRequestLength() const { return m_expectedRequestLength; }",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSourceModule {\n  unsigned expectedRequestLength() const { return m_expectedRequestLength; }\n}"
  },
  {
    "function_name": "setFrameCount",
    "container": "TestSourceModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "64-64",
    "snippet": "void setFrameCount(unsigned frameCount) { m_frameCount = frameCount; }",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSourceModule {\n  void setFrameCount(unsigned frameCount) { m_frameCount = frameCount; }\n}"
  },
  {
    "function_name": "frameCount",
    "container": "TestSourceModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "63-63",
    "snippet": "unsigned frameCount() const { return m_frameCount; }",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSourceModule {\n  unsigned frameCount() const { return m_frameCount; }\n}"
  },
  {
    "function_name": "setStartFrame",
    "container": "TestSourceModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "62-62",
    "snippet": "void setStartFrame(unsigned startFrame) { m_startFrame = startFrame; }",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSourceModule {\n  void setStartFrame(unsigned startFrame) { m_startFrame = startFrame; }\n}"
  },
  {
    "function_name": "startFrame",
    "container": "TestSourceModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "61-61",
    "snippet": "unsigned startFrame() const { return m_startFrame; }",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSourceModule {\n  unsigned startFrame() const { return m_startFrame; }\n}"
  },
  {
    "function_name": "TestSourceModule",
    "container": "TestSourceModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "55-60",
    "snippet": "TestSourceModule() :\n\t\tm_startFrame(0),\n\t\tm_frameCount(0),\n\t\tm_expectedRequestLength(0)\n\t{\n\t}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nTestSourceModule {\n  TestSourceModule() :\n  \t\tm_startFrame(0),\n  \t\tm_frameCount(0),\n  \t\tm_expectedRequestLength(0)\n  \t{\n  \t}\n}"
  },
  {
    "function_name": "validateChunkData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "42-50",
    "snippet": "static void validateChunkData(const Chunk &chunk, int frameOffset)\n{\n\tconst int16_t *data = static_cast<const int16_t *>(chunk.buffer);\n\tint channels = chunk.f.channelCount;\n\tfor (unsigned i=0; i < chunk.frameCount; i++)\n\t\tfor (int c=0; c < channels; c++)\n\t\t\tEXPECT_EQ(data[i * channels + c],\n\t\t\t\tint(frameOffset + i) * channels + c);\n}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "data[i * channels + c]",
            "int(frameOffset + i) * channels + c"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "frameOffset + i"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "_af_print_filehandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/debug.cpp",
          "lines": "187-213",
          "snippet": "void _af_print_filehandle (AFfilehandle filehandle)\n{\n\tprintf(\"file handle: 0x%p\\n\", filehandle);\n\n\tif (filehandle->m_valid == _AF_VALID_FILEHANDLE)\n\t\tprintf(\"valid\\n\");\n\telse\n\t\tprintf(\"invalid!\\n\");\n\n\tprintf(\" access: \");\n\tif (filehandle->m_access == _AF_READ_ACCESS)\n\t\tputchar('r');\n\telse\n\t\tputchar('w');\n\n\tprintf(\" fileFormat: %d\\n\", filehandle->m_fileFormat);\n\n\tprintf(\" instrument count: %d\\n\", filehandle->m_instrumentCount);\n\tprintf(\" instruments: 0x%p\\n\", filehandle->m_instruments);\n\n\tprintf(\" miscellaneous count: %d\\n\", filehandle->m_miscellaneousCount);\n\tprintf(\" miscellaneous: 0x%p\\n\", filehandle->m_miscellaneous);\n\n\tprintf(\" trackCount: %d\\n\", filehandle->m_trackCount);\n\tprintf(\" tracks: 0x%p\\n\", filehandle->m_tracks);\n\t_af_print_tracks(filehandle);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"debug.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <math.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"debug.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nvoid _af_print_filehandle (AFfilehandle filehandle)\n{\n\tprintf(\"file handle: 0x%p\\n\", filehandle);\n\n\tif (filehandle->m_valid == _AF_VALID_FILEHANDLE)\n\t\tprintf(\"valid\\n\");\n\telse\n\t\tprintf(\"invalid!\\n\");\n\n\tprintf(\" access: \");\n\tif (filehandle->m_access == _AF_READ_ACCESS)\n\t\tputchar('r');\n\telse\n\t\tputchar('w');\n\n\tprintf(\" fileFormat: %d\\n\", filehandle->m_fileFormat);\n\n\tprintf(\" instrument count: %d\\n\", filehandle->m_instrumentCount);\n\tprintf(\" instruments: 0x%p\\n\", filehandle->m_instruments);\n\n\tprintf(\" miscellaneous count: %d\\n\", filehandle->m_miscellaneousCount);\n\tprintf(\" miscellaneous: 0x%p\\n\", filehandle->m_miscellaneous);\n\n\tprintf(\" trackCount: %d\\n\", filehandle->m_trackCount);\n\tprintf(\" tracks: 0x%p\\n\", filehandle->m_tracks);\n\t_af_print_tracks(filehandle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<const int16_t *>",
          "args": [
            "chunk.buffer"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic void validateChunkData(const Chunk &chunk, int frameOffset)\n{\n\tconst int16_t *data = static_cast<const int16_t *>(chunk.buffer);\n\tint channels = chunk.f.channelCount;\n\tfor (unsigned i=0; i < chunk.frameCount; i++)\n\t\tfor (int c=0; c < channels; c++)\n\t\t\tEXPECT_EQ(data[i * channels + c],\n\t\t\t\tint(frameOffset + i) * channels + c);\n}"
  },
  {
    "function_name": "setChunkData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/UT_RebufferModule.cpp",
    "lines": "33-40",
    "snippet": "static void setChunkData(Chunk &chunk, int frameOffset)\n{\n\tint16_t *data = static_cast<int16_t *>(chunk.buffer);\n\tint channels = chunk.f.channelCount;\n\tfor (unsigned i=0; i<chunk.frameCount; i++)\n\t\tfor (int c=0; c<channels; c++)\n\t\t\tdata[i*channels + c] = (frameOffset + i) * channels + c;\n}",
    "includes": [
      "#include \"RebufferModule.h\"",
      "#include \"byteorder.h\"",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <limits>",
      "#include <gtest/gtest.h>",
      "#include <audiofile.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<int16_t *>",
          "args": [
            "chunk.buffer"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"RebufferModule.h\"\n#include \"byteorder.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits>\n#include <gtest/gtest.h>\n#include <audiofile.h>\n#include \"config.h\"\n\nstatic void setChunkData(Chunk &chunk, int frameOffset)\n{\n\tint16_t *data = static_cast<int16_t *>(chunk.buffer);\n\tint channels = chunk.f.channelCount;\n\tfor (unsigned i=0; i<chunk.frameCount; i++)\n\t\tfor (int c=0; c<channels; c++)\n\t\t\tdata[i*channels + c] = (frameOffset + i) * channels + c;\n}"
  }
]