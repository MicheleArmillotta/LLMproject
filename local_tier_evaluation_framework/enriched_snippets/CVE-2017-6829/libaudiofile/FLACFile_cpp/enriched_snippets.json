[
  {
    "function_name": "update",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "298-301",
    "snippet": "status FLACFile::update()\n{\n\treturn AF_FAIL;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  status FLACFile::update()\n  {\n  \treturn AF_FAIL;\n  }\n}"
  },
  {
    "function_name": "writeInit",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "293-296",
    "snippet": "status FLACFile::writeInit(AFfilesetup)\n{\n\treturn AF_FAIL;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  status FLACFile::writeInit(AFfilesetup)\n  {\n  \treturn AF_FAIL;\n  }\n}"
  },
  {
    "function_name": "readInit",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "287-291",
    "snippet": "status FLACFile::readInit(AFfilesetup)\n{\n\t_af_error(AF_BAD_FILEFMT, \"FLAC is disabled\");\n\treturn AF_FAIL;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_FILEFMT",
            "\"FLAC is disabled\""
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  status FLACFile::readInit(AFfilesetup)\n  {\n  \t_af_error(AF_BAD_FILEFMT, \"FLAC is disabled\");\n  \treturn AF_FAIL;\n  }\n}"
  },
  {
    "function_name": "completeSetup",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "281-285",
    "snippet": "AFfilesetup FLACFile::completeSetup(AFfilesetup)\n{\n\t_af_error(AF_BAD_FILEFMT, \"FLAC is disabled\");\n\treturn AF_NULL_FILESETUP;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_FILEFMT",
            "\"FLAC is disabled\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  AFfilesetup FLACFile::completeSetup(AFfilesetup)\n  {\n  \t_af_error(AF_BAD_FILEFMT, \"FLAC is disabled\");\n  \treturn AF_NULL_FILESETUP;\n  }\n}"
  },
  {
    "function_name": "errorCallback",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "274-277",
    "snippet": "void FLACFile::errorCallback(const FLAC__StreamDecoder *, FLAC__StreamDecoderErrorStatus status, void *clientData)\n{\n\t_af_error(AF_BAD_FILEFMT, \"error %d parsing FLAC file\", status);\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_FILEFMT",
            "\"error %d parsing FLAC file\"",
            "status"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  void FLACFile::errorCallback(const FLAC__StreamDecoder *, FLAC__StreamDecoderErrorStatus status, void *clientData)\n  {\n  \t_af_error(AF_BAD_FILEFMT, \"error %d parsing FLAC file\", status);\n  }\n}"
  },
  {
    "function_name": "metadataCallback",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "267-272",
    "snippet": "void FLACFile::metadataCallback(const FLAC__StreamDecoder *, const FLAC__StreamMetadata *metadata, void *clientData)\n{\n\tFLACFile *flac = static_cast<FLACFile *>(clientData);\n\tif (metadata->type == FLAC__METADATA_TYPE_STREAMINFO)\n\t\tflac->parseStreamInfo(metadata->data.stream_info);\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flac->parseStreamInfo",
          "args": [
            "metadata->data.stream_info"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "parseStreamInfo",
          "container": "FLACFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
          "lines": "194-212",
          "snippet": "void FLACFile::parseStreamInfo(const FLAC__StreamMetadata_StreamInfo &streamInfo)\n{\n\tTrack *track = allocateTrack();\n\n\ttrack->f.channelCount = streamInfo.channels;\n\ttrack->f.sampleRate = streamInfo.sample_rate;\n\n\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\ttrack->f.framesPerPacket = 0;\n\ttrack->f.bytesPerPacket = 0;\n\n\ttrack->f.compressionType = AF_COMPRESSION_FLAC;\n\ttrack->f.compressionParams = NULL;\n\n\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, streamInfo.bits_per_sample);\n\n\ttrack->totalfframes = streamInfo.total_samples;\n}",
          "includes": [
            "#include <string.h>",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"File.h\"",
            "#include \"FLACFile.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  void FLACFile::parseStreamInfo(const FLAC__StreamMetadata_StreamInfo &streamInfo)\n  {\n  \tTrack *track = allocateTrack();\n  \n  \ttrack->f.channelCount = streamInfo.channels;\n  \ttrack->f.sampleRate = streamInfo.sample_rate;\n  \n  \ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \n  \ttrack->f.framesPerPacket = 0;\n  \ttrack->f.bytesPerPacket = 0;\n  \n  \ttrack->f.compressionType = AF_COMPRESSION_FLAC;\n  \ttrack->f.compressionParams = NULL;\n  \n  \t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, streamInfo.bits_per_sample);\n  \n  \ttrack->totalfframes = streamInfo.total_samples;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<FLACFile *>",
          "args": [
            "clientData"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  void FLACFile::metadataCallback(const FLAC__StreamDecoder *, const FLAC__StreamMetadata *metadata, void *clientData)\n  {\n  \tFLACFile *flac = static_cast<FLACFile *>(clientData);\n  \tif (metadata->type == FLAC__METADATA_TYPE_STREAMINFO)\n  \t\tflac->parseStreamInfo(metadata->data.stream_info);\n  }\n}"
  },
  {
    "function_name": "writeCallback",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "262-265",
    "snippet": "FLAC__StreamDecoderWriteStatus FLACFile::writeCallback(const FLAC__StreamDecoder *, const FLAC__Frame *frame, const FLAC__int32 * const buffer[], void *clientData)\n{\n\treturn FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  FLAC__StreamDecoderWriteStatus FLACFile::writeCallback(const FLAC__StreamDecoder *, const FLAC__Frame *frame, const FLAC__int32 * const buffer[], void *clientData)\n  {\n  \treturn FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;\n  }\n}"
  },
  {
    "function_name": "eofCallback",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "256-260",
    "snippet": "FLAC__bool FLACFile::eofCallback(const FLAC__StreamDecoder *, void *clientData)\n{\n\tFLACFile *flac = static_cast<FLACFile *>(clientData);\n\treturn flac->m_fh->tell() == flac->m_fh->length();\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flac->m_fh->length",
          "args": [],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "182-185",
          "snippet": "off_t FileVF::length()\n{\n\treturn m_vf->length(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::length()\n  {\n  \treturn m_vf->length(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "flac->m_fh->tell",
          "args": [],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<FLACFile *>",
          "args": [
            "clientData"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  FLAC__bool FLACFile::eofCallback(const FLAC__StreamDecoder *, void *clientData)\n  {\n  \tFLACFile *flac = static_cast<FLACFile *>(clientData);\n  \treturn flac->m_fh->tell() == flac->m_fh->length();\n  }\n}"
  },
  {
    "function_name": "lengthCallback",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "246-254",
    "snippet": "FLAC__StreamDecoderLengthStatus FLACFile::lengthCallback(const FLAC__StreamDecoder *, FLAC__uint64 *length, void *clientData)\n{\n\tFLACFile *flac = static_cast<FLACFile *>(clientData);\n\toff_t result = flac->m_fh->length();\n\tif (result < 0)\n\t\treturn FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR;\n\t*length = result;\n\treturn FLAC__STREAM_DECODER_LENGTH_STATUS_OK;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flac->m_fh->length",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "182-185",
          "snippet": "off_t FileVF::length()\n{\n\treturn m_vf->length(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::length()\n  {\n  \treturn m_vf->length(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<FLACFile *>",
          "args": [
            "clientData"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  FLAC__StreamDecoderLengthStatus FLACFile::lengthCallback(const FLAC__StreamDecoder *, FLAC__uint64 *length, void *clientData)\n  {\n  \tFLACFile *flac = static_cast<FLACFile *>(clientData);\n  \toff_t result = flac->m_fh->length();\n  \tif (result < 0)\n  \t\treturn FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR;\n  \t*length = result;\n  \treturn FLAC__STREAM_DECODER_LENGTH_STATUS_OK;\n  }\n}"
  },
  {
    "function_name": "tellCallback",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "236-244",
    "snippet": "FLAC__StreamDecoderTellStatus FLACFile::tellCallback(const FLAC__StreamDecoder *, FLAC__uint64 *absoluteByteOffset, void *clientData)\n{\n\tFLACFile *flac = static_cast<FLACFile *>(clientData);\n\toff_t result = flac->m_fh->tell();\n\tif (result < 0)\n\t\treturn FLAC__STREAM_DECODER_TELL_STATUS_ERROR;\n\t*absoluteByteOffset = static_cast<FLAC__uint64>(result);\n\treturn FLAC__STREAM_DECODER_TELL_STATUS_OK;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<FLAC__uint64>",
          "args": [
            "result"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flac->m_fh->tell",
          "args": [],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<FLACFile *>",
          "args": [
            "clientData"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  FLAC__StreamDecoderTellStatus FLACFile::tellCallback(const FLAC__StreamDecoder *, FLAC__uint64 *absoluteByteOffset, void *clientData)\n  {\n  \tFLACFile *flac = static_cast<FLACFile *>(clientData);\n  \toff_t result = flac->m_fh->tell();\n  \tif (result < 0)\n  \t\treturn FLAC__STREAM_DECODER_TELL_STATUS_ERROR;\n  \t*absoluteByteOffset = static_cast<FLAC__uint64>(result);\n  \treturn FLAC__STREAM_DECODER_TELL_STATUS_OK;\n  }\n}"
  },
  {
    "function_name": "seekCallback",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "228-234",
    "snippet": "FLAC__StreamDecoderSeekStatus FLACFile::seekCallback(const FLAC__StreamDecoder *, FLAC__uint64 absoluteByteOffset, void *clientData)\n{\n\tFLACFile *flac = static_cast<FLACFile *>(clientData);\n\tif (flac->m_fh->seek(static_cast<off_t>(absoluteByteOffset), File::SeekFromBeginning) < 0)\n\t\treturn FLAC__STREAM_DECODER_SEEK_STATUS_ERROR;\n\treturn FLAC__STREAM_DECODER_SEEK_STATUS_OK;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flac->m_fh->seek",
          "args": [
            "static_cast<off_t>(absoluteByteOffset)",
            "File::SeekFromBeginning"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<off_t>",
          "args": [
            "absoluteByteOffset"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<FLACFile *>",
          "args": [
            "clientData"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  FLAC__StreamDecoderSeekStatus FLACFile::seekCallback(const FLAC__StreamDecoder *, FLAC__uint64 absoluteByteOffset, void *clientData)\n  {\n  \tFLACFile *flac = static_cast<FLACFile *>(clientData);\n  \tif (flac->m_fh->seek(static_cast<off_t>(absoluteByteOffset), File::SeekFromBeginning) < 0)\n  \t\treturn FLAC__STREAM_DECODER_SEEK_STATUS_ERROR;\n  \treturn FLAC__STREAM_DECODER_SEEK_STATUS_OK;\n  }\n}"
  },
  {
    "function_name": "readCallback",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "214-226",
    "snippet": "FLAC__StreamDecoderReadStatus FLACFile::readCallback(const FLAC__StreamDecoder *, FLAC__byte buffer[], size_t *bytes, void *clientData)\n{\n\tFLACFile *flac = static_cast<FLACFile *>(clientData);\n\tssize_t result = flac->m_fh->read(buffer, *bytes);\n\tif (result > 0)\n\t{\n\t\t*bytes = result;\n\t\treturn FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;\n\t}\n\n\t*bytes = 0;\n\treturn FLAC__STREAM_DECODER_READ_STATUS_ABORT;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flac->m_fh->read",
          "args": [
            "buffer",
            "*bytes"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<FLACFile *>",
          "args": [
            "clientData"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  FLAC__StreamDecoderReadStatus FLACFile::readCallback(const FLAC__StreamDecoder *, FLAC__byte buffer[], size_t *bytes, void *clientData)\n  {\n  \tFLACFile *flac = static_cast<FLACFile *>(clientData);\n  \tssize_t result = flac->m_fh->read(buffer, *bytes);\n  \tif (result > 0)\n  \t{\n  \t\t*bytes = result;\n  \t\treturn FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;\n  \t}\n  \n  \t*bytes = 0;\n  \treturn FLAC__STREAM_DECODER_READ_STATUS_ABORT;\n  }\n}"
  },
  {
    "function_name": "parseStreamInfo",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "194-212",
    "snippet": "void FLACFile::parseStreamInfo(const FLAC__StreamMetadata_StreamInfo &streamInfo)\n{\n\tTrack *track = allocateTrack();\n\n\ttrack->f.channelCount = streamInfo.channels;\n\ttrack->f.sampleRate = streamInfo.sample_rate;\n\n\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\ttrack->f.framesPerPacket = 0;\n\ttrack->f.bytesPerPacket = 0;\n\n\ttrack->f.compressionType = AF_COMPRESSION_FLAC;\n\ttrack->f.compressionParams = NULL;\n\n\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, streamInfo.bits_per_sample);\n\n\ttrack->totalfframes = streamInfo.total_samples;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_set_sample_format",
          "args": [
            "&track->f",
            "AF_SAMPFMT_TWOSCOMP",
            "streamInfo.bits_per_sample"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "_af_set_sample_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "315-361",
          "snippet": "status _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatus _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocateTrack",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  void FLACFile::parseStreamInfo(const FLAC__StreamMetadata_StreamInfo &streamInfo)\n  {\n  \tTrack *track = allocateTrack();\n  \n  \ttrack->f.channelCount = streamInfo.channels;\n  \ttrack->f.sampleRate = streamInfo.sample_rate;\n  \n  \ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \n  \ttrack->f.framesPerPacket = 0;\n  \ttrack->f.bytesPerPacket = 0;\n  \n  \ttrack->f.compressionType = AF_COMPRESSION_FLAC;\n  \ttrack->f.compressionParams = NULL;\n  \n  \t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, streamInfo.bits_per_sample);\n  \n  \ttrack->totalfframes = streamInfo.total_samples;\n  }\n}"
  },
  {
    "function_name": "update",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "189-192",
    "snippet": "status FLACFile::update()\n{\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  status FLACFile::update()\n  {\n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeInit",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "181-187",
    "snippet": "status FLACFile::writeInit(AFfilesetup setup)\n{\n\tif (initFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "initFromSetup",
          "args": [
            "setup"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "initFromSetup",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "222-231",
          "snippet": "status _AFfilehandle::initFromSetup(AFfilesetup setup)\n{\n\tif (copyTracksFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\tif (copyInstrumentsFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\tif (copyMiscellaneousFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  status _AFfilehandle::initFromSetup(AFfilesetup setup)\n  {\n  \tif (copyTracksFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \tif (copyInstrumentsFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \tif (copyMiscellaneousFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \treturn AF_SUCCEED;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  status FLACFile::writeInit(AFfilesetup setup)\n  {\n  \tif (initFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "readInit",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "139-179",
    "snippet": "status FLACFile::readInit(AFfilesetup)\n{\n\tm_fh->seek(0, File::SeekFromBeginning);\n\n\tFLAC__StreamDecoder *decoder = FLAC__stream_decoder_new();\n\n\tif (FLAC__stream_decoder_init_stream(decoder,\n\t\treadCallback,\n\t\tseekCallback,\n\t\ttellCallback,\n\t\tlengthCallback,\n\t\teofCallback,\n\t\twriteCallback,\n\t\tmetadataCallback,\n\t\terrorCallback,\n\t\tthis) != FLAC__STREAM_DECODER_INIT_STATUS_OK)\n\t{\n\t\t_af_error(AF_BAD_HEADER, \"could not read FLAC file\");\n\t\treturn AF_FAIL;\n\t}\n\n\tif (!FLAC__stream_decoder_process_until_end_of_metadata(decoder))\n\t\treturn AF_FAIL;\n\n\tFLAC__uint64 position;\n\tif (!FLAC__stream_decoder_get_decode_position(decoder, &position))\n\t\treturn AF_FAIL;\n\n\tTrack *track = getTrack();\n\tif (track)\n\t{\n\t\ttrack->fpos_first_frame = static_cast<off_t>(position);\n\t\ttrack->data_size = m_fh->length() - track->fpos_first_frame;\n\t}\n\n\tFLAC__stream_decoder_delete(decoder);\n\n\tif (!track)\n\t\treturn AF_FAIL;\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FLAC__stream_decoder_delete",
          "args": [
            "decoder"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fh->length",
          "args": [],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "182-185",
          "snippet": "off_t FileVF::length()\n{\n\treturn m_vf->length(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::length()\n  {\n  \treturn m_vf->length(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<off_t>",
          "args": [
            "position"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLAC__stream_decoder_get_decode_position",
          "args": [
            "decoder",
            "&position"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLAC__stream_decoder_process_until_end_of_metadata",
          "args": [
            "decoder"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_HEADER",
            "\"could not read FLAC file\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLAC__stream_decoder_init_stream",
          "args": [
            "decoder",
            "readCallback",
            "seekCallback",
            "tellCallback",
            "lengthCallback",
            "eofCallback",
            "writeCallback",
            "metadataCallback",
            "errorCallback",
            "this"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLAC__stream_decoder_new",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "0",
            "File::SeekFromBeginning"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  status FLACFile::readInit(AFfilesetup)\n  {\n  \tm_fh->seek(0, File::SeekFromBeginning);\n  \n  \tFLAC__StreamDecoder *decoder = FLAC__stream_decoder_new();\n  \n  \tif (FLAC__stream_decoder_init_stream(decoder,\n  \t\treadCallback,\n  \t\tseekCallback,\n  \t\ttellCallback,\n  \t\tlengthCallback,\n  \t\teofCallback,\n  \t\twriteCallback,\n  \t\tmetadataCallback,\n  \t\terrorCallback,\n  \t\tthis) != FLAC__STREAM_DECODER_INIT_STATUS_OK)\n  \t{\n  \t\t_af_error(AF_BAD_HEADER, \"could not read FLAC file\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \tif (!FLAC__stream_decoder_process_until_end_of_metadata(decoder))\n  \t\treturn AF_FAIL;\n  \n  \tFLAC__uint64 position;\n  \tif (!FLAC__stream_decoder_get_decode_position(decoder, &position))\n  \t\treturn AF_FAIL;\n  \n  \tTrack *track = getTrack();\n  \tif (track)\n  \t{\n  \t\ttrack->fpos_first_frame = static_cast<off_t>(position);\n  \t\ttrack->data_size = m_fh->length() - track->fpos_first_frame;\n  \t}\n  \n  \tFLAC__stream_decoder_delete(decoder);\n  \n  \tif (!track)\n  \t\treturn AF_FAIL;\n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "completeSetup",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "71-137",
    "snippet": "AFfilesetup FLACFile::completeSetup(AFfilesetup setup)\n{\n\tif (setup->trackSet && setup->trackCount != 1)\n\t{\n\t\t_af_error(AF_BAD_NUMTRACKS, \"FLAC file must have 1 track\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tTrackSetup *track = setup->getTrack();\n\tif (!track)\n\t\treturn AF_NULL_FILESETUP;\n\n\tif (track->sampleFormatSet &&\n\t\ttrack->f.sampleFormat != AF_SAMPFMT_TWOSCOMP)\n\t{\n\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\"FLAC files support only signed integer audio data\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->sampleWidthSet &&\n\t\ttrack->f.sampleWidth != 16 && track->f.sampleWidth != 24)\n\t{\n\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\"FLAC files support only 16- or 24-bit audio data\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, track->f.sampleWidth);\n\n\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\tif (track->compressionSet &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_FLAC)\n\t{\n\t\t_af_error(AF_BAD_COMPTYPE, \"Only FLAC compression supported in FLAC files\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\ttrack->f.compressionType = AF_COMPRESSION_FLAC;\n\n\tif (track->markersSet && track->markerCount)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"FLAC does not yet support markers\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->aesDataSet)\n\t{\n\t\t_af_error(AF_BAD_FILESETUP, \"FLAC does not support AES data\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (setup->instrumentSet && setup->instrumentCount)\n\t{\n\t\t_af_error(AF_BAD_FILESETUP, \"FLAC does not support instruments\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (setup->miscellaneousSet && setup->miscellaneousCount)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"FLAC does not yet support miscellaneous data\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\treturn _af_filesetup_copy(setup, &flacDefaultFileSetup, true);\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const _AFfilesetup flacDefaultFileSetup =\n{\n\t_AF_VALID_FILESETUP,\n\tAF_FILE_FLAC,\n\ttrue,\n\ttrue,\n\ttrue,\n\t1,\t\t// trackCount\n\tNULL,\t// tracks\n\t0,\t\t// instrumentCount\n\tNULL,\t// instruments\n\t0,\t\t// miscellaneousCount\n\tNULL\t// miscellaneous\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_filesetup_copy",
          "args": [
            "setup",
            "&flacDefaultFileSetup",
            "true"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "_af_filesetup_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Setup.cpp",
          "lines": "440-525",
          "snippet": "AFfilesetup _af_filesetup_copy (const _AFfilesetup *setup,\n\tconst _AFfilesetup *defaultSetup, bool copyMarks)\n{\n\tAFfilesetup newsetup;\n\tint instrumentCount, miscellaneousCount, trackCount;\n\n\tnewsetup = (_AFfilesetup *) _af_malloc(sizeof (_AFfilesetup));\n\tif (newsetup == AF_NULL_FILESETUP)\n\t\treturn AF_NULL_FILESETUP;\n\n\t*newsetup = *defaultSetup;\n\n\tnewsetup->tracks = NULL;\n\tnewsetup->instruments = NULL;\n\tnewsetup->miscellaneous = NULL;\n\n\t/* Copy tracks. */\n\ttrackCount = setup->trackSet ? setup->trackCount :\n\t\tnewsetup->trackSet ? newsetup->trackCount : 0;\n\talloccopy(TrackSetup, trackCount, newsetup->tracks, setup->tracks);\n\tnewsetup->trackCount = trackCount;\n\n\t/* Copy instruments. */\n\tinstrumentCount = setup->instrumentSet ? setup->instrumentCount :\n\t\tnewsetup->instrumentSet ? newsetup->instrumentCount : 0;\n\talloccopy(InstrumentSetup, instrumentCount, newsetup->instruments, setup->instruments);\n\tnewsetup->instrumentCount = instrumentCount;\n\n\t/* Copy miscellaneous information. */\n\tmiscellaneousCount = setup->miscellaneousSet ? setup->miscellaneousCount :\n\t\tnewsetup->miscellaneousSet ? newsetup->miscellaneousCount : 0;\n\talloccopy(MiscellaneousSetup, miscellaneousCount, newsetup->miscellaneous, setup->miscellaneous);\n\tnewsetup->miscellaneousCount = miscellaneousCount;\n\n\tfor (int i=0; i<setup->trackCount; i++)\n\t{\n\t\tTrackSetup\t*track = &newsetup->tracks[i];\n\n\t\t/* XXXmpruett set compression information */\n\n\t\tif (!setup->tracks[i].markersSet && !copyMarks)\n\t\t{\n\t\t\ttrack->markers = NULL;\n\t\t\ttrack->markerCount = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\talloccopy(MarkerSetup, setup->tracks[i].markerCount,\n\t\t\ttrack->markers, setup->tracks[i].markers);\n\t\ttrack->markerCount = setup->tracks[i].markerCount;\n\n\t\tfor (int j=0; j<setup->tracks[i].markerCount; j++)\n\t\t{\n\t\t\ttrack->markers[j].name =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].name);\n\t\t\tif (track->markers[j].name == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\ttrack->markers[j].comment =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].comment);\n\t\t\tif (track->markers[j].comment == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (int i=0; i<newsetup->instrumentCount; i++)\n\t{\n\t\tInstrumentSetup\t*instrument = &newsetup->instruments[i];\n\t\talloccopy(LoopSetup, setup->instruments[i].loopCount,\n\t\t\tinstrument->loops, setup->instruments[i].loops);\n\t}\n\n\treturn newsetup;\n\n\tfail:\n\t\tif (newsetup->miscellaneous)\n\t\t\tfree(newsetup->miscellaneous);\n\t\tif (newsetup->instruments)\n\t\t\tfree(newsetup->instruments);\n\t\tif (newsetup->tracks)\n\t\t\tfree(newsetup->tracks);\n\t\tif (newsetup)\n\t\t\tfree(newsetup);\n\n\treturn AF_NULL_FILESETUP;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"audiofile.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"Setup.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"audiofile.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include <string.h>\n#include <stdlib.h>\n#include \"Setup.h\"\n#include \"config.h\"\n\nAFfilesetup _af_filesetup_copy (const _AFfilesetup *setup,\n\tconst _AFfilesetup *defaultSetup, bool copyMarks)\n{\n\tAFfilesetup newsetup;\n\tint instrumentCount, miscellaneousCount, trackCount;\n\n\tnewsetup = (_AFfilesetup *) _af_malloc(sizeof (_AFfilesetup));\n\tif (newsetup == AF_NULL_FILESETUP)\n\t\treturn AF_NULL_FILESETUP;\n\n\t*newsetup = *defaultSetup;\n\n\tnewsetup->tracks = NULL;\n\tnewsetup->instruments = NULL;\n\tnewsetup->miscellaneous = NULL;\n\n\t/* Copy tracks. */\n\ttrackCount = setup->trackSet ? setup->trackCount :\n\t\tnewsetup->trackSet ? newsetup->trackCount : 0;\n\talloccopy(TrackSetup, trackCount, newsetup->tracks, setup->tracks);\n\tnewsetup->trackCount = trackCount;\n\n\t/* Copy instruments. */\n\tinstrumentCount = setup->instrumentSet ? setup->instrumentCount :\n\t\tnewsetup->instrumentSet ? newsetup->instrumentCount : 0;\n\talloccopy(InstrumentSetup, instrumentCount, newsetup->instruments, setup->instruments);\n\tnewsetup->instrumentCount = instrumentCount;\n\n\t/* Copy miscellaneous information. */\n\tmiscellaneousCount = setup->miscellaneousSet ? setup->miscellaneousCount :\n\t\tnewsetup->miscellaneousSet ? newsetup->miscellaneousCount : 0;\n\talloccopy(MiscellaneousSetup, miscellaneousCount, newsetup->miscellaneous, setup->miscellaneous);\n\tnewsetup->miscellaneousCount = miscellaneousCount;\n\n\tfor (int i=0; i<setup->trackCount; i++)\n\t{\n\t\tTrackSetup\t*track = &newsetup->tracks[i];\n\n\t\t/* XXXmpruett set compression information */\n\n\t\tif (!setup->tracks[i].markersSet && !copyMarks)\n\t\t{\n\t\t\ttrack->markers = NULL;\n\t\t\ttrack->markerCount = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\talloccopy(MarkerSetup, setup->tracks[i].markerCount,\n\t\t\ttrack->markers, setup->tracks[i].markers);\n\t\ttrack->markerCount = setup->tracks[i].markerCount;\n\n\t\tfor (int j=0; j<setup->tracks[i].markerCount; j++)\n\t\t{\n\t\t\ttrack->markers[j].name =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].name);\n\t\t\tif (track->markers[j].name == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\ttrack->markers[j].comment =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].comment);\n\t\t\tif (track->markers[j].comment == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (int i=0; i<newsetup->instrumentCount; i++)\n\t{\n\t\tInstrumentSetup\t*instrument = &newsetup->instruments[i];\n\t\talloccopy(LoopSetup, setup->instruments[i].loopCount,\n\t\t\tinstrument->loops, setup->instruments[i].loops);\n\t}\n\n\treturn newsetup;\n\n\tfail:\n\t\tif (newsetup->miscellaneous)\n\t\t\tfree(newsetup->miscellaneous);\n\t\tif (newsetup->instruments)\n\t\t\tfree(newsetup->instruments);\n\t\tif (newsetup->tracks)\n\t\t\tfree(newsetup->tracks);\n\t\tif (newsetup)\n\t\t\tfree(newsetup);\n\n\treturn AF_NULL_FILESETUP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"FLAC does not yet support miscellaneous data\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_FILESETUP",
            "\"FLAC does not support instruments\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_FILESETUP",
            "\"FLAC does not support AES data\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"FLAC does not yet support markers\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_COMPTYPE",
            "\"Only FLAC compression supported in FLAC files\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_set_sample_format",
          "args": [
            "&track->f",
            "AF_SAMPFMT_TWOSCOMP",
            "track->f.sampleWidth"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "_af_set_sample_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "315-361",
          "snippet": "status _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatus _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_WIDTH",
            "\"FLAC files support only 16- or 24-bit audio data\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_SAMPFMT",
            "\"FLAC files support only signed integer audio data\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup->getTrack",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NUMTRACKS",
            "\"FLAC file must have 1 track\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nconst _AFfilesetup flacDefaultFileSetup =\n{\n\t_AF_VALID_FILESETUP,\n\tAF_FILE_FLAC,\n\ttrue,\n\ttrue,\n\ttrue,\n\t1,\t\t// trackCount\n\tNULL,\t// tracks\n\t0,\t\t// instrumentCount\n\tNULL,\t// instruments\n\t0,\t\t// miscellaneousCount\n\tNULL\t// miscellaneous\n};\n\nFLACFile {\n  AFfilesetup FLACFile::completeSetup(AFfilesetup setup)\n  {\n  \tif (setup->trackSet && setup->trackCount != 1)\n  \t{\n  \t\t_af_error(AF_BAD_NUMTRACKS, \"FLAC file must have 1 track\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tTrackSetup *track = setup->getTrack();\n  \tif (!track)\n  \t\treturn AF_NULL_FILESETUP;\n  \n  \tif (track->sampleFormatSet &&\n  \t\ttrack->f.sampleFormat != AF_SAMPFMT_TWOSCOMP)\n  \t{\n  \t\t_af_error(AF_BAD_SAMPFMT,\n  \t\t\t\"FLAC files support only signed integer audio data\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (track->sampleWidthSet &&\n  \t\ttrack->f.sampleWidth != 16 && track->f.sampleWidth != 24)\n  \t{\n  \t\t_af_error(AF_BAD_WIDTH,\n  \t\t\t\"FLAC files support only 16- or 24-bit audio data\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, track->f.sampleWidth);\n  \n  \ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \n  \tif (track->compressionSet &&\n  \t\ttrack->f.compressionType != AF_COMPRESSION_FLAC)\n  \t{\n  \t\t_af_error(AF_BAD_COMPTYPE, \"Only FLAC compression supported in FLAC files\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \ttrack->f.compressionType = AF_COMPRESSION_FLAC;\n  \n  \tif (track->markersSet && track->markerCount)\n  \t{\n  \t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"FLAC does not yet support markers\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (track->aesDataSet)\n  \t{\n  \t\t_af_error(AF_BAD_FILESETUP, \"FLAC does not support AES data\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (setup->instrumentSet && setup->instrumentCount)\n  \t{\n  \t\t_af_error(AF_BAD_FILESETUP, \"FLAC does not support instruments\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (setup->miscellaneousSet && setup->miscellaneousCount)\n  \t{\n  \t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"FLAC does not yet support miscellaneous data\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \treturn _af_filesetup_copy(setup, &flacDefaultFileSetup, true);\n  }\n}"
  },
  {
    "function_name": "~FLACFile",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "65-67",
    "snippet": "FLACFile::~FLACFile()\n{\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  FLACFile::~FLACFile()\n  {\n  }\n}"
  },
  {
    "function_name": "FLACFile",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "61-63",
    "snippet": "FLACFile::FLACFile()\n{\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  FLACFile::FLACFile()\n  {\n  }\n}"
  },
  {
    "function_name": "recognize",
    "container": "FLACFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FLACFile.cpp",
    "lines": "52-59",
    "snippet": "bool FLACFile::recognize(File *file)\n{\n\tfile->seek(0, File::SeekFromBeginning);\n\tuint8_t buffer[4];\n\tif (file->read(buffer, 4) != 4 || memcmp(buffer, \"fLaC\", 4) != 0)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"File.h\"",
      "#include \"FLACFile.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"fLaC\"",
            "4"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->read",
          "args": [
            "buffer",
            "4"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->seek",
          "args": [
            "0",
            "File::SeekFromBeginning"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"File.h\"\n#include \"FLACFile.h\"\n#include \"config.h\"\n\nFLACFile {\n  bool FLACFile::recognize(File *file)\n  {\n  \tfile->seek(0, File::SeekFromBeginning);\n  \tuint8_t buffer[4];\n  \tif (file->read(buffer, 4) != 4 || memcmp(buffer, \"fLaC\", 4) != 0)\n  \t\treturn false;\n  \treturn true;\n  }\n}"
  }
]