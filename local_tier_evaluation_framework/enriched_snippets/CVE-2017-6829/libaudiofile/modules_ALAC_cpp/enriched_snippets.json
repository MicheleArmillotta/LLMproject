[
  {
    "function_name": "_af_alac_format_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
    "lines": "337-371",
    "snippet": "bool _af_alac_format_ok (AudioFormat *f)\n{\n\tif (f->channelCount > kALACMaxChannels)\n\t{\n\t\t_af_error(AF_BAD_CHANNELS,\n\t\t\t\"ALAC compression supports a maximum of 8 channels\");\n\t\treturn false;\n\t}\n\n\tif (f->sampleFormat != AF_SAMPFMT_TWOSCOMP)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"ALAC compression requires signed integer audio data\");\n\t\treturn false;\n\t}\n\n\tif (f->sampleWidth != 16 &&\n\t\tf->sampleWidth != 20 &&\n\t\tf->sampleWidth != 24 &&\n\t\tf->sampleWidth != 32)\n\t{\n\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\"ALAC compression requires 16, 20, 24, or 32 bits per sample\");\n\t\treturn false;\n\t}\n\n\tif (f->byteOrder != _AF_BYTEORDER_NATIVE)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"ALAC compression requires native-endian format\");\n\t\tf->byteOrder = _AF_BYTEORDER_NATIVE;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"../alac/ALACEncoder.h\"",
      "#include \"../alac/ALACDecoder.h\"",
      "#include \"../alac/ALACBitUtilities.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"PacketTable.h\"",
      "#include \"FileModule.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"Buffer.h\"",
      "#include \"ALAC.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_COMPRESSION",
            "\"ALAC compression requires native-endian format\""
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_WIDTH",
            "\"ALAC compression requires 16, 20, 24, or 32 bits per sample\""
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_COMPRESSION",
            "\"ALAC compression requires signed integer audio data\""
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_CHANNELS",
            "\"ALAC compression supports a maximum of 8 channels\""
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nbool _af_alac_format_ok (AudioFormat *f)\n{\n\tif (f->channelCount > kALACMaxChannels)\n\t{\n\t\t_af_error(AF_BAD_CHANNELS,\n\t\t\t\"ALAC compression supports a maximum of 8 channels\");\n\t\treturn false;\n\t}\n\n\tif (f->sampleFormat != AF_SAMPFMT_TWOSCOMP)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"ALAC compression requires signed integer audio data\");\n\t\treturn false;\n\t}\n\n\tif (f->sampleWidth != 16 &&\n\t\tf->sampleWidth != 20 &&\n\t\tf->sampleWidth != 24 &&\n\t\tf->sampleWidth != 32)\n\t{\n\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\"ALAC compression requires 16, 20, 24, or 32 bits per sample\");\n\t\treturn false;\n\t}\n\n\tif (f->byteOrder != _AF_BYTEORDER_NATIVE)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"ALAC compression requires native-endian format\");\n\t\tf->byteOrder = _AF_BYTEORDER_NATIVE;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "sync2",
    "container": "ALAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
    "lines": "327-335",
    "snippet": "void ALAC::sync2()\n{\n\tassert(!canSeek() || (tell() == m_track->fpos_next_frame));\n\n\tm_track->fpos_after_data = tell();\n\n\tm_track->fpos_next_frame = m_savedPositionNextFrame;\n\tm_track->nextfframe = m_savedNextFrame;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"../alac/ALACEncoder.h\"",
      "#include \"../alac/ALACDecoder.h\"",
      "#include \"../alac/ALACBitUtilities.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"PacketTable.h\"",
      "#include \"FileModule.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"Buffer.h\"",
      "#include \"ALAC.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tell",
          "args": [],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "66-69",
          "snippet": "off_t FileModule::tell()\n{\n\treturn m_fh->tell();\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  off_t FileModule::tell()\n  {\n  \treturn m_fh->tell();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!canSeek() || (tell() == m_track->fpos_next_frame)"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "canSeek",
          "args": [],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "canSeek",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.h",
          "lines": "38-38",
          "snippet": "bool canSeek() const { return m_canSeek; }",
          "includes": [
            "#include \"Module.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Module.h\"\n\nFileModule {\n  bool canSeek() const { return m_canSeek; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  void ALAC::sync2()\n  {\n  \tassert(!canSeek() || (tell() == m_track->fpos_next_frame));\n  \n  \tm_track->fpos_after_data = tell();\n  \n  \tm_track->fpos_next_frame = m_savedPositionNextFrame;\n  \tm_track->nextfframe = m_savedNextFrame;\n  }\n}"
  },
  {
    "function_name": "sync1",
    "container": "ALAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
    "lines": "321-325",
    "snippet": "void ALAC::sync1()\n{\n\tm_savedPositionNextFrame = m_track->fpos_next_frame;\n\tm_savedNextFrame = m_track->nextfframe;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"../alac/ALACEncoder.h\"",
      "#include \"../alac/ALACDecoder.h\"",
      "#include \"../alac/ALACBitUtilities.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"PacketTable.h\"",
      "#include \"FileModule.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"Buffer.h\"",
      "#include \"ALAC.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  void ALAC::sync1()\n  {\n  \tm_savedPositionNextFrame = m_track->fpos_next_frame;\n  \tm_savedNextFrame = m_track->nextfframe;\n  }\n}"
  },
  {
    "function_name": "runPush",
    "container": "ALAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
    "lines": "279-319",
    "snippet": "void ALAC::runPush()\n{\n\tAudioFormatDescription inputFormat;\n\tinputFormat.mSampleRate = m_track->f.sampleRate;\n\tinputFormat.mFormatID = kALACFormatLinearPCM;\n\tinputFormat.mFormatFlags = kALACFormatFlagsNativeEndian;\n\tinputFormat.mBytesPerPacket = _af_format_frame_size_uncompressed(&m_track->f, false);\n\tinputFormat.mFramesPerPacket = 1;\n\tinputFormat.mBytesPerFrame = _af_format_frame_size_uncompressed(&m_track->f, false);\n\tinputFormat.mChannelsPerFrame = m_track->f.channelCount;\n\tinputFormat.mBitsPerChannel = m_track->f.sampleWidth;\n\tinputFormat.mReserved = 0;\n\n\tint32_t numBytes = m_inChunk->frameCount * inputFormat.mBytesPerFrame;\n\tint32_t result = m_encoder->Encode(inputFormat, outputFormat(),\n\t\tstatic_cast<uint8_t *>(m_inChunk->buffer),\n\t\tstatic_cast<uint8_t *>(m_outChunk->buffer),\n\t\t&numBytes);\n\tif (result)\n\t{\n\t\t_af_error(AF_BAD_CODEC_STATE, \"error encoding ALAC audio data\");\n\t\tm_track->filemodhappy = false;\n\t\treturn;\n\t}\n\n\tassert(numBytes <= bufferSize());\n\n\tssize_t bytesWritten = write(m_outChunk->buffer, numBytes);\n\tif (bytesWritten != numBytes)\n\t{\n\t\treportWriteError(0, m_track->f.framesPerPacket);\n\t\treturn;\n\t}\n\n\tPacketTable *packetTable = m_track->m_packetTable.get();\n\n\tpacketTable->append(numBytes);\n\n\tpacketTable->setNumValidFrames(packetTable->numValidFrames() +\n\t\tm_inChunk->frameCount);\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"../alac/ALACEncoder.h\"",
      "#include \"../alac/ALACDecoder.h\"",
      "#include \"../alac/ALACBitUtilities.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"PacketTable.h\"",
      "#include \"FileModule.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"Buffer.h\"",
      "#include \"ALAC.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "packetTable->setNumValidFrames",
          "args": [
            "packetTable->numValidFrames() +\n\t\tm_inChunk->frameCount"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "setNumValidFrames",
          "container": "PacketTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/PacketTable.cpp",
          "lines": "43-46",
          "snippet": "void PacketTable::setNumValidFrames(int64_t numValidFrames)\n{\n\tm_numValidFrames = numValidFrames;\n}",
          "includes": [
            "#include \"PacketTable.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"PacketTable.h\"\n#include \"config.h\"\n\nPacketTable {\n  void PacketTable::setNumValidFrames(int64_t numValidFrames)\n  {\n  \tm_numValidFrames = numValidFrames;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "packetTable->numValidFrames",
          "args": [],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "numValidFrames",
          "container": "PacketTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/PacketTable.h",
          "lines": "42-42",
          "snippet": "int64_t numValidFrames() const { return m_numValidFrames; }",
          "includes": [
            "#include <vector>",
            "#include <sys/types.h>",
            "#include <stdint.h>",
            "#include <audiofile.h>",
            "#include \"Shared.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <sys/types.h>\n#include <stdint.h>\n#include <audiofile.h>\n#include \"Shared.h\"\n\nPacketTable {\n  int64_t numValidFrames() const { return m_numValidFrames; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "packetTable->append",
          "args": [
            "numBytes"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "append",
          "container": "PacketTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/PacketTable.cpp",
          "lines": "58-61",
          "snippet": "void PacketTable::append(size_t bytesPerPacket)\n{\n\tm_bytesPerPacket.push_back(bytesPerPacket);\n}",
          "includes": [
            "#include \"PacketTable.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"PacketTable.h\"\n#include \"config.h\"\n\nPacketTable {\n  void PacketTable::append(size_t bytesPerPacket)\n  {\n  \tm_bytesPerPacket.push_back(bytesPerPacket);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_track->m_packetTable.get",
          "args": [],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reportWriteError",
          "args": [
            "0",
            "m_track->f.framesPerPacket"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "reportWriteError",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "90-117",
          "snippet": "void FileModule::reportWriteError(AFframecount framesWritten,\n\tAFframecount framesToWrite)\n{\n\t// Report error if we haven't already.\n\tif (!m_track->filemodhappy)\n\t\treturn;\n\n\tif (framesWritten < 0)\n\t{\n\t\t// Signal I/O error.\n\t\t_af_error(AF_BAD_WRITE,\n\t\t\t\"unable to write data (%s) -- wrote %jd out of %jd frames\",\n\t\t\tstrerror(errno),\n\t\t\tstatic_cast<intmax_t>(m_track->nextfframe),\n\t\t\tstatic_cast<intmax_t>(m_track->nextfframe + framesToWrite));\n\t}\n\telse\n\t{\n\t\t// Signal disk full error.\n\t\t_af_error(AF_BAD_WRITE,\n\t\t\t\"unable to write data (disk full) -- \"\n\t\t\t\"wrote %jd out of %jd frames\",\n\t\t\tstatic_cast<intmax_t>(m_track->nextfframe + framesWritten),\n\t\t\tstatic_cast<intmax_t>(m_track->nextfframe + framesToWrite));\n\t}\n\n\tm_track->filemodhappy = false;\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  void FileModule::reportWriteError(AFframecount framesWritten,\n  \tAFframecount framesToWrite)\n  {\n  \t// Report error if we haven't already.\n  \tif (!m_track->filemodhappy)\n  \t\treturn;\n  \n  \tif (framesWritten < 0)\n  \t{\n  \t\t// Signal I/O error.\n  \t\t_af_error(AF_BAD_WRITE,\n  \t\t\t\"unable to write data (%s) -- wrote %jd out of %jd frames\",\n  \t\t\tstrerror(errno),\n  \t\t\tstatic_cast<intmax_t>(m_track->nextfframe),\n  \t\t\tstatic_cast<intmax_t>(m_track->nextfframe + framesToWrite));\n  \t}\n  \telse\n  \t{\n  \t\t// Signal disk full error.\n  \t\t_af_error(AF_BAD_WRITE,\n  \t\t\t\"unable to write data (disk full) -- \"\n  \t\t\t\"wrote %jd out of %jd frames\",\n  \t\t\tstatic_cast<intmax_t>(m_track->nextfframe + framesWritten),\n  \t\t\tstatic_cast<intmax_t>(m_track->nextfframe + framesToWrite));\n  \t}\n  \n  \tm_track->filemodhappy = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "m_outChunk->buffer",
            "numBytes"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "50-59",
          "snippet": "ssize_t FileModule::write(const void *data, size_t nbytes)\n{\n\tssize_t bytesWritten = m_fh->write(data, nbytes);\n\tif (bytesWritten > 0)\n\t{\n\t\tm_track->fpos_next_frame += bytesWritten;\n\t\tm_track->data_size += bytesWritten;\n\t}\n\treturn bytesWritten;\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  ssize_t FileModule::write(const void *data, size_t nbytes)\n  {\n  \tssize_t bytesWritten = m_fh->write(data, nbytes);\n  \tif (bytesWritten > 0)\n  \t{\n  \t\tm_track->fpos_next_frame += bytesWritten;\n  \t\tm_track->data_size += bytesWritten;\n  \t}\n  \treturn bytesWritten;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "numBytes <= bufferSize()"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bufferSize",
          "args": [],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "bufferSize",
          "container": "ALAC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
          "lines": "273-277",
          "snippet": "int ALAC::bufferSize() const\n{\n\treturn m_track->f.framesPerPacket * m_track->f.channelCount *\n\t\t((10 + m_track->f.sampleWidth) / 8) + 1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"../alac/ALACEncoder.h\"",
            "#include \"../alac/ALACDecoder.h\"",
            "#include \"../alac/ALACBitUtilities.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"PacketTable.h\"",
            "#include \"FileModule.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"Buffer.h\"",
            "#include \"ALAC.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  int ALAC::bufferSize() const\n  {\n  \treturn m_track->f.framesPerPacket * m_track->f.channelCount *\n  \t\t((10 + m_track->f.sampleWidth) / 8) + 1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_CODEC_STATE",
            "\"error encoding ALAC audio data\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_encoder->Encode",
          "args": [
            "inputFormat",
            "outputFormat()",
            "static_cast<uint8_t *>(m_inChunk->buffer)",
            "static_cast<uint8_t *>(m_outChunk->buffer)",
            "&numBytes"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "ALACEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
          "lines": "1020-1158",
          "snippet": "int32_t ALACEncoder::Encode(AudioFormatDescription theInputFormat, AudioFormatDescription theOutputFormat,\n                             unsigned char * theReadBuffer, unsigned char * theWriteBuffer, int32_t * ioNumBytes)\n{\n\tuint32_t\t\t\t\tnumFrames;\n\tuint32_t\t\t\t\toutputSize;\n\tBitBuffer\t\t\tbitstream;\n\tint32_t\t\t\tstatus;\n\n\tnumFrames = *ioNumBytes/theInputFormat.mBytesPerPacket;\n\n\t// create a bit buffer structure pointing to our output buffer\n\tBitBufferInit( &bitstream, theWriteBuffer, mMaxOutputBytes );\n\n\tif ( theInputFormat.mChannelsPerFrame == 2 )\n\t{\n\t\t// add 3-bit frame start tag ID_CPE = channel pair & 4-bit element instance tag = 0\n\t\tBitBufferWrite( &bitstream, ID_CPE, 3 );\n\t\tBitBufferWrite( &bitstream, 0, 4 );\n\n\t\t// encode stereo input buffer\n\t\tif ( mFastMode == false )\n\t\t\tstatus = this->EncodeStereo( &bitstream, theReadBuffer, 2, 0, numFrames );\n\t\telse\n\t\t\tstatus = this->EncodeStereoFast( &bitstream, theReadBuffer, 2, 0, numFrames );\n\t\tRequireNoErr( status, goto Exit; );\n\t}\n\telse if ( theInputFormat.mChannelsPerFrame == 1 )\n\t{\n\t\t// add 3-bit frame start tag ID_SCE = mono channel & 4-bit element instance tag = 0\n\t\tBitBufferWrite( &bitstream, ID_SCE, 3 );\n\t\tBitBufferWrite( &bitstream, 0, 4 );\n\n\t\t// encode mono input buffer\n\t\tstatus = this->EncodeMono( &bitstream, theReadBuffer, 1, 0, numFrames );\n\t\tRequireNoErr( status, goto Exit; );\n\t}\n\telse\n\t{\n\t\tchar *\t\t\t\t\tinputBuffer;\n\t\tuint32_t\t\t\t\ttag;\n\t\tuint32_t\t\t\t\tchannelIndex;\n\t\tuint32_t\t\t\t\tinputIncrement;\n\t\tuint8_t\t\t\t\tstereoElementTag;\n\t\tuint8_t\t\t\t\tmonoElementTag;\n\t\tuint8_t\t\t\t\tlfeElementTag;\n\t\t\n\t\tinputBuffer\t\t= (char *) theReadBuffer;\n\t\tinputIncrement\t= ((mBitDepth + 7) / 8);\n\t\t\n\t\tstereoElementTag\t= 0;\n\t\tmonoElementTag\t\t= 0;\n\t\tlfeElementTag\t\t= 0;\n\n\t\tfor ( channelIndex = 0; channelIndex < theInputFormat.mChannelsPerFrame; )\n\t\t{\n\t\t\ttag = (sChannelMaps[theInputFormat.mChannelsPerFrame - 1] & (0x7ul << (channelIndex * 3))) >> (channelIndex * 3);\n\t\n\t\t\tBitBufferWrite( &bitstream, tag, 3 );\n\t\t\tswitch ( tag )\n\t\t\t{\n\t\t\t\tcase ID_SCE:\n\t\t\t\t\t// mono\n\t\t\t\t\tBitBufferWrite( &bitstream, monoElementTag, 4 );\n\n\t\t\t\t\tstatus = this->EncodeMono( &bitstream, inputBuffer, theInputFormat.mChannelsPerFrame, channelIndex, numFrames );\n\t\t\t\t\t\n\t\t\t\t\tinputBuffer += inputIncrement;\n\t\t\t\t\tchannelIndex++;\n\t\t\t\t\tmonoElementTag++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ID_CPE:\n\t\t\t\t\t// stereo\n\t\t\t\t\tBitBufferWrite( &bitstream, stereoElementTag, 4 );\n\n\t\t\t\t\tstatus = this->EncodeStereo( &bitstream, inputBuffer, theInputFormat.mChannelsPerFrame, channelIndex, numFrames );\n\n\t\t\t\t\tinputBuffer += (inputIncrement * 2);\n\t\t\t\t\tchannelIndex += 2;\n\t\t\t\t\tstereoElementTag++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ID_LFE:\n\t\t\t\t\t// LFE channel (subwoofer)\n\t\t\t\t\tBitBufferWrite( &bitstream, lfeElementTag, 4 );\n\n\t\t\t\t\tstatus = this->EncodeMono( &bitstream, inputBuffer, theInputFormat.mChannelsPerFrame, channelIndex, numFrames );\n\n\t\t\t\t\tinputBuffer += inputIncrement;\n\t\t\t\t\tchannelIndex++;\n\t\t\t\t\tlfeElementTag++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tstatus = kALAC_ParamError;\n\t\t\t\t\tgoto Exit;\n\t\t\t}\n\n\t\t\tRequireNoErr( status, goto Exit; );\n\t\t}\n\t}\n\n#if VERBOSE_DEBUG\n{\n\t// if there is room left in the output buffer, add some random fill data to test decoder\n\tint32_t\t\t\tbitsLeft;\n\tint32_t\t\t\tbytesLeft;\n\t\n\tbitsLeft = BitBufferGetPosition( &bitstream ) - 3;\t// - 3 for ID_END tag\n\tbytesLeft = bitstream.byteSize - ((bitsLeft + 7) / 8);\n\t\n\tif ( (bytesLeft > 20) && ((bytesLeft & 0x4u) != 0) )\n\t\tAddFiller( &bitstream, bytesLeft );\n}\n#endif\n\n\t// add 3-bit frame end tag: ID_END\n\tBitBufferWrite( &bitstream, ID_END, 3 );\n\n\t// byte-align the output data\n\tBitBufferByteAlign( &bitstream, true );\n\n\toutputSize = BitBufferGetPosition( &bitstream ) / 8;\n\t//Assert( outputSize <= mMaxOutputBytes );\n\n\n\t// all good, let iTunes know what happened and remember the total number of input sample frames\n\t*ioNumBytes = outputSize;\n\t//mEncodedFrames\t\t   \t   += encodeMsg->numInputSamples;\n\n\t// gather encoding stats\n\tmTotalBytesGenerated += outputSize;\n\tmMaxFrameBytes = MAX( mMaxFrameBytes, outputSize );\n\n\tstatus = ALAC_noErr;\n\nExit:\n\treturn status;\n}",
          "includes": [
            "#include \"EndianPortable.h\"",
            "#include \"ALACAudioTypes.h\"",
            "#include \"ALACBitUtilities.h\"",
            "#include \"matrixlib.h\"",
            "#include \"dplib.h\"",
            "#include \"aglib.h\"",
            "#include \"ALACEncoder.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define VERBOSE_DEBUG\t\t0"
          ],
          "globals_used": [
            "static const uint32_t\tsChannelMaps[kALACMaxChannels] =\n{\n\tID_SCE,\n\tID_CPE,\n\t(ID_CPE << 3) | (ID_SCE),\n\t(ID_SCE << 9) | (ID_CPE << 3) | (ID_SCE),\n\t(ID_CPE << 9) | (ID_CPE << 3) | (ID_SCE),\n\t(ID_SCE << 15) | (ID_CPE << 9) | (ID_CPE << 3) | (ID_SCE),\n\t(ID_SCE << 18) | (ID_SCE << 15) | (ID_CPE << 9) | (ID_CPE << 3) | (ID_SCE),\n\t(ID_SCE << 21) | (ID_CPE << 15) | (ID_CPE << 9) | (ID_CPE << 3) | (ID_SCE)\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define VERBOSE_DEBUG\t\t0\n\nstatic const uint32_t\tsChannelMaps[kALACMaxChannels] =\n{\n\tID_SCE,\n\tID_CPE,\n\t(ID_CPE << 3) | (ID_SCE),\n\t(ID_SCE << 9) | (ID_CPE << 3) | (ID_SCE),\n\t(ID_CPE << 9) | (ID_CPE << 3) | (ID_SCE),\n\t(ID_SCE << 15) | (ID_CPE << 9) | (ID_CPE << 3) | (ID_SCE),\n\t(ID_SCE << 18) | (ID_SCE << 15) | (ID_CPE << 9) | (ID_CPE << 3) | (ID_SCE),\n\t(ID_SCE << 21) | (ID_CPE << 15) | (ID_CPE << 9) | (ID_CPE << 3) | (ID_SCE)\n};\n\nALACEncoder {\n  int32_t ALACEncoder::Encode(AudioFormatDescription theInputFormat, AudioFormatDescription theOutputFormat,\n                               unsigned char * theReadBuffer, unsigned char * theWriteBuffer, int32_t * ioNumBytes)\n  {\n  \tuint32_t\t\t\t\tnumFrames;\n  \tuint32_t\t\t\t\toutputSize;\n  \tBitBuffer\t\t\tbitstream;\n  \tint32_t\t\t\tstatus;\n  \n  \tnumFrames = *ioNumBytes/theInputFormat.mBytesPerPacket;\n  \n  \t// create a bit buffer structure pointing to our output buffer\n  \tBitBufferInit( &bitstream, theWriteBuffer, mMaxOutputBytes );\n  \n  \tif ( theInputFormat.mChannelsPerFrame == 2 )\n  \t{\n  \t\t// add 3-bit frame start tag ID_CPE = channel pair & 4-bit element instance tag = 0\n  \t\tBitBufferWrite( &bitstream, ID_CPE, 3 );\n  \t\tBitBufferWrite( &bitstream, 0, 4 );\n  \n  \t\t// encode stereo input buffer\n  \t\tif ( mFastMode == false )\n  \t\t\tstatus = this->EncodeStereo( &bitstream, theReadBuffer, 2, 0, numFrames );\n  \t\telse\n  \t\t\tstatus = this->EncodeStereoFast( &bitstream, theReadBuffer, 2, 0, numFrames );\n  \t\tRequireNoErr( status, goto Exit; );\n  \t}\n  \telse if ( theInputFormat.mChannelsPerFrame == 1 )\n  \t{\n  \t\t// add 3-bit frame start tag ID_SCE = mono channel & 4-bit element instance tag = 0\n  \t\tBitBufferWrite( &bitstream, ID_SCE, 3 );\n  \t\tBitBufferWrite( &bitstream, 0, 4 );\n  \n  \t\t// encode mono input buffer\n  \t\tstatus = this->EncodeMono( &bitstream, theReadBuffer, 1, 0, numFrames );\n  \t\tRequireNoErr( status, goto Exit; );\n  \t}\n  \telse\n  \t{\n  \t\tchar *\t\t\t\t\tinputBuffer;\n  \t\tuint32_t\t\t\t\ttag;\n  \t\tuint32_t\t\t\t\tchannelIndex;\n  \t\tuint32_t\t\t\t\tinputIncrement;\n  \t\tuint8_t\t\t\t\tstereoElementTag;\n  \t\tuint8_t\t\t\t\tmonoElementTag;\n  \t\tuint8_t\t\t\t\tlfeElementTag;\n  \t\t\n  \t\tinputBuffer\t\t= (char *) theReadBuffer;\n  \t\tinputIncrement\t= ((mBitDepth + 7) / 8);\n  \t\t\n  \t\tstereoElementTag\t= 0;\n  \t\tmonoElementTag\t\t= 0;\n  \t\tlfeElementTag\t\t= 0;\n  \n  \t\tfor ( channelIndex = 0; channelIndex < theInputFormat.mChannelsPerFrame; )\n  \t\t{\n  \t\t\ttag = (sChannelMaps[theInputFormat.mChannelsPerFrame - 1] & (0x7ul << (channelIndex * 3))) >> (channelIndex * 3);\n  \t\n  \t\t\tBitBufferWrite( &bitstream, tag, 3 );\n  \t\t\tswitch ( tag )\n  \t\t\t{\n  \t\t\t\tcase ID_SCE:\n  \t\t\t\t\t// mono\n  \t\t\t\t\tBitBufferWrite( &bitstream, monoElementTag, 4 );\n  \n  \t\t\t\t\tstatus = this->EncodeMono( &bitstream, inputBuffer, theInputFormat.mChannelsPerFrame, channelIndex, numFrames );\n  \t\t\t\t\t\n  \t\t\t\t\tinputBuffer += inputIncrement;\n  \t\t\t\t\tchannelIndex++;\n  \t\t\t\t\tmonoElementTag++;\n  \t\t\t\t\tbreak;\n  \n  \t\t\t\tcase ID_CPE:\n  \t\t\t\t\t// stereo\n  \t\t\t\t\tBitBufferWrite( &bitstream, stereoElementTag, 4 );\n  \n  \t\t\t\t\tstatus = this->EncodeStereo( &bitstream, inputBuffer, theInputFormat.mChannelsPerFrame, channelIndex, numFrames );\n  \n  \t\t\t\t\tinputBuffer += (inputIncrement * 2);\n  \t\t\t\t\tchannelIndex += 2;\n  \t\t\t\t\tstereoElementTag++;\n  \t\t\t\t\tbreak;\n  \n  \t\t\t\tcase ID_LFE:\n  \t\t\t\t\t// LFE channel (subwoofer)\n  \t\t\t\t\tBitBufferWrite( &bitstream, lfeElementTag, 4 );\n  \n  \t\t\t\t\tstatus = this->EncodeMono( &bitstream, inputBuffer, theInputFormat.mChannelsPerFrame, channelIndex, numFrames );\n  \n  \t\t\t\t\tinputBuffer += inputIncrement;\n  \t\t\t\t\tchannelIndex++;\n  \t\t\t\t\tlfeElementTag++;\n  \t\t\t\t\tbreak;\n  \n  \t\t\t\tdefault:\n  \t\t\t\t\tstatus = kALAC_ParamError;\n  \t\t\t\t\tgoto Exit;\n  \t\t\t}\n  \n  \t\t\tRequireNoErr( status, goto Exit; );\n  \t\t}\n  \t}\n  \n  #if VERBOSE_DEBUG\n  {\n  \t// if there is room left in the output buffer, add some random fill data to test decoder\n  \tint32_t\t\t\tbitsLeft;\n  \tint32_t\t\t\tbytesLeft;\n  \t\n  \tbitsLeft = BitBufferGetPosition( &bitstream ) - 3;\t// - 3 for ID_END tag\n  \tbytesLeft = bitstream.byteSize - ((bitsLeft + 7) / 8);\n  \t\n  \tif ( (bytesLeft > 20) && ((bytesLeft & 0x4u) != 0) )\n  \t\tAddFiller( &bitstream, bytesLeft );\n  }\n  #endif\n  \n  \t// add 3-bit frame end tag: ID_END\n  \tBitBufferWrite( &bitstream, ID_END, 3 );\n  \n  \t// byte-align the output data\n  \tBitBufferByteAlign( &bitstream, true );\n  \n  \toutputSize = BitBufferGetPosition( &bitstream ) / 8;\n  \t//Assert( outputSize <= mMaxOutputBytes );\n  \n  \n  \t// all good, let iTunes know what happened and remember the total number of input sample frames\n  \t*ioNumBytes = outputSize;\n  \t//mEncodedFrames\t\t   \t   += encodeMsg->numInputSamples;\n  \n  \t// gather encoding stats\n  \tmTotalBytesGenerated += outputSize;\n  \tmMaxFrameBytes = MAX( mMaxFrameBytes, outputSize );\n  \n  \tstatus = ALAC_noErr;\n  \n  Exit:\n  \treturn status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<uint8_t *>",
          "args": [
            "m_outChunk->buffer"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint8_t *>",
          "args": [
            "m_inChunk->buffer"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outputFormat",
          "args": [],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "outputFormat",
          "container": "ALAC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
          "lines": "135-160",
          "snippet": "AudioFormatDescription ALAC::outputFormat() const\n{\n\tAudioFormatDescription outputFormat;\n\toutputFormat.mSampleRate = m_track->f.sampleRate;\n\toutputFormat.mFormatID = kALACFormatAppleLossless;\n\tswitch (m_track->f.sampleWidth)\n\t{\n\t\tcase 16:\n\t\t\toutputFormat.mFormatFlags = kALACFormatFlag_16BitSourceData; break;\n\t\tcase 20:\n\t\t\toutputFormat.mFormatFlags = kALACFormatFlag_20BitSourceData; break;\n\t\tcase 24:\n\t\t\toutputFormat.mFormatFlags = kALACFormatFlag_24BitSourceData; break;\n\t\tcase 32:\n\t\t\toutputFormat.mFormatFlags = kALACFormatFlag_32BitSourceData; break;\n\t\tdefault:\n\t\t\toutputFormat.mFormatFlags = 0; break;\n\t}\n\toutputFormat.mFramesPerPacket = m_track->f.framesPerPacket;\n\toutputFormat.mChannelsPerFrame = m_track->f.channelCount;\n\toutputFormat.mBytesPerPacket = 0;\n\toutputFormat.mBytesPerFrame = 0;\n\toutputFormat.mBitsPerChannel = 0;\n\toutputFormat.mReserved = 0;\n\treturn outputFormat;\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"../alac/ALACEncoder.h\"",
            "#include \"../alac/ALACDecoder.h\"",
            "#include \"../alac/ALACBitUtilities.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"PacketTable.h\"",
            "#include \"FileModule.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"Buffer.h\"",
            "#include \"ALAC.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  AudioFormatDescription ALAC::outputFormat() const\n  {\n  \tAudioFormatDescription outputFormat;\n  \toutputFormat.mSampleRate = m_track->f.sampleRate;\n  \toutputFormat.mFormatID = kALACFormatAppleLossless;\n  \tswitch (m_track->f.sampleWidth)\n  \t{\n  \t\tcase 16:\n  \t\t\toutputFormat.mFormatFlags = kALACFormatFlag_16BitSourceData; break;\n  \t\tcase 20:\n  \t\t\toutputFormat.mFormatFlags = kALACFormatFlag_20BitSourceData; break;\n  \t\tcase 24:\n  \t\t\toutputFormat.mFormatFlags = kALACFormatFlag_24BitSourceData; break;\n  \t\tcase 32:\n  \t\t\toutputFormat.mFormatFlags = kALACFormatFlag_32BitSourceData; break;\n  \t\tdefault:\n  \t\t\toutputFormat.mFormatFlags = 0; break;\n  \t}\n  \toutputFormat.mFramesPerPacket = m_track->f.framesPerPacket;\n  \toutputFormat.mChannelsPerFrame = m_track->f.channelCount;\n  \toutputFormat.mBytesPerPacket = 0;\n  \toutputFormat.mBytesPerFrame = 0;\n  \toutputFormat.mBitsPerChannel = 0;\n  \toutputFormat.mReserved = 0;\n  \treturn outputFormat;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_format_frame_size_uncompressed",
          "args": [
            "&m_track->f",
            "false"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "_af_format_frame_size_uncompressed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "295-299",
          "snippet": "int _af_format_frame_size_uncompressed (const AudioFormat *fmt, bool stretch3to4)\n{\n\treturn _af_format_sample_size_uncompressed(fmt, stretch3to4) *\n\t\tfmt->channelCount;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nint _af_format_frame_size_uncompressed (const AudioFormat *fmt, bool stretch3to4)\n{\n\treturn _af_format_sample_size_uncompressed(fmt, stretch3to4) *\n\t\tfmt->channelCount;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  void ALAC::runPush()\n  {\n  \tAudioFormatDescription inputFormat;\n  \tinputFormat.mSampleRate = m_track->f.sampleRate;\n  \tinputFormat.mFormatID = kALACFormatLinearPCM;\n  \tinputFormat.mFormatFlags = kALACFormatFlagsNativeEndian;\n  \tinputFormat.mBytesPerPacket = _af_format_frame_size_uncompressed(&m_track->f, false);\n  \tinputFormat.mFramesPerPacket = 1;\n  \tinputFormat.mBytesPerFrame = _af_format_frame_size_uncompressed(&m_track->f, false);\n  \tinputFormat.mChannelsPerFrame = m_track->f.channelCount;\n  \tinputFormat.mBitsPerChannel = m_track->f.sampleWidth;\n  \tinputFormat.mReserved = 0;\n  \n  \tint32_t numBytes = m_inChunk->frameCount * inputFormat.mBytesPerFrame;\n  \tint32_t result = m_encoder->Encode(inputFormat, outputFormat(),\n  \t\tstatic_cast<uint8_t *>(m_inChunk->buffer),\n  \t\tstatic_cast<uint8_t *>(m_outChunk->buffer),\n  \t\t&numBytes);\n  \tif (result)\n  \t{\n  \t\t_af_error(AF_BAD_CODEC_STATE, \"error encoding ALAC audio data\");\n  \t\tm_track->filemodhappy = false;\n  \t\treturn;\n  \t}\n  \n  \tassert(numBytes <= bufferSize());\n  \n  \tssize_t bytesWritten = write(m_outChunk->buffer, numBytes);\n  \tif (bytesWritten != numBytes)\n  \t{\n  \t\treportWriteError(0, m_track->f.framesPerPacket);\n  \t\treturn;\n  \t}\n  \n  \tPacketTable *packetTable = m_track->m_packetTable.get();\n  \n  \tpacketTable->append(numBytes);\n  \n  \tpacketTable->setNumValidFrames(packetTable->numValidFrames() +\n  \t\tm_inChunk->frameCount);\n  }\n}"
  },
  {
    "function_name": "bufferSize",
    "container": "ALAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
    "lines": "273-277",
    "snippet": "int ALAC::bufferSize() const\n{\n\treturn m_track->f.framesPerPacket * m_track->f.channelCount *\n\t\t((10 + m_track->f.sampleWidth) / 8) + 1;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"../alac/ALACEncoder.h\"",
      "#include \"../alac/ALACDecoder.h\"",
      "#include \"../alac/ALACBitUtilities.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"PacketTable.h\"",
      "#include \"FileModule.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"Buffer.h\"",
      "#include \"ALAC.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  int ALAC::bufferSize() const\n  {\n  \treturn m_track->f.framesPerPacket * m_track->f.channelCount *\n  \t\t((10 + m_track->f.sampleWidth) / 8) + 1;\n  }\n}"
  },
  {
    "function_name": "reset2",
    "container": "ALAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
    "lines": "266-271",
    "snippet": "void ALAC::reset2()\n{\n\tm_track->fpos_next_frame = m_track->fpos_first_frame +\n\t\tm_track->m_packetTable->startOfPacket(m_currentPacket);\n\tm_track->frames2ignore += m_framesToIgnore;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"../alac/ALACEncoder.h\"",
      "#include \"../alac/ALACDecoder.h\"",
      "#include \"../alac/ALACBitUtilities.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"PacketTable.h\"",
      "#include \"FileModule.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"Buffer.h\"",
      "#include \"ALAC.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_track->m_packetTable->startOfPacket",
          "args": [
            "m_currentPacket"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "startOfPacket",
          "container": "PacketTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/PacketTable.cpp",
          "lines": "63-69",
          "snippet": "AFfileoffset PacketTable::startOfPacket(size_t packet) const\n{\n\tAFfileoffset offset = 0;\n\tfor (size_t i=0; i<packet; i++)\n\t\toffset += m_bytesPerPacket[i];\n\treturn offset;\n}",
          "includes": [
            "#include \"PacketTable.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"PacketTable.h\"\n#include \"config.h\"\n\nPacketTable {\n  AFfileoffset PacketTable::startOfPacket(size_t packet) const\n  {\n  \tAFfileoffset offset = 0;\n  \tfor (size_t i=0; i<packet; i++)\n  \t\toffset += m_bytesPerPacket[i];\n  \treturn offset;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  void ALAC::reset2()\n  {\n  \tm_track->fpos_next_frame = m_track->fpos_first_frame +\n  \t\tm_track->m_packetTable->startOfPacket(m_currentPacket);\n  \tm_track->frames2ignore += m_framesToIgnore;\n  }\n}"
  },
  {
    "function_name": "reset1",
    "container": "ALAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
    "lines": "258-264",
    "snippet": "void ALAC::reset1()\n{\n\tAFframecount nextFrame = m_track->nextfframe;\n\tm_currentPacket = nextFrame / m_track->f.framesPerPacket;\n\tm_track->nextfframe = m_currentPacket * m_track->f.framesPerPacket;\n\tm_framesToIgnore = nextFrame - m_track->nextfframe;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"../alac/ALACEncoder.h\"",
      "#include \"../alac/ALACDecoder.h\"",
      "#include \"../alac/ALACBitUtilities.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"PacketTable.h\"",
      "#include \"FileModule.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"Buffer.h\"",
      "#include \"ALAC.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  void ALAC::reset1()\n  {\n  \tAFframecount nextFrame = m_track->nextfframe;\n  \tm_currentPacket = nextFrame / m_track->f.framesPerPacket;\n  \tm_track->nextfframe = m_currentPacket * m_track->f.framesPerPacket;\n  \tm_framesToIgnore = nextFrame - m_track->nextfframe;\n  }\n}"
  },
  {
    "function_name": "runPull",
    "container": "ALAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
    "lines": "227-256",
    "snippet": "void ALAC::runPull()\n{\n\tSharedPtr<PacketTable> packetTable = m_track->m_packetTable;\n\tif (m_currentPacket >= static_cast<int>(packetTable->numPackets()))\n\t{\n\t\tm_outChunk->frameCount = 0;\n\t\treturn;\n\t}\n\tassert(m_currentPacket < static_cast<int>(packetTable->numPackets()));\n\n\tssize_t bytesPerPacket = packetTable->bytesPerPacket(m_currentPacket);\n\tassert(bytesPerPacket <= bufferSize());\n\n\tif (read(m_inChunk->buffer, bytesPerPacket) < bytesPerPacket)\n\t{\n\t\treportReadError(0, m_track->f.framesPerPacket);\n\t\treturn;\n\t}\n\n\tBitBuffer bitBuffer;\n\tBitBufferInit(&bitBuffer, static_cast<uint8_t *>(m_inChunk->buffer),\n\t\tbytesPerPacket);\n\n\tuint32_t numFrames;\n\tm_decoder->Decode(&bitBuffer, static_cast<uint8_t *>(m_outChunk->buffer),\n\t\tm_track->f.framesPerPacket, m_track->f.channelCount, &numFrames);\n\tm_outChunk->frameCount = numFrames;\n\n\tm_currentPacket++;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"../alac/ALACEncoder.h\"",
      "#include \"../alac/ALACDecoder.h\"",
      "#include \"../alac/ALACBitUtilities.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"PacketTable.h\"",
      "#include \"FileModule.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"Buffer.h\"",
      "#include \"ALAC.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_decoder->Decode",
          "args": [
            "&bitBuffer",
            "static_cast<uint8_t *>(m_outChunk->buffer)",
            "m_track->f.framesPerPacket",
            "m_track->f.channelCount",
            "&numFrames"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "Decode",
          "container": "ALACDecoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACDecoder.cpp",
          "lines": "163-622",
          "snippet": "int32_t ALACDecoder::Decode( BitBuffer * bits, uint8_t * sampleBuffer, uint32_t numSamples, uint32_t numChannels, uint32_t * outNumSamples )\n{\n\tBitBuffer\t\t\tshiftBits;\n\tuint32_t            bits1, bits2;\n\tuint8_t\t\t\t\ttag;\n\tuint8_t\t\t\t\telementInstanceTag;\n\tAGParamRec\t\t\tagParams;\n\tuint32_t\t\t\t\tchannelIndex;\n\tint16_t\t\t\t\tcoefsU[32];\t\t// max possible size is 32 although NUMCOEPAIRS is the current limit\n\tint16_t\t\t\t\tcoefsV[32];\n\tuint8_t\t\t\t\tnumU, numV;\n\tuint8_t\t\t\t\tmixBits;\n\tint8_t\t\t\t\tmixRes;\n\tuint16_t\t\t\tunusedHeader;\n\tuint8_t\t\t\t\tescapeFlag;\n\tuint32_t\t\t\tchanBits;\n\tuint8_t\t\t\t\tbytesShifted;\n\tuint32_t\t\t\tshift;\n\tuint8_t\t\t\t\tmodeU, modeV;\n\tuint32_t\t\t\tdenShiftU, denShiftV;\n\tuint16_t\t\t\tpbFactorU, pbFactorV;\n\tuint16_t\t\t\tpb;\n\tint16_t *\t\t\tsamples;\n\tint16_t *\t\t\tout16;\n\tuint8_t *\t\t\tout20;\n\tuint8_t *\t\t\tout24;\n\tint32_t *\t\t\tout32;\n\tuint8_t\t\t\t\theaderByte;\n\tuint8_t\t\t\t\tpartialFrame;\n\tuint32_t\t\t\textraBits;\n\tint32_t\t\t\t\tval;\n\tuint32_t\t\t\ti, j;\n\tint32_t             status;\n\t\n\tRequireAction( (bits != nil) && (sampleBuffer != nil) && (outNumSamples != nil), return kALAC_ParamError; );\n\tRequireAction( numChannels > 0, return kALAC_ParamError; );\n\n\tmActiveElements = 0;\n\tchannelIndex\t= 0;\n\t\n\tsamples = (int16_t *) sampleBuffer;\n\n\tstatus = ALAC_noErr;\n\t*outNumSamples = numSamples;\n\n\twhile ( status == ALAC_noErr )\n\t{\n\t\t// bail if we ran off the end of the buffer\n    \tRequireAction( bits->cur < bits->end, status = kALAC_ParamError; goto Exit; );\n\n\t\t// copy global decode params for this element\n\t\tpb = mConfig.pb;\n\n\t\t// read element tag\n\t\ttag = BitBufferReadSmall( bits, 3 );\n\t\tswitch ( tag )\n\t\t{\n\t\t\tcase ID_SCE:\n\t\t\tcase ID_LFE:\n\t\t\t{\n\t\t\t\t// mono/LFE channel\n\t\t\t\telementInstanceTag = BitBufferReadSmall( bits, 4 );\n\t\t\t\tmActiveElements |= (1u << elementInstanceTag);\n\n\t\t\t\t// read the 12 unused header bits\n\t\t\t\tunusedHeader = (uint16_t) BitBufferRead( bits, 12 );\n\t\t\t\tRequireAction( unusedHeader == 0, status = kALAC_ParamError; goto Exit; );\n\n\t\t\t\t// read the 1-bit \"partial frame\" flag, 2-bit \"shift-off\" flag & 1-bit \"escape\" flag\n\t\t\t\theaderByte = (uint8_t) BitBufferRead( bits, 4 );\n\t\t\t\t\n\t\t\t\tpartialFrame = headerByte >> 3;\n\t\t\t\t\n\t\t\t\tbytesShifted = (headerByte >> 1) & 0x3u;\n\t\t\t\tRequireAction( bytesShifted != 3, status = kALAC_ParamError; goto Exit; );\n\n\t\t\t\tshift = bytesShifted * 8;\n\n\t\t\t\tescapeFlag = headerByte & 0x1;\n\n\t\t\t\tchanBits = mConfig.bitDepth - (bytesShifted * 8);\n\t\t\t\t\n\t\t\t\t// check for partial frame to override requested numSamples\n\t\t\t\tif ( partialFrame != 0 )\n\t\t\t\t{\n\t\t\t\t\tnumSamples  = BitBufferRead( bits, 16 ) << 16;\n\t\t\t\t\tnumSamples |= BitBufferRead( bits, 16 );\n\t\t\t\t}\n\n\t\t\t\tif ( escapeFlag == 0 )\n\t\t\t\t{\n\t\t\t\t\t// compressed frame, read rest of parameters\n\t\t\t\t\tmixBits\t= (uint8_t) BitBufferRead( bits, 8 );\n\t\t\t\t\tmixRes\t= (int8_t) BitBufferRead( bits, 8 );\n\t\t\t\t\t//Assert( (mixBits == 0) && (mixRes == 0) );\t\t// no mixing for mono\n\n\t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n\t\t\t\t\tmodeU\t\t= headerByte >> 4;\n\t\t\t\t\tdenShiftU\t= headerByte & 0xfu;\n\t\t\t\t\t\n\t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n\t\t\t\t\tpbFactorU\t= headerByte >> 5;\n\t\t\t\t\tnumU\t\t= headerByte & 0x1fu;\n\n\t\t\t\t\tfor ( i = 0; i < numU; i++ )\n\t\t\t\t\t\tcoefsU[i] = (int16_t) BitBufferRead( bits, 16 );\n\t\t\t\t\t\n\t\t\t\t\t// if shift active, skip the the shift buffer but remember where it starts\n\t\t\t\t\tif ( bytesShifted != 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tshiftBits = *bits;\n\t\t\t\t\t\tBitBufferAdvance( bits, (bytesShifted * 8) * numSamples ); \n\t\t\t\t\t}\n\n\t\t\t\t\t// decompress\n\t\t\t\t\tset_ag_params( &agParams, mConfig.mb, (pb * pbFactorU) / 4, mConfig.kb, numSamples, numSamples, mConfig.maxRun );\n\t\t\t\t\tstatus = dyn_decomp( &agParams, bits, mPredictor, numSamples, chanBits, &bits1 );\n\t\t\t\t\tRequireNoErr( status, goto Exit; );\n\n\t\t\t\t\tif ( modeU == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tunpc_block( mPredictor, mMixBufferU, numSamples, &coefsU[0], numU, chanBits, denShiftU );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// the special \"numActive == 31\" mode can be done in-place\n\t\t\t\t\t\tunpc_block( mPredictor, mPredictor, numSamples, nil, 31, chanBits, 0 );\n\t\t\t\t\t\tunpc_block( mPredictor, mMixBufferU, numSamples, &coefsU[0], numU, chanBits, denShiftU );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//Assert( bytesShifted == 0 );\n\n\t\t\t\t\t// uncompressed frame, copy data into the mix buffer to use common output code\n\t\t\t\t\tshift = 32 - chanBits;\n\t\t\t\t\tif ( chanBits <= 16 )\n\t\t\t\t\t{\n\t\t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, (uint8_t) chanBits );\n\t\t\t\t\t\t\tval = (val << shift) >> shift;\n\t\t\t\t\t\t\tmMixBufferU[i] = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// BitBufferRead() can't read more than 16 bits at a time so break up the reads\n\t\t\t\t\t\textraBits = chanBits - 16;\n\t\t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, 16 );\n\t\t\t\t\t\t\tval = (val << 16) >> shift;\n\t\t\t\t\t\t\tmMixBufferU[i] = val | BitBufferRead( bits, (uint8_t) extraBits );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tmixBits = mixRes = 0;\n\t\t\t\t\tbits1 = chanBits * numSamples;\n\t\t\t\t\tbytesShifted = 0;\n\t\t\t\t}\n\n\t\t\t\t// now read the shifted values into the shift buffer\n\t\t\t\tif ( bytesShifted != 0 )\n\t\t\t\t{\n\t\t\t\t\tshift = bytesShifted * 8;\n\t\t\t\t\t//Assert( shift <= 16 );\n\n\t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n\t\t\t\t\t\tmShiftBuffer[i] = (uint16_t) BitBufferRead( &shiftBits, (uint8_t) shift );\n\t\t\t\t}\n\n\t\t\t\t// convert 32-bit integers into output buffer\n\t\t\t\tswitch ( mConfig.bitDepth )\n\t\t\t\t{\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\tout16 = &((int16_t *)sampleBuffer)[channelIndex];\n\t\t\t\t\t\tfor ( i = 0, j = 0; i < numSamples; i++, j += numChannels )\n\t\t\t\t\t\t\tout16[j] = (int16_t) mMixBufferU[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 20:\n\t\t\t\t\t\tout20 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n\t\t\t\t\t\tcopyPredictorTo20( mMixBufferU, out20, numChannels, numSamples );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 24:\n\t\t\t\t\t\tout24 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n\t\t\t\t\t\tif ( bytesShifted != 0 )\n\t\t\t\t\t\t\tcopyPredictorTo24Shift( mMixBufferU, mShiftBuffer, out24, numChannels, numSamples, bytesShifted );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcopyPredictorTo24( mMixBufferU, out24, numChannels, numSamples );\t\t\t\t\t\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\tout32 = &((int32_t *)sampleBuffer)[channelIndex];\n\t\t\t\t\t\tif ( bytesShifted != 0 )\n\t\t\t\t\t\t\tcopyPredictorTo32Shift( mMixBufferU, mShiftBuffer, out32, numChannels, numSamples, bytesShifted );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcopyPredictorTo32( mMixBufferU, out32, numChannels, numSamples);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchannelIndex += 1;\n\t\t\t\t*outNumSamples = numSamples;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase ID_CPE:\n\t\t\t{\n\t\t\t\t// if decoding this pair would take us over the max channels limit, bail\n\t\t\t\tif ( (channelIndex + 2) > numChannels )\n\t\t\t\t\tgoto NoMoreChannels;\n\n\t\t\t\t// stereo channel pair\n\t\t\t\telementInstanceTag = BitBufferReadSmall( bits, 4 );\n\t\t\t\tmActiveElements |= (1u << elementInstanceTag);\n\n\t\t\t\t// read the 12 unused header bits\n\t\t\t\tunusedHeader = (uint16_t) BitBufferRead( bits, 12 );\n\t\t\t\tRequireAction( unusedHeader == 0, status = kALAC_ParamError; goto Exit; );\n\n\t\t\t\t// read the 1-bit \"partial frame\" flag, 2-bit \"shift-off\" flag & 1-bit \"escape\" flag\n\t\t\t\theaderByte = (uint8_t) BitBufferRead( bits, 4 );\n\t\t\t\t\n\t\t\t\tpartialFrame = headerByte >> 3;\n\t\t\t\t\n\t\t\t\tbytesShifted = (headerByte >> 1) & 0x3u;\n\t\t\t\tRequireAction( bytesShifted != 3, status = kALAC_ParamError; goto Exit; );\n\n\t\t\t\tshift = bytesShifted * 8;\n\n\t\t\t\tescapeFlag = headerByte & 0x1;\n\n\t\t\t\tchanBits = mConfig.bitDepth - (bytesShifted * 8) + 1;\n\t\t\t\t\n\t\t\t\t// check for partial frame length to override requested numSamples\n\t\t\t\tif ( partialFrame != 0 )\n\t\t\t\t{\n\t\t\t\t\tnumSamples  = BitBufferRead( bits, 16 ) << 16;\n\t\t\t\t\tnumSamples |= BitBufferRead( bits, 16 );\n\t\t\t\t}\n\n\t\t\t\tif ( escapeFlag == 0 )\n\t\t\t\t{\n\t\t\t\t\t// compressed frame, read rest of parameters\n\t\t\t\t\tmixBits\t\t= (uint8_t) BitBufferRead( bits, 8 );\n\t\t\t\t\tmixRes\t\t= (int8_t) BitBufferRead( bits, 8 );\n\n\t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n\t\t\t\t\tmodeU\t\t= headerByte >> 4;\n\t\t\t\t\tdenShiftU\t= headerByte & 0xfu;\n\t\t\t\t\t\n\t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n\t\t\t\t\tpbFactorU\t= headerByte >> 5;\n\t\t\t\t\tnumU\t\t= headerByte & 0x1fu;\n\t\t\t\t\tfor ( i = 0; i < numU; i++ )\n\t\t\t\t\t\tcoefsU[i] = (int16_t) BitBufferRead( bits, 16 );\n\n\t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n\t\t\t\t\tmodeV\t\t= headerByte >> 4;\n\t\t\t\t\tdenShiftV\t= headerByte & 0xfu;\n\t\t\t\t\t\n\t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n\t\t\t\t\tpbFactorV\t= headerByte >> 5;\n\t\t\t\t\tnumV\t\t= headerByte & 0x1fu;\n\t\t\t\t\tfor ( i = 0; i < numV; i++ )\n\t\t\t\t\t\tcoefsV[i] = (int16_t) BitBufferRead( bits, 16 );\n\n\t\t\t\t\t// if shift active, skip the interleaved shifted values but remember where they start\n\t\t\t\t\tif ( bytesShifted != 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tshiftBits = *bits;\n\t\t\t\t\t\tBitBufferAdvance( bits, (bytesShifted * 8) * 2 * numSamples );\n\t\t\t\t\t}\n\n\t\t\t\t\t// decompress and run predictor for \"left\" channel\n\t\t\t\t\tset_ag_params( &agParams, mConfig.mb, (pb * pbFactorU) / 4, mConfig.kb, numSamples, numSamples, mConfig.maxRun );\n\t\t\t\t\tstatus = dyn_decomp( &agParams, bits, mPredictor, numSamples, chanBits, &bits1 );\n\t\t\t\t\tRequireNoErr( status, goto Exit; );\n\n\t\t\t\t\tif ( modeU == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tunpc_block( mPredictor, mMixBufferU, numSamples, &coefsU[0], numU, chanBits, denShiftU );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// the special \"numActive == 31\" mode can be done in-place\n\t\t\t\t\t\tunpc_block( mPredictor, mPredictor, numSamples, nil, 31, chanBits, 0 );\n\t\t\t\t\t\tunpc_block( mPredictor, mMixBufferU, numSamples, &coefsU[0], numU, chanBits, denShiftU );\n\t\t\t\t\t}\n\n\t\t\t\t\t// decompress and run predictor for \"right\" channel\n\t\t\t\t\tset_ag_params( &agParams, mConfig.mb, (pb * pbFactorV) / 4, mConfig.kb, numSamples, numSamples, mConfig.maxRun );\n\t\t\t\t\tstatus = dyn_decomp( &agParams, bits, mPredictor, numSamples, chanBits, &bits2 );\n\t\t\t\t\tRequireNoErr( status, goto Exit; );\n\n\t\t\t\t\tif ( modeV == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tunpc_block( mPredictor, mMixBufferV, numSamples, &coefsV[0], numV, chanBits, denShiftV );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// the special \"numActive == 31\" mode can be done in-place\n\t\t\t\t\t\tunpc_block( mPredictor, mPredictor, numSamples, nil, 31, chanBits, 0 );\n\t\t\t\t\t\tunpc_block( mPredictor, mMixBufferV, numSamples, &coefsV[0], numV, chanBits, denShiftV );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//Assert( bytesShifted == 0 );\n\n\t\t\t\t\t// uncompressed frame, copy data into the mix buffers to use common output code\n\t\t\t\t\tchanBits = mConfig.bitDepth;\n\t\t\t\t\tshift = 32 - chanBits;\n\t\t\t\t\tif ( chanBits <= 16 )\n\t\t\t\t\t{\n\t\t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, (uint8_t) chanBits );\n\t\t\t\t\t\t\tval = (val << shift) >> shift;\n\t\t\t\t\t\t\tmMixBufferU[i] = val;\n\n\t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, (uint8_t) chanBits );\n\t\t\t\t\t\t\tval = (val << shift) >> shift;\n\t\t\t\t\t\t\tmMixBufferV[i] = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// BitBufferRead() can't read more than 16 bits at a time so break up the reads\n\t\t\t\t\t\textraBits = chanBits - 16;\n\t\t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, 16 );\n\t\t\t\t\t\t\tval = (val << 16) >> shift;\n\t\t\t\t\t\t\tmMixBufferU[i] = val | BitBufferRead( bits, (uint8_t)extraBits );\n\n\t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, 16 );\n\t\t\t\t\t\t\tval = (val << 16) >> shift;\n\t\t\t\t\t\t\tmMixBufferV[i] = val | BitBufferRead( bits, (uint8_t)extraBits );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbits1 = chanBits * numSamples;\n\t\t\t\t\tbits2 = chanBits * numSamples;\n\t\t\t\t\tmixBits = mixRes = 0;\n\t\t\t\t\tbytesShifted = 0;\n\t\t\t\t}\n\n\t\t\t\t// now read the shifted values into the shift buffer\n\t\t\t\tif ( bytesShifted != 0 )\n\t\t\t\t{\n\t\t\t\t\tshift = bytesShifted * 8;\n\t\t\t\t\t//Assert( shift <= 16 );\n\n\t\t\t\t\tfor ( i = 0; i < (numSamples * 2); i += 2 )\n\t\t\t\t\t{\n\t\t\t\t\t\tmShiftBuffer[i + 0] = (uint16_t) BitBufferRead( &shiftBits, (uint8_t) shift );\n\t\t\t\t\t\tmShiftBuffer[i + 1] = (uint16_t) BitBufferRead( &shiftBits, (uint8_t) shift );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// un-mix the data and convert to output format\n\t\t\t\t// - note that mixRes = 0 means just interleave so we use that path for uncompressed frames\n\t\t\t\tswitch ( mConfig.bitDepth )\n\t\t\t\t{\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\tout16 = &((int16_t *)sampleBuffer)[channelIndex];\n\t\t\t\t\t\tunmix16( mMixBufferU, mMixBufferV, out16, numChannels, numSamples, mixBits, mixRes );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 20:\n\t\t\t\t\t\tout20 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n\t\t\t\t\t\tunmix20( mMixBufferU, mMixBufferV, out20, numChannels, numSamples, mixBits, mixRes );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 24:\n\t\t\t\t\t\tout24 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n\t\t\t\t\t\tunmix24( mMixBufferU, mMixBufferV, out24, numChannels, numSamples,\n\t\t\t\t\t\t\t\t\tmixBits, mixRes, mShiftBuffer, bytesShifted );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\tout32 = &((int32_t *)sampleBuffer)[channelIndex];\n\t\t\t\t\t\tunmix32( mMixBufferU, mMixBufferV, out32, numChannels, numSamples,\n\t\t\t\t\t\t\t\t\tmixBits, mixRes, mShiftBuffer, bytesShifted );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchannelIndex += 2;\n\t\t\t\t*outNumSamples = numSamples;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase ID_CCE:\n\t\t\tcase ID_PCE:\n\t\t\t{\n\t\t\t\t// unsupported element, bail\n\t\t\t\t//AssertNoErr( tag );\n\t\t\t\tstatus = kALAC_ParamError;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase ID_DSE:\n\t\t\t{\n\t\t\t\t// data stream element -- parse but ignore\n\t\t\t\tstatus = this->DataStreamElement( bits );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcase ID_FIL:\n\t\t\t{\n\t\t\t\t// fill element -- parse but ignore\n\t\t\t\tstatus = this->FillElement( bits );\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase ID_END:\n\t\t\t{\n\t\t\t\t// frame end, all done so byte align the frame and check for overruns\n\t\t\t\tBitBufferByteAlign( bits, false );\n\t\t\t\t//Assert( bits->cur == bits->end );\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\n#if ! DEBUG\n\t\t// if we've decoded all of our channels, bail (but not in debug b/c we want to know if we're seeing bad bits)\n\t\t// - this also protects us if the config does not match the bitstream or crap data bits follow the audio bits\n\t\tif ( channelIndex >= numChannels )\n\t\t\tbreak;\n#endif\n\t}\n\nNoMoreChannels:\n\n\t// if we get here and haven't decoded all of the requested channels, fill the remaining channels with zeros\n\tfor ( ; channelIndex < numChannels; channelIndex++ )\n\t{\n\t\tswitch ( mConfig.bitDepth )\n\t\t{\n\t\t\tcase 16:\n\t\t\t{\n\t\t\t\tint16_t *\tfill16 = &((int16_t *)sampleBuffer)[channelIndex];\n\t\t\t\tZero16( fill16, numSamples, numChannels );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 24:\n\t\t\t{\n\t\t\t\tuint8_t *\tfill24 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n\t\t\t\tZero24( fill24, numSamples, numChannels );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 32:\n\t\t\t{\n\t\t\t\tint32_t *\tfill32 = &((int32_t *)sampleBuffer)[channelIndex];\n\t\t\t\tZero32( fill32, numSamples, numChannels );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nExit:\n\treturn status;\n}",
          "includes": [
            "#include \"EndianPortable.h\"",
            "#include \"ALACBitUtilities.h\"",
            "#include \"matrixlib.h\"",
            "#include \"aglib.h\"",
            "#include \"dplib.h\"",
            "#include \"ALACDecoder.h\"",
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"aglib.h\"\n#include \"dplib.h\"\n#include \"ALACDecoder.h\"\n#include <string.h>\n#include <stdlib.h>\n\nALACDecoder {\n  int32_t ALACDecoder::Decode( BitBuffer * bits, uint8_t * sampleBuffer, uint32_t numSamples, uint32_t numChannels, uint32_t * outNumSamples )\n  {\n  \tBitBuffer\t\t\tshiftBits;\n  \tuint32_t            bits1, bits2;\n  \tuint8_t\t\t\t\ttag;\n  \tuint8_t\t\t\t\telementInstanceTag;\n  \tAGParamRec\t\t\tagParams;\n  \tuint32_t\t\t\t\tchannelIndex;\n  \tint16_t\t\t\t\tcoefsU[32];\t\t// max possible size is 32 although NUMCOEPAIRS is the current limit\n  \tint16_t\t\t\t\tcoefsV[32];\n  \tuint8_t\t\t\t\tnumU, numV;\n  \tuint8_t\t\t\t\tmixBits;\n  \tint8_t\t\t\t\tmixRes;\n  \tuint16_t\t\t\tunusedHeader;\n  \tuint8_t\t\t\t\tescapeFlag;\n  \tuint32_t\t\t\tchanBits;\n  \tuint8_t\t\t\t\tbytesShifted;\n  \tuint32_t\t\t\tshift;\n  \tuint8_t\t\t\t\tmodeU, modeV;\n  \tuint32_t\t\t\tdenShiftU, denShiftV;\n  \tuint16_t\t\t\tpbFactorU, pbFactorV;\n  \tuint16_t\t\t\tpb;\n  \tint16_t *\t\t\tsamples;\n  \tint16_t *\t\t\tout16;\n  \tuint8_t *\t\t\tout20;\n  \tuint8_t *\t\t\tout24;\n  \tint32_t *\t\t\tout32;\n  \tuint8_t\t\t\t\theaderByte;\n  \tuint8_t\t\t\t\tpartialFrame;\n  \tuint32_t\t\t\textraBits;\n  \tint32_t\t\t\t\tval;\n  \tuint32_t\t\t\ti, j;\n  \tint32_t             status;\n  \t\n  \tRequireAction( (bits != nil) && (sampleBuffer != nil) && (outNumSamples != nil), return kALAC_ParamError; );\n  \tRequireAction( numChannels > 0, return kALAC_ParamError; );\n  \n  \tmActiveElements = 0;\n  \tchannelIndex\t= 0;\n  \t\n  \tsamples = (int16_t *) sampleBuffer;\n  \n  \tstatus = ALAC_noErr;\n  \t*outNumSamples = numSamples;\n  \n  \twhile ( status == ALAC_noErr )\n  \t{\n  \t\t// bail if we ran off the end of the buffer\n      \tRequireAction( bits->cur < bits->end, status = kALAC_ParamError; goto Exit; );\n  \n  \t\t// copy global decode params for this element\n  \t\tpb = mConfig.pb;\n  \n  \t\t// read element tag\n  \t\ttag = BitBufferReadSmall( bits, 3 );\n  \t\tswitch ( tag )\n  \t\t{\n  \t\t\tcase ID_SCE:\n  \t\t\tcase ID_LFE:\n  \t\t\t{\n  \t\t\t\t// mono/LFE channel\n  \t\t\t\telementInstanceTag = BitBufferReadSmall( bits, 4 );\n  \t\t\t\tmActiveElements |= (1u << elementInstanceTag);\n  \n  \t\t\t\t// read the 12 unused header bits\n  \t\t\t\tunusedHeader = (uint16_t) BitBufferRead( bits, 12 );\n  \t\t\t\tRequireAction( unusedHeader == 0, status = kALAC_ParamError; goto Exit; );\n  \n  \t\t\t\t// read the 1-bit \"partial frame\" flag, 2-bit \"shift-off\" flag & 1-bit \"escape\" flag\n  \t\t\t\theaderByte = (uint8_t) BitBufferRead( bits, 4 );\n  \t\t\t\t\n  \t\t\t\tpartialFrame = headerByte >> 3;\n  \t\t\t\t\n  \t\t\t\tbytesShifted = (headerByte >> 1) & 0x3u;\n  \t\t\t\tRequireAction( bytesShifted != 3, status = kALAC_ParamError; goto Exit; );\n  \n  \t\t\t\tshift = bytesShifted * 8;\n  \n  \t\t\t\tescapeFlag = headerByte & 0x1;\n  \n  \t\t\t\tchanBits = mConfig.bitDepth - (bytesShifted * 8);\n  \t\t\t\t\n  \t\t\t\t// check for partial frame to override requested numSamples\n  \t\t\t\tif ( partialFrame != 0 )\n  \t\t\t\t{\n  \t\t\t\t\tnumSamples  = BitBufferRead( bits, 16 ) << 16;\n  \t\t\t\t\tnumSamples |= BitBufferRead( bits, 16 );\n  \t\t\t\t}\n  \n  \t\t\t\tif ( escapeFlag == 0 )\n  \t\t\t\t{\n  \t\t\t\t\t// compressed frame, read rest of parameters\n  \t\t\t\t\tmixBits\t= (uint8_t) BitBufferRead( bits, 8 );\n  \t\t\t\t\tmixRes\t= (int8_t) BitBufferRead( bits, 8 );\n  \t\t\t\t\t//Assert( (mixBits == 0) && (mixRes == 0) );\t\t// no mixing for mono\n  \n  \t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n  \t\t\t\t\tmodeU\t\t= headerByte >> 4;\n  \t\t\t\t\tdenShiftU\t= headerByte & 0xfu;\n  \t\t\t\t\t\n  \t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n  \t\t\t\t\tpbFactorU\t= headerByte >> 5;\n  \t\t\t\t\tnumU\t\t= headerByte & 0x1fu;\n  \n  \t\t\t\t\tfor ( i = 0; i < numU; i++ )\n  \t\t\t\t\t\tcoefsU[i] = (int16_t) BitBufferRead( bits, 16 );\n  \t\t\t\t\t\n  \t\t\t\t\t// if shift active, skip the the shift buffer but remember where it starts\n  \t\t\t\t\tif ( bytesShifted != 0 )\n  \t\t\t\t\t{\n  \t\t\t\t\t\tshiftBits = *bits;\n  \t\t\t\t\t\tBitBufferAdvance( bits, (bytesShifted * 8) * numSamples ); \n  \t\t\t\t\t}\n  \n  \t\t\t\t\t// decompress\n  \t\t\t\t\tset_ag_params( &agParams, mConfig.mb, (pb * pbFactorU) / 4, mConfig.kb, numSamples, numSamples, mConfig.maxRun );\n  \t\t\t\t\tstatus = dyn_decomp( &agParams, bits, mPredictor, numSamples, chanBits, &bits1 );\n  \t\t\t\t\tRequireNoErr( status, goto Exit; );\n  \n  \t\t\t\t\tif ( modeU == 0 )\n  \t\t\t\t\t{\n  \t\t\t\t\t\tunpc_block( mPredictor, mMixBufferU, numSamples, &coefsU[0], numU, chanBits, denShiftU );\n  \t\t\t\t\t}\n  \t\t\t\t\telse\n  \t\t\t\t\t{\n  \t\t\t\t\t\t// the special \"numActive == 31\" mode can be done in-place\n  \t\t\t\t\t\tunpc_block( mPredictor, mPredictor, numSamples, nil, 31, chanBits, 0 );\n  \t\t\t\t\t\tunpc_block( mPredictor, mMixBufferU, numSamples, &coefsU[0], numU, chanBits, denShiftU );\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t{\n  \t\t\t\t\t//Assert( bytesShifted == 0 );\n  \n  \t\t\t\t\t// uncompressed frame, copy data into the mix buffer to use common output code\n  \t\t\t\t\tshift = 32 - chanBits;\n  \t\t\t\t\tif ( chanBits <= 16 )\n  \t\t\t\t\t{\n  \t\t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n  \t\t\t\t\t\t{\n  \t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, (uint8_t) chanBits );\n  \t\t\t\t\t\t\tval = (val << shift) >> shift;\n  \t\t\t\t\t\t\tmMixBufferU[i] = val;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t\telse\n  \t\t\t\t\t{\n  \t\t\t\t\t\t// BitBufferRead() can't read more than 16 bits at a time so break up the reads\n  \t\t\t\t\t\textraBits = chanBits - 16;\n  \t\t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n  \t\t\t\t\t\t{\n  \t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, 16 );\n  \t\t\t\t\t\t\tval = (val << 16) >> shift;\n  \t\t\t\t\t\t\tmMixBufferU[i] = val | BitBufferRead( bits, (uint8_t) extraBits );\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \n  \t\t\t\t\tmixBits = mixRes = 0;\n  \t\t\t\t\tbits1 = chanBits * numSamples;\n  \t\t\t\t\tbytesShifted = 0;\n  \t\t\t\t}\n  \n  \t\t\t\t// now read the shifted values into the shift buffer\n  \t\t\t\tif ( bytesShifted != 0 )\n  \t\t\t\t{\n  \t\t\t\t\tshift = bytesShifted * 8;\n  \t\t\t\t\t//Assert( shift <= 16 );\n  \n  \t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n  \t\t\t\t\t\tmShiftBuffer[i] = (uint16_t) BitBufferRead( &shiftBits, (uint8_t) shift );\n  \t\t\t\t}\n  \n  \t\t\t\t// convert 32-bit integers into output buffer\n  \t\t\t\tswitch ( mConfig.bitDepth )\n  \t\t\t\t{\n  \t\t\t\t\tcase 16:\n  \t\t\t\t\t\tout16 = &((int16_t *)sampleBuffer)[channelIndex];\n  \t\t\t\t\t\tfor ( i = 0, j = 0; i < numSamples; i++, j += numChannels )\n  \t\t\t\t\t\t\tout16[j] = (int16_t) mMixBufferU[i];\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\tcase 20:\n  \t\t\t\t\t\tout20 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n  \t\t\t\t\t\tcopyPredictorTo20( mMixBufferU, out20, numChannels, numSamples );\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\tcase 24:\n  \t\t\t\t\t\tout24 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n  \t\t\t\t\t\tif ( bytesShifted != 0 )\n  \t\t\t\t\t\t\tcopyPredictorTo24Shift( mMixBufferU, mShiftBuffer, out24, numChannels, numSamples, bytesShifted );\n  \t\t\t\t\t\telse\n  \t\t\t\t\t\t\tcopyPredictorTo24( mMixBufferU, out24, numChannels, numSamples );\t\t\t\t\t\t\t\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\tcase 32:\n  \t\t\t\t\t\tout32 = &((int32_t *)sampleBuffer)[channelIndex];\n  \t\t\t\t\t\tif ( bytesShifted != 0 )\n  \t\t\t\t\t\t\tcopyPredictorTo32Shift( mMixBufferU, mShiftBuffer, out32, numChannels, numSamples, bytesShifted );\n  \t\t\t\t\t\telse\n  \t\t\t\t\t\t\tcopyPredictorTo32( mMixBufferU, out32, numChannels, numSamples);\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t}\n  \n  \t\t\t\tchannelIndex += 1;\n  \t\t\t\t*outNumSamples = numSamples;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \n  \t\t\tcase ID_CPE:\n  \t\t\t{\n  \t\t\t\t// if decoding this pair would take us over the max channels limit, bail\n  \t\t\t\tif ( (channelIndex + 2) > numChannels )\n  \t\t\t\t\tgoto NoMoreChannels;\n  \n  \t\t\t\t// stereo channel pair\n  \t\t\t\telementInstanceTag = BitBufferReadSmall( bits, 4 );\n  \t\t\t\tmActiveElements |= (1u << elementInstanceTag);\n  \n  \t\t\t\t// read the 12 unused header bits\n  \t\t\t\tunusedHeader = (uint16_t) BitBufferRead( bits, 12 );\n  \t\t\t\tRequireAction( unusedHeader == 0, status = kALAC_ParamError; goto Exit; );\n  \n  \t\t\t\t// read the 1-bit \"partial frame\" flag, 2-bit \"shift-off\" flag & 1-bit \"escape\" flag\n  \t\t\t\theaderByte = (uint8_t) BitBufferRead( bits, 4 );\n  \t\t\t\t\n  \t\t\t\tpartialFrame = headerByte >> 3;\n  \t\t\t\t\n  \t\t\t\tbytesShifted = (headerByte >> 1) & 0x3u;\n  \t\t\t\tRequireAction( bytesShifted != 3, status = kALAC_ParamError; goto Exit; );\n  \n  \t\t\t\tshift = bytesShifted * 8;\n  \n  \t\t\t\tescapeFlag = headerByte & 0x1;\n  \n  \t\t\t\tchanBits = mConfig.bitDepth - (bytesShifted * 8) + 1;\n  \t\t\t\t\n  \t\t\t\t// check for partial frame length to override requested numSamples\n  \t\t\t\tif ( partialFrame != 0 )\n  \t\t\t\t{\n  \t\t\t\t\tnumSamples  = BitBufferRead( bits, 16 ) << 16;\n  \t\t\t\t\tnumSamples |= BitBufferRead( bits, 16 );\n  \t\t\t\t}\n  \n  \t\t\t\tif ( escapeFlag == 0 )\n  \t\t\t\t{\n  \t\t\t\t\t// compressed frame, read rest of parameters\n  \t\t\t\t\tmixBits\t\t= (uint8_t) BitBufferRead( bits, 8 );\n  \t\t\t\t\tmixRes\t\t= (int8_t) BitBufferRead( bits, 8 );\n  \n  \t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n  \t\t\t\t\tmodeU\t\t= headerByte >> 4;\n  \t\t\t\t\tdenShiftU\t= headerByte & 0xfu;\n  \t\t\t\t\t\n  \t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n  \t\t\t\t\tpbFactorU\t= headerByte >> 5;\n  \t\t\t\t\tnumU\t\t= headerByte & 0x1fu;\n  \t\t\t\t\tfor ( i = 0; i < numU; i++ )\n  \t\t\t\t\t\tcoefsU[i] = (int16_t) BitBufferRead( bits, 16 );\n  \n  \t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n  \t\t\t\t\tmodeV\t\t= headerByte >> 4;\n  \t\t\t\t\tdenShiftV\t= headerByte & 0xfu;\n  \t\t\t\t\t\n  \t\t\t\t\theaderByte\t= (uint8_t) BitBufferRead( bits, 8 );\n  \t\t\t\t\tpbFactorV\t= headerByte >> 5;\n  \t\t\t\t\tnumV\t\t= headerByte & 0x1fu;\n  \t\t\t\t\tfor ( i = 0; i < numV; i++ )\n  \t\t\t\t\t\tcoefsV[i] = (int16_t) BitBufferRead( bits, 16 );\n  \n  \t\t\t\t\t// if shift active, skip the interleaved shifted values but remember where they start\n  \t\t\t\t\tif ( bytesShifted != 0 )\n  \t\t\t\t\t{\n  \t\t\t\t\t\tshiftBits = *bits;\n  \t\t\t\t\t\tBitBufferAdvance( bits, (bytesShifted * 8) * 2 * numSamples );\n  \t\t\t\t\t}\n  \n  \t\t\t\t\t// decompress and run predictor for \"left\" channel\n  \t\t\t\t\tset_ag_params( &agParams, mConfig.mb, (pb * pbFactorU) / 4, mConfig.kb, numSamples, numSamples, mConfig.maxRun );\n  \t\t\t\t\tstatus = dyn_decomp( &agParams, bits, mPredictor, numSamples, chanBits, &bits1 );\n  \t\t\t\t\tRequireNoErr( status, goto Exit; );\n  \n  \t\t\t\t\tif ( modeU == 0 )\n  \t\t\t\t\t{\n  \t\t\t\t\t\tunpc_block( mPredictor, mMixBufferU, numSamples, &coefsU[0], numU, chanBits, denShiftU );\n  \t\t\t\t\t}\n  \t\t\t\t\telse\n  \t\t\t\t\t{\n  \t\t\t\t\t\t// the special \"numActive == 31\" mode can be done in-place\n  \t\t\t\t\t\tunpc_block( mPredictor, mPredictor, numSamples, nil, 31, chanBits, 0 );\n  \t\t\t\t\t\tunpc_block( mPredictor, mMixBufferU, numSamples, &coefsU[0], numU, chanBits, denShiftU );\n  \t\t\t\t\t}\n  \n  \t\t\t\t\t// decompress and run predictor for \"right\" channel\n  \t\t\t\t\tset_ag_params( &agParams, mConfig.mb, (pb * pbFactorV) / 4, mConfig.kb, numSamples, numSamples, mConfig.maxRun );\n  \t\t\t\t\tstatus = dyn_decomp( &agParams, bits, mPredictor, numSamples, chanBits, &bits2 );\n  \t\t\t\t\tRequireNoErr( status, goto Exit; );\n  \n  \t\t\t\t\tif ( modeV == 0 )\n  \t\t\t\t\t{\n  \t\t\t\t\t\tunpc_block( mPredictor, mMixBufferV, numSamples, &coefsV[0], numV, chanBits, denShiftV );\n  \t\t\t\t\t}\n  \t\t\t\t\telse\n  \t\t\t\t\t{\n  \t\t\t\t\t\t// the special \"numActive == 31\" mode can be done in-place\n  \t\t\t\t\t\tunpc_block( mPredictor, mPredictor, numSamples, nil, 31, chanBits, 0 );\n  \t\t\t\t\t\tunpc_block( mPredictor, mMixBufferV, numSamples, &coefsV[0], numV, chanBits, denShiftV );\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t{\n  \t\t\t\t\t//Assert( bytesShifted == 0 );\n  \n  \t\t\t\t\t// uncompressed frame, copy data into the mix buffers to use common output code\n  \t\t\t\t\tchanBits = mConfig.bitDepth;\n  \t\t\t\t\tshift = 32 - chanBits;\n  \t\t\t\t\tif ( chanBits <= 16 )\n  \t\t\t\t\t{\n  \t\t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n  \t\t\t\t\t\t{\n  \t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, (uint8_t) chanBits );\n  \t\t\t\t\t\t\tval = (val << shift) >> shift;\n  \t\t\t\t\t\t\tmMixBufferU[i] = val;\n  \n  \t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, (uint8_t) chanBits );\n  \t\t\t\t\t\t\tval = (val << shift) >> shift;\n  \t\t\t\t\t\t\tmMixBufferV[i] = val;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t\telse\n  \t\t\t\t\t{\n  \t\t\t\t\t\t// BitBufferRead() can't read more than 16 bits at a time so break up the reads\n  \t\t\t\t\t\textraBits = chanBits - 16;\n  \t\t\t\t\t\tfor ( i = 0; i < numSamples; i++ )\n  \t\t\t\t\t\t{\n  \t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, 16 );\n  \t\t\t\t\t\t\tval = (val << 16) >> shift;\n  \t\t\t\t\t\t\tmMixBufferU[i] = val | BitBufferRead( bits, (uint8_t)extraBits );\n  \n  \t\t\t\t\t\t\tval = (int32_t) BitBufferRead( bits, 16 );\n  \t\t\t\t\t\t\tval = (val << 16) >> shift;\n  \t\t\t\t\t\t\tmMixBufferV[i] = val | BitBufferRead( bits, (uint8_t)extraBits );\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \n  \t\t\t\t\tbits1 = chanBits * numSamples;\n  \t\t\t\t\tbits2 = chanBits * numSamples;\n  \t\t\t\t\tmixBits = mixRes = 0;\n  \t\t\t\t\tbytesShifted = 0;\n  \t\t\t\t}\n  \n  \t\t\t\t// now read the shifted values into the shift buffer\n  \t\t\t\tif ( bytesShifted != 0 )\n  \t\t\t\t{\n  \t\t\t\t\tshift = bytesShifted * 8;\n  \t\t\t\t\t//Assert( shift <= 16 );\n  \n  \t\t\t\t\tfor ( i = 0; i < (numSamples * 2); i += 2 )\n  \t\t\t\t\t{\n  \t\t\t\t\t\tmShiftBuffer[i + 0] = (uint16_t) BitBufferRead( &shiftBits, (uint8_t) shift );\n  \t\t\t\t\t\tmShiftBuffer[i + 1] = (uint16_t) BitBufferRead( &shiftBits, (uint8_t) shift );\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \n  \t\t\t\t// un-mix the data and convert to output format\n  \t\t\t\t// - note that mixRes = 0 means just interleave so we use that path for uncompressed frames\n  \t\t\t\tswitch ( mConfig.bitDepth )\n  \t\t\t\t{\n  \t\t\t\t\tcase 16:\n  \t\t\t\t\t\tout16 = &((int16_t *)sampleBuffer)[channelIndex];\n  \t\t\t\t\t\tunmix16( mMixBufferU, mMixBufferV, out16, numChannels, numSamples, mixBits, mixRes );\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\tcase 20:\n  \t\t\t\t\t\tout20 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n  \t\t\t\t\t\tunmix20( mMixBufferU, mMixBufferV, out20, numChannels, numSamples, mixBits, mixRes );\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\tcase 24:\n  \t\t\t\t\t\tout24 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n  \t\t\t\t\t\tunmix24( mMixBufferU, mMixBufferV, out24, numChannels, numSamples,\n  \t\t\t\t\t\t\t\t\tmixBits, mixRes, mShiftBuffer, bytesShifted );\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\tcase 32:\n  \t\t\t\t\t\tout32 = &((int32_t *)sampleBuffer)[channelIndex];\n  \t\t\t\t\t\tunmix32( mMixBufferU, mMixBufferV, out32, numChannels, numSamples,\n  \t\t\t\t\t\t\t\t\tmixBits, mixRes, mShiftBuffer, bytesShifted );\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t}\n  \n  \t\t\t\tchannelIndex += 2;\n  \t\t\t\t*outNumSamples = numSamples;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \n  \t\t\tcase ID_CCE:\n  \t\t\tcase ID_PCE:\n  \t\t\t{\n  \t\t\t\t// unsupported element, bail\n  \t\t\t\t//AssertNoErr( tag );\n  \t\t\t\tstatus = kALAC_ParamError;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \n  \t\t\tcase ID_DSE:\n  \t\t\t{\n  \t\t\t\t// data stream element -- parse but ignore\n  \t\t\t\tstatus = this->DataStreamElement( bits );\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\t\n  \t\t\tcase ID_FIL:\n  \t\t\t{\n  \t\t\t\t// fill element -- parse but ignore\n  \t\t\t\tstatus = this->FillElement( bits );\n  \t\t\t\tbreak;\n  \t\t\t}\n  \n  \t\t\tcase ID_END:\n  \t\t\t{\n  \t\t\t\t// frame end, all done so byte align the frame and check for overruns\n  \t\t\t\tBitBufferByteAlign( bits, false );\n  \t\t\t\t//Assert( bits->cur == bits->end );\n  \t\t\t\tgoto Exit;\n  \t\t\t}\n  \t\t}\n  \n  #if ! DEBUG\n  \t\t// if we've decoded all of our channels, bail (but not in debug b/c we want to know if we're seeing bad bits)\n  \t\t// - this also protects us if the config does not match the bitstream or crap data bits follow the audio bits\n  \t\tif ( channelIndex >= numChannels )\n  \t\t\tbreak;\n  #endif\n  \t}\n  \n  NoMoreChannels:\n  \n  \t// if we get here and haven't decoded all of the requested channels, fill the remaining channels with zeros\n  \tfor ( ; channelIndex < numChannels; channelIndex++ )\n  \t{\n  \t\tswitch ( mConfig.bitDepth )\n  \t\t{\n  \t\t\tcase 16:\n  \t\t\t{\n  \t\t\t\tint16_t *\tfill16 = &((int16_t *)sampleBuffer)[channelIndex];\n  \t\t\t\tZero16( fill16, numSamples, numChannels );\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tcase 24:\n  \t\t\t{\n  \t\t\t\tuint8_t *\tfill24 = (uint8_t *)sampleBuffer + (channelIndex * 3);\n  \t\t\t\tZero24( fill24, numSamples, numChannels );\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tcase 32:\n  \t\t\t{\n  \t\t\t\tint32_t *\tfill32 = &((int32_t *)sampleBuffer)[channelIndex];\n  \t\t\t\tZero32( fill32, numSamples, numChannels );\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t}\n  \n  Exit:\n  \treturn status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<uint8_t *>",
          "args": [
            "m_outChunk->buffer"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferInit",
          "args": [
            "&bitBuffer",
            "static_cast<uint8_t *>(m_inChunk->buffer)",
            "bytesPerPacket"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint8_t *>",
          "args": [
            "m_inChunk->buffer"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reportReadError",
          "args": [
            "0",
            "m_track->f.framesPerPacket"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "reportReadError",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "76-88",
          "snippet": "void FileModule::reportReadError(AFframecount framesRead,\n\tAFframecount framesToRead)\n{\n\t// Report error if we haven't already.\n\tif (!m_track->filemodhappy)\n\t\treturn;\n\n\t_af_error(AF_BAD_READ,\n\t\t\"file missing data -- read %jd frames, should be %jd\",\n\t\tstatic_cast<intmax_t>(m_track->nextfframe),\n\t\tstatic_cast<intmax_t>(m_track->totalfframes));\n\tm_track->filemodhappy = false;\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  void FileModule::reportReadError(AFframecount framesRead,\n  \tAFframecount framesToRead)\n  {\n  \t// Report error if we haven't already.\n  \tif (!m_track->filemodhappy)\n  \t\treturn;\n  \n  \t_af_error(AF_BAD_READ,\n  \t\t\"file missing data -- read %jd frames, should be %jd\",\n  \t\tstatic_cast<intmax_t>(m_track->nextfframe),\n  \t\tstatic_cast<intmax_t>(m_track->totalfframes));\n  \tm_track->filemodhappy = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "m_inChunk->buffer",
            "bytesPerPacket"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "40-48",
          "snippet": "ssize_t FileModule::read(void *data, size_t nbytes)\n{\n\tssize_t bytesRead = m_fh->read(data, nbytes);\n\tif (bytesRead > 0)\n\t{\n\t\tm_track->fpos_next_frame += bytesRead;\n\t}\n\treturn bytesRead;\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  ssize_t FileModule::read(void *data, size_t nbytes)\n  {\n  \tssize_t bytesRead = m_fh->read(data, nbytes);\n  \tif (bytesRead > 0)\n  \t{\n  \t\tm_track->fpos_next_frame += bytesRead;\n  \t}\n  \treturn bytesRead;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "bytesPerPacket <= bufferSize()"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bufferSize",
          "args": [],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "bufferSize",
          "container": "ALAC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
          "lines": "273-277",
          "snippet": "int ALAC::bufferSize() const\n{\n\treturn m_track->f.framesPerPacket * m_track->f.channelCount *\n\t\t((10 + m_track->f.sampleWidth) / 8) + 1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"../alac/ALACEncoder.h\"",
            "#include \"../alac/ALACDecoder.h\"",
            "#include \"../alac/ALACBitUtilities.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"PacketTable.h\"",
            "#include \"FileModule.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"Buffer.h\"",
            "#include \"ALAC.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  int ALAC::bufferSize() const\n  {\n  \treturn m_track->f.framesPerPacket * m_track->f.channelCount *\n  \t\t((10 + m_track->f.sampleWidth) / 8) + 1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "packetTable->bytesPerPacket",
          "args": [
            "m_currentPacket"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "bytesPerPacket",
          "container": "PacketTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/PacketTable.h",
          "lines": "50-50",
          "snippet": "size_t bytesPerPacket(size_t packet) const { return m_bytesPerPacket[packet]; }",
          "includes": [
            "#include <vector>",
            "#include <sys/types.h>",
            "#include <stdint.h>",
            "#include <audiofile.h>",
            "#include \"Shared.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <sys/types.h>\n#include <stdint.h>\n#include <audiofile.h>\n#include \"Shared.h\"\n\nPacketTable {\n  size_t bytesPerPacket(size_t packet) const { return m_bytesPerPacket[packet]; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_currentPacket < static_cast<int>(packetTable->numPackets())"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<int>",
          "args": [
            "packetTable->numPackets()"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packetTable->numPackets",
          "args": [],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "numPackets",
          "container": "PacketTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/PacketTable.h",
          "lines": "41-41",
          "snippet": "size_t numPackets() const { return m_bytesPerPacket.size(); }",
          "includes": [
            "#include <vector>",
            "#include <sys/types.h>",
            "#include <stdint.h>",
            "#include <audiofile.h>",
            "#include \"Shared.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <sys/types.h>\n#include <stdint.h>\n#include <audiofile.h>\n#include \"Shared.h\"\n\nPacketTable {\n  size_t numPackets() const { return m_bytesPerPacket.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<int>",
          "args": [
            "packetTable->numPackets()"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  void ALAC::runPull()\n  {\n  \tSharedPtr<PacketTable> packetTable = m_track->m_packetTable;\n  \tif (m_currentPacket >= static_cast<int>(packetTable->numPackets()))\n  \t{\n  \t\tm_outChunk->frameCount = 0;\n  \t\treturn;\n  \t}\n  \tassert(m_currentPacket < static_cast<int>(packetTable->numPackets()));\n  \n  \tssize_t bytesPerPacket = packetTable->bytesPerPacket(m_currentPacket);\n  \tassert(bytesPerPacket <= bufferSize());\n  \n  \tif (read(m_inChunk->buffer, bytesPerPacket) < bytesPerPacket)\n  \t{\n  \t\treportReadError(0, m_track->f.framesPerPacket);\n  \t\treturn;\n  \t}\n  \n  \tBitBuffer bitBuffer;\n  \tBitBufferInit(&bitBuffer, static_cast<uint8_t *>(m_inChunk->buffer),\n  \t\tbytesPerPacket);\n  \n  \tuint32_t numFrames;\n  \tm_decoder->Decode(&bitBuffer, static_cast<uint8_t *>(m_outChunk->buffer),\n  \t\tm_track->f.framesPerPacket, m_track->f.channelCount, &numFrames);\n  \tm_outChunk->frameCount = numFrames;\n  \n  \tm_currentPacket++;\n  }\n}"
  },
  {
    "function_name": "describe",
    "container": "ALAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
    "lines": "162-167",
    "snippet": "void ALAC::describe()\n{\n\tm_outChunk->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\tm_outChunk->f.compressionType = AF_COMPRESSION_NONE;\n\tm_outChunk->f.compressionParams = AU_NULL_PVLIST;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"../alac/ALACEncoder.h\"",
      "#include \"../alac/ALACDecoder.h\"",
      "#include \"../alac/ALACBitUtilities.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"PacketTable.h\"",
      "#include \"FileModule.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"Buffer.h\"",
      "#include \"ALAC.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  void ALAC::describe()\n  {\n  \tm_outChunk->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \tm_outChunk->f.compressionType = AF_COMPRESSION_NONE;\n  \tm_outChunk->f.compressionParams = AU_NULL_PVLIST;\n  }\n}"
  },
  {
    "function_name": "outputFormat",
    "container": "ALAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
    "lines": "135-160",
    "snippet": "AudioFormatDescription ALAC::outputFormat() const\n{\n\tAudioFormatDescription outputFormat;\n\toutputFormat.mSampleRate = m_track->f.sampleRate;\n\toutputFormat.mFormatID = kALACFormatAppleLossless;\n\tswitch (m_track->f.sampleWidth)\n\t{\n\t\tcase 16:\n\t\t\toutputFormat.mFormatFlags = kALACFormatFlag_16BitSourceData; break;\n\t\tcase 20:\n\t\t\toutputFormat.mFormatFlags = kALACFormatFlag_20BitSourceData; break;\n\t\tcase 24:\n\t\t\toutputFormat.mFormatFlags = kALACFormatFlag_24BitSourceData; break;\n\t\tcase 32:\n\t\t\toutputFormat.mFormatFlags = kALACFormatFlag_32BitSourceData; break;\n\t\tdefault:\n\t\t\toutputFormat.mFormatFlags = 0; break;\n\t}\n\toutputFormat.mFramesPerPacket = m_track->f.framesPerPacket;\n\toutputFormat.mChannelsPerFrame = m_track->f.channelCount;\n\toutputFormat.mBytesPerPacket = 0;\n\toutputFormat.mBytesPerFrame = 0;\n\toutputFormat.mBitsPerChannel = 0;\n\toutputFormat.mReserved = 0;\n\treturn outputFormat;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"../alac/ALACEncoder.h\"",
      "#include \"../alac/ALACDecoder.h\"",
      "#include \"../alac/ALACBitUtilities.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"PacketTable.h\"",
      "#include \"FileModule.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"Buffer.h\"",
      "#include \"ALAC.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  AudioFormatDescription ALAC::outputFormat() const\n  {\n  \tAudioFormatDescription outputFormat;\n  \toutputFormat.mSampleRate = m_track->f.sampleRate;\n  \toutputFormat.mFormatID = kALACFormatAppleLossless;\n  \tswitch (m_track->f.sampleWidth)\n  \t{\n  \t\tcase 16:\n  \t\t\toutputFormat.mFormatFlags = kALACFormatFlag_16BitSourceData; break;\n  \t\tcase 20:\n  \t\t\toutputFormat.mFormatFlags = kALACFormatFlag_20BitSourceData; break;\n  \t\tcase 24:\n  \t\t\toutputFormat.mFormatFlags = kALACFormatFlag_24BitSourceData; break;\n  \t\tcase 32:\n  \t\t\toutputFormat.mFormatFlags = kALACFormatFlag_32BitSourceData; break;\n  \t\tdefault:\n  \t\t\toutputFormat.mFormatFlags = 0; break;\n  \t}\n  \toutputFormat.mFramesPerPacket = m_track->f.framesPerPacket;\n  \toutputFormat.mChannelsPerFrame = m_track->f.channelCount;\n  \toutputFormat.mBytesPerPacket = 0;\n  \toutputFormat.mBytesPerFrame = 0;\n  \toutputFormat.mBitsPerChannel = 0;\n  \toutputFormat.mReserved = 0;\n  \treturn outputFormat;\n  }\n}"
  },
  {
    "function_name": "initEncoder",
    "container": "ALAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
    "lines": "120-133",
    "snippet": "void ALAC::initEncoder()\n{\n\tm_encoder = new ALACEncoder();\n\tm_encoder->SetFrameSize(m_track->f.framesPerPacket);\n\tm_encoder->InitializeEncoder(outputFormat());\n\n\tuint32_t cookieSize = m_encoder->GetMagicCookieSize(m_track->f.channelCount);\n\tassert(cookieSize == m_codecData->size());\n\tm_encoder->GetMagicCookie(m_codecData->data(), &cookieSize);\n\n\tvoid *v = NULL;\n\t_af_pv_getptr(m_track->f.compressionParams, _AF_CODEC_DATA, &v);\n\t::memcpy(v, m_codecData->data(), cookieSize);\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"../alac/ALACEncoder.h\"",
      "#include \"../alac/ALACDecoder.h\"",
      "#include \"../alac/ALACBitUtilities.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"PacketTable.h\"",
      "#include \"FileModule.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"Buffer.h\"",
      "#include \"ALAC.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "::memcpy",
          "args": [
            "v",
            "m_codecData->data()",
            "cookieSize"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_codecData->data",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_pv_getptr",
          "args": [
            "m_track->f.compressionParams",
            "_AF_CODEC_DATA",
            "&v"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "_af_pv_getptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "239-261",
          "snippet": "bool _af_pv_getptr (AUpvlist pvlist, int param, void **v)\n{\n\tfor (int i=0; i<AUpvgetmaxitems(pvlist); i++)\n\t{\n\t\tint\tp, t;\n\n\t\tAUpvgetparam(pvlist, i, &p);\n\n\t\tif (p != param)\n\t\t\tcontinue;\n\n\t\tAUpvgetvaltype(pvlist, i, &t);\n\n\t\t/* Ensure that this parameter is of type AU_PVTYPE_PTR. */\n\t\tif (t != AU_PVTYPE_PTR)\n\t\t\treturn false;\n\n\t\tAUpvgetval(pvlist, i, v);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nbool _af_pv_getptr (AUpvlist pvlist, int param, void **v)\n{\n\tfor (int i=0; i<AUpvgetmaxitems(pvlist); i++)\n\t{\n\t\tint\tp, t;\n\n\t\tAUpvgetparam(pvlist, i, &p);\n\n\t\tif (p != param)\n\t\t\tcontinue;\n\n\t\tAUpvgetvaltype(pvlist, i, &t);\n\n\t\t/* Ensure that this parameter is of type AU_PVTYPE_PTR. */\n\t\tif (t != AU_PVTYPE_PTR)\n\t\t\treturn false;\n\n\t\tAUpvgetval(pvlist, i, v);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_encoder->GetMagicCookie",
          "args": [
            "m_codecData->data()",
            "&cookieSize"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "GetMagicCookie",
          "container": "ALACEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
          "lines": "1210-1241",
          "snippet": "void ALACEncoder::GetMagicCookie(void * outCookie, uint32_t * ioSize)\n{\n    ALACSpecificConfig theConfig = {0};\n    ALACAudioChannelLayout theChannelLayout = {0};\n    uint8_t theChannelAtom[kChannelAtomSize] = {0, 0, 0, 0, 'c', 'h', 'a', 'n', 0, 0, 0, 0};\n    uint32_t theCookieSize = sizeof(ALACSpecificConfig);\n    uint8_t * theCookiePointer = (uint8_t *)outCookie;\n    \n    GetConfig(theConfig);\n    if (theConfig.numChannels > 2)\n    {\n        theChannelLayout.mChannelLayoutTag = Swap32NtoB(ALACChannelLayoutTags[theConfig.numChannels - 1]);\n        theCookieSize += (sizeof(ALACAudioChannelLayout) + kChannelAtomSize);\n    }\n     if (*ioSize >= theCookieSize)\n    {\n        memcpy(theCookiePointer, &theConfig, sizeof(ALACSpecificConfig));\n        theChannelAtom[3] = (sizeof(ALACAudioChannelLayout) + kChannelAtomSize);\n        if (theConfig.numChannels > 2)\n        {\n            theCookiePointer += sizeof(ALACSpecificConfig);\n            memcpy(theCookiePointer, theChannelAtom, kChannelAtomSize);\n            theCookiePointer += kChannelAtomSize;\n            memcpy(theCookiePointer, &theChannelLayout, sizeof(ALACAudioChannelLayout));\n        }\n        *ioSize = theCookieSize;\n    }\n    else\n    {\n        *ioSize = 0; // no incomplete cookies\n    }\n}",
          "includes": [
            "#include \"EndianPortable.h\"",
            "#include \"ALACAudioTypes.h\"",
            "#include \"ALACBitUtilities.h\"",
            "#include \"matrixlib.h\"",
            "#include \"dplib.h\"",
            "#include \"aglib.h\"",
            "#include \"ALACEncoder.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nALACEncoder {\n  void ALACEncoder::GetMagicCookie(void * outCookie, uint32_t * ioSize)\n  {\n      ALACSpecificConfig theConfig = {0};\n      ALACAudioChannelLayout theChannelLayout = {0};\n      uint8_t theChannelAtom[kChannelAtomSize] = {0, 0, 0, 0, 'c', 'h', 'a', 'n', 0, 0, 0, 0};\n      uint32_t theCookieSize = sizeof(ALACSpecificConfig);\n      uint8_t * theCookiePointer = (uint8_t *)outCookie;\n      \n      GetConfig(theConfig);\n      if (theConfig.numChannels > 2)\n      {\n          theChannelLayout.mChannelLayoutTag = Swap32NtoB(ALACChannelLayoutTags[theConfig.numChannels - 1]);\n          theCookieSize += (sizeof(ALACAudioChannelLayout) + kChannelAtomSize);\n      }\n       if (*ioSize >= theCookieSize)\n      {\n          memcpy(theCookiePointer, &theConfig, sizeof(ALACSpecificConfig));\n          theChannelAtom[3] = (sizeof(ALACAudioChannelLayout) + kChannelAtomSize);\n          if (theConfig.numChannels > 2)\n          {\n              theCookiePointer += sizeof(ALACSpecificConfig);\n              memcpy(theCookiePointer, theChannelAtom, kChannelAtomSize);\n              theCookiePointer += kChannelAtomSize;\n              memcpy(theCookiePointer, &theChannelLayout, sizeof(ALACAudioChannelLayout));\n          }\n          *ioSize = theCookieSize;\n      }\n      else\n      {\n          *ioSize = 0; // no incomplete cookies\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_codecData->data",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cookieSize == m_codecData->size()"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_codecData->size",
          "args": [],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Buffer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Buffer.h",
          "lines": "39-39",
          "snippet": "size_t size() const { return m_size; }",
          "includes": [
            "#include <sys/types.h>",
            "#include \"Shared.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"Shared.h\"\n\nBuffer {\n  size_t size() const { return m_size; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_encoder->GetMagicCookieSize",
          "args": [
            "m_track->f.channelCount"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "GetMagicCookieSize",
          "container": "ALACEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
          "lines": "1198-1208",
          "snippet": "uint32_t ALACEncoder::GetMagicCookieSize(uint32_t inNumChannels)\n{\n    if (inNumChannels > 2)\n    {\n        return sizeof(ALACSpecificConfig) + kChannelAtomSize + sizeof(ALACAudioChannelLayout);\n    }\n    else\n    {\n        return sizeof(ALACSpecificConfig);\n    }\n}",
          "includes": [
            "#include \"EndianPortable.h\"",
            "#include \"ALACAudioTypes.h\"",
            "#include \"ALACBitUtilities.h\"",
            "#include \"matrixlib.h\"",
            "#include \"dplib.h\"",
            "#include \"aglib.h\"",
            "#include \"ALACEncoder.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nALACEncoder {\n  uint32_t ALACEncoder::GetMagicCookieSize(uint32_t inNumChannels)\n  {\n      if (inNumChannels > 2)\n      {\n          return sizeof(ALACSpecificConfig) + kChannelAtomSize + sizeof(ALACAudioChannelLayout);\n      }\n      else\n      {\n          return sizeof(ALACSpecificConfig);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_encoder->InitializeEncoder",
          "args": [
            "outputFormat()"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "InitializeEncoder",
          "container": "ALACEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
          "lines": "1247-1315",
          "snippet": "int32_t ALACEncoder::InitializeEncoder(AudioFormatDescription theOutputFormat)\n{\n\tint32_t\t\t\tstatus;\n    \n    mOutputSampleRate = theOutputFormat.mSampleRate;\n    mNumChannels = theOutputFormat.mChannelsPerFrame;\n    switch(theOutputFormat.mFormatFlags)\n    {\n        case 1:\n            mBitDepth = 16;\n            break;\n        case 2:\n            mBitDepth = 20;\n            break;\n        case 3:\n            mBitDepth = 24;\n            break;\n        case 4:\n            mBitDepth = 32;\n            break;\n        default:\n            break;\n    }\n\n\t// set up default encoding parameters and state\n\t// - note: mFrameSize is set in the constructor or via SetFrameSize() which must be called before this routine\n\tfor ( uint32_t index = 0; index < kALACMaxChannels; index++ )\n\t\tmLastMixRes[index] = kDefaultMixRes;\n\n\t// the maximum output frame size can be no bigger than (samplesPerBlock * numChannels * ((10 + sampleSize)/8) + 1)\n\t// but note that this can be bigger than the input size!\n\t// - since we don't yet know what our input format will be, use our max allowed sample size in the calculation\n\tmMaxOutputBytes = mFrameSize * mNumChannels * ((10 + kMaxSampleSize) / 8)  + 1;\n\n\t// allocate mix buffers\n\tmMixBufferU = (int32_t *) calloc( mFrameSize * sizeof(int32_t), 1 );\n\tmMixBufferV = (int32_t *) calloc( mFrameSize * sizeof(int32_t), 1 );\n\n\t// allocate dynamic predictor buffers\n\tmPredictorU = (int32_t *) calloc( mFrameSize * sizeof(int32_t), 1 );\n\tmPredictorV = (int32_t *) calloc( mFrameSize * sizeof(int32_t), 1 );\n\t\n\t// allocate combined shift buffer\n\tmShiftBufferUV = (uint16_t *) calloc( mFrameSize * 2 * sizeof(uint16_t),1 );\n\t\n\t// allocate work buffer for search loop\n\tmWorkBuffer = (uint8_t *) calloc( mMaxOutputBytes, 1 );\n\n\tRequireAction( (mMixBufferU != nil) && (mMixBufferV != nil) &&\n\t\t\t\t\t(mPredictorU != nil) && (mPredictorV != nil) &&\n\t\t\t\t\t(mShiftBufferUV != nil) && (mWorkBuffer != nil ),\n\t\t\t\t\tstatus = kALAC_MemFullError; goto Exit; );\n\n\tstatus = ALAC_noErr;\n\n\n\t// initialize coefs arrays once b/c retaining state across blocks actually improves the encode ratio\n\tfor ( int32_t channel = 0; channel < (int32_t)mNumChannels; channel++ )\n\t{\n\t\tfor ( int32_t search = 0; search < kALACMaxSearches; search++ )\n\t\t{\n\t\t\tinit_coefs( mCoefsU[channel][search], DENSHIFT_DEFAULT, kALACMaxCoefs );\n\t\t\tinit_coefs( mCoefsV[channel][search], DENSHIFT_DEFAULT, kALACMaxCoefs );\n\t\t}\n\t}\n\nExit:\n\treturn status;\n}",
          "includes": [
            "#include \"EndianPortable.h\"",
            "#include \"ALACAudioTypes.h\"",
            "#include \"ALACBitUtilities.h\"",
            "#include \"matrixlib.h\"",
            "#include \"dplib.h\"",
            "#include \"aglib.h\"",
            "#include \"ALACEncoder.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const uint32_t kMaxSampleSize\t\t= 32;",
            "const uint32_t kDefaultMixRes\t\t= 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nconst uint32_t kMaxSampleSize\t\t= 32;\nconst uint32_t kDefaultMixRes\t\t= 0;\n\nALACEncoder {\n  int32_t ALACEncoder::InitializeEncoder(AudioFormatDescription theOutputFormat)\n  {\n  \tint32_t\t\t\tstatus;\n      \n      mOutputSampleRate = theOutputFormat.mSampleRate;\n      mNumChannels = theOutputFormat.mChannelsPerFrame;\n      switch(theOutputFormat.mFormatFlags)\n      {\n          case 1:\n              mBitDepth = 16;\n              break;\n          case 2:\n              mBitDepth = 20;\n              break;\n          case 3:\n              mBitDepth = 24;\n              break;\n          case 4:\n              mBitDepth = 32;\n              break;\n          default:\n              break;\n      }\n  \n  \t// set up default encoding parameters and state\n  \t// - note: mFrameSize is set in the constructor or via SetFrameSize() which must be called before this routine\n  \tfor ( uint32_t index = 0; index < kALACMaxChannels; index++ )\n  \t\tmLastMixRes[index] = kDefaultMixRes;\n  \n  \t// the maximum output frame size can be no bigger than (samplesPerBlock * numChannels * ((10 + sampleSize)/8) + 1)\n  \t// but note that this can be bigger than the input size!\n  \t// - since we don't yet know what our input format will be, use our max allowed sample size in the calculation\n  \tmMaxOutputBytes = mFrameSize * mNumChannels * ((10 + kMaxSampleSize) / 8)  + 1;\n  \n  \t// allocate mix buffers\n  \tmMixBufferU = (int32_t *) calloc( mFrameSize * sizeof(int32_t), 1 );\n  \tmMixBufferV = (int32_t *) calloc( mFrameSize * sizeof(int32_t), 1 );\n  \n  \t// allocate dynamic predictor buffers\n  \tmPredictorU = (int32_t *) calloc( mFrameSize * sizeof(int32_t), 1 );\n  \tmPredictorV = (int32_t *) calloc( mFrameSize * sizeof(int32_t), 1 );\n  \t\n  \t// allocate combined shift buffer\n  \tmShiftBufferUV = (uint16_t *) calloc( mFrameSize * 2 * sizeof(uint16_t),1 );\n  \t\n  \t// allocate work buffer for search loop\n  \tmWorkBuffer = (uint8_t *) calloc( mMaxOutputBytes, 1 );\n  \n  \tRequireAction( (mMixBufferU != nil) && (mMixBufferV != nil) &&\n  \t\t\t\t\t(mPredictorU != nil) && (mPredictorV != nil) &&\n  \t\t\t\t\t(mShiftBufferUV != nil) && (mWorkBuffer != nil ),\n  \t\t\t\t\tstatus = kALAC_MemFullError; goto Exit; );\n  \n  \tstatus = ALAC_noErr;\n  \n  \n  \t// initialize coefs arrays once b/c retaining state across blocks actually improves the encode ratio\n  \tfor ( int32_t channel = 0; channel < (int32_t)mNumChannels; channel++ )\n  \t{\n  \t\tfor ( int32_t search = 0; search < kALACMaxSearches; search++ )\n  \t\t{\n  \t\t\tinit_coefs( mCoefsU[channel][search], DENSHIFT_DEFAULT, kALACMaxCoefs );\n  \t\t\tinit_coefs( mCoefsV[channel][search], DENSHIFT_DEFAULT, kALACMaxCoefs );\n  \t\t}\n  \t}\n  \n  Exit:\n  \treturn status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "outputFormat",
          "args": [],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "outputFormat",
          "container": "ALAC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
          "lines": "135-160",
          "snippet": "AudioFormatDescription ALAC::outputFormat() const\n{\n\tAudioFormatDescription outputFormat;\n\toutputFormat.mSampleRate = m_track->f.sampleRate;\n\toutputFormat.mFormatID = kALACFormatAppleLossless;\n\tswitch (m_track->f.sampleWidth)\n\t{\n\t\tcase 16:\n\t\t\toutputFormat.mFormatFlags = kALACFormatFlag_16BitSourceData; break;\n\t\tcase 20:\n\t\t\toutputFormat.mFormatFlags = kALACFormatFlag_20BitSourceData; break;\n\t\tcase 24:\n\t\t\toutputFormat.mFormatFlags = kALACFormatFlag_24BitSourceData; break;\n\t\tcase 32:\n\t\t\toutputFormat.mFormatFlags = kALACFormatFlag_32BitSourceData; break;\n\t\tdefault:\n\t\t\toutputFormat.mFormatFlags = 0; break;\n\t}\n\toutputFormat.mFramesPerPacket = m_track->f.framesPerPacket;\n\toutputFormat.mChannelsPerFrame = m_track->f.channelCount;\n\toutputFormat.mBytesPerPacket = 0;\n\toutputFormat.mBytesPerFrame = 0;\n\toutputFormat.mBitsPerChannel = 0;\n\toutputFormat.mReserved = 0;\n\treturn outputFormat;\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"../alac/ALACEncoder.h\"",
            "#include \"../alac/ALACDecoder.h\"",
            "#include \"../alac/ALACBitUtilities.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"PacketTable.h\"",
            "#include \"FileModule.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"Buffer.h\"",
            "#include \"ALAC.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  AudioFormatDescription ALAC::outputFormat() const\n  {\n  \tAudioFormatDescription outputFormat;\n  \toutputFormat.mSampleRate = m_track->f.sampleRate;\n  \toutputFormat.mFormatID = kALACFormatAppleLossless;\n  \tswitch (m_track->f.sampleWidth)\n  \t{\n  \t\tcase 16:\n  \t\t\toutputFormat.mFormatFlags = kALACFormatFlag_16BitSourceData; break;\n  \t\tcase 20:\n  \t\t\toutputFormat.mFormatFlags = kALACFormatFlag_20BitSourceData; break;\n  \t\tcase 24:\n  \t\t\toutputFormat.mFormatFlags = kALACFormatFlag_24BitSourceData; break;\n  \t\tcase 32:\n  \t\t\toutputFormat.mFormatFlags = kALACFormatFlag_32BitSourceData; break;\n  \t\tdefault:\n  \t\t\toutputFormat.mFormatFlags = 0; break;\n  \t}\n  \toutputFormat.mFramesPerPacket = m_track->f.framesPerPacket;\n  \toutputFormat.mChannelsPerFrame = m_track->f.channelCount;\n  \toutputFormat.mBytesPerPacket = 0;\n  \toutputFormat.mBytesPerFrame = 0;\n  \toutputFormat.mBitsPerChannel = 0;\n  \toutputFormat.mReserved = 0;\n  \treturn outputFormat;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_encoder->SetFrameSize",
          "args": [
            "m_track->f.framesPerPacket"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "SetFrameSize",
          "container": "ALACEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.h",
          "lines": "47-47",
          "snippet": "void\t\t\t\tSetFrameSize( uint32_t frameSize ) { mFrameSize = frameSize; }",
          "includes": [
            "#include \"ALACAudioTypes.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ALACAudioTypes.h\"\n#include <stdint.h>\n\nALACEncoder {\n  void\t\t\t\tSetFrameSize( uint32_t frameSize ) { mFrameSize = frameSize; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  void ALAC::initEncoder()\n  {\n  \tm_encoder = new ALACEncoder();\n  \tm_encoder->SetFrameSize(m_track->f.framesPerPacket);\n  \tm_encoder->InitializeEncoder(outputFormat());\n  \n  \tuint32_t cookieSize = m_encoder->GetMagicCookieSize(m_track->f.channelCount);\n  \tassert(cookieSize == m_codecData->size());\n  \tm_encoder->GetMagicCookie(m_codecData->data(), &cookieSize);\n  \n  \tvoid *v = NULL;\n  \t_af_pv_getptr(m_track->f.compressionParams, _AF_CODEC_DATA, &v);\n  \t::memcpy(v, m_codecData->data(), cookieSize);\n  }\n}"
  },
  {
    "function_name": "initDecoder",
    "container": "ALAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
    "lines": "114-118",
    "snippet": "void ALAC::initDecoder()\n{\n\tm_decoder = new ALACDecoder();\n\tm_decoder->Init(m_codecData->data(), m_codecData->size());\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"../alac/ALACEncoder.h\"",
      "#include \"../alac/ALACDecoder.h\"",
      "#include \"../alac/ALACBitUtilities.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"PacketTable.h\"",
      "#include \"FileModule.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"Buffer.h\"",
      "#include \"ALAC.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_decoder->Init",
          "args": [
            "m_codecData->data()",
            "m_codecData->size()"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "Init",
          "container": "ALACDecoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACDecoder.cpp",
          "lines": "88-156",
          "snippet": "int32_t ALACDecoder::Init( void * inMagicCookie, uint32_t inMagicCookieSize )\n{\n\tint32_t\t\tstatus = ALAC_noErr;\n    ALACSpecificConfig theConfig;\n    uint8_t * theActualCookie = (uint8_t *)inMagicCookie;\n    uint32_t theCookieBytesRemaining = inMagicCookieSize;\n\n    // For historical reasons the decoder needs to be resilient to magic cookies vended by older encoders.\n    // As specified in the ALACMagicCookieDescription.txt document, there may be additional data encapsulating \n    // the ALACSpecificConfig. This would consist of format ('frma') and 'alac' atoms which precede the\n    // ALACSpecificConfig. \n    // See ALACMagicCookieDescription.txt for additional documentation concerning the 'magic cookie'\n    \n    // skip format ('frma') atom if present\n    if (theActualCookie[4] == 'f' && theActualCookie[5] == 'r' && theActualCookie[6] == 'm' && theActualCookie[7] == 'a')\n    {\n        theActualCookie += 12;\n        theCookieBytesRemaining -= 12;\n    }\n    \n    // skip 'alac' atom header if present\n    if (theActualCookie[4] == 'a' && theActualCookie[5] == 'l' && theActualCookie[6] == 'a' && theActualCookie[7] == 'c')\n    {\n        theActualCookie += 12;\n        theCookieBytesRemaining -= 12;\n    }\n\n    // read the ALACSpecificConfig\n    if (theCookieBytesRemaining >= sizeof(ALACSpecificConfig))\n    {\n        memcpy(&theConfig, theActualCookie, sizeof(ALACSpecificConfig));\n\n        theConfig.frameLength = Swap32BtoN(theConfig.frameLength);\n        theConfig.maxRun = Swap16BtoN(theConfig.maxRun);\n        theConfig.maxFrameBytes = Swap32BtoN(theConfig.maxFrameBytes);\n        theConfig.avgBitRate = Swap32BtoN(theConfig.avgBitRate);\n        theConfig.sampleRate = Swap32BtoN(theConfig.sampleRate);\n\n        mConfig = theConfig;\n        \n        RequireAction( mConfig.compatibleVersion <= kALACVersion, return kALAC_ParamError; );\n\n        // allocate mix buffers\n        mMixBufferU = (int32_t *) calloc( mConfig.frameLength * sizeof(int32_t), 1 );\n        mMixBufferV = (int32_t *) calloc( mConfig.frameLength * sizeof(int32_t), 1 );\n\n        // allocate dynamic predictor buffer\n        mPredictor = (int32_t *) calloc( mConfig.frameLength * sizeof(int32_t), 1 );\n\n        // \"shift off\" buffer shares memory with predictor buffer\n        mShiftBuffer = (uint16_t *) mPredictor;\n        \n        RequireAction( (mMixBufferU != nil) && (mMixBufferV != nil) && (mPredictor != nil),\n                        status = kALAC_MemFullError; goto Exit; );\n     }\n    else\n    {\n        status = kALAC_ParamError;\n    }\n\n    // skip to Channel Layout Info\n    // theActualCookie += sizeof(ALACSpecificConfig);\n    \n    // Currently, the Channel Layout Info portion of the magic cookie (as defined in the \n    // ALACMagicCookieDescription.txt document) is unused by the decoder. \n    \nExit:\n\treturn status;\n}",
          "includes": [
            "#include \"EndianPortable.h\"",
            "#include \"ALACBitUtilities.h\"",
            "#include \"matrixlib.h\"",
            "#include \"aglib.h\"",
            "#include \"dplib.h\"",
            "#include \"ALACDecoder.h\"",
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"aglib.h\"\n#include \"dplib.h\"\n#include \"ALACDecoder.h\"\n#include <string.h>\n#include <stdlib.h>\n\nALACDecoder {\n  int32_t ALACDecoder::Init( void * inMagicCookie, uint32_t inMagicCookieSize )\n  {\n  \tint32_t\t\tstatus = ALAC_noErr;\n      ALACSpecificConfig theConfig;\n      uint8_t * theActualCookie = (uint8_t *)inMagicCookie;\n      uint32_t theCookieBytesRemaining = inMagicCookieSize;\n  \n      // For historical reasons the decoder needs to be resilient to magic cookies vended by older encoders.\n      // As specified in the ALACMagicCookieDescription.txt document, there may be additional data encapsulating \n      // the ALACSpecificConfig. This would consist of format ('frma') and 'alac' atoms which precede the\n      // ALACSpecificConfig. \n      // See ALACMagicCookieDescription.txt for additional documentation concerning the 'magic cookie'\n      \n      // skip format ('frma') atom if present\n      if (theActualCookie[4] == 'f' && theActualCookie[5] == 'r' && theActualCookie[6] == 'm' && theActualCookie[7] == 'a')\n      {\n          theActualCookie += 12;\n          theCookieBytesRemaining -= 12;\n      }\n      \n      // skip 'alac' atom header if present\n      if (theActualCookie[4] == 'a' && theActualCookie[5] == 'l' && theActualCookie[6] == 'a' && theActualCookie[7] == 'c')\n      {\n          theActualCookie += 12;\n          theCookieBytesRemaining -= 12;\n      }\n  \n      // read the ALACSpecificConfig\n      if (theCookieBytesRemaining >= sizeof(ALACSpecificConfig))\n      {\n          memcpy(&theConfig, theActualCookie, sizeof(ALACSpecificConfig));\n  \n          theConfig.frameLength = Swap32BtoN(theConfig.frameLength);\n          theConfig.maxRun = Swap16BtoN(theConfig.maxRun);\n          theConfig.maxFrameBytes = Swap32BtoN(theConfig.maxFrameBytes);\n          theConfig.avgBitRate = Swap32BtoN(theConfig.avgBitRate);\n          theConfig.sampleRate = Swap32BtoN(theConfig.sampleRate);\n  \n          mConfig = theConfig;\n          \n          RequireAction( mConfig.compatibleVersion <= kALACVersion, return kALAC_ParamError; );\n  \n          // allocate mix buffers\n          mMixBufferU = (int32_t *) calloc( mConfig.frameLength * sizeof(int32_t), 1 );\n          mMixBufferV = (int32_t *) calloc( mConfig.frameLength * sizeof(int32_t), 1 );\n  \n          // allocate dynamic predictor buffer\n          mPredictor = (int32_t *) calloc( mConfig.frameLength * sizeof(int32_t), 1 );\n  \n          // \"shift off\" buffer shares memory with predictor buffer\n          mShiftBuffer = (uint16_t *) mPredictor;\n          \n          RequireAction( (mMixBufferU != nil) && (mMixBufferV != nil) && (mPredictor != nil),\n                          status = kALAC_MemFullError; goto Exit; );\n       }\n      else\n      {\n          status = kALAC_ParamError;\n      }\n  \n      // skip to Channel Layout Info\n      // theActualCookie += sizeof(ALACSpecificConfig);\n      \n      // Currently, the Channel Layout Info portion of the magic cookie (as defined in the \n      // ALACMagicCookieDescription.txt document) is unused by the decoder. \n      \n  Exit:\n  \treturn status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_codecData->size",
          "args": [],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Buffer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Buffer.h",
          "lines": "39-39",
          "snippet": "size_t size() const { return m_size; }",
          "includes": [
            "#include <sys/types.h>",
            "#include \"Shared.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"Shared.h\"\n\nBuffer {\n  size_t size() const { return m_size; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_codecData->data",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  void ALAC::initDecoder()\n  {\n  \tm_decoder = new ALACDecoder();\n  \tm_decoder->Init(m_codecData->data(), m_codecData->size());\n  }\n}"
  },
  {
    "function_name": "~ALAC",
    "container": "ALAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
    "lines": "108-112",
    "snippet": "ALAC::~ALAC()\n{\n\tdelete m_decoder;\n\tdelete m_encoder;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"../alac/ALACEncoder.h\"",
      "#include \"../alac/ALACDecoder.h\"",
      "#include \"../alac/ALACBitUtilities.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"PacketTable.h\"",
      "#include \"FileModule.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"Buffer.h\"",
      "#include \"ALAC.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  ALAC::~ALAC()\n  {\n  \tdelete m_decoder;\n  \tdelete m_encoder;\n  }\n}"
  },
  {
    "function_name": "ALAC",
    "container": "ALAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
    "lines": "93-106",
    "snippet": "ALAC::ALAC(Mode mode, Track *track, File *fh, bool canSeek, Buffer *codecData) :\n\tFileModule(mode, track, fh, canSeek),\n\tm_savedPositionNextFrame(-1),\n\tm_savedNextFrame(-1),\n\tm_codecData(codecData),\n\tm_decoder(NULL),\n\tm_encoder(NULL),\n\tm_currentPacket(0)\n{\n\tif (mode == Decompress)\n\t\tinitDecoder();\n\telse\n\t\tinitEncoder();\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"../alac/ALACEncoder.h\"",
      "#include \"../alac/ALACDecoder.h\"",
      "#include \"../alac/ALACBitUtilities.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"PacketTable.h\"",
      "#include \"FileModule.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"Buffer.h\"",
      "#include \"ALAC.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "initEncoder",
          "args": [],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "initEncoder",
          "container": "ALAC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
          "lines": "120-133",
          "snippet": "void ALAC::initEncoder()\n{\n\tm_encoder = new ALACEncoder();\n\tm_encoder->SetFrameSize(m_track->f.framesPerPacket);\n\tm_encoder->InitializeEncoder(outputFormat());\n\n\tuint32_t cookieSize = m_encoder->GetMagicCookieSize(m_track->f.channelCount);\n\tassert(cookieSize == m_codecData->size());\n\tm_encoder->GetMagicCookie(m_codecData->data(), &cookieSize);\n\n\tvoid *v = NULL;\n\t_af_pv_getptr(m_track->f.compressionParams, _AF_CODEC_DATA, &v);\n\t::memcpy(v, m_codecData->data(), cookieSize);\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"../alac/ALACEncoder.h\"",
            "#include \"../alac/ALACDecoder.h\"",
            "#include \"../alac/ALACBitUtilities.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"PacketTable.h\"",
            "#include \"FileModule.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"Buffer.h\"",
            "#include \"ALAC.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  void ALAC::initEncoder()\n  {\n  \tm_encoder = new ALACEncoder();\n  \tm_encoder->SetFrameSize(m_track->f.framesPerPacket);\n  \tm_encoder->InitializeEncoder(outputFormat());\n  \n  \tuint32_t cookieSize = m_encoder->GetMagicCookieSize(m_track->f.channelCount);\n  \tassert(cookieSize == m_codecData->size());\n  \tm_encoder->GetMagicCookie(m_codecData->data(), &cookieSize);\n  \n  \tvoid *v = NULL;\n  \t_af_pv_getptr(m_track->f.compressionParams, _AF_CODEC_DATA, &v);\n  \t::memcpy(v, m_codecData->data(), cookieSize);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "initDecoder",
          "args": [],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "initDecoder",
          "container": "ALAC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
          "lines": "114-118",
          "snippet": "void ALAC::initDecoder()\n{\n\tm_decoder = new ALACDecoder();\n\tm_decoder->Init(m_codecData->data(), m_codecData->size());\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"../alac/ALACEncoder.h\"",
            "#include \"../alac/ALACDecoder.h\"",
            "#include \"../alac/ALACBitUtilities.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"PacketTable.h\"",
            "#include \"FileModule.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"Buffer.h\"",
            "#include \"ALAC.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  void ALAC::initDecoder()\n  {\n  \tm_decoder = new ALACDecoder();\n  \tm_decoder->Init(m_codecData->data(), m_codecData->size());\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  ALAC::ALAC(Mode mode, Track *track, File *fh, bool canSeek, Buffer *codecData) :\n  \tFileModule(mode, track, fh, canSeek),\n  \tm_savedPositionNextFrame(-1),\n  \tm_savedNextFrame(-1),\n  \tm_codecData(codecData),\n  \tm_decoder(NULL),\n  \tm_encoder(NULL),\n  \tm_currentPacket(0)\n  {\n  \tif (mode == Decompress)\n  \t\tinitDecoder();\n  \telse\n  \t\tinitEncoder();\n  }\n}"
  }
]