[
  {
    "function_name": "describe",
    "container": "IMA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
    "lines": "365-370",
    "snippet": "void IMA::describe()\n{\n\tm_outChunk->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\tm_outChunk->f.compressionType = AF_COMPRESSION_NONE;\n\tm_outChunk->f.compressionParams = AU_NULL_PVLIST;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <audiofile.h>",
      "#include <assert.h>",
      "#include \"IMA.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nIMA {\n  void IMA::describe()\n  {\n  \tm_outChunk->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \tm_outChunk->f.compressionType = AF_COMPRESSION_NONE;\n  \tm_outChunk->f.compressionParams = AU_NULL_PVLIST;\n  }\n}"
  },
  {
    "function_name": "_af_ima_adpcm_format_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
    "lines": "339-363",
    "snippet": "bool _af_ima_adpcm_format_ok (AudioFormat *f)\n{\n\tif (f->channelCount != 1 && f->channelCount != 2)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"IMA ADPCM compression requires 1 or 2 channels\");\n\t\treturn false;\n\t}\n\n\tif (f->sampleFormat != AF_SAMPFMT_TWOSCOMP || f->sampleWidth != 16)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"IMA ADPCM compression requires 16-bit signed integer format\");\n\t\treturn false;\n\t}\n\n\tif (f->byteOrder != _AF_BYTEORDER_NATIVE)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"IMA ADPCM compression requires native byte order\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <audiofile.h>",
      "#include <assert.h>",
      "#include \"IMA.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_COMPRESSION",
            "\"IMA ADPCM compression requires native byte order\""
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_COMPRESSION",
            "\"IMA ADPCM compression requires 16-bit signed integer format\""
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_COMPRESSION",
            "\"IMA ADPCM compression requires 1 or 2 channels\""
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nbool _af_ima_adpcm_format_ok (AudioFormat *f)\n{\n\tif (f->channelCount != 1 && f->channelCount != 2)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"IMA ADPCM compression requires 1 or 2 channels\");\n\t\treturn false;\n\t}\n\n\tif (f->sampleFormat != AF_SAMPFMT_TWOSCOMP || f->sampleWidth != 16)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"IMA ADPCM compression requires 16-bit signed integer format\");\n\t\treturn false;\n\t}\n\n\tif (f->byteOrder != _AF_BYTEORDER_NATIVE)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"IMA ADPCM compression requires native byte order\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "encodeBlockQT",
    "container": "IMA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
    "lines": "312-337",
    "snippet": "int IMA::encodeBlockQT(const int16_t *input, uint8_t *output)\n{\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tadpcmState state = m_adpcmState[c];\n\n\t\tstate.previousValue &= ~0x7f;\n\n\t\toutput[0] = (state.previousValue >> 8) & 0xff;\n\t\toutput[1] = (state.previousValue & 0x80) | (state.index & 0x7f);\n\t\toutput += 2;\n\n\t\tfor (int n=0; n<m_framesPerPacket; n+=2)\n\t\t{\n\t\t\tuint8_t encoded = encodeSample(state, input[n*channelCount + c]);\n\t\t\tencoded |= encodeSample(state, input[(n+1)*channelCount + c]) << 4;\n\t\t\t*output++ = encoded;\n\t\t}\n\n\t\tm_adpcmState[c] = state;\n\t}\n\n\treturn m_bytesPerPacket;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <audiofile.h>",
      "#include <assert.h>",
      "#include \"IMA.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encodeSample",
          "args": [
            "state",
            "input[(n+1)*channelCount + c]"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "encodeSample",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
          "lines": "237-275",
          "snippet": "static inline uint8_t encodeSample(adpcmState &state, int16_t sample)\n{\n\tint step = stepTable[state.index];\n\tint diff = sample - state.previousValue;\n\tint vpdiff = step >> 3;\n\tuint8_t code = 0;\n\tif (diff < 0)\n\t{\n\t\tcode = 8;\n\t\tdiff = -diff;\n\t}\n\tif (diff >= step)\n\t{\n\t\tcode |= 4;\n\t\tdiff -= step;\n\t\tvpdiff += step;\n\t}\n\tstep >>= 1;\n\tif (diff >= step)\n\t{\n\t\tcode |= 2;\n\t\tdiff -= step;\n\t\tvpdiff += step;\n\t}\n\tstep >>= 1;\n\tif (diff >= step)\n\t{\n\t\tcode |= 1;\n\t\tvpdiff += step;\n\t}\n\n\tif (code & 8)\n\t\tvpdiff = -vpdiff;\n\tstate.previousValue = clamp(state.previousValue + vpdiff,\n\t\tMIN_INT16, MAX_INT16);\n\n\tstate.index = clamp(state.index + indexTable[code], 0, 88);\n\treturn code & 0xf;\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <audiofile.h>",
            "#include <assert.h>",
            "#include \"IMA.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const int8_t indexTable[16] =\n{\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n};",
            "static const int16_t stepTable[89] =\n{\n\t7, 8, 9, 10, 11, 12, 13, 14, 16, 17,\n\t19, 21, 23, 25, 28, 31, 34, 37, 41, 45,\n\t50, 55, 60, 66, 73, 80, 88, 97, 107, 118,\n\t130, 143, 157, 173, 190, 209, 230, 253, 279, 307,\n\t337, 371, 408, 449, 494, 544, 598, 658, 724, 796,\n\t876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,\n\t2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,\n\t5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\n\t15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nstatic const int8_t indexTable[16] =\n{\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n};\nstatic const int16_t stepTable[89] =\n{\n\t7, 8, 9, 10, 11, 12, 13, 14, 16, 17,\n\t19, 21, 23, 25, 28, 31, 34, 37, 41, 45,\n\t50, 55, 60, 66, 73, 80, 88, 97, 107, 118,\n\t130, 143, 157, 173, 190, 209, 230, 253, 279, 307,\n\t337, 371, 408, 449, 494, 544, 598, 658, 724, 796,\n\t876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,\n\t2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,\n\t5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\n\t15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767\n};\n\nstatic inline uint8_t encodeSample(adpcmState &state, int16_t sample)\n{\n\tint step = stepTable[state.index];\n\tint diff = sample - state.previousValue;\n\tint vpdiff = step >> 3;\n\tuint8_t code = 0;\n\tif (diff < 0)\n\t{\n\t\tcode = 8;\n\t\tdiff = -diff;\n\t}\n\tif (diff >= step)\n\t{\n\t\tcode |= 4;\n\t\tdiff -= step;\n\t\tvpdiff += step;\n\t}\n\tstep >>= 1;\n\tif (diff >= step)\n\t{\n\t\tcode |= 2;\n\t\tdiff -= step;\n\t\tvpdiff += step;\n\t}\n\tstep >>= 1;\n\tif (diff >= step)\n\t{\n\t\tcode |= 1;\n\t\tvpdiff += step;\n\t}\n\n\tif (code & 8)\n\t\tvpdiff = -vpdiff;\n\tstate.previousValue = clamp(state.previousValue + vpdiff,\n\t\tMIN_INT16, MAX_INT16);\n\n\tstate.index = clamp(state.index + indexTable[code], 0, 88);\n\treturn code & 0xf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nIMA {\n  int IMA::encodeBlockQT(const int16_t *input, uint8_t *output)\n  {\n  \tint channelCount = m_track->f.channelCount;\n  \n  \tfor (int c=0; c<channelCount; c++)\n  \t{\n  \t\tadpcmState state = m_adpcmState[c];\n  \n  \t\tstate.previousValue &= ~0x7f;\n  \n  \t\toutput[0] = (state.previousValue >> 8) & 0xff;\n  \t\toutput[1] = (state.previousValue & 0x80) | (state.index & 0x7f);\n  \t\toutput += 2;\n  \n  \t\tfor (int n=0; n<m_framesPerPacket; n+=2)\n  \t\t{\n  \t\t\tuint8_t encoded = encodeSample(state, input[n*channelCount + c]);\n  \t\t\tencoded |= encodeSample(state, input[(n+1)*channelCount + c]) << 4;\n  \t\t\t*output++ = encoded;\n  \t\t}\n  \n  \t\tm_adpcmState[c] = state;\n  \t}\n  \n  \treturn m_bytesPerPacket;\n  }\n}"
  },
  {
    "function_name": "encodeBlockWAVE",
    "container": "IMA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
    "lines": "277-310",
    "snippet": "int IMA::encodeBlockWAVE(const int16_t *input, uint8_t *output)\n{\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\toutput[0] = m_adpcmState[c].previousValue & 0xff;\n\t\toutput[1] = m_adpcmState[c].previousValue >> 8;\n\t\toutput[2] = m_adpcmState[c].index;\n\t\toutput[3] = 0;\n\n\t\toutput += 4;\n\t}\n\n\tfor (int n=0; n<m_framesPerPacket - 1; n += 8)\n\t{\n\t\tfor (int c=0; c<channelCount; c++)\n\t\t{\n\t\t\tconst int16_t *currentInput = input + c;\n\t\t\tfor (int s=0; s<4; s++)\n\t\t\t{\n\t\t\t\tuint8_t encodedValue = encodeSample(m_adpcmState[c], *currentInput);\n\t\t\t\tcurrentInput += channelCount;\n\t\t\t\tencodedValue |= encodeSample(m_adpcmState[c], *currentInput) << 4;\n\t\t\t\tcurrentInput += channelCount;\n\t\t\t\t*output++ = encodedValue;\n\t\t\t}\n\t\t}\n\n\t\tinput += channelCount * 8;\n\t}\n\n\treturn m_bytesPerPacket;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <audiofile.h>",
      "#include <assert.h>",
      "#include \"IMA.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encodeSample",
          "args": [
            "m_adpcmState[c]",
            "*currentInput"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "encodeSample",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
          "lines": "237-275",
          "snippet": "static inline uint8_t encodeSample(adpcmState &state, int16_t sample)\n{\n\tint step = stepTable[state.index];\n\tint diff = sample - state.previousValue;\n\tint vpdiff = step >> 3;\n\tuint8_t code = 0;\n\tif (diff < 0)\n\t{\n\t\tcode = 8;\n\t\tdiff = -diff;\n\t}\n\tif (diff >= step)\n\t{\n\t\tcode |= 4;\n\t\tdiff -= step;\n\t\tvpdiff += step;\n\t}\n\tstep >>= 1;\n\tif (diff >= step)\n\t{\n\t\tcode |= 2;\n\t\tdiff -= step;\n\t\tvpdiff += step;\n\t}\n\tstep >>= 1;\n\tif (diff >= step)\n\t{\n\t\tcode |= 1;\n\t\tvpdiff += step;\n\t}\n\n\tif (code & 8)\n\t\tvpdiff = -vpdiff;\n\tstate.previousValue = clamp(state.previousValue + vpdiff,\n\t\tMIN_INT16, MAX_INT16);\n\n\tstate.index = clamp(state.index + indexTable[code], 0, 88);\n\treturn code & 0xf;\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <audiofile.h>",
            "#include <assert.h>",
            "#include \"IMA.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const int8_t indexTable[16] =\n{\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n};",
            "static const int16_t stepTable[89] =\n{\n\t7, 8, 9, 10, 11, 12, 13, 14, 16, 17,\n\t19, 21, 23, 25, 28, 31, 34, 37, 41, 45,\n\t50, 55, 60, 66, 73, 80, 88, 97, 107, 118,\n\t130, 143, 157, 173, 190, 209, 230, 253, 279, 307,\n\t337, 371, 408, 449, 494, 544, 598, 658, 724, 796,\n\t876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,\n\t2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,\n\t5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\n\t15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nstatic const int8_t indexTable[16] =\n{\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n};\nstatic const int16_t stepTable[89] =\n{\n\t7, 8, 9, 10, 11, 12, 13, 14, 16, 17,\n\t19, 21, 23, 25, 28, 31, 34, 37, 41, 45,\n\t50, 55, 60, 66, 73, 80, 88, 97, 107, 118,\n\t130, 143, 157, 173, 190, 209, 230, 253, 279, 307,\n\t337, 371, 408, 449, 494, 544, 598, 658, 724, 796,\n\t876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,\n\t2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,\n\t5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\n\t15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767\n};\n\nstatic inline uint8_t encodeSample(adpcmState &state, int16_t sample)\n{\n\tint step = stepTable[state.index];\n\tint diff = sample - state.previousValue;\n\tint vpdiff = step >> 3;\n\tuint8_t code = 0;\n\tif (diff < 0)\n\t{\n\t\tcode = 8;\n\t\tdiff = -diff;\n\t}\n\tif (diff >= step)\n\t{\n\t\tcode |= 4;\n\t\tdiff -= step;\n\t\tvpdiff += step;\n\t}\n\tstep >>= 1;\n\tif (diff >= step)\n\t{\n\t\tcode |= 2;\n\t\tdiff -= step;\n\t\tvpdiff += step;\n\t}\n\tstep >>= 1;\n\tif (diff >= step)\n\t{\n\t\tcode |= 1;\n\t\tvpdiff += step;\n\t}\n\n\tif (code & 8)\n\t\tvpdiff = -vpdiff;\n\tstate.previousValue = clamp(state.previousValue + vpdiff,\n\t\tMIN_INT16, MAX_INT16);\n\n\tstate.index = clamp(state.index + indexTable[code], 0, 88);\n\treturn code & 0xf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nIMA {\n  int IMA::encodeBlockWAVE(const int16_t *input, uint8_t *output)\n  {\n  \tint channelCount = m_track->f.channelCount;\n  \n  \tfor (int c=0; c<channelCount; c++)\n  \t{\n  \t\toutput[0] = m_adpcmState[c].previousValue & 0xff;\n  \t\toutput[1] = m_adpcmState[c].previousValue >> 8;\n  \t\toutput[2] = m_adpcmState[c].index;\n  \t\toutput[3] = 0;\n  \n  \t\toutput += 4;\n  \t}\n  \n  \tfor (int n=0; n<m_framesPerPacket - 1; n += 8)\n  \t{\n  \t\tfor (int c=0; c<channelCount; c++)\n  \t\t{\n  \t\t\tconst int16_t *currentInput = input + c;\n  \t\t\tfor (int s=0; s<4; s++)\n  \t\t\t{\n  \t\t\t\tuint8_t encodedValue = encodeSample(m_adpcmState[c], *currentInput);\n  \t\t\t\tcurrentInput += channelCount;\n  \t\t\t\tencodedValue |= encodeSample(m_adpcmState[c], *currentInput) << 4;\n  \t\t\t\tcurrentInput += channelCount;\n  \t\t\t\t*output++ = encodedValue;\n  \t\t\t}\n  \t\t}\n  \n  \t\tinput += channelCount * 8;\n  \t}\n  \n  \treturn m_bytesPerPacket;\n  }\n}"
  },
  {
    "function_name": "encodeSample",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
    "lines": "237-275",
    "snippet": "static inline uint8_t encodeSample(adpcmState &state, int16_t sample)\n{\n\tint step = stepTable[state.index];\n\tint diff = sample - state.previousValue;\n\tint vpdiff = step >> 3;\n\tuint8_t code = 0;\n\tif (diff < 0)\n\t{\n\t\tcode = 8;\n\t\tdiff = -diff;\n\t}\n\tif (diff >= step)\n\t{\n\t\tcode |= 4;\n\t\tdiff -= step;\n\t\tvpdiff += step;\n\t}\n\tstep >>= 1;\n\tif (diff >= step)\n\t{\n\t\tcode |= 2;\n\t\tdiff -= step;\n\t\tvpdiff += step;\n\t}\n\tstep >>= 1;\n\tif (diff >= step)\n\t{\n\t\tcode |= 1;\n\t\tvpdiff += step;\n\t}\n\n\tif (code & 8)\n\t\tvpdiff = -vpdiff;\n\tstate.previousValue = clamp(state.previousValue + vpdiff,\n\t\tMIN_INT16, MAX_INT16);\n\n\tstate.index = clamp(state.index + indexTable[code], 0, 88);\n\treturn code & 0xf;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <audiofile.h>",
      "#include <assert.h>",
      "#include \"IMA.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const int8_t indexTable[16] =\n{\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n};",
      "static const int16_t stepTable[89] =\n{\n\t7, 8, 9, 10, 11, 12, 13, 14, 16, 17,\n\t19, 21, 23, 25, 28, 31, 34, 37, 41, 45,\n\t50, 55, 60, 66, 73, 80, 88, 97, 107, 118,\n\t130, 143, 157, 173, 190, 209, 230, 253, 279, 307,\n\t337, 371, 408, 449, 494, 544, 598, 658, 724, 796,\n\t876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,\n\t2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,\n\t5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\n\t15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "state.index + indexTable[code]",
            "0",
            "88"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "clamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
          "lines": "135-140",
          "snippet": "static inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <audiofile.h>",
            "#include <assert.h>",
            "#include \"IMA.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nstatic inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nstatic const int8_t indexTable[16] =\n{\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n};\nstatic const int16_t stepTable[89] =\n{\n\t7, 8, 9, 10, 11, 12, 13, 14, 16, 17,\n\t19, 21, 23, 25, 28, 31, 34, 37, 41, 45,\n\t50, 55, 60, 66, 73, 80, 88, 97, 107, 118,\n\t130, 143, 157, 173, 190, 209, 230, 253, 279, 307,\n\t337, 371, 408, 449, 494, 544, 598, 658, 724, 796,\n\t876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,\n\t2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,\n\t5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\n\t15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767\n};\n\nstatic inline uint8_t encodeSample(adpcmState &state, int16_t sample)\n{\n\tint step = stepTable[state.index];\n\tint diff = sample - state.previousValue;\n\tint vpdiff = step >> 3;\n\tuint8_t code = 0;\n\tif (diff < 0)\n\t{\n\t\tcode = 8;\n\t\tdiff = -diff;\n\t}\n\tif (diff >= step)\n\t{\n\t\tcode |= 4;\n\t\tdiff -= step;\n\t\tvpdiff += step;\n\t}\n\tstep >>= 1;\n\tif (diff >= step)\n\t{\n\t\tcode |= 2;\n\t\tdiff -= step;\n\t\tvpdiff += step;\n\t}\n\tstep >>= 1;\n\tif (diff >= step)\n\t{\n\t\tcode |= 1;\n\t\tvpdiff += step;\n\t}\n\n\tif (code & 8)\n\t\tvpdiff = -vpdiff;\n\tstate.previousValue = clamp(state.previousValue + vpdiff,\n\t\tMIN_INT16, MAX_INT16);\n\n\tstate.index = clamp(state.index + indexTable[code], 0, 88);\n\treturn code & 0xf;\n}"
  },
  {
    "function_name": "encodeBlock",
    "container": "IMA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
    "lines": "228-235",
    "snippet": "int IMA::encodeBlock(const int16_t *input, uint8_t *output)\n{\n\tif (m_imaType == _AF_IMA_ADPCM_TYPE_WAVE)\n\t\treturn encodeBlockWAVE(input, output);\n\telse if (m_imaType == _AF_IMA_ADPCM_TYPE_QT)\n\t\treturn encodeBlockQT(input, output);\n\treturn 0;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <audiofile.h>",
      "#include <assert.h>",
      "#include \"IMA.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encodeBlockQT",
          "args": [
            "input",
            "output"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "encodeBlockQT",
          "container": "IMA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
          "lines": "312-337",
          "snippet": "int IMA::encodeBlockQT(const int16_t *input, uint8_t *output)\n{\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tadpcmState state = m_adpcmState[c];\n\n\t\tstate.previousValue &= ~0x7f;\n\n\t\toutput[0] = (state.previousValue >> 8) & 0xff;\n\t\toutput[1] = (state.previousValue & 0x80) | (state.index & 0x7f);\n\t\toutput += 2;\n\n\t\tfor (int n=0; n<m_framesPerPacket; n+=2)\n\t\t{\n\t\t\tuint8_t encoded = encodeSample(state, input[n*channelCount + c]);\n\t\t\tencoded |= encodeSample(state, input[(n+1)*channelCount + c]) << 4;\n\t\t\t*output++ = encoded;\n\t\t}\n\n\t\tm_adpcmState[c] = state;\n\t}\n\n\treturn m_bytesPerPacket;\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <audiofile.h>",
            "#include <assert.h>",
            "#include \"IMA.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nIMA {\n  int IMA::encodeBlockQT(const int16_t *input, uint8_t *output)\n  {\n  \tint channelCount = m_track->f.channelCount;\n  \n  \tfor (int c=0; c<channelCount; c++)\n  \t{\n  \t\tadpcmState state = m_adpcmState[c];\n  \n  \t\tstate.previousValue &= ~0x7f;\n  \n  \t\toutput[0] = (state.previousValue >> 8) & 0xff;\n  \t\toutput[1] = (state.previousValue & 0x80) | (state.index & 0x7f);\n  \t\toutput += 2;\n  \n  \t\tfor (int n=0; n<m_framesPerPacket; n+=2)\n  \t\t{\n  \t\t\tuint8_t encoded = encodeSample(state, input[n*channelCount + c]);\n  \t\t\tencoded |= encodeSample(state, input[(n+1)*channelCount + c]) << 4;\n  \t\t\t*output++ = encoded;\n  \t\t}\n  \n  \t\tm_adpcmState[c] = state;\n  \t}\n  \n  \treturn m_bytesPerPacket;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "encodeBlockWAVE",
          "args": [
            "input",
            "output"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "encodeBlockWAVE",
          "container": "IMA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
          "lines": "277-310",
          "snippet": "int IMA::encodeBlockWAVE(const int16_t *input, uint8_t *output)\n{\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\toutput[0] = m_adpcmState[c].previousValue & 0xff;\n\t\toutput[1] = m_adpcmState[c].previousValue >> 8;\n\t\toutput[2] = m_adpcmState[c].index;\n\t\toutput[3] = 0;\n\n\t\toutput += 4;\n\t}\n\n\tfor (int n=0; n<m_framesPerPacket - 1; n += 8)\n\t{\n\t\tfor (int c=0; c<channelCount; c++)\n\t\t{\n\t\t\tconst int16_t *currentInput = input + c;\n\t\t\tfor (int s=0; s<4; s++)\n\t\t\t{\n\t\t\t\tuint8_t encodedValue = encodeSample(m_adpcmState[c], *currentInput);\n\t\t\t\tcurrentInput += channelCount;\n\t\t\t\tencodedValue |= encodeSample(m_adpcmState[c], *currentInput) << 4;\n\t\t\t\tcurrentInput += channelCount;\n\t\t\t\t*output++ = encodedValue;\n\t\t\t}\n\t\t}\n\n\t\tinput += channelCount * 8;\n\t}\n\n\treturn m_bytesPerPacket;\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <audiofile.h>",
            "#include <assert.h>",
            "#include \"IMA.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nIMA {\n  int IMA::encodeBlockWAVE(const int16_t *input, uint8_t *output)\n  {\n  \tint channelCount = m_track->f.channelCount;\n  \n  \tfor (int c=0; c<channelCount; c++)\n  \t{\n  \t\toutput[0] = m_adpcmState[c].previousValue & 0xff;\n  \t\toutput[1] = m_adpcmState[c].previousValue >> 8;\n  \t\toutput[2] = m_adpcmState[c].index;\n  \t\toutput[3] = 0;\n  \n  \t\toutput += 4;\n  \t}\n  \n  \tfor (int n=0; n<m_framesPerPacket - 1; n += 8)\n  \t{\n  \t\tfor (int c=0; c<channelCount; c++)\n  \t\t{\n  \t\t\tconst int16_t *currentInput = input + c;\n  \t\t\tfor (int s=0; s<4; s++)\n  \t\t\t{\n  \t\t\t\tuint8_t encodedValue = encodeSample(m_adpcmState[c], *currentInput);\n  \t\t\t\tcurrentInput += channelCount;\n  \t\t\t\tencodedValue |= encodeSample(m_adpcmState[c], *currentInput) << 4;\n  \t\t\t\tcurrentInput += channelCount;\n  \t\t\t\t*output++ = encodedValue;\n  \t\t\t}\n  \t\t}\n  \n  \t\tinput += channelCount * 8;\n  \t}\n  \n  \treturn m_bytesPerPacket;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nIMA {\n  int IMA::encodeBlock(const int16_t *input, uint8_t *output)\n  {\n  \tif (m_imaType == _AF_IMA_ADPCM_TYPE_WAVE)\n  \t\treturn encodeBlockWAVE(input, output);\n  \telse if (m_imaType == _AF_IMA_ADPCM_TYPE_QT)\n  \t\treturn encodeBlockQT(input, output);\n  \treturn 0;\n  }\n}"
  },
  {
    "function_name": "decodeBlockQT",
    "container": "IMA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
    "lines": "201-226",
    "snippet": "int IMA::decodeBlockQT(const uint8_t *encoded, int16_t *decoded)\n{\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tadpcmState state;\n\t\tint predictor = (encoded[0] << 8) | (encoded[1] & 0x80);\n\t\tif (predictor & 0x8000)\n\t\t\tpredictor -= 0x10000;\n\n\t\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n\t\tstate.index = encoded[1] & 0x7f;\n\t\tencoded += 2;\n\n\t\tfor (int n=0; n<m_framesPerPacket; n+=2)\n\t\t{\n\t\t\tuint8_t e = *encoded;\n\t\t\tdecoded[n*channelCount + c] = decodeSample(state, e & 0xf);\n\t\t\tdecoded[(n+1)*channelCount + c] = decodeSample(state, e >> 4);\n\t\t\tencoded++;\n\t\t}\n\t}\n\n\treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <audiofile.h>",
      "#include <assert.h>",
      "#include \"IMA.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "decodeSample",
          "args": [
            "state",
            "e >> 4"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "decodeSample",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
          "lines": "142-160",
          "snippet": "static inline int16_t decodeSample(adpcmState &state, uint8_t code)\n{\n\tint step = stepTable[state.index];\n\n\tint diff = step >> 3;\n\tif (code & 4) diff += step;\n\tif (code & 2) diff += step>>1;\n\tif (code & 1) diff += step>>2;\n\n\tint predictor = state.previousValue;\n\tif (code & 8)\n\t\tpredictor -= diff;\n\telse\n\t\tpredictor += diff;\n\n\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n\tstate.index = clamp(state.index + indexTable[code], 0, 88);\n\treturn state.previousValue;\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <audiofile.h>",
            "#include <assert.h>",
            "#include \"IMA.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const int8_t indexTable[16] =\n{\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n};",
            "static const int16_t stepTable[89] =\n{\n\t7, 8, 9, 10, 11, 12, 13, 14, 16, 17,\n\t19, 21, 23, 25, 28, 31, 34, 37, 41, 45,\n\t50, 55, 60, 66, 73, 80, 88, 97, 107, 118,\n\t130, 143, 157, 173, 190, 209, 230, 253, 279, 307,\n\t337, 371, 408, 449, 494, 544, 598, 658, 724, 796,\n\t876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,\n\t2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,\n\t5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\n\t15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nstatic const int8_t indexTable[16] =\n{\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n};\nstatic const int16_t stepTable[89] =\n{\n\t7, 8, 9, 10, 11, 12, 13, 14, 16, 17,\n\t19, 21, 23, 25, 28, 31, 34, 37, 41, 45,\n\t50, 55, 60, 66, 73, 80, 88, 97, 107, 118,\n\t130, 143, 157, 173, 190, 209, 230, 253, 279, 307,\n\t337, 371, 408, 449, 494, 544, 598, 658, 724, 796,\n\t876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,\n\t2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,\n\t5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\n\t15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767\n};\n\nstatic inline int16_t decodeSample(adpcmState &state, uint8_t code)\n{\n\tint step = stepTable[state.index];\n\n\tint diff = step >> 3;\n\tif (code & 4) diff += step;\n\tif (code & 2) diff += step>>1;\n\tif (code & 1) diff += step>>2;\n\n\tint predictor = state.previousValue;\n\tif (code & 8)\n\t\tpredictor -= diff;\n\telse\n\t\tpredictor += diff;\n\n\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n\tstate.index = clamp(state.index + indexTable[code], 0, 88);\n\treturn state.previousValue;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "predictor",
            "MIN_INT16",
            "MAX_INT16"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "clamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
          "lines": "135-140",
          "snippet": "static inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <audiofile.h>",
            "#include <assert.h>",
            "#include \"IMA.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nstatic inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nIMA {\n  int IMA::decodeBlockQT(const uint8_t *encoded, int16_t *decoded)\n  {\n  \tint channelCount = m_track->f.channelCount;\n  \n  \tfor (int c=0; c<channelCount; c++)\n  \t{\n  \t\tadpcmState state;\n  \t\tint predictor = (encoded[0] << 8) | (encoded[1] & 0x80);\n  \t\tif (predictor & 0x8000)\n  \t\t\tpredictor -= 0x10000;\n  \n  \t\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n  \t\tstate.index = encoded[1] & 0x7f;\n  \t\tencoded += 2;\n  \n  \t\tfor (int n=0; n<m_framesPerPacket; n+=2)\n  \t\t{\n  \t\t\tuint8_t e = *encoded;\n  \t\t\tdecoded[n*channelCount + c] = decodeSample(state, e & 0xf);\n  \t\t\tdecoded[(n+1)*channelCount + c] = decodeSample(state, e >> 4);\n  \t\t\tencoded++;\n  \t\t}\n  \t}\n  \n  \treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n  }\n}"
  },
  {
    "function_name": "decodeBlockWAVE",
    "container": "IMA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
    "lines": "162-198",
    "snippet": "int IMA::decodeBlockWAVE(const uint8_t *encoded, int16_t *decoded)\n{\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tm_adpcmState[c].previousValue = (encoded[1]<<8) | encoded[0];\n\t\tif (encoded[1] & 0x80)\n\t\t\tm_adpcmState[c].previousValue -= 0x10000;\n\n\t\tm_adpcmState[c].index = encoded[2];\n\n\t\t*decoded++ = m_adpcmState[c].previousValue;\n\n\t\tencoded += 4;\n\t}\n\n\tfor (int n=0; n<m_framesPerPacket - 1; n += 8)\n\t{\n\t\tfor (int c=0; c<channelCount; c++)\n\t\t{\n\t\t\tint16_t *output = decoded + c;\n\t\t\tfor (int s=0; s<4; s++)\n\t\t\t{\n\t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded & 0xf);\n\t\t\t\toutput += channelCount;\n\t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded >> 4);\n\t\t\t\toutput += channelCount;\n\t\t\t\tencoded++;\n\t\t\t}\n\t\t}\n\n\t\tdecoded += channelCount * 8;\n\t}\n\n\treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <audiofile.h>",
      "#include <assert.h>",
      "#include \"IMA.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "decodeSample",
          "args": [
            "m_adpcmState[c]",
            "*encoded >> 4"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "decodeSample",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
          "lines": "142-160",
          "snippet": "static inline int16_t decodeSample(adpcmState &state, uint8_t code)\n{\n\tint step = stepTable[state.index];\n\n\tint diff = step >> 3;\n\tif (code & 4) diff += step;\n\tif (code & 2) diff += step>>1;\n\tif (code & 1) diff += step>>2;\n\n\tint predictor = state.previousValue;\n\tif (code & 8)\n\t\tpredictor -= diff;\n\telse\n\t\tpredictor += diff;\n\n\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n\tstate.index = clamp(state.index + indexTable[code], 0, 88);\n\treturn state.previousValue;\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <audiofile.h>",
            "#include <assert.h>",
            "#include \"IMA.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const int8_t indexTable[16] =\n{\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n};",
            "static const int16_t stepTable[89] =\n{\n\t7, 8, 9, 10, 11, 12, 13, 14, 16, 17,\n\t19, 21, 23, 25, 28, 31, 34, 37, 41, 45,\n\t50, 55, 60, 66, 73, 80, 88, 97, 107, 118,\n\t130, 143, 157, 173, 190, 209, 230, 253, 279, 307,\n\t337, 371, 408, 449, 494, 544, 598, 658, 724, 796,\n\t876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,\n\t2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,\n\t5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\n\t15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nstatic const int8_t indexTable[16] =\n{\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n};\nstatic const int16_t stepTable[89] =\n{\n\t7, 8, 9, 10, 11, 12, 13, 14, 16, 17,\n\t19, 21, 23, 25, 28, 31, 34, 37, 41, 45,\n\t50, 55, 60, 66, 73, 80, 88, 97, 107, 118,\n\t130, 143, 157, 173, 190, 209, 230, 253, 279, 307,\n\t337, 371, 408, 449, 494, 544, 598, 658, 724, 796,\n\t876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,\n\t2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,\n\t5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\n\t15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767\n};\n\nstatic inline int16_t decodeSample(adpcmState &state, uint8_t code)\n{\n\tint step = stepTable[state.index];\n\n\tint diff = step >> 3;\n\tif (code & 4) diff += step;\n\tif (code & 2) diff += step>>1;\n\tif (code & 1) diff += step>>2;\n\n\tint predictor = state.previousValue;\n\tif (code & 8)\n\t\tpredictor -= diff;\n\telse\n\t\tpredictor += diff;\n\n\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n\tstate.index = clamp(state.index + indexTable[code], 0, 88);\n\treturn state.previousValue;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nIMA {\n  int IMA::decodeBlockWAVE(const uint8_t *encoded, int16_t *decoded)\n  {\n  \tint channelCount = m_track->f.channelCount;\n  \n  \tfor (int c=0; c<channelCount; c++)\n  \t{\n  \t\tm_adpcmState[c].previousValue = (encoded[1]<<8) | encoded[0];\n  \t\tif (encoded[1] & 0x80)\n  \t\t\tm_adpcmState[c].previousValue -= 0x10000;\n  \n  \t\tm_adpcmState[c].index = encoded[2];\n  \n  \t\t*decoded++ = m_adpcmState[c].previousValue;\n  \n  \t\tencoded += 4;\n  \t}\n  \n  \tfor (int n=0; n<m_framesPerPacket - 1; n += 8)\n  \t{\n  \t\tfor (int c=0; c<channelCount; c++)\n  \t\t{\n  \t\t\tint16_t *output = decoded + c;\n  \t\t\tfor (int s=0; s<4; s++)\n  \t\t\t{\n  \t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded & 0xf);\n  \t\t\t\toutput += channelCount;\n  \t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded >> 4);\n  \t\t\t\toutput += channelCount;\n  \t\t\t\tencoded++;\n  \t\t\t}\n  \t\t}\n  \n  \t\tdecoded += channelCount * 8;\n  \t}\n  \n  \treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n  }\n}"
  },
  {
    "function_name": "decodeSample",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
    "lines": "142-160",
    "snippet": "static inline int16_t decodeSample(adpcmState &state, uint8_t code)\n{\n\tint step = stepTable[state.index];\n\n\tint diff = step >> 3;\n\tif (code & 4) diff += step;\n\tif (code & 2) diff += step>>1;\n\tif (code & 1) diff += step>>2;\n\n\tint predictor = state.previousValue;\n\tif (code & 8)\n\t\tpredictor -= diff;\n\telse\n\t\tpredictor += diff;\n\n\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n\tstate.index = clamp(state.index + indexTable[code], 0, 88);\n\treturn state.previousValue;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <audiofile.h>",
      "#include <assert.h>",
      "#include \"IMA.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const int8_t indexTable[16] =\n{\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n};",
      "static const int16_t stepTable[89] =\n{\n\t7, 8, 9, 10, 11, 12, 13, 14, 16, 17,\n\t19, 21, 23, 25, 28, 31, 34, 37, 41, 45,\n\t50, 55, 60, 66, 73, 80, 88, 97, 107, 118,\n\t130, 143, 157, 173, 190, 209, 230, 253, 279, 307,\n\t337, 371, 408, 449, 494, 544, 598, 658, 724, 796,\n\t876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,\n\t2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,\n\t5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\n\t15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "state.index + indexTable[code]",
            "0",
            "88"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "clamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
          "lines": "135-140",
          "snippet": "static inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <audiofile.h>",
            "#include <assert.h>",
            "#include \"IMA.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nstatic inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nstatic const int8_t indexTable[16] =\n{\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n};\nstatic const int16_t stepTable[89] =\n{\n\t7, 8, 9, 10, 11, 12, 13, 14, 16, 17,\n\t19, 21, 23, 25, 28, 31, 34, 37, 41, 45,\n\t50, 55, 60, 66, 73, 80, 88, 97, 107, 118,\n\t130, 143, 157, 173, 190, 209, 230, 253, 279, 307,\n\t337, 371, 408, 449, 494, 544, 598, 658, 724, 796,\n\t876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,\n\t2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,\n\t5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\n\t15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767\n};\n\nstatic inline int16_t decodeSample(adpcmState &state, uint8_t code)\n{\n\tint step = stepTable[state.index];\n\n\tint diff = step >> 3;\n\tif (code & 4) diff += step;\n\tif (code & 2) diff += step>>1;\n\tif (code & 1) diff += step>>2;\n\n\tint predictor = state.previousValue;\n\tif (code & 8)\n\t\tpredictor -= diff;\n\telse\n\t\tpredictor += diff;\n\n\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n\tstate.index = clamp(state.index + indexTable[code], 0, 88);\n\treturn state.previousValue;\n}"
  },
  {
    "function_name": "clamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
    "lines": "135-140",
    "snippet": "static inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <audiofile.h>",
      "#include <assert.h>",
      "#include \"IMA.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nstatic inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}"
  },
  {
    "function_name": "decodeBlock",
    "container": "IMA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
    "lines": "107-114",
    "snippet": "int IMA::decodeBlock(const uint8_t *encoded, int16_t *decoded)\n{\n\tif (m_imaType == _AF_IMA_ADPCM_TYPE_WAVE)\n\t\treturn decodeBlockWAVE(encoded, decoded);\n\telse if (m_imaType == _AF_IMA_ADPCM_TYPE_QT)\n\t\treturn decodeBlockQT(encoded, decoded);\n\treturn 0;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <audiofile.h>",
      "#include <assert.h>",
      "#include \"IMA.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "decodeBlockQT",
          "args": [
            "encoded",
            "decoded"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "decodeBlockQT",
          "container": "IMA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
          "lines": "201-226",
          "snippet": "int IMA::decodeBlockQT(const uint8_t *encoded, int16_t *decoded)\n{\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tadpcmState state;\n\t\tint predictor = (encoded[0] << 8) | (encoded[1] & 0x80);\n\t\tif (predictor & 0x8000)\n\t\t\tpredictor -= 0x10000;\n\n\t\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n\t\tstate.index = encoded[1] & 0x7f;\n\t\tencoded += 2;\n\n\t\tfor (int n=0; n<m_framesPerPacket; n+=2)\n\t\t{\n\t\t\tuint8_t e = *encoded;\n\t\t\tdecoded[n*channelCount + c] = decodeSample(state, e & 0xf);\n\t\t\tdecoded[(n+1)*channelCount + c] = decodeSample(state, e >> 4);\n\t\t\tencoded++;\n\t\t}\n\t}\n\n\treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <audiofile.h>",
            "#include <assert.h>",
            "#include \"IMA.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nIMA {\n  int IMA::decodeBlockQT(const uint8_t *encoded, int16_t *decoded)\n  {\n  \tint channelCount = m_track->f.channelCount;\n  \n  \tfor (int c=0; c<channelCount; c++)\n  \t{\n  \t\tadpcmState state;\n  \t\tint predictor = (encoded[0] << 8) | (encoded[1] & 0x80);\n  \t\tif (predictor & 0x8000)\n  \t\t\tpredictor -= 0x10000;\n  \n  \t\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n  \t\tstate.index = encoded[1] & 0x7f;\n  \t\tencoded += 2;\n  \n  \t\tfor (int n=0; n<m_framesPerPacket; n+=2)\n  \t\t{\n  \t\t\tuint8_t e = *encoded;\n  \t\t\tdecoded[n*channelCount + c] = decodeSample(state, e & 0xf);\n  \t\t\tdecoded[(n+1)*channelCount + c] = decodeSample(state, e >> 4);\n  \t\t\tencoded++;\n  \t\t}\n  \t}\n  \n  \treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "decodeBlockWAVE",
          "args": [
            "encoded",
            "decoded"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "decodeBlockWAVE",
          "container": "IMA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
          "lines": "162-198",
          "snippet": "int IMA::decodeBlockWAVE(const uint8_t *encoded, int16_t *decoded)\n{\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tm_adpcmState[c].previousValue = (encoded[1]<<8) | encoded[0];\n\t\tif (encoded[1] & 0x80)\n\t\t\tm_adpcmState[c].previousValue -= 0x10000;\n\n\t\tm_adpcmState[c].index = encoded[2];\n\n\t\t*decoded++ = m_adpcmState[c].previousValue;\n\n\t\tencoded += 4;\n\t}\n\n\tfor (int n=0; n<m_framesPerPacket - 1; n += 8)\n\t{\n\t\tfor (int c=0; c<channelCount; c++)\n\t\t{\n\t\t\tint16_t *output = decoded + c;\n\t\t\tfor (int s=0; s<4; s++)\n\t\t\t{\n\t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded & 0xf);\n\t\t\t\toutput += channelCount;\n\t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded >> 4);\n\t\t\t\toutput += channelCount;\n\t\t\t\tencoded++;\n\t\t\t}\n\t\t}\n\n\t\tdecoded += channelCount * 8;\n\t}\n\n\treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <audiofile.h>",
            "#include <assert.h>",
            "#include \"IMA.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nIMA {\n  int IMA::decodeBlockWAVE(const uint8_t *encoded, int16_t *decoded)\n  {\n  \tint channelCount = m_track->f.channelCount;\n  \n  \tfor (int c=0; c<channelCount; c++)\n  \t{\n  \t\tm_adpcmState[c].previousValue = (encoded[1]<<8) | encoded[0];\n  \t\tif (encoded[1] & 0x80)\n  \t\t\tm_adpcmState[c].previousValue -= 0x10000;\n  \n  \t\tm_adpcmState[c].index = encoded[2];\n  \n  \t\t*decoded++ = m_adpcmState[c].previousValue;\n  \n  \t\tencoded += 4;\n  \t}\n  \n  \tfor (int n=0; n<m_framesPerPacket - 1; n += 8)\n  \t{\n  \t\tfor (int c=0; c<channelCount; c++)\n  \t\t{\n  \t\t\tint16_t *output = decoded + c;\n  \t\t\tfor (int s=0; s<4; s++)\n  \t\t\t{\n  \t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded & 0xf);\n  \t\t\t\toutput += channelCount;\n  \t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded >> 4);\n  \t\t\t\toutput += channelCount;\n  \t\t\t\tencoded++;\n  \t\t\t}\n  \t\t}\n  \n  \t\tdecoded += channelCount * 8;\n  \t}\n  \n  \treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nIMA {\n  int IMA::decodeBlock(const uint8_t *encoded, int16_t *decoded)\n  {\n  \tif (m_imaType == _AF_IMA_ADPCM_TYPE_WAVE)\n  \t\treturn decodeBlockWAVE(encoded, decoded);\n  \telse if (m_imaType == _AF_IMA_ADPCM_TYPE_QT)\n  \t\treturn decodeBlockQT(encoded, decoded);\n  \treturn 0;\n  }\n}"
  },
  {
    "function_name": "~IMA",
    "container": "IMA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
    "lines": "102-105",
    "snippet": "IMA::~IMA()\n{\n\tdelete [] m_adpcmState;\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <audiofile.h>",
      "#include <assert.h>",
      "#include \"IMA.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nIMA {\n  IMA::~IMA()\n  {\n  \tdelete [] m_adpcmState;\n  }\n}"
  },
  {
    "function_name": "IMA",
    "container": "IMA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
    "lines": "86-100",
    "snippet": "IMA::IMA(Mode mode, Track *track, File *fh, bool canSeek) :\n\tBlockCodec(mode, track, fh, canSeek),\n\tm_imaType(0)\n{\n\tAUpvlist pv = (AUpvlist) track->f.compressionParams;\n\n\tm_framesPerPacket = track->f.framesPerPacket;\n\tm_bytesPerPacket = track->f.bytesPerPacket;\n\n\tlong l;\n\tif (_af_pv_getlong(pv, _AF_IMA_ADPCM_TYPE, &l))\n\t\tm_imaType = l;\n\n\tm_adpcmState = new adpcmState[track->f.channelCount];\n}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <audiofile.h>",
      "#include <assert.h>",
      "#include \"IMA.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_pv_getlong",
          "args": [
            "pv",
            "_AF_IMA_ADPCM_TYPE",
            "&l"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "_af_pv_getlong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "191-213",
          "snippet": "bool _af_pv_getlong (AUpvlist pvlist, int param, long *l)\n{\n\tfor (int i=0; i<AUpvgetmaxitems(pvlist); i++)\n\t{\n\t\tint\tp, t;\n\n\t\tAUpvgetparam(pvlist, i, &p);\n\n\t\tif (p != param)\n\t\t\tcontinue;\n\n\t\tAUpvgetvaltype(pvlist, i, &t);\n\n\t\t/* Ensure that this parameter is of type AU_PVTYPE_LONG. */\n\t\tif (t != AU_PVTYPE_LONG)\n\t\t\treturn false;\n\n\t\tAUpvgetval(pvlist, i, l);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nbool _af_pv_getlong (AUpvlist pvlist, int param, long *l)\n{\n\tfor (int i=0; i<AUpvgetmaxitems(pvlist); i++)\n\t{\n\t\tint\tp, t;\n\n\t\tAUpvgetparam(pvlist, i, &p);\n\n\t\tif (p != param)\n\t\t\tcontinue;\n\n\t\tAUpvgetvaltype(pvlist, i, &t);\n\n\t\t/* Ensure that this parameter is of type AU_PVTYPE_LONG. */\n\t\tif (t != AU_PVTYPE_LONG)\n\t\t\treturn false;\n\n\t\tAUpvgetval(pvlist, i, l);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nIMA {\n  IMA::IMA(Mode mode, Track *track, File *fh, bool canSeek) :\n  \tBlockCodec(mode, track, fh, canSeek),\n  \tm_imaType(0)\n  {\n  \tAUpvlist pv = (AUpvlist) track->f.compressionParams;\n  \n  \tm_framesPerPacket = track->f.framesPerPacket;\n  \tm_bytesPerPacket = track->f.bytesPerPacket;\n  \n  \tlong l;\n  \tif (_af_pv_getlong(pv, _AF_IMA_ADPCM_TYPE, &l))\n  \t\tm_imaType = l;\n  \n  \tm_adpcmState = new adpcmState[track->f.channelCount];\n  }\n}"
  },
  {
    "function_name": "adpcmState",
    "container": "adpcmState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
    "lines": "47-51",
    "snippet": "adpcmState()\n\t{\n\t\tpreviousValue = 0;\n\t\tindex = 0;\n\t}",
    "includes": [
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"File.h\"",
      "#include \"Compiler.h\"",
      "#include \"BlockCodec.h\"",
      "#include <audiofile.h>",
      "#include <assert.h>",
      "#include \"IMA.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nadpcmState {\n  adpcmState()\n  \t{\n  \t\tpreviousValue = 0;\n  \t\tindex = 0;\n  \t}\n}"
  }
]