[
  {
    "function_name": "initMSADPCMCompressionParams",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "1578-1610",
    "snippet": "void WAVEFile::initMSADPCMCompressionParams()\n{\n\tconst int16_t coefficients[7][2] =\n\t{\n\t\t{ 256, 0 },\n\t\t{ 512, -256 },\n\t\t{ 0, 0 },\n\t\t{ 192, 64 },\n\t\t{ 240, 0 },\n\t\t{ 460, -208 },\n\t\t{ 392, -232 }\n\t};\n\tmemcpy(m_msadpcmCoefficients, coefficients, sizeof (int16_t) * 7 * 2);\n\tm_msadpcmNumCoefficients = 7;\n\n\tTrack *track = getTrack();\n\n\ttrack->f.framesPerPacket = 500;\n\ttrack->f.bytesPerPacket = 256 * track->f.channelCount;\n\n\tAUpvlist pv = AUpvnew(2);\n\tAUpvsetparam(pv, 0, _AF_MS_ADPCM_NUM_COEFFICIENTS);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = m_msadpcmNumCoefficients;\n\tAUpvsetval(pv, 0, &l);\n\n\tAUpvsetparam(pv, 1, _AF_MS_ADPCM_COEFFICIENTS);\n\tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n\tvoid *v = m_msadpcmCoefficients;\n\tAUpvsetval(pv, 1, &v);\n\n\ttrack->f.compressionParams = pv;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AUpvsetval",
          "args": [
            "pv",
            "1",
            "&v"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetvaltype",
          "args": [
            "pv",
            "1",
            "AU_PVTYPE_PTR"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetparam",
          "args": [
            "pv",
            "1",
            "_AF_MS_ADPCM_COEFFICIENTS"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetval",
          "args": [
            "pv",
            "0",
            "&l"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetvaltype",
          "args": [
            "pv",
            "0",
            "AU_PVTYPE_LONG"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetparam",
          "args": [
            "pv",
            "0",
            "_AF_MS_ADPCM_NUM_COEFFICIENTS"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvnew",
          "args": [
            "2"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_msadpcmCoefficients",
            "coefficients",
            "sizeof (int16_t) * 7 * 2"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  void WAVEFile::initMSADPCMCompressionParams()\n  {\n  \tconst int16_t coefficients[7][2] =\n  \t{\n  \t\t{ 256, 0 },\n  \t\t{ 512, -256 },\n  \t\t{ 0, 0 },\n  \t\t{ 192, 64 },\n  \t\t{ 240, 0 },\n  \t\t{ 460, -208 },\n  \t\t{ 392, -232 }\n  \t};\n  \tmemcpy(m_msadpcmCoefficients, coefficients, sizeof (int16_t) * 7 * 2);\n  \tm_msadpcmNumCoefficients = 7;\n  \n  \tTrack *track = getTrack();\n  \n  \ttrack->f.framesPerPacket = 500;\n  \ttrack->f.bytesPerPacket = 256 * track->f.channelCount;\n  \n  \tAUpvlist pv = AUpvnew(2);\n  \tAUpvsetparam(pv, 0, _AF_MS_ADPCM_NUM_COEFFICIENTS);\n  \tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n  \tlong l = m_msadpcmNumCoefficients;\n  \tAUpvsetval(pv, 0, &l);\n  \n  \tAUpvsetparam(pv, 1, _AF_MS_ADPCM_COEFFICIENTS);\n  \tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n  \tvoid *v = m_msadpcmCoefficients;\n  \tAUpvsetval(pv, 1, &v);\n  \n  \ttrack->f.compressionParams = pv;\n  }\n}"
  },
  {
    "function_name": "initIMACompressionParams",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "1562-1576",
    "snippet": "void WAVEFile::initIMACompressionParams()\n{\n\tTrack *track = getTrack();\n\n\ttrack->f.framesPerPacket = 505;\n\ttrack->f.bytesPerPacket = 256 * track->f.channelCount;\n\n\tAUpvlist pv = AUpvnew(1);\n\tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = _AF_IMA_ADPCM_TYPE_WAVE;\n\tAUpvsetval(pv, 0, &l);\n\n\ttrack->f.compressionParams = pv;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AUpvsetval",
          "args": [
            "pv",
            "0",
            "&l"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetvaltype",
          "args": [
            "pv",
            "0",
            "AU_PVTYPE_LONG"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetparam",
          "args": [
            "pv",
            "0",
            "_AF_IMA_ADPCM_TYPE"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvnew",
          "args": [
            "1"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  void WAVEFile::initIMACompressionParams()\n  {\n  \tTrack *track = getTrack();\n  \n  \ttrack->f.framesPerPacket = 505;\n  \ttrack->f.bytesPerPacket = 256 * track->f.channelCount;\n  \n  \tAUpvlist pv = AUpvnew(1);\n  \tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n  \tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n  \tlong l = _AF_IMA_ADPCM_TYPE_WAVE;\n  \tAUpvsetval(pv, 0, &l);\n  \n  \ttrack->f.compressionParams = pv;\n  }\n}"
  },
  {
    "function_name": "initCompressionParams",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "1553-1560",
    "snippet": "void WAVEFile::initCompressionParams()\n{\n\tTrack *track = getTrack();\n\tif (track->f.compressionType == AF_COMPRESSION_IMA)\n\t\tinitIMACompressionParams();\n\telse if (track->f.compressionType == AF_COMPRESSION_MS_ADPCM)\n\t\tinitMSADPCMCompressionParams();\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "initMSADPCMCompressionParams",
          "args": [],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "initMSADPCMCompressionParams",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "1578-1610",
          "snippet": "void WAVEFile::initMSADPCMCompressionParams()\n{\n\tconst int16_t coefficients[7][2] =\n\t{\n\t\t{ 256, 0 },\n\t\t{ 512, -256 },\n\t\t{ 0, 0 },\n\t\t{ 192, 64 },\n\t\t{ 240, 0 },\n\t\t{ 460, -208 },\n\t\t{ 392, -232 }\n\t};\n\tmemcpy(m_msadpcmCoefficients, coefficients, sizeof (int16_t) * 7 * 2);\n\tm_msadpcmNumCoefficients = 7;\n\n\tTrack *track = getTrack();\n\n\ttrack->f.framesPerPacket = 500;\n\ttrack->f.bytesPerPacket = 256 * track->f.channelCount;\n\n\tAUpvlist pv = AUpvnew(2);\n\tAUpvsetparam(pv, 0, _AF_MS_ADPCM_NUM_COEFFICIENTS);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = m_msadpcmNumCoefficients;\n\tAUpvsetval(pv, 0, &l);\n\n\tAUpvsetparam(pv, 1, _AF_MS_ADPCM_COEFFICIENTS);\n\tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n\tvoid *v = m_msadpcmCoefficients;\n\tAUpvsetval(pv, 1, &v);\n\n\ttrack->f.compressionParams = pv;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  void WAVEFile::initMSADPCMCompressionParams()\n  {\n  \tconst int16_t coefficients[7][2] =\n  \t{\n  \t\t{ 256, 0 },\n  \t\t{ 512, -256 },\n  \t\t{ 0, 0 },\n  \t\t{ 192, 64 },\n  \t\t{ 240, 0 },\n  \t\t{ 460, -208 },\n  \t\t{ 392, -232 }\n  \t};\n  \tmemcpy(m_msadpcmCoefficients, coefficients, sizeof (int16_t) * 7 * 2);\n  \tm_msadpcmNumCoefficients = 7;\n  \n  \tTrack *track = getTrack();\n  \n  \ttrack->f.framesPerPacket = 500;\n  \ttrack->f.bytesPerPacket = 256 * track->f.channelCount;\n  \n  \tAUpvlist pv = AUpvnew(2);\n  \tAUpvsetparam(pv, 0, _AF_MS_ADPCM_NUM_COEFFICIENTS);\n  \tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n  \tlong l = m_msadpcmNumCoefficients;\n  \tAUpvsetval(pv, 0, &l);\n  \n  \tAUpvsetparam(pv, 1, _AF_MS_ADPCM_COEFFICIENTS);\n  \tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n  \tvoid *v = m_msadpcmCoefficients;\n  \tAUpvsetval(pv, 1, &v);\n  \n  \ttrack->f.compressionParams = pv;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "initIMACompressionParams",
          "args": [],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "initIMACompressionParams",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "1562-1576",
          "snippet": "void WAVEFile::initIMACompressionParams()\n{\n\tTrack *track = getTrack();\n\n\ttrack->f.framesPerPacket = 505;\n\ttrack->f.bytesPerPacket = 256 * track->f.channelCount;\n\n\tAUpvlist pv = AUpvnew(1);\n\tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = _AF_IMA_ADPCM_TYPE_WAVE;\n\tAUpvsetval(pv, 0, &l);\n\n\ttrack->f.compressionParams = pv;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  void WAVEFile::initIMACompressionParams()\n  {\n  \tTrack *track = getTrack();\n  \n  \ttrack->f.framesPerPacket = 505;\n  \ttrack->f.bytesPerPacket = 256 * track->f.channelCount;\n  \n  \tAUpvlist pv = AUpvnew(1);\n  \tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n  \tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n  \tlong l = _AF_IMA_ADPCM_TYPE_WAVE;\n  \tAUpvsetval(pv, 0, &l);\n  \n  \ttrack->f.compressionParams = pv;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  void WAVEFile::initCompressionParams()\n  {\n  \tTrack *track = getTrack();\n  \tif (track->f.compressionType == AF_COMPRESSION_IMA)\n  \t\tinitIMACompressionParams();\n  \telse if (track->f.compressionType == AF_COMPRESSION_MS_ADPCM)\n  \t\tinitMSADPCMCompressionParams();\n  }\n}"
  },
  {
    "function_name": "writeUUID",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "1548-1551",
    "snippet": "bool WAVEFile::writeUUID(const UUID *u)\n{\n\treturn m_fh->write(u->data, 16) == 16;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "u->data",
            "16"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  bool WAVEFile::writeUUID(const UUID *u)\n  {\n  \treturn m_fh->write(u->data, 16) == 16;\n  }\n}"
  },
  {
    "function_name": "readUUID",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "1543-1546",
    "snippet": "bool WAVEFile::readUUID(UUID *u)\n{\n\treturn m_fh->read(u->data, 16) == 16;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->read",
          "args": [
            "u->data",
            "16"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  bool WAVEFile::readUUID(UUID *u)\n  {\n  \treturn m_fh->read(u->data, 16) == 16;\n  }\n}"
  },
  {
    "function_name": "writeInit",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "1520-1541",
    "snippet": "status WAVEFile::writeInit(AFfilesetup setup)\n{\n\tif (initFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\n\tinitCompressionParams();\n\n\tuint32_t zero = 0;\n\n\tm_fh->seek(0, File::SeekFromBeginning);\n\tm_fh->write(\"RIFF\", 4);\n\tm_fh->write(&zero, 4);\n\tm_fh->write(\"WAVE\", 4);\n\n\twriteMiscellaneous();\n\twriteCues();\n\twriteFormat();\n\twriteFrameCount();\n\twriteData();\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeData",
          "args": [],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "writeData",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "1234-1247",
          "snippet": "status WAVEFile::writeData()\n{\n\tTrack *track = getTrack();\n\n\tm_fh->write(\"data\", 4);\n\tm_dataSizeOffset = m_fh->tell();\n\n\tuint32_t chunkSize = track->data_size;\n\n\twriteU32(&chunkSize);\n\ttrack->fpos_first_frame = m_fh->tell();\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::writeData()\n  {\n  \tTrack *track = getTrack();\n  \n  \tm_fh->write(\"data\", 4);\n  \tm_dataSizeOffset = m_fh->tell();\n  \n  \tuint32_t chunkSize = track->data_size;\n  \n  \twriteU32(&chunkSize);\n  \ttrack->fpos_first_frame = m_fh->tell();\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeFrameCount",
          "args": [],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "writeFrameCount",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "1203-1232",
          "snippet": "status WAVEFile::writeFrameCount()\n{\n\tuint32_t factSize = 4;\n\tuint32_t totalFrameCount;\n\n\tTrack *track = getTrack();\n\n\t/* Omit the fact chunk only for uncompressed integer audio formats. */\n\tif (track->f.compressionType == AF_COMPRESSION_NONE &&\n\t\t(track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP ||\n\t\ttrack->f.sampleFormat == AF_SAMPFMT_UNSIGNED))\n\t\treturn AF_SUCCEED;\n\n\t/*\n\t\tIf the offset for the fact chunk hasn't been set yet,\n\t\tset it to the file's current position.\n\t*/\n\tif (m_factOffset == 0)\n\t\tm_factOffset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_factOffset, File::SeekFromBeginning);\n\n\tm_fh->write(\"fact\", 4);\n\twriteU32(&factSize);\n\n\ttotalFrameCount = track->totalfframes;\n\twriteU32(&totalFrameCount);\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::writeFrameCount()\n  {\n  \tuint32_t factSize = 4;\n  \tuint32_t totalFrameCount;\n  \n  \tTrack *track = getTrack();\n  \n  \t/* Omit the fact chunk only for uncompressed integer audio formats. */\n  \tif (track->f.compressionType == AF_COMPRESSION_NONE &&\n  \t\t(track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP ||\n  \t\ttrack->f.sampleFormat == AF_SAMPFMT_UNSIGNED))\n  \t\treturn AF_SUCCEED;\n  \n  \t/*\n  \t\tIf the offset for the fact chunk hasn't been set yet,\n  \t\tset it to the file's current position.\n  \t*/\n  \tif (m_factOffset == 0)\n  \t\tm_factOffset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_factOffset, File::SeekFromBeginning);\n  \n  \tm_fh->write(\"fact\", 4);\n  \twriteU32(&factSize);\n  \n  \ttotalFrameCount = track->totalfframes;\n  \twriteU32(&totalFrameCount);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeFormat",
          "args": [],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "writeFormat",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "1077-1201",
          "snippet": "status WAVEFile::writeFormat()\n{\n\tuint16_t\tformatTag, channelCount;\n\tuint32_t\tsampleRate, averageBytesPerSecond;\n\tuint16_t\tblockAlign;\n\tuint32_t\tchunkSize;\n\tuint16_t\tbitsPerSample;\n\n\tTrack *track = getTrack();\n\n\tm_fh->write(\"fmt \", 4);\n\n\tswitch (track->f.compressionType)\n\t{\n\t\tcase AF_COMPRESSION_NONE:\n\t\t\tchunkSize = 16;\n\t\t\tif (track->f.sampleFormat == AF_SAMPFMT_FLOAT ||\n\t\t\t\ttrack->f.sampleFormat == AF_SAMPFMT_DOUBLE)\n\t\t\t{\n\t\t\t\tformatTag = WAVE_FORMAT_IEEE_FLOAT;\n\t\t\t}\n\t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP ||\n\t\t\t\ttrack->f.sampleFormat == AF_SAMPFMT_UNSIGNED)\n\t\t\t{\n\t\t\t\tformatTag = WAVE_FORMAT_PCM;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_COMPTYPE, \"bad sample format\");\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tblockAlign = _af_format_frame_size(&track->f, false);\n\t\t\tbitsPerSample = 8 * _af_format_sample_size(&track->f, false);\n\t\t\tbreak;\n\n\t\t/*\n\t\t\tG.711 compression uses eight bits per sample.\n\t\t*/\n\t\tcase AF_COMPRESSION_G711_ULAW:\n\t\t\tchunkSize = 18;\n\t\t\tformatTag = IBM_FORMAT_MULAW;\n\t\t\tblockAlign = track->f.channelCount;\n\t\t\tbitsPerSample = 8;\n\t\t\tbreak;\n\n\t\tcase AF_COMPRESSION_G711_ALAW:\n\t\t\tchunkSize = 18;\n\t\t\tformatTag = IBM_FORMAT_ALAW;\n\t\t\tblockAlign = track->f.channelCount;\n\t\t\tbitsPerSample = 8;\n\t\t\tbreak;\n\n\t\tcase AF_COMPRESSION_IMA:\n\t\t\tchunkSize = 20;\n\t\t\tformatTag = WAVE_FORMAT_DVI_ADPCM;\n\t\t\tblockAlign = track->f.bytesPerPacket;\n\t\t\tbitsPerSample = 4;\n\t\t\tbreak;\n\n\t\tcase AF_COMPRESSION_MS_ADPCM:\n\t\t\tchunkSize = 50;\n\t\t\tformatTag = WAVE_FORMAT_ADPCM;\n\t\t\tblockAlign = track->f.bytesPerPacket;\n\t\t\tbitsPerSample = 4;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_COMPTYPE, \"bad compression type\");\n\t\t\treturn AF_FAIL;\n\t}\n\n\twriteU32(&chunkSize);\n\twriteU16(&formatTag);\n\n\tchannelCount = track->f.channelCount;\n\twriteU16(&channelCount);\n\n\tsampleRate = track->f.sampleRate;\n\twriteU32(&sampleRate);\n\n\taverageBytesPerSecond =\n\t\ttrack->f.sampleRate * _af_format_frame_size(&track->f, false);\n\tif (track->f.compressionType == AF_COMPRESSION_IMA ||\n\t\ttrack->f.compressionType == AF_COMPRESSION_MS_ADPCM)\n\t\taverageBytesPerSecond = track->f.sampleRate * track->f.bytesPerPacket /\n\t\t\ttrack->f.framesPerPacket;\n\twriteU32(&averageBytesPerSecond);\n\n\twriteU16(&blockAlign);\n\n\twriteU16(&bitsPerSample);\n\n\tif (track->f.compressionType == AF_COMPRESSION_G711_ULAW ||\n\t\ttrack->f.compressionType == AF_COMPRESSION_G711_ALAW)\n\t{\n\t\tuint16_t zero = 0;\n\t\twriteU16(&zero);\n\t}\n\telse if (track->f.compressionType == AF_COMPRESSION_IMA)\n\t{\n\t\tuint16_t extraByteCount = 2;\n\t\twriteU16(&extraByteCount);\n\t\tuint16_t samplesPerBlock = track->f.framesPerPacket;\n\t\twriteU16(&samplesPerBlock);\n\t}\n\telse if (track->f.compressionType == AF_COMPRESSION_MS_ADPCM)\n\t{\n\t\tuint16_t extraByteCount = 2 + 2 + m_msadpcmNumCoefficients * 4;\n\t\twriteU16(&extraByteCount);\n\t\tuint16_t samplesPerBlock = track->f.framesPerPacket;\n\t\twriteU16(&samplesPerBlock);\n\n\t\tuint16_t numCoefficients = m_msadpcmNumCoefficients;\n\t\twriteU16(&numCoefficients);\n\n\t\tfor (int i=0; i<m_msadpcmNumCoefficients; i++)\n\t\t{\n\t\t\twriteS16(&m_msadpcmCoefficients[i][0]);\n\t\t\twriteS16(&m_msadpcmCoefficients[i][1]);\n\t\t}\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::writeFormat()\n  {\n  \tuint16_t\tformatTag, channelCount;\n  \tuint32_t\tsampleRate, averageBytesPerSecond;\n  \tuint16_t\tblockAlign;\n  \tuint32_t\tchunkSize;\n  \tuint16_t\tbitsPerSample;\n  \n  \tTrack *track = getTrack();\n  \n  \tm_fh->write(\"fmt \", 4);\n  \n  \tswitch (track->f.compressionType)\n  \t{\n  \t\tcase AF_COMPRESSION_NONE:\n  \t\t\tchunkSize = 16;\n  \t\t\tif (track->f.sampleFormat == AF_SAMPFMT_FLOAT ||\n  \t\t\t\ttrack->f.sampleFormat == AF_SAMPFMT_DOUBLE)\n  \t\t\t{\n  \t\t\t\tformatTag = WAVE_FORMAT_IEEE_FLOAT;\n  \t\t\t}\n  \t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP ||\n  \t\t\t\ttrack->f.sampleFormat == AF_SAMPFMT_UNSIGNED)\n  \t\t\t{\n  \t\t\t\tformatTag = WAVE_FORMAT_PCM;\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_COMPTYPE, \"bad sample format\");\n  \t\t\t\treturn AF_FAIL;\n  \t\t\t}\n  \n  \t\t\tblockAlign = _af_format_frame_size(&track->f, false);\n  \t\t\tbitsPerSample = 8 * _af_format_sample_size(&track->f, false);\n  \t\t\tbreak;\n  \n  \t\t/*\n  \t\t\tG.711 compression uses eight bits per sample.\n  \t\t*/\n  \t\tcase AF_COMPRESSION_G711_ULAW:\n  \t\t\tchunkSize = 18;\n  \t\t\tformatTag = IBM_FORMAT_MULAW;\n  \t\t\tblockAlign = track->f.channelCount;\n  \t\t\tbitsPerSample = 8;\n  \t\t\tbreak;\n  \n  \t\tcase AF_COMPRESSION_G711_ALAW:\n  \t\t\tchunkSize = 18;\n  \t\t\tformatTag = IBM_FORMAT_ALAW;\n  \t\t\tblockAlign = track->f.channelCount;\n  \t\t\tbitsPerSample = 8;\n  \t\t\tbreak;\n  \n  \t\tcase AF_COMPRESSION_IMA:\n  \t\t\tchunkSize = 20;\n  \t\t\tformatTag = WAVE_FORMAT_DVI_ADPCM;\n  \t\t\tblockAlign = track->f.bytesPerPacket;\n  \t\t\tbitsPerSample = 4;\n  \t\t\tbreak;\n  \n  \t\tcase AF_COMPRESSION_MS_ADPCM:\n  \t\t\tchunkSize = 50;\n  \t\t\tformatTag = WAVE_FORMAT_ADPCM;\n  \t\t\tblockAlign = track->f.bytesPerPacket;\n  \t\t\tbitsPerSample = 4;\n  \t\t\tbreak;\n  \n  \t\tdefault:\n  \t\t\t_af_error(AF_BAD_COMPTYPE, \"bad compression type\");\n  \t\t\treturn AF_FAIL;\n  \t}\n  \n  \twriteU32(&chunkSize);\n  \twriteU16(&formatTag);\n  \n  \tchannelCount = track->f.channelCount;\n  \twriteU16(&channelCount);\n  \n  \tsampleRate = track->f.sampleRate;\n  \twriteU32(&sampleRate);\n  \n  \taverageBytesPerSecond =\n  \t\ttrack->f.sampleRate * _af_format_frame_size(&track->f, false);\n  \tif (track->f.compressionType == AF_COMPRESSION_IMA ||\n  \t\ttrack->f.compressionType == AF_COMPRESSION_MS_ADPCM)\n  \t\taverageBytesPerSecond = track->f.sampleRate * track->f.bytesPerPacket /\n  \t\t\ttrack->f.framesPerPacket;\n  \twriteU32(&averageBytesPerSecond);\n  \n  \twriteU16(&blockAlign);\n  \n  \twriteU16(&bitsPerSample);\n  \n  \tif (track->f.compressionType == AF_COMPRESSION_G711_ULAW ||\n  \t\ttrack->f.compressionType == AF_COMPRESSION_G711_ALAW)\n  \t{\n  \t\tuint16_t zero = 0;\n  \t\twriteU16(&zero);\n  \t}\n  \telse if (track->f.compressionType == AF_COMPRESSION_IMA)\n  \t{\n  \t\tuint16_t extraByteCount = 2;\n  \t\twriteU16(&extraByteCount);\n  \t\tuint16_t samplesPerBlock = track->f.framesPerPacket;\n  \t\twriteU16(&samplesPerBlock);\n  \t}\n  \telse if (track->f.compressionType == AF_COMPRESSION_MS_ADPCM)\n  \t{\n  \t\tuint16_t extraByteCount = 2 + 2 + m_msadpcmNumCoefficients * 4;\n  \t\twriteU16(&extraByteCount);\n  \t\tuint16_t samplesPerBlock = track->f.framesPerPacket;\n  \t\twriteU16(&samplesPerBlock);\n  \n  \t\tuint16_t numCoefficients = m_msadpcmNumCoefficients;\n  \t\twriteU16(&numCoefficients);\n  \n  \t\tfor (int i=0; i<m_msadpcmNumCoefficients; i++)\n  \t\t{\n  \t\t\twriteS16(&m_msadpcmCoefficients[i][0]);\n  \t\t\twriteS16(&m_msadpcmCoefficients[i][1]);\n  \t\t}\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeCues",
          "args": [],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "writeCues",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "1399-1498",
          "snippet": "status WAVEFile::writeCues()\n{\n\tTrack *track = getTrack();\n\n\tif (!track->markerCount)\n\t\treturn AF_SUCCEED;\n\n\tif (m_markOffset == 0)\n\t\tm_markOffset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_markOffset, File::SeekFromBeginning);\n\n\tTag cue(\"cue \");\n\twriteTag(&cue);\n\n\t/*\n\t\tThe cue chunk consists of 4 bytes for the number of cue points\n\t\tfollowed by 24 bytes for each cue point record.\n\t*/\n\tuint32_t cueChunkSize = 4 + track->markerCount * 24;\n\twriteU32(&cueChunkSize);\n\tuint32_t numCues = track->markerCount;\n\twriteU32(&numCues);\n\n\t// Write each marker to the file.\n\tfor (int i=0; i<track->markerCount; i++)\n\t{\n\t\tuint32_t identifier = track->markers[i].id;\n\t\twriteU32(&identifier);\n\n\t\tuint32_t position = i;\n\t\twriteU32(&position);\n\n\t\tTag data(\"data\");\n\t\twriteTag(&data);\n\n\t\t/*\n\t\t\tFor an uncompressed WAVE file which contains only one data chunk,\n\t\t\tchunkStart and blockStart are zero.\n\t\t*/\n\t\tuint32_t chunkStart = 0;\n\t\twriteU32(&chunkStart);\n\n\t\tuint32_t blockStart = 0;\n\t\twriteU32(&blockStart);\n\n\t\tAFframecount markPosition = track->markers[i].position;\n\t\tuint32_t sampleOffset = markPosition;\n\t\twriteU32(&sampleOffset);\n\t}\n\n\t// Now write the cue names and comments within a master list chunk.\n\tuint32_t listChunkSize = 4;\n\tfor (int i=0; i<track->markerCount; i++)\n\t{\n\t\tconst char *name = track->markers[i].name;\n\t\tconst char *comment = track->markers[i].comment;\n\n\t\t/*\n\t\t\tEach 'labl' or 'note' chunk consists of 4 bytes for the chunk ID,\n\t\t\t4 bytes for the chunk data size, 4 bytes for the cue point ID,\n\t\t\tand then the length of the label as a null-terminated string.\n\n\t\t\tIn all, this is 12 bytes plus the length of the string, its null\n\t\t\ttermination byte, and a trailing pad byte if the length of the\n\t\t\tchunk is otherwise odd.\n\t\t*/\n\t\tlistChunkSize += 12 + zStringLength(name);\n\t\tlistChunkSize += 12 + zStringLength(comment);\n\t}\n\n\tTag list(\"LIST\");\n\twriteTag(&list);\n\twriteU32(&listChunkSize);\n\tTag adtl(\"adtl\");\n\twriteTag(&adtl);\n\n\tfor (int i=0; i<track->markerCount; i++)\n\t{\n\t\tuint32_t cuePointID = track->markers[i].id;\n\n\t\tconst char *name = track->markers[i].name;\n\t\tuint32_t labelSize = 4 + zStringLength(name);\n\t\tTag lablTag(\"labl\");\n\t\twriteTag(&lablTag);\n\t\twriteU32(&labelSize);\n\t\twriteU32(&cuePointID);\n\t\twriteZString(name);\n\n\t\tconst char *comment = track->markers[i].comment;\n\t\tuint32_t noteSize = 4 + zStringLength(comment);\n\t\tTag noteTag(\"note\");\n\t\twriteTag(&noteTag);\n\t\twriteU32(&noteSize);\n\t\twriteU32(&cuePointID);\n\t\twriteZString(comment);\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::writeCues()\n  {\n  \tTrack *track = getTrack();\n  \n  \tif (!track->markerCount)\n  \t\treturn AF_SUCCEED;\n  \n  \tif (m_markOffset == 0)\n  \t\tm_markOffset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_markOffset, File::SeekFromBeginning);\n  \n  \tTag cue(\"cue \");\n  \twriteTag(&cue);\n  \n  \t/*\n  \t\tThe cue chunk consists of 4 bytes for the number of cue points\n  \t\tfollowed by 24 bytes for each cue point record.\n  \t*/\n  \tuint32_t cueChunkSize = 4 + track->markerCount * 24;\n  \twriteU32(&cueChunkSize);\n  \tuint32_t numCues = track->markerCount;\n  \twriteU32(&numCues);\n  \n  \t// Write each marker to the file.\n  \tfor (int i=0; i<track->markerCount; i++)\n  \t{\n  \t\tuint32_t identifier = track->markers[i].id;\n  \t\twriteU32(&identifier);\n  \n  \t\tuint32_t position = i;\n  \t\twriteU32(&position);\n  \n  \t\tTag data(\"data\");\n  \t\twriteTag(&data);\n  \n  \t\t/*\n  \t\t\tFor an uncompressed WAVE file which contains only one data chunk,\n  \t\t\tchunkStart and blockStart are zero.\n  \t\t*/\n  \t\tuint32_t chunkStart = 0;\n  \t\twriteU32(&chunkStart);\n  \n  \t\tuint32_t blockStart = 0;\n  \t\twriteU32(&blockStart);\n  \n  \t\tAFframecount markPosition = track->markers[i].position;\n  \t\tuint32_t sampleOffset = markPosition;\n  \t\twriteU32(&sampleOffset);\n  \t}\n  \n  \t// Now write the cue names and comments within a master list chunk.\n  \tuint32_t listChunkSize = 4;\n  \tfor (int i=0; i<track->markerCount; i++)\n  \t{\n  \t\tconst char *name = track->markers[i].name;\n  \t\tconst char *comment = track->markers[i].comment;\n  \n  \t\t/*\n  \t\t\tEach 'labl' or 'note' chunk consists of 4 bytes for the chunk ID,\n  \t\t\t4 bytes for the chunk data size, 4 bytes for the cue point ID,\n  \t\t\tand then the length of the label as a null-terminated string.\n  \n  \t\t\tIn all, this is 12 bytes plus the length of the string, its null\n  \t\t\ttermination byte, and a trailing pad byte if the length of the\n  \t\t\tchunk is otherwise odd.\n  \t\t*/\n  \t\tlistChunkSize += 12 + zStringLength(name);\n  \t\tlistChunkSize += 12 + zStringLength(comment);\n  \t}\n  \n  \tTag list(\"LIST\");\n  \twriteTag(&list);\n  \twriteU32(&listChunkSize);\n  \tTag adtl(\"adtl\");\n  \twriteTag(&adtl);\n  \n  \tfor (int i=0; i<track->markerCount; i++)\n  \t{\n  \t\tuint32_t cuePointID = track->markers[i].id;\n  \n  \t\tconst char *name = track->markers[i].name;\n  \t\tuint32_t labelSize = 4 + zStringLength(name);\n  \t\tTag lablTag(\"labl\");\n  \t\twriteTag(&lablTag);\n  \t\twriteU32(&labelSize);\n  \t\twriteU32(&cuePointID);\n  \t\twriteZString(name);\n  \n  \t\tconst char *comment = track->markers[i].comment;\n  \t\tuint32_t noteSize = 4 + zStringLength(comment);\n  \t\tTag noteTag(\"note\");\n  \t\twriteTag(&noteTag);\n  \t\twriteU32(&noteSize);\n  \t\twriteU32(&cuePointID);\n  \t\twriteZString(comment);\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeMiscellaneous",
          "args": [],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "writeMiscellaneous",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "1307-1397",
          "snippet": "status WAVEFile::writeMiscellaneous()\n{\n\tif (m_miscellaneousCount != 0)\n\t{\n\t\tuint32_t\tmiscellaneousBytes;\n\t\tuint32_t \tchunkSize;\n\n\t\t/* Start at 12 to account for 'LIST', size, and 'INFO'. */\n\t\tmiscellaneousBytes = 12;\n\n\t\t/* Then calculate the size of the whole INFO chunk. */\n\t\tfor (int i=0; i<m_miscellaneousCount; i++)\n\t\t{\n\t\t\tTag miscid;\n\n\t\t\t// Skip miscellaneous data of an unsupported type.\n\t\t\tif (!misc_type_to_wave(m_miscellaneous[i].type, &miscid))\n\t\t\t\tcontinue;\n\n\t\t\t// Account for miscellaneous type and size.\n\t\t\tmiscellaneousBytes += 8;\n\t\t\tmiscellaneousBytes += m_miscellaneous[i].size;\n\n\t\t\t// Add a pad byte if necessary.\n\t\t\tif (m_miscellaneous[i].size % 2 != 0)\n\t\t\t\tmiscellaneousBytes++;\n\n\t\t\tassert(miscellaneousBytes % 2 == 0);\n\t\t}\n\n\t\tif (m_miscellaneousOffset == 0)\n\t\t\tm_miscellaneousOffset = m_fh->tell();\n\t\telse\n\t\t\tm_fh->seek(m_miscellaneousOffset, File::SeekFromBeginning);\n\n\t\t/*\n\t\t\tWrite the data.  On the first call to this\n\t\t\tfunction (from _af_wave_write_init), the\n\t\t\tdata won't be available, fh->seek is used to\n\t\t\treserve space until the data has been provided.\n\t\t\tOn subseuent calls to this function (from\n\t\t\t_af_wave_update), the data will really be written.\n\t\t*/\n\n\t\t/* Write 'LIST'. */\n\t\tm_fh->write(\"LIST\", 4);\n\n\t\t/* Write the size of the following chunk. */\n\t\tchunkSize = miscellaneousBytes-8;\n\t\twriteU32(&chunkSize);\n\n\t\t/* Write 'INFO'. */\n\t\tm_fh->write(\"INFO\", 4);\n\n\t\t/* Write each miscellaneous chunk. */\n\t\tfor (int i=0; i<m_miscellaneousCount; i++)\n\t\t{\n\t\t\tuint32_t miscsize = m_miscellaneous[i].size;\n\t\t\tTag miscid;\n\n\t\t\t// Skip miscellaneous data of an unsupported type.\n\t\t\tif (!misc_type_to_wave(m_miscellaneous[i].type, &miscid))\n\t\t\t\tcontinue;\n\n\t\t\twriteTag(&miscid);\n\t\t\twriteU32(&miscsize);\n\t\t\tif (m_miscellaneous[i].buffer != NULL)\n\t\t\t{\n\t\t\t\tuint8_t\tzero = 0;\n\n\t\t\t\tm_fh->write(m_miscellaneous[i].buffer, m_miscellaneous[i].size);\n\n\t\t\t\t// Pad if necessary.\n\t\t\t\tif ((m_miscellaneous[i].size%2) != 0)\n\t\t\t\t\twriteU8(&zero);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\tsize;\n\t\t\t\tsize = m_miscellaneous[i].size;\n\n\t\t\t\t// Pad if necessary.\n\t\t\t\tif ((size % 2) != 0)\n\t\t\t\t\tsize++;\n\t\t\t\tm_fh->seek(size, File::SeekFromCurrent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::writeMiscellaneous()\n  {\n  \tif (m_miscellaneousCount != 0)\n  \t{\n  \t\tuint32_t\tmiscellaneousBytes;\n  \t\tuint32_t \tchunkSize;\n  \n  \t\t/* Start at 12 to account for 'LIST', size, and 'INFO'. */\n  \t\tmiscellaneousBytes = 12;\n  \n  \t\t/* Then calculate the size of the whole INFO chunk. */\n  \t\tfor (int i=0; i<m_miscellaneousCount; i++)\n  \t\t{\n  \t\t\tTag miscid;\n  \n  \t\t\t// Skip miscellaneous data of an unsupported type.\n  \t\t\tif (!misc_type_to_wave(m_miscellaneous[i].type, &miscid))\n  \t\t\t\tcontinue;\n  \n  \t\t\t// Account for miscellaneous type and size.\n  \t\t\tmiscellaneousBytes += 8;\n  \t\t\tmiscellaneousBytes += m_miscellaneous[i].size;\n  \n  \t\t\t// Add a pad byte if necessary.\n  \t\t\tif (m_miscellaneous[i].size % 2 != 0)\n  \t\t\t\tmiscellaneousBytes++;\n  \n  \t\t\tassert(miscellaneousBytes % 2 == 0);\n  \t\t}\n  \n  \t\tif (m_miscellaneousOffset == 0)\n  \t\t\tm_miscellaneousOffset = m_fh->tell();\n  \t\telse\n  \t\t\tm_fh->seek(m_miscellaneousOffset, File::SeekFromBeginning);\n  \n  \t\t/*\n  \t\t\tWrite the data.  On the first call to this\n  \t\t\tfunction (from _af_wave_write_init), the\n  \t\t\tdata won't be available, fh->seek is used to\n  \t\t\treserve space until the data has been provided.\n  \t\t\tOn subseuent calls to this function (from\n  \t\t\t_af_wave_update), the data will really be written.\n  \t\t*/\n  \n  \t\t/* Write 'LIST'. */\n  \t\tm_fh->write(\"LIST\", 4);\n  \n  \t\t/* Write the size of the following chunk. */\n  \t\tchunkSize = miscellaneousBytes-8;\n  \t\twriteU32(&chunkSize);\n  \n  \t\t/* Write 'INFO'. */\n  \t\tm_fh->write(\"INFO\", 4);\n  \n  \t\t/* Write each miscellaneous chunk. */\n  \t\tfor (int i=0; i<m_miscellaneousCount; i++)\n  \t\t{\n  \t\t\tuint32_t miscsize = m_miscellaneous[i].size;\n  \t\t\tTag miscid;\n  \n  \t\t\t// Skip miscellaneous data of an unsupported type.\n  \t\t\tif (!misc_type_to_wave(m_miscellaneous[i].type, &miscid))\n  \t\t\t\tcontinue;\n  \n  \t\t\twriteTag(&miscid);\n  \t\t\twriteU32(&miscsize);\n  \t\t\tif (m_miscellaneous[i].buffer != NULL)\n  \t\t\t{\n  \t\t\t\tuint8_t\tzero = 0;\n  \n  \t\t\t\tm_fh->write(m_miscellaneous[i].buffer, m_miscellaneous[i].size);\n  \n  \t\t\t\t// Pad if necessary.\n  \t\t\t\tif ((m_miscellaneous[i].size%2) != 0)\n  \t\t\t\t\twriteU8(&zero);\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tint\tsize;\n  \t\t\t\tsize = m_miscellaneous[i].size;\n  \n  \t\t\t\t// Pad if necessary.\n  \t\t\t\tif ((size % 2) != 0)\n  \t\t\t\t\tsize++;\n  \t\t\t\tm_fh->seek(size, File::SeekFromCurrent);\n  \t\t\t}\n  \t\t}\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "\"WAVE\"",
            "4"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "0",
            "File::SeekFromBeginning"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "initCompressionParams",
          "args": [],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "initCompressionParams",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "1553-1560",
          "snippet": "void WAVEFile::initCompressionParams()\n{\n\tTrack *track = getTrack();\n\tif (track->f.compressionType == AF_COMPRESSION_IMA)\n\t\tinitIMACompressionParams();\n\telse if (track->f.compressionType == AF_COMPRESSION_MS_ADPCM)\n\t\tinitMSADPCMCompressionParams();\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  void WAVEFile::initCompressionParams()\n  {\n  \tTrack *track = getTrack();\n  \tif (track->f.compressionType == AF_COMPRESSION_IMA)\n  \t\tinitIMACompressionParams();\n  \telse if (track->f.compressionType == AF_COMPRESSION_MS_ADPCM)\n  \t\tinitMSADPCMCompressionParams();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "initFromSetup",
          "args": [
            "setup"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "initFromSetup",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "222-231",
          "snippet": "status _AFfilehandle::initFromSetup(AFfilesetup setup)\n{\n\tif (copyTracksFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\tif (copyInstrumentsFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\tif (copyMiscellaneousFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  status _AFfilehandle::initFromSetup(AFfilesetup setup)\n  {\n  \tif (copyTracksFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \tif (copyInstrumentsFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \tif (copyMiscellaneousFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \treturn AF_SUCCEED;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::writeInit(AFfilesetup setup)\n  {\n  \tif (initFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \n  \tinitCompressionParams();\n  \n  \tuint32_t zero = 0;\n  \n  \tm_fh->seek(0, File::SeekFromBeginning);\n  \tm_fh->write(\"RIFF\", 4);\n  \tm_fh->write(&zero, 4);\n  \tm_fh->write(\"WAVE\", 4);\n  \n  \twriteMiscellaneous();\n  \twriteCues();\n  \twriteFormat();\n  \twriteFrameCount();\n  \twriteData();\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "zStringLength",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "1514-1518",
    "snippet": "size_t WAVEFile::zStringLength(const char *s)\n{\n\tsize_t lengthPlusNull = strlen(s) + 1;\n\treturn lengthPlusNull + (lengthPlusNull & 1);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  size_t WAVEFile::zStringLength(const char *s)\n  {\n  \tsize_t lengthPlusNull = strlen(s) + 1;\n  \treturn lengthPlusNull + (lengthPlusNull & 1);\n  }\n}"
  },
  {
    "function_name": "writeZString",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "1500-1512",
    "snippet": "bool WAVEFile::writeZString(const char *s)\n{\n\tssize_t lengthPlusNull = strlen(s) + 1;\n\tif (m_fh->write(s, lengthPlusNull) != lengthPlusNull)\n\t\treturn false;\n\tif (lengthPlusNull & 1)\n\t{\n\t\tuint8_t zero = 0;\n\t\tif (!writeU8(&zero))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeU8",
          "args": [
            "&zero"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "writeU8",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "430-430",
          "snippet": "bool _AFfilehandle::writeU8(const uint8_t *v) { return writeValue(m_fh, v); }",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU8(const uint8_t *v) { return writeValue(m_fh, v); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "s",
            "lengthPlusNull"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  bool WAVEFile::writeZString(const char *s)\n  {\n  \tssize_t lengthPlusNull = strlen(s) + 1;\n  \tif (m_fh->write(s, lengthPlusNull) != lengthPlusNull)\n  \t\treturn false;\n  \tif (lengthPlusNull & 1)\n  \t{\n  \t\tuint8_t zero = 0;\n  \t\tif (!writeU8(&zero))\n  \t\t\treturn false;\n  \t}\n  \treturn true;\n  }\n}"
  },
  {
    "function_name": "writeCues",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "1399-1498",
    "snippet": "status WAVEFile::writeCues()\n{\n\tTrack *track = getTrack();\n\n\tif (!track->markerCount)\n\t\treturn AF_SUCCEED;\n\n\tif (m_markOffset == 0)\n\t\tm_markOffset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_markOffset, File::SeekFromBeginning);\n\n\tTag cue(\"cue \");\n\twriteTag(&cue);\n\n\t/*\n\t\tThe cue chunk consists of 4 bytes for the number of cue points\n\t\tfollowed by 24 bytes for each cue point record.\n\t*/\n\tuint32_t cueChunkSize = 4 + track->markerCount * 24;\n\twriteU32(&cueChunkSize);\n\tuint32_t numCues = track->markerCount;\n\twriteU32(&numCues);\n\n\t// Write each marker to the file.\n\tfor (int i=0; i<track->markerCount; i++)\n\t{\n\t\tuint32_t identifier = track->markers[i].id;\n\t\twriteU32(&identifier);\n\n\t\tuint32_t position = i;\n\t\twriteU32(&position);\n\n\t\tTag data(\"data\");\n\t\twriteTag(&data);\n\n\t\t/*\n\t\t\tFor an uncompressed WAVE file which contains only one data chunk,\n\t\t\tchunkStart and blockStart are zero.\n\t\t*/\n\t\tuint32_t chunkStart = 0;\n\t\twriteU32(&chunkStart);\n\n\t\tuint32_t blockStart = 0;\n\t\twriteU32(&blockStart);\n\n\t\tAFframecount markPosition = track->markers[i].position;\n\t\tuint32_t sampleOffset = markPosition;\n\t\twriteU32(&sampleOffset);\n\t}\n\n\t// Now write the cue names and comments within a master list chunk.\n\tuint32_t listChunkSize = 4;\n\tfor (int i=0; i<track->markerCount; i++)\n\t{\n\t\tconst char *name = track->markers[i].name;\n\t\tconst char *comment = track->markers[i].comment;\n\n\t\t/*\n\t\t\tEach 'labl' or 'note' chunk consists of 4 bytes for the chunk ID,\n\t\t\t4 bytes for the chunk data size, 4 bytes for the cue point ID,\n\t\t\tand then the length of the label as a null-terminated string.\n\n\t\t\tIn all, this is 12 bytes plus the length of the string, its null\n\t\t\ttermination byte, and a trailing pad byte if the length of the\n\t\t\tchunk is otherwise odd.\n\t\t*/\n\t\tlistChunkSize += 12 + zStringLength(name);\n\t\tlistChunkSize += 12 + zStringLength(comment);\n\t}\n\n\tTag list(\"LIST\");\n\twriteTag(&list);\n\twriteU32(&listChunkSize);\n\tTag adtl(\"adtl\");\n\twriteTag(&adtl);\n\n\tfor (int i=0; i<track->markerCount; i++)\n\t{\n\t\tuint32_t cuePointID = track->markers[i].id;\n\n\t\tconst char *name = track->markers[i].name;\n\t\tuint32_t labelSize = 4 + zStringLength(name);\n\t\tTag lablTag(\"labl\");\n\t\twriteTag(&lablTag);\n\t\twriteU32(&labelSize);\n\t\twriteU32(&cuePointID);\n\t\twriteZString(name);\n\n\t\tconst char *comment = track->markers[i].comment;\n\t\tuint32_t noteSize = 4 + zStringLength(comment);\n\t\tTag noteTag(\"note\");\n\t\twriteTag(&noteTag);\n\t\twriteU32(&noteSize);\n\t\twriteU32(&cuePointID);\n\t\twriteZString(comment);\n\t}\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeZString",
          "args": [
            "comment"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "writeZString",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "1500-1512",
          "snippet": "bool WAVEFile::writeZString(const char *s)\n{\n\tssize_t lengthPlusNull = strlen(s) + 1;\n\tif (m_fh->write(s, lengthPlusNull) != lengthPlusNull)\n\t\treturn false;\n\tif (lengthPlusNull & 1)\n\t{\n\t\tuint8_t zero = 0;\n\t\tif (!writeU8(&zero))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  bool WAVEFile::writeZString(const char *s)\n  {\n  \tssize_t lengthPlusNull = strlen(s) + 1;\n  \tif (m_fh->write(s, lengthPlusNull) != lengthPlusNull)\n  \t\treturn false;\n  \tif (lengthPlusNull & 1)\n  \t{\n  \t\tuint8_t zero = 0;\n  \t\tif (!writeU8(&zero))\n  \t\t\treturn false;\n  \t}\n  \treturn true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&cuePointID"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeTag",
          "args": [
            "&noteTag"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "writeTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "484-488",
          "snippet": "bool _AFfilehandle::writeTag(const Tag *t)\n{\n\tuint32_t v = t->value();\n\treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeTag(const Tag *t)\n  {\n  \tuint32_t v = t->value();\n  \treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "zStringLength",
          "args": [
            "comment"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "zStringLength",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "1514-1518",
          "snippet": "size_t WAVEFile::zStringLength(const char *s)\n{\n\tsize_t lengthPlusNull = strlen(s) + 1;\n\treturn lengthPlusNull + (lengthPlusNull & 1);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  size_t WAVEFile::zStringLength(const char *s)\n  {\n  \tsize_t lengthPlusNull = strlen(s) + 1;\n  \treturn lengthPlusNull + (lengthPlusNull & 1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "m_markOffset",
            "File::SeekFromBeginning"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::writeCues()\n  {\n  \tTrack *track = getTrack();\n  \n  \tif (!track->markerCount)\n  \t\treturn AF_SUCCEED;\n  \n  \tif (m_markOffset == 0)\n  \t\tm_markOffset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_markOffset, File::SeekFromBeginning);\n  \n  \tTag cue(\"cue \");\n  \twriteTag(&cue);\n  \n  \t/*\n  \t\tThe cue chunk consists of 4 bytes for the number of cue points\n  \t\tfollowed by 24 bytes for each cue point record.\n  \t*/\n  \tuint32_t cueChunkSize = 4 + track->markerCount * 24;\n  \twriteU32(&cueChunkSize);\n  \tuint32_t numCues = track->markerCount;\n  \twriteU32(&numCues);\n  \n  \t// Write each marker to the file.\n  \tfor (int i=0; i<track->markerCount; i++)\n  \t{\n  \t\tuint32_t identifier = track->markers[i].id;\n  \t\twriteU32(&identifier);\n  \n  \t\tuint32_t position = i;\n  \t\twriteU32(&position);\n  \n  \t\tTag data(\"data\");\n  \t\twriteTag(&data);\n  \n  \t\t/*\n  \t\t\tFor an uncompressed WAVE file which contains only one data chunk,\n  \t\t\tchunkStart and blockStart are zero.\n  \t\t*/\n  \t\tuint32_t chunkStart = 0;\n  \t\twriteU32(&chunkStart);\n  \n  \t\tuint32_t blockStart = 0;\n  \t\twriteU32(&blockStart);\n  \n  \t\tAFframecount markPosition = track->markers[i].position;\n  \t\tuint32_t sampleOffset = markPosition;\n  \t\twriteU32(&sampleOffset);\n  \t}\n  \n  \t// Now write the cue names and comments within a master list chunk.\n  \tuint32_t listChunkSize = 4;\n  \tfor (int i=0; i<track->markerCount; i++)\n  \t{\n  \t\tconst char *name = track->markers[i].name;\n  \t\tconst char *comment = track->markers[i].comment;\n  \n  \t\t/*\n  \t\t\tEach 'labl' or 'note' chunk consists of 4 bytes for the chunk ID,\n  \t\t\t4 bytes for the chunk data size, 4 bytes for the cue point ID,\n  \t\t\tand then the length of the label as a null-terminated string.\n  \n  \t\t\tIn all, this is 12 bytes plus the length of the string, its null\n  \t\t\ttermination byte, and a trailing pad byte if the length of the\n  \t\t\tchunk is otherwise odd.\n  \t\t*/\n  \t\tlistChunkSize += 12 + zStringLength(name);\n  \t\tlistChunkSize += 12 + zStringLength(comment);\n  \t}\n  \n  \tTag list(\"LIST\");\n  \twriteTag(&list);\n  \twriteU32(&listChunkSize);\n  \tTag adtl(\"adtl\");\n  \twriteTag(&adtl);\n  \n  \tfor (int i=0; i<track->markerCount; i++)\n  \t{\n  \t\tuint32_t cuePointID = track->markers[i].id;\n  \n  \t\tconst char *name = track->markers[i].name;\n  \t\tuint32_t labelSize = 4 + zStringLength(name);\n  \t\tTag lablTag(\"labl\");\n  \t\twriteTag(&lablTag);\n  \t\twriteU32(&labelSize);\n  \t\twriteU32(&cuePointID);\n  \t\twriteZString(name);\n  \n  \t\tconst char *comment = track->markers[i].comment;\n  \t\tuint32_t noteSize = 4 + zStringLength(comment);\n  \t\tTag noteTag(\"note\");\n  \t\twriteTag(&noteTag);\n  \t\twriteU32(&noteSize);\n  \t\twriteU32(&cuePointID);\n  \t\twriteZString(comment);\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeMiscellaneous",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "1307-1397",
    "snippet": "status WAVEFile::writeMiscellaneous()\n{\n\tif (m_miscellaneousCount != 0)\n\t{\n\t\tuint32_t\tmiscellaneousBytes;\n\t\tuint32_t \tchunkSize;\n\n\t\t/* Start at 12 to account for 'LIST', size, and 'INFO'. */\n\t\tmiscellaneousBytes = 12;\n\n\t\t/* Then calculate the size of the whole INFO chunk. */\n\t\tfor (int i=0; i<m_miscellaneousCount; i++)\n\t\t{\n\t\t\tTag miscid;\n\n\t\t\t// Skip miscellaneous data of an unsupported type.\n\t\t\tif (!misc_type_to_wave(m_miscellaneous[i].type, &miscid))\n\t\t\t\tcontinue;\n\n\t\t\t// Account for miscellaneous type and size.\n\t\t\tmiscellaneousBytes += 8;\n\t\t\tmiscellaneousBytes += m_miscellaneous[i].size;\n\n\t\t\t// Add a pad byte if necessary.\n\t\t\tif (m_miscellaneous[i].size % 2 != 0)\n\t\t\t\tmiscellaneousBytes++;\n\n\t\t\tassert(miscellaneousBytes % 2 == 0);\n\t\t}\n\n\t\tif (m_miscellaneousOffset == 0)\n\t\t\tm_miscellaneousOffset = m_fh->tell();\n\t\telse\n\t\t\tm_fh->seek(m_miscellaneousOffset, File::SeekFromBeginning);\n\n\t\t/*\n\t\t\tWrite the data.  On the first call to this\n\t\t\tfunction (from _af_wave_write_init), the\n\t\t\tdata won't be available, fh->seek is used to\n\t\t\treserve space until the data has been provided.\n\t\t\tOn subseuent calls to this function (from\n\t\t\t_af_wave_update), the data will really be written.\n\t\t*/\n\n\t\t/* Write 'LIST'. */\n\t\tm_fh->write(\"LIST\", 4);\n\n\t\t/* Write the size of the following chunk. */\n\t\tchunkSize = miscellaneousBytes-8;\n\t\twriteU32(&chunkSize);\n\n\t\t/* Write 'INFO'. */\n\t\tm_fh->write(\"INFO\", 4);\n\n\t\t/* Write each miscellaneous chunk. */\n\t\tfor (int i=0; i<m_miscellaneousCount; i++)\n\t\t{\n\t\t\tuint32_t miscsize = m_miscellaneous[i].size;\n\t\t\tTag miscid;\n\n\t\t\t// Skip miscellaneous data of an unsupported type.\n\t\t\tif (!misc_type_to_wave(m_miscellaneous[i].type, &miscid))\n\t\t\t\tcontinue;\n\n\t\t\twriteTag(&miscid);\n\t\t\twriteU32(&miscsize);\n\t\t\tif (m_miscellaneous[i].buffer != NULL)\n\t\t\t{\n\t\t\t\tuint8_t\tzero = 0;\n\n\t\t\t\tm_fh->write(m_miscellaneous[i].buffer, m_miscellaneous[i].size);\n\n\t\t\t\t// Pad if necessary.\n\t\t\t\tif ((m_miscellaneous[i].size%2) != 0)\n\t\t\t\t\twriteU8(&zero);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\tsize;\n\t\t\t\tsize = m_miscellaneous[i].size;\n\n\t\t\t\t// Pad if necessary.\n\t\t\t\tif ((size % 2) != 0)\n\t\t\t\t\tsize++;\n\t\t\t\tm_fh->seek(size, File::SeekFromCurrent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "size",
            "File::SeekFromCurrent"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU8",
          "args": [
            "&zero"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "writeU8",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "430-430",
          "snippet": "bool _AFfilehandle::writeU8(const uint8_t *v) { return writeValue(m_fh, v); }",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU8(const uint8_t *v) { return writeValue(m_fh, v); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "m_miscellaneous[i].buffer",
            "m_miscellaneous[i].size"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&miscsize"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeTag",
          "args": [
            "&miscid"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "writeTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "484-488",
          "snippet": "bool _AFfilehandle::writeTag(const Tag *t)\n{\n\tuint32_t v = t->value();\n\treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeTag(const Tag *t)\n  {\n  \tuint32_t v = t->value();\n  \treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "misc_type_to_wave",
          "args": [
            "m_miscellaneous[i].type",
            "&miscid"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "misc_type_to_wave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "1287-1305",
          "snippet": "static bool misc_type_to_wave (int misctype, Tag *miscid)\n{\n\tif (misctype == AF_MISC_AUTH)\n\t\t*miscid = \"IART\";\n\telse if (misctype == AF_MISC_NAME)\n\t\t*miscid = \"INAM\";\n\telse if (misctype == AF_MISC_COPY)\n\t\t*miscid = \"ICOP\";\n\telse if (misctype == AF_MISC_ICMT)\n\t\t*miscid = \"ICMT\";\n\telse if (misctype == AF_MISC_ICRD)\n\t\t*miscid = \"ICRD\";\n\telse if (misctype == AF_MISC_ISFT)\n\t\t*miscid = \"ISFT\";\n\telse\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nstatic bool misc_type_to_wave (int misctype, Tag *miscid)\n{\n\tif (misctype == AF_MISC_AUTH)\n\t\t*miscid = \"IART\";\n\telse if (misctype == AF_MISC_NAME)\n\t\t*miscid = \"INAM\";\n\telse if (misctype == AF_MISC_COPY)\n\t\t*miscid = \"ICOP\";\n\telse if (misctype == AF_MISC_ICMT)\n\t\t*miscid = \"ICMT\";\n\telse if (misctype == AF_MISC_ICRD)\n\t\t*miscid = \"ICRD\";\n\telse if (misctype == AF_MISC_ISFT)\n\t\t*miscid = \"ISFT\";\n\telse\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "miscellaneousBytes % 2 == 0"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::writeMiscellaneous()\n  {\n  \tif (m_miscellaneousCount != 0)\n  \t{\n  \t\tuint32_t\tmiscellaneousBytes;\n  \t\tuint32_t \tchunkSize;\n  \n  \t\t/* Start at 12 to account for 'LIST', size, and 'INFO'. */\n  \t\tmiscellaneousBytes = 12;\n  \n  \t\t/* Then calculate the size of the whole INFO chunk. */\n  \t\tfor (int i=0; i<m_miscellaneousCount; i++)\n  \t\t{\n  \t\t\tTag miscid;\n  \n  \t\t\t// Skip miscellaneous data of an unsupported type.\n  \t\t\tif (!misc_type_to_wave(m_miscellaneous[i].type, &miscid))\n  \t\t\t\tcontinue;\n  \n  \t\t\t// Account for miscellaneous type and size.\n  \t\t\tmiscellaneousBytes += 8;\n  \t\t\tmiscellaneousBytes += m_miscellaneous[i].size;\n  \n  \t\t\t// Add a pad byte if necessary.\n  \t\t\tif (m_miscellaneous[i].size % 2 != 0)\n  \t\t\t\tmiscellaneousBytes++;\n  \n  \t\t\tassert(miscellaneousBytes % 2 == 0);\n  \t\t}\n  \n  \t\tif (m_miscellaneousOffset == 0)\n  \t\t\tm_miscellaneousOffset = m_fh->tell();\n  \t\telse\n  \t\t\tm_fh->seek(m_miscellaneousOffset, File::SeekFromBeginning);\n  \n  \t\t/*\n  \t\t\tWrite the data.  On the first call to this\n  \t\t\tfunction (from _af_wave_write_init), the\n  \t\t\tdata won't be available, fh->seek is used to\n  \t\t\treserve space until the data has been provided.\n  \t\t\tOn subseuent calls to this function (from\n  \t\t\t_af_wave_update), the data will really be written.\n  \t\t*/\n  \n  \t\t/* Write 'LIST'. */\n  \t\tm_fh->write(\"LIST\", 4);\n  \n  \t\t/* Write the size of the following chunk. */\n  \t\tchunkSize = miscellaneousBytes-8;\n  \t\twriteU32(&chunkSize);\n  \n  \t\t/* Write 'INFO'. */\n  \t\tm_fh->write(\"INFO\", 4);\n  \n  \t\t/* Write each miscellaneous chunk. */\n  \t\tfor (int i=0; i<m_miscellaneousCount; i++)\n  \t\t{\n  \t\t\tuint32_t miscsize = m_miscellaneous[i].size;\n  \t\t\tTag miscid;\n  \n  \t\t\t// Skip miscellaneous data of an unsupported type.\n  \t\t\tif (!misc_type_to_wave(m_miscellaneous[i].type, &miscid))\n  \t\t\t\tcontinue;\n  \n  \t\t\twriteTag(&miscid);\n  \t\t\twriteU32(&miscsize);\n  \t\t\tif (m_miscellaneous[i].buffer != NULL)\n  \t\t\t{\n  \t\t\t\tuint8_t\tzero = 0;\n  \n  \t\t\t\tm_fh->write(m_miscellaneous[i].buffer, m_miscellaneous[i].size);\n  \n  \t\t\t\t// Pad if necessary.\n  \t\t\t\tif ((m_miscellaneous[i].size%2) != 0)\n  \t\t\t\t\twriteU8(&zero);\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tint\tsize;\n  \t\t\t\tsize = m_miscellaneous[i].size;\n  \n  \t\t\t\t// Pad if necessary.\n  \t\t\t\tif ((size % 2) != 0)\n  \t\t\t\t\tsize++;\n  \t\t\t\tm_fh->seek(size, File::SeekFromCurrent);\n  \t\t\t}\n  \t\t}\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "misc_type_to_wave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "1287-1305",
    "snippet": "static bool misc_type_to_wave (int misctype, Tag *miscid)\n{\n\tif (misctype == AF_MISC_AUTH)\n\t\t*miscid = \"IART\";\n\telse if (misctype == AF_MISC_NAME)\n\t\t*miscid = \"INAM\";\n\telse if (misctype == AF_MISC_COPY)\n\t\t*miscid = \"ICOP\";\n\telse if (misctype == AF_MISC_ICMT)\n\t\t*miscid = \"ICMT\";\n\telse if (misctype == AF_MISC_ICRD)\n\t\t*miscid = \"ICRD\";\n\telse if (misctype == AF_MISC_ISFT)\n\t\t*miscid = \"ISFT\";\n\telse\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nstatic bool misc_type_to_wave (int misctype, Tag *miscid)\n{\n\tif (misctype == AF_MISC_AUTH)\n\t\t*miscid = \"IART\";\n\telse if (misctype == AF_MISC_NAME)\n\t\t*miscid = \"INAM\";\n\telse if (misctype == AF_MISC_COPY)\n\t\t*miscid = \"ICOP\";\n\telse if (misctype == AF_MISC_ICMT)\n\t\t*miscid = \"ICMT\";\n\telse if (misctype == AF_MISC_ICRD)\n\t\t*miscid = \"ICRD\";\n\telse if (misctype == AF_MISC_ISFT)\n\t\t*miscid = \"ISFT\";\n\telse\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "update",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "1249-1284",
    "snippet": "status WAVEFile::update()\n{\n\tTrack *track = getTrack();\n\n\tif (track->fpos_first_frame != 0)\n\t{\n\t\tuint32_t dataLength, fileLength;\n\n\t\t// Update the frame count chunk if present.\n\t\twriteFrameCount();\n\n\t\t// Update the length of the data chunk.\n\t\tm_fh->seek(m_dataSizeOffset, File::SeekFromBeginning);\n\t\tdataLength = (uint32_t) track->data_size;\n\t\twriteU32(&dataLength);\n\n\t\t// Update the length of the RIFF chunk.\n\t\tfileLength = (uint32_t) m_fh->length();\n\t\tfileLength -= 8;\n\n\t\tm_fh->seek(4, File::SeekFromBeginning);\n\t\twriteU32(&fileLength);\n\t}\n\n\t/*\n\t\tWrite the actual data that was set after initializing\n\t\tthe miscellaneous IDs.\tThe size of the data will be\n\t\tunchanged.\n\t*/\n\twriteMiscellaneous();\n\n\t// Write the new positions; the size of the data will be unchanged.\n\twriteCues();\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeCues",
          "args": [],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "writeCues",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "1399-1498",
          "snippet": "status WAVEFile::writeCues()\n{\n\tTrack *track = getTrack();\n\n\tif (!track->markerCount)\n\t\treturn AF_SUCCEED;\n\n\tif (m_markOffset == 0)\n\t\tm_markOffset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_markOffset, File::SeekFromBeginning);\n\n\tTag cue(\"cue \");\n\twriteTag(&cue);\n\n\t/*\n\t\tThe cue chunk consists of 4 bytes for the number of cue points\n\t\tfollowed by 24 bytes for each cue point record.\n\t*/\n\tuint32_t cueChunkSize = 4 + track->markerCount * 24;\n\twriteU32(&cueChunkSize);\n\tuint32_t numCues = track->markerCount;\n\twriteU32(&numCues);\n\n\t// Write each marker to the file.\n\tfor (int i=0; i<track->markerCount; i++)\n\t{\n\t\tuint32_t identifier = track->markers[i].id;\n\t\twriteU32(&identifier);\n\n\t\tuint32_t position = i;\n\t\twriteU32(&position);\n\n\t\tTag data(\"data\");\n\t\twriteTag(&data);\n\n\t\t/*\n\t\t\tFor an uncompressed WAVE file which contains only one data chunk,\n\t\t\tchunkStart and blockStart are zero.\n\t\t*/\n\t\tuint32_t chunkStart = 0;\n\t\twriteU32(&chunkStart);\n\n\t\tuint32_t blockStart = 0;\n\t\twriteU32(&blockStart);\n\n\t\tAFframecount markPosition = track->markers[i].position;\n\t\tuint32_t sampleOffset = markPosition;\n\t\twriteU32(&sampleOffset);\n\t}\n\n\t// Now write the cue names and comments within a master list chunk.\n\tuint32_t listChunkSize = 4;\n\tfor (int i=0; i<track->markerCount; i++)\n\t{\n\t\tconst char *name = track->markers[i].name;\n\t\tconst char *comment = track->markers[i].comment;\n\n\t\t/*\n\t\t\tEach 'labl' or 'note' chunk consists of 4 bytes for the chunk ID,\n\t\t\t4 bytes for the chunk data size, 4 bytes for the cue point ID,\n\t\t\tand then the length of the label as a null-terminated string.\n\n\t\t\tIn all, this is 12 bytes plus the length of the string, its null\n\t\t\ttermination byte, and a trailing pad byte if the length of the\n\t\t\tchunk is otherwise odd.\n\t\t*/\n\t\tlistChunkSize += 12 + zStringLength(name);\n\t\tlistChunkSize += 12 + zStringLength(comment);\n\t}\n\n\tTag list(\"LIST\");\n\twriteTag(&list);\n\twriteU32(&listChunkSize);\n\tTag adtl(\"adtl\");\n\twriteTag(&adtl);\n\n\tfor (int i=0; i<track->markerCount; i++)\n\t{\n\t\tuint32_t cuePointID = track->markers[i].id;\n\n\t\tconst char *name = track->markers[i].name;\n\t\tuint32_t labelSize = 4 + zStringLength(name);\n\t\tTag lablTag(\"labl\");\n\t\twriteTag(&lablTag);\n\t\twriteU32(&labelSize);\n\t\twriteU32(&cuePointID);\n\t\twriteZString(name);\n\n\t\tconst char *comment = track->markers[i].comment;\n\t\tuint32_t noteSize = 4 + zStringLength(comment);\n\t\tTag noteTag(\"note\");\n\t\twriteTag(&noteTag);\n\t\twriteU32(&noteSize);\n\t\twriteU32(&cuePointID);\n\t\twriteZString(comment);\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::writeCues()\n  {\n  \tTrack *track = getTrack();\n  \n  \tif (!track->markerCount)\n  \t\treturn AF_SUCCEED;\n  \n  \tif (m_markOffset == 0)\n  \t\tm_markOffset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_markOffset, File::SeekFromBeginning);\n  \n  \tTag cue(\"cue \");\n  \twriteTag(&cue);\n  \n  \t/*\n  \t\tThe cue chunk consists of 4 bytes for the number of cue points\n  \t\tfollowed by 24 bytes for each cue point record.\n  \t*/\n  \tuint32_t cueChunkSize = 4 + track->markerCount * 24;\n  \twriteU32(&cueChunkSize);\n  \tuint32_t numCues = track->markerCount;\n  \twriteU32(&numCues);\n  \n  \t// Write each marker to the file.\n  \tfor (int i=0; i<track->markerCount; i++)\n  \t{\n  \t\tuint32_t identifier = track->markers[i].id;\n  \t\twriteU32(&identifier);\n  \n  \t\tuint32_t position = i;\n  \t\twriteU32(&position);\n  \n  \t\tTag data(\"data\");\n  \t\twriteTag(&data);\n  \n  \t\t/*\n  \t\t\tFor an uncompressed WAVE file which contains only one data chunk,\n  \t\t\tchunkStart and blockStart are zero.\n  \t\t*/\n  \t\tuint32_t chunkStart = 0;\n  \t\twriteU32(&chunkStart);\n  \n  \t\tuint32_t blockStart = 0;\n  \t\twriteU32(&blockStart);\n  \n  \t\tAFframecount markPosition = track->markers[i].position;\n  \t\tuint32_t sampleOffset = markPosition;\n  \t\twriteU32(&sampleOffset);\n  \t}\n  \n  \t// Now write the cue names and comments within a master list chunk.\n  \tuint32_t listChunkSize = 4;\n  \tfor (int i=0; i<track->markerCount; i++)\n  \t{\n  \t\tconst char *name = track->markers[i].name;\n  \t\tconst char *comment = track->markers[i].comment;\n  \n  \t\t/*\n  \t\t\tEach 'labl' or 'note' chunk consists of 4 bytes for the chunk ID,\n  \t\t\t4 bytes for the chunk data size, 4 bytes for the cue point ID,\n  \t\t\tand then the length of the label as a null-terminated string.\n  \n  \t\t\tIn all, this is 12 bytes plus the length of the string, its null\n  \t\t\ttermination byte, and a trailing pad byte if the length of the\n  \t\t\tchunk is otherwise odd.\n  \t\t*/\n  \t\tlistChunkSize += 12 + zStringLength(name);\n  \t\tlistChunkSize += 12 + zStringLength(comment);\n  \t}\n  \n  \tTag list(\"LIST\");\n  \twriteTag(&list);\n  \twriteU32(&listChunkSize);\n  \tTag adtl(\"adtl\");\n  \twriteTag(&adtl);\n  \n  \tfor (int i=0; i<track->markerCount; i++)\n  \t{\n  \t\tuint32_t cuePointID = track->markers[i].id;\n  \n  \t\tconst char *name = track->markers[i].name;\n  \t\tuint32_t labelSize = 4 + zStringLength(name);\n  \t\tTag lablTag(\"labl\");\n  \t\twriteTag(&lablTag);\n  \t\twriteU32(&labelSize);\n  \t\twriteU32(&cuePointID);\n  \t\twriteZString(name);\n  \n  \t\tconst char *comment = track->markers[i].comment;\n  \t\tuint32_t noteSize = 4 + zStringLength(comment);\n  \t\tTag noteTag(\"note\");\n  \t\twriteTag(&noteTag);\n  \t\twriteU32(&noteSize);\n  \t\twriteU32(&cuePointID);\n  \t\twriteZString(comment);\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeMiscellaneous",
          "args": [],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "writeMiscellaneous",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "1307-1397",
          "snippet": "status WAVEFile::writeMiscellaneous()\n{\n\tif (m_miscellaneousCount != 0)\n\t{\n\t\tuint32_t\tmiscellaneousBytes;\n\t\tuint32_t \tchunkSize;\n\n\t\t/* Start at 12 to account for 'LIST', size, and 'INFO'. */\n\t\tmiscellaneousBytes = 12;\n\n\t\t/* Then calculate the size of the whole INFO chunk. */\n\t\tfor (int i=0; i<m_miscellaneousCount; i++)\n\t\t{\n\t\t\tTag miscid;\n\n\t\t\t// Skip miscellaneous data of an unsupported type.\n\t\t\tif (!misc_type_to_wave(m_miscellaneous[i].type, &miscid))\n\t\t\t\tcontinue;\n\n\t\t\t// Account for miscellaneous type and size.\n\t\t\tmiscellaneousBytes += 8;\n\t\t\tmiscellaneousBytes += m_miscellaneous[i].size;\n\n\t\t\t// Add a pad byte if necessary.\n\t\t\tif (m_miscellaneous[i].size % 2 != 0)\n\t\t\t\tmiscellaneousBytes++;\n\n\t\t\tassert(miscellaneousBytes % 2 == 0);\n\t\t}\n\n\t\tif (m_miscellaneousOffset == 0)\n\t\t\tm_miscellaneousOffset = m_fh->tell();\n\t\telse\n\t\t\tm_fh->seek(m_miscellaneousOffset, File::SeekFromBeginning);\n\n\t\t/*\n\t\t\tWrite the data.  On the first call to this\n\t\t\tfunction (from _af_wave_write_init), the\n\t\t\tdata won't be available, fh->seek is used to\n\t\t\treserve space until the data has been provided.\n\t\t\tOn subseuent calls to this function (from\n\t\t\t_af_wave_update), the data will really be written.\n\t\t*/\n\n\t\t/* Write 'LIST'. */\n\t\tm_fh->write(\"LIST\", 4);\n\n\t\t/* Write the size of the following chunk. */\n\t\tchunkSize = miscellaneousBytes-8;\n\t\twriteU32(&chunkSize);\n\n\t\t/* Write 'INFO'. */\n\t\tm_fh->write(\"INFO\", 4);\n\n\t\t/* Write each miscellaneous chunk. */\n\t\tfor (int i=0; i<m_miscellaneousCount; i++)\n\t\t{\n\t\t\tuint32_t miscsize = m_miscellaneous[i].size;\n\t\t\tTag miscid;\n\n\t\t\t// Skip miscellaneous data of an unsupported type.\n\t\t\tif (!misc_type_to_wave(m_miscellaneous[i].type, &miscid))\n\t\t\t\tcontinue;\n\n\t\t\twriteTag(&miscid);\n\t\t\twriteU32(&miscsize);\n\t\t\tif (m_miscellaneous[i].buffer != NULL)\n\t\t\t{\n\t\t\t\tuint8_t\tzero = 0;\n\n\t\t\t\tm_fh->write(m_miscellaneous[i].buffer, m_miscellaneous[i].size);\n\n\t\t\t\t// Pad if necessary.\n\t\t\t\tif ((m_miscellaneous[i].size%2) != 0)\n\t\t\t\t\twriteU8(&zero);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\tsize;\n\t\t\t\tsize = m_miscellaneous[i].size;\n\n\t\t\t\t// Pad if necessary.\n\t\t\t\tif ((size % 2) != 0)\n\t\t\t\t\tsize++;\n\t\t\t\tm_fh->seek(size, File::SeekFromCurrent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::writeMiscellaneous()\n  {\n  \tif (m_miscellaneousCount != 0)\n  \t{\n  \t\tuint32_t\tmiscellaneousBytes;\n  \t\tuint32_t \tchunkSize;\n  \n  \t\t/* Start at 12 to account for 'LIST', size, and 'INFO'. */\n  \t\tmiscellaneousBytes = 12;\n  \n  \t\t/* Then calculate the size of the whole INFO chunk. */\n  \t\tfor (int i=0; i<m_miscellaneousCount; i++)\n  \t\t{\n  \t\t\tTag miscid;\n  \n  \t\t\t// Skip miscellaneous data of an unsupported type.\n  \t\t\tif (!misc_type_to_wave(m_miscellaneous[i].type, &miscid))\n  \t\t\t\tcontinue;\n  \n  \t\t\t// Account for miscellaneous type and size.\n  \t\t\tmiscellaneousBytes += 8;\n  \t\t\tmiscellaneousBytes += m_miscellaneous[i].size;\n  \n  \t\t\t// Add a pad byte if necessary.\n  \t\t\tif (m_miscellaneous[i].size % 2 != 0)\n  \t\t\t\tmiscellaneousBytes++;\n  \n  \t\t\tassert(miscellaneousBytes % 2 == 0);\n  \t\t}\n  \n  \t\tif (m_miscellaneousOffset == 0)\n  \t\t\tm_miscellaneousOffset = m_fh->tell();\n  \t\telse\n  \t\t\tm_fh->seek(m_miscellaneousOffset, File::SeekFromBeginning);\n  \n  \t\t/*\n  \t\t\tWrite the data.  On the first call to this\n  \t\t\tfunction (from _af_wave_write_init), the\n  \t\t\tdata won't be available, fh->seek is used to\n  \t\t\treserve space until the data has been provided.\n  \t\t\tOn subseuent calls to this function (from\n  \t\t\t_af_wave_update), the data will really be written.\n  \t\t*/\n  \n  \t\t/* Write 'LIST'. */\n  \t\tm_fh->write(\"LIST\", 4);\n  \n  \t\t/* Write the size of the following chunk. */\n  \t\tchunkSize = miscellaneousBytes-8;\n  \t\twriteU32(&chunkSize);\n  \n  \t\t/* Write 'INFO'. */\n  \t\tm_fh->write(\"INFO\", 4);\n  \n  \t\t/* Write each miscellaneous chunk. */\n  \t\tfor (int i=0; i<m_miscellaneousCount; i++)\n  \t\t{\n  \t\t\tuint32_t miscsize = m_miscellaneous[i].size;\n  \t\t\tTag miscid;\n  \n  \t\t\t// Skip miscellaneous data of an unsupported type.\n  \t\t\tif (!misc_type_to_wave(m_miscellaneous[i].type, &miscid))\n  \t\t\t\tcontinue;\n  \n  \t\t\twriteTag(&miscid);\n  \t\t\twriteU32(&miscsize);\n  \t\t\tif (m_miscellaneous[i].buffer != NULL)\n  \t\t\t{\n  \t\t\t\tuint8_t\tzero = 0;\n  \n  \t\t\t\tm_fh->write(m_miscellaneous[i].buffer, m_miscellaneous[i].size);\n  \n  \t\t\t\t// Pad if necessary.\n  \t\t\t\tif ((m_miscellaneous[i].size%2) != 0)\n  \t\t\t\t\twriteU8(&zero);\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tint\tsize;\n  \t\t\t\tsize = m_miscellaneous[i].size;\n  \n  \t\t\t\t// Pad if necessary.\n  \t\t\t\tif ((size % 2) != 0)\n  \t\t\t\t\tsize++;\n  \t\t\t\tm_fh->seek(size, File::SeekFromCurrent);\n  \t\t\t}\n  \t\t}\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&fileLength"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "4",
            "File::SeekFromBeginning"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->length",
          "args": [],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "182-185",
          "snippet": "off_t FileVF::length()\n{\n\treturn m_vf->length(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::length()\n  {\n  \treturn m_vf->length(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeFrameCount",
          "args": [],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "writeFrameCount",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "1203-1232",
          "snippet": "status WAVEFile::writeFrameCount()\n{\n\tuint32_t factSize = 4;\n\tuint32_t totalFrameCount;\n\n\tTrack *track = getTrack();\n\n\t/* Omit the fact chunk only for uncompressed integer audio formats. */\n\tif (track->f.compressionType == AF_COMPRESSION_NONE &&\n\t\t(track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP ||\n\t\ttrack->f.sampleFormat == AF_SAMPFMT_UNSIGNED))\n\t\treturn AF_SUCCEED;\n\n\t/*\n\t\tIf the offset for the fact chunk hasn't been set yet,\n\t\tset it to the file's current position.\n\t*/\n\tif (m_factOffset == 0)\n\t\tm_factOffset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_factOffset, File::SeekFromBeginning);\n\n\tm_fh->write(\"fact\", 4);\n\twriteU32(&factSize);\n\n\ttotalFrameCount = track->totalfframes;\n\twriteU32(&totalFrameCount);\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::writeFrameCount()\n  {\n  \tuint32_t factSize = 4;\n  \tuint32_t totalFrameCount;\n  \n  \tTrack *track = getTrack();\n  \n  \t/* Omit the fact chunk only for uncompressed integer audio formats. */\n  \tif (track->f.compressionType == AF_COMPRESSION_NONE &&\n  \t\t(track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP ||\n  \t\ttrack->f.sampleFormat == AF_SAMPFMT_UNSIGNED))\n  \t\treturn AF_SUCCEED;\n  \n  \t/*\n  \t\tIf the offset for the fact chunk hasn't been set yet,\n  \t\tset it to the file's current position.\n  \t*/\n  \tif (m_factOffset == 0)\n  \t\tm_factOffset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_factOffset, File::SeekFromBeginning);\n  \n  \tm_fh->write(\"fact\", 4);\n  \twriteU32(&factSize);\n  \n  \ttotalFrameCount = track->totalfframes;\n  \twriteU32(&totalFrameCount);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::update()\n  {\n  \tTrack *track = getTrack();\n  \n  \tif (track->fpos_first_frame != 0)\n  \t{\n  \t\tuint32_t dataLength, fileLength;\n  \n  \t\t// Update the frame count chunk if present.\n  \t\twriteFrameCount();\n  \n  \t\t// Update the length of the data chunk.\n  \t\tm_fh->seek(m_dataSizeOffset, File::SeekFromBeginning);\n  \t\tdataLength = (uint32_t) track->data_size;\n  \t\twriteU32(&dataLength);\n  \n  \t\t// Update the length of the RIFF chunk.\n  \t\tfileLength = (uint32_t) m_fh->length();\n  \t\tfileLength -= 8;\n  \n  \t\tm_fh->seek(4, File::SeekFromBeginning);\n  \t\twriteU32(&fileLength);\n  \t}\n  \n  \t/*\n  \t\tWrite the actual data that was set after initializing\n  \t\tthe miscellaneous IDs.\tThe size of the data will be\n  \t\tunchanged.\n  \t*/\n  \twriteMiscellaneous();\n  \n  \t// Write the new positions; the size of the data will be unchanged.\n  \twriteCues();\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeData",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "1234-1247",
    "snippet": "status WAVEFile::writeData()\n{\n\tTrack *track = getTrack();\n\n\tm_fh->write(\"data\", 4);\n\tm_dataSizeOffset = m_fh->tell();\n\n\tuint32_t chunkSize = track->data_size;\n\n\twriteU32(&chunkSize);\n\ttrack->fpos_first_frame = m_fh->tell();\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&chunkSize"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "\"data\"",
            "4"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::writeData()\n  {\n  \tTrack *track = getTrack();\n  \n  \tm_fh->write(\"data\", 4);\n  \tm_dataSizeOffset = m_fh->tell();\n  \n  \tuint32_t chunkSize = track->data_size;\n  \n  \twriteU32(&chunkSize);\n  \ttrack->fpos_first_frame = m_fh->tell();\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeFrameCount",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "1203-1232",
    "snippet": "status WAVEFile::writeFrameCount()\n{\n\tuint32_t factSize = 4;\n\tuint32_t totalFrameCount;\n\n\tTrack *track = getTrack();\n\n\t/* Omit the fact chunk only for uncompressed integer audio formats. */\n\tif (track->f.compressionType == AF_COMPRESSION_NONE &&\n\t\t(track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP ||\n\t\ttrack->f.sampleFormat == AF_SAMPFMT_UNSIGNED))\n\t\treturn AF_SUCCEED;\n\n\t/*\n\t\tIf the offset for the fact chunk hasn't been set yet,\n\t\tset it to the file's current position.\n\t*/\n\tif (m_factOffset == 0)\n\t\tm_factOffset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_factOffset, File::SeekFromBeginning);\n\n\tm_fh->write(\"fact\", 4);\n\twriteU32(&factSize);\n\n\ttotalFrameCount = track->totalfframes;\n\twriteU32(&totalFrameCount);\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&totalFrameCount"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "\"fact\"",
            "4"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "m_factOffset",
            "File::SeekFromBeginning"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::writeFrameCount()\n  {\n  \tuint32_t factSize = 4;\n  \tuint32_t totalFrameCount;\n  \n  \tTrack *track = getTrack();\n  \n  \t/* Omit the fact chunk only for uncompressed integer audio formats. */\n  \tif (track->f.compressionType == AF_COMPRESSION_NONE &&\n  \t\t(track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP ||\n  \t\ttrack->f.sampleFormat == AF_SAMPFMT_UNSIGNED))\n  \t\treturn AF_SUCCEED;\n  \n  \t/*\n  \t\tIf the offset for the fact chunk hasn't been set yet,\n  \t\tset it to the file's current position.\n  \t*/\n  \tif (m_factOffset == 0)\n  \t\tm_factOffset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_factOffset, File::SeekFromBeginning);\n  \n  \tm_fh->write(\"fact\", 4);\n  \twriteU32(&factSize);\n  \n  \ttotalFrameCount = track->totalfframes;\n  \twriteU32(&totalFrameCount);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeFormat",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "1077-1201",
    "snippet": "status WAVEFile::writeFormat()\n{\n\tuint16_t\tformatTag, channelCount;\n\tuint32_t\tsampleRate, averageBytesPerSecond;\n\tuint16_t\tblockAlign;\n\tuint32_t\tchunkSize;\n\tuint16_t\tbitsPerSample;\n\n\tTrack *track = getTrack();\n\n\tm_fh->write(\"fmt \", 4);\n\n\tswitch (track->f.compressionType)\n\t{\n\t\tcase AF_COMPRESSION_NONE:\n\t\t\tchunkSize = 16;\n\t\t\tif (track->f.sampleFormat == AF_SAMPFMT_FLOAT ||\n\t\t\t\ttrack->f.sampleFormat == AF_SAMPFMT_DOUBLE)\n\t\t\t{\n\t\t\t\tformatTag = WAVE_FORMAT_IEEE_FLOAT;\n\t\t\t}\n\t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP ||\n\t\t\t\ttrack->f.sampleFormat == AF_SAMPFMT_UNSIGNED)\n\t\t\t{\n\t\t\t\tformatTag = WAVE_FORMAT_PCM;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_COMPTYPE, \"bad sample format\");\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tblockAlign = _af_format_frame_size(&track->f, false);\n\t\t\tbitsPerSample = 8 * _af_format_sample_size(&track->f, false);\n\t\t\tbreak;\n\n\t\t/*\n\t\t\tG.711 compression uses eight bits per sample.\n\t\t*/\n\t\tcase AF_COMPRESSION_G711_ULAW:\n\t\t\tchunkSize = 18;\n\t\t\tformatTag = IBM_FORMAT_MULAW;\n\t\t\tblockAlign = track->f.channelCount;\n\t\t\tbitsPerSample = 8;\n\t\t\tbreak;\n\n\t\tcase AF_COMPRESSION_G711_ALAW:\n\t\t\tchunkSize = 18;\n\t\t\tformatTag = IBM_FORMAT_ALAW;\n\t\t\tblockAlign = track->f.channelCount;\n\t\t\tbitsPerSample = 8;\n\t\t\tbreak;\n\n\t\tcase AF_COMPRESSION_IMA:\n\t\t\tchunkSize = 20;\n\t\t\tformatTag = WAVE_FORMAT_DVI_ADPCM;\n\t\t\tblockAlign = track->f.bytesPerPacket;\n\t\t\tbitsPerSample = 4;\n\t\t\tbreak;\n\n\t\tcase AF_COMPRESSION_MS_ADPCM:\n\t\t\tchunkSize = 50;\n\t\t\tformatTag = WAVE_FORMAT_ADPCM;\n\t\t\tblockAlign = track->f.bytesPerPacket;\n\t\t\tbitsPerSample = 4;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_COMPTYPE, \"bad compression type\");\n\t\t\treturn AF_FAIL;\n\t}\n\n\twriteU32(&chunkSize);\n\twriteU16(&formatTag);\n\n\tchannelCount = track->f.channelCount;\n\twriteU16(&channelCount);\n\n\tsampleRate = track->f.sampleRate;\n\twriteU32(&sampleRate);\n\n\taverageBytesPerSecond =\n\t\ttrack->f.sampleRate * _af_format_frame_size(&track->f, false);\n\tif (track->f.compressionType == AF_COMPRESSION_IMA ||\n\t\ttrack->f.compressionType == AF_COMPRESSION_MS_ADPCM)\n\t\taverageBytesPerSecond = track->f.sampleRate * track->f.bytesPerPacket /\n\t\t\ttrack->f.framesPerPacket;\n\twriteU32(&averageBytesPerSecond);\n\n\twriteU16(&blockAlign);\n\n\twriteU16(&bitsPerSample);\n\n\tif (track->f.compressionType == AF_COMPRESSION_G711_ULAW ||\n\t\ttrack->f.compressionType == AF_COMPRESSION_G711_ALAW)\n\t{\n\t\tuint16_t zero = 0;\n\t\twriteU16(&zero);\n\t}\n\telse if (track->f.compressionType == AF_COMPRESSION_IMA)\n\t{\n\t\tuint16_t extraByteCount = 2;\n\t\twriteU16(&extraByteCount);\n\t\tuint16_t samplesPerBlock = track->f.framesPerPacket;\n\t\twriteU16(&samplesPerBlock);\n\t}\n\telse if (track->f.compressionType == AF_COMPRESSION_MS_ADPCM)\n\t{\n\t\tuint16_t extraByteCount = 2 + 2 + m_msadpcmNumCoefficients * 4;\n\t\twriteU16(&extraByteCount);\n\t\tuint16_t samplesPerBlock = track->f.framesPerPacket;\n\t\twriteU16(&samplesPerBlock);\n\n\t\tuint16_t numCoefficients = m_msadpcmNumCoefficients;\n\t\twriteU16(&numCoefficients);\n\n\t\tfor (int i=0; i<m_msadpcmNumCoefficients; i++)\n\t\t{\n\t\t\twriteS16(&m_msadpcmCoefficients[i][0]);\n\t\t\twriteS16(&m_msadpcmCoefficients[i][1]);\n\t\t}\n\t}\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeS16",
          "args": [
            "&m_msadpcmCoefficients[i][1]"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "writeS16",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "438-441",
          "snippet": "bool _AFfilehandle::writeS16(const int16_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeS16(const int16_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU16",
          "args": [
            "&numCoefficients"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "writeU16",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "433-436",
          "snippet": "bool _AFfilehandle::writeU16(const uint16_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU16(const uint16_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&averageBytesPerSecond"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_format_frame_size",
          "args": [
            "&track->f",
            "false"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "_af_format_frame_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "301-308",
          "snippet": "float _af_format_frame_size (const AudioFormat *fmt, bool stretch3to4)\n{\n\tconst CompressionUnit *unit = _af_compression_unit_from_id(fmt->compressionType);\n\tfloat squishFactor = unit->squishFactor;\n\n\treturn _af_format_frame_size_uncompressed(fmt, stretch3to4) /\n\t\tsquishFactor;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nfloat _af_format_frame_size (const AudioFormat *fmt, bool stretch3to4)\n{\n\tconst CompressionUnit *unit = _af_compression_unit_from_id(fmt->compressionType);\n\tfloat squishFactor = unit->squishFactor;\n\n\treturn _af_format_frame_size_uncompressed(fmt, stretch3to4) /\n\t\tsquishFactor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_COMPTYPE",
            "\"bad compression type\""
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_format_sample_size",
          "args": [
            "&track->f",
            "false"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "_af_format_sample_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "286-293",
          "snippet": "float _af_format_sample_size (const AudioFormat *fmt, bool stretch3to4)\n{\n\tconst CompressionUnit *unit = _af_compression_unit_from_id(fmt->compressionType);\n\tfloat squishFactor = unit->squishFactor;\n\n\treturn _af_format_sample_size_uncompressed(fmt, stretch3to4) /\n\t\tsquishFactor;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nfloat _af_format_sample_size (const AudioFormat *fmt, bool stretch3to4)\n{\n\tconst CompressionUnit *unit = _af_compression_unit_from_id(fmt->compressionType);\n\tfloat squishFactor = unit->squishFactor;\n\n\treturn _af_format_sample_size_uncompressed(fmt, stretch3to4) /\n\t\tsquishFactor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_COMPTYPE",
            "\"bad sample format\""
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "\"fmt \"",
            "4"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::writeFormat()\n  {\n  \tuint16_t\tformatTag, channelCount;\n  \tuint32_t\tsampleRate, averageBytesPerSecond;\n  \tuint16_t\tblockAlign;\n  \tuint32_t\tchunkSize;\n  \tuint16_t\tbitsPerSample;\n  \n  \tTrack *track = getTrack();\n  \n  \tm_fh->write(\"fmt \", 4);\n  \n  \tswitch (track->f.compressionType)\n  \t{\n  \t\tcase AF_COMPRESSION_NONE:\n  \t\t\tchunkSize = 16;\n  \t\t\tif (track->f.sampleFormat == AF_SAMPFMT_FLOAT ||\n  \t\t\t\ttrack->f.sampleFormat == AF_SAMPFMT_DOUBLE)\n  \t\t\t{\n  \t\t\t\tformatTag = WAVE_FORMAT_IEEE_FLOAT;\n  \t\t\t}\n  \t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP ||\n  \t\t\t\ttrack->f.sampleFormat == AF_SAMPFMT_UNSIGNED)\n  \t\t\t{\n  \t\t\t\tformatTag = WAVE_FORMAT_PCM;\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_COMPTYPE, \"bad sample format\");\n  \t\t\t\treturn AF_FAIL;\n  \t\t\t}\n  \n  \t\t\tblockAlign = _af_format_frame_size(&track->f, false);\n  \t\t\tbitsPerSample = 8 * _af_format_sample_size(&track->f, false);\n  \t\t\tbreak;\n  \n  \t\t/*\n  \t\t\tG.711 compression uses eight bits per sample.\n  \t\t*/\n  \t\tcase AF_COMPRESSION_G711_ULAW:\n  \t\t\tchunkSize = 18;\n  \t\t\tformatTag = IBM_FORMAT_MULAW;\n  \t\t\tblockAlign = track->f.channelCount;\n  \t\t\tbitsPerSample = 8;\n  \t\t\tbreak;\n  \n  \t\tcase AF_COMPRESSION_G711_ALAW:\n  \t\t\tchunkSize = 18;\n  \t\t\tformatTag = IBM_FORMAT_ALAW;\n  \t\t\tblockAlign = track->f.channelCount;\n  \t\t\tbitsPerSample = 8;\n  \t\t\tbreak;\n  \n  \t\tcase AF_COMPRESSION_IMA:\n  \t\t\tchunkSize = 20;\n  \t\t\tformatTag = WAVE_FORMAT_DVI_ADPCM;\n  \t\t\tblockAlign = track->f.bytesPerPacket;\n  \t\t\tbitsPerSample = 4;\n  \t\t\tbreak;\n  \n  \t\tcase AF_COMPRESSION_MS_ADPCM:\n  \t\t\tchunkSize = 50;\n  \t\t\tformatTag = WAVE_FORMAT_ADPCM;\n  \t\t\tblockAlign = track->f.bytesPerPacket;\n  \t\t\tbitsPerSample = 4;\n  \t\t\tbreak;\n  \n  \t\tdefault:\n  \t\t\t_af_error(AF_BAD_COMPTYPE, \"bad compression type\");\n  \t\t\treturn AF_FAIL;\n  \t}\n  \n  \twriteU32(&chunkSize);\n  \twriteU16(&formatTag);\n  \n  \tchannelCount = track->f.channelCount;\n  \twriteU16(&channelCount);\n  \n  \tsampleRate = track->f.sampleRate;\n  \twriteU32(&sampleRate);\n  \n  \taverageBytesPerSecond =\n  \t\ttrack->f.sampleRate * _af_format_frame_size(&track->f, false);\n  \tif (track->f.compressionType == AF_COMPRESSION_IMA ||\n  \t\ttrack->f.compressionType == AF_COMPRESSION_MS_ADPCM)\n  \t\taverageBytesPerSecond = track->f.sampleRate * track->f.bytesPerPacket /\n  \t\t\ttrack->f.framesPerPacket;\n  \twriteU32(&averageBytesPerSecond);\n  \n  \twriteU16(&blockAlign);\n  \n  \twriteU16(&bitsPerSample);\n  \n  \tif (track->f.compressionType == AF_COMPRESSION_G711_ULAW ||\n  \t\ttrack->f.compressionType == AF_COMPRESSION_G711_ALAW)\n  \t{\n  \t\tuint16_t zero = 0;\n  \t\twriteU16(&zero);\n  \t}\n  \telse if (track->f.compressionType == AF_COMPRESSION_IMA)\n  \t{\n  \t\tuint16_t extraByteCount = 2;\n  \t\twriteU16(&extraByteCount);\n  \t\tuint16_t samplesPerBlock = track->f.framesPerPacket;\n  \t\twriteU16(&samplesPerBlock);\n  \t}\n  \telse if (track->f.compressionType == AF_COMPRESSION_MS_ADPCM)\n  \t{\n  \t\tuint16_t extraByteCount = 2 + 2 + m_msadpcmNumCoefficients * 4;\n  \t\twriteU16(&extraByteCount);\n  \t\tuint16_t samplesPerBlock = track->f.framesPerPacket;\n  \t\twriteU16(&samplesPerBlock);\n  \n  \t\tuint16_t numCoefficients = m_msadpcmNumCoefficients;\n  \t\twriteU16(&numCoefficients);\n  \n  \t\tfor (int i=0; i<m_msadpcmNumCoefficients; i++)\n  \t\t{\n  \t\t\twriteS16(&m_msadpcmCoefficients[i][0]);\n  \t\t\twriteS16(&m_msadpcmCoefficients[i][1]);\n  \t\t}\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "isInstrumentParameterValid",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "1035-1075",
    "snippet": "bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)\n{\n\tint param, type;\n\n\tAUpvgetparam(list, i, &param);\n\tAUpvgetvaltype(list, i, &type);\n\tif (type != AU_PVTYPE_LONG)\n\t\treturn false;\n\n\tlong lval;\n\tAUpvgetval(list, i, &lval);\n\n\tswitch (param)\n\t{\n\t\tcase AF_INST_MIDI_BASENOTE:\n\t\t\treturn ((lval >= 0) && (lval <= 127));\n\n\t\tcase AF_INST_NUMCENTS_DETUNE:\n\t\t\treturn ((lval >= -50) && (lval <= 50));\n\n\t\tcase AF_INST_MIDI_LOVELOCITY:\n\t\t\treturn ((lval >= 1) && (lval <= 127));\n\n\t\tcase AF_INST_MIDI_HIVELOCITY:\n\t\t\treturn ((lval >= 1) && (lval <= 127));\n\n\t\tcase AF_INST_MIDI_LONOTE:\n\t\t\treturn ((lval >= 0) && (lval <= 127));\n\n\t\tcase AF_INST_MIDI_HINOTE:\n\t\t\treturn ((lval >= 0) && (lval <= 127));\n\n\t\tcase AF_INST_NUMDBS_GAIN:\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AUpvgetval",
          "args": [
            "list",
            "i",
            "&lval"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvgetvaltype",
          "args": [
            "list",
            "i",
            "&type"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvgetparam",
          "args": [
            "list",
            "i",
            "&param"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)\n  {\n  \tint param, type;\n  \n  \tAUpvgetparam(list, i, &param);\n  \tAUpvgetvaltype(list, i, &type);\n  \tif (type != AU_PVTYPE_LONG)\n  \t\treturn false;\n  \n  \tlong lval;\n  \tAUpvgetval(list, i, &lval);\n  \n  \tswitch (param)\n  \t{\n  \t\tcase AF_INST_MIDI_BASENOTE:\n  \t\t\treturn ((lval >= 0) && (lval <= 127));\n  \n  \t\tcase AF_INST_NUMCENTS_DETUNE:\n  \t\t\treturn ((lval >= -50) && (lval <= 50));\n  \n  \t\tcase AF_INST_MIDI_LOVELOCITY:\n  \t\t\treturn ((lval >= 1) && (lval <= 127));\n  \n  \t\tcase AF_INST_MIDI_HIVELOCITY:\n  \t\t\treturn ((lval >= 1) && (lval <= 127));\n  \n  \t\tcase AF_INST_MIDI_LONOTE:\n  \t\t\treturn ((lval >= 0) && (lval <= 127));\n  \n  \t\tcase AF_INST_MIDI_HINOTE:\n  \t\t\treturn ((lval >= 0) && (lval <= 127));\n  \n  \t\tcase AF_INST_NUMDBS_GAIN:\n  \t\t\treturn true;\n  \n  \t\tdefault:\n  \t\t\treturn false;\n  \t}\n  \n  \treturn true;\n  }\n}"
  },
  {
    "function_name": "completeSetup",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "834-1033",
    "snippet": "AFfilesetup WAVEFile::completeSetup(AFfilesetup setup)\n{\n\tif (setup->trackSet && setup->trackCount != 1)\n\t{\n\t\t_af_error(AF_BAD_NUMTRACKS, \"WAVE file must have 1 track\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tTrackSetup *track = setup->getTrack();\n\tif (!track)\n\t\treturn AF_NULL_FILESETUP;\n\n\tif (track->f.isCompressed())\n\t{\n\t\tif (!track->sampleFormatSet)\n\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, 16);\n\t\telse\n\t\t\t_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);\n\t}\n\telse if (track->sampleFormatSet)\n\t{\n\t\tswitch (track->f.sampleFormat)\n\t\t{\n\t\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\t\tif (track->sampleWidthSet &&\n\t\t\t\t\ttrack->f.sampleWidth != 32)\n\t\t\t\t{\n\t\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\t\"Warning: invalid sample width for floating-point WAVE file: %d (must be 32 bits)\\n\",\n\t\t\t\t\t\ttrack->f.sampleWidth);\n\t\t\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_FLOAT, 32);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\t\tif (track->sampleWidthSet &&\n\t\t\t\t\ttrack->f.sampleWidth != 64)\n\t\t\t\t{\n\t\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\t\"Warning: invalid sample width for double-precision floating-point WAVE file: %d (must be 64 bits)\\n\",\n\t\t\t\t\t\ttrack->f.sampleWidth);\n\t\t\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_DOUBLE, 64);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\t\t\tif (track->sampleWidthSet)\n\t\t\t\t{\n\t\t\t\t\tif (track->f.sampleWidth < 1 || track->f.sampleWidth > 32)\n\t\t\t\t\t{\n\t\t\t\t\t\t_af_error(AF_BAD_WIDTH, \"invalid sample width for WAVE file: %d (must be 1-32 bits)\\n\", track->f.sampleWidth);\n\t\t\t\t\t\treturn AF_NULL_FILESETUP;\n\t\t\t\t\t}\n\t\t\t\t\tif (track->f.sampleWidth > 8)\n\t\t\t\t\t{\n\t\t\t\t\t\t_af_error(AF_BAD_SAMPFMT, \"WAVE integer data of more than 8 bits must be two's complement signed\");\n\t\t\t\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, track->f.sampleWidth);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t/*\n\t\t\t\t\tIf the sample width is not set but the user requests\n\t\t\t\t\tunsigned data, set the width to 8 bits.\n\t\t\t\t*/\n\t\t\t\t\t_af_set_sample_format(&track->f, track->f.sampleFormat, 8);\n\t\t\t\tbreak;\n\n\t\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\t\t\tif (track->sampleWidthSet)\n\t\t\t\t{\n\t\t\t\t\tif (track->f.sampleWidth < 1 || track->f.sampleWidth > 32)\n\t\t\t\t\t{\n\t\t\t\t\t\t_af_error(AF_BAD_WIDTH, \"invalid sample width %d for WAVE file (must be 1-32)\", track->f.sampleWidth);\n\t\t\t\t\t\treturn AF_NULL_FILESETUP;\n\t\t\t\t\t}\n\t\t\t\t\telse if (track->f.sampleWidth <= 8)\n\t\t\t\t\t{\n\t\t\t\t\t\t_af_error(AF_BAD_SAMPFMT, \"Warning: WAVE format integer data of 1-8 bits must be unsigned; setting sample format to unsigned\");\n\t\t\t\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_UNSIGNED, track->f.sampleWidth);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t/*\n\t\t\t\t\tIf no sample width was specified, we default to 16 bits\n\t\t\t\t\tfor signed integer data.\n\t\t\t\t*/\n\t\t\t\t\t_af_set_sample_format(&track->f, track->f.sampleFormat, 16);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t\tOtherwise set the sample format depending on the sample\n\t\twidth or set completely to default.\n\t*/\n\telse\n\t{\n\t\tif (!track->sampleWidthSet)\n\t\t{\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (track->f.sampleWidth < 1 || track->f.sampleWidth > 32)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_WIDTH, \"invalid sample width %d for WAVE file (must be 1-32)\", track->f.sampleWidth);\n\t\t\t\treturn AF_NULL_FILESETUP;\n\t\t\t}\n\t\t\telse if (track->f.sampleWidth > 8)\n\t\t\t\t/* Here track->f.sampleWidth is in {1..32}. */\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\telse\n\t\t\t\t/* Here track->f.sampleWidth is in {1..8}. */\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t}\n\t}\n\n\tif (track->f.compressionType != AF_COMPRESSION_NONE &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_G711_ULAW &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_G711_ALAW &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_IMA &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_MS_ADPCM)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"compression format not supported in WAVE format\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->f.isUncompressed() &&\n\t\ttrack->byteOrderSet &&\n\t\ttrack->f.byteOrder != AF_BYTEORDER_LITTLEENDIAN &&\n\t\ttrack->f.isByteOrderSignificant())\n\t{\n\t\t_af_error(AF_BAD_BYTEORDER, \"WAVE format only supports little-endian data\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->f.isUncompressed())\n\t\ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n\n\tif (track->aesDataSet)\n\t{\n\t\t_af_error(AF_BAD_FILESETUP, \"WAVE files cannot have AES data\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (setup->instrumentSet)\n\t{\n\t\tif (setup->instrumentCount > 1)\n\t\t{\n\t\t\t_af_error(AF_BAD_NUMINSTS, \"WAVE files can have 0 or 1 instrument\");\n\t\t\treturn AF_NULL_FILESETUP;\n\t\t}\n\t\telse if (setup->instrumentCount == 1)\n\t\t{\n\t\t\tif (setup->instruments[0].loopSet &&\n\t\t\t\tsetup->instruments[0].loopCount > 0 &&\n\t\t\t\t(!track->markersSet || track->markerCount == 0))\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_NUMMARKS, \"WAVE files with loops must contain at least 1 marker\");\n\t\t\t\treturn AF_NULL_FILESETUP;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Make sure the miscellaneous data is of an acceptable type. */\n\tif (setup->miscellaneousSet)\n\t{\n\t\tfor (int i=0; i<setup->miscellaneousCount; i++)\n\t\t{\n\t\t\tswitch (setup->miscellaneous[i].type)\n\t\t\t{\n\t\t\t\tcase AF_MISC_COPY:\n\t\t\t\tcase AF_MISC_AUTH:\n\t\t\t\tcase AF_MISC_NAME:\n\t\t\t\tcase AF_MISC_ICRD:\n\t\t\t\tcase AF_MISC_ISFT:\n\t\t\t\tcase AF_MISC_ICMT:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t_af_error(AF_BAD_MISCTYPE, \"illegal miscellaneous type [%d] for WAVE file\", setup->miscellaneous[i].type);\n\t\t\t\t\treturn AF_NULL_FILESETUP;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t\tAllocate an AFfilesetup and make all the unset fields correct.\n\t*/\n\tAFfilesetup\tnewsetup = _af_filesetup_copy(setup, &waveDefaultFileSetup, false);\n\n\t/* Make sure we do not copy loops if they are not specified in setup. */\n\tif (setup->instrumentSet && setup->instrumentCount > 0 &&\n\t\tsetup->instruments[0].loopSet)\n\t{\n\t\tfree(newsetup->instruments[0].loops);\n\t\tnewsetup->instruments[0].loopCount = 0;\n\t}\n\n\treturn newsetup;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const _AFfilesetup waveDefaultFileSetup =\n{\n\t_AF_VALID_FILESETUP,\t/* valid */\n\tAF_FILE_WAVE,\t\t/* fileFormat */\n\ttrue,\t\t\t/* trackSet */\n\ttrue,\t\t\t/* instrumentSet */\n\ttrue,\t\t\t/* miscellaneousSet  */\n\t1,\t\t\t/* trackCount */\n\tNULL,\t\t\t/* tracks */\n\t0,\t\t\t/* instrumentCount */\n\tNULL,\t\t\t/* instruments */\n\t0,\t\t\t/* miscellaneousCount */\n\tNULL\t\t\t/* miscellaneous */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newsetup->instruments[0].loops"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "_af_setup_free_instruments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Setup.cpp",
          "lines": "251-263",
          "snippet": "void _af_setup_free_instruments (AFfilesetup setup)\n{\n\tif (setup->instruments)\n\t{\n\t\tfor (int i=0; i < setup->instrumentCount; i++)\n\t\t\tsetup->instruments[i].freeLoops();\n\n\t\tfree(setup->instruments);\n\t}\n\n\tsetup->instruments = NULL;\n\tsetup->instrumentCount = 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"audiofile.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"Setup.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"audiofile.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include <string.h>\n#include <stdlib.h>\n#include \"Setup.h\"\n#include \"config.h\"\n\nvoid _af_setup_free_instruments (AFfilesetup setup)\n{\n\tif (setup->instruments)\n\t{\n\t\tfor (int i=0; i < setup->instrumentCount; i++)\n\t\t\tsetup->instruments[i].freeLoops();\n\n\t\tfree(setup->instruments);\n\t}\n\n\tsetup->instruments = NULL;\n\tsetup->instrumentCount = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_filesetup_copy",
          "args": [
            "setup",
            "&waveDefaultFileSetup",
            "false"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "_af_filesetup_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Setup.cpp",
          "lines": "440-525",
          "snippet": "AFfilesetup _af_filesetup_copy (const _AFfilesetup *setup,\n\tconst _AFfilesetup *defaultSetup, bool copyMarks)\n{\n\tAFfilesetup newsetup;\n\tint instrumentCount, miscellaneousCount, trackCount;\n\n\tnewsetup = (_AFfilesetup *) _af_malloc(sizeof (_AFfilesetup));\n\tif (newsetup == AF_NULL_FILESETUP)\n\t\treturn AF_NULL_FILESETUP;\n\n\t*newsetup = *defaultSetup;\n\n\tnewsetup->tracks = NULL;\n\tnewsetup->instruments = NULL;\n\tnewsetup->miscellaneous = NULL;\n\n\t/* Copy tracks. */\n\ttrackCount = setup->trackSet ? setup->trackCount :\n\t\tnewsetup->trackSet ? newsetup->trackCount : 0;\n\talloccopy(TrackSetup, trackCount, newsetup->tracks, setup->tracks);\n\tnewsetup->trackCount = trackCount;\n\n\t/* Copy instruments. */\n\tinstrumentCount = setup->instrumentSet ? setup->instrumentCount :\n\t\tnewsetup->instrumentSet ? newsetup->instrumentCount : 0;\n\talloccopy(InstrumentSetup, instrumentCount, newsetup->instruments, setup->instruments);\n\tnewsetup->instrumentCount = instrumentCount;\n\n\t/* Copy miscellaneous information. */\n\tmiscellaneousCount = setup->miscellaneousSet ? setup->miscellaneousCount :\n\t\tnewsetup->miscellaneousSet ? newsetup->miscellaneousCount : 0;\n\talloccopy(MiscellaneousSetup, miscellaneousCount, newsetup->miscellaneous, setup->miscellaneous);\n\tnewsetup->miscellaneousCount = miscellaneousCount;\n\n\tfor (int i=0; i<setup->trackCount; i++)\n\t{\n\t\tTrackSetup\t*track = &newsetup->tracks[i];\n\n\t\t/* XXXmpruett set compression information */\n\n\t\tif (!setup->tracks[i].markersSet && !copyMarks)\n\t\t{\n\t\t\ttrack->markers = NULL;\n\t\t\ttrack->markerCount = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\talloccopy(MarkerSetup, setup->tracks[i].markerCount,\n\t\t\ttrack->markers, setup->tracks[i].markers);\n\t\ttrack->markerCount = setup->tracks[i].markerCount;\n\n\t\tfor (int j=0; j<setup->tracks[i].markerCount; j++)\n\t\t{\n\t\t\ttrack->markers[j].name =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].name);\n\t\t\tif (track->markers[j].name == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\ttrack->markers[j].comment =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].comment);\n\t\t\tif (track->markers[j].comment == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (int i=0; i<newsetup->instrumentCount; i++)\n\t{\n\t\tInstrumentSetup\t*instrument = &newsetup->instruments[i];\n\t\talloccopy(LoopSetup, setup->instruments[i].loopCount,\n\t\t\tinstrument->loops, setup->instruments[i].loops);\n\t}\n\n\treturn newsetup;\n\n\tfail:\n\t\tif (newsetup->miscellaneous)\n\t\t\tfree(newsetup->miscellaneous);\n\t\tif (newsetup->instruments)\n\t\t\tfree(newsetup->instruments);\n\t\tif (newsetup->tracks)\n\t\t\tfree(newsetup->tracks);\n\t\tif (newsetup)\n\t\t\tfree(newsetup);\n\n\treturn AF_NULL_FILESETUP;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"audiofile.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"Setup.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"audiofile.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include <string.h>\n#include <stdlib.h>\n#include \"Setup.h\"\n#include \"config.h\"\n\nAFfilesetup _af_filesetup_copy (const _AFfilesetup *setup,\n\tconst _AFfilesetup *defaultSetup, bool copyMarks)\n{\n\tAFfilesetup newsetup;\n\tint instrumentCount, miscellaneousCount, trackCount;\n\n\tnewsetup = (_AFfilesetup *) _af_malloc(sizeof (_AFfilesetup));\n\tif (newsetup == AF_NULL_FILESETUP)\n\t\treturn AF_NULL_FILESETUP;\n\n\t*newsetup = *defaultSetup;\n\n\tnewsetup->tracks = NULL;\n\tnewsetup->instruments = NULL;\n\tnewsetup->miscellaneous = NULL;\n\n\t/* Copy tracks. */\n\ttrackCount = setup->trackSet ? setup->trackCount :\n\t\tnewsetup->trackSet ? newsetup->trackCount : 0;\n\talloccopy(TrackSetup, trackCount, newsetup->tracks, setup->tracks);\n\tnewsetup->trackCount = trackCount;\n\n\t/* Copy instruments. */\n\tinstrumentCount = setup->instrumentSet ? setup->instrumentCount :\n\t\tnewsetup->instrumentSet ? newsetup->instrumentCount : 0;\n\talloccopy(InstrumentSetup, instrumentCount, newsetup->instruments, setup->instruments);\n\tnewsetup->instrumentCount = instrumentCount;\n\n\t/* Copy miscellaneous information. */\n\tmiscellaneousCount = setup->miscellaneousSet ? setup->miscellaneousCount :\n\t\tnewsetup->miscellaneousSet ? newsetup->miscellaneousCount : 0;\n\talloccopy(MiscellaneousSetup, miscellaneousCount, newsetup->miscellaneous, setup->miscellaneous);\n\tnewsetup->miscellaneousCount = miscellaneousCount;\n\n\tfor (int i=0; i<setup->trackCount; i++)\n\t{\n\t\tTrackSetup\t*track = &newsetup->tracks[i];\n\n\t\t/* XXXmpruett set compression information */\n\n\t\tif (!setup->tracks[i].markersSet && !copyMarks)\n\t\t{\n\t\t\ttrack->markers = NULL;\n\t\t\ttrack->markerCount = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\talloccopy(MarkerSetup, setup->tracks[i].markerCount,\n\t\t\ttrack->markers, setup->tracks[i].markers);\n\t\ttrack->markerCount = setup->tracks[i].markerCount;\n\n\t\tfor (int j=0; j<setup->tracks[i].markerCount; j++)\n\t\t{\n\t\t\ttrack->markers[j].name =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].name);\n\t\t\tif (track->markers[j].name == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\ttrack->markers[j].comment =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].comment);\n\t\t\tif (track->markers[j].comment == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (int i=0; i<newsetup->instrumentCount; i++)\n\t{\n\t\tInstrumentSetup\t*instrument = &newsetup->instruments[i];\n\t\talloccopy(LoopSetup, setup->instruments[i].loopCount,\n\t\t\tinstrument->loops, setup->instruments[i].loops);\n\t}\n\n\treturn newsetup;\n\n\tfail:\n\t\tif (newsetup->miscellaneous)\n\t\t\tfree(newsetup->miscellaneous);\n\t\tif (newsetup->instruments)\n\t\t\tfree(newsetup->instruments);\n\t\tif (newsetup->tracks)\n\t\t\tfree(newsetup->tracks);\n\t\tif (newsetup)\n\t\t\tfree(newsetup);\n\n\treturn AF_NULL_FILESETUP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_MISCTYPE",
            "\"illegal miscellaneous type [%d] for WAVE file\"",
            "setup->miscellaneous[i].type"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NUMMARKS",
            "\"WAVE files with loops must contain at least 1 marker\""
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NUMINSTS",
            "\"WAVE files can have 0 or 1 instrument\""
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_FILESETUP",
            "\"WAVE files cannot have AES data\""
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track->f.isUncompressed",
          "args": [],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "isUncompressed",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "93-96",
          "snippet": "bool AudioFormat::isUncompressed() const\n{\n\treturn compressionType == AF_COMPRESSION_NONE;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  bool AudioFormat::isUncompressed() const\n  {\n  \treturn compressionType == AF_COMPRESSION_NONE;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_BYTEORDER",
            "\"WAVE format only supports little-endian data\""
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track->f.isByteOrderSignificant",
          "args": [],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "isByteOrderSignificant",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.h",
          "lines": "64-64",
          "snippet": "bool isByteOrderSignificant() const { return sampleWidth > 8; }",
          "includes": [
            "#include <string>",
            "#include <sys/types.h>",
            "#include \"aupvlist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <sys/types.h>\n#include \"aupvlist.h\"\n\nAudioFormat {\n  bool isByteOrderSignificant() const { return sampleWidth > 8; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"compression format not supported in WAVE format\""
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_WIDTH",
            "\"invalid sample width %d for WAVE file (must be 1-32)\"",
            "track->f.sampleWidth"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_set_sample_format",
          "args": [
            "&track->f",
            "track->f.sampleFormat",
            "16"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "_af_set_sample_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "315-361",
          "snippet": "status _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatus _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_SAMPFMT",
            "\"Warning: WAVE format integer data of 1-8 bits must be unsigned; setting sample format to unsigned\""
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_WIDTH",
            "\"invalid sample width %d for WAVE file (must be 1-32)\"",
            "track->f.sampleWidth"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_SAMPFMT",
            "\"WAVE integer data of more than 8 bits must be two's complement signed\""
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_WIDTH",
            "\"invalid sample width for WAVE file: %d (must be 1-32 bits)\\n\"",
            "track->f.sampleWidth"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_WIDTH",
            "\"Warning: invalid sample width for double-precision floating-point WAVE file: %d (must be 64 bits)\\n\"",
            "track->f.sampleWidth"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_WIDTH",
            "\"Warning: invalid sample width for floating-point WAVE file: %d (must be 32 bits)\\n\"",
            "track->f.sampleWidth"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track->f.isCompressed",
          "args": [],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "isCompressed",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "88-91",
          "snippet": "bool AudioFormat::isCompressed() const\n{\n\treturn compressionType != AF_COMPRESSION_NONE;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  bool AudioFormat::isCompressed() const\n  {\n  \treturn compressionType != AF_COMPRESSION_NONE;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup->getTrack",
          "args": [],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NUMTRACKS",
            "\"WAVE file must have 1 track\""
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nstatic const _AFfilesetup waveDefaultFileSetup =\n{\n\t_AF_VALID_FILESETUP,\t/* valid */\n\tAF_FILE_WAVE,\t\t/* fileFormat */\n\ttrue,\t\t\t/* trackSet */\n\ttrue,\t\t\t/* instrumentSet */\n\ttrue,\t\t\t/* miscellaneousSet  */\n\t1,\t\t\t/* trackCount */\n\tNULL,\t\t\t/* tracks */\n\t0,\t\t\t/* instrumentCount */\n\tNULL,\t\t\t/* instruments */\n\t0,\t\t\t/* miscellaneousCount */\n\tNULL\t\t\t/* miscellaneous */\n};\n\nWAVEFile {\n  AFfilesetup WAVEFile::completeSetup(AFfilesetup setup)\n  {\n  \tif (setup->trackSet && setup->trackCount != 1)\n  \t{\n  \t\t_af_error(AF_BAD_NUMTRACKS, \"WAVE file must have 1 track\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tTrackSetup *track = setup->getTrack();\n  \tif (!track)\n  \t\treturn AF_NULL_FILESETUP;\n  \n  \tif (track->f.isCompressed())\n  \t{\n  \t\tif (!track->sampleFormatSet)\n  \t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, 16);\n  \t\telse\n  \t\t\t_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);\n  \t}\n  \telse if (track->sampleFormatSet)\n  \t{\n  \t\tswitch (track->f.sampleFormat)\n  \t\t{\n  \t\t\tcase AF_SAMPFMT_FLOAT:\n  \t\t\t\tif (track->sampleWidthSet &&\n  \t\t\t\t\ttrack->f.sampleWidth != 32)\n  \t\t\t\t{\n  \t\t\t\t\t_af_error(AF_BAD_WIDTH,\n  \t\t\t\t\t\t\"Warning: invalid sample width for floating-point WAVE file: %d (must be 32 bits)\\n\",\n  \t\t\t\t\t\ttrack->f.sampleWidth);\n  \t\t\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_FLOAT, 32);\n  \t\t\t\t}\n  \t\t\t\tbreak;\n  \n  \t\t\tcase AF_SAMPFMT_DOUBLE:\n  \t\t\t\tif (track->sampleWidthSet &&\n  \t\t\t\t\ttrack->f.sampleWidth != 64)\n  \t\t\t\t{\n  \t\t\t\t\t_af_error(AF_BAD_WIDTH,\n  \t\t\t\t\t\t\"Warning: invalid sample width for double-precision floating-point WAVE file: %d (must be 64 bits)\\n\",\n  \t\t\t\t\t\ttrack->f.sampleWidth);\n  \t\t\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_DOUBLE, 64);\n  \t\t\t\t}\n  \t\t\t\tbreak;\n  \n  \t\t\tcase AF_SAMPFMT_UNSIGNED:\n  \t\t\t\tif (track->sampleWidthSet)\n  \t\t\t\t{\n  \t\t\t\t\tif (track->f.sampleWidth < 1 || track->f.sampleWidth > 32)\n  \t\t\t\t\t{\n  \t\t\t\t\t\t_af_error(AF_BAD_WIDTH, \"invalid sample width for WAVE file: %d (must be 1-32 bits)\\n\", track->f.sampleWidth);\n  \t\t\t\t\t\treturn AF_NULL_FILESETUP;\n  \t\t\t\t\t}\n  \t\t\t\t\tif (track->f.sampleWidth > 8)\n  \t\t\t\t\t{\n  \t\t\t\t\t\t_af_error(AF_BAD_SAMPFMT, \"WAVE integer data of more than 8 bits must be two's complement signed\");\n  \t\t\t\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, track->f.sampleWidth);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t/*\n  \t\t\t\t\tIf the sample width is not set but the user requests\n  \t\t\t\t\tunsigned data, set the width to 8 bits.\n  \t\t\t\t*/\n  \t\t\t\t\t_af_set_sample_format(&track->f, track->f.sampleFormat, 8);\n  \t\t\t\tbreak;\n  \n  \t\t\tcase AF_SAMPFMT_TWOSCOMP:\n  \t\t\t\tif (track->sampleWidthSet)\n  \t\t\t\t{\n  \t\t\t\t\tif (track->f.sampleWidth < 1 || track->f.sampleWidth > 32)\n  \t\t\t\t\t{\n  \t\t\t\t\t\t_af_error(AF_BAD_WIDTH, \"invalid sample width %d for WAVE file (must be 1-32)\", track->f.sampleWidth);\n  \t\t\t\t\t\treturn AF_NULL_FILESETUP;\n  \t\t\t\t\t}\n  \t\t\t\t\telse if (track->f.sampleWidth <= 8)\n  \t\t\t\t\t{\n  \t\t\t\t\t\t_af_error(AF_BAD_SAMPFMT, \"Warning: WAVE format integer data of 1-8 bits must be unsigned; setting sample format to unsigned\");\n  \t\t\t\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_UNSIGNED, track->f.sampleWidth);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t/*\n  \t\t\t\t\tIf no sample width was specified, we default to 16 bits\n  \t\t\t\t\tfor signed integer data.\n  \t\t\t\t*/\n  \t\t\t\t\t_af_set_sample_format(&track->f, track->f.sampleFormat, 16);\n  \t\t\t\tbreak;\n  \t\t}\n  \t}\n  \t/*\n  \t\tOtherwise set the sample format depending on the sample\n  \t\twidth or set completely to default.\n  \t*/\n  \telse\n  \t{\n  \t\tif (!track->sampleWidthSet)\n  \t\t{\n  \t\t\ttrack->f.sampleWidth = 16;\n  \t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tif (track->f.sampleWidth < 1 || track->f.sampleWidth > 32)\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_WIDTH, \"invalid sample width %d for WAVE file (must be 1-32)\", track->f.sampleWidth);\n  \t\t\t\treturn AF_NULL_FILESETUP;\n  \t\t\t}\n  \t\t\telse if (track->f.sampleWidth > 8)\n  \t\t\t\t/* Here track->f.sampleWidth is in {1..32}. */\n  \t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t\telse\n  \t\t\t\t/* Here track->f.sampleWidth is in {1..8}. */\n  \t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n  \t\t}\n  \t}\n  \n  \tif (track->f.compressionType != AF_COMPRESSION_NONE &&\n  \t\ttrack->f.compressionType != AF_COMPRESSION_G711_ULAW &&\n  \t\ttrack->f.compressionType != AF_COMPRESSION_G711_ALAW &&\n  \t\ttrack->f.compressionType != AF_COMPRESSION_IMA &&\n  \t\ttrack->f.compressionType != AF_COMPRESSION_MS_ADPCM)\n  \t{\n  \t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"compression format not supported in WAVE format\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (track->f.isUncompressed() &&\n  \t\ttrack->byteOrderSet &&\n  \t\ttrack->f.byteOrder != AF_BYTEORDER_LITTLEENDIAN &&\n  \t\ttrack->f.isByteOrderSignificant())\n  \t{\n  \t\t_af_error(AF_BAD_BYTEORDER, \"WAVE format only supports little-endian data\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (track->f.isUncompressed())\n  \t\ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n  \n  \tif (track->aesDataSet)\n  \t{\n  \t\t_af_error(AF_BAD_FILESETUP, \"WAVE files cannot have AES data\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (setup->instrumentSet)\n  \t{\n  \t\tif (setup->instrumentCount > 1)\n  \t\t{\n  \t\t\t_af_error(AF_BAD_NUMINSTS, \"WAVE files can have 0 or 1 instrument\");\n  \t\t\treturn AF_NULL_FILESETUP;\n  \t\t}\n  \t\telse if (setup->instrumentCount == 1)\n  \t\t{\n  \t\t\tif (setup->instruments[0].loopSet &&\n  \t\t\t\tsetup->instruments[0].loopCount > 0 &&\n  \t\t\t\t(!track->markersSet || track->markerCount == 0))\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_NUMMARKS, \"WAVE files with loops must contain at least 1 marker\");\n  \t\t\t\treturn AF_NULL_FILESETUP;\n  \t\t\t}\n  \t\t}\n  \t}\n  \n  \t/* Make sure the miscellaneous data is of an acceptable type. */\n  \tif (setup->miscellaneousSet)\n  \t{\n  \t\tfor (int i=0; i<setup->miscellaneousCount; i++)\n  \t\t{\n  \t\t\tswitch (setup->miscellaneous[i].type)\n  \t\t\t{\n  \t\t\t\tcase AF_MISC_COPY:\n  \t\t\t\tcase AF_MISC_AUTH:\n  \t\t\t\tcase AF_MISC_NAME:\n  \t\t\t\tcase AF_MISC_ICRD:\n  \t\t\t\tcase AF_MISC_ISFT:\n  \t\t\t\tcase AF_MISC_ICMT:\n  \t\t\t\t\tbreak;\n  \t\t\t\tdefault:\n  \t\t\t\t\t_af_error(AF_BAD_MISCTYPE, \"illegal miscellaneous type [%d] for WAVE file\", setup->miscellaneous[i].type);\n  \t\t\t\t\treturn AF_NULL_FILESETUP;\n  \t\t\t}\n  \t\t}\n  \t}\n  \n  \t/*\n  \t\tAllocate an AFfilesetup and make all the unset fields correct.\n  \t*/\n  \tAFfilesetup\tnewsetup = _af_filesetup_copy(setup, &waveDefaultFileSetup, false);\n  \n  \t/* Make sure we do not copy loops if they are not specified in setup. */\n  \tif (setup->instrumentSet && setup->instrumentCount > 0 &&\n  \t\tsetup->instruments[0].loopSet)\n  \t{\n  \t\tfree(newsetup->instruments[0].loops);\n  \t\tnewsetup->instruments[0].loopCount = 0;\n  \t}\n  \n  \treturn newsetup;\n  }\n}"
  },
  {
    "function_name": "readInit",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "704-832",
    "snippet": "status WAVEFile::readInit(AFfilesetup setup)\n{\n\tTag type, formtype;\n\tuint32_t size;\n\tuint32_t index = 0;\n\n\tbool hasFormat = false;\n\tbool hasData = false;\n\tbool hasFrameCount = false;\n\n\tTrack *track = allocateTrack();\n\n\tm_fh->seek(0, File::SeekFromBeginning);\n\n\treadTag(&type);\n\treadU32(&size);\n\treadTag(&formtype);\n\n\tassert(type == \"RIFF\");\n\tassert(formtype == \"WAVE\");\n\n\t/* Include the offset of the form type. */\n\tindex += 4;\n\n\twhile (index < size)\n\t{\n\t\tTag chunkid;\n\t\tuint32_t chunksize = 0;\n\t\tstatus result;\n\n\t\treadTag(&chunkid);\n\t\treadU32(&chunksize);\n\n\t\tif (chunkid == \"fmt \")\n\t\t{\n\t\t\tresult = parseFormat(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\n\t\t\thasFormat = true;\n\t\t}\n\t\telse if (chunkid == \"data\")\n\t\t{\n\t\t\t/* The format chunk must precede the data chunk. */\n\t\t\tif (!hasFormat)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_HEADER, \"missing format chunk in WAVE file\");\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tresult = parseData(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\n\t\t\thasData = true;\n\t\t}\n\t\telse if (chunkid == \"inst\")\n\t\t{\n\t\t\tresult = parseInstrument(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (chunkid == \"fact\")\n\t\t{\n\t\t\thasFrameCount = true;\n\t\t\tresult = parseFrameCount(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (chunkid == \"cue \")\n\t\t{\n\t\t\tresult = parseCues(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (chunkid == \"LIST\" || chunkid == \"list\")\n\t\t{\n\t\t\tresult = parseList(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (chunkid == \"INST\")\n\t\t{\n\t\t\tresult = parseInstrument(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (chunkid == \"plst\")\n\t\t{\n\t\t\tresult = parsePlayList(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\n\t\tindex += chunksize + 8;\n\n\t\t/* All chunks must be aligned on an even number of bytes */\n\t\tif ((index % 2) != 0)\n\t\t\tindex++;\n\n\t\tm_fh->seek(index + 8, File::SeekFromBeginning);\n\t}\n\n\t/* The format chunk and the data chunk are required. */\n\tif (!hasFormat || !hasData)\n\t{\n\t\treturn AF_FAIL;\n\t}\n\n\t/*\n\t\tAt this point we know that the file has a format chunk and a\n\t\tdata chunk, so we can assume that track->f and track->data_size\n\t\thave been initialized.\n\t*/\n\tif (!hasFrameCount)\n\t{\n\t\tif (track->f.bytesPerPacket && track->f.framesPerPacket)\n\t\t{\n\t\t\ttrack->computeTotalFileFrames();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_af_error(AF_BAD_HEADER, \"Frame count required but not found\");\n\t\t\treturn AF_FAIL;\n\t\t}\n\t}\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_HEADER",
            "\"Frame count required but not found\""
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track->computeTotalFileFrames",
          "args": [],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "computeTotalFileFrames",
          "container": "Track",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Track.cpp",
          "lines": "173-177",
          "snippet": "void Track::computeTotalFileFrames()\n{\n\tif (f.bytesPerPacket && f.framesPerPacket)\n\t\ttotalfframes = (data_size / f.bytesPerPacket) * f.framesPerPacket;\n}",
          "includes": [
            "#include \"modules/ModuleState.h\"",
            "#include \"modules/Module.h\"",
            "#include \"PacketTable.h\"",
            "#include \"Marker.h\"",
            "#include \"util.h\"",
            "#include \"afinternal.h\"",
            "#include \"audiofile.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <assert.h>",
            "#include \"Track.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"PacketTable.h\"\n#include \"Marker.h\"\n#include \"util.h\"\n#include \"afinternal.h\"\n#include \"audiofile.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <assert.h>\n#include \"Track.h\"\n#include \"config.h\"\n\nTrack {\n  void Track::computeTotalFileFrames()\n  {\n  \tif (f.bytesPerPacket && f.framesPerPacket)\n  \t\ttotalfframes = (data_size / f.bytesPerPacket) * f.framesPerPacket;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "index + 8",
            "File::SeekFromBeginning"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parsePlayList",
          "args": [
            "chunkid",
            "chunksize"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "parsePlayList",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "463-485",
          "snippet": "status WAVEFile::parsePlayList(const Tag &id, uint32_t size)\n{\n\tuint32_t segmentCount;\n\treadU32(&segmentCount);\n\n\tif (segmentCount == 0)\n\t{\n\t\tm_instrumentCount = 0;\n\t\tm_instruments = NULL;\n\t\treturn AF_SUCCEED;\n\t}\n\n\tfor (unsigned segment=0; segment<segmentCount; segment++)\n\t{\n\t\tuint32_t startMarkID, loopLength, loopCount;\n\n\t\treadU32(&startMarkID);\n\t\treadU32(&loopLength);\n\t\treadU32(&loopCount);\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::parsePlayList(const Tag &id, uint32_t size)\n  {\n  \tuint32_t segmentCount;\n  \treadU32(&segmentCount);\n  \n  \tif (segmentCount == 0)\n  \t{\n  \t\tm_instrumentCount = 0;\n  \t\tm_instruments = NULL;\n  \t\treturn AF_SUCCEED;\n  \t}\n  \n  \tfor (unsigned segment=0; segment<segmentCount; segment++)\n  \t{\n  \t\tuint32_t startMarkID, loopLength, loopCount;\n  \n  \t\treadU32(&startMarkID);\n  \t\treadU32(&loopLength);\n  \t\treadU32(&loopCount);\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseInstrument",
          "args": [
            "chunkid",
            "chunksize"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "parseInstrument",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "671-688",
          "snippet": "status WAVEFile::parseInstrument(const Tag &id, uint32_t size)\n{\n\tuint8_t baseNote;\n\tint8_t detune, gain;\n\tuint8_t lowNote, highNote, lowVelocity, highVelocity;\n\tuint8_t padByte;\n\n\treadU8(&baseNote);\n\treadS8(&detune);\n\treadS8(&gain);\n\treadU8(&lowNote);\n\treadU8(&highNote);\n\treadU8(&lowVelocity);\n\treadU8(&highVelocity);\n\treadU8(&padByte);\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::parseInstrument(const Tag &id, uint32_t size)\n  {\n  \tuint8_t baseNote;\n  \tint8_t detune, gain;\n  \tuint8_t lowNote, highNote, lowVelocity, highVelocity;\n  \tuint8_t padByte;\n  \n  \treadU8(&baseNote);\n  \treadS8(&detune);\n  \treadS8(&gain);\n  \treadU8(&lowNote);\n  \treadU8(&highNote);\n  \treadU8(&lowVelocity);\n  \treadU8(&highVelocity);\n  \treadU8(&padByte);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseList",
          "args": [
            "chunkid",
            "chunksize"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "parseList",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "646-669",
          "snippet": "status WAVEFile::parseList(const Tag &id, uint32_t size)\n{\n\tTag typeID;\n\treadTag(&typeID);\n\tsize-=4;\n\n\tif (typeID == \"adtl\")\n\t{\n\t\t/* Handle adtl sub-chunks. */\n\t\treturn parseADTLSubChunk(typeID, size);\n\t}\n\telse if (typeID == \"INFO\")\n\t{\n\t\t/* Handle INFO sub-chunks. */\n\t\treturn parseINFOSubChunk(typeID, size);\n\t}\n\telse\n\t{\n\t\t/* Skip unhandled sub-chunks. */\n\t\tm_fh->seek(size, File::SeekFromCurrent);\n\t\treturn AF_SUCCEED;\n\t}\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::parseList(const Tag &id, uint32_t size)\n  {\n  \tTag typeID;\n  \treadTag(&typeID);\n  \tsize-=4;\n  \n  \tif (typeID == \"adtl\")\n  \t{\n  \t\t/* Handle adtl sub-chunks. */\n  \t\treturn parseADTLSubChunk(typeID, size);\n  \t}\n  \telse if (typeID == \"INFO\")\n  \t{\n  \t\t/* Handle INFO sub-chunks. */\n  \t\treturn parseINFOSubChunk(typeID, size);\n  \t}\n  \telse\n  \t{\n  \t\t/* Skip unhandled sub-chunks. */\n  \t\tm_fh->seek(size, File::SeekFromCurrent);\n  \t\treturn AF_SUCCEED;\n  \t}\n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseCues",
          "args": [
            "chunkid",
            "chunksize"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "parseCues",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "487-530",
          "snippet": "status WAVEFile::parseCues(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\tuint32_t markerCount;\n\treadU32(&markerCount);\n\ttrack->markerCount = markerCount;\n\n\tif (markerCount == 0)\n\t{\n\t\ttrack->markers = NULL;\n\t\treturn AF_SUCCEED;\n\t}\n\n\tif ((track->markers = _af_marker_new(markerCount)) == NULL)\n\t\treturn AF_FAIL;\n\n\tfor (unsigned i=0; i<markerCount; i++)\n\t{\n\t\tuint32_t id, position, chunkid;\n\t\tuint32_t chunkByteOffset, blockByteOffset;\n\t\tuint32_t sampleFrameOffset;\n\t\tMarker *marker = &track->markers[i];\n\n\t\treadU32(&id);\n\t\treadU32(&position);\n\t\treadU32(&chunkid);\n\t\treadU32(&chunkByteOffset);\n\t\treadU32(&blockByteOffset);\n\n\t\t/*\n\t\t\tsampleFrameOffset represents the position of\n\t\t\tthe mark in units of frames.\n\t\t*/\n\t\treadU32(&sampleFrameOffset);\n\n\t\tmarker->id = id;\n\t\tmarker->position = sampleFrameOffset;\n\t\tmarker->name = _af_strdup(\"\");\n\t\tmarker->comment = _af_strdup(\"\");\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::parseCues(const Tag &id, uint32_t size)\n  {\n  \tTrack *track = getTrack();\n  \n  \tuint32_t markerCount;\n  \treadU32(&markerCount);\n  \ttrack->markerCount = markerCount;\n  \n  \tif (markerCount == 0)\n  \t{\n  \t\ttrack->markers = NULL;\n  \t\treturn AF_SUCCEED;\n  \t}\n  \n  \tif ((track->markers = _af_marker_new(markerCount)) == NULL)\n  \t\treturn AF_FAIL;\n  \n  \tfor (unsigned i=0; i<markerCount; i++)\n  \t{\n  \t\tuint32_t id, position, chunkid;\n  \t\tuint32_t chunkByteOffset, blockByteOffset;\n  \t\tuint32_t sampleFrameOffset;\n  \t\tMarker *marker = &track->markers[i];\n  \n  \t\treadU32(&id);\n  \t\treadU32(&position);\n  \t\treadU32(&chunkid);\n  \t\treadU32(&chunkByteOffset);\n  \t\treadU32(&blockByteOffset);\n  \n  \t\t/*\n  \t\t\tsampleFrameOffset represents the position of\n  \t\t\tthe mark in units of frames.\n  \t\t*/\n  \t\treadU32(&sampleFrameOffset);\n  \n  \t\tmarker->id = id;\n  \t\tmarker->position = sampleFrameOffset;\n  \t\tmarker->name = _af_strdup(\"\");\n  \t\tmarker->comment = _af_strdup(\"\");\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseFrameCount",
          "args": [
            "chunkid",
            "chunksize"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "parseFrameCount",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "163-173",
          "snippet": "status WAVEFile::parseFrameCount(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\tuint32_t totalFrames;\n\treadU32(&totalFrames);\n\n\ttrack->totalfframes = totalFrames;\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::parseFrameCount(const Tag &id, uint32_t size)\n  {\n  \tTrack *track = getTrack();\n  \n  \tuint32_t totalFrames;\n  \treadU32(&totalFrames);\n  \n  \ttrack->totalfframes = totalFrames;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseData",
          "args": [
            "chunkid",
            "chunksize"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "parseData",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "453-461",
          "snippet": "status WAVEFile::parseData(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\ttrack->fpos_first_frame = m_fh->tell();\n\ttrack->data_size = size;\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::parseData(const Tag &id, uint32_t size)\n  {\n  \tTrack *track = getTrack();\n  \n  \ttrack->fpos_first_frame = m_fh->tell();\n  \ttrack->data_size = size;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_HEADER",
            "\"missing format chunk in WAVE file\""
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseFormat",
          "args": [
            "chunkid",
            "chunksize"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "parseFormat",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "175-451",
          "snippet": "status WAVEFile::parseFormat(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\tuint16_t formatTag;\n\treadU16(&formatTag);\n\tuint16_t channelCount;\n\treadU16(&channelCount);\n\tuint32_t sampleRate;\n\treadU32(&sampleRate);\n\tuint32_t averageBytesPerSecond;\n\treadU32(&averageBytesPerSecond);\n\tuint16_t blockAlign;\n\treadU16(&blockAlign);\n\n\tif (!channelCount)\n\t{\n\t\t_af_error(AF_BAD_CHANNELS, \"invalid file with 0 channels\");\n\t\treturn AF_FAIL;\n\t}\n\n\ttrack->f.channelCount = channelCount;\n\ttrack->f.sampleRate = sampleRate;\n\ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n\n\t/* Default to uncompressed audio data. */\n\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\ttrack->f.framesPerPacket = 1;\n\n\tswitch (formatTag)\n\t{\n\t\tcase WAVE_FORMAT_PCM:\n\t\t{\n\t\t\tuint16_t bitsPerSample;\n\t\t\treadU16(&bitsPerSample);\n\n\t\t\ttrack->f.sampleWidth = bitsPerSample;\n\n\t\t\tif (bitsPerSample == 0 || bitsPerSample > 32)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\"bad sample width of %d bits\",\n\t\t\t\t\tbitsPerSample);\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tif (bitsPerSample <= 8)\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t\telse\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MULAW:\n\t\tcase IBM_FORMAT_MULAW:\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n\t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_ALAW:\n\t\tcase IBM_FORMAT_ALAW:\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n\t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_IEEE_FLOAT:\n\t\t{\n\t\t\tuint16_t bitsPerSample;\n\t\t\treadU16(&bitsPerSample);\n\n\t\t\tif (bitsPerSample == 64)\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = 64;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = 32;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_ADPCM:\n\t\t{\n\t\t\tuint16_t bitsPerSample, extraByteCount,\n\t\t\t\t\tsamplesPerBlock, numCoefficients;\n\n\t\t\tif (track->f.channelCount != 1 &&\n\t\t\t\ttrack->f.channelCount != 2)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_CHANNELS,\n\t\t\t\t\t\"WAVE file with MS ADPCM compression \"\n\t\t\t\t\t\"must have 1 or 2 channels\");\n\t\t\t}\n\n\t\t\treadU16(&bitsPerSample);\n\t\t\treadU16(&extraByteCount);\n\t\t\treadU16(&samplesPerBlock);\n\t\t\treadU16(&numCoefficients);\n\n\t\t\t/* numCoefficients should be at least 7. */\n\t\t\tassert(numCoefficients >= 7 && numCoefficients <= 255);\n\t\t\tif (numCoefficients < 7 || numCoefficients > 255)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_HEADER,\n\t\t\t\t\t\t\"Bad number of coefficients\");\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tm_msadpcmNumCoefficients = numCoefficients;\n\n\t\t\tfor (int i=0; i<m_msadpcmNumCoefficients; i++)\n\t\t\t{\n\t\t\t\treadS16(&m_msadpcmCoefficients[i][0]);\n\t\t\t\treadS16(&m_msadpcmCoefficients[i][1]);\n\t\t\t}\n\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_MS_ADPCM;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\t\t\ttrack->f.framesPerPacket = samplesPerBlock;\n\t\t\ttrack->f.bytesPerPacket = blockAlign;\n\n\t\t\t// Create the parameter list.\n\t\t\tAUpvlist pv = AUpvnew(2);\n\t\t\tAUpvsetparam(pv, 0, _AF_MS_ADPCM_NUM_COEFFICIENTS);\n\t\t\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\t\t\tlong l = m_msadpcmNumCoefficients;\n\t\t\tAUpvsetval(pv, 0, &l);\n\n\t\t\tAUpvsetparam(pv, 1, _AF_MS_ADPCM_COEFFICIENTS);\n\t\t\tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n\t\t\tvoid *v = m_msadpcmCoefficients;\n\t\t\tAUpvsetval(pv, 1, &v);\n\n\t\t\ttrack->f.compressionParams = pv;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_DVI_ADPCM:\n\t\t{\n\t\t\tuint16_t bitsPerSample, extraByteCount, samplesPerBlock;\n\n\t\t\treadU16(&bitsPerSample);\n\t\t\treadU16(&extraByteCount);\n\t\t\treadU16(&samplesPerBlock);\n\n\t\t\tif (bitsPerSample != 4)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\t\"IMA ADPCM compression supports only 4 bits per sample\");\n\t\t\t}\n\n\t\t\tint bytesPerBlock = (samplesPerBlock + 14) / 8 * 4 * channelCount;\n\t\t\tif (bytesPerBlock > blockAlign || (samplesPerBlock % 8) != 1)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_CODEC_CONFIG,\n\t\t\t\t\t\"Invalid samples per block for IMA ADPCM compression\");\n\t\t\t}\n\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_IMA;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\t\t\tinitIMACompressionParams();\n\n\t\t\ttrack->f.framesPerPacket = samplesPerBlock;\n\t\t\ttrack->f.bytesPerPacket = blockAlign;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_EXTENSIBLE:\n\t\t{\n\t\t\tuint16_t bitsPerSample;\n\t\t\treadU16(&bitsPerSample);\n\t\t\tuint16_t extraByteCount;\n\t\t\treadU16(&extraByteCount);\n\t\t\tuint16_t reserved;\n\t\t\treadU16(&reserved);\n\t\t\tuint32_t channelMask;\n\t\t\treadU32(&channelMask);\n\t\t\tUUID subformat;\n\t\t\treadUUID(&subformat);\n\t\t\tif (subformat == _af_wave_guid_pcm)\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = bitsPerSample;\n\n\t\t\t\tif (bitsPerSample == 0 || bitsPerSample > 32)\n\t\t\t\t{\n\t\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\t\"bad sample width of %d bits\",\n\t\t\t\t\t\tbitsPerSample);\n\t\t\t\t\treturn AF_FAIL;\n\t\t\t\t}\n\n\t\t\t\t// Use valid bits per sample if bytes per sample is the same.\n\t\t\t\tif (reserved <= bitsPerSample &&\n\t\t\t\t\t(reserved + 7) / 8 == (bitsPerSample + 7) / 8)\n\t\t\t\t\ttrack->f.sampleWidth = reserved;\n\n\t\t\t\tif (bitsPerSample <= 8)\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t\t\telse\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\t}\n\t\t\telse if (subformat == _af_wave_guid_ieee_float)\n\t\t\t{\n\t\t\t\tif (bitsPerSample == 64)\n\t\t\t\t{\n\t\t\t\t\ttrack->f.sampleWidth = 64;\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttrack->f.sampleWidth = 32;\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (subformat == _af_wave_guid_alaw ||\n\t\t\t\tsubformat == _af_wave_guid_ulaw)\n\t\t\t{\n\t\t\t\ttrack->f.compressionType = subformat == _af_wave_guid_alaw ?\n\t\t\t\t\tAF_COMPRESSION_G711_ALAW : AF_COMPRESSION_G711_ULAW;\n\t\t\t\ttrack->f.sampleWidth = 16;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\t\ttrack->f.bytesPerPacket = channelCount;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE extensible data format %s is not currently supported\", subformat.name().c_str());\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_YAMAHA_ADPCM:\n\t\tcase WAVE_FORMAT_OKI_ADPCM:\n\t\tcase WAVE_FORMAT_CREATIVE_ADPCM:\n\t\tcase IBM_FORMAT_ADPCM:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE ADPCM data format 0x%x is not currently supported\", formatTag);\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MPEG:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG data format is not supported\");\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MPEGLAYER3:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG layer 3 data format is not supported\");\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE file data format 0x%x not currently supported != 0xfffe ? %d, != EXTENSIBLE? %d\", formatTag, formatTag != 0xfffe, formatTag != WAVE_FORMAT_EXTENSIBLE);\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\t}\n\n\tif (track->f.isUncompressed())\n\t\ttrack->f.computeBytesPerPacketPCM();\n\n\t_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const UUID _af_wave_guid_pcm =\n{{\n\t0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};",
            "static const UUID _af_wave_guid_ieee_float =\n{{\n\t0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};",
            "static const UUID _af_wave_guid_ulaw =\n{{\n\t0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};",
            "static const UUID _af_wave_guid_alaw =\n{{\n\t0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nstatic const UUID _af_wave_guid_pcm =\n{{\n\t0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};\nstatic const UUID _af_wave_guid_ieee_float =\n{{\n\t0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};\nstatic const UUID _af_wave_guid_ulaw =\n{{\n\t0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};\nstatic const UUID _af_wave_guid_alaw =\n{{\n\t0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};\n\nWAVEFile {\n  status WAVEFile::parseFormat(const Tag &id, uint32_t size)\n  {\n  \tTrack *track = getTrack();\n  \n  \tuint16_t formatTag;\n  \treadU16(&formatTag);\n  \tuint16_t channelCount;\n  \treadU16(&channelCount);\n  \tuint32_t sampleRate;\n  \treadU32(&sampleRate);\n  \tuint32_t averageBytesPerSecond;\n  \treadU32(&averageBytesPerSecond);\n  \tuint16_t blockAlign;\n  \treadU16(&blockAlign);\n  \n  \tif (!channelCount)\n  \t{\n  \t\t_af_error(AF_BAD_CHANNELS, \"invalid file with 0 channels\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \ttrack->f.channelCount = channelCount;\n  \ttrack->f.sampleRate = sampleRate;\n  \ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n  \n  \t/* Default to uncompressed audio data. */\n  \ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \ttrack->f.framesPerPacket = 1;\n  \n  \tswitch (formatTag)\n  \t{\n  \t\tcase WAVE_FORMAT_PCM:\n  \t\t{\n  \t\t\tuint16_t bitsPerSample;\n  \t\t\treadU16(&bitsPerSample);\n  \n  \t\t\ttrack->f.sampleWidth = bitsPerSample;\n  \n  \t\t\tif (bitsPerSample == 0 || bitsPerSample > 32)\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_WIDTH,\n  \t\t\t\t\t\"bad sample width of %d bits\",\n  \t\t\t\t\tbitsPerSample);\n  \t\t\t\treturn AF_FAIL;\n  \t\t\t}\n  \n  \t\t\tif (bitsPerSample <= 8)\n  \t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n  \t\t\telse\n  \t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t}\n  \t\tbreak;\n  \n  \t\tcase WAVE_FORMAT_MULAW:\n  \t\tcase IBM_FORMAT_MULAW:\n  \t\t\ttrack->f.sampleWidth = 16;\n  \t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n  \t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n  \t\t\tbreak;\n  \n  \t\tcase WAVE_FORMAT_ALAW:\n  \t\tcase IBM_FORMAT_ALAW:\n  \t\t\ttrack->f.sampleWidth = 16;\n  \t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n  \t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n  \t\t\tbreak;\n  \n  \t\tcase WAVE_FORMAT_IEEE_FLOAT:\n  \t\t{\n  \t\t\tuint16_t bitsPerSample;\n  \t\t\treadU16(&bitsPerSample);\n  \n  \t\t\tif (bitsPerSample == 64)\n  \t\t\t{\n  \t\t\t\ttrack->f.sampleWidth = 64;\n  \t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\ttrack->f.sampleWidth = 32;\n  \t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n  \t\t\t}\n  \t\t}\n  \t\tbreak;\n  \n  \t\tcase WAVE_FORMAT_ADPCM:\n  \t\t{\n  \t\t\tuint16_t bitsPerSample, extraByteCount,\n  \t\t\t\t\tsamplesPerBlock, numCoefficients;\n  \n  \t\t\tif (track->f.channelCount != 1 &&\n  \t\t\t\ttrack->f.channelCount != 2)\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_CHANNELS,\n  \t\t\t\t\t\"WAVE file with MS ADPCM compression \"\n  \t\t\t\t\t\"must have 1 or 2 channels\");\n  \t\t\t}\n  \n  \t\t\treadU16(&bitsPerSample);\n  \t\t\treadU16(&extraByteCount);\n  \t\t\treadU16(&samplesPerBlock);\n  \t\t\treadU16(&numCoefficients);\n  \n  \t\t\t/* numCoefficients should be at least 7. */\n  \t\t\tassert(numCoefficients >= 7 && numCoefficients <= 255);\n  \t\t\tif (numCoefficients < 7 || numCoefficients > 255)\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_HEADER,\n  \t\t\t\t\t\t\"Bad number of coefficients\");\n  \t\t\t\treturn AF_FAIL;\n  \t\t\t}\n  \n  \t\t\tm_msadpcmNumCoefficients = numCoefficients;\n  \n  \t\t\tfor (int i=0; i<m_msadpcmNumCoefficients; i++)\n  \t\t\t{\n  \t\t\t\treadS16(&m_msadpcmCoefficients[i][0]);\n  \t\t\t\treadS16(&m_msadpcmCoefficients[i][1]);\n  \t\t\t}\n  \n  \t\t\ttrack->f.sampleWidth = 16;\n  \t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_MS_ADPCM;\n  \t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \n  \t\t\ttrack->f.framesPerPacket = samplesPerBlock;\n  \t\t\ttrack->f.bytesPerPacket = blockAlign;\n  \n  \t\t\t// Create the parameter list.\n  \t\t\tAUpvlist pv = AUpvnew(2);\n  \t\t\tAUpvsetparam(pv, 0, _AF_MS_ADPCM_NUM_COEFFICIENTS);\n  \t\t\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n  \t\t\tlong l = m_msadpcmNumCoefficients;\n  \t\t\tAUpvsetval(pv, 0, &l);\n  \n  \t\t\tAUpvsetparam(pv, 1, _AF_MS_ADPCM_COEFFICIENTS);\n  \t\t\tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n  \t\t\tvoid *v = m_msadpcmCoefficients;\n  \t\t\tAUpvsetval(pv, 1, &v);\n  \n  \t\t\ttrack->f.compressionParams = pv;\n  \t\t}\n  \t\tbreak;\n  \n  \t\tcase WAVE_FORMAT_DVI_ADPCM:\n  \t\t{\n  \t\t\tuint16_t bitsPerSample, extraByteCount, samplesPerBlock;\n  \n  \t\t\treadU16(&bitsPerSample);\n  \t\t\treadU16(&extraByteCount);\n  \t\t\treadU16(&samplesPerBlock);\n  \n  \t\t\tif (bitsPerSample != 4)\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n  \t\t\t\t\t\"IMA ADPCM compression supports only 4 bits per sample\");\n  \t\t\t}\n  \n  \t\t\tint bytesPerBlock = (samplesPerBlock + 14) / 8 * 4 * channelCount;\n  \t\t\tif (bytesPerBlock > blockAlign || (samplesPerBlock % 8) != 1)\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_CODEC_CONFIG,\n  \t\t\t\t\t\"Invalid samples per block for IMA ADPCM compression\");\n  \t\t\t}\n  \n  \t\t\ttrack->f.sampleWidth = 16;\n  \t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_IMA;\n  \t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \n  \t\t\tinitIMACompressionParams();\n  \n  \t\t\ttrack->f.framesPerPacket = samplesPerBlock;\n  \t\t\ttrack->f.bytesPerPacket = blockAlign;\n  \t\t}\n  \t\tbreak;\n  \n  \t\tcase WAVE_FORMAT_EXTENSIBLE:\n  \t\t{\n  \t\t\tuint16_t bitsPerSample;\n  \t\t\treadU16(&bitsPerSample);\n  \t\t\tuint16_t extraByteCount;\n  \t\t\treadU16(&extraByteCount);\n  \t\t\tuint16_t reserved;\n  \t\t\treadU16(&reserved);\n  \t\t\tuint32_t channelMask;\n  \t\t\treadU32(&channelMask);\n  \t\t\tUUID subformat;\n  \t\t\treadUUID(&subformat);\n  \t\t\tif (subformat == _af_wave_guid_pcm)\n  \t\t\t{\n  \t\t\t\ttrack->f.sampleWidth = bitsPerSample;\n  \n  \t\t\t\tif (bitsPerSample == 0 || bitsPerSample > 32)\n  \t\t\t\t{\n  \t\t\t\t\t_af_error(AF_BAD_WIDTH,\n  \t\t\t\t\t\t\"bad sample width of %d bits\",\n  \t\t\t\t\t\tbitsPerSample);\n  \t\t\t\t\treturn AF_FAIL;\n  \t\t\t\t}\n  \n  \t\t\t\t// Use valid bits per sample if bytes per sample is the same.\n  \t\t\t\tif (reserved <= bitsPerSample &&\n  \t\t\t\t\t(reserved + 7) / 8 == (bitsPerSample + 7) / 8)\n  \t\t\t\t\ttrack->f.sampleWidth = reserved;\n  \n  \t\t\t\tif (bitsPerSample <= 8)\n  \t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n  \t\t\t\telse\n  \t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t\t}\n  \t\t\telse if (subformat == _af_wave_guid_ieee_float)\n  \t\t\t{\n  \t\t\t\tif (bitsPerSample == 64)\n  \t\t\t\t{\n  \t\t\t\t\ttrack->f.sampleWidth = 64;\n  \t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t{\n  \t\t\t\t\ttrack->f.sampleWidth = 32;\n  \t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\telse if (subformat == _af_wave_guid_alaw ||\n  \t\t\t\tsubformat == _af_wave_guid_ulaw)\n  \t\t\t{\n  \t\t\t\ttrack->f.compressionType = subformat == _af_wave_guid_alaw ?\n  \t\t\t\t\tAF_COMPRESSION_G711_ALAW : AF_COMPRESSION_G711_ULAW;\n  \t\t\t\ttrack->f.sampleWidth = 16;\n  \t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t\t\t\ttrack->f.bytesPerPacket = channelCount;\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE extensible data format %s is not currently supported\", subformat.name().c_str());\n  \t\t\t\treturn AF_FAIL;\n  \t\t\t}\n  \t\t}\n  \t\tbreak;\n  \n  \t\tcase WAVE_FORMAT_YAMAHA_ADPCM:\n  \t\tcase WAVE_FORMAT_OKI_ADPCM:\n  \t\tcase WAVE_FORMAT_CREATIVE_ADPCM:\n  \t\tcase IBM_FORMAT_ADPCM:\n  \t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE ADPCM data format 0x%x is not currently supported\", formatTag);\n  \t\t\treturn AF_FAIL;\n  \t\t\tbreak;\n  \n  \t\tcase WAVE_FORMAT_MPEG:\n  \t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG data format is not supported\");\n  \t\t\treturn AF_FAIL;\n  \t\t\tbreak;\n  \n  \t\tcase WAVE_FORMAT_MPEGLAYER3:\n  \t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG layer 3 data format is not supported\");\n  \t\t\treturn AF_FAIL;\n  \t\t\tbreak;\n  \n  \t\tdefault:\n  \t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE file data format 0x%x not currently supported != 0xfffe ? %d, != EXTENSIBLE? %d\", formatTag, formatTag != 0xfffe, formatTag != WAVE_FORMAT_EXTENSIBLE);\n  \t\t\treturn AF_FAIL;\n  \t\t\tbreak;\n  \t}\n  \n  \tif (track->f.isUncompressed())\n  \t\ttrack->f.computeBytesPerPacketPCM();\n  \n  \t_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readU32",
          "args": [
            "&chunksize"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "readU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "400-403",
          "snippet": "bool _AFfilehandle::readU32(uint32_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU32(uint32_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readTag",
          "args": [
            "&chunkid"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "readTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "473-482",
          "snippet": "bool _AFfilehandle::readTag(Tag *t)\n{\n\tuint32_t v;\n\tif (m_fh->read(&v, sizeof (v)) == sizeof (v))\n\t{\n\t\t*t = Tag(v);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readTag(Tag *t)\n  {\n  \tuint32_t v;\n  \tif (m_fh->read(&v, sizeof (v)) == sizeof (v))\n  \t{\n  \t\t*t = Tag(v);\n  \t\treturn true;\n  \t}\n  \treturn false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "formtype == \"WAVE\""
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "type == \"RIFF\""
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocateTrack",
          "args": [],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::readInit(AFfilesetup setup)\n  {\n  \tTag type, formtype;\n  \tuint32_t size;\n  \tuint32_t index = 0;\n  \n  \tbool hasFormat = false;\n  \tbool hasData = false;\n  \tbool hasFrameCount = false;\n  \n  \tTrack *track = allocateTrack();\n  \n  \tm_fh->seek(0, File::SeekFromBeginning);\n  \n  \treadTag(&type);\n  \treadU32(&size);\n  \treadTag(&formtype);\n  \n  \tassert(type == \"RIFF\");\n  \tassert(formtype == \"WAVE\");\n  \n  \t/* Include the offset of the form type. */\n  \tindex += 4;\n  \n  \twhile (index < size)\n  \t{\n  \t\tTag chunkid;\n  \t\tuint32_t chunksize = 0;\n  \t\tstatus result;\n  \n  \t\treadTag(&chunkid);\n  \t\treadU32(&chunksize);\n  \n  \t\tif (chunkid == \"fmt \")\n  \t\t{\n  \t\t\tresult = parseFormat(chunkid, chunksize);\n  \t\t\tif (result == AF_FAIL)\n  \t\t\t\treturn AF_FAIL;\n  \n  \t\t\thasFormat = true;\n  \t\t}\n  \t\telse if (chunkid == \"data\")\n  \t\t{\n  \t\t\t/* The format chunk must precede the data chunk. */\n  \t\t\tif (!hasFormat)\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_HEADER, \"missing format chunk in WAVE file\");\n  \t\t\t\treturn AF_FAIL;\n  \t\t\t}\n  \n  \t\t\tresult = parseData(chunkid, chunksize);\n  \t\t\tif (result == AF_FAIL)\n  \t\t\t\treturn AF_FAIL;\n  \n  \t\t\thasData = true;\n  \t\t}\n  \t\telse if (chunkid == \"inst\")\n  \t\t{\n  \t\t\tresult = parseInstrument(chunkid, chunksize);\n  \t\t\tif (result == AF_FAIL)\n  \t\t\t\treturn AF_FAIL;\n  \t\t}\n  \t\telse if (chunkid == \"fact\")\n  \t\t{\n  \t\t\thasFrameCount = true;\n  \t\t\tresult = parseFrameCount(chunkid, chunksize);\n  \t\t\tif (result == AF_FAIL)\n  \t\t\t\treturn AF_FAIL;\n  \t\t}\n  \t\telse if (chunkid == \"cue \")\n  \t\t{\n  \t\t\tresult = parseCues(chunkid, chunksize);\n  \t\t\tif (result == AF_FAIL)\n  \t\t\t\treturn AF_FAIL;\n  \t\t}\n  \t\telse if (chunkid == \"LIST\" || chunkid == \"list\")\n  \t\t{\n  \t\t\tresult = parseList(chunkid, chunksize);\n  \t\t\tif (result == AF_FAIL)\n  \t\t\t\treturn AF_FAIL;\n  \t\t}\n  \t\telse if (chunkid == \"INST\")\n  \t\t{\n  \t\t\tresult = parseInstrument(chunkid, chunksize);\n  \t\t\tif (result == AF_FAIL)\n  \t\t\t\treturn AF_FAIL;\n  \t\t}\n  \t\telse if (chunkid == \"plst\")\n  \t\t{\n  \t\t\tresult = parsePlayList(chunkid, chunksize);\n  \t\t\tif (result == AF_FAIL)\n  \t\t\t\treturn AF_FAIL;\n  \t\t}\n  \n  \t\tindex += chunksize + 8;\n  \n  \t\t/* All chunks must be aligned on an even number of bytes */\n  \t\tif ((index % 2) != 0)\n  \t\t\tindex++;\n  \n  \t\tm_fh->seek(index + 8, File::SeekFromBeginning);\n  \t}\n  \n  \t/* The format chunk and the data chunk are required. */\n  \tif (!hasFormat || !hasData)\n  \t{\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \t/*\n  \t\tAt this point we know that the file has a format chunk and a\n  \t\tdata chunk, so we can assume that track->f and track->data_size\n  \t\thave been initialized.\n  \t*/\n  \tif (!hasFrameCount)\n  \t{\n  \t\tif (track->f.bytesPerPacket && track->f.framesPerPacket)\n  \t\t{\n  \t\t\ttrack->computeTotalFileFrames();\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\t_af_error(AF_BAD_HEADER, \"Frame count required but not found\");\n  \t\t\treturn AF_FAIL;\n  \t\t}\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "recognize",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "690-702",
    "snippet": "bool WAVEFile::recognize(File *fh)\n{\n\tuint8_t buffer[8];\n\n\tfh->seek(0, File::SeekFromBeginning);\n\n\tif (fh->read(buffer, 8) != 8 || memcmp(buffer, \"RIFF\", 4) != 0)\n\t\treturn false;\n\tif (fh->read(buffer, 4) != 4 || memcmp(buffer, \"WAVE\", 4) != 0)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"WAVE\"",
            "4"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh->read",
          "args": [
            "buffer",
            "4"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"RIFF\"",
            "4"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh->seek",
          "args": [
            "0",
            "File::SeekFromBeginning"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  bool WAVEFile::recognize(File *fh)\n  {\n  \tuint8_t buffer[8];\n  \n  \tfh->seek(0, File::SeekFromBeginning);\n  \n  \tif (fh->read(buffer, 8) != 8 || memcmp(buffer, \"RIFF\", 4) != 0)\n  \t\treturn false;\n  \tif (fh->read(buffer, 4) != 4 || memcmp(buffer, \"WAVE\", 4) != 0)\n  \t\treturn false;\n  \n  \treturn true;\n  }\n}"
  },
  {
    "function_name": "parseInstrument",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "671-688",
    "snippet": "status WAVEFile::parseInstrument(const Tag &id, uint32_t size)\n{\n\tuint8_t baseNote;\n\tint8_t detune, gain;\n\tuint8_t lowNote, highNote, lowVelocity, highVelocity;\n\tuint8_t padByte;\n\n\treadU8(&baseNote);\n\treadS8(&detune);\n\treadS8(&gain);\n\treadU8(&lowNote);\n\treadU8(&highNote);\n\treadU8(&lowVelocity);\n\treadU8(&highVelocity);\n\treadU8(&padByte);\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readU8",
          "args": [
            "&padByte"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "readU8",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "387-387",
          "snippet": "bool _AFfilehandle::readU8(uint8_t *v) { return readValue(m_fh, v); }",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU8(uint8_t *v) { return readValue(m_fh, v); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readS8",
          "args": [
            "&gain"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "readS8",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "388-388",
          "snippet": "bool _AFfilehandle::readS8(int8_t *v) { return readValue(m_fh, v); }",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readS8(int8_t *v) { return readValue(m_fh, v); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::parseInstrument(const Tag &id, uint32_t size)\n  {\n  \tuint8_t baseNote;\n  \tint8_t detune, gain;\n  \tuint8_t lowNote, highNote, lowVelocity, highVelocity;\n  \tuint8_t padByte;\n  \n  \treadU8(&baseNote);\n  \treadS8(&detune);\n  \treadS8(&gain);\n  \treadU8(&lowNote);\n  \treadU8(&highNote);\n  \treadU8(&lowVelocity);\n  \treadU8(&highVelocity);\n  \treadU8(&padByte);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseList",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "646-669",
    "snippet": "status WAVEFile::parseList(const Tag &id, uint32_t size)\n{\n\tTag typeID;\n\treadTag(&typeID);\n\tsize-=4;\n\n\tif (typeID == \"adtl\")\n\t{\n\t\t/* Handle adtl sub-chunks. */\n\t\treturn parseADTLSubChunk(typeID, size);\n\t}\n\telse if (typeID == \"INFO\")\n\t{\n\t\t/* Handle INFO sub-chunks. */\n\t\treturn parseINFOSubChunk(typeID, size);\n\t}\n\telse\n\t{\n\t\t/* Skip unhandled sub-chunks. */\n\t\tm_fh->seek(size, File::SeekFromCurrent);\n\t\treturn AF_SUCCEED;\n\t}\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "size",
            "File::SeekFromCurrent"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseINFOSubChunk",
          "args": [
            "typeID",
            "size"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "parseINFOSubChunk",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "593-644",
          "snippet": "status WAVEFile::parseINFOSubChunk(const Tag &id, uint32_t size)\n{\n\tAFfileoffset endPos = m_fh->tell() + size;\n\n\twhile (m_fh->tell() < endPos)\n\t{\n\t\tint misctype = AF_MISC_UNRECOGNIZED;\n\t\tTag miscid;\n\t\tuint32_t miscsize;\n\n\t\treadTag(&miscid);\n\t\treadU32(&miscsize);\n\n\t\tif (miscid == \"IART\")\n\t\t\tmisctype = AF_MISC_AUTH;\n\t\telse if (miscid == \"INAM\")\n\t\t\tmisctype = AF_MISC_NAME;\n\t\telse if (miscid == \"ICOP\")\n\t\t\tmisctype = AF_MISC_COPY;\n\t\telse if (miscid == \"ICMT\")\n\t\t\tmisctype = AF_MISC_ICMT;\n\t\telse if (miscid == \"ICRD\")\n\t\t\tmisctype = AF_MISC_ICRD;\n\t\telse if (miscid == \"ISFT\")\n\t\t\tmisctype = AF_MISC_ISFT;\n\n\t\tif (misctype != AF_MISC_UNRECOGNIZED)\n\t\t{\n\t\t\tchar *string = (char *) _af_malloc(miscsize);\n\n\t\t\tm_fh->read(string, miscsize);\n\n\t\t\tm_miscellaneousCount++;\n\t\t\tm_miscellaneous = (Miscellaneous *) _af_realloc(m_miscellaneous, sizeof (Miscellaneous) * m_miscellaneousCount);\n\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].id = m_miscellaneousCount;\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].type = misctype;\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].size = miscsize;\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].position = 0;\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].buffer = string;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_fh->seek(miscsize, File::SeekFromCurrent);\n\t\t}\n\n\t\t/* Make the current position an even number of bytes.  */\n\t\tif (miscsize % 2 != 0)\n\t\t\tm_fh->seek(1, File::SeekFromCurrent);\n\t}\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::parseINFOSubChunk(const Tag &id, uint32_t size)\n  {\n  \tAFfileoffset endPos = m_fh->tell() + size;\n  \n  \twhile (m_fh->tell() < endPos)\n  \t{\n  \t\tint misctype = AF_MISC_UNRECOGNIZED;\n  \t\tTag miscid;\n  \t\tuint32_t miscsize;\n  \n  \t\treadTag(&miscid);\n  \t\treadU32(&miscsize);\n  \n  \t\tif (miscid == \"IART\")\n  \t\t\tmisctype = AF_MISC_AUTH;\n  \t\telse if (miscid == \"INAM\")\n  \t\t\tmisctype = AF_MISC_NAME;\n  \t\telse if (miscid == \"ICOP\")\n  \t\t\tmisctype = AF_MISC_COPY;\n  \t\telse if (miscid == \"ICMT\")\n  \t\t\tmisctype = AF_MISC_ICMT;\n  \t\telse if (miscid == \"ICRD\")\n  \t\t\tmisctype = AF_MISC_ICRD;\n  \t\telse if (miscid == \"ISFT\")\n  \t\t\tmisctype = AF_MISC_ISFT;\n  \n  \t\tif (misctype != AF_MISC_UNRECOGNIZED)\n  \t\t{\n  \t\t\tchar *string = (char *) _af_malloc(miscsize);\n  \n  \t\t\tm_fh->read(string, miscsize);\n  \n  \t\t\tm_miscellaneousCount++;\n  \t\t\tm_miscellaneous = (Miscellaneous *) _af_realloc(m_miscellaneous, sizeof (Miscellaneous) * m_miscellaneousCount);\n  \n  \t\t\tm_miscellaneous[m_miscellaneousCount-1].id = m_miscellaneousCount;\n  \t\t\tm_miscellaneous[m_miscellaneousCount-1].type = misctype;\n  \t\t\tm_miscellaneous[m_miscellaneousCount-1].size = miscsize;\n  \t\t\tm_miscellaneous[m_miscellaneousCount-1].position = 0;\n  \t\t\tm_miscellaneous[m_miscellaneousCount-1].buffer = string;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tm_fh->seek(miscsize, File::SeekFromCurrent);\n  \t\t}\n  \n  \t\t/* Make the current position an even number of bytes.  */\n  \t\tif (miscsize % 2 != 0)\n  \t\t\tm_fh->seek(1, File::SeekFromCurrent);\n  \t}\n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseADTLSubChunk",
          "args": [
            "typeID",
            "size"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "parseADTLSubChunk",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "533-590",
          "snippet": "status WAVEFile::parseADTLSubChunk(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\tAFfileoffset endPos = m_fh->tell() + size;\n\n\twhile (m_fh->tell() < endPos)\n\t{\n\t\tTag chunkID;\n\t\tuint32_t chunkSize;\n\n\t\treadTag(&chunkID);\n\t\treadU32(&chunkSize);\n\n\t\tif (chunkID == \"labl\" || chunkID == \"note\")\n\t\t{\n\t\t\tuint32_t id;\n\t\t\tlong length=chunkSize-4;\n\t\t\tchar *p = (char *) _af_malloc(length);\n\n\t\t\treadU32(&id);\n\t\t\tm_fh->read(p, length);\n\n\t\t\tMarker *marker = track->getMarker(id);\n\n\t\t\tif (marker)\n\t\t\t{\n\t\t\t\tif (chunkID == \"labl\")\n\t\t\t\t{\n\t\t\t\t\tfree(marker->name);\n\t\t\t\t\tmarker->name = p;\n\t\t\t\t}\n\t\t\t\telse if (chunkID == \"note\")\n\t\t\t\t{\n\t\t\t\t\tfree(marker->comment);\n\t\t\t\t\tmarker->comment = p;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfree(p);\n\t\t\t}\n\t\t\telse\n\t\t\t\tfree(p);\n\n\t\t\t/*\n\t\t\t\tIf chunkSize is odd, skip an extra byte\n\t\t\t\tat the end of the chunk.\n\t\t\t*/\n\t\t\tif ((chunkSize % 2) != 0)\n\t\t\t\tm_fh->seek(1, File::SeekFromCurrent);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* If chunkSize is odd, skip an extra byte. */\n\t\t\tm_fh->seek(chunkSize + (chunkSize % 2), File::SeekFromCurrent);\n\t\t}\n\t}\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::parseADTLSubChunk(const Tag &id, uint32_t size)\n  {\n  \tTrack *track = getTrack();\n  \n  \tAFfileoffset endPos = m_fh->tell() + size;\n  \n  \twhile (m_fh->tell() < endPos)\n  \t{\n  \t\tTag chunkID;\n  \t\tuint32_t chunkSize;\n  \n  \t\treadTag(&chunkID);\n  \t\treadU32(&chunkSize);\n  \n  \t\tif (chunkID == \"labl\" || chunkID == \"note\")\n  \t\t{\n  \t\t\tuint32_t id;\n  \t\t\tlong length=chunkSize-4;\n  \t\t\tchar *p = (char *) _af_malloc(length);\n  \n  \t\t\treadU32(&id);\n  \t\t\tm_fh->read(p, length);\n  \n  \t\t\tMarker *marker = track->getMarker(id);\n  \n  \t\t\tif (marker)\n  \t\t\t{\n  \t\t\t\tif (chunkID == \"labl\")\n  \t\t\t\t{\n  \t\t\t\t\tfree(marker->name);\n  \t\t\t\t\tmarker->name = p;\n  \t\t\t\t}\n  \t\t\t\telse if (chunkID == \"note\")\n  \t\t\t\t{\n  \t\t\t\t\tfree(marker->comment);\n  \t\t\t\t\tmarker->comment = p;\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t\tfree(p);\n  \t\t\t}\n  \t\t\telse\n  \t\t\t\tfree(p);\n  \n  \t\t\t/*\n  \t\t\t\tIf chunkSize is odd, skip an extra byte\n  \t\t\t\tat the end of the chunk.\n  \t\t\t*/\n  \t\t\tif ((chunkSize % 2) != 0)\n  \t\t\t\tm_fh->seek(1, File::SeekFromCurrent);\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\t/* If chunkSize is odd, skip an extra byte. */\n  \t\t\tm_fh->seek(chunkSize + (chunkSize % 2), File::SeekFromCurrent);\n  \t\t}\n  \t}\n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readTag",
          "args": [
            "&typeID"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "readTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "473-482",
          "snippet": "bool _AFfilehandle::readTag(Tag *t)\n{\n\tuint32_t v;\n\tif (m_fh->read(&v, sizeof (v)) == sizeof (v))\n\t{\n\t\t*t = Tag(v);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readTag(Tag *t)\n  {\n  \tuint32_t v;\n  \tif (m_fh->read(&v, sizeof (v)) == sizeof (v))\n  \t{\n  \t\t*t = Tag(v);\n  \t\treturn true;\n  \t}\n  \treturn false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::parseList(const Tag &id, uint32_t size)\n  {\n  \tTag typeID;\n  \treadTag(&typeID);\n  \tsize-=4;\n  \n  \tif (typeID == \"adtl\")\n  \t{\n  \t\t/* Handle adtl sub-chunks. */\n  \t\treturn parseADTLSubChunk(typeID, size);\n  \t}\n  \telse if (typeID == \"INFO\")\n  \t{\n  \t\t/* Handle INFO sub-chunks. */\n  \t\treturn parseINFOSubChunk(typeID, size);\n  \t}\n  \telse\n  \t{\n  \t\t/* Skip unhandled sub-chunks. */\n  \t\tm_fh->seek(size, File::SeekFromCurrent);\n  \t\treturn AF_SUCCEED;\n  \t}\n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseINFOSubChunk",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "593-644",
    "snippet": "status WAVEFile::parseINFOSubChunk(const Tag &id, uint32_t size)\n{\n\tAFfileoffset endPos = m_fh->tell() + size;\n\n\twhile (m_fh->tell() < endPos)\n\t{\n\t\tint misctype = AF_MISC_UNRECOGNIZED;\n\t\tTag miscid;\n\t\tuint32_t miscsize;\n\n\t\treadTag(&miscid);\n\t\treadU32(&miscsize);\n\n\t\tif (miscid == \"IART\")\n\t\t\tmisctype = AF_MISC_AUTH;\n\t\telse if (miscid == \"INAM\")\n\t\t\tmisctype = AF_MISC_NAME;\n\t\telse if (miscid == \"ICOP\")\n\t\t\tmisctype = AF_MISC_COPY;\n\t\telse if (miscid == \"ICMT\")\n\t\t\tmisctype = AF_MISC_ICMT;\n\t\telse if (miscid == \"ICRD\")\n\t\t\tmisctype = AF_MISC_ICRD;\n\t\telse if (miscid == \"ISFT\")\n\t\t\tmisctype = AF_MISC_ISFT;\n\n\t\tif (misctype != AF_MISC_UNRECOGNIZED)\n\t\t{\n\t\t\tchar *string = (char *) _af_malloc(miscsize);\n\n\t\t\tm_fh->read(string, miscsize);\n\n\t\t\tm_miscellaneousCount++;\n\t\t\tm_miscellaneous = (Miscellaneous *) _af_realloc(m_miscellaneous, sizeof (Miscellaneous) * m_miscellaneousCount);\n\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].id = m_miscellaneousCount;\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].type = misctype;\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].size = miscsize;\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].position = 0;\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].buffer = string;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_fh->seek(miscsize, File::SeekFromCurrent);\n\t\t}\n\n\t\t/* Make the current position an even number of bytes.  */\n\t\tif (miscsize % 2 != 0)\n\t\t\tm_fh->seek(1, File::SeekFromCurrent);\n\t}\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "1",
            "File::SeekFromCurrent"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_realloc",
          "args": [
            "m_miscellaneous",
            "sizeof (Miscellaneous) * m_miscellaneousCount"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fh->read",
          "args": [
            "string",
            "miscsize"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_malloc",
          "args": [
            "miscsize"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readU32",
          "args": [
            "&miscsize"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "readU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "400-403",
          "snippet": "bool _AFfilehandle::readU32(uint32_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU32(uint32_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readTag",
          "args": [
            "&miscid"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "readTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "473-482",
          "snippet": "bool _AFfilehandle::readTag(Tag *t)\n{\n\tuint32_t v;\n\tif (m_fh->read(&v, sizeof (v)) == sizeof (v))\n\t{\n\t\t*t = Tag(v);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readTag(Tag *t)\n  {\n  \tuint32_t v;\n  \tif (m_fh->read(&v, sizeof (v)) == sizeof (v))\n  \t{\n  \t\t*t = Tag(v);\n  \t\treturn true;\n  \t}\n  \treturn false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::parseINFOSubChunk(const Tag &id, uint32_t size)\n  {\n  \tAFfileoffset endPos = m_fh->tell() + size;\n  \n  \twhile (m_fh->tell() < endPos)\n  \t{\n  \t\tint misctype = AF_MISC_UNRECOGNIZED;\n  \t\tTag miscid;\n  \t\tuint32_t miscsize;\n  \n  \t\treadTag(&miscid);\n  \t\treadU32(&miscsize);\n  \n  \t\tif (miscid == \"IART\")\n  \t\t\tmisctype = AF_MISC_AUTH;\n  \t\telse if (miscid == \"INAM\")\n  \t\t\tmisctype = AF_MISC_NAME;\n  \t\telse if (miscid == \"ICOP\")\n  \t\t\tmisctype = AF_MISC_COPY;\n  \t\telse if (miscid == \"ICMT\")\n  \t\t\tmisctype = AF_MISC_ICMT;\n  \t\telse if (miscid == \"ICRD\")\n  \t\t\tmisctype = AF_MISC_ICRD;\n  \t\telse if (miscid == \"ISFT\")\n  \t\t\tmisctype = AF_MISC_ISFT;\n  \n  \t\tif (misctype != AF_MISC_UNRECOGNIZED)\n  \t\t{\n  \t\t\tchar *string = (char *) _af_malloc(miscsize);\n  \n  \t\t\tm_fh->read(string, miscsize);\n  \n  \t\t\tm_miscellaneousCount++;\n  \t\t\tm_miscellaneous = (Miscellaneous *) _af_realloc(m_miscellaneous, sizeof (Miscellaneous) * m_miscellaneousCount);\n  \n  \t\t\tm_miscellaneous[m_miscellaneousCount-1].id = m_miscellaneousCount;\n  \t\t\tm_miscellaneous[m_miscellaneousCount-1].type = misctype;\n  \t\t\tm_miscellaneous[m_miscellaneousCount-1].size = miscsize;\n  \t\t\tm_miscellaneous[m_miscellaneousCount-1].position = 0;\n  \t\t\tm_miscellaneous[m_miscellaneousCount-1].buffer = string;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tm_fh->seek(miscsize, File::SeekFromCurrent);\n  \t\t}\n  \n  \t\t/* Make the current position an even number of bytes.  */\n  \t\tif (miscsize % 2 != 0)\n  \t\t\tm_fh->seek(1, File::SeekFromCurrent);\n  \t}\n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseADTLSubChunk",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "533-590",
    "snippet": "status WAVEFile::parseADTLSubChunk(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\tAFfileoffset endPos = m_fh->tell() + size;\n\n\twhile (m_fh->tell() < endPos)\n\t{\n\t\tTag chunkID;\n\t\tuint32_t chunkSize;\n\n\t\treadTag(&chunkID);\n\t\treadU32(&chunkSize);\n\n\t\tif (chunkID == \"labl\" || chunkID == \"note\")\n\t\t{\n\t\t\tuint32_t id;\n\t\t\tlong length=chunkSize-4;\n\t\t\tchar *p = (char *) _af_malloc(length);\n\n\t\t\treadU32(&id);\n\t\t\tm_fh->read(p, length);\n\n\t\t\tMarker *marker = track->getMarker(id);\n\n\t\t\tif (marker)\n\t\t\t{\n\t\t\t\tif (chunkID == \"labl\")\n\t\t\t\t{\n\t\t\t\t\tfree(marker->name);\n\t\t\t\t\tmarker->name = p;\n\t\t\t\t}\n\t\t\t\telse if (chunkID == \"note\")\n\t\t\t\t{\n\t\t\t\t\tfree(marker->comment);\n\t\t\t\t\tmarker->comment = p;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfree(p);\n\t\t\t}\n\t\t\telse\n\t\t\t\tfree(p);\n\n\t\t\t/*\n\t\t\t\tIf chunkSize is odd, skip an extra byte\n\t\t\t\tat the end of the chunk.\n\t\t\t*/\n\t\t\tif ((chunkSize % 2) != 0)\n\t\t\t\tm_fh->seek(1, File::SeekFromCurrent);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* If chunkSize is odd, skip an extra byte. */\n\t\t\tm_fh->seek(chunkSize + (chunkSize % 2), File::SeekFromCurrent);\n\t\t}\n\t}\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "chunkSize + (chunkSize % 2)",
            "File::SeekFromCurrent"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "_af_setup_free_instruments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Setup.cpp",
          "lines": "251-263",
          "snippet": "void _af_setup_free_instruments (AFfilesetup setup)\n{\n\tif (setup->instruments)\n\t{\n\t\tfor (int i=0; i < setup->instrumentCount; i++)\n\t\t\tsetup->instruments[i].freeLoops();\n\n\t\tfree(setup->instruments);\n\t}\n\n\tsetup->instruments = NULL;\n\tsetup->instrumentCount = 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"audiofile.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"Setup.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"audiofile.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include <string.h>\n#include <stdlib.h>\n#include \"Setup.h\"\n#include \"config.h\"\n\nvoid _af_setup_free_instruments (AFfilesetup setup)\n{\n\tif (setup->instruments)\n\t{\n\t\tfor (int i=0; i < setup->instrumentCount; i++)\n\t\t\tsetup->instruments[i].freeLoops();\n\n\t\tfree(setup->instruments);\n\t}\n\n\tsetup->instruments = NULL;\n\tsetup->instrumentCount = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->getMarker",
          "args": [
            "id"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fh->read",
          "args": [
            "p",
            "length"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readU32",
          "args": [
            "&id"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "readU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "400-403",
          "snippet": "bool _AFfilehandle::readU32(uint32_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU32(uint32_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_malloc",
          "args": [
            "length"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readTag",
          "args": [
            "&chunkID"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "readTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "473-482",
          "snippet": "bool _AFfilehandle::readTag(Tag *t)\n{\n\tuint32_t v;\n\tif (m_fh->read(&v, sizeof (v)) == sizeof (v))\n\t{\n\t\t*t = Tag(v);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readTag(Tag *t)\n  {\n  \tuint32_t v;\n  \tif (m_fh->read(&v, sizeof (v)) == sizeof (v))\n  \t{\n  \t\t*t = Tag(v);\n  \t\treturn true;\n  \t}\n  \treturn false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::parseADTLSubChunk(const Tag &id, uint32_t size)\n  {\n  \tTrack *track = getTrack();\n  \n  \tAFfileoffset endPos = m_fh->tell() + size;\n  \n  \twhile (m_fh->tell() < endPos)\n  \t{\n  \t\tTag chunkID;\n  \t\tuint32_t chunkSize;\n  \n  \t\treadTag(&chunkID);\n  \t\treadU32(&chunkSize);\n  \n  \t\tif (chunkID == \"labl\" || chunkID == \"note\")\n  \t\t{\n  \t\t\tuint32_t id;\n  \t\t\tlong length=chunkSize-4;\n  \t\t\tchar *p = (char *) _af_malloc(length);\n  \n  \t\t\treadU32(&id);\n  \t\t\tm_fh->read(p, length);\n  \n  \t\t\tMarker *marker = track->getMarker(id);\n  \n  \t\t\tif (marker)\n  \t\t\t{\n  \t\t\t\tif (chunkID == \"labl\")\n  \t\t\t\t{\n  \t\t\t\t\tfree(marker->name);\n  \t\t\t\t\tmarker->name = p;\n  \t\t\t\t}\n  \t\t\t\telse if (chunkID == \"note\")\n  \t\t\t\t{\n  \t\t\t\t\tfree(marker->comment);\n  \t\t\t\t\tmarker->comment = p;\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t\tfree(p);\n  \t\t\t}\n  \t\t\telse\n  \t\t\t\tfree(p);\n  \n  \t\t\t/*\n  \t\t\t\tIf chunkSize is odd, skip an extra byte\n  \t\t\t\tat the end of the chunk.\n  \t\t\t*/\n  \t\t\tif ((chunkSize % 2) != 0)\n  \t\t\t\tm_fh->seek(1, File::SeekFromCurrent);\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\t/* If chunkSize is odd, skip an extra byte. */\n  \t\t\tm_fh->seek(chunkSize + (chunkSize % 2), File::SeekFromCurrent);\n  \t\t}\n  \t}\n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseCues",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "487-530",
    "snippet": "status WAVEFile::parseCues(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\tuint32_t markerCount;\n\treadU32(&markerCount);\n\ttrack->markerCount = markerCount;\n\n\tif (markerCount == 0)\n\t{\n\t\ttrack->markers = NULL;\n\t\treturn AF_SUCCEED;\n\t}\n\n\tif ((track->markers = _af_marker_new(markerCount)) == NULL)\n\t\treturn AF_FAIL;\n\n\tfor (unsigned i=0; i<markerCount; i++)\n\t{\n\t\tuint32_t id, position, chunkid;\n\t\tuint32_t chunkByteOffset, blockByteOffset;\n\t\tuint32_t sampleFrameOffset;\n\t\tMarker *marker = &track->markers[i];\n\n\t\treadU32(&id);\n\t\treadU32(&position);\n\t\treadU32(&chunkid);\n\t\treadU32(&chunkByteOffset);\n\t\treadU32(&blockByteOffset);\n\n\t\t/*\n\t\t\tsampleFrameOffset represents the position of\n\t\t\tthe mark in units of frames.\n\t\t*/\n\t\treadU32(&sampleFrameOffset);\n\n\t\tmarker->id = id;\n\t\tmarker->position = sampleFrameOffset;\n\t\tmarker->name = _af_strdup(\"\");\n\t\tmarker->comment = _af_strdup(\"\");\n\t}\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_strdup",
          "args": [
            "\"\""
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_strdup",
          "args": [
            "\"\""
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readU32",
          "args": [
            "&sampleFrameOffset"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "readU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "400-403",
          "snippet": "bool _AFfilehandle::readU32(uint32_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU32(uint32_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_marker_new",
          "args": [
            "markerCount"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::parseCues(const Tag &id, uint32_t size)\n  {\n  \tTrack *track = getTrack();\n  \n  \tuint32_t markerCount;\n  \treadU32(&markerCount);\n  \ttrack->markerCount = markerCount;\n  \n  \tif (markerCount == 0)\n  \t{\n  \t\ttrack->markers = NULL;\n  \t\treturn AF_SUCCEED;\n  \t}\n  \n  \tif ((track->markers = _af_marker_new(markerCount)) == NULL)\n  \t\treturn AF_FAIL;\n  \n  \tfor (unsigned i=0; i<markerCount; i++)\n  \t{\n  \t\tuint32_t id, position, chunkid;\n  \t\tuint32_t chunkByteOffset, blockByteOffset;\n  \t\tuint32_t sampleFrameOffset;\n  \t\tMarker *marker = &track->markers[i];\n  \n  \t\treadU32(&id);\n  \t\treadU32(&position);\n  \t\treadU32(&chunkid);\n  \t\treadU32(&chunkByteOffset);\n  \t\treadU32(&blockByteOffset);\n  \n  \t\t/*\n  \t\t\tsampleFrameOffset represents the position of\n  \t\t\tthe mark in units of frames.\n  \t\t*/\n  \t\treadU32(&sampleFrameOffset);\n  \n  \t\tmarker->id = id;\n  \t\tmarker->position = sampleFrameOffset;\n  \t\tmarker->name = _af_strdup(\"\");\n  \t\tmarker->comment = _af_strdup(\"\");\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parsePlayList",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "463-485",
    "snippet": "status WAVEFile::parsePlayList(const Tag &id, uint32_t size)\n{\n\tuint32_t segmentCount;\n\treadU32(&segmentCount);\n\n\tif (segmentCount == 0)\n\t{\n\t\tm_instrumentCount = 0;\n\t\tm_instruments = NULL;\n\t\treturn AF_SUCCEED;\n\t}\n\n\tfor (unsigned segment=0; segment<segmentCount; segment++)\n\t{\n\t\tuint32_t startMarkID, loopLength, loopCount;\n\n\t\treadU32(&startMarkID);\n\t\treadU32(&loopLength);\n\t\treadU32(&loopCount);\n\t}\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readU32",
          "args": [
            "&loopCount"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "readU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "400-403",
          "snippet": "bool _AFfilehandle::readU32(uint32_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU32(uint32_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::parsePlayList(const Tag &id, uint32_t size)\n  {\n  \tuint32_t segmentCount;\n  \treadU32(&segmentCount);\n  \n  \tif (segmentCount == 0)\n  \t{\n  \t\tm_instrumentCount = 0;\n  \t\tm_instruments = NULL;\n  \t\treturn AF_SUCCEED;\n  \t}\n  \n  \tfor (unsigned segment=0; segment<segmentCount; segment++)\n  \t{\n  \t\tuint32_t startMarkID, loopLength, loopCount;\n  \n  \t\treadU32(&startMarkID);\n  \t\treadU32(&loopLength);\n  \t\treadU32(&loopCount);\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseData",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "453-461",
    "snippet": "status WAVEFile::parseData(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\ttrack->fpos_first_frame = m_fh->tell();\n\ttrack->data_size = size;\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::parseData(const Tag &id, uint32_t size)\n  {\n  \tTrack *track = getTrack();\n  \n  \ttrack->fpos_first_frame = m_fh->tell();\n  \ttrack->data_size = size;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseFormat",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "175-451",
    "snippet": "status WAVEFile::parseFormat(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\tuint16_t formatTag;\n\treadU16(&formatTag);\n\tuint16_t channelCount;\n\treadU16(&channelCount);\n\tuint32_t sampleRate;\n\treadU32(&sampleRate);\n\tuint32_t averageBytesPerSecond;\n\treadU32(&averageBytesPerSecond);\n\tuint16_t blockAlign;\n\treadU16(&blockAlign);\n\n\tif (!channelCount)\n\t{\n\t\t_af_error(AF_BAD_CHANNELS, \"invalid file with 0 channels\");\n\t\treturn AF_FAIL;\n\t}\n\n\ttrack->f.channelCount = channelCount;\n\ttrack->f.sampleRate = sampleRate;\n\ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n\n\t/* Default to uncompressed audio data. */\n\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\ttrack->f.framesPerPacket = 1;\n\n\tswitch (formatTag)\n\t{\n\t\tcase WAVE_FORMAT_PCM:\n\t\t{\n\t\t\tuint16_t bitsPerSample;\n\t\t\treadU16(&bitsPerSample);\n\n\t\t\ttrack->f.sampleWidth = bitsPerSample;\n\n\t\t\tif (bitsPerSample == 0 || bitsPerSample > 32)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\"bad sample width of %d bits\",\n\t\t\t\t\tbitsPerSample);\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tif (bitsPerSample <= 8)\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t\telse\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MULAW:\n\t\tcase IBM_FORMAT_MULAW:\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n\t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_ALAW:\n\t\tcase IBM_FORMAT_ALAW:\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n\t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_IEEE_FLOAT:\n\t\t{\n\t\t\tuint16_t bitsPerSample;\n\t\t\treadU16(&bitsPerSample);\n\n\t\t\tif (bitsPerSample == 64)\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = 64;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = 32;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_ADPCM:\n\t\t{\n\t\t\tuint16_t bitsPerSample, extraByteCount,\n\t\t\t\t\tsamplesPerBlock, numCoefficients;\n\n\t\t\tif (track->f.channelCount != 1 &&\n\t\t\t\ttrack->f.channelCount != 2)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_CHANNELS,\n\t\t\t\t\t\"WAVE file with MS ADPCM compression \"\n\t\t\t\t\t\"must have 1 or 2 channels\");\n\t\t\t}\n\n\t\t\treadU16(&bitsPerSample);\n\t\t\treadU16(&extraByteCount);\n\t\t\treadU16(&samplesPerBlock);\n\t\t\treadU16(&numCoefficients);\n\n\t\t\t/* numCoefficients should be at least 7. */\n\t\t\tassert(numCoefficients >= 7 && numCoefficients <= 255);\n\t\t\tif (numCoefficients < 7 || numCoefficients > 255)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_HEADER,\n\t\t\t\t\t\t\"Bad number of coefficients\");\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tm_msadpcmNumCoefficients = numCoefficients;\n\n\t\t\tfor (int i=0; i<m_msadpcmNumCoefficients; i++)\n\t\t\t{\n\t\t\t\treadS16(&m_msadpcmCoefficients[i][0]);\n\t\t\t\treadS16(&m_msadpcmCoefficients[i][1]);\n\t\t\t}\n\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_MS_ADPCM;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\t\t\ttrack->f.framesPerPacket = samplesPerBlock;\n\t\t\ttrack->f.bytesPerPacket = blockAlign;\n\n\t\t\t// Create the parameter list.\n\t\t\tAUpvlist pv = AUpvnew(2);\n\t\t\tAUpvsetparam(pv, 0, _AF_MS_ADPCM_NUM_COEFFICIENTS);\n\t\t\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\t\t\tlong l = m_msadpcmNumCoefficients;\n\t\t\tAUpvsetval(pv, 0, &l);\n\n\t\t\tAUpvsetparam(pv, 1, _AF_MS_ADPCM_COEFFICIENTS);\n\t\t\tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n\t\t\tvoid *v = m_msadpcmCoefficients;\n\t\t\tAUpvsetval(pv, 1, &v);\n\n\t\t\ttrack->f.compressionParams = pv;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_DVI_ADPCM:\n\t\t{\n\t\t\tuint16_t bitsPerSample, extraByteCount, samplesPerBlock;\n\n\t\t\treadU16(&bitsPerSample);\n\t\t\treadU16(&extraByteCount);\n\t\t\treadU16(&samplesPerBlock);\n\n\t\t\tif (bitsPerSample != 4)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\t\"IMA ADPCM compression supports only 4 bits per sample\");\n\t\t\t}\n\n\t\t\tint bytesPerBlock = (samplesPerBlock + 14) / 8 * 4 * channelCount;\n\t\t\tif (bytesPerBlock > blockAlign || (samplesPerBlock % 8) != 1)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_CODEC_CONFIG,\n\t\t\t\t\t\"Invalid samples per block for IMA ADPCM compression\");\n\t\t\t}\n\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_IMA;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\t\t\tinitIMACompressionParams();\n\n\t\t\ttrack->f.framesPerPacket = samplesPerBlock;\n\t\t\ttrack->f.bytesPerPacket = blockAlign;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_EXTENSIBLE:\n\t\t{\n\t\t\tuint16_t bitsPerSample;\n\t\t\treadU16(&bitsPerSample);\n\t\t\tuint16_t extraByteCount;\n\t\t\treadU16(&extraByteCount);\n\t\t\tuint16_t reserved;\n\t\t\treadU16(&reserved);\n\t\t\tuint32_t channelMask;\n\t\t\treadU32(&channelMask);\n\t\t\tUUID subformat;\n\t\t\treadUUID(&subformat);\n\t\t\tif (subformat == _af_wave_guid_pcm)\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = bitsPerSample;\n\n\t\t\t\tif (bitsPerSample == 0 || bitsPerSample > 32)\n\t\t\t\t{\n\t\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\t\"bad sample width of %d bits\",\n\t\t\t\t\t\tbitsPerSample);\n\t\t\t\t\treturn AF_FAIL;\n\t\t\t\t}\n\n\t\t\t\t// Use valid bits per sample if bytes per sample is the same.\n\t\t\t\tif (reserved <= bitsPerSample &&\n\t\t\t\t\t(reserved + 7) / 8 == (bitsPerSample + 7) / 8)\n\t\t\t\t\ttrack->f.sampleWidth = reserved;\n\n\t\t\t\tif (bitsPerSample <= 8)\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t\t\telse\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\t}\n\t\t\telse if (subformat == _af_wave_guid_ieee_float)\n\t\t\t{\n\t\t\t\tif (bitsPerSample == 64)\n\t\t\t\t{\n\t\t\t\t\ttrack->f.sampleWidth = 64;\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttrack->f.sampleWidth = 32;\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (subformat == _af_wave_guid_alaw ||\n\t\t\t\tsubformat == _af_wave_guid_ulaw)\n\t\t\t{\n\t\t\t\ttrack->f.compressionType = subformat == _af_wave_guid_alaw ?\n\t\t\t\t\tAF_COMPRESSION_G711_ALAW : AF_COMPRESSION_G711_ULAW;\n\t\t\t\ttrack->f.sampleWidth = 16;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\t\ttrack->f.bytesPerPacket = channelCount;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE extensible data format %s is not currently supported\", subformat.name().c_str());\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_YAMAHA_ADPCM:\n\t\tcase WAVE_FORMAT_OKI_ADPCM:\n\t\tcase WAVE_FORMAT_CREATIVE_ADPCM:\n\t\tcase IBM_FORMAT_ADPCM:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE ADPCM data format 0x%x is not currently supported\", formatTag);\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MPEG:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG data format is not supported\");\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MPEGLAYER3:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG layer 3 data format is not supported\");\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE file data format 0x%x not currently supported != 0xfffe ? %d, != EXTENSIBLE? %d\", formatTag, formatTag != 0xfffe, formatTag != WAVE_FORMAT_EXTENSIBLE);\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\t}\n\n\tif (track->f.isUncompressed())\n\t\ttrack->f.computeBytesPerPacketPCM();\n\n\t_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const UUID _af_wave_guid_pcm =\n{{\n\t0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};",
      "static const UUID _af_wave_guid_ieee_float =\n{{\n\t0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};",
      "static const UUID _af_wave_guid_ulaw =\n{{\n\t0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};",
      "static const UUID _af_wave_guid_alaw =\n{{\n\t0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_set_sample_format",
          "args": [
            "&track->f",
            "track->f.sampleFormat",
            "track->f.sampleWidth"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "_af_set_sample_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "315-361",
          "snippet": "status _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatus _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->f.computeBytesPerPacketPCM",
          "args": [],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "computeBytesPerPacketPCM",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "98-103",
          "snippet": "void AudioFormat::computeBytesPerPacketPCM()\n{\n\tassert(isUncompressed());\n\tint bytesPerSample = (sampleWidth + 7) / 8;\n\tbytesPerPacket = bytesPerSample * channelCount;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  void AudioFormat::computeBytesPerPacketPCM()\n  {\n  \tassert(isUncompressed());\n  \tint bytesPerSample = (sampleWidth + 7) / 8;\n  \tbytesPerPacket = bytesPerSample * channelCount;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->f.isUncompressed",
          "args": [],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "isUncompressed",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "93-96",
          "snippet": "bool AudioFormat::isUncompressed() const\n{\n\treturn compressionType == AF_COMPRESSION_NONE;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  bool AudioFormat::isUncompressed() const\n  {\n  \treturn compressionType == AF_COMPRESSION_NONE;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"WAVE file data format 0x%x not currently supported != 0xfffe ? %d, != EXTENSIBLE? %d\"",
            "formatTag",
            "formatTag != 0xfffe",
            "formatTag != WAVE_FORMAT_EXTENSIBLE"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"WAVE MPEG layer 3 data format is not supported\""
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"WAVE MPEG data format is not supported\""
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"WAVE ADPCM data format 0x%x is not currently supported\"",
            "formatTag"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"WAVE extensible data format %s is not currently supported\"",
            "subformat.name().c_str()"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "subformat.name",
          "args": [],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Tag",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Tag.h",
          "lines": "45-51",
          "snippet": "std::string name() const\n\t{\n\t\tchar s[5];\n\t\tmemcpy(s, &m_value, 4);\n\t\ts[4] = '\\0';\n\t\treturn std::string(s);\n\t}",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stdint.h>\n#include <assert.h>\n\nTag {\n  std::string name() const\n  \t{\n  \t\tchar s[5];\n  \t\tmemcpy(s, &m_value, 4);\n  \t\ts[4] = '\\0';\n  \t\treturn std::string(s);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_WIDTH",
            "\"bad sample width of %d bits\"",
            "bitsPerSample"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readUUID",
          "args": [
            "&subformat"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "readUUID",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "1543-1546",
          "snippet": "bool WAVEFile::readUUID(UUID *u)\n{\n\treturn m_fh->read(u->data, 16) == 16;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  bool WAVEFile::readUUID(UUID *u)\n  {\n  \treturn m_fh->read(u->data, 16) == 16;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readU32",
          "args": [
            "&channelMask"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "readU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "400-403",
          "snippet": "bool _AFfilehandle::readU32(uint32_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU32(uint32_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readU16",
          "args": [
            "&reserved"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "readU16",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "390-393",
          "snippet": "bool _AFfilehandle::readU16(uint16_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU16(uint16_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "initIMACompressionParams",
          "args": [],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "initIMACompressionParams",
          "container": "WAVEFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
          "lines": "1562-1576",
          "snippet": "void WAVEFile::initIMACompressionParams()\n{\n\tTrack *track = getTrack();\n\n\ttrack->f.framesPerPacket = 505;\n\ttrack->f.bytesPerPacket = 256 * track->f.channelCount;\n\n\tAUpvlist pv = AUpvnew(1);\n\tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = _AF_IMA_ADPCM_TYPE_WAVE;\n\tAUpvsetval(pv, 0, &l);\n\n\ttrack->f.compressionParams = pv;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"UUID.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <math.h>",
            "#include <assert.h>",
            "#include \"WAVE.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  void WAVEFile::initIMACompressionParams()\n  {\n  \tTrack *track = getTrack();\n  \n  \ttrack->f.framesPerPacket = 505;\n  \ttrack->f.bytesPerPacket = 256 * track->f.channelCount;\n  \n  \tAUpvlist pv = AUpvnew(1);\n  \tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n  \tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n  \tlong l = _AF_IMA_ADPCM_TYPE_WAVE;\n  \tAUpvsetval(pv, 0, &l);\n  \n  \ttrack->f.compressionParams = pv;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_CODEC_CONFIG",
            "\"Invalid samples per block for IMA ADPCM compression\""
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"IMA ADPCM compression supports only 4 bits per sample\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetval",
          "args": [
            "pv",
            "1",
            "&v"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetvaltype",
          "args": [
            "pv",
            "1",
            "AU_PVTYPE_PTR"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetparam",
          "args": [
            "pv",
            "1",
            "_AF_MS_ADPCM_COEFFICIENTS"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetval",
          "args": [
            "pv",
            "0",
            "&l"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetvaltype",
          "args": [
            "pv",
            "0",
            "AU_PVTYPE_LONG"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetparam",
          "args": [
            "pv",
            "0",
            "_AF_MS_ADPCM_NUM_COEFFICIENTS"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvnew",
          "args": [
            "2"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readS16",
          "args": [
            "&m_msadpcmCoefficients[i][1]"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "readS16",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "395-398",
          "snippet": "bool _AFfilehandle::readS16(int16_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readS16(int16_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_HEADER",
            "\"Bad number of coefficients\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "numCoefficients >= 7 && numCoefficients <= 255"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_CHANNELS",
            "\"WAVE file with MS ADPCM compression \"\n\t\t\t\t\t\"must have 1 or 2 channels\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_WIDTH",
            "\"bad sample width of %d bits\"",
            "bitsPerSample"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_CHANNELS",
            "\"invalid file with 0 channels\""
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nstatic const UUID _af_wave_guid_pcm =\n{{\n\t0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};\nstatic const UUID _af_wave_guid_ieee_float =\n{{\n\t0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};\nstatic const UUID _af_wave_guid_ulaw =\n{{\n\t0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};\nstatic const UUID _af_wave_guid_alaw =\n{{\n\t0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};\n\nWAVEFile {\n  status WAVEFile::parseFormat(const Tag &id, uint32_t size)\n  {\n  \tTrack *track = getTrack();\n  \n  \tuint16_t formatTag;\n  \treadU16(&formatTag);\n  \tuint16_t channelCount;\n  \treadU16(&channelCount);\n  \tuint32_t sampleRate;\n  \treadU32(&sampleRate);\n  \tuint32_t averageBytesPerSecond;\n  \treadU32(&averageBytesPerSecond);\n  \tuint16_t blockAlign;\n  \treadU16(&blockAlign);\n  \n  \tif (!channelCount)\n  \t{\n  \t\t_af_error(AF_BAD_CHANNELS, \"invalid file with 0 channels\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \ttrack->f.channelCount = channelCount;\n  \ttrack->f.sampleRate = sampleRate;\n  \ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n  \n  \t/* Default to uncompressed audio data. */\n  \ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \ttrack->f.framesPerPacket = 1;\n  \n  \tswitch (formatTag)\n  \t{\n  \t\tcase WAVE_FORMAT_PCM:\n  \t\t{\n  \t\t\tuint16_t bitsPerSample;\n  \t\t\treadU16(&bitsPerSample);\n  \n  \t\t\ttrack->f.sampleWidth = bitsPerSample;\n  \n  \t\t\tif (bitsPerSample == 0 || bitsPerSample > 32)\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_WIDTH,\n  \t\t\t\t\t\"bad sample width of %d bits\",\n  \t\t\t\t\tbitsPerSample);\n  \t\t\t\treturn AF_FAIL;\n  \t\t\t}\n  \n  \t\t\tif (bitsPerSample <= 8)\n  \t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n  \t\t\telse\n  \t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t}\n  \t\tbreak;\n  \n  \t\tcase WAVE_FORMAT_MULAW:\n  \t\tcase IBM_FORMAT_MULAW:\n  \t\t\ttrack->f.sampleWidth = 16;\n  \t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n  \t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n  \t\t\tbreak;\n  \n  \t\tcase WAVE_FORMAT_ALAW:\n  \t\tcase IBM_FORMAT_ALAW:\n  \t\t\ttrack->f.sampleWidth = 16;\n  \t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n  \t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n  \t\t\tbreak;\n  \n  \t\tcase WAVE_FORMAT_IEEE_FLOAT:\n  \t\t{\n  \t\t\tuint16_t bitsPerSample;\n  \t\t\treadU16(&bitsPerSample);\n  \n  \t\t\tif (bitsPerSample == 64)\n  \t\t\t{\n  \t\t\t\ttrack->f.sampleWidth = 64;\n  \t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\ttrack->f.sampleWidth = 32;\n  \t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n  \t\t\t}\n  \t\t}\n  \t\tbreak;\n  \n  \t\tcase WAVE_FORMAT_ADPCM:\n  \t\t{\n  \t\t\tuint16_t bitsPerSample, extraByteCount,\n  \t\t\t\t\tsamplesPerBlock, numCoefficients;\n  \n  \t\t\tif (track->f.channelCount != 1 &&\n  \t\t\t\ttrack->f.channelCount != 2)\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_CHANNELS,\n  \t\t\t\t\t\"WAVE file with MS ADPCM compression \"\n  \t\t\t\t\t\"must have 1 or 2 channels\");\n  \t\t\t}\n  \n  \t\t\treadU16(&bitsPerSample);\n  \t\t\treadU16(&extraByteCount);\n  \t\t\treadU16(&samplesPerBlock);\n  \t\t\treadU16(&numCoefficients);\n  \n  \t\t\t/* numCoefficients should be at least 7. */\n  \t\t\tassert(numCoefficients >= 7 && numCoefficients <= 255);\n  \t\t\tif (numCoefficients < 7 || numCoefficients > 255)\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_HEADER,\n  \t\t\t\t\t\t\"Bad number of coefficients\");\n  \t\t\t\treturn AF_FAIL;\n  \t\t\t}\n  \n  \t\t\tm_msadpcmNumCoefficients = numCoefficients;\n  \n  \t\t\tfor (int i=0; i<m_msadpcmNumCoefficients; i++)\n  \t\t\t{\n  \t\t\t\treadS16(&m_msadpcmCoefficients[i][0]);\n  \t\t\t\treadS16(&m_msadpcmCoefficients[i][1]);\n  \t\t\t}\n  \n  \t\t\ttrack->f.sampleWidth = 16;\n  \t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_MS_ADPCM;\n  \t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \n  \t\t\ttrack->f.framesPerPacket = samplesPerBlock;\n  \t\t\ttrack->f.bytesPerPacket = blockAlign;\n  \n  \t\t\t// Create the parameter list.\n  \t\t\tAUpvlist pv = AUpvnew(2);\n  \t\t\tAUpvsetparam(pv, 0, _AF_MS_ADPCM_NUM_COEFFICIENTS);\n  \t\t\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n  \t\t\tlong l = m_msadpcmNumCoefficients;\n  \t\t\tAUpvsetval(pv, 0, &l);\n  \n  \t\t\tAUpvsetparam(pv, 1, _AF_MS_ADPCM_COEFFICIENTS);\n  \t\t\tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n  \t\t\tvoid *v = m_msadpcmCoefficients;\n  \t\t\tAUpvsetval(pv, 1, &v);\n  \n  \t\t\ttrack->f.compressionParams = pv;\n  \t\t}\n  \t\tbreak;\n  \n  \t\tcase WAVE_FORMAT_DVI_ADPCM:\n  \t\t{\n  \t\t\tuint16_t bitsPerSample, extraByteCount, samplesPerBlock;\n  \n  \t\t\treadU16(&bitsPerSample);\n  \t\t\treadU16(&extraByteCount);\n  \t\t\treadU16(&samplesPerBlock);\n  \n  \t\t\tif (bitsPerSample != 4)\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n  \t\t\t\t\t\"IMA ADPCM compression supports only 4 bits per sample\");\n  \t\t\t}\n  \n  \t\t\tint bytesPerBlock = (samplesPerBlock + 14) / 8 * 4 * channelCount;\n  \t\t\tif (bytesPerBlock > blockAlign || (samplesPerBlock % 8) != 1)\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_CODEC_CONFIG,\n  \t\t\t\t\t\"Invalid samples per block for IMA ADPCM compression\");\n  \t\t\t}\n  \n  \t\t\ttrack->f.sampleWidth = 16;\n  \t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_IMA;\n  \t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \n  \t\t\tinitIMACompressionParams();\n  \n  \t\t\ttrack->f.framesPerPacket = samplesPerBlock;\n  \t\t\ttrack->f.bytesPerPacket = blockAlign;\n  \t\t}\n  \t\tbreak;\n  \n  \t\tcase WAVE_FORMAT_EXTENSIBLE:\n  \t\t{\n  \t\t\tuint16_t bitsPerSample;\n  \t\t\treadU16(&bitsPerSample);\n  \t\t\tuint16_t extraByteCount;\n  \t\t\treadU16(&extraByteCount);\n  \t\t\tuint16_t reserved;\n  \t\t\treadU16(&reserved);\n  \t\t\tuint32_t channelMask;\n  \t\t\treadU32(&channelMask);\n  \t\t\tUUID subformat;\n  \t\t\treadUUID(&subformat);\n  \t\t\tif (subformat == _af_wave_guid_pcm)\n  \t\t\t{\n  \t\t\t\ttrack->f.sampleWidth = bitsPerSample;\n  \n  \t\t\t\tif (bitsPerSample == 0 || bitsPerSample > 32)\n  \t\t\t\t{\n  \t\t\t\t\t_af_error(AF_BAD_WIDTH,\n  \t\t\t\t\t\t\"bad sample width of %d bits\",\n  \t\t\t\t\t\tbitsPerSample);\n  \t\t\t\t\treturn AF_FAIL;\n  \t\t\t\t}\n  \n  \t\t\t\t// Use valid bits per sample if bytes per sample is the same.\n  \t\t\t\tif (reserved <= bitsPerSample &&\n  \t\t\t\t\t(reserved + 7) / 8 == (bitsPerSample + 7) / 8)\n  \t\t\t\t\ttrack->f.sampleWidth = reserved;\n  \n  \t\t\t\tif (bitsPerSample <= 8)\n  \t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n  \t\t\t\telse\n  \t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t\t}\n  \t\t\telse if (subformat == _af_wave_guid_ieee_float)\n  \t\t\t{\n  \t\t\t\tif (bitsPerSample == 64)\n  \t\t\t\t{\n  \t\t\t\t\ttrack->f.sampleWidth = 64;\n  \t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t{\n  \t\t\t\t\ttrack->f.sampleWidth = 32;\n  \t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\telse if (subformat == _af_wave_guid_alaw ||\n  \t\t\t\tsubformat == _af_wave_guid_ulaw)\n  \t\t\t{\n  \t\t\t\ttrack->f.compressionType = subformat == _af_wave_guid_alaw ?\n  \t\t\t\t\tAF_COMPRESSION_G711_ALAW : AF_COMPRESSION_G711_ULAW;\n  \t\t\t\ttrack->f.sampleWidth = 16;\n  \t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t\t\t\ttrack->f.bytesPerPacket = channelCount;\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE extensible data format %s is not currently supported\", subformat.name().c_str());\n  \t\t\t\treturn AF_FAIL;\n  \t\t\t}\n  \t\t}\n  \t\tbreak;\n  \n  \t\tcase WAVE_FORMAT_YAMAHA_ADPCM:\n  \t\tcase WAVE_FORMAT_OKI_ADPCM:\n  \t\tcase WAVE_FORMAT_CREATIVE_ADPCM:\n  \t\tcase IBM_FORMAT_ADPCM:\n  \t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE ADPCM data format 0x%x is not currently supported\", formatTag);\n  \t\t\treturn AF_FAIL;\n  \t\t\tbreak;\n  \n  \t\tcase WAVE_FORMAT_MPEG:\n  \t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG data format is not supported\");\n  \t\t\treturn AF_FAIL;\n  \t\t\tbreak;\n  \n  \t\tcase WAVE_FORMAT_MPEGLAYER3:\n  \t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG layer 3 data format is not supported\");\n  \t\t\treturn AF_FAIL;\n  \t\t\tbreak;\n  \n  \t\tdefault:\n  \t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE file data format 0x%x not currently supported != 0xfffe ? %d, != EXTENSIBLE? %d\", formatTag, formatTag != 0xfffe, formatTag != WAVE_FORMAT_EXTENSIBLE);\n  \t\t\treturn AF_FAIL;\n  \t\t\tbreak;\n  \t}\n  \n  \tif (track->f.isUncompressed())\n  \t\ttrack->f.computeBytesPerPacketPCM();\n  \n  \t_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseFrameCount",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "163-173",
    "snippet": "status WAVEFile::parseFrameCount(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\tuint32_t totalFrames;\n\treadU32(&totalFrames);\n\n\ttrack->totalfframes = totalFrames;\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readU32",
          "args": [
            "&totalFrames"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "readU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "400-403",
          "snippet": "bool _AFfilehandle::readU32(uint32_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU32(uint32_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  status WAVEFile::parseFrameCount(const Tag &id, uint32_t size)\n  {\n  \tTrack *track = getTrack();\n  \n  \tuint32_t totalFrames;\n  \treadU32(&totalFrames);\n  \n  \ttrack->totalfframes = totalFrames;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "WAVEFile",
    "container": "WAVEFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/WAVE.cpp",
    "lines": "151-161",
    "snippet": "WAVEFile::WAVEFile()\n{\n\tsetFormatByteOrder(AF_BYTEORDER_LITTLEENDIAN);\n\n\tm_factOffset = 0;\n\tm_miscellaneousOffset = 0;\n\tm_markOffset = 0;\n\tm_dataSizeOffset = 0;\n\n\tm_msadpcmNumCoefficients = 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"UUID.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <math.h>",
      "#include <assert.h>",
      "#include \"WAVE.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setFormatByteOrder",
          "args": [
            "AF_BYTEORDER_LITTLEENDIAN"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "setFormatByteOrder",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.h",
          "lines": "86-86",
          "snippet": "void setFormatByteOrder(int byteOrder) { m_formatByteOrder = byteOrder; }",
          "includes": [
            "#include <stdint.h>",
            "#include \"afinternal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include \"afinternal.h\"\n\n_AFfilehandle {\n  void setFormatByteOrder(int byteOrder) { m_formatByteOrder = byteOrder; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"UUID.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <assert.h>\n#include \"WAVE.h\"\n#include \"config.h\"\n\nWAVEFile {\n  WAVEFile::WAVEFile()\n  {\n  \tsetFormatByteOrder(AF_BYTEORDER_LITTLEENDIAN);\n  \n  \tm_factOffset = 0;\n  \tm_miscellaneousOffset = 0;\n  \tm_markOffset = 0;\n  \tm_dataSizeOffset = 0;\n  \n  \tm_msadpcmNumCoefficients = 0;\n  }\n}"
  }
]