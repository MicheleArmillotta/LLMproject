[
  {
    "function_name": "sync2",
    "container": "RebufferModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/RebufferModule.cpp",
    "lines": "259-271",
    "snippet": "void RebufferModule::sync2()\n{\n\tassert(m_offset >= 0 && m_offset < m_numFrames);\n\n\tmemcpy(m_outChunk->buffer, m_buffer, m_offset * m_bytesPerFrame);\n\n\tpush(m_offset);\n\n\tmemcpy(m_buffer, m_savedBuffer, m_numFrames * m_bytesPerFrame);\n\tm_offset = m_savedOffset;\n\n\tassert(m_offset >= 0 && m_offset < m_numFrames);\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include <algorithm>",
      "#include \"RebufferModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_offset >= 0 && m_offset < m_numFrames"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_buffer",
            "m_savedBuffer",
            "m_numFrames * m_bytesPerFrame"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "push",
          "args": [
            "m_offset"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "push",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.cpp",
          "lines": "74-78",
          "snippet": "void Module::push(size_t frames)\n{\n\tm_outChunk->frameCount = frames;\n\tm_sink->runPush();\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"File.h\"",
            "#include \"Module.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"SimpleModule.h\"\n#include \"File.h\"\n#include \"Module.h\"\n#include \"config.h\"\n\nModule {\n  void Module::push(size_t frames)\n  {\n  \tm_outChunk->frameCount = frames;\n  \tm_sink->runPush();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_outChunk->buffer",
            "m_buffer",
            "m_offset * m_bytesPerFrame"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_offset >= 0 && m_offset < m_numFrames"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include <algorithm>\n#include \"RebufferModule.h\"\n#include \"config.h\"\n\nRebufferModule {\n  void RebufferModule::sync2()\n  {\n  \tassert(m_offset >= 0 && m_offset < m_numFrames);\n  \n  \tmemcpy(m_outChunk->buffer, m_buffer, m_offset * m_bytesPerFrame);\n  \n  \tpush(m_offset);\n  \n  \tmemcpy(m_buffer, m_savedBuffer, m_numFrames * m_bytesPerFrame);\n  \tm_offset = m_savedOffset;\n  \n  \tassert(m_offset >= 0 && m_offset < m_numFrames);\n  }\n}"
  },
  {
    "function_name": "sync1",
    "container": "RebufferModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/RebufferModule.cpp",
    "lines": "250-257",
    "snippet": "void RebufferModule::sync1()\n{\n\tassert(m_offset >= 0 && m_offset < m_numFrames);\n\n\t// Save all the frames and the offset so we can restore our state later.\n\tmemcpy(m_savedBuffer, m_buffer, m_numFrames * m_bytesPerFrame);\n\tm_savedOffset = m_offset;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include <algorithm>",
      "#include \"RebufferModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_savedBuffer",
            "m_buffer",
            "m_numFrames * m_bytesPerFrame"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_offset >= 0 && m_offset < m_numFrames"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include <algorithm>\n#include \"RebufferModule.h\"\n#include \"config.h\"\n\nRebufferModule {\n  void RebufferModule::sync1()\n  {\n  \tassert(m_offset >= 0 && m_offset < m_numFrames);\n  \n  \t// Save all the frames and the offset so we can restore our state later.\n  \tmemcpy(m_savedBuffer, m_buffer, m_numFrames * m_bytesPerFrame);\n  \tm_savedOffset = m_offset;\n  }\n}"
  },
  {
    "function_name": "runPush",
    "container": "RebufferModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/RebufferModule.cpp",
    "lines": "184-248",
    "snippet": "void RebufferModule::runPush()\n{\n\tint framesToPush = m_inChunk->frameCount;\n\tconst char *inBuffer = static_cast<const char *>(m_inChunk->buffer);\n\tchar *outBuffer = static_cast<char *>(m_outChunk->buffer);\n\n\tassert(m_offset >= 0 && m_offset < m_numFrames);\n\n\t// Check that we will be able to push even one block.\n\tif (m_offset + framesToPush >= m_numFrames)\n\t{\n\t\tif (m_offset > 0)\n\t\t\tmemcpy(m_outChunk->buffer, m_buffer, m_offset * m_bytesPerFrame);\n\n\t\tif (m_multipleOf)\n\t\t{\n\t\t\t// Round down to nearest multiple of m_numFrames.\n\t\t\tint n = ((m_offset + framesToPush) / m_numFrames) * m_numFrames;\n\n\t\t\tassert(n > m_offset);\n\t\t\tmemcpy(outBuffer + m_offset * m_bytesPerFrame,\n\t\t\t\tinBuffer,\n\t\t\t\t(n - m_offset) * m_bytesPerFrame);\n\n\t\t\tpush(n);\n\n\t\t\tinBuffer += (n - m_offset) * m_bytesPerFrame;\n\t\t\tframesToPush -= n - m_offset;\n\t\t\tassert(framesToPush >= 0);\n\t\t\tm_offset = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (m_offset + framesToPush >= m_numFrames)\n\t\t\t{\n\t\t\t\tint n = m_numFrames - m_offset;\n\t\t\t\tmemcpy(outBuffer + m_offset * m_bytesPerFrame,\n\t\t\t\t\tinBuffer,\n\t\t\t\t\tn * m_bytesPerFrame);\n\n\t\t\t\tpush(m_numFrames);\n\n\t\t\t\tinBuffer += n * m_bytesPerFrame;\n\t\t\t\tframesToPush -= n;\n\t\t\t\tassert(framesToPush >= 0);\n\t\t\t\tm_offset = 0;\n\t\t\t}\n\t\t}\n\n\t\tassert(m_offset == 0);\n\t}\n\n\tassert(m_offset + framesToPush < m_numFrames);\n\n\t// Save remaining samples in buffer.\n\tif (framesToPush > 0)\n\t{\n\t\tmemcpy(m_buffer + m_offset * m_bytesPerFrame,\n\t\t\tinBuffer,\n\t\t\tframesToPush * m_bytesPerFrame);\n\t\tm_offset += framesToPush;\n\t}\n\n\tassert(m_offset >= 0 && m_offset < m_numFrames);\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include <algorithm>",
      "#include \"RebufferModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_offset >= 0 && m_offset < m_numFrames"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_buffer + m_offset * m_bytesPerFrame",
            "inBuffer",
            "framesToPush * m_bytesPerFrame"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_offset + framesToPush < m_numFrames"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_offset == 0"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "framesToPush >= 0"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "push",
          "args": [
            "m_numFrames"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "push",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.cpp",
          "lines": "74-78",
          "snippet": "void Module::push(size_t frames)\n{\n\tm_outChunk->frameCount = frames;\n\tm_sink->runPush();\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"File.h\"",
            "#include \"Module.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"SimpleModule.h\"\n#include \"File.h\"\n#include \"Module.h\"\n#include \"config.h\"\n\nModule {\n  void Module::push(size_t frames)\n  {\n  \tm_outChunk->frameCount = frames;\n  \tm_sink->runPush();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outBuffer + m_offset * m_bytesPerFrame",
            "inBuffer",
            "n * m_bytesPerFrame"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "framesToPush >= 0"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outBuffer + m_offset * m_bytesPerFrame",
            "inBuffer",
            "(n - m_offset) * m_bytesPerFrame"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "n > m_offset"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_outChunk->buffer",
            "m_buffer",
            "m_offset * m_bytesPerFrame"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_offset >= 0 && m_offset < m_numFrames"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<char *>",
          "args": [
            "m_outChunk->buffer"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<const char *>",
          "args": [
            "m_inChunk->buffer"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include <algorithm>\n#include \"RebufferModule.h\"\n#include \"config.h\"\n\nRebufferModule {\n  void RebufferModule::runPush()\n  {\n  \tint framesToPush = m_inChunk->frameCount;\n  \tconst char *inBuffer = static_cast<const char *>(m_inChunk->buffer);\n  \tchar *outBuffer = static_cast<char *>(m_outChunk->buffer);\n  \n  \tassert(m_offset >= 0 && m_offset < m_numFrames);\n  \n  \t// Check that we will be able to push even one block.\n  \tif (m_offset + framesToPush >= m_numFrames)\n  \t{\n  \t\tif (m_offset > 0)\n  \t\t\tmemcpy(m_outChunk->buffer, m_buffer, m_offset * m_bytesPerFrame);\n  \n  \t\tif (m_multipleOf)\n  \t\t{\n  \t\t\t// Round down to nearest multiple of m_numFrames.\n  \t\t\tint n = ((m_offset + framesToPush) / m_numFrames) * m_numFrames;\n  \n  \t\t\tassert(n > m_offset);\n  \t\t\tmemcpy(outBuffer + m_offset * m_bytesPerFrame,\n  \t\t\t\tinBuffer,\n  \t\t\t\t(n - m_offset) * m_bytesPerFrame);\n  \n  \t\t\tpush(n);\n  \n  \t\t\tinBuffer += (n - m_offset) * m_bytesPerFrame;\n  \t\t\tframesToPush -= n - m_offset;\n  \t\t\tassert(framesToPush >= 0);\n  \t\t\tm_offset = 0;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\twhile (m_offset + framesToPush >= m_numFrames)\n  \t\t\t{\n  \t\t\t\tint n = m_numFrames - m_offset;\n  \t\t\t\tmemcpy(outBuffer + m_offset * m_bytesPerFrame,\n  \t\t\t\t\tinBuffer,\n  \t\t\t\t\tn * m_bytesPerFrame);\n  \n  \t\t\t\tpush(m_numFrames);\n  \n  \t\t\t\tinBuffer += n * m_bytesPerFrame;\n  \t\t\t\tframesToPush -= n;\n  \t\t\t\tassert(framesToPush >= 0);\n  \t\t\t\tm_offset = 0;\n  \t\t\t}\n  \t\t}\n  \n  \t\tassert(m_offset == 0);\n  \t}\n  \n  \tassert(m_offset + framesToPush < m_numFrames);\n  \n  \t// Save remaining samples in buffer.\n  \tif (framesToPush > 0)\n  \t{\n  \t\tmemcpy(m_buffer + m_offset * m_bytesPerFrame,\n  \t\t\tinBuffer,\n  \t\t\tframesToPush * m_bytesPerFrame);\n  \t\tm_offset += framesToPush;\n  \t}\n  \n  \tassert(m_offset >= 0 && m_offset < m_numFrames);\n  }\n}"
  },
  {
    "function_name": "reset2",
    "container": "RebufferModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/RebufferModule.cpp",
    "lines": "179-182",
    "snippet": "void RebufferModule::reset2()\n{\n\tassert(m_offset > 0 && m_offset <= m_numFrames);\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include <algorithm>",
      "#include \"RebufferModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_offset > 0 && m_offset <= m_numFrames"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include <algorithm>\n#include \"RebufferModule.h\"\n#include \"config.h\"\n\nRebufferModule {\n  void RebufferModule::reset2()\n  {\n  \tassert(m_offset > 0 && m_offset <= m_numFrames);\n  }\n}"
  },
  {
    "function_name": "reset1",
    "container": "RebufferModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/RebufferModule.cpp",
    "lines": "171-177",
    "snippet": "void RebufferModule::reset1()\n{\n\tm_offset = m_numFrames;\n\tm_eof = false;\n\tm_sentShortChunk = false;\n\tassert(m_offset > 0 && m_offset <= m_numFrames);\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include <algorithm>",
      "#include \"RebufferModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_offset > 0 && m_offset <= m_numFrames"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include <algorithm>\n#include \"RebufferModule.h\"\n#include \"config.h\"\n\nRebufferModule {\n  void RebufferModule::reset1()\n  {\n  \tm_offset = m_numFrames;\n  \tm_eof = false;\n  \tm_sentShortChunk = false;\n  \tassert(m_offset > 0 && m_offset <= m_numFrames);\n  }\n}"
  },
  {
    "function_name": "runPull",
    "container": "RebufferModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/RebufferModule.cpp",
    "lines": "85-169",
    "snippet": "void RebufferModule::runPull()\n{\n\tint framesToPull = m_outChunk->frameCount;\n\tconst char *inBuffer = static_cast<const char *>(m_inChunk->buffer);\n\tchar *outBuffer = static_cast<char *>(m_outChunk->buffer);\n\n\tassert(m_offset > 0 && m_offset <= m_numFrames);\n\n\t/*\n\t\tA module should not pull more frames from its input\n\t\tafter receiving a short chunk.\n\t*/\n\tassert(!m_sentShortChunk);\n\n\tif (m_offset < m_numFrames)\n\t{\n\t\tint buffered = m_numFrames - m_offset;\n\t\tint n = std::min(framesToPull, buffered);\n\t\tmemcpy(outBuffer, m_buffer + m_offset * m_bytesPerFrame,\n\t\t\tn * m_bytesPerFrame);\n\t\toutBuffer += buffered * m_bytesPerFrame;\n\t\tframesToPull -= buffered;\n\t\tm_offset += n;\n\t}\n\n\t// Try to pull more frames from the source.\n\twhile (!m_eof && framesToPull > 0)\n\t{\n\t\tint framesRequested;\n\t\tif (m_multipleOf)\n\t\t\t// Round framesToPull up to nearest multiple of m_numFrames.\n\t\t\tframesRequested = ((framesToPull - 1) / m_numFrames + 1) * m_numFrames;\n\t\telse\n\t\t\tframesRequested = m_numFrames;\n\n\t\tassert(framesRequested > 0);\n\n\t\tpull(framesRequested);\n\n\t\tint framesReceived = m_inChunk->frameCount;\n\n\t\tif (framesReceived != framesRequested)\n\t\t\tm_eof = true;\n\n\t\tmemcpy(outBuffer, inBuffer,\n\t\t\tstd::min(framesToPull, framesReceived) * m_bytesPerFrame);\n\n\t\toutBuffer += framesReceived * m_bytesPerFrame;\n\t\tframesToPull -= framesReceived;\n\n\t\tif (m_multipleOf)\n\t\t\tassert(m_eof || framesToPull <= 0);\n\n\t\tif (framesToPull < 0)\n\t\t{\n\t\t\tassert(m_offset == m_numFrames);\n\n\t\t\tm_offset = m_numFrames + framesToPull;\n\n\t\t\tassert(m_offset > 0 && m_offset <= m_numFrames);\n\n\t\t\tmemcpy(m_buffer + m_offset * m_bytesPerFrame,\n\t\t\t\tinBuffer + (framesReceived + framesToPull) * m_bytesPerFrame,\n\t\t\t\t(m_numFrames - m_offset) * m_bytesPerFrame);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(m_offset == m_numFrames);\n\t\t}\n\t}\n\n\tif (m_eof && framesToPull > 0)\n\t{\n\t\t// Output short chunk.\n\t\tm_outChunk->frameCount -= framesToPull;\n\t\tm_sentShortChunk = true;\n\t\tassert(m_offset == m_numFrames);\n\t}\n\telse\n\t{\n\t\tassert(framesToPull <= 0);\n\t\tassert(m_offset == m_numFrames + framesToPull);\n\t}\n\tassert(m_offset > 0 && m_offset <= m_numFrames);\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include <algorithm>",
      "#include \"RebufferModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_offset > 0 && m_offset <= m_numFrames"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_offset == m_numFrames + framesToPull"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "framesToPull <= 0"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_offset == m_numFrames"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_offset == m_numFrames"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_buffer + m_offset * m_bytesPerFrame",
            "inBuffer + (framesReceived + framesToPull) * m_bytesPerFrame",
            "(m_numFrames - m_offset) * m_bytesPerFrame"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_offset > 0 && m_offset <= m_numFrames"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_offset == m_numFrames"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_eof || framesToPull <= 0"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outBuffer",
            "inBuffer",
            "std::min(framesToPull, framesReceived) * m_bytesPerFrame"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::min",
          "args": [
            "framesToPull",
            "framesReceived"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pull",
          "args": [
            "framesRequested"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "pull",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.cpp",
          "lines": "68-72",
          "snippet": "void Module::pull(size_t frames)\n{\n\tm_inChunk->frameCount = frames;\n\tm_source->runPull();\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"File.h\"",
            "#include \"Module.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"SimpleModule.h\"\n#include \"File.h\"\n#include \"Module.h\"\n#include \"config.h\"\n\nModule {\n  void Module::pull(size_t frames)\n  {\n  \tm_inChunk->frameCount = frames;\n  \tm_source->runPull();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "framesRequested > 0"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outBuffer",
            "m_buffer + m_offset * m_bytesPerFrame",
            "n * m_bytesPerFrame"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::min",
          "args": [
            "framesToPull",
            "buffered"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!m_sentShortChunk"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_offset > 0 && m_offset <= m_numFrames"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<char *>",
          "args": [
            "m_outChunk->buffer"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<const char *>",
          "args": [
            "m_inChunk->buffer"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include <algorithm>\n#include \"RebufferModule.h\"\n#include \"config.h\"\n\nRebufferModule {\n  void RebufferModule::runPull()\n  {\n  \tint framesToPull = m_outChunk->frameCount;\n  \tconst char *inBuffer = static_cast<const char *>(m_inChunk->buffer);\n  \tchar *outBuffer = static_cast<char *>(m_outChunk->buffer);\n  \n  \tassert(m_offset > 0 && m_offset <= m_numFrames);\n  \n  \t/*\n  \t\tA module should not pull more frames from its input\n  \t\tafter receiving a short chunk.\n  \t*/\n  \tassert(!m_sentShortChunk);\n  \n  \tif (m_offset < m_numFrames)\n  \t{\n  \t\tint buffered = m_numFrames - m_offset;\n  \t\tint n = std::min(framesToPull, buffered);\n  \t\tmemcpy(outBuffer, m_buffer + m_offset * m_bytesPerFrame,\n  \t\t\tn * m_bytesPerFrame);\n  \t\toutBuffer += buffered * m_bytesPerFrame;\n  \t\tframesToPull -= buffered;\n  \t\tm_offset += n;\n  \t}\n  \n  \t// Try to pull more frames from the source.\n  \twhile (!m_eof && framesToPull > 0)\n  \t{\n  \t\tint framesRequested;\n  \t\tif (m_multipleOf)\n  \t\t\t// Round framesToPull up to nearest multiple of m_numFrames.\n  \t\t\tframesRequested = ((framesToPull - 1) / m_numFrames + 1) * m_numFrames;\n  \t\telse\n  \t\t\tframesRequested = m_numFrames;\n  \n  \t\tassert(framesRequested > 0);\n  \n  \t\tpull(framesRequested);\n  \n  \t\tint framesReceived = m_inChunk->frameCount;\n  \n  \t\tif (framesReceived != framesRequested)\n  \t\t\tm_eof = true;\n  \n  \t\tmemcpy(outBuffer, inBuffer,\n  \t\t\tstd::min(framesToPull, framesReceived) * m_bytesPerFrame);\n  \n  \t\toutBuffer += framesReceived * m_bytesPerFrame;\n  \t\tframesToPull -= framesReceived;\n  \n  \t\tif (m_multipleOf)\n  \t\t\tassert(m_eof || framesToPull <= 0);\n  \n  \t\tif (framesToPull < 0)\n  \t\t{\n  \t\t\tassert(m_offset == m_numFrames);\n  \n  \t\t\tm_offset = m_numFrames + framesToPull;\n  \n  \t\t\tassert(m_offset > 0 && m_offset <= m_numFrames);\n  \n  \t\t\tmemcpy(m_buffer + m_offset * m_bytesPerFrame,\n  \t\t\t\tinBuffer + (framesReceived + framesToPull) * m_bytesPerFrame,\n  \t\t\t\t(m_numFrames - m_offset) * m_bytesPerFrame);\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tassert(m_offset == m_numFrames);\n  \t\t}\n  \t}\n  \n  \tif (m_eof && framesToPull > 0)\n  \t{\n  \t\t// Output short chunk.\n  \t\tm_outChunk->frameCount -= framesToPull;\n  \t\tm_sentShortChunk = true;\n  \t\tassert(m_offset == m_numFrames);\n  \t}\n  \telse\n  \t{\n  \t\tassert(framesToPull <= 0);\n  \t\tassert(m_offset == m_numFrames + framesToPull);\n  \t}\n  \tassert(m_offset > 0 && m_offset <= m_numFrames);\n  }\n}"
  },
  {
    "function_name": "maxPush",
    "container": "RebufferModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/RebufferModule.cpp",
    "lines": "76-83",
    "snippet": "void RebufferModule::maxPush()\n{\n\tassert(m_direction == VariableToFixed);\n\tif (m_multipleOf)\n\t\tm_outChunk->frameCount = m_inChunk->frameCount + m_numFrames;\n\telse\n\t\tm_outChunk->frameCount = m_numFrames;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include <algorithm>",
      "#include \"RebufferModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_direction == VariableToFixed"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include <algorithm>\n#include \"RebufferModule.h\"\n#include \"config.h\"\n\nRebufferModule {\n  void RebufferModule::maxPush()\n  {\n  \tassert(m_direction == VariableToFixed);\n  \tif (m_multipleOf)\n  \t\tm_outChunk->frameCount = m_inChunk->frameCount + m_numFrames;\n  \telse\n  \t\tm_outChunk->frameCount = m_numFrames;\n  }\n}"
  },
  {
    "function_name": "maxPull",
    "container": "RebufferModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/RebufferModule.cpp",
    "lines": "67-74",
    "snippet": "void RebufferModule::maxPull()\n{\n\tassert(m_direction == FixedToVariable);\n\tif (m_multipleOf)\n\t\tm_inChunk->frameCount = m_outChunk->frameCount + m_numFrames;\n\telse\n\t\tm_inChunk->frameCount = m_numFrames;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include <algorithm>",
      "#include \"RebufferModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_direction == FixedToVariable"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include <algorithm>\n#include \"RebufferModule.h\"\n#include \"config.h\"\n\nRebufferModule {\n  void RebufferModule::maxPull()\n  {\n  \tassert(m_direction == FixedToVariable);\n  \tif (m_multipleOf)\n  \t\tm_inChunk->frameCount = m_outChunk->frameCount + m_numFrames;\n  \telse\n  \t\tm_inChunk->frameCount = m_numFrames;\n  }\n}"
  },
  {
    "function_name": "initVariableToFixed",
    "container": "RebufferModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/RebufferModule.cpp",
    "lines": "60-65",
    "snippet": "void RebufferModule::initVariableToFixed()\n{\n\tm_offset = 0;\n\tm_buffer = new char[m_numFrames * m_bytesPerFrame];\n\tm_savedBuffer = new char[m_numFrames * m_bytesPerFrame];\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include <algorithm>",
      "#include \"RebufferModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include <algorithm>\n#include \"RebufferModule.h\"\n#include \"config.h\"\n\nRebufferModule {\n  void RebufferModule::initVariableToFixed()\n  {\n  \tm_offset = 0;\n  \tm_buffer = new char[m_numFrames * m_bytesPerFrame];\n  \tm_savedBuffer = new char[m_numFrames * m_bytesPerFrame];\n  }\n}"
  },
  {
    "function_name": "initFixedToVariable",
    "container": "RebufferModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/RebufferModule.cpp",
    "lines": "54-58",
    "snippet": "void RebufferModule::initFixedToVariable()\n{\n\tm_offset = m_numFrames;\n\tm_buffer = new char[m_numFrames * m_bytesPerFrame];\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include <algorithm>",
      "#include \"RebufferModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include <algorithm>\n#include \"RebufferModule.h\"\n#include \"config.h\"\n\nRebufferModule {\n  void RebufferModule::initFixedToVariable()\n  {\n  \tm_offset = m_numFrames;\n  \tm_buffer = new char[m_numFrames * m_bytesPerFrame];\n  }\n}"
  },
  {
    "function_name": "~RebufferModule",
    "container": "RebufferModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/RebufferModule.cpp",
    "lines": "48-52",
    "snippet": "RebufferModule::~RebufferModule()\n{\n\tdelete [] m_buffer;\n\tdelete [] m_savedBuffer;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include <algorithm>",
      "#include \"RebufferModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include <algorithm>\n#include \"RebufferModule.h\"\n#include \"config.h\"\n\nRebufferModule {\n  RebufferModule::~RebufferModule()\n  {\n  \tdelete [] m_buffer;\n  \tdelete [] m_savedBuffer;\n  }\n}"
  },
  {
    "function_name": "RebufferModule",
    "container": "RebufferModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/RebufferModule.cpp",
    "lines": "29-46",
    "snippet": "RebufferModule::RebufferModule(Direction direction, int bytesPerFrame,\n\tint numFrames, bool multipleOf) :\n\tm_direction(direction),\n\tm_bytesPerFrame(bytesPerFrame),\n\tm_numFrames(numFrames),\n\tm_multipleOf(multipleOf),\n\tm_eof(false),\n\tm_sentShortChunk(false),\n\tm_buffer(NULL),\n\tm_offset(-1),\n\tm_savedBuffer(NULL),\n\tm_savedOffset(-1)\n{\n\tif (m_direction == FixedToVariable)\n\t\tinitFixedToVariable();\n\telse\n\t\tinitVariableToFixed();\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include <algorithm>",
      "#include \"RebufferModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "initVariableToFixed",
          "args": [],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "initVariableToFixed",
          "container": "RebufferModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/RebufferModule.cpp",
          "lines": "60-65",
          "snippet": "void RebufferModule::initVariableToFixed()\n{\n\tm_offset = 0;\n\tm_buffer = new char[m_numFrames * m_bytesPerFrame];\n\tm_savedBuffer = new char[m_numFrames * m_bytesPerFrame];\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include <algorithm>",
            "#include \"RebufferModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include <algorithm>\n#include \"RebufferModule.h\"\n#include \"config.h\"\n\nRebufferModule {\n  void RebufferModule::initVariableToFixed()\n  {\n  \tm_offset = 0;\n  \tm_buffer = new char[m_numFrames * m_bytesPerFrame];\n  \tm_savedBuffer = new char[m_numFrames * m_bytesPerFrame];\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "initFixedToVariable",
          "args": [],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "initFixedToVariable",
          "container": "RebufferModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/RebufferModule.cpp",
          "lines": "54-58",
          "snippet": "void RebufferModule::initFixedToVariable()\n{\n\tm_offset = m_numFrames;\n\tm_buffer = new char[m_numFrames * m_bytesPerFrame];\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include <algorithm>",
            "#include \"RebufferModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include <algorithm>\n#include \"RebufferModule.h\"\n#include \"config.h\"\n\nRebufferModule {\n  void RebufferModule::initFixedToVariable()\n  {\n  \tm_offset = m_numFrames;\n  \tm_buffer = new char[m_numFrames * m_bytesPerFrame];\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include <algorithm>\n#include \"RebufferModule.h\"\n#include \"config.h\"\n\nRebufferModule {\n  RebufferModule::RebufferModule(Direction direction, int bytesPerFrame,\n  \tint numFrames, bool multipleOf) :\n  \tm_direction(direction),\n  \tm_bytesPerFrame(bytesPerFrame),\n  \tm_numFrames(numFrames),\n  \tm_multipleOf(multipleOf),\n  \tm_eof(false),\n  \tm_sentShortChunk(false),\n  \tm_buffer(NULL),\n  \tm_offset(-1),\n  \tm_savedBuffer(NULL),\n  \tm_savedOffset(-1)\n  {\n  \tif (m_direction == FixedToVariable)\n  \t\tinitFixedToVariable();\n  \telse\n  \t\tinitVariableToFixed();\n  }\n}"
  }
]