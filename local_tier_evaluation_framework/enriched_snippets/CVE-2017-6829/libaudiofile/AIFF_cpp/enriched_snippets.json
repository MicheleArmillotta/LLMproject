[
  {
    "function_name": "writePString",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "1199-1220",
    "snippet": "bool AIFFFile::writePString(const char *s)\n{\n\tsize_t length = strlen(s);\n\tif (length > 255)\n\t\treturn false;\n\tuint8_t sizeByte = static_cast<uint8_t>(length);\n\tif (m_fh->write(&sizeByte, 1) != 1)\n\t\treturn false;\n\tif (m_fh->write(s, length) != (ssize_t) length)\n\t\treturn false;\n\t/*\n\t\tAdd a pad byte if the length of the Pascal-style string\n\t\t(including the size byte) is odd.\n\t*/\n\tif ((length % 2) == 0)\n\t{\n\t\tuint8_t zero = 0;\n\t\tif (m_fh->write(&zero, 1) != 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "&zero",
            "1"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<uint8_t>",
          "args": [
            "length"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  bool AIFFFile::writePString(const char *s)\n  {\n  \tsize_t length = strlen(s);\n  \tif (length > 255)\n  \t\treturn false;\n  \tuint8_t sizeByte = static_cast<uint8_t>(length);\n  \tif (m_fh->write(&sizeByte, 1) != 1)\n  \t\treturn false;\n  \tif (m_fh->write(s, length) != (ssize_t) length)\n  \t\treturn false;\n  \t/*\n  \t\tAdd a pad byte if the length of the Pascal-style string\n  \t\t(including the size byte) is odd.\n  \t*/\n  \tif ((length % 2) == 0)\n  \t{\n  \t\tuint8_t zero = 0;\n  \t\tif (m_fh->write(&zero, 1) != 1)\n  \t\t\treturn false;\n  \t}\n  \treturn true;\n  }\n}"
  },
  {
    "function_name": "readPString",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "1187-1196",
    "snippet": "bool AIFFFile::readPString(char s[256])\n{\n\tuint8_t length;\n\tif (m_fh->read(&length, 1) != 1)\n\t\treturn false;\n\tif (m_fh->read(s, length) != static_cast<ssize_t>(length))\n\t\treturn false;\n\ts[length] = '\\0';\n\treturn true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<ssize_t>",
          "args": [
            "length"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fh->read",
          "args": [
            "s",
            "length"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  bool AIFFFile::readPString(char s[256])\n  {\n  \tuint8_t length;\n  \tif (m_fh->read(&length, 1) != 1)\n  \t\treturn false;\n  \tif (m_fh->read(s, length) != static_cast<ssize_t>(length))\n  \t\treturn false;\n  \ts[length] = '\\0';\n  \treturn true;\n  }\n}"
  },
  {
    "function_name": "initIMACompressionParams",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "1170-1184",
    "snippet": "void AIFFFile::initIMACompressionParams()\n{\n\tTrack *track = getTrack();\n\n\ttrack->f.bytesPerPacket = 34 * track->f.channelCount;\n\ttrack->f.framesPerPacket = 64;\n\n\tAUpvlist pv = AUpvnew(1);\n\tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = _AF_IMA_ADPCM_TYPE_QT;\n\tAUpvsetval(pv, 0, &l);\n\n\ttrack->f.compressionParams = pv;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AUpvsetval",
          "args": [
            "pv",
            "0",
            "&l"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetvaltype",
          "args": [
            "pv",
            "0",
            "AU_PVTYPE_LONG"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetparam",
          "args": [
            "pv",
            "0",
            "_AF_IMA_ADPCM_TYPE"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvnew",
          "args": [
            "1"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  void AIFFFile::initIMACompressionParams()\n  {\n  \tTrack *track = getTrack();\n  \n  \ttrack->f.bytesPerPacket = 34 * track->f.channelCount;\n  \ttrack->f.framesPerPacket = 64;\n  \n  \tAUpvlist pv = AUpvnew(1);\n  \tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n  \tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n  \tlong l = _AF_IMA_ADPCM_TYPE_QT;\n  \tAUpvsetval(pv, 0, &l);\n  \n  \ttrack->f.compressionParams = pv;\n  }\n}"
  },
  {
    "function_name": "initCompressionParams",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "1163-1168",
    "snippet": "void AIFFFile::initCompressionParams()\n{\n\tTrack *track = getTrack();\n\tif (track->f.compressionType == AF_COMPRESSION_IMA)\n\t\tinitIMACompressionParams();\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "initIMACompressionParams",
          "args": [],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "initIMACompressionParams",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "1170-1184",
          "snippet": "void AIFFFile::initIMACompressionParams()\n{\n\tTrack *track = getTrack();\n\n\ttrack->f.bytesPerPacket = 34 * track->f.channelCount;\n\ttrack->f.framesPerPacket = 64;\n\n\tAUpvlist pv = AUpvnew(1);\n\tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = _AF_IMA_ADPCM_TYPE_QT;\n\tAUpvsetval(pv, 0, &l);\n\n\ttrack->f.compressionParams = pv;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  void AIFFFile::initIMACompressionParams()\n  {\n  \tTrack *track = getTrack();\n  \n  \ttrack->f.bytesPerPacket = 34 * track->f.channelCount;\n  \ttrack->f.framesPerPacket = 64;\n  \n  \tAUpvlist pv = AUpvnew(1);\n  \tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n  \tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n  \tlong l = _AF_IMA_ADPCM_TYPE_QT;\n  \tAUpvsetval(pv, 0, &l);\n  \n  \ttrack->f.compressionParams = pv;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  void AIFFFile::initCompressionParams()\n  {\n  \tTrack *track = getTrack();\n  \tif (track->f.compressionType == AF_COMPRESSION_IMA)\n  \t\tinitIMACompressionParams();\n  }\n}"
  },
  {
    "function_name": "writeMiscellaneous",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "1112-1161",
    "snippet": "status AIFFFile::writeMiscellaneous()\n{\n\tif (m_miscellaneousPosition == 0)\n\t\tm_miscellaneousPosition = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_miscellaneousPosition, File::SeekFromBeginning);\n\n\tfor (int i=0; i<m_miscellaneousCount; i++)\n\t{\n\t\tMiscellaneous *misc = &m_miscellaneous[i];\n\t\tTag chunkType;\n\t\tuint32_t chunkSize;\n\t\tuint8_t padByte = 0;\n\n\t\tswitch (misc->type)\n\t\t{\n\t\t\tcase AF_MISC_NAME:\n\t\t\t\tchunkType = \"NAME\"; break;\n\t\t\tcase AF_MISC_AUTH:\n\t\t\t\tchunkType = \"AUTH\"; break;\n\t\t\tcase AF_MISC_COPY:\n\t\t\t\tchunkType = \"(c) \"; break;\n\t\t\tcase AF_MISC_ANNO:\n\t\t\t\tchunkType = \"ANNO\"; break;\n\t\t\tcase AF_MISC_MIDI:\n\t\t\t\tchunkType = \"MIDI\"; break;\n\t\t\tcase AF_MISC_APPL:\n\t\t\t\tchunkType = \"APPL\"; break;\n\t\t}\n\n\t\twriteTag(&chunkType);\n\n\t\tchunkSize = misc->size;\n\t\twriteU32(&chunkSize);\n\t\t/*\n\t\t\tWrite the miscellaneous buffer and then a pad byte\n\t\t\tif necessary.  If the buffer is null, skip the space\n\t\t\tfor now.\n\t\t*/\n\t\tif (misc->buffer != NULL)\n\t\t\tm_fh->write(misc->buffer, misc->size);\n\t\telse\n\t\t\tm_fh->seek(misc->size, File::SeekFromCurrent);\n\n\t\tif (misc->size % 2 != 0)\n\t\t\twriteU8(&padByte);\n\t}\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeU8",
          "args": [
            "&padByte"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "writeU8",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "430-430",
          "snippet": "bool _AFfilehandle::writeU8(const uint8_t *v) { return writeValue(m_fh, v); }",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU8(const uint8_t *v) { return writeValue(m_fh, v); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "misc->size",
            "File::SeekFromCurrent"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "misc->buffer",
            "misc->size"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&chunkSize"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeTag",
          "args": [
            "&chunkType"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "writeTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "484-488",
          "snippet": "bool _AFfilehandle::writeTag(const Tag *t)\n{\n\tuint32_t v = t->value();\n\treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeTag(const Tag *t)\n  {\n  \tuint32_t v = t->value();\n  \treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeMiscellaneous()\n  {\n  \tif (m_miscellaneousPosition == 0)\n  \t\tm_miscellaneousPosition = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_miscellaneousPosition, File::SeekFromBeginning);\n  \n  \tfor (int i=0; i<m_miscellaneousCount; i++)\n  \t{\n  \t\tMiscellaneous *misc = &m_miscellaneous[i];\n  \t\tTag chunkType;\n  \t\tuint32_t chunkSize;\n  \t\tuint8_t padByte = 0;\n  \n  \t\tswitch (misc->type)\n  \t\t{\n  \t\t\tcase AF_MISC_NAME:\n  \t\t\t\tchunkType = \"NAME\"; break;\n  \t\t\tcase AF_MISC_AUTH:\n  \t\t\t\tchunkType = \"AUTH\"; break;\n  \t\t\tcase AF_MISC_COPY:\n  \t\t\t\tchunkType = \"(c) \"; break;\n  \t\t\tcase AF_MISC_ANNO:\n  \t\t\t\tchunkType = \"ANNO\"; break;\n  \t\t\tcase AF_MISC_MIDI:\n  \t\t\t\tchunkType = \"MIDI\"; break;\n  \t\t\tcase AF_MISC_APPL:\n  \t\t\t\tchunkType = \"APPL\"; break;\n  \t\t}\n  \n  \t\twriteTag(&chunkType);\n  \n  \t\tchunkSize = misc->size;\n  \t\twriteU32(&chunkSize);\n  \t\t/*\n  \t\t\tWrite the miscellaneous buffer and then a pad byte\n  \t\t\tif necessary.  If the buffer is null, skip the space\n  \t\t\tfor now.\n  \t\t*/\n  \t\tif (misc->buffer != NULL)\n  \t\t\tm_fh->write(misc->buffer, misc->size);\n  \t\telse\n  \t\t\tm_fh->seek(misc->size, File::SeekFromCurrent);\n  \n  \t\tif (misc->size % 2 != 0)\n  \t\t\twriteU8(&padByte);\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeFVER",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "1086-1106",
    "snippet": "status AIFFFile::writeFVER()\n{\n\tuint32_t chunkSize, timeStamp;\n\n\tassert(isAIFFC());\n\n\tif (m_FVER_offset == 0)\n\t\tm_FVER_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_FVER_offset, File::SeekFromBeginning);\n\n\tm_fh->write(\"FVER\", 4);\n\n\tchunkSize = 4;\n\twriteU32(&chunkSize);\n\n\ttimeStamp = AIFC_VERSION_1;\n\twriteU32(&timeStamp);\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define AIFC_VERSION_1 0xa2805140"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&timeStamp"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "\"FVER\"",
            "4"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "m_FVER_offset",
            "File::SeekFromBeginning"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "isAIFFC()"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isAIFFC",
          "args": [],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "isAIFFC",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.h",
          "lines": "86-86",
          "snippet": "bool isAIFFC() const { return m_fileFormat == AF_FILE_AIFFC; }",
          "includes": [
            "#include \"FileHandle.h\"",
            "#include \"Compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FileHandle.h\"\n#include \"Compiler.h\"\n\nAIFFFile {\n  bool isAIFFC() const { return m_fileFormat == AF_FILE_AIFFC; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\n#define AIFC_VERSION_1 0xa2805140\n\nAIFFFile {\n  status AIFFFile::writeFVER()\n  {\n  \tuint32_t chunkSize, timeStamp;\n  \n  \tassert(isAIFFC());\n  \n  \tif (m_FVER_offset == 0)\n  \t\tm_FVER_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_FVER_offset, File::SeekFromBeginning);\n  \n  \tm_fh->write(\"FVER\", 4);\n  \n  \tchunkSize = 4;\n  \twriteU32(&chunkSize);\n  \n  \ttimeStamp = AIFC_VERSION_1;\n  \twriteU32(&timeStamp);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeMARK",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "1035-1081",
    "snippet": "status AIFFFile::writeMARK()\n{\n\tTrack *track = getTrack();\n\tif (!track->markerCount)\n\t\treturn AF_SUCCEED;\n\n\tif (m_MARK_offset == 0)\n\t\tm_MARK_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_MARK_offset, File::SeekFromBeginning);\n\n\tTag markTag(\"MARK\");\n\tuint32_t length = 0;\n\n\twriteTag(&markTag);\n\twriteU32(&length);\n\n\tAFfileoffset chunkStartPosition = m_fh->tell();\n\n\tuint16_t numMarkers = track->markerCount;\n\twriteU16(&numMarkers);\n\n\tfor (unsigned i=0; i<numMarkers; i++)\n\t{\n\t\tuint16_t id = track->markers[i].id;\n\t\twriteU16(&id);\n\n\t\tuint32_t position = track->markers[i].position;\n\t\twriteU32(&position);\n\n\t\tconst char *name = track->markers[i].name;\n\t\tassert(name);\n\n\t\t// Write the name as a Pascal-style string.\n\t\twritePString(name);\n\t}\n\n\tAFfileoffset chunkEndPosition = m_fh->tell();\n\tlength = chunkEndPosition - chunkStartPosition;\n\n\tm_fh->seek(chunkStartPosition - 4, File::SeekFromBeginning);\n\n\twriteU32(&length);\n\tm_fh->seek(chunkEndPosition, File::SeekFromBeginning);\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "chunkEndPosition",
            "File::SeekFromBeginning"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&length"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writePString",
          "args": [
            "name"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "writePString",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "1199-1220",
          "snippet": "bool AIFFFile::writePString(const char *s)\n{\n\tsize_t length = strlen(s);\n\tif (length > 255)\n\t\treturn false;\n\tuint8_t sizeByte = static_cast<uint8_t>(length);\n\tif (m_fh->write(&sizeByte, 1) != 1)\n\t\treturn false;\n\tif (m_fh->write(s, length) != (ssize_t) length)\n\t\treturn false;\n\t/*\n\t\tAdd a pad byte if the length of the Pascal-style string\n\t\t(including the size byte) is odd.\n\t*/\n\tif ((length % 2) == 0)\n\t{\n\t\tuint8_t zero = 0;\n\t\tif (m_fh->write(&zero, 1) != 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  bool AIFFFile::writePString(const char *s)\n  {\n  \tsize_t length = strlen(s);\n  \tif (length > 255)\n  \t\treturn false;\n  \tuint8_t sizeByte = static_cast<uint8_t>(length);\n  \tif (m_fh->write(&sizeByte, 1) != 1)\n  \t\treturn false;\n  \tif (m_fh->write(s, length) != (ssize_t) length)\n  \t\treturn false;\n  \t/*\n  \t\tAdd a pad byte if the length of the Pascal-style string\n  \t\t(including the size byte) is odd.\n  \t*/\n  \tif ((length % 2) == 0)\n  \t{\n  \t\tuint8_t zero = 0;\n  \t\tif (m_fh->write(&zero, 1) != 1)\n  \t\t\treturn false;\n  \t}\n  \treturn true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "name"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeU16",
          "args": [
            "&id"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "writeU16",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "433-436",
          "snippet": "bool _AFfilehandle::writeU16(const uint16_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU16(const uint16_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeTag",
          "args": [
            "&markTag"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "writeTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "484-488",
          "snippet": "bool _AFfilehandle::writeTag(const Tag *t)\n{\n\tuint32_t v = t->value();\n\treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeTag(const Tag *t)\n  {\n  \tuint32_t v = t->value();\n  \treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeMARK()\n  {\n  \tTrack *track = getTrack();\n  \tif (!track->markerCount)\n  \t\treturn AF_SUCCEED;\n  \n  \tif (m_MARK_offset == 0)\n  \t\tm_MARK_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_MARK_offset, File::SeekFromBeginning);\n  \n  \tTag markTag(\"MARK\");\n  \tuint32_t length = 0;\n  \n  \twriteTag(&markTag);\n  \twriteU32(&length);\n  \n  \tAFfileoffset chunkStartPosition = m_fh->tell();\n  \n  \tuint16_t numMarkers = track->markerCount;\n  \twriteU16(&numMarkers);\n  \n  \tfor (unsigned i=0; i<numMarkers; i++)\n  \t{\n  \t\tuint16_t id = track->markers[i].id;\n  \t\twriteU16(&id);\n  \n  \t\tuint32_t position = track->markers[i].position;\n  \t\twriteU32(&position);\n  \n  \t\tconst char *name = track->markers[i].name;\n  \t\tassert(name);\n  \n  \t\t// Write the name as a Pascal-style string.\n  \t\twritePString(name);\n  \t}\n  \n  \tAFfileoffset chunkEndPosition = m_fh->tell();\n  \tlength = chunkEndPosition - chunkStartPosition;\n  \n  \tm_fh->seek(chunkStartPosition - 4, File::SeekFromBeginning);\n  \n  \twriteU32(&length);\n  \tm_fh->seek(chunkEndPosition, File::SeekFromBeginning);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeINST",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "978-1033",
    "snippet": "status AIFFFile::writeINST()\n{\n\tuint32_t length = 20;\n\n\tstruct _INST instrumentdata;\n\n\tinstrumentdata.sustainLoopPlayMode =\n\t\tafGetLoopMode(this, AF_DEFAULT_INST, 1);\n\tinstrumentdata.sustainLoopBegin =\n\t\tafGetLoopStart(this, AF_DEFAULT_INST, 1);\n\tinstrumentdata.sustainLoopEnd =\n\t\tafGetLoopEnd(this, AF_DEFAULT_INST, 1);\n\n\tinstrumentdata.releaseLoopPlayMode =\n\t\tafGetLoopMode(this, AF_DEFAULT_INST, 2);\n\tinstrumentdata.releaseLoopBegin =\n\t\tafGetLoopStart(this, AF_DEFAULT_INST, 2);\n\tinstrumentdata.releaseLoopEnd =\n\t\tafGetLoopEnd(this, AF_DEFAULT_INST, 2);\n\n\tm_fh->write(\"INST\", 4);\n\twriteU32(&length);\n\n\tinstrumentdata.baseNote =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_BASENOTE);\n\twriteU8(&instrumentdata.baseNote);\n\tinstrumentdata.detune =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_NUMCENTS_DETUNE);\n\twriteS8(&instrumentdata.detune);\n\tinstrumentdata.lowNote =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_LONOTE);\n\twriteU8(&instrumentdata.lowNote);\n\tinstrumentdata.highNote =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_HINOTE);\n\twriteU8(&instrumentdata.highNote);\n\tinstrumentdata.lowVelocity =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_LOVELOCITY);\n\twriteU8(&instrumentdata.lowVelocity);\n\tinstrumentdata.highVelocity =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_HIVELOCITY);\n\twriteU8(&instrumentdata.highVelocity);\n\n\tinstrumentdata.gain =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_NUMDBS_GAIN);\n\twriteS16(&instrumentdata.gain);\n\n\twriteU16(&instrumentdata.sustainLoopPlayMode);\n\twriteU16(&instrumentdata.sustainLoopBegin);\n\twriteU16(&instrumentdata.sustainLoopEnd);\n\n\twriteU16(&instrumentdata.releaseLoopPlayMode);\n\twriteU16(&instrumentdata.releaseLoopBegin);\n\twriteU16(&instrumentdata.releaseLoopEnd);\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeU16",
          "args": [
            "&instrumentdata.releaseLoopEnd"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "writeU16",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "433-436",
          "snippet": "bool _AFfilehandle::writeU16(const uint16_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU16(const uint16_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeS16",
          "args": [
            "&instrumentdata.gain"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "writeS16",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "438-441",
          "snippet": "bool _AFfilehandle::writeS16(const int16_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeS16(const int16_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "afGetInstParamLong",
          "args": [
            "this",
            "AF_DEFAULT_INST",
            "AF_INST_NUMDBS_GAIN"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "afGetInstParamLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Instrument.cpp",
          "lines": "251-265",
          "snippet": "long afGetInstParamLong (AFfilehandle file, int inst, int param)\n{\n\tlong val;\n\tAUpvlist pvlist = AUpvnew(1);\n\n\tAUpvsetparam(pvlist, 0, param);\n\tAUpvsetvaltype(pvlist, 0, AU_PVTYPE_LONG);\n\n\t_af_instparam_get(file, inst, pvlist, 1, true);\n\n\tAUpvgetval(pvlist, 0, &val);\n\tAUpvfree(pvlist);\n\n\treturn(val);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\nlong afGetInstParamLong (AFfilehandle file, int inst, int param)\n{\n\tlong val;\n\tAUpvlist pvlist = AUpvnew(1);\n\n\tAUpvsetparam(pvlist, 0, param);\n\tAUpvsetvaltype(pvlist, 0, AU_PVTYPE_LONG);\n\n\t_af_instparam_get(file, inst, pvlist, 1, true);\n\n\tAUpvgetval(pvlist, 0, &val);\n\tAUpvfree(pvlist);\n\n\treturn(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU8",
          "args": [
            "&instrumentdata.highVelocity"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "writeU8",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "430-430",
          "snippet": "bool _AFfilehandle::writeU8(const uint8_t *v) { return writeValue(m_fh, v); }",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU8(const uint8_t *v) { return writeValue(m_fh, v); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeS8",
          "args": [
            "&instrumentdata.detune"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "writeS8",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "431-431",
          "snippet": "bool _AFfilehandle::writeS8(const int8_t *v) { return writeValue(m_fh, v); }",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeS8(const int8_t *v) { return writeValue(m_fh, v); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&length"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "\"INST\"",
            "4"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "afGetLoopEnd",
          "args": [
            "this",
            "AF_DEFAULT_INST",
            "2"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "afGetLoopEndFrame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Loop.cpp",
          "lines": "302-313",
          "snippet": "AFframecount afGetLoopEndFrame (AFfilehandle file, int instid, int loopid)\n{\n\tLoop *loop = getLoop(file, instid, loopid, false);\n\n\tif (!loop)\n\t\treturn -1;\n\n\tint trackid = loop->trackid;\n\tint endMarker = loop->endMarker;\n\n\treturn afGetMarkPosition(file, trackid, endMarker);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\nAFframecount afGetLoopEndFrame (AFfilehandle file, int instid, int loopid)\n{\n\tLoop *loop = getLoop(file, instid, loopid, false);\n\n\tif (!loop)\n\t\treturn -1;\n\n\tint trackid = loop->trackid;\n\tint endMarker = loop->endMarker;\n\n\treturn afGetMarkPosition(file, trackid, endMarker);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afGetLoopStart",
          "args": [
            "this",
            "AF_DEFAULT_INST",
            "2"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "afGetLoopStartFrame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Loop.cpp",
          "lines": "213-223",
          "snippet": "AFframecount afGetLoopStartFrame (AFfilehandle file, int instid, int loopid)\n{\n\tLoop *loop = getLoop(file, instid, loopid, false);\n\tif (!loop)\n\t\treturn -1;\n\n\tint trackid = loop->trackid;\n\tint beginMarker = loop->beginMarker;\n\n\treturn afGetMarkPosition(file, trackid, beginMarker);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\nAFframecount afGetLoopStartFrame (AFfilehandle file, int instid, int loopid)\n{\n\tLoop *loop = getLoop(file, instid, loopid, false);\n\tif (!loop)\n\t\treturn -1;\n\n\tint trackid = loop->trackid;\n\tint beginMarker = loop->beginMarker;\n\n\treturn afGetMarkPosition(file, trackid, beginMarker);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afGetLoopMode",
          "args": [
            "this",
            "AF_DEFAULT_INST",
            "2"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "afGetLoopMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Loop.cpp",
          "lines": "118-126",
          "snippet": "int afGetLoopMode (AFfilehandle file, int instid, int loopid)\n{\n\tLoop *loop = getLoop(file, instid, loopid, false);\n\n\tif (!loop)\n\t\treturn -1;\n\n\treturn loop->mode;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\nint afGetLoopMode (AFfilehandle file, int instid, int loopid)\n{\n\tLoop *loop = getLoop(file, instid, loopid, false);\n\n\tif (!loop)\n\t\treturn -1;\n\n\treturn loop->mode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeINST()\n  {\n  \tuint32_t length = 20;\n  \n  \tstruct _INST instrumentdata;\n  \n  \tinstrumentdata.sustainLoopPlayMode =\n  \t\tafGetLoopMode(this, AF_DEFAULT_INST, 1);\n  \tinstrumentdata.sustainLoopBegin =\n  \t\tafGetLoopStart(this, AF_DEFAULT_INST, 1);\n  \tinstrumentdata.sustainLoopEnd =\n  \t\tafGetLoopEnd(this, AF_DEFAULT_INST, 1);\n  \n  \tinstrumentdata.releaseLoopPlayMode =\n  \t\tafGetLoopMode(this, AF_DEFAULT_INST, 2);\n  \tinstrumentdata.releaseLoopBegin =\n  \t\tafGetLoopStart(this, AF_DEFAULT_INST, 2);\n  \tinstrumentdata.releaseLoopEnd =\n  \t\tafGetLoopEnd(this, AF_DEFAULT_INST, 2);\n  \n  \tm_fh->write(\"INST\", 4);\n  \twriteU32(&length);\n  \n  \tinstrumentdata.baseNote =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_BASENOTE);\n  \twriteU8(&instrumentdata.baseNote);\n  \tinstrumentdata.detune =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_NUMCENTS_DETUNE);\n  \twriteS8(&instrumentdata.detune);\n  \tinstrumentdata.lowNote =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_LONOTE);\n  \twriteU8(&instrumentdata.lowNote);\n  \tinstrumentdata.highNote =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_HINOTE);\n  \twriteU8(&instrumentdata.highNote);\n  \tinstrumentdata.lowVelocity =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_LOVELOCITY);\n  \twriteU8(&instrumentdata.lowVelocity);\n  \tinstrumentdata.highVelocity =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_HIVELOCITY);\n  \twriteU8(&instrumentdata.highVelocity);\n  \n  \tinstrumentdata.gain =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_NUMDBS_GAIN);\n  \twriteS16(&instrumentdata.gain);\n  \n  \twriteU16(&instrumentdata.sustainLoopPlayMode);\n  \twriteU16(&instrumentdata.sustainLoopBegin);\n  \twriteU16(&instrumentdata.sustainLoopEnd);\n  \n  \twriteU16(&instrumentdata.releaseLoopPlayMode);\n  \twriteU16(&instrumentdata.releaseLoopBegin);\n  \twriteU16(&instrumentdata.releaseLoopEnd);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeSSND",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "952-976",
    "snippet": "status AIFFFile::writeSSND()\n{\n\tTrack *track = getTrack();\n\n\tif (m_SSND_offset == 0)\n\t\tm_SSND_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_SSND_offset, File::SeekFromBeginning);\n\n\tm_fh->write(\"SSND\", 4);\n\n\tuint32_t chunkSize = track->data_size + 8;\n\twriteU32(&chunkSize);\n\n\tuint32_t zero = 0;\n\t/* data offset */\n\twriteU32(&zero);\n\t/* block size */\n\twriteU32(&zero);\n\n\tif (track->fpos_first_frame == 0)\n\t\ttrack->fpos_first_frame = m_fh->tell();\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&zero"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "\"SSND\"",
            "4"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "m_SSND_offset",
            "File::SeekFromBeginning"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeSSND()\n  {\n  \tTrack *track = getTrack();\n  \n  \tif (m_SSND_offset == 0)\n  \t\tm_SSND_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_SSND_offset, File::SeekFromBeginning);\n  \n  \tm_fh->write(\"SSND\", 4);\n  \n  \tuint32_t chunkSize = track->data_size + 8;\n  \twriteU32(&chunkSize);\n  \n  \tuint32_t zero = 0;\n  \t/* data offset */\n  \twriteU32(&zero);\n  \t/* block size */\n  \twriteU32(&zero);\n  \n  \tif (track->fpos_first_frame == 0)\n  \t\ttrack->fpos_first_frame = m_fh->tell();\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeAESD",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "927-950",
    "snippet": "status AIFFFile::writeAESD()\n{\n\tTrack *track = getTrack();\n\n\tif (!track->hasAESData)\n\t\treturn AF_SUCCEED;\n\n\tif (m_AESD_offset == 0)\n\t\tm_AESD_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_AESD_offset, File::SeekFromBeginning);\n\n\tif (m_fh->write(\"AESD\", 4) < 4)\n\t\treturn AF_FAIL;\n\n\tuint32_t size = 24;\n\tif (!writeU32(&size))\n\t\treturn AF_FAIL;\n\n\tif (m_fh->write(track->aesData, 24) < 24)\n\t\treturn AF_FAIL;\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "track->aesData",
            "24"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&size"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "m_AESD_offset",
            "File::SeekFromBeginning"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeAESD()\n  {\n  \tTrack *track = getTrack();\n  \n  \tif (!track->hasAESData)\n  \t\treturn AF_SUCCEED;\n  \n  \tif (m_AESD_offset == 0)\n  \t\tm_AESD_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_AESD_offset, File::SeekFromBeginning);\n  \n  \tif (m_fh->write(\"AESD\", 4) < 4)\n  \t\treturn AF_FAIL;\n  \n  \tuint32_t size = 24;\n  \tif (!writeU32(&size))\n  \t\treturn AF_FAIL;\n  \n  \tif (m_fh->write(track->aesData, 24) < 24)\n  \t\treturn AF_FAIL;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeCOMM",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "812-921",
    "snippet": "status AIFFFile::writeCOMM()\n{\n\t/*\n\t\tIf COMM_offset hasn't been set yet, set it to the\n\t\tcurrent offset.\n\t*/\n\tif (m_COMM_offset == 0)\n\t\tm_COMM_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_COMM_offset, File::SeekFromBeginning);\n\n\tTrack *track = getTrack();\n\n\tTag compressionTag;\n\t/* Pascal strings can occupy only 255 bytes (+ a size byte). */\n\tchar compressionName[256];\n\n\tif (isAIFFC())\n\t{\n\t\tif (track->f.compressionType == AF_COMPRESSION_NONE)\n\t\t{\n\t\t\tif (track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t{\n\t\t\t\tcompressionTag = \"NONE\";\n\t\t\t\tstrcpy(compressionName, \"not compressed\");\n\t\t\t}\n\t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_FLOAT)\n\t\t\t{\n\t\t\t\tcompressionTag = \"fl32\";\n\t\t\t\tstrcpy(compressionName, \"32-bit Floating Point\");\n\t\t\t}\n\t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_DOUBLE)\n\t\t\t{\n\t\t\t\tcompressionTag = \"fl64\";\n\t\t\t\tstrcpy(compressionName, \"64-bit Floating Point\");\n\t\t\t}\n\t\t\t/*\n\t\t\t\tWe disallow unsigned sample data for\n\t\t\t\tAIFF files in _af_aiff_complete_setup,\n\t\t\t\tso the next condition should never be\n\t\t\t\tsatisfied.\n\t\t\t*/\n\t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_UNSIGNED)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\t\"AIFF/AIFF-C format does not support unsigned data\");\n\t\t\t\tassert(0);\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\t\t}\n\t\telse if (track->f.compressionType == AF_COMPRESSION_G711_ULAW)\n\t\t{\n\t\t\tcompressionTag = \"ulaw\";\n\t\t\tstrcpy(compressionName, \"CCITT G.711 u-law\");\n\t\t}\n\t\telse if (track->f.compressionType == AF_COMPRESSION_G711_ALAW)\n\t\t{\n\t\t\tcompressionTag = \"alaw\";\n\t\t\tstrcpy(compressionName, \"CCITT G.711 A-law\");\n\t\t}\n\t\telse if (track->f.compressionType == AF_COMPRESSION_IMA)\n\t\t{\n\t\t\tcompressionTag = \"ima4\";\n\t\t\tstrcpy(compressionName, \"IMA 4:1 compression\");\n\t\t}\n\t}\n\n\tm_fh->write(\"COMM\", 4);\n\n\t/*\n\t\tFor AIFF-C files, the length of the COMM chunk is 22\n\t\tplus the length of the compression name plus the size\n\t\tbyte.  If the length of the data is an odd number of\n\t\tbytes, add a zero pad byte at the end, but don't\n\t\tinclude the pad byte in the chunk's size.\n\t*/\n\tuint32_t chunkSize;\n\tif (isAIFFC())\n\t\tchunkSize = 22 + strlen(compressionName) + 1;\n\telse\n\t\tchunkSize = 18;\n\twriteU32(&chunkSize);\n\n\t/* number of channels, 2 bytes */\n\tuint16_t channelCount = track->f.channelCount;\n\twriteU16(&channelCount);\n\n\t/* number of sample frames, 4 bytes */\n\tuint32_t frameCount = track->totalfframes;\n\tif (track->f.compressionType == AF_COMPRESSION_IMA)\n\t\tframeCount = track->totalfframes / track->f.framesPerPacket;\n\twriteU32(&frameCount);\n\n\t/* sample size, 2 bytes */\n\tuint16_t sampleSize = track->f.sampleWidth;\n\twriteU16(&sampleSize);\n\n\t/* sample rate, 10 bytes */\n\tuint8_t sampleRate[10];\n\t_af_convert_to_ieee_extended(track->f.sampleRate, sampleRate);\n\tm_fh->write(sampleRate, 10);\n\n\tif (isAIFFC())\n\t{\n\t\twriteTag(&compressionTag);\n\t\twritePString(compressionName);\n\t}\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writePString",
          "args": [
            "compressionName"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "writePString",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "1199-1220",
          "snippet": "bool AIFFFile::writePString(const char *s)\n{\n\tsize_t length = strlen(s);\n\tif (length > 255)\n\t\treturn false;\n\tuint8_t sizeByte = static_cast<uint8_t>(length);\n\tif (m_fh->write(&sizeByte, 1) != 1)\n\t\treturn false;\n\tif (m_fh->write(s, length) != (ssize_t) length)\n\t\treturn false;\n\t/*\n\t\tAdd a pad byte if the length of the Pascal-style string\n\t\t(including the size byte) is odd.\n\t*/\n\tif ((length % 2) == 0)\n\t{\n\t\tuint8_t zero = 0;\n\t\tif (m_fh->write(&zero, 1) != 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  bool AIFFFile::writePString(const char *s)\n  {\n  \tsize_t length = strlen(s);\n  \tif (length > 255)\n  \t\treturn false;\n  \tuint8_t sizeByte = static_cast<uint8_t>(length);\n  \tif (m_fh->write(&sizeByte, 1) != 1)\n  \t\treturn false;\n  \tif (m_fh->write(s, length) != (ssize_t) length)\n  \t\treturn false;\n  \t/*\n  \t\tAdd a pad byte if the length of the Pascal-style string\n  \t\t(including the size byte) is odd.\n  \t*/\n  \tif ((length % 2) == 0)\n  \t{\n  \t\tuint8_t zero = 0;\n  \t\tif (m_fh->write(&zero, 1) != 1)\n  \t\t\treturn false;\n  \t}\n  \treturn true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeTag",
          "args": [
            "&compressionTag"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "writeTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "484-488",
          "snippet": "bool _AFfilehandle::writeTag(const Tag *t)\n{\n\tuint32_t v = t->value();\n\treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeTag(const Tag *t)\n  {\n  \tuint32_t v = t->value();\n  \treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isAIFFC",
          "args": [],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "isAIFFC",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.h",
          "lines": "86-86",
          "snippet": "bool isAIFFC() const { return m_fileFormat == AF_FILE_AIFFC; }",
          "includes": [
            "#include \"FileHandle.h\"",
            "#include \"Compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FileHandle.h\"\n#include \"Compiler.h\"\n\nAIFFFile {\n  bool isAIFFC() const { return m_fileFormat == AF_FILE_AIFFC; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "sampleRate",
            "10"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_convert_to_ieee_extended",
          "args": [
            "track->f.sampleRate",
            "sampleRate"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeU16",
          "args": [
            "&sampleSize"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "writeU16",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "433-436",
          "snippet": "bool _AFfilehandle::writeU16(const uint16_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU16(const uint16_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&frameCount"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "compressionName"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "compressionName",
            "\"IMA 4:1 compression\""
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "compressionName",
            "\"CCITT G.711 A-law\""
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "compressionName",
            "\"CCITT G.711 u-law\""
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_SAMPFMT",
            "\"AIFF/AIFF-C format does not support unsigned data\""
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "compressionName",
            "\"64-bit Floating Point\""
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "compressionName",
            "\"32-bit Floating Point\""
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "compressionName",
            "\"not compressed\""
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "m_COMM_offset",
            "File::SeekFromBeginning"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeCOMM()\n  {\n  \t/*\n  \t\tIf COMM_offset hasn't been set yet, set it to the\n  \t\tcurrent offset.\n  \t*/\n  \tif (m_COMM_offset == 0)\n  \t\tm_COMM_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_COMM_offset, File::SeekFromBeginning);\n  \n  \tTrack *track = getTrack();\n  \n  \tTag compressionTag;\n  \t/* Pascal strings can occupy only 255 bytes (+ a size byte). */\n  \tchar compressionName[256];\n  \n  \tif (isAIFFC())\n  \t{\n  \t\tif (track->f.compressionType == AF_COMPRESSION_NONE)\n  \t\t{\n  \t\t\tif (track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP)\n  \t\t\t{\n  \t\t\t\tcompressionTag = \"NONE\";\n  \t\t\t\tstrcpy(compressionName, \"not compressed\");\n  \t\t\t}\n  \t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_FLOAT)\n  \t\t\t{\n  \t\t\t\tcompressionTag = \"fl32\";\n  \t\t\t\tstrcpy(compressionName, \"32-bit Floating Point\");\n  \t\t\t}\n  \t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_DOUBLE)\n  \t\t\t{\n  \t\t\t\tcompressionTag = \"fl64\";\n  \t\t\t\tstrcpy(compressionName, \"64-bit Floating Point\");\n  \t\t\t}\n  \t\t\t/*\n  \t\t\t\tWe disallow unsigned sample data for\n  \t\t\t\tAIFF files in _af_aiff_complete_setup,\n  \t\t\t\tso the next condition should never be\n  \t\t\t\tsatisfied.\n  \t\t\t*/\n  \t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_UNSIGNED)\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_SAMPFMT,\n  \t\t\t\t\t\"AIFF/AIFF-C format does not support unsigned data\");\n  \t\t\t\tassert(0);\n  \t\t\t\treturn AF_FAIL;\n  \t\t\t}\n  \t\t}\n  \t\telse if (track->f.compressionType == AF_COMPRESSION_G711_ULAW)\n  \t\t{\n  \t\t\tcompressionTag = \"ulaw\";\n  \t\t\tstrcpy(compressionName, \"CCITT G.711 u-law\");\n  \t\t}\n  \t\telse if (track->f.compressionType == AF_COMPRESSION_G711_ALAW)\n  \t\t{\n  \t\t\tcompressionTag = \"alaw\";\n  \t\t\tstrcpy(compressionName, \"CCITT G.711 A-law\");\n  \t\t}\n  \t\telse if (track->f.compressionType == AF_COMPRESSION_IMA)\n  \t\t{\n  \t\t\tcompressionTag = \"ima4\";\n  \t\t\tstrcpy(compressionName, \"IMA 4:1 compression\");\n  \t\t}\n  \t}\n  \n  \tm_fh->write(\"COMM\", 4);\n  \n  \t/*\n  \t\tFor AIFF-C files, the length of the COMM chunk is 22\n  \t\tplus the length of the compression name plus the size\n  \t\tbyte.  If the length of the data is an odd number of\n  \t\tbytes, add a zero pad byte at the end, but don't\n  \t\tinclude the pad byte in the chunk's size.\n  \t*/\n  \tuint32_t chunkSize;\n  \tif (isAIFFC())\n  \t\tchunkSize = 22 + strlen(compressionName) + 1;\n  \telse\n  \t\tchunkSize = 18;\n  \twriteU32(&chunkSize);\n  \n  \t/* number of channels, 2 bytes */\n  \tuint16_t channelCount = track->f.channelCount;\n  \twriteU16(&channelCount);\n  \n  \t/* number of sample frames, 4 bytes */\n  \tuint32_t frameCount = track->totalfframes;\n  \tif (track->f.compressionType == AF_COMPRESSION_IMA)\n  \t\tframeCount = track->totalfframes / track->f.framesPerPacket;\n  \twriteU32(&frameCount);\n  \n  \t/* sample size, 2 bytes */\n  \tuint16_t sampleSize = track->f.sampleWidth;\n  \twriteU16(&sampleSize);\n  \n  \t/* sample rate, 10 bytes */\n  \tuint8_t sampleRate[10];\n  \t_af_convert_to_ieee_extended(track->f.sampleRate, sampleRate);\n  \tm_fh->write(sampleRate, 10);\n  \n  \tif (isAIFFC())\n  \t{\n  \t\twriteTag(&compressionTag);\n  \t\twritePString(compressionName);\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "update",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "789-810",
    "snippet": "status AIFFFile::update()\n{\n\t/* Get the length of the file. */\n\tuint32_t length = m_fh->length();\n\tlength -= 8;\n\n\t/* Set the length of the FORM chunk. */\n\tm_fh->seek(4, File::SeekFromBeginning);\n\twriteU32(&length);\n\n\tif (isAIFFC())\n\t\twriteFVER();\n\n\twriteCOMM();\n\twriteMARK();\n\twriteINST();\n\twriteAESD();\n\twriteMiscellaneous();\n\twriteSSND();\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeSSND",
          "args": [],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "writeSSND",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "952-976",
          "snippet": "status AIFFFile::writeSSND()\n{\n\tTrack *track = getTrack();\n\n\tif (m_SSND_offset == 0)\n\t\tm_SSND_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_SSND_offset, File::SeekFromBeginning);\n\n\tm_fh->write(\"SSND\", 4);\n\n\tuint32_t chunkSize = track->data_size + 8;\n\twriteU32(&chunkSize);\n\n\tuint32_t zero = 0;\n\t/* data offset */\n\twriteU32(&zero);\n\t/* block size */\n\twriteU32(&zero);\n\n\tif (track->fpos_first_frame == 0)\n\t\ttrack->fpos_first_frame = m_fh->tell();\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeSSND()\n  {\n  \tTrack *track = getTrack();\n  \n  \tif (m_SSND_offset == 0)\n  \t\tm_SSND_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_SSND_offset, File::SeekFromBeginning);\n  \n  \tm_fh->write(\"SSND\", 4);\n  \n  \tuint32_t chunkSize = track->data_size + 8;\n  \twriteU32(&chunkSize);\n  \n  \tuint32_t zero = 0;\n  \t/* data offset */\n  \twriteU32(&zero);\n  \t/* block size */\n  \twriteU32(&zero);\n  \n  \tif (track->fpos_first_frame == 0)\n  \t\ttrack->fpos_first_frame = m_fh->tell();\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeMiscellaneous",
          "args": [],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "writeMiscellaneous",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "1112-1161",
          "snippet": "status AIFFFile::writeMiscellaneous()\n{\n\tif (m_miscellaneousPosition == 0)\n\t\tm_miscellaneousPosition = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_miscellaneousPosition, File::SeekFromBeginning);\n\n\tfor (int i=0; i<m_miscellaneousCount; i++)\n\t{\n\t\tMiscellaneous *misc = &m_miscellaneous[i];\n\t\tTag chunkType;\n\t\tuint32_t chunkSize;\n\t\tuint8_t padByte = 0;\n\n\t\tswitch (misc->type)\n\t\t{\n\t\t\tcase AF_MISC_NAME:\n\t\t\t\tchunkType = \"NAME\"; break;\n\t\t\tcase AF_MISC_AUTH:\n\t\t\t\tchunkType = \"AUTH\"; break;\n\t\t\tcase AF_MISC_COPY:\n\t\t\t\tchunkType = \"(c) \"; break;\n\t\t\tcase AF_MISC_ANNO:\n\t\t\t\tchunkType = \"ANNO\"; break;\n\t\t\tcase AF_MISC_MIDI:\n\t\t\t\tchunkType = \"MIDI\"; break;\n\t\t\tcase AF_MISC_APPL:\n\t\t\t\tchunkType = \"APPL\"; break;\n\t\t}\n\n\t\twriteTag(&chunkType);\n\n\t\tchunkSize = misc->size;\n\t\twriteU32(&chunkSize);\n\t\t/*\n\t\t\tWrite the miscellaneous buffer and then a pad byte\n\t\t\tif necessary.  If the buffer is null, skip the space\n\t\t\tfor now.\n\t\t*/\n\t\tif (misc->buffer != NULL)\n\t\t\tm_fh->write(misc->buffer, misc->size);\n\t\telse\n\t\t\tm_fh->seek(misc->size, File::SeekFromCurrent);\n\n\t\tif (misc->size % 2 != 0)\n\t\t\twriteU8(&padByte);\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeMiscellaneous()\n  {\n  \tif (m_miscellaneousPosition == 0)\n  \t\tm_miscellaneousPosition = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_miscellaneousPosition, File::SeekFromBeginning);\n  \n  \tfor (int i=0; i<m_miscellaneousCount; i++)\n  \t{\n  \t\tMiscellaneous *misc = &m_miscellaneous[i];\n  \t\tTag chunkType;\n  \t\tuint32_t chunkSize;\n  \t\tuint8_t padByte = 0;\n  \n  \t\tswitch (misc->type)\n  \t\t{\n  \t\t\tcase AF_MISC_NAME:\n  \t\t\t\tchunkType = \"NAME\"; break;\n  \t\t\tcase AF_MISC_AUTH:\n  \t\t\t\tchunkType = \"AUTH\"; break;\n  \t\t\tcase AF_MISC_COPY:\n  \t\t\t\tchunkType = \"(c) \"; break;\n  \t\t\tcase AF_MISC_ANNO:\n  \t\t\t\tchunkType = \"ANNO\"; break;\n  \t\t\tcase AF_MISC_MIDI:\n  \t\t\t\tchunkType = \"MIDI\"; break;\n  \t\t\tcase AF_MISC_APPL:\n  \t\t\t\tchunkType = \"APPL\"; break;\n  \t\t}\n  \n  \t\twriteTag(&chunkType);\n  \n  \t\tchunkSize = misc->size;\n  \t\twriteU32(&chunkSize);\n  \t\t/*\n  \t\t\tWrite the miscellaneous buffer and then a pad byte\n  \t\t\tif necessary.  If the buffer is null, skip the space\n  \t\t\tfor now.\n  \t\t*/\n  \t\tif (misc->buffer != NULL)\n  \t\t\tm_fh->write(misc->buffer, misc->size);\n  \t\telse\n  \t\t\tm_fh->seek(misc->size, File::SeekFromCurrent);\n  \n  \t\tif (misc->size % 2 != 0)\n  \t\t\twriteU8(&padByte);\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeAESD",
          "args": [],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "writeAESD",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "927-950",
          "snippet": "status AIFFFile::writeAESD()\n{\n\tTrack *track = getTrack();\n\n\tif (!track->hasAESData)\n\t\treturn AF_SUCCEED;\n\n\tif (m_AESD_offset == 0)\n\t\tm_AESD_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_AESD_offset, File::SeekFromBeginning);\n\n\tif (m_fh->write(\"AESD\", 4) < 4)\n\t\treturn AF_FAIL;\n\n\tuint32_t size = 24;\n\tif (!writeU32(&size))\n\t\treturn AF_FAIL;\n\n\tif (m_fh->write(track->aesData, 24) < 24)\n\t\treturn AF_FAIL;\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeAESD()\n  {\n  \tTrack *track = getTrack();\n  \n  \tif (!track->hasAESData)\n  \t\treturn AF_SUCCEED;\n  \n  \tif (m_AESD_offset == 0)\n  \t\tm_AESD_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_AESD_offset, File::SeekFromBeginning);\n  \n  \tif (m_fh->write(\"AESD\", 4) < 4)\n  \t\treturn AF_FAIL;\n  \n  \tuint32_t size = 24;\n  \tif (!writeU32(&size))\n  \t\treturn AF_FAIL;\n  \n  \tif (m_fh->write(track->aesData, 24) < 24)\n  \t\treturn AF_FAIL;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeINST",
          "args": [],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "writeINST",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "978-1033",
          "snippet": "status AIFFFile::writeINST()\n{\n\tuint32_t length = 20;\n\n\tstruct _INST instrumentdata;\n\n\tinstrumentdata.sustainLoopPlayMode =\n\t\tafGetLoopMode(this, AF_DEFAULT_INST, 1);\n\tinstrumentdata.sustainLoopBegin =\n\t\tafGetLoopStart(this, AF_DEFAULT_INST, 1);\n\tinstrumentdata.sustainLoopEnd =\n\t\tafGetLoopEnd(this, AF_DEFAULT_INST, 1);\n\n\tinstrumentdata.releaseLoopPlayMode =\n\t\tafGetLoopMode(this, AF_DEFAULT_INST, 2);\n\tinstrumentdata.releaseLoopBegin =\n\t\tafGetLoopStart(this, AF_DEFAULT_INST, 2);\n\tinstrumentdata.releaseLoopEnd =\n\t\tafGetLoopEnd(this, AF_DEFAULT_INST, 2);\n\n\tm_fh->write(\"INST\", 4);\n\twriteU32(&length);\n\n\tinstrumentdata.baseNote =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_BASENOTE);\n\twriteU8(&instrumentdata.baseNote);\n\tinstrumentdata.detune =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_NUMCENTS_DETUNE);\n\twriteS8(&instrumentdata.detune);\n\tinstrumentdata.lowNote =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_LONOTE);\n\twriteU8(&instrumentdata.lowNote);\n\tinstrumentdata.highNote =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_HINOTE);\n\twriteU8(&instrumentdata.highNote);\n\tinstrumentdata.lowVelocity =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_LOVELOCITY);\n\twriteU8(&instrumentdata.lowVelocity);\n\tinstrumentdata.highVelocity =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_HIVELOCITY);\n\twriteU8(&instrumentdata.highVelocity);\n\n\tinstrumentdata.gain =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_NUMDBS_GAIN);\n\twriteS16(&instrumentdata.gain);\n\n\twriteU16(&instrumentdata.sustainLoopPlayMode);\n\twriteU16(&instrumentdata.sustainLoopBegin);\n\twriteU16(&instrumentdata.sustainLoopEnd);\n\n\twriteU16(&instrumentdata.releaseLoopPlayMode);\n\twriteU16(&instrumentdata.releaseLoopBegin);\n\twriteU16(&instrumentdata.releaseLoopEnd);\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeINST()\n  {\n  \tuint32_t length = 20;\n  \n  \tstruct _INST instrumentdata;\n  \n  \tinstrumentdata.sustainLoopPlayMode =\n  \t\tafGetLoopMode(this, AF_DEFAULT_INST, 1);\n  \tinstrumentdata.sustainLoopBegin =\n  \t\tafGetLoopStart(this, AF_DEFAULT_INST, 1);\n  \tinstrumentdata.sustainLoopEnd =\n  \t\tafGetLoopEnd(this, AF_DEFAULT_INST, 1);\n  \n  \tinstrumentdata.releaseLoopPlayMode =\n  \t\tafGetLoopMode(this, AF_DEFAULT_INST, 2);\n  \tinstrumentdata.releaseLoopBegin =\n  \t\tafGetLoopStart(this, AF_DEFAULT_INST, 2);\n  \tinstrumentdata.releaseLoopEnd =\n  \t\tafGetLoopEnd(this, AF_DEFAULT_INST, 2);\n  \n  \tm_fh->write(\"INST\", 4);\n  \twriteU32(&length);\n  \n  \tinstrumentdata.baseNote =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_BASENOTE);\n  \twriteU8(&instrumentdata.baseNote);\n  \tinstrumentdata.detune =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_NUMCENTS_DETUNE);\n  \twriteS8(&instrumentdata.detune);\n  \tinstrumentdata.lowNote =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_LONOTE);\n  \twriteU8(&instrumentdata.lowNote);\n  \tinstrumentdata.highNote =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_HINOTE);\n  \twriteU8(&instrumentdata.highNote);\n  \tinstrumentdata.lowVelocity =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_LOVELOCITY);\n  \twriteU8(&instrumentdata.lowVelocity);\n  \tinstrumentdata.highVelocity =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_HIVELOCITY);\n  \twriteU8(&instrumentdata.highVelocity);\n  \n  \tinstrumentdata.gain =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_NUMDBS_GAIN);\n  \twriteS16(&instrumentdata.gain);\n  \n  \twriteU16(&instrumentdata.sustainLoopPlayMode);\n  \twriteU16(&instrumentdata.sustainLoopBegin);\n  \twriteU16(&instrumentdata.sustainLoopEnd);\n  \n  \twriteU16(&instrumentdata.releaseLoopPlayMode);\n  \twriteU16(&instrumentdata.releaseLoopBegin);\n  \twriteU16(&instrumentdata.releaseLoopEnd);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeMARK",
          "args": [],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "writeMARK",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "1035-1081",
          "snippet": "status AIFFFile::writeMARK()\n{\n\tTrack *track = getTrack();\n\tif (!track->markerCount)\n\t\treturn AF_SUCCEED;\n\n\tif (m_MARK_offset == 0)\n\t\tm_MARK_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_MARK_offset, File::SeekFromBeginning);\n\n\tTag markTag(\"MARK\");\n\tuint32_t length = 0;\n\n\twriteTag(&markTag);\n\twriteU32(&length);\n\n\tAFfileoffset chunkStartPosition = m_fh->tell();\n\n\tuint16_t numMarkers = track->markerCount;\n\twriteU16(&numMarkers);\n\n\tfor (unsigned i=0; i<numMarkers; i++)\n\t{\n\t\tuint16_t id = track->markers[i].id;\n\t\twriteU16(&id);\n\n\t\tuint32_t position = track->markers[i].position;\n\t\twriteU32(&position);\n\n\t\tconst char *name = track->markers[i].name;\n\t\tassert(name);\n\n\t\t// Write the name as a Pascal-style string.\n\t\twritePString(name);\n\t}\n\n\tAFfileoffset chunkEndPosition = m_fh->tell();\n\tlength = chunkEndPosition - chunkStartPosition;\n\n\tm_fh->seek(chunkStartPosition - 4, File::SeekFromBeginning);\n\n\twriteU32(&length);\n\tm_fh->seek(chunkEndPosition, File::SeekFromBeginning);\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeMARK()\n  {\n  \tTrack *track = getTrack();\n  \tif (!track->markerCount)\n  \t\treturn AF_SUCCEED;\n  \n  \tif (m_MARK_offset == 0)\n  \t\tm_MARK_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_MARK_offset, File::SeekFromBeginning);\n  \n  \tTag markTag(\"MARK\");\n  \tuint32_t length = 0;\n  \n  \twriteTag(&markTag);\n  \twriteU32(&length);\n  \n  \tAFfileoffset chunkStartPosition = m_fh->tell();\n  \n  \tuint16_t numMarkers = track->markerCount;\n  \twriteU16(&numMarkers);\n  \n  \tfor (unsigned i=0; i<numMarkers; i++)\n  \t{\n  \t\tuint16_t id = track->markers[i].id;\n  \t\twriteU16(&id);\n  \n  \t\tuint32_t position = track->markers[i].position;\n  \t\twriteU32(&position);\n  \n  \t\tconst char *name = track->markers[i].name;\n  \t\tassert(name);\n  \n  \t\t// Write the name as a Pascal-style string.\n  \t\twritePString(name);\n  \t}\n  \n  \tAFfileoffset chunkEndPosition = m_fh->tell();\n  \tlength = chunkEndPosition - chunkStartPosition;\n  \n  \tm_fh->seek(chunkStartPosition - 4, File::SeekFromBeginning);\n  \n  \twriteU32(&length);\n  \tm_fh->seek(chunkEndPosition, File::SeekFromBeginning);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeCOMM",
          "args": [],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "writeCOMM",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "812-921",
          "snippet": "status AIFFFile::writeCOMM()\n{\n\t/*\n\t\tIf COMM_offset hasn't been set yet, set it to the\n\t\tcurrent offset.\n\t*/\n\tif (m_COMM_offset == 0)\n\t\tm_COMM_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_COMM_offset, File::SeekFromBeginning);\n\n\tTrack *track = getTrack();\n\n\tTag compressionTag;\n\t/* Pascal strings can occupy only 255 bytes (+ a size byte). */\n\tchar compressionName[256];\n\n\tif (isAIFFC())\n\t{\n\t\tif (track->f.compressionType == AF_COMPRESSION_NONE)\n\t\t{\n\t\t\tif (track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t{\n\t\t\t\tcompressionTag = \"NONE\";\n\t\t\t\tstrcpy(compressionName, \"not compressed\");\n\t\t\t}\n\t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_FLOAT)\n\t\t\t{\n\t\t\t\tcompressionTag = \"fl32\";\n\t\t\t\tstrcpy(compressionName, \"32-bit Floating Point\");\n\t\t\t}\n\t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_DOUBLE)\n\t\t\t{\n\t\t\t\tcompressionTag = \"fl64\";\n\t\t\t\tstrcpy(compressionName, \"64-bit Floating Point\");\n\t\t\t}\n\t\t\t/*\n\t\t\t\tWe disallow unsigned sample data for\n\t\t\t\tAIFF files in _af_aiff_complete_setup,\n\t\t\t\tso the next condition should never be\n\t\t\t\tsatisfied.\n\t\t\t*/\n\t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_UNSIGNED)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\t\"AIFF/AIFF-C format does not support unsigned data\");\n\t\t\t\tassert(0);\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\t\t}\n\t\telse if (track->f.compressionType == AF_COMPRESSION_G711_ULAW)\n\t\t{\n\t\t\tcompressionTag = \"ulaw\";\n\t\t\tstrcpy(compressionName, \"CCITT G.711 u-law\");\n\t\t}\n\t\telse if (track->f.compressionType == AF_COMPRESSION_G711_ALAW)\n\t\t{\n\t\t\tcompressionTag = \"alaw\";\n\t\t\tstrcpy(compressionName, \"CCITT G.711 A-law\");\n\t\t}\n\t\telse if (track->f.compressionType == AF_COMPRESSION_IMA)\n\t\t{\n\t\t\tcompressionTag = \"ima4\";\n\t\t\tstrcpy(compressionName, \"IMA 4:1 compression\");\n\t\t}\n\t}\n\n\tm_fh->write(\"COMM\", 4);\n\n\t/*\n\t\tFor AIFF-C files, the length of the COMM chunk is 22\n\t\tplus the length of the compression name plus the size\n\t\tbyte.  If the length of the data is an odd number of\n\t\tbytes, add a zero pad byte at the end, but don't\n\t\tinclude the pad byte in the chunk's size.\n\t*/\n\tuint32_t chunkSize;\n\tif (isAIFFC())\n\t\tchunkSize = 22 + strlen(compressionName) + 1;\n\telse\n\t\tchunkSize = 18;\n\twriteU32(&chunkSize);\n\n\t/* number of channels, 2 bytes */\n\tuint16_t channelCount = track->f.channelCount;\n\twriteU16(&channelCount);\n\n\t/* number of sample frames, 4 bytes */\n\tuint32_t frameCount = track->totalfframes;\n\tif (track->f.compressionType == AF_COMPRESSION_IMA)\n\t\tframeCount = track->totalfframes / track->f.framesPerPacket;\n\twriteU32(&frameCount);\n\n\t/* sample size, 2 bytes */\n\tuint16_t sampleSize = track->f.sampleWidth;\n\twriteU16(&sampleSize);\n\n\t/* sample rate, 10 bytes */\n\tuint8_t sampleRate[10];\n\t_af_convert_to_ieee_extended(track->f.sampleRate, sampleRate);\n\tm_fh->write(sampleRate, 10);\n\n\tif (isAIFFC())\n\t{\n\t\twriteTag(&compressionTag);\n\t\twritePString(compressionName);\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeCOMM()\n  {\n  \t/*\n  \t\tIf COMM_offset hasn't been set yet, set it to the\n  \t\tcurrent offset.\n  \t*/\n  \tif (m_COMM_offset == 0)\n  \t\tm_COMM_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_COMM_offset, File::SeekFromBeginning);\n  \n  \tTrack *track = getTrack();\n  \n  \tTag compressionTag;\n  \t/* Pascal strings can occupy only 255 bytes (+ a size byte). */\n  \tchar compressionName[256];\n  \n  \tif (isAIFFC())\n  \t{\n  \t\tif (track->f.compressionType == AF_COMPRESSION_NONE)\n  \t\t{\n  \t\t\tif (track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP)\n  \t\t\t{\n  \t\t\t\tcompressionTag = \"NONE\";\n  \t\t\t\tstrcpy(compressionName, \"not compressed\");\n  \t\t\t}\n  \t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_FLOAT)\n  \t\t\t{\n  \t\t\t\tcompressionTag = \"fl32\";\n  \t\t\t\tstrcpy(compressionName, \"32-bit Floating Point\");\n  \t\t\t}\n  \t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_DOUBLE)\n  \t\t\t{\n  \t\t\t\tcompressionTag = \"fl64\";\n  \t\t\t\tstrcpy(compressionName, \"64-bit Floating Point\");\n  \t\t\t}\n  \t\t\t/*\n  \t\t\t\tWe disallow unsigned sample data for\n  \t\t\t\tAIFF files in _af_aiff_complete_setup,\n  \t\t\t\tso the next condition should never be\n  \t\t\t\tsatisfied.\n  \t\t\t*/\n  \t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_UNSIGNED)\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_SAMPFMT,\n  \t\t\t\t\t\"AIFF/AIFF-C format does not support unsigned data\");\n  \t\t\t\tassert(0);\n  \t\t\t\treturn AF_FAIL;\n  \t\t\t}\n  \t\t}\n  \t\telse if (track->f.compressionType == AF_COMPRESSION_G711_ULAW)\n  \t\t{\n  \t\t\tcompressionTag = \"ulaw\";\n  \t\t\tstrcpy(compressionName, \"CCITT G.711 u-law\");\n  \t\t}\n  \t\telse if (track->f.compressionType == AF_COMPRESSION_G711_ALAW)\n  \t\t{\n  \t\t\tcompressionTag = \"alaw\";\n  \t\t\tstrcpy(compressionName, \"CCITT G.711 A-law\");\n  \t\t}\n  \t\telse if (track->f.compressionType == AF_COMPRESSION_IMA)\n  \t\t{\n  \t\t\tcompressionTag = \"ima4\";\n  \t\t\tstrcpy(compressionName, \"IMA 4:1 compression\");\n  \t\t}\n  \t}\n  \n  \tm_fh->write(\"COMM\", 4);\n  \n  \t/*\n  \t\tFor AIFF-C files, the length of the COMM chunk is 22\n  \t\tplus the length of the compression name plus the size\n  \t\tbyte.  If the length of the data is an odd number of\n  \t\tbytes, add a zero pad byte at the end, but don't\n  \t\tinclude the pad byte in the chunk's size.\n  \t*/\n  \tuint32_t chunkSize;\n  \tif (isAIFFC())\n  \t\tchunkSize = 22 + strlen(compressionName) + 1;\n  \telse\n  \t\tchunkSize = 18;\n  \twriteU32(&chunkSize);\n  \n  \t/* number of channels, 2 bytes */\n  \tuint16_t channelCount = track->f.channelCount;\n  \twriteU16(&channelCount);\n  \n  \t/* number of sample frames, 4 bytes */\n  \tuint32_t frameCount = track->totalfframes;\n  \tif (track->f.compressionType == AF_COMPRESSION_IMA)\n  \t\tframeCount = track->totalfframes / track->f.framesPerPacket;\n  \twriteU32(&frameCount);\n  \n  \t/* sample size, 2 bytes */\n  \tuint16_t sampleSize = track->f.sampleWidth;\n  \twriteU16(&sampleSize);\n  \n  \t/* sample rate, 10 bytes */\n  \tuint8_t sampleRate[10];\n  \t_af_convert_to_ieee_extended(track->f.sampleRate, sampleRate);\n  \tm_fh->write(sampleRate, 10);\n  \n  \tif (isAIFFC())\n  \t{\n  \t\twriteTag(&compressionTag);\n  \t\twritePString(compressionName);\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeFVER",
          "args": [],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "writeFVER",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "1086-1106",
          "snippet": "status AIFFFile::writeFVER()\n{\n\tuint32_t chunkSize, timeStamp;\n\n\tassert(isAIFFC());\n\n\tif (m_FVER_offset == 0)\n\t\tm_FVER_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_FVER_offset, File::SeekFromBeginning);\n\n\tm_fh->write(\"FVER\", 4);\n\n\tchunkSize = 4;\n\twriteU32(&chunkSize);\n\n\ttimeStamp = AIFC_VERSION_1;\n\twriteU32(&timeStamp);\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define AIFC_VERSION_1 0xa2805140"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\n#define AIFC_VERSION_1 0xa2805140\n\nAIFFFile {\n  status AIFFFile::writeFVER()\n  {\n  \tuint32_t chunkSize, timeStamp;\n  \n  \tassert(isAIFFC());\n  \n  \tif (m_FVER_offset == 0)\n  \t\tm_FVER_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_FVER_offset, File::SeekFromBeginning);\n  \n  \tm_fh->write(\"FVER\", 4);\n  \n  \tchunkSize = 4;\n  \twriteU32(&chunkSize);\n  \n  \ttimeStamp = AIFC_VERSION_1;\n  \twriteU32(&timeStamp);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isAIFFC",
          "args": [],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "isAIFFC",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.h",
          "lines": "86-86",
          "snippet": "bool isAIFFC() const { return m_fileFormat == AF_FILE_AIFFC; }",
          "includes": [
            "#include \"FileHandle.h\"",
            "#include \"Compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FileHandle.h\"\n#include \"Compiler.h\"\n\nAIFFFile {\n  bool isAIFFC() const { return m_fileFormat == AF_FILE_AIFFC; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&length"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "4",
            "File::SeekFromBeginning"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->length",
          "args": [],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "182-185",
          "snippet": "off_t FileVF::length()\n{\n\treturn m_vf->length(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::length()\n  {\n  \treturn m_vf->length(m_vf);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::update()\n  {\n  \t/* Get the length of the file. */\n  \tuint32_t length = m_fh->length();\n  \tlength -= 8;\n  \n  \t/* Set the length of the FORM chunk. */\n  \tm_fh->seek(4, File::SeekFromBeginning);\n  \twriteU32(&length);\n  \n  \tif (isAIFFC())\n  \t\twriteFVER();\n  \n  \twriteCOMM();\n  \twriteMARK();\n  \twriteINST();\n  \twriteAESD();\n  \twriteMiscellaneous();\n  \twriteSSND();\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeInit",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "760-787",
    "snippet": "status AIFFFile::writeInit(AFfilesetup setup)\n{\n\tif (initFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\n\tinitCompressionParams();\n\n\tuint32_t fileSize = 0;\n\tm_fh->write(\"FORM\", 4);\n\twriteU32(&fileSize);\n\n\tif (isAIFFC())\n\t\tm_fh->write(\"AIFC\", 4);\n\telse\n\t\tm_fh->write(\"AIFF\", 4);\n\n\tif (isAIFFC())\n\t\twriteFVER();\n\n\twriteCOMM();\n\twriteMARK();\n\twriteINST();\n\twriteAESD();\n\twriteMiscellaneous();\n\twriteSSND();\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeSSND",
          "args": [],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "writeSSND",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "952-976",
          "snippet": "status AIFFFile::writeSSND()\n{\n\tTrack *track = getTrack();\n\n\tif (m_SSND_offset == 0)\n\t\tm_SSND_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_SSND_offset, File::SeekFromBeginning);\n\n\tm_fh->write(\"SSND\", 4);\n\n\tuint32_t chunkSize = track->data_size + 8;\n\twriteU32(&chunkSize);\n\n\tuint32_t zero = 0;\n\t/* data offset */\n\twriteU32(&zero);\n\t/* block size */\n\twriteU32(&zero);\n\n\tif (track->fpos_first_frame == 0)\n\t\ttrack->fpos_first_frame = m_fh->tell();\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeSSND()\n  {\n  \tTrack *track = getTrack();\n  \n  \tif (m_SSND_offset == 0)\n  \t\tm_SSND_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_SSND_offset, File::SeekFromBeginning);\n  \n  \tm_fh->write(\"SSND\", 4);\n  \n  \tuint32_t chunkSize = track->data_size + 8;\n  \twriteU32(&chunkSize);\n  \n  \tuint32_t zero = 0;\n  \t/* data offset */\n  \twriteU32(&zero);\n  \t/* block size */\n  \twriteU32(&zero);\n  \n  \tif (track->fpos_first_frame == 0)\n  \t\ttrack->fpos_first_frame = m_fh->tell();\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeMiscellaneous",
          "args": [],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "writeMiscellaneous",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "1112-1161",
          "snippet": "status AIFFFile::writeMiscellaneous()\n{\n\tif (m_miscellaneousPosition == 0)\n\t\tm_miscellaneousPosition = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_miscellaneousPosition, File::SeekFromBeginning);\n\n\tfor (int i=0; i<m_miscellaneousCount; i++)\n\t{\n\t\tMiscellaneous *misc = &m_miscellaneous[i];\n\t\tTag chunkType;\n\t\tuint32_t chunkSize;\n\t\tuint8_t padByte = 0;\n\n\t\tswitch (misc->type)\n\t\t{\n\t\t\tcase AF_MISC_NAME:\n\t\t\t\tchunkType = \"NAME\"; break;\n\t\t\tcase AF_MISC_AUTH:\n\t\t\t\tchunkType = \"AUTH\"; break;\n\t\t\tcase AF_MISC_COPY:\n\t\t\t\tchunkType = \"(c) \"; break;\n\t\t\tcase AF_MISC_ANNO:\n\t\t\t\tchunkType = \"ANNO\"; break;\n\t\t\tcase AF_MISC_MIDI:\n\t\t\t\tchunkType = \"MIDI\"; break;\n\t\t\tcase AF_MISC_APPL:\n\t\t\t\tchunkType = \"APPL\"; break;\n\t\t}\n\n\t\twriteTag(&chunkType);\n\n\t\tchunkSize = misc->size;\n\t\twriteU32(&chunkSize);\n\t\t/*\n\t\t\tWrite the miscellaneous buffer and then a pad byte\n\t\t\tif necessary.  If the buffer is null, skip the space\n\t\t\tfor now.\n\t\t*/\n\t\tif (misc->buffer != NULL)\n\t\t\tm_fh->write(misc->buffer, misc->size);\n\t\telse\n\t\t\tm_fh->seek(misc->size, File::SeekFromCurrent);\n\n\t\tif (misc->size % 2 != 0)\n\t\t\twriteU8(&padByte);\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeMiscellaneous()\n  {\n  \tif (m_miscellaneousPosition == 0)\n  \t\tm_miscellaneousPosition = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_miscellaneousPosition, File::SeekFromBeginning);\n  \n  \tfor (int i=0; i<m_miscellaneousCount; i++)\n  \t{\n  \t\tMiscellaneous *misc = &m_miscellaneous[i];\n  \t\tTag chunkType;\n  \t\tuint32_t chunkSize;\n  \t\tuint8_t padByte = 0;\n  \n  \t\tswitch (misc->type)\n  \t\t{\n  \t\t\tcase AF_MISC_NAME:\n  \t\t\t\tchunkType = \"NAME\"; break;\n  \t\t\tcase AF_MISC_AUTH:\n  \t\t\t\tchunkType = \"AUTH\"; break;\n  \t\t\tcase AF_MISC_COPY:\n  \t\t\t\tchunkType = \"(c) \"; break;\n  \t\t\tcase AF_MISC_ANNO:\n  \t\t\t\tchunkType = \"ANNO\"; break;\n  \t\t\tcase AF_MISC_MIDI:\n  \t\t\t\tchunkType = \"MIDI\"; break;\n  \t\t\tcase AF_MISC_APPL:\n  \t\t\t\tchunkType = \"APPL\"; break;\n  \t\t}\n  \n  \t\twriteTag(&chunkType);\n  \n  \t\tchunkSize = misc->size;\n  \t\twriteU32(&chunkSize);\n  \t\t/*\n  \t\t\tWrite the miscellaneous buffer and then a pad byte\n  \t\t\tif necessary.  If the buffer is null, skip the space\n  \t\t\tfor now.\n  \t\t*/\n  \t\tif (misc->buffer != NULL)\n  \t\t\tm_fh->write(misc->buffer, misc->size);\n  \t\telse\n  \t\t\tm_fh->seek(misc->size, File::SeekFromCurrent);\n  \n  \t\tif (misc->size % 2 != 0)\n  \t\t\twriteU8(&padByte);\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeAESD",
          "args": [],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "writeAESD",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "927-950",
          "snippet": "status AIFFFile::writeAESD()\n{\n\tTrack *track = getTrack();\n\n\tif (!track->hasAESData)\n\t\treturn AF_SUCCEED;\n\n\tif (m_AESD_offset == 0)\n\t\tm_AESD_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_AESD_offset, File::SeekFromBeginning);\n\n\tif (m_fh->write(\"AESD\", 4) < 4)\n\t\treturn AF_FAIL;\n\n\tuint32_t size = 24;\n\tif (!writeU32(&size))\n\t\treturn AF_FAIL;\n\n\tif (m_fh->write(track->aesData, 24) < 24)\n\t\treturn AF_FAIL;\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeAESD()\n  {\n  \tTrack *track = getTrack();\n  \n  \tif (!track->hasAESData)\n  \t\treturn AF_SUCCEED;\n  \n  \tif (m_AESD_offset == 0)\n  \t\tm_AESD_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_AESD_offset, File::SeekFromBeginning);\n  \n  \tif (m_fh->write(\"AESD\", 4) < 4)\n  \t\treturn AF_FAIL;\n  \n  \tuint32_t size = 24;\n  \tif (!writeU32(&size))\n  \t\treturn AF_FAIL;\n  \n  \tif (m_fh->write(track->aesData, 24) < 24)\n  \t\treturn AF_FAIL;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeINST",
          "args": [],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "writeINST",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "978-1033",
          "snippet": "status AIFFFile::writeINST()\n{\n\tuint32_t length = 20;\n\n\tstruct _INST instrumentdata;\n\n\tinstrumentdata.sustainLoopPlayMode =\n\t\tafGetLoopMode(this, AF_DEFAULT_INST, 1);\n\tinstrumentdata.sustainLoopBegin =\n\t\tafGetLoopStart(this, AF_DEFAULT_INST, 1);\n\tinstrumentdata.sustainLoopEnd =\n\t\tafGetLoopEnd(this, AF_DEFAULT_INST, 1);\n\n\tinstrumentdata.releaseLoopPlayMode =\n\t\tafGetLoopMode(this, AF_DEFAULT_INST, 2);\n\tinstrumentdata.releaseLoopBegin =\n\t\tafGetLoopStart(this, AF_DEFAULT_INST, 2);\n\tinstrumentdata.releaseLoopEnd =\n\t\tafGetLoopEnd(this, AF_DEFAULT_INST, 2);\n\n\tm_fh->write(\"INST\", 4);\n\twriteU32(&length);\n\n\tinstrumentdata.baseNote =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_BASENOTE);\n\twriteU8(&instrumentdata.baseNote);\n\tinstrumentdata.detune =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_NUMCENTS_DETUNE);\n\twriteS8(&instrumentdata.detune);\n\tinstrumentdata.lowNote =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_LONOTE);\n\twriteU8(&instrumentdata.lowNote);\n\tinstrumentdata.highNote =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_HINOTE);\n\twriteU8(&instrumentdata.highNote);\n\tinstrumentdata.lowVelocity =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_LOVELOCITY);\n\twriteU8(&instrumentdata.lowVelocity);\n\tinstrumentdata.highVelocity =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_HIVELOCITY);\n\twriteU8(&instrumentdata.highVelocity);\n\n\tinstrumentdata.gain =\n\t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_NUMDBS_GAIN);\n\twriteS16(&instrumentdata.gain);\n\n\twriteU16(&instrumentdata.sustainLoopPlayMode);\n\twriteU16(&instrumentdata.sustainLoopBegin);\n\twriteU16(&instrumentdata.sustainLoopEnd);\n\n\twriteU16(&instrumentdata.releaseLoopPlayMode);\n\twriteU16(&instrumentdata.releaseLoopBegin);\n\twriteU16(&instrumentdata.releaseLoopEnd);\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeINST()\n  {\n  \tuint32_t length = 20;\n  \n  \tstruct _INST instrumentdata;\n  \n  \tinstrumentdata.sustainLoopPlayMode =\n  \t\tafGetLoopMode(this, AF_DEFAULT_INST, 1);\n  \tinstrumentdata.sustainLoopBegin =\n  \t\tafGetLoopStart(this, AF_DEFAULT_INST, 1);\n  \tinstrumentdata.sustainLoopEnd =\n  \t\tafGetLoopEnd(this, AF_DEFAULT_INST, 1);\n  \n  \tinstrumentdata.releaseLoopPlayMode =\n  \t\tafGetLoopMode(this, AF_DEFAULT_INST, 2);\n  \tinstrumentdata.releaseLoopBegin =\n  \t\tafGetLoopStart(this, AF_DEFAULT_INST, 2);\n  \tinstrumentdata.releaseLoopEnd =\n  \t\tafGetLoopEnd(this, AF_DEFAULT_INST, 2);\n  \n  \tm_fh->write(\"INST\", 4);\n  \twriteU32(&length);\n  \n  \tinstrumentdata.baseNote =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_BASENOTE);\n  \twriteU8(&instrumentdata.baseNote);\n  \tinstrumentdata.detune =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_NUMCENTS_DETUNE);\n  \twriteS8(&instrumentdata.detune);\n  \tinstrumentdata.lowNote =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_LONOTE);\n  \twriteU8(&instrumentdata.lowNote);\n  \tinstrumentdata.highNote =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_HINOTE);\n  \twriteU8(&instrumentdata.highNote);\n  \tinstrumentdata.lowVelocity =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_LOVELOCITY);\n  \twriteU8(&instrumentdata.lowVelocity);\n  \tinstrumentdata.highVelocity =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_MIDI_HIVELOCITY);\n  \twriteU8(&instrumentdata.highVelocity);\n  \n  \tinstrumentdata.gain =\n  \t\tafGetInstParamLong(this, AF_DEFAULT_INST, AF_INST_NUMDBS_GAIN);\n  \twriteS16(&instrumentdata.gain);\n  \n  \twriteU16(&instrumentdata.sustainLoopPlayMode);\n  \twriteU16(&instrumentdata.sustainLoopBegin);\n  \twriteU16(&instrumentdata.sustainLoopEnd);\n  \n  \twriteU16(&instrumentdata.releaseLoopPlayMode);\n  \twriteU16(&instrumentdata.releaseLoopBegin);\n  \twriteU16(&instrumentdata.releaseLoopEnd);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeMARK",
          "args": [],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "writeMARK",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "1035-1081",
          "snippet": "status AIFFFile::writeMARK()\n{\n\tTrack *track = getTrack();\n\tif (!track->markerCount)\n\t\treturn AF_SUCCEED;\n\n\tif (m_MARK_offset == 0)\n\t\tm_MARK_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_MARK_offset, File::SeekFromBeginning);\n\n\tTag markTag(\"MARK\");\n\tuint32_t length = 0;\n\n\twriteTag(&markTag);\n\twriteU32(&length);\n\n\tAFfileoffset chunkStartPosition = m_fh->tell();\n\n\tuint16_t numMarkers = track->markerCount;\n\twriteU16(&numMarkers);\n\n\tfor (unsigned i=0; i<numMarkers; i++)\n\t{\n\t\tuint16_t id = track->markers[i].id;\n\t\twriteU16(&id);\n\n\t\tuint32_t position = track->markers[i].position;\n\t\twriteU32(&position);\n\n\t\tconst char *name = track->markers[i].name;\n\t\tassert(name);\n\n\t\t// Write the name as a Pascal-style string.\n\t\twritePString(name);\n\t}\n\n\tAFfileoffset chunkEndPosition = m_fh->tell();\n\tlength = chunkEndPosition - chunkStartPosition;\n\n\tm_fh->seek(chunkStartPosition - 4, File::SeekFromBeginning);\n\n\twriteU32(&length);\n\tm_fh->seek(chunkEndPosition, File::SeekFromBeginning);\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeMARK()\n  {\n  \tTrack *track = getTrack();\n  \tif (!track->markerCount)\n  \t\treturn AF_SUCCEED;\n  \n  \tif (m_MARK_offset == 0)\n  \t\tm_MARK_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_MARK_offset, File::SeekFromBeginning);\n  \n  \tTag markTag(\"MARK\");\n  \tuint32_t length = 0;\n  \n  \twriteTag(&markTag);\n  \twriteU32(&length);\n  \n  \tAFfileoffset chunkStartPosition = m_fh->tell();\n  \n  \tuint16_t numMarkers = track->markerCount;\n  \twriteU16(&numMarkers);\n  \n  \tfor (unsigned i=0; i<numMarkers; i++)\n  \t{\n  \t\tuint16_t id = track->markers[i].id;\n  \t\twriteU16(&id);\n  \n  \t\tuint32_t position = track->markers[i].position;\n  \t\twriteU32(&position);\n  \n  \t\tconst char *name = track->markers[i].name;\n  \t\tassert(name);\n  \n  \t\t// Write the name as a Pascal-style string.\n  \t\twritePString(name);\n  \t}\n  \n  \tAFfileoffset chunkEndPosition = m_fh->tell();\n  \tlength = chunkEndPosition - chunkStartPosition;\n  \n  \tm_fh->seek(chunkStartPosition - 4, File::SeekFromBeginning);\n  \n  \twriteU32(&length);\n  \tm_fh->seek(chunkEndPosition, File::SeekFromBeginning);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeCOMM",
          "args": [],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "writeCOMM",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "812-921",
          "snippet": "status AIFFFile::writeCOMM()\n{\n\t/*\n\t\tIf COMM_offset hasn't been set yet, set it to the\n\t\tcurrent offset.\n\t*/\n\tif (m_COMM_offset == 0)\n\t\tm_COMM_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_COMM_offset, File::SeekFromBeginning);\n\n\tTrack *track = getTrack();\n\n\tTag compressionTag;\n\t/* Pascal strings can occupy only 255 bytes (+ a size byte). */\n\tchar compressionName[256];\n\n\tif (isAIFFC())\n\t{\n\t\tif (track->f.compressionType == AF_COMPRESSION_NONE)\n\t\t{\n\t\t\tif (track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t{\n\t\t\t\tcompressionTag = \"NONE\";\n\t\t\t\tstrcpy(compressionName, \"not compressed\");\n\t\t\t}\n\t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_FLOAT)\n\t\t\t{\n\t\t\t\tcompressionTag = \"fl32\";\n\t\t\t\tstrcpy(compressionName, \"32-bit Floating Point\");\n\t\t\t}\n\t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_DOUBLE)\n\t\t\t{\n\t\t\t\tcompressionTag = \"fl64\";\n\t\t\t\tstrcpy(compressionName, \"64-bit Floating Point\");\n\t\t\t}\n\t\t\t/*\n\t\t\t\tWe disallow unsigned sample data for\n\t\t\t\tAIFF files in _af_aiff_complete_setup,\n\t\t\t\tso the next condition should never be\n\t\t\t\tsatisfied.\n\t\t\t*/\n\t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_UNSIGNED)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\t\"AIFF/AIFF-C format does not support unsigned data\");\n\t\t\t\tassert(0);\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\t\t}\n\t\telse if (track->f.compressionType == AF_COMPRESSION_G711_ULAW)\n\t\t{\n\t\t\tcompressionTag = \"ulaw\";\n\t\t\tstrcpy(compressionName, \"CCITT G.711 u-law\");\n\t\t}\n\t\telse if (track->f.compressionType == AF_COMPRESSION_G711_ALAW)\n\t\t{\n\t\t\tcompressionTag = \"alaw\";\n\t\t\tstrcpy(compressionName, \"CCITT G.711 A-law\");\n\t\t}\n\t\telse if (track->f.compressionType == AF_COMPRESSION_IMA)\n\t\t{\n\t\t\tcompressionTag = \"ima4\";\n\t\t\tstrcpy(compressionName, \"IMA 4:1 compression\");\n\t\t}\n\t}\n\n\tm_fh->write(\"COMM\", 4);\n\n\t/*\n\t\tFor AIFF-C files, the length of the COMM chunk is 22\n\t\tplus the length of the compression name plus the size\n\t\tbyte.  If the length of the data is an odd number of\n\t\tbytes, add a zero pad byte at the end, but don't\n\t\tinclude the pad byte in the chunk's size.\n\t*/\n\tuint32_t chunkSize;\n\tif (isAIFFC())\n\t\tchunkSize = 22 + strlen(compressionName) + 1;\n\telse\n\t\tchunkSize = 18;\n\twriteU32(&chunkSize);\n\n\t/* number of channels, 2 bytes */\n\tuint16_t channelCount = track->f.channelCount;\n\twriteU16(&channelCount);\n\n\t/* number of sample frames, 4 bytes */\n\tuint32_t frameCount = track->totalfframes;\n\tif (track->f.compressionType == AF_COMPRESSION_IMA)\n\t\tframeCount = track->totalfframes / track->f.framesPerPacket;\n\twriteU32(&frameCount);\n\n\t/* sample size, 2 bytes */\n\tuint16_t sampleSize = track->f.sampleWidth;\n\twriteU16(&sampleSize);\n\n\t/* sample rate, 10 bytes */\n\tuint8_t sampleRate[10];\n\t_af_convert_to_ieee_extended(track->f.sampleRate, sampleRate);\n\tm_fh->write(sampleRate, 10);\n\n\tif (isAIFFC())\n\t{\n\t\twriteTag(&compressionTag);\n\t\twritePString(compressionName);\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeCOMM()\n  {\n  \t/*\n  \t\tIf COMM_offset hasn't been set yet, set it to the\n  \t\tcurrent offset.\n  \t*/\n  \tif (m_COMM_offset == 0)\n  \t\tm_COMM_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_COMM_offset, File::SeekFromBeginning);\n  \n  \tTrack *track = getTrack();\n  \n  \tTag compressionTag;\n  \t/* Pascal strings can occupy only 255 bytes (+ a size byte). */\n  \tchar compressionName[256];\n  \n  \tif (isAIFFC())\n  \t{\n  \t\tif (track->f.compressionType == AF_COMPRESSION_NONE)\n  \t\t{\n  \t\t\tif (track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP)\n  \t\t\t{\n  \t\t\t\tcompressionTag = \"NONE\";\n  \t\t\t\tstrcpy(compressionName, \"not compressed\");\n  \t\t\t}\n  \t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_FLOAT)\n  \t\t\t{\n  \t\t\t\tcompressionTag = \"fl32\";\n  \t\t\t\tstrcpy(compressionName, \"32-bit Floating Point\");\n  \t\t\t}\n  \t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_DOUBLE)\n  \t\t\t{\n  \t\t\t\tcompressionTag = \"fl64\";\n  \t\t\t\tstrcpy(compressionName, \"64-bit Floating Point\");\n  \t\t\t}\n  \t\t\t/*\n  \t\t\t\tWe disallow unsigned sample data for\n  \t\t\t\tAIFF files in _af_aiff_complete_setup,\n  \t\t\t\tso the next condition should never be\n  \t\t\t\tsatisfied.\n  \t\t\t*/\n  \t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_UNSIGNED)\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_SAMPFMT,\n  \t\t\t\t\t\"AIFF/AIFF-C format does not support unsigned data\");\n  \t\t\t\tassert(0);\n  \t\t\t\treturn AF_FAIL;\n  \t\t\t}\n  \t\t}\n  \t\telse if (track->f.compressionType == AF_COMPRESSION_G711_ULAW)\n  \t\t{\n  \t\t\tcompressionTag = \"ulaw\";\n  \t\t\tstrcpy(compressionName, \"CCITT G.711 u-law\");\n  \t\t}\n  \t\telse if (track->f.compressionType == AF_COMPRESSION_G711_ALAW)\n  \t\t{\n  \t\t\tcompressionTag = \"alaw\";\n  \t\t\tstrcpy(compressionName, \"CCITT G.711 A-law\");\n  \t\t}\n  \t\telse if (track->f.compressionType == AF_COMPRESSION_IMA)\n  \t\t{\n  \t\t\tcompressionTag = \"ima4\";\n  \t\t\tstrcpy(compressionName, \"IMA 4:1 compression\");\n  \t\t}\n  \t}\n  \n  \tm_fh->write(\"COMM\", 4);\n  \n  \t/*\n  \t\tFor AIFF-C files, the length of the COMM chunk is 22\n  \t\tplus the length of the compression name plus the size\n  \t\tbyte.  If the length of the data is an odd number of\n  \t\tbytes, add a zero pad byte at the end, but don't\n  \t\tinclude the pad byte in the chunk's size.\n  \t*/\n  \tuint32_t chunkSize;\n  \tif (isAIFFC())\n  \t\tchunkSize = 22 + strlen(compressionName) + 1;\n  \telse\n  \t\tchunkSize = 18;\n  \twriteU32(&chunkSize);\n  \n  \t/* number of channels, 2 bytes */\n  \tuint16_t channelCount = track->f.channelCount;\n  \twriteU16(&channelCount);\n  \n  \t/* number of sample frames, 4 bytes */\n  \tuint32_t frameCount = track->totalfframes;\n  \tif (track->f.compressionType == AF_COMPRESSION_IMA)\n  \t\tframeCount = track->totalfframes / track->f.framesPerPacket;\n  \twriteU32(&frameCount);\n  \n  \t/* sample size, 2 bytes */\n  \tuint16_t sampleSize = track->f.sampleWidth;\n  \twriteU16(&sampleSize);\n  \n  \t/* sample rate, 10 bytes */\n  \tuint8_t sampleRate[10];\n  \t_af_convert_to_ieee_extended(track->f.sampleRate, sampleRate);\n  \tm_fh->write(sampleRate, 10);\n  \n  \tif (isAIFFC())\n  \t{\n  \t\twriteTag(&compressionTag);\n  \t\twritePString(compressionName);\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeFVER",
          "args": [],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "writeFVER",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "1086-1106",
          "snippet": "status AIFFFile::writeFVER()\n{\n\tuint32_t chunkSize, timeStamp;\n\n\tassert(isAIFFC());\n\n\tif (m_FVER_offset == 0)\n\t\tm_FVER_offset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_FVER_offset, File::SeekFromBeginning);\n\n\tm_fh->write(\"FVER\", 4);\n\n\tchunkSize = 4;\n\twriteU32(&chunkSize);\n\n\ttimeStamp = AIFC_VERSION_1;\n\twriteU32(&timeStamp);\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define AIFC_VERSION_1 0xa2805140"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\n#define AIFC_VERSION_1 0xa2805140\n\nAIFFFile {\n  status AIFFFile::writeFVER()\n  {\n  \tuint32_t chunkSize, timeStamp;\n  \n  \tassert(isAIFFC());\n  \n  \tif (m_FVER_offset == 0)\n  \t\tm_FVER_offset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_FVER_offset, File::SeekFromBeginning);\n  \n  \tm_fh->write(\"FVER\", 4);\n  \n  \tchunkSize = 4;\n  \twriteU32(&chunkSize);\n  \n  \ttimeStamp = AIFC_VERSION_1;\n  \twriteU32(&timeStamp);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isAIFFC",
          "args": [],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "isAIFFC",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.h",
          "lines": "86-86",
          "snippet": "bool isAIFFC() const { return m_fileFormat == AF_FILE_AIFFC; }",
          "includes": [
            "#include \"FileHandle.h\"",
            "#include \"Compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FileHandle.h\"\n#include \"Compiler.h\"\n\nAIFFFile {\n  bool isAIFFC() const { return m_fileFormat == AF_FILE_AIFFC; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "\"AIFF\"",
            "4"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&fileSize"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "initCompressionParams",
          "args": [],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "initCompressionParams",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "1163-1168",
          "snippet": "void AIFFFile::initCompressionParams()\n{\n\tTrack *track = getTrack();\n\tif (track->f.compressionType == AF_COMPRESSION_IMA)\n\t\tinitIMACompressionParams();\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  void AIFFFile::initCompressionParams()\n  {\n  \tTrack *track = getTrack();\n  \tif (track->f.compressionType == AF_COMPRESSION_IMA)\n  \t\tinitIMACompressionParams();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "initFromSetup",
          "args": [
            "setup"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "initFromSetup",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "222-231",
          "snippet": "status _AFfilehandle::initFromSetup(AFfilesetup setup)\n{\n\tif (copyTracksFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\tif (copyInstrumentsFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\tif (copyMiscellaneousFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  status _AFfilehandle::initFromSetup(AFfilesetup setup)\n  {\n  \tif (copyTracksFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \tif (copyInstrumentsFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \tif (copyMiscellaneousFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \treturn AF_SUCCEED;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::writeInit(AFfilesetup setup)\n  {\n  \tif (initFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \n  \tinitCompressionParams();\n  \n  \tuint32_t fileSize = 0;\n  \tm_fh->write(\"FORM\", 4);\n  \twriteU32(&fileSize);\n  \n  \tif (isAIFFC())\n  \t\tm_fh->write(\"AIFC\", 4);\n  \telse\n  \t\tm_fh->write(\"AIFF\", 4);\n  \n  \tif (isAIFFC())\n  \t\twriteFVER();\n  \n  \twriteCOMM();\n  \twriteMARK();\n  \twriteINST();\n  \twriteAESD();\n  \twriteMiscellaneous();\n  \twriteSSND();\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "getVersion",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "753-758",
    "snippet": "int AIFFFile::getVersion()\n{\n\tif (isAIFFC())\n\t\treturn AIFC_VERSION_1;\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define AIFC_VERSION_1 0xa2805140"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isAIFFC",
          "args": [],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "isAIFFC",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.h",
          "lines": "86-86",
          "snippet": "bool isAIFFC() const { return m_fileFormat == AF_FILE_AIFFC; }",
          "includes": [
            "#include \"FileHandle.h\"",
            "#include \"Compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FileHandle.h\"\n#include \"Compiler.h\"\n\nAIFFFile {\n  bool isAIFFC() const { return m_fileFormat == AF_FILE_AIFFC; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\n#define AIFC_VERSION_1 0xa2805140\n\nAIFFFile {\n  int AIFFFile::getVersion()\n  {\n  \tif (isAIFFC())\n  \t\treturn AIFC_VERSION_1;\n  \treturn 0;\n  }\n}"
  },
  {
    "function_name": "isInstrumentParameterValid",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "708-751",
    "snippet": "bool AIFFFile::isInstrumentParameterValid(AUpvlist list, int i)\n{\n\tint param, type;\n\n\tAUpvgetparam(list, i, &param);\n\tAUpvgetvaltype(list, i, &type);\n\tif (type != AU_PVTYPE_LONG)\n\t\treturn false;\n\n\tlong lval;\n\tAUpvgetval(list, i, &lval);\n\n\tswitch (param)\n\t{\n\t\tcase AF_INST_MIDI_BASENOTE:\n\t\t\treturn ((lval >= 0) && (lval <= 127));\n\n\t\tcase AF_INST_NUMCENTS_DETUNE:\n\t\t\treturn ((lval >= -50) && (lval <= 50));\n\n\t\tcase AF_INST_MIDI_LOVELOCITY:\n\t\t\treturn ((lval >= 1) && (lval <= 127));\n\n\t\tcase AF_INST_MIDI_HIVELOCITY:\n\t\t\treturn ((lval >= 1) && (lval <= 127));\n\n\t\tcase AF_INST_MIDI_LONOTE:\n\t\t\treturn ((lval >= 0) && (lval <= 127));\n\n\t\tcase AF_INST_MIDI_HINOTE:\n\t\t\treturn ((lval >= 0) && (lval <= 127));\n\n\t\tcase AF_INST_NUMDBS_GAIN:\n\t\tcase AF_INST_SUSLOOPID:\n\t\tcase AF_INST_RELLOOPID:\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\treturn false;\n\t\t\tbreak;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AUpvgetval",
          "args": [
            "list",
            "i",
            "&lval"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvgetvaltype",
          "args": [
            "list",
            "i",
            "&type"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvgetparam",
          "args": [
            "list",
            "i",
            "&param"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  bool AIFFFile::isInstrumentParameterValid(AUpvlist list, int i)\n  {\n  \tint param, type;\n  \n  \tAUpvgetparam(list, i, &param);\n  \tAUpvgetvaltype(list, i, &type);\n  \tif (type != AU_PVTYPE_LONG)\n  \t\treturn false;\n  \n  \tlong lval;\n  \tAUpvgetval(list, i, &lval);\n  \n  \tswitch (param)\n  \t{\n  \t\tcase AF_INST_MIDI_BASENOTE:\n  \t\t\treturn ((lval >= 0) && (lval <= 127));\n  \n  \t\tcase AF_INST_NUMCENTS_DETUNE:\n  \t\t\treturn ((lval >= -50) && (lval <= 50));\n  \n  \t\tcase AF_INST_MIDI_LOVELOCITY:\n  \t\t\treturn ((lval >= 1) && (lval <= 127));\n  \n  \t\tcase AF_INST_MIDI_HIVELOCITY:\n  \t\t\treturn ((lval >= 1) && (lval <= 127));\n  \n  \t\tcase AF_INST_MIDI_LONOTE:\n  \t\t\treturn ((lval >= 0) && (lval <= 127));\n  \n  \t\tcase AF_INST_MIDI_HINOTE:\n  \t\t\treturn ((lval >= 0) && (lval <= 127));\n  \n  \t\tcase AF_INST_NUMDBS_GAIN:\n  \t\tcase AF_INST_SUSLOOPID:\n  \t\tcase AF_INST_RELLOOPID:\n  \t\t\treturn true;\n  \n  \t\tdefault:\n  \t\t\treturn false;\n  \t\t\tbreak;\n  \t}\n  \n  \treturn true;\n  }\n}"
  },
  {
    "function_name": "completeSetup",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "599-706",
    "snippet": "AFfilesetup AIFFFile::completeSetup(AFfilesetup setup)\n{\n\tbool\tisAIFF = setup->fileFormat == AF_FILE_AIFF;\n\n\tif (setup->trackSet && setup->trackCount != 1)\n\t{\n\t\t_af_error(AF_BAD_NUMTRACKS, \"AIFF/AIFF-C file must have 1 track\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tTrackSetup *track = setup->getTrack();\n\tif (!track)\n\t\treturn AF_NULL_FILESETUP;\n\n\tif (track->sampleFormatSet)\n\t{\n\t\tif (track->f.sampleFormat == AF_SAMPFMT_UNSIGNED)\n\t\t{\n\t\t\t_af_error(AF_BAD_FILEFMT, \"AIFF/AIFF-C format does not support unsigned data\");\n\t\t\treturn AF_NULL_FILESETUP;\n\t\t}\n\t\telse if (isAIFF && track->f.sampleFormat != AF_SAMPFMT_TWOSCOMP)\n\t\t{\n\t\t\t_af_error(AF_BAD_FILEFMT, \"AIFF format supports only two's complement integer data\");\n\t\t\treturn AF_NULL_FILESETUP;\n\t\t}\n\t}\n\telse\n\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP,\n\t\t\ttrack->f.sampleWidth);\n\n\t/* Check sample width if writing two's complement. Otherwise ignore. */\n\tif (track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP &&\n\t\t(track->f.sampleWidth < 1 || track->f.sampleWidth > 32))\n\t{\n\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\"invalid sample width %d for AIFF/AIFF-C file \"\n\t\t\t\"(must be 1-32)\", track->f.sampleWidth);\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (isAIFF && track->f.compressionType != AF_COMPRESSION_NONE)\n\t{\n\t\t_af_error(AF_BAD_FILESETUP,\n\t\t\t\"AIFF does not support compression; use AIFF-C\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->f.compressionType != AF_COMPRESSION_NONE &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_G711_ULAW &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_G711_ALAW &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_IMA)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"compression format not supported in AIFF-C\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->f.isUncompressed() &&\n\t\ttrack->byteOrderSet &&\n\t\ttrack->f.byteOrder != AF_BYTEORDER_BIGENDIAN &&\n\t\ttrack->f.isByteOrderSignificant())\n\t{\n\t\t_af_error(AF_BAD_BYTEORDER,\n\t\t\t\"AIFF/AIFF-C format supports only big-endian data\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->f.isUncompressed())\n\t\ttrack->f.byteOrder = AF_BYTEORDER_BIGENDIAN;\n\n\tif (setup->instrumentSet)\n\t{\n\t\tif (setup->instrumentCount != 0 && setup->instrumentCount != 1)\n\t\t{\n\t\t\t_af_error(AF_BAD_NUMINSTS, \"AIFF/AIFF-C file must have 0 or 1 instrument chunk\");\n\t\t\treturn AF_NULL_FILESETUP;\n\t\t}\n\t\tif (setup->instruments != 0 &&\n\t\t\tsetup->instruments[0].loopCount != 2)\n\t\t{\n\t\t\t_af_error(AF_BAD_NUMLOOPS, \"AIFF/AIFF-C file with instrument must also have 2 loops\");\n\t\t\treturn AF_NULL_FILESETUP;\n\t\t}\n\t}\n\n\tif (setup->miscellaneousSet)\n\t{\n\t\tfor (int i=0; i<setup->miscellaneousCount; i++)\n\t\t{\n\t\t\tswitch (setup->miscellaneous[i].type)\n\t\t\t{\n\t\t\t\tcase AF_MISC_COPY:\n\t\t\t\tcase AF_MISC_AUTH:\n\t\t\t\tcase AF_MISC_NAME:\n\t\t\t\tcase AF_MISC_ANNO:\n\t\t\t\tcase AF_MISC_APPL:\n\t\t\t\tcase AF_MISC_MIDI:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t_af_error(AF_BAD_MISCTYPE, \"invalid miscellaneous type %d for AIFF/AIFF-C file\", setup->miscellaneous[i].type);\n\t\t\t\t\treturn AF_NULL_FILESETUP;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn _af_filesetup_copy(setup, &aiffDefaultFileSetup, true);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const _AFfilesetup aiffDefaultFileSetup =\n{\n\t_AF_VALID_FILESETUP,\t/* valid */\n\tAF_FILE_AIFF,\t\t/* fileFormat */\n\ttrue,\t\t\t/* trackSet */\n\ttrue,\t\t\t/* instrumentSet */\n\ttrue,\t\t\t/* miscellaneousSet */\n\t1,\t\t\t/* trackCount */\n\tNULL,\t\t\t/* tracks */\n\t1,\t\t\t/* instrumentCount */\n\tNULL,\t\t\t/* instruments */\n\t0,\t\t\t/* miscellaneousCount */\n\tNULL\t\t\t/* miscellaneous */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_filesetup_copy",
          "args": [
            "setup",
            "&aiffDefaultFileSetup",
            "true"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "_af_filesetup_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Setup.cpp",
          "lines": "440-525",
          "snippet": "AFfilesetup _af_filesetup_copy (const _AFfilesetup *setup,\n\tconst _AFfilesetup *defaultSetup, bool copyMarks)\n{\n\tAFfilesetup newsetup;\n\tint instrumentCount, miscellaneousCount, trackCount;\n\n\tnewsetup = (_AFfilesetup *) _af_malloc(sizeof (_AFfilesetup));\n\tif (newsetup == AF_NULL_FILESETUP)\n\t\treturn AF_NULL_FILESETUP;\n\n\t*newsetup = *defaultSetup;\n\n\tnewsetup->tracks = NULL;\n\tnewsetup->instruments = NULL;\n\tnewsetup->miscellaneous = NULL;\n\n\t/* Copy tracks. */\n\ttrackCount = setup->trackSet ? setup->trackCount :\n\t\tnewsetup->trackSet ? newsetup->trackCount : 0;\n\talloccopy(TrackSetup, trackCount, newsetup->tracks, setup->tracks);\n\tnewsetup->trackCount = trackCount;\n\n\t/* Copy instruments. */\n\tinstrumentCount = setup->instrumentSet ? setup->instrumentCount :\n\t\tnewsetup->instrumentSet ? newsetup->instrumentCount : 0;\n\talloccopy(InstrumentSetup, instrumentCount, newsetup->instruments, setup->instruments);\n\tnewsetup->instrumentCount = instrumentCount;\n\n\t/* Copy miscellaneous information. */\n\tmiscellaneousCount = setup->miscellaneousSet ? setup->miscellaneousCount :\n\t\tnewsetup->miscellaneousSet ? newsetup->miscellaneousCount : 0;\n\talloccopy(MiscellaneousSetup, miscellaneousCount, newsetup->miscellaneous, setup->miscellaneous);\n\tnewsetup->miscellaneousCount = miscellaneousCount;\n\n\tfor (int i=0; i<setup->trackCount; i++)\n\t{\n\t\tTrackSetup\t*track = &newsetup->tracks[i];\n\n\t\t/* XXXmpruett set compression information */\n\n\t\tif (!setup->tracks[i].markersSet && !copyMarks)\n\t\t{\n\t\t\ttrack->markers = NULL;\n\t\t\ttrack->markerCount = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\talloccopy(MarkerSetup, setup->tracks[i].markerCount,\n\t\t\ttrack->markers, setup->tracks[i].markers);\n\t\ttrack->markerCount = setup->tracks[i].markerCount;\n\n\t\tfor (int j=0; j<setup->tracks[i].markerCount; j++)\n\t\t{\n\t\t\ttrack->markers[j].name =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].name);\n\t\t\tif (track->markers[j].name == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\ttrack->markers[j].comment =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].comment);\n\t\t\tif (track->markers[j].comment == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (int i=0; i<newsetup->instrumentCount; i++)\n\t{\n\t\tInstrumentSetup\t*instrument = &newsetup->instruments[i];\n\t\talloccopy(LoopSetup, setup->instruments[i].loopCount,\n\t\t\tinstrument->loops, setup->instruments[i].loops);\n\t}\n\n\treturn newsetup;\n\n\tfail:\n\t\tif (newsetup->miscellaneous)\n\t\t\tfree(newsetup->miscellaneous);\n\t\tif (newsetup->instruments)\n\t\t\tfree(newsetup->instruments);\n\t\tif (newsetup->tracks)\n\t\t\tfree(newsetup->tracks);\n\t\tif (newsetup)\n\t\t\tfree(newsetup);\n\n\treturn AF_NULL_FILESETUP;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"audiofile.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"Setup.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"audiofile.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include <string.h>\n#include <stdlib.h>\n#include \"Setup.h\"\n#include \"config.h\"\n\nAFfilesetup _af_filesetup_copy (const _AFfilesetup *setup,\n\tconst _AFfilesetup *defaultSetup, bool copyMarks)\n{\n\tAFfilesetup newsetup;\n\tint instrumentCount, miscellaneousCount, trackCount;\n\n\tnewsetup = (_AFfilesetup *) _af_malloc(sizeof (_AFfilesetup));\n\tif (newsetup == AF_NULL_FILESETUP)\n\t\treturn AF_NULL_FILESETUP;\n\n\t*newsetup = *defaultSetup;\n\n\tnewsetup->tracks = NULL;\n\tnewsetup->instruments = NULL;\n\tnewsetup->miscellaneous = NULL;\n\n\t/* Copy tracks. */\n\ttrackCount = setup->trackSet ? setup->trackCount :\n\t\tnewsetup->trackSet ? newsetup->trackCount : 0;\n\talloccopy(TrackSetup, trackCount, newsetup->tracks, setup->tracks);\n\tnewsetup->trackCount = trackCount;\n\n\t/* Copy instruments. */\n\tinstrumentCount = setup->instrumentSet ? setup->instrumentCount :\n\t\tnewsetup->instrumentSet ? newsetup->instrumentCount : 0;\n\talloccopy(InstrumentSetup, instrumentCount, newsetup->instruments, setup->instruments);\n\tnewsetup->instrumentCount = instrumentCount;\n\n\t/* Copy miscellaneous information. */\n\tmiscellaneousCount = setup->miscellaneousSet ? setup->miscellaneousCount :\n\t\tnewsetup->miscellaneousSet ? newsetup->miscellaneousCount : 0;\n\talloccopy(MiscellaneousSetup, miscellaneousCount, newsetup->miscellaneous, setup->miscellaneous);\n\tnewsetup->miscellaneousCount = miscellaneousCount;\n\n\tfor (int i=0; i<setup->trackCount; i++)\n\t{\n\t\tTrackSetup\t*track = &newsetup->tracks[i];\n\n\t\t/* XXXmpruett set compression information */\n\n\t\tif (!setup->tracks[i].markersSet && !copyMarks)\n\t\t{\n\t\t\ttrack->markers = NULL;\n\t\t\ttrack->markerCount = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\talloccopy(MarkerSetup, setup->tracks[i].markerCount,\n\t\t\ttrack->markers, setup->tracks[i].markers);\n\t\ttrack->markerCount = setup->tracks[i].markerCount;\n\n\t\tfor (int j=0; j<setup->tracks[i].markerCount; j++)\n\t\t{\n\t\t\ttrack->markers[j].name =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].name);\n\t\t\tif (track->markers[j].name == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\ttrack->markers[j].comment =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].comment);\n\t\t\tif (track->markers[j].comment == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (int i=0; i<newsetup->instrumentCount; i++)\n\t{\n\t\tInstrumentSetup\t*instrument = &newsetup->instruments[i];\n\t\talloccopy(LoopSetup, setup->instruments[i].loopCount,\n\t\t\tinstrument->loops, setup->instruments[i].loops);\n\t}\n\n\treturn newsetup;\n\n\tfail:\n\t\tif (newsetup->miscellaneous)\n\t\t\tfree(newsetup->miscellaneous);\n\t\tif (newsetup->instruments)\n\t\t\tfree(newsetup->instruments);\n\t\tif (newsetup->tracks)\n\t\t\tfree(newsetup->tracks);\n\t\tif (newsetup)\n\t\t\tfree(newsetup);\n\n\treturn AF_NULL_FILESETUP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_MISCTYPE",
            "\"invalid miscellaneous type %d for AIFF/AIFF-C file\"",
            "setup->miscellaneous[i].type"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NUMLOOPS",
            "\"AIFF/AIFF-C file with instrument must also have 2 loops\""
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NUMINSTS",
            "\"AIFF/AIFF-C file must have 0 or 1 instrument chunk\""
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track->f.isUncompressed",
          "args": [],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "isUncompressed",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "93-96",
          "snippet": "bool AudioFormat::isUncompressed() const\n{\n\treturn compressionType == AF_COMPRESSION_NONE;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  bool AudioFormat::isUncompressed() const\n  {\n  \treturn compressionType == AF_COMPRESSION_NONE;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_BYTEORDER",
            "\"AIFF/AIFF-C format supports only big-endian data\""
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track->f.isByteOrderSignificant",
          "args": [],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "isByteOrderSignificant",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.h",
          "lines": "64-64",
          "snippet": "bool isByteOrderSignificant() const { return sampleWidth > 8; }",
          "includes": [
            "#include <string>",
            "#include <sys/types.h>",
            "#include \"aupvlist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <sys/types.h>\n#include \"aupvlist.h\"\n\nAudioFormat {\n  bool isByteOrderSignificant() const { return sampleWidth > 8; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"compression format not supported in AIFF-C\""
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_FILESETUP",
            "\"AIFF does not support compression; use AIFF-C\""
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_WIDTH",
            "\"invalid sample width %d for AIFF/AIFF-C file \"\n\t\t\t\"(must be 1-32)\"",
            "track->f.sampleWidth"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_set_sample_format",
          "args": [
            "&track->f",
            "AF_SAMPFMT_TWOSCOMP",
            "track->f.sampleWidth"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "_af_set_sample_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "315-361",
          "snippet": "status _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatus _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_FILEFMT",
            "\"AIFF format supports only two's complement integer data\""
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_FILEFMT",
            "\"AIFF/AIFF-C format does not support unsigned data\""
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup->getTrack",
          "args": [],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NUMTRACKS",
            "\"AIFF/AIFF-C file must have 1 track\""
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nstatic const _AFfilesetup aiffDefaultFileSetup =\n{\n\t_AF_VALID_FILESETUP,\t/* valid */\n\tAF_FILE_AIFF,\t\t/* fileFormat */\n\ttrue,\t\t\t/* trackSet */\n\ttrue,\t\t\t/* instrumentSet */\n\ttrue,\t\t\t/* miscellaneousSet */\n\t1,\t\t\t/* trackCount */\n\tNULL,\t\t\t/* tracks */\n\t1,\t\t\t/* instrumentCount */\n\tNULL,\t\t\t/* instruments */\n\t0,\t\t\t/* miscellaneousCount */\n\tNULL\t\t\t/* miscellaneous */\n};\n\nAIFFFile {\n  AFfilesetup AIFFFile::completeSetup(AFfilesetup setup)\n  {\n  \tbool\tisAIFF = setup->fileFormat == AF_FILE_AIFF;\n  \n  \tif (setup->trackSet && setup->trackCount != 1)\n  \t{\n  \t\t_af_error(AF_BAD_NUMTRACKS, \"AIFF/AIFF-C file must have 1 track\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tTrackSetup *track = setup->getTrack();\n  \tif (!track)\n  \t\treturn AF_NULL_FILESETUP;\n  \n  \tif (track->sampleFormatSet)\n  \t{\n  \t\tif (track->f.sampleFormat == AF_SAMPFMT_UNSIGNED)\n  \t\t{\n  \t\t\t_af_error(AF_BAD_FILEFMT, \"AIFF/AIFF-C format does not support unsigned data\");\n  \t\t\treturn AF_NULL_FILESETUP;\n  \t\t}\n  \t\telse if (isAIFF && track->f.sampleFormat != AF_SAMPFMT_TWOSCOMP)\n  \t\t{\n  \t\t\t_af_error(AF_BAD_FILEFMT, \"AIFF format supports only two's complement integer data\");\n  \t\t\treturn AF_NULL_FILESETUP;\n  \t\t}\n  \t}\n  \telse\n  \t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP,\n  \t\t\ttrack->f.sampleWidth);\n  \n  \t/* Check sample width if writing two's complement. Otherwise ignore. */\n  \tif (track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP &&\n  \t\t(track->f.sampleWidth < 1 || track->f.sampleWidth > 32))\n  \t{\n  \t\t_af_error(AF_BAD_WIDTH,\n  \t\t\t\"invalid sample width %d for AIFF/AIFF-C file \"\n  \t\t\t\"(must be 1-32)\", track->f.sampleWidth);\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (isAIFF && track->f.compressionType != AF_COMPRESSION_NONE)\n  \t{\n  \t\t_af_error(AF_BAD_FILESETUP,\n  \t\t\t\"AIFF does not support compression; use AIFF-C\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (track->f.compressionType != AF_COMPRESSION_NONE &&\n  \t\ttrack->f.compressionType != AF_COMPRESSION_G711_ULAW &&\n  \t\ttrack->f.compressionType != AF_COMPRESSION_G711_ALAW &&\n  \t\ttrack->f.compressionType != AF_COMPRESSION_IMA)\n  \t{\n  \t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"compression format not supported in AIFF-C\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (track->f.isUncompressed() &&\n  \t\ttrack->byteOrderSet &&\n  \t\ttrack->f.byteOrder != AF_BYTEORDER_BIGENDIAN &&\n  \t\ttrack->f.isByteOrderSignificant())\n  \t{\n  \t\t_af_error(AF_BAD_BYTEORDER,\n  \t\t\t\"AIFF/AIFF-C format supports only big-endian data\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (track->f.isUncompressed())\n  \t\ttrack->f.byteOrder = AF_BYTEORDER_BIGENDIAN;\n  \n  \tif (setup->instrumentSet)\n  \t{\n  \t\tif (setup->instrumentCount != 0 && setup->instrumentCount != 1)\n  \t\t{\n  \t\t\t_af_error(AF_BAD_NUMINSTS, \"AIFF/AIFF-C file must have 0 or 1 instrument chunk\");\n  \t\t\treturn AF_NULL_FILESETUP;\n  \t\t}\n  \t\tif (setup->instruments != 0 &&\n  \t\t\tsetup->instruments[0].loopCount != 2)\n  \t\t{\n  \t\t\t_af_error(AF_BAD_NUMLOOPS, \"AIFF/AIFF-C file with instrument must also have 2 loops\");\n  \t\t\treturn AF_NULL_FILESETUP;\n  \t\t}\n  \t}\n  \n  \tif (setup->miscellaneousSet)\n  \t{\n  \t\tfor (int i=0; i<setup->miscellaneousCount; i++)\n  \t\t{\n  \t\t\tswitch (setup->miscellaneous[i].type)\n  \t\t\t{\n  \t\t\t\tcase AF_MISC_COPY:\n  \t\t\t\tcase AF_MISC_AUTH:\n  \t\t\t\tcase AF_MISC_NAME:\n  \t\t\t\tcase AF_MISC_ANNO:\n  \t\t\t\tcase AF_MISC_APPL:\n  \t\t\t\tcase AF_MISC_MIDI:\n  \t\t\t\t\tbreak;\n  \n  \t\t\t\tdefault:\n  \t\t\t\t\t_af_error(AF_BAD_MISCTYPE, \"invalid miscellaneous type %d for AIFF/AIFF-C file\", setup->miscellaneous[i].type);\n  \t\t\t\t\treturn AF_NULL_FILESETUP;\n  \t\t\t}\n  \t\t}\n  \t}\n  \n  \treturn _af_filesetup_copy(setup, &aiffDefaultFileSetup, true);\n  }\n}"
  },
  {
    "function_name": "recognizeAIFFC",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "585-597",
    "snippet": "bool AIFFFile::recognizeAIFFC(File *fh)\n{\n\tuint8_t buffer[8];\n\n\tfh->seek(0, File::SeekFromBeginning);\n\n\tif (fh->read(buffer, 8) != 8 || memcmp(buffer, \"FORM\", 4) != 0)\n\t\treturn false;\n\tif (fh->read(buffer, 4) != 4 || memcmp(buffer, \"AIFC\", 4) != 0)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"AIFC\"",
            "4"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh->read",
          "args": [
            "buffer",
            "4"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"FORM\"",
            "4"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh->seek",
          "args": [
            "0",
            "File::SeekFromBeginning"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  bool AIFFFile::recognizeAIFFC(File *fh)\n  {\n  \tuint8_t buffer[8];\n  \n  \tfh->seek(0, File::SeekFromBeginning);\n  \n  \tif (fh->read(buffer, 8) != 8 || memcmp(buffer, \"FORM\", 4) != 0)\n  \t\treturn false;\n  \tif (fh->read(buffer, 4) != 4 || memcmp(buffer, \"AIFC\", 4) != 0)\n  \t\treturn false;\n  \n  \treturn true;\n  }\n}"
  },
  {
    "function_name": "recognizeAIFF",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "571-583",
    "snippet": "bool AIFFFile::recognizeAIFF(File *fh)\n{\n\tuint8_t buffer[8];\n\n\tfh->seek(0, File::SeekFromBeginning);\n\n\tif (fh->read(buffer, 8) != 8 || memcmp(buffer, \"FORM\", 4) != 0)\n\t\treturn false;\n\tif (fh->read(buffer, 4) != 4 || memcmp(buffer, \"AIFF\", 4) != 0)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"AIFF\"",
            "4"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh->read",
          "args": [
            "buffer",
            "4"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"FORM\"",
            "4"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh->seek",
          "args": [
            "0",
            "File::SeekFromBeginning"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  bool AIFFFile::recognizeAIFF(File *fh)\n  {\n  \tuint8_t buffer[8];\n  \n  \tfh->seek(0, File::SeekFromBeginning);\n  \n  \tif (fh->read(buffer, 8) != 8 || memcmp(buffer, \"FORM\", 4) != 0)\n  \t\treturn false;\n  \tif (fh->read(buffer, 4) != 4 || memcmp(buffer, \"AIFF\", 4) != 0)\n  \t\treturn false;\n  \n  \treturn true;\n  }\n}"
  },
  {
    "function_name": "readInit",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "467-569",
    "snippet": "status AIFFFile::readInit(AFfilesetup setup)\n{\n\tuint32_t type, size, formtype;\n\n\tbool hasCOMM = false;\n\tbool hasFVER = false;\n\tbool hasSSND = false;\n\n\tm_fh->seek(0, File::SeekFromBeginning);\n\n\tm_fh->read(&type, 4);\n\treadU32(&size);\n\tm_fh->read(&formtype, 4);\n\n\tif (memcmp(&type, \"FORM\", 4) != 0 ||\n\t\t(memcmp(&formtype, \"AIFF\", 4) && memcmp(&formtype, \"AIFC\", 4)))\n\t\treturn AF_FAIL;\n\n\tif (!allocateTrack())\n\t\treturn AF_FAIL;\n\n\t/* Include the offset of the form type. */\n\tsize_t index = 4;\n\twhile (index < size)\n\t{\n\t\tTag chunkid;\n\t\tuint32_t chunksize = 0;\n\t\tstatus result = AF_SUCCEED;\n\n\t\treadTag(&chunkid);\n\t\treadU32(&chunksize);\n\n\t\tif (chunkid == \"COMM\")\n\t\t{\n\t\t\thasCOMM = true;\n\t\t\tresult = parseCOMM(chunkid, chunksize);\n\t\t}\n\t\telse if (chunkid == \"FVER\")\n\t\t{\n\t\t\thasFVER = true;\n\t\t\tparseFVER(chunkid, chunksize);\n\t\t}\n\t\telse if (chunkid == \"INST\")\n\t\t{\n\t\t\tparseINST(chunkid, chunksize);\n\t\t}\n\t\telse if (chunkid == \"MARK\")\n\t\t{\n\t\t\tparseMARK(chunkid, chunksize);\n\t\t}\n\t\telse if (chunkid == \"AESD\")\n\t\t{\n\t\t\tparseAESD(chunkid, chunksize);\n\t\t}\n\t\telse if (chunkid == \"NAME\" ||\n\t\t\tchunkid == \"AUTH\" ||\n\t\t\tchunkid == \"(c) \" ||\n\t\t\tchunkid == \"ANNO\" ||\n\t\t\tchunkid == \"APPL\" ||\n\t\t\tchunkid == \"MIDI\")\n\t\t{\n\t\t\tparseMiscellaneous(chunkid, chunksize);\n\t\t}\n\t\t/*\n\t\t\tThe sound data chunk is required if there are more than\n\t\t\tzero sample frames.\n\t\t*/\n\t\telse if (chunkid == \"SSND\")\n\t\t{\n\t\t\tif (hasSSND)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_AIFF_SSND, \"AIFF file has more than one SSND chunk\");\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\t\t\thasSSND = true;\n\t\t\tresult = parseSSND(chunkid, chunksize);\n\t\t}\n\n\t\tif (result == AF_FAIL)\n\t\t\treturn AF_FAIL;\n\n\t\tindex += chunksize + 8;\n\n\t\t/* all chunks must be aligned on an even number of bytes */\n\t\tif ((index % 2) != 0)\n\t\t\tindex++;\n\n\t\tm_fh->seek(index + 8, File::SeekFromBeginning);\n\t}\n\n\tif (!hasCOMM)\n\t{\n\t\t_af_error(AF_BAD_AIFF_COMM, \"bad AIFF COMM chunk\");\n\t}\n\n\tif (isAIFFC() && !hasFVER)\n\t{\n\t\t_af_error(AF_BAD_HEADER, \"FVER chunk is required in AIFF-C\");\n\t}\n\n\t/* The file has been successfully parsed. */\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_HEADER",
            "\"FVER chunk is required in AIFF-C\""
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isAIFFC",
          "args": [],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "isAIFFC",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.h",
          "lines": "86-86",
          "snippet": "bool isAIFFC() const { return m_fileFormat == AF_FILE_AIFFC; }",
          "includes": [
            "#include \"FileHandle.h\"",
            "#include \"Compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FileHandle.h\"\n#include \"Compiler.h\"\n\nAIFFFile {\n  bool isAIFFC() const { return m_fileFormat == AF_FILE_AIFFC; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_AIFF_COMM",
            "\"bad AIFF COMM chunk\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "index + 8",
            "File::SeekFromBeginning"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseSSND",
          "args": [
            "chunkid",
            "chunksize"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "parseSSND",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "450-465",
          "snippet": "status AIFFFile::parseSSND(const Tag &type, size_t size)\n{\n\tassert(type == \"SSND\");\n\n\tTrack *track = getTrack();\n\n\tuint32_t offset, blockSize;\n\treadU32(&offset);\n\treadU32(&blockSize);\n\n\ttrack->data_size = size - 8 - offset;\n\n\ttrack->fpos_first_frame = m_fh->tell() + offset;\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::parseSSND(const Tag &type, size_t size)\n  {\n  \tassert(type == \"SSND\");\n  \n  \tTrack *track = getTrack();\n  \n  \tuint32_t offset, blockSize;\n  \treadU32(&offset);\n  \treadU32(&blockSize);\n  \n  \ttrack->data_size = size - 8 - offset;\n  \n  \ttrack->fpos_first_frame = m_fh->tell() + offset;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_AIFF_SSND",
            "\"AIFF file has more than one SSND chunk\""
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseMiscellaneous",
          "args": [
            "chunkid",
            "chunksize"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "parseMiscellaneous",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "158-198",
          "snippet": "status AIFFFile::parseMiscellaneous(const Tag &type, size_t size)\n{\n\tint misctype = AF_MISC_UNRECOGNIZED;\n\n\tassert(type == \"NAME\" ||\n\t\ttype == \"AUTH\" ||\n\t\ttype == \"(c) \" ||\n\t\ttype == \"ANNO\" ||\n\t\ttype == \"APPL\" ||\n\t\ttype == \"MIDI\");\n\n\t/* Skip zero-length miscellaneous chunks. */\n\tif (size == 0)\n\t\treturn AF_FAIL;\n\n\tm_miscellaneousCount++;\n\tm_miscellaneous = (Miscellaneous *) _af_realloc(m_miscellaneous,\n\t\tm_miscellaneousCount * sizeof (Miscellaneous));\n\n\tif (type == \"NAME\")\n\t\tmisctype = AF_MISC_NAME;\n\telse if (type == \"AUTH\")\n\t\tmisctype = AF_MISC_AUTH;\n\telse if (type == \"(c) \")\n\t\tmisctype = AF_MISC_COPY;\n\telse if (type == \"ANNO\")\n\t\tmisctype = AF_MISC_ANNO;\n\telse if (type == \"APPL\")\n\t\tmisctype = AF_MISC_APPL;\n\telse if (type == \"MIDI\")\n\t\tmisctype = AF_MISC_MIDI;\n\n\tm_miscellaneous[m_miscellaneousCount - 1].id = m_miscellaneousCount;\n\tm_miscellaneous[m_miscellaneousCount - 1].type = misctype;\n\tm_miscellaneous[m_miscellaneousCount - 1].size = size;\n\tm_miscellaneous[m_miscellaneousCount - 1].position = 0;\n\tm_miscellaneous[m_miscellaneousCount - 1].buffer = _af_malloc(size);\n\tm_fh->read(m_miscellaneous[m_miscellaneousCount - 1].buffer, size);\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::parseMiscellaneous(const Tag &type, size_t size)\n  {\n  \tint misctype = AF_MISC_UNRECOGNIZED;\n  \n  \tassert(type == \"NAME\" ||\n  \t\ttype == \"AUTH\" ||\n  \t\ttype == \"(c) \" ||\n  \t\ttype == \"ANNO\" ||\n  \t\ttype == \"APPL\" ||\n  \t\ttype == \"MIDI\");\n  \n  \t/* Skip zero-length miscellaneous chunks. */\n  \tif (size == 0)\n  \t\treturn AF_FAIL;\n  \n  \tm_miscellaneousCount++;\n  \tm_miscellaneous = (Miscellaneous *) _af_realloc(m_miscellaneous,\n  \t\tm_miscellaneousCount * sizeof (Miscellaneous));\n  \n  \tif (type == \"NAME\")\n  \t\tmisctype = AF_MISC_NAME;\n  \telse if (type == \"AUTH\")\n  \t\tmisctype = AF_MISC_AUTH;\n  \telse if (type == \"(c) \")\n  \t\tmisctype = AF_MISC_COPY;\n  \telse if (type == \"ANNO\")\n  \t\tmisctype = AF_MISC_ANNO;\n  \telse if (type == \"APPL\")\n  \t\tmisctype = AF_MISC_APPL;\n  \telse if (type == \"MIDI\")\n  \t\tmisctype = AF_MISC_MIDI;\n  \n  \tm_miscellaneous[m_miscellaneousCount - 1].id = m_miscellaneousCount;\n  \tm_miscellaneous[m_miscellaneousCount - 1].type = misctype;\n  \tm_miscellaneous[m_miscellaneousCount - 1].size = size;\n  \tm_miscellaneous[m_miscellaneousCount - 1].position = 0;\n  \tm_miscellaneous[m_miscellaneousCount - 1].buffer = _af_malloc(size);\n  \tm_fh->read(m_miscellaneous[m_miscellaneousCount - 1].buffer, size);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseAESD",
          "args": [
            "chunkid",
            "chunksize"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "parseAESD",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "131-152",
          "snippet": "status AIFFFile::parseAESD(const Tag &type, size_t size)\n{\n\tunsigned char aesChannelStatusData[24];\n\n\tassert(type == \"AESD\");\n\tassert(size == 24);\n\n\tTrack *track = getTrack();\n\n\ttrack->hasAESData = true;\n\n\t/*\n\t\tTry to read 24 bytes of AES nonaudio data from the file.\n\t\tFail if the file disappoints.\n\t*/\n\tif (m_fh->read(aesChannelStatusData, 24) != 24)\n\t\treturn AF_FAIL;\n\n\tmemcpy(track->aesData, aesChannelStatusData, 24);\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::parseAESD(const Tag &type, size_t size)\n  {\n  \tunsigned char aesChannelStatusData[24];\n  \n  \tassert(type == \"AESD\");\n  \tassert(size == 24);\n  \n  \tTrack *track = getTrack();\n  \n  \ttrack->hasAESData = true;\n  \n  \t/*\n  \t\tTry to read 24 bytes of AES nonaudio data from the file.\n  \t\tFail if the file disappoints.\n  \t*/\n  \tif (m_fh->read(aesChannelStatusData, 24) != 24)\n  \t\treturn AF_FAIL;\n  \n  \tmemcpy(track->aesData, aesChannelStatusData, 24);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseMARK",
          "args": [
            "chunkid",
            "chunksize"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "parseMARK",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "268-312",
          "snippet": "status AIFFFile::parseMARK(const Tag &type, size_t size)\n{\n\tassert(type == \"MARK\");\n\n\tTrack *track = getTrack();\n\n\tuint16_t numMarkers;\n\treadU16(&numMarkers);\n\n\ttrack->markerCount = numMarkers;\n\tif (numMarkers)\n\t\ttrack->markers = _af_marker_new(numMarkers);\n\n\tfor (unsigned i=0; i<numMarkers; i++)\n\t{\n\t\tuint16_t markerID = 0;\n\t\tuint32_t markerPosition = 0;\n\t\tuint8_t sizeByte = 0;\n\t\tchar *markerName = NULL;\n\n\t\treadU16(&markerID);\n\t\treadU32(&markerPosition);\n\t\tm_fh->read(&sizeByte, 1);\n\t\tmarkerName = (char *) _af_malloc(sizeByte + 1);\n\t\tm_fh->read(markerName, sizeByte);\n\n\t\tmarkerName[sizeByte] = '\\0';\n\n\t\t/*\n\t\t\tIf sizeByte is even, then 1+sizeByte (the length\n\t\t\tof the string) is odd.\tSkip an extra byte to\n\t\t\tmake it even.\n\t\t*/\n\n\t\tif ((sizeByte % 2) == 0)\n\t\t\tm_fh->seek(1, File::SeekFromCurrent);\n\n\t\ttrack->markers[i].id = markerID;\n\t\ttrack->markers[i].position = markerPosition;\n\t\ttrack->markers[i].name = markerName;\n\t\ttrack->markers[i].comment = _af_strdup(\"\");\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::parseMARK(const Tag &type, size_t size)\n  {\n  \tassert(type == \"MARK\");\n  \n  \tTrack *track = getTrack();\n  \n  \tuint16_t numMarkers;\n  \treadU16(&numMarkers);\n  \n  \ttrack->markerCount = numMarkers;\n  \tif (numMarkers)\n  \t\ttrack->markers = _af_marker_new(numMarkers);\n  \n  \tfor (unsigned i=0; i<numMarkers; i++)\n  \t{\n  \t\tuint16_t markerID = 0;\n  \t\tuint32_t markerPosition = 0;\n  \t\tuint8_t sizeByte = 0;\n  \t\tchar *markerName = NULL;\n  \n  \t\treadU16(&markerID);\n  \t\treadU32(&markerPosition);\n  \t\tm_fh->read(&sizeByte, 1);\n  \t\tmarkerName = (char *) _af_malloc(sizeByte + 1);\n  \t\tm_fh->read(markerName, sizeByte);\n  \n  \t\tmarkerName[sizeByte] = '\\0';\n  \n  \t\t/*\n  \t\t\tIf sizeByte is even, then 1+sizeByte (the length\n  \t\t\tof the string) is odd.\tSkip an extra byte to\n  \t\t\tmake it even.\n  \t\t*/\n  \n  \t\tif ((sizeByte % 2) == 0)\n  \t\t\tm_fh->seek(1, File::SeekFromCurrent);\n  \n  \t\ttrack->markers[i].id = markerID;\n  \t\ttrack->markers[i].position = markerPosition;\n  \t\ttrack->markers[i].name = markerName;\n  \t\ttrack->markers[i].comment = _af_strdup(\"\");\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseINST",
          "args": [
            "chunkid",
            "chunksize"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "parseINST",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "204-263",
          "snippet": "status AIFFFile::parseINST(const Tag &type, size_t size)\n{\n\tuint8_t baseNote;\n\tint8_t detune;\n\tuint8_t lowNote, highNote, lowVelocity, highVelocity;\n\tint16_t gain;\n\n\tuint16_t sustainLoopPlayMode, sustainLoopBegin, sustainLoopEnd;\n\tuint16_t releaseLoopPlayMode, releaseLoopBegin, releaseLoopEnd;\n\n\tInstrument *instrument = (Instrument *) _af_calloc(1, sizeof (Instrument));\n\tinstrument->id = AF_DEFAULT_INST;\n\tinstrument->values = (AFPVu *) _af_calloc(_AF_AIFF_NUM_INSTPARAMS, sizeof (AFPVu));\n\tinstrument->loopCount = 2;\n\tinstrument->loops = (Loop *) _af_calloc(2, sizeof (Loop));\n\n\tm_instrumentCount = 1;\n\tm_instruments = instrument;\n\n\treadU8(&baseNote);\n\treadS8(&detune);\n\treadU8(&lowNote);\n\treadU8(&highNote);\n\treadU8(&lowVelocity);\n\treadU8(&highVelocity);\n\treadS16(&gain);\n\n\tinstrument->values[0].l = baseNote;\n\tinstrument->values[1].l = detune;\n\tinstrument->values[2].l = lowVelocity;\n\tinstrument->values[3].l = highVelocity;\n\tinstrument->values[4].l = lowNote;\n\tinstrument->values[5].l = highNote;\n\tinstrument->values[6].l = gain;\n\n\tinstrument->values[7].l = 1;\t/* sustain loop id */\n\tinstrument->values[8].l = 2;\t/* release loop id */\n\n\treadU16(&sustainLoopPlayMode);\n\treadU16(&sustainLoopBegin);\n\treadU16(&sustainLoopEnd);\n\n\treadU16(&releaseLoopPlayMode);\n\treadU16(&releaseLoopBegin);\n\treadU16(&releaseLoopEnd);\n\n\tinstrument->loops[0].id = 1;\n\tinstrument->loops[0].mode = sustainLoopPlayMode;\n\tinstrument->loops[0].beginMarker = sustainLoopBegin;\n\tinstrument->loops[0].endMarker = sustainLoopEnd;\n\tinstrument->loops[0].trackid = AF_DEFAULT_TRACK;\n\n\tinstrument->loops[1].id = 2;\n\tinstrument->loops[1].mode = releaseLoopPlayMode;\n\tinstrument->loops[1].beginMarker = releaseLoopBegin;\n\tinstrument->loops[1].endMarker = releaseLoopEnd;\n\tinstrument->loops[1].trackid = AF_DEFAULT_TRACK;\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::parseINST(const Tag &type, size_t size)\n  {\n  \tuint8_t baseNote;\n  \tint8_t detune;\n  \tuint8_t lowNote, highNote, lowVelocity, highVelocity;\n  \tint16_t gain;\n  \n  \tuint16_t sustainLoopPlayMode, sustainLoopBegin, sustainLoopEnd;\n  \tuint16_t releaseLoopPlayMode, releaseLoopBegin, releaseLoopEnd;\n  \n  \tInstrument *instrument = (Instrument *) _af_calloc(1, sizeof (Instrument));\n  \tinstrument->id = AF_DEFAULT_INST;\n  \tinstrument->values = (AFPVu *) _af_calloc(_AF_AIFF_NUM_INSTPARAMS, sizeof (AFPVu));\n  \tinstrument->loopCount = 2;\n  \tinstrument->loops = (Loop *) _af_calloc(2, sizeof (Loop));\n  \n  \tm_instrumentCount = 1;\n  \tm_instruments = instrument;\n  \n  \treadU8(&baseNote);\n  \treadS8(&detune);\n  \treadU8(&lowNote);\n  \treadU8(&highNote);\n  \treadU8(&lowVelocity);\n  \treadU8(&highVelocity);\n  \treadS16(&gain);\n  \n  \tinstrument->values[0].l = baseNote;\n  \tinstrument->values[1].l = detune;\n  \tinstrument->values[2].l = lowVelocity;\n  \tinstrument->values[3].l = highVelocity;\n  \tinstrument->values[4].l = lowNote;\n  \tinstrument->values[5].l = highNote;\n  \tinstrument->values[6].l = gain;\n  \n  \tinstrument->values[7].l = 1;\t/* sustain loop id */\n  \tinstrument->values[8].l = 2;\t/* release loop id */\n  \n  \treadU16(&sustainLoopPlayMode);\n  \treadU16(&sustainLoopBegin);\n  \treadU16(&sustainLoopEnd);\n  \n  \treadU16(&releaseLoopPlayMode);\n  \treadU16(&releaseLoopBegin);\n  \treadU16(&releaseLoopEnd);\n  \n  \tinstrument->loops[0].id = 1;\n  \tinstrument->loops[0].mode = sustainLoopPlayMode;\n  \tinstrument->loops[0].beginMarker = sustainLoopBegin;\n  \tinstrument->loops[0].endMarker = sustainLoopEnd;\n  \tinstrument->loops[0].trackid = AF_DEFAULT_TRACK;\n  \n  \tinstrument->loops[1].id = 2;\n  \tinstrument->loops[1].mode = releaseLoopPlayMode;\n  \tinstrument->loops[1].beginMarker = releaseLoopBegin;\n  \tinstrument->loops[1].endMarker = releaseLoopEnd;\n  \tinstrument->loops[1].trackid = AF_DEFAULT_TRACK;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseFVER",
          "args": [
            "chunkid",
            "chunksize"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "parseFVER",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "117-126",
          "snippet": "status AIFFFile::parseFVER(const Tag &type, size_t size)\n{\n\tassert(type == \"FVER\");\n\n\tuint32_t timestamp;\n\treadU32(&timestamp);\n\t/* timestamp holds the number of seconds since January 1, 1904. */\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::parseFVER(const Tag &type, size_t size)\n  {\n  \tassert(type == \"FVER\");\n  \n  \tuint32_t timestamp;\n  \treadU32(&timestamp);\n  \t/* timestamp holds the number of seconds since January 1, 1904. */\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseCOMM",
          "args": [
            "chunkid",
            "chunksize"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "parseCOMM",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "319-444",
          "snippet": "status AIFFFile::parseCOMM(const Tag &type, size_t size)\n{\n\tassert(type == \"COMM\");\n\n\tTrack *track = getTrack();\n\n\tuint16_t numChannels;\n\tuint32_t numSampleFrames;\n\tuint16_t sampleSize;\n\tunsigned char sampleRate[10];\n\n\treadU16(&numChannels);\n\ttrack->f.channelCount = numChannels;\n\n\tif (!numChannels)\n\t{\n\t\t_af_error(AF_BAD_CHANNELS, \"invalid file with 0 channels\");\n\t\treturn AF_FAIL;\n\t}\n\n\treadU32(&numSampleFrames);\n\ttrack->totalfframes = numSampleFrames;\n\n\treadU16(&sampleSize);\n\ttrack->f.sampleWidth = sampleSize;\n\n\tm_fh->read(sampleRate, 10);\n\ttrack->f.sampleRate = _af_convert_from_ieee_extended(sampleRate);\n\n\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\ttrack->f.byteOrder = AF_BYTEORDER_BIGENDIAN;\n\n\ttrack->f.framesPerPacket = 1;\n\n\tif (isAIFFC())\n\t{\n\t\tTag compressionID;\n\t\t// Pascal strings are at most 255 bytes long.\n\t\tchar compressionName[256];\n\n\t\treadTag(&compressionID);\n\n\t\t// Read the Pascal-style string containing the name.\n\t\treadPString(compressionName);\n\n\t\tif (compressionID == \"NONE\" || compressionID == \"twos\")\n\t\t{\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\t\t}\n\t\telse if (compressionID == \"in24\")\n\t\t{\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\t\t\ttrack->f.sampleWidth = 24;\n\t\t}\n\t\telse if (compressionID == \"in32\")\n\t\t{\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\t\t\ttrack->f.sampleWidth = 32;\n\t\t}\n\t\telse if (compressionID == \"ACE2\" ||\n\t\t\tcompressionID == \"ACE8\" ||\n\t\t\tcompressionID == \"MAC3\" ||\n\t\t\tcompressionID == \"MAC6\")\n\t\t{\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"AIFF-C format does not support Apple's proprietary %s compression format\", compressionName);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (compressionID == \"ulaw\" || compressionID == \"ULAW\")\n\t\t{\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n\t\t}\n\t\telse if (compressionID == \"alaw\" || compressionID == \"ALAW\")\n\t\t{\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n\t\t}\n\t\telse if (compressionID == \"fl32\" || compressionID == \"FL32\")\n\t\t{\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n\t\t\ttrack->f.sampleWidth = 32;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\t\t}\n\t\telse if (compressionID == \"fl64\" || compressionID == \"FL64\")\n\t\t{\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n\t\t\ttrack->f.sampleWidth = 64;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\t\t}\n\t\telse if (compressionID == \"sowt\")\n\t\t{\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\t\t\ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n\t\t}\n\t\telse if (compressionID == \"ima4\")\n\t\t{\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_IMA;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\t\t\tinitIMACompressionParams();\n\n\t\t\ttrack->totalfframes *= 64;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"AIFF-C compression type '%s' not currently supported\",\n\t\t\t\tcompressionID.name().c_str());\n\t\t\treturn AF_FAIL;\n\t\t}\n\t}\n\n\tif (track->f.isUncompressed())\n\t\ttrack->f.computeBytesPerPacketPCM();\n\n\tif (_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth) == AF_FAIL)\n\t\treturn AF_FAIL;\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::parseCOMM(const Tag &type, size_t size)\n  {\n  \tassert(type == \"COMM\");\n  \n  \tTrack *track = getTrack();\n  \n  \tuint16_t numChannels;\n  \tuint32_t numSampleFrames;\n  \tuint16_t sampleSize;\n  \tunsigned char sampleRate[10];\n  \n  \treadU16(&numChannels);\n  \ttrack->f.channelCount = numChannels;\n  \n  \tif (!numChannels)\n  \t{\n  \t\t_af_error(AF_BAD_CHANNELS, \"invalid file with 0 channels\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \treadU32(&numSampleFrames);\n  \ttrack->totalfframes = numSampleFrames;\n  \n  \treadU16(&sampleSize);\n  \ttrack->f.sampleWidth = sampleSize;\n  \n  \tm_fh->read(sampleRate, 10);\n  \ttrack->f.sampleRate = _af_convert_from_ieee_extended(sampleRate);\n  \n  \ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \ttrack->f.byteOrder = AF_BYTEORDER_BIGENDIAN;\n  \n  \ttrack->f.framesPerPacket = 1;\n  \n  \tif (isAIFFC())\n  \t{\n  \t\tTag compressionID;\n  \t\t// Pascal strings are at most 255 bytes long.\n  \t\tchar compressionName[256];\n  \n  \t\treadTag(&compressionID);\n  \n  \t\t// Read the Pascal-style string containing the name.\n  \t\treadPString(compressionName);\n  \n  \t\tif (compressionID == \"NONE\" || compressionID == \"twos\")\n  \t\t{\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \t\t}\n  \t\telse if (compressionID == \"in24\")\n  \t\t{\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \t\t\ttrack->f.sampleWidth = 24;\n  \t\t}\n  \t\telse if (compressionID == \"in32\")\n  \t\t{\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \t\t\ttrack->f.sampleWidth = 32;\n  \t\t}\n  \t\telse if (compressionID == \"ACE2\" ||\n  \t\t\tcompressionID == \"ACE8\" ||\n  \t\t\tcompressionID == \"MAC3\" ||\n  \t\t\tcompressionID == \"MAC6\")\n  \t\t{\n  \t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"AIFF-C format does not support Apple's proprietary %s compression format\", compressionName);\n  \t\t\treturn AF_FAIL;\n  \t\t}\n  \t\telse if (compressionID == \"ulaw\" || compressionID == \"ULAW\")\n  \t\t{\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n  \t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t\t\ttrack->f.sampleWidth = 16;\n  \t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n  \t\t}\n  \t\telse if (compressionID == \"alaw\" || compressionID == \"ALAW\")\n  \t\t{\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n  \t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t\t\ttrack->f.sampleWidth = 16;\n  \t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n  \t\t}\n  \t\telse if (compressionID == \"fl32\" || compressionID == \"FL32\")\n  \t\t{\n  \t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n  \t\t\ttrack->f.sampleWidth = 32;\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \t\t}\n  \t\telse if (compressionID == \"fl64\" || compressionID == \"FL64\")\n  \t\t{\n  \t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n  \t\t\ttrack->f.sampleWidth = 64;\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \t\t}\n  \t\telse if (compressionID == \"sowt\")\n  \t\t{\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \t\t\ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n  \t\t}\n  \t\telse if (compressionID == \"ima4\")\n  \t\t{\n  \t\t\ttrack->f.sampleWidth = 16;\n  \t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_IMA;\n  \t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \n  \t\t\tinitIMACompressionParams();\n  \n  \t\t\ttrack->totalfframes *= 64;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"AIFF-C compression type '%s' not currently supported\",\n  \t\t\t\tcompressionID.name().c_str());\n  \t\t\treturn AF_FAIL;\n  \t\t}\n  \t}\n  \n  \tif (track->f.isUncompressed())\n  \t\ttrack->f.computeBytesPerPacketPCM();\n  \n  \tif (_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readU32",
          "args": [
            "&chunksize"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "readU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "400-403",
          "snippet": "bool _AFfilehandle::readU32(uint32_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU32(uint32_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readTag",
          "args": [
            "&chunkid"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "readTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "473-482",
          "snippet": "bool _AFfilehandle::readTag(Tag *t)\n{\n\tuint32_t v;\n\tif (m_fh->read(&v, sizeof (v)) == sizeof (v))\n\t{\n\t\t*t = Tag(v);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readTag(Tag *t)\n  {\n  \tuint32_t v;\n  \tif (m_fh->read(&v, sizeof (v)) == sizeof (v))\n  \t{\n  \t\t*t = Tag(v);\n  \t\treturn true;\n  \t}\n  \treturn false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocateTrack",
          "args": [],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&formtype",
            "\"AIFC\"",
            "4"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&formtype",
            "\"AIFF\"",
            "4"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&type",
            "\"FORM\"",
            "4"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fh->read",
          "args": [
            "&formtype",
            "4"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::readInit(AFfilesetup setup)\n  {\n  \tuint32_t type, size, formtype;\n  \n  \tbool hasCOMM = false;\n  \tbool hasFVER = false;\n  \tbool hasSSND = false;\n  \n  \tm_fh->seek(0, File::SeekFromBeginning);\n  \n  \tm_fh->read(&type, 4);\n  \treadU32(&size);\n  \tm_fh->read(&formtype, 4);\n  \n  \tif (memcmp(&type, \"FORM\", 4) != 0 ||\n  \t\t(memcmp(&formtype, \"AIFF\", 4) && memcmp(&formtype, \"AIFC\", 4)))\n  \t\treturn AF_FAIL;\n  \n  \tif (!allocateTrack())\n  \t\treturn AF_FAIL;\n  \n  \t/* Include the offset of the form type. */\n  \tsize_t index = 4;\n  \twhile (index < size)\n  \t{\n  \t\tTag chunkid;\n  \t\tuint32_t chunksize = 0;\n  \t\tstatus result = AF_SUCCEED;\n  \n  \t\treadTag(&chunkid);\n  \t\treadU32(&chunksize);\n  \n  \t\tif (chunkid == \"COMM\")\n  \t\t{\n  \t\t\thasCOMM = true;\n  \t\t\tresult = parseCOMM(chunkid, chunksize);\n  \t\t}\n  \t\telse if (chunkid == \"FVER\")\n  \t\t{\n  \t\t\thasFVER = true;\n  \t\t\tparseFVER(chunkid, chunksize);\n  \t\t}\n  \t\telse if (chunkid == \"INST\")\n  \t\t{\n  \t\t\tparseINST(chunkid, chunksize);\n  \t\t}\n  \t\telse if (chunkid == \"MARK\")\n  \t\t{\n  \t\t\tparseMARK(chunkid, chunksize);\n  \t\t}\n  \t\telse if (chunkid == \"AESD\")\n  \t\t{\n  \t\t\tparseAESD(chunkid, chunksize);\n  \t\t}\n  \t\telse if (chunkid == \"NAME\" ||\n  \t\t\tchunkid == \"AUTH\" ||\n  \t\t\tchunkid == \"(c) \" ||\n  \t\t\tchunkid == \"ANNO\" ||\n  \t\t\tchunkid == \"APPL\" ||\n  \t\t\tchunkid == \"MIDI\")\n  \t\t{\n  \t\t\tparseMiscellaneous(chunkid, chunksize);\n  \t\t}\n  \t\t/*\n  \t\t\tThe sound data chunk is required if there are more than\n  \t\t\tzero sample frames.\n  \t\t*/\n  \t\telse if (chunkid == \"SSND\")\n  \t\t{\n  \t\t\tif (hasSSND)\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_AIFF_SSND, \"AIFF file has more than one SSND chunk\");\n  \t\t\t\treturn AF_FAIL;\n  \t\t\t}\n  \t\t\thasSSND = true;\n  \t\t\tresult = parseSSND(chunkid, chunksize);\n  \t\t}\n  \n  \t\tif (result == AF_FAIL)\n  \t\t\treturn AF_FAIL;\n  \n  \t\tindex += chunksize + 8;\n  \n  \t\t/* all chunks must be aligned on an even number of bytes */\n  \t\tif ((index % 2) != 0)\n  \t\t\tindex++;\n  \n  \t\tm_fh->seek(index + 8, File::SeekFromBeginning);\n  \t}\n  \n  \tif (!hasCOMM)\n  \t{\n  \t\t_af_error(AF_BAD_AIFF_COMM, \"bad AIFF COMM chunk\");\n  \t}\n  \n  \tif (isAIFFC() && !hasFVER)\n  \t{\n  \t\t_af_error(AF_BAD_HEADER, \"FVER chunk is required in AIFF-C\");\n  \t}\n  \n  \t/* The file has been successfully parsed. */\n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseSSND",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "450-465",
    "snippet": "status AIFFFile::parseSSND(const Tag &type, size_t size)\n{\n\tassert(type == \"SSND\");\n\n\tTrack *track = getTrack();\n\n\tuint32_t offset, blockSize;\n\treadU32(&offset);\n\treadU32(&blockSize);\n\n\ttrack->data_size = size - 8 - offset;\n\n\ttrack->fpos_first_frame = m_fh->tell() + offset;\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readU32",
          "args": [
            "&blockSize"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "readU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "400-403",
          "snippet": "bool _AFfilehandle::readU32(uint32_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU32(uint32_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "type == \"SSND\""
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::parseSSND(const Tag &type, size_t size)\n  {\n  \tassert(type == \"SSND\");\n  \n  \tTrack *track = getTrack();\n  \n  \tuint32_t offset, blockSize;\n  \treadU32(&offset);\n  \treadU32(&blockSize);\n  \n  \ttrack->data_size = size - 8 - offset;\n  \n  \ttrack->fpos_first_frame = m_fh->tell() + offset;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseCOMM",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "319-444",
    "snippet": "status AIFFFile::parseCOMM(const Tag &type, size_t size)\n{\n\tassert(type == \"COMM\");\n\n\tTrack *track = getTrack();\n\n\tuint16_t numChannels;\n\tuint32_t numSampleFrames;\n\tuint16_t sampleSize;\n\tunsigned char sampleRate[10];\n\n\treadU16(&numChannels);\n\ttrack->f.channelCount = numChannels;\n\n\tif (!numChannels)\n\t{\n\t\t_af_error(AF_BAD_CHANNELS, \"invalid file with 0 channels\");\n\t\treturn AF_FAIL;\n\t}\n\n\treadU32(&numSampleFrames);\n\ttrack->totalfframes = numSampleFrames;\n\n\treadU16(&sampleSize);\n\ttrack->f.sampleWidth = sampleSize;\n\n\tm_fh->read(sampleRate, 10);\n\ttrack->f.sampleRate = _af_convert_from_ieee_extended(sampleRate);\n\n\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\ttrack->f.byteOrder = AF_BYTEORDER_BIGENDIAN;\n\n\ttrack->f.framesPerPacket = 1;\n\n\tif (isAIFFC())\n\t{\n\t\tTag compressionID;\n\t\t// Pascal strings are at most 255 bytes long.\n\t\tchar compressionName[256];\n\n\t\treadTag(&compressionID);\n\n\t\t// Read the Pascal-style string containing the name.\n\t\treadPString(compressionName);\n\n\t\tif (compressionID == \"NONE\" || compressionID == \"twos\")\n\t\t{\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\t\t}\n\t\telse if (compressionID == \"in24\")\n\t\t{\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\t\t\ttrack->f.sampleWidth = 24;\n\t\t}\n\t\telse if (compressionID == \"in32\")\n\t\t{\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\t\t\ttrack->f.sampleWidth = 32;\n\t\t}\n\t\telse if (compressionID == \"ACE2\" ||\n\t\t\tcompressionID == \"ACE8\" ||\n\t\t\tcompressionID == \"MAC3\" ||\n\t\t\tcompressionID == \"MAC6\")\n\t\t{\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"AIFF-C format does not support Apple's proprietary %s compression format\", compressionName);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (compressionID == \"ulaw\" || compressionID == \"ULAW\")\n\t\t{\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n\t\t}\n\t\telse if (compressionID == \"alaw\" || compressionID == \"ALAW\")\n\t\t{\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n\t\t}\n\t\telse if (compressionID == \"fl32\" || compressionID == \"FL32\")\n\t\t{\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n\t\t\ttrack->f.sampleWidth = 32;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\t\t}\n\t\telse if (compressionID == \"fl64\" || compressionID == \"FL64\")\n\t\t{\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n\t\t\ttrack->f.sampleWidth = 64;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\t\t}\n\t\telse if (compressionID == \"sowt\")\n\t\t{\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\t\t\ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n\t\t}\n\t\telse if (compressionID == \"ima4\")\n\t\t{\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_IMA;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\t\t\tinitIMACompressionParams();\n\n\t\t\ttrack->totalfframes *= 64;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"AIFF-C compression type '%s' not currently supported\",\n\t\t\t\tcompressionID.name().c_str());\n\t\t\treturn AF_FAIL;\n\t\t}\n\t}\n\n\tif (track->f.isUncompressed())\n\t\ttrack->f.computeBytesPerPacketPCM();\n\n\tif (_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth) == AF_FAIL)\n\t\treturn AF_FAIL;\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_set_sample_format",
          "args": [
            "&track->f",
            "track->f.sampleFormat",
            "track->f.sampleWidth"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "_af_set_sample_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "315-361",
          "snippet": "status _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatus _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->f.computeBytesPerPacketPCM",
          "args": [],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "computeBytesPerPacketPCM",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "98-103",
          "snippet": "void AudioFormat::computeBytesPerPacketPCM()\n{\n\tassert(isUncompressed());\n\tint bytesPerSample = (sampleWidth + 7) / 8;\n\tbytesPerPacket = bytesPerSample * channelCount;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  void AudioFormat::computeBytesPerPacketPCM()\n  {\n  \tassert(isUncompressed());\n  \tint bytesPerSample = (sampleWidth + 7) / 8;\n  \tbytesPerPacket = bytesPerSample * channelCount;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->f.isUncompressed",
          "args": [],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "isUncompressed",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "93-96",
          "snippet": "bool AudioFormat::isUncompressed() const\n{\n\treturn compressionType == AF_COMPRESSION_NONE;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  bool AudioFormat::isUncompressed() const\n  {\n  \treturn compressionType == AF_COMPRESSION_NONE;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"AIFF-C compression type '%s' not currently supported\"",
            "compressionID.name().c_str()"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compressionID.name",
          "args": [],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Tag",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Tag.h",
          "lines": "45-51",
          "snippet": "std::string name() const\n\t{\n\t\tchar s[5];\n\t\tmemcpy(s, &m_value, 4);\n\t\ts[4] = '\\0';\n\t\treturn std::string(s);\n\t}",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stdint.h>\n#include <assert.h>\n\nTag {\n  std::string name() const\n  \t{\n  \t\tchar s[5];\n  \t\tmemcpy(s, &m_value, 4);\n  \t\ts[4] = '\\0';\n  \t\treturn std::string(s);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "initIMACompressionParams",
          "args": [],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "initIMACompressionParams",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "1170-1184",
          "snippet": "void AIFFFile::initIMACompressionParams()\n{\n\tTrack *track = getTrack();\n\n\ttrack->f.bytesPerPacket = 34 * track->f.channelCount;\n\ttrack->f.framesPerPacket = 64;\n\n\tAUpvlist pv = AUpvnew(1);\n\tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = _AF_IMA_ADPCM_TYPE_QT;\n\tAUpvsetval(pv, 0, &l);\n\n\ttrack->f.compressionParams = pv;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  void AIFFFile::initIMACompressionParams()\n  {\n  \tTrack *track = getTrack();\n  \n  \ttrack->f.bytesPerPacket = 34 * track->f.channelCount;\n  \ttrack->f.framesPerPacket = 64;\n  \n  \tAUpvlist pv = AUpvnew(1);\n  \tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n  \tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n  \tlong l = _AF_IMA_ADPCM_TYPE_QT;\n  \tAUpvsetval(pv, 0, &l);\n  \n  \ttrack->f.compressionParams = pv;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"AIFF-C format does not support Apple's proprietary %s compression format\"",
            "compressionName"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readPString",
          "args": [
            "compressionName"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "readPString",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
          "lines": "1187-1196",
          "snippet": "bool AIFFFile::readPString(char s[256])\n{\n\tuint8_t length;\n\tif (m_fh->read(&length, 1) != 1)\n\t\treturn false;\n\tif (m_fh->read(s, length) != static_cast<ssize_t>(length))\n\t\treturn false;\n\ts[length] = '\\0';\n\treturn true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"extended.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"AIFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  bool AIFFFile::readPString(char s[256])\n  {\n  \tuint8_t length;\n  \tif (m_fh->read(&length, 1) != 1)\n  \t\treturn false;\n  \tif (m_fh->read(s, length) != static_cast<ssize_t>(length))\n  \t\treturn false;\n  \ts[length] = '\\0';\n  \treturn true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readTag",
          "args": [
            "&compressionID"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "readTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "473-482",
          "snippet": "bool _AFfilehandle::readTag(Tag *t)\n{\n\tuint32_t v;\n\tif (m_fh->read(&v, sizeof (v)) == sizeof (v))\n\t{\n\t\t*t = Tag(v);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readTag(Tag *t)\n  {\n  \tuint32_t v;\n  \tif (m_fh->read(&v, sizeof (v)) == sizeof (v))\n  \t{\n  \t\t*t = Tag(v);\n  \t\treturn true;\n  \t}\n  \treturn false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isAIFFC",
          "args": [],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "isAIFFC",
          "container": "AIFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.h",
          "lines": "86-86",
          "snippet": "bool isAIFFC() const { return m_fileFormat == AF_FILE_AIFFC; }",
          "includes": [
            "#include \"FileHandle.h\"",
            "#include \"Compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FileHandle.h\"\n#include \"Compiler.h\"\n\nAIFFFile {\n  bool isAIFFC() const { return m_fileFormat == AF_FILE_AIFFC; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_convert_from_ieee_extended",
          "args": [
            "sampleRate"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fh->read",
          "args": [
            "sampleRate",
            "10"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readU16",
          "args": [
            "&sampleSize"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "readU16",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "390-393",
          "snippet": "bool _AFfilehandle::readU16(uint16_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU16(uint16_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readU32",
          "args": [
            "&numSampleFrames"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "readU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "400-403",
          "snippet": "bool _AFfilehandle::readU32(uint32_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU32(uint32_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_CHANNELS",
            "\"invalid file with 0 channels\""
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "type == \"COMM\""
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::parseCOMM(const Tag &type, size_t size)\n  {\n  \tassert(type == \"COMM\");\n  \n  \tTrack *track = getTrack();\n  \n  \tuint16_t numChannels;\n  \tuint32_t numSampleFrames;\n  \tuint16_t sampleSize;\n  \tunsigned char sampleRate[10];\n  \n  \treadU16(&numChannels);\n  \ttrack->f.channelCount = numChannels;\n  \n  \tif (!numChannels)\n  \t{\n  \t\t_af_error(AF_BAD_CHANNELS, \"invalid file with 0 channels\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \treadU32(&numSampleFrames);\n  \ttrack->totalfframes = numSampleFrames;\n  \n  \treadU16(&sampleSize);\n  \ttrack->f.sampleWidth = sampleSize;\n  \n  \tm_fh->read(sampleRate, 10);\n  \ttrack->f.sampleRate = _af_convert_from_ieee_extended(sampleRate);\n  \n  \ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \ttrack->f.byteOrder = AF_BYTEORDER_BIGENDIAN;\n  \n  \ttrack->f.framesPerPacket = 1;\n  \n  \tif (isAIFFC())\n  \t{\n  \t\tTag compressionID;\n  \t\t// Pascal strings are at most 255 bytes long.\n  \t\tchar compressionName[256];\n  \n  \t\treadTag(&compressionID);\n  \n  \t\t// Read the Pascal-style string containing the name.\n  \t\treadPString(compressionName);\n  \n  \t\tif (compressionID == \"NONE\" || compressionID == \"twos\")\n  \t\t{\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \t\t}\n  \t\telse if (compressionID == \"in24\")\n  \t\t{\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \t\t\ttrack->f.sampleWidth = 24;\n  \t\t}\n  \t\telse if (compressionID == \"in32\")\n  \t\t{\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \t\t\ttrack->f.sampleWidth = 32;\n  \t\t}\n  \t\telse if (compressionID == \"ACE2\" ||\n  \t\t\tcompressionID == \"ACE8\" ||\n  \t\t\tcompressionID == \"MAC3\" ||\n  \t\t\tcompressionID == \"MAC6\")\n  \t\t{\n  \t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"AIFF-C format does not support Apple's proprietary %s compression format\", compressionName);\n  \t\t\treturn AF_FAIL;\n  \t\t}\n  \t\telse if (compressionID == \"ulaw\" || compressionID == \"ULAW\")\n  \t\t{\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n  \t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t\t\ttrack->f.sampleWidth = 16;\n  \t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n  \t\t}\n  \t\telse if (compressionID == \"alaw\" || compressionID == \"ALAW\")\n  \t\t{\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n  \t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t\t\ttrack->f.sampleWidth = 16;\n  \t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n  \t\t}\n  \t\telse if (compressionID == \"fl32\" || compressionID == \"FL32\")\n  \t\t{\n  \t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n  \t\t\ttrack->f.sampleWidth = 32;\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \t\t}\n  \t\telse if (compressionID == \"fl64\" || compressionID == \"FL64\")\n  \t\t{\n  \t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n  \t\t\ttrack->f.sampleWidth = 64;\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \t\t}\n  \t\telse if (compressionID == \"sowt\")\n  \t\t{\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \t\t\ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n  \t\t}\n  \t\telse if (compressionID == \"ima4\")\n  \t\t{\n  \t\t\ttrack->f.sampleWidth = 16;\n  \t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_IMA;\n  \t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \n  \t\t\tinitIMACompressionParams();\n  \n  \t\t\ttrack->totalfframes *= 64;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"AIFF-C compression type '%s' not currently supported\",\n  \t\t\t\tcompressionID.name().c_str());\n  \t\t\treturn AF_FAIL;\n  \t\t}\n  \t}\n  \n  \tif (track->f.isUncompressed())\n  \t\ttrack->f.computeBytesPerPacketPCM();\n  \n  \tif (_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseMARK",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "268-312",
    "snippet": "status AIFFFile::parseMARK(const Tag &type, size_t size)\n{\n\tassert(type == \"MARK\");\n\n\tTrack *track = getTrack();\n\n\tuint16_t numMarkers;\n\treadU16(&numMarkers);\n\n\ttrack->markerCount = numMarkers;\n\tif (numMarkers)\n\t\ttrack->markers = _af_marker_new(numMarkers);\n\n\tfor (unsigned i=0; i<numMarkers; i++)\n\t{\n\t\tuint16_t markerID = 0;\n\t\tuint32_t markerPosition = 0;\n\t\tuint8_t sizeByte = 0;\n\t\tchar *markerName = NULL;\n\n\t\treadU16(&markerID);\n\t\treadU32(&markerPosition);\n\t\tm_fh->read(&sizeByte, 1);\n\t\tmarkerName = (char *) _af_malloc(sizeByte + 1);\n\t\tm_fh->read(markerName, sizeByte);\n\n\t\tmarkerName[sizeByte] = '\\0';\n\n\t\t/*\n\t\t\tIf sizeByte is even, then 1+sizeByte (the length\n\t\t\tof the string) is odd.\tSkip an extra byte to\n\t\t\tmake it even.\n\t\t*/\n\n\t\tif ((sizeByte % 2) == 0)\n\t\t\tm_fh->seek(1, File::SeekFromCurrent);\n\n\t\ttrack->markers[i].id = markerID;\n\t\ttrack->markers[i].position = markerPosition;\n\t\ttrack->markers[i].name = markerName;\n\t\ttrack->markers[i].comment = _af_strdup(\"\");\n\t}\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_strdup",
          "args": [
            "\"\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "1",
            "File::SeekFromCurrent"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->read",
          "args": [
            "markerName",
            "sizeByte"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_malloc",
          "args": [
            "sizeByte + 1"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readU32",
          "args": [
            "&markerPosition"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "readU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "400-403",
          "snippet": "bool _AFfilehandle::readU32(uint32_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU32(uint32_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readU16",
          "args": [
            "&markerID"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "readU16",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "390-393",
          "snippet": "bool _AFfilehandle::readU16(uint16_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU16(uint16_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_marker_new",
          "args": [
            "numMarkers"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "type == \"MARK\""
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::parseMARK(const Tag &type, size_t size)\n  {\n  \tassert(type == \"MARK\");\n  \n  \tTrack *track = getTrack();\n  \n  \tuint16_t numMarkers;\n  \treadU16(&numMarkers);\n  \n  \ttrack->markerCount = numMarkers;\n  \tif (numMarkers)\n  \t\ttrack->markers = _af_marker_new(numMarkers);\n  \n  \tfor (unsigned i=0; i<numMarkers; i++)\n  \t{\n  \t\tuint16_t markerID = 0;\n  \t\tuint32_t markerPosition = 0;\n  \t\tuint8_t sizeByte = 0;\n  \t\tchar *markerName = NULL;\n  \n  \t\treadU16(&markerID);\n  \t\treadU32(&markerPosition);\n  \t\tm_fh->read(&sizeByte, 1);\n  \t\tmarkerName = (char *) _af_malloc(sizeByte + 1);\n  \t\tm_fh->read(markerName, sizeByte);\n  \n  \t\tmarkerName[sizeByte] = '\\0';\n  \n  \t\t/*\n  \t\t\tIf sizeByte is even, then 1+sizeByte (the length\n  \t\t\tof the string) is odd.\tSkip an extra byte to\n  \t\t\tmake it even.\n  \t\t*/\n  \n  \t\tif ((sizeByte % 2) == 0)\n  \t\t\tm_fh->seek(1, File::SeekFromCurrent);\n  \n  \t\ttrack->markers[i].id = markerID;\n  \t\ttrack->markers[i].position = markerPosition;\n  \t\ttrack->markers[i].name = markerName;\n  \t\ttrack->markers[i].comment = _af_strdup(\"\");\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseINST",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "204-263",
    "snippet": "status AIFFFile::parseINST(const Tag &type, size_t size)\n{\n\tuint8_t baseNote;\n\tint8_t detune;\n\tuint8_t lowNote, highNote, lowVelocity, highVelocity;\n\tint16_t gain;\n\n\tuint16_t sustainLoopPlayMode, sustainLoopBegin, sustainLoopEnd;\n\tuint16_t releaseLoopPlayMode, releaseLoopBegin, releaseLoopEnd;\n\n\tInstrument *instrument = (Instrument *) _af_calloc(1, sizeof (Instrument));\n\tinstrument->id = AF_DEFAULT_INST;\n\tinstrument->values = (AFPVu *) _af_calloc(_AF_AIFF_NUM_INSTPARAMS, sizeof (AFPVu));\n\tinstrument->loopCount = 2;\n\tinstrument->loops = (Loop *) _af_calloc(2, sizeof (Loop));\n\n\tm_instrumentCount = 1;\n\tm_instruments = instrument;\n\n\treadU8(&baseNote);\n\treadS8(&detune);\n\treadU8(&lowNote);\n\treadU8(&highNote);\n\treadU8(&lowVelocity);\n\treadU8(&highVelocity);\n\treadS16(&gain);\n\n\tinstrument->values[0].l = baseNote;\n\tinstrument->values[1].l = detune;\n\tinstrument->values[2].l = lowVelocity;\n\tinstrument->values[3].l = highVelocity;\n\tinstrument->values[4].l = lowNote;\n\tinstrument->values[5].l = highNote;\n\tinstrument->values[6].l = gain;\n\n\tinstrument->values[7].l = 1;\t/* sustain loop id */\n\tinstrument->values[8].l = 2;\t/* release loop id */\n\n\treadU16(&sustainLoopPlayMode);\n\treadU16(&sustainLoopBegin);\n\treadU16(&sustainLoopEnd);\n\n\treadU16(&releaseLoopPlayMode);\n\treadU16(&releaseLoopBegin);\n\treadU16(&releaseLoopEnd);\n\n\tinstrument->loops[0].id = 1;\n\tinstrument->loops[0].mode = sustainLoopPlayMode;\n\tinstrument->loops[0].beginMarker = sustainLoopBegin;\n\tinstrument->loops[0].endMarker = sustainLoopEnd;\n\tinstrument->loops[0].trackid = AF_DEFAULT_TRACK;\n\n\tinstrument->loops[1].id = 2;\n\tinstrument->loops[1].mode = releaseLoopPlayMode;\n\tinstrument->loops[1].beginMarker = releaseLoopBegin;\n\tinstrument->loops[1].endMarker = releaseLoopEnd;\n\tinstrument->loops[1].trackid = AF_DEFAULT_TRACK;\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readU16",
          "args": [
            "&releaseLoopEnd"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "readU16",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "390-393",
          "snippet": "bool _AFfilehandle::readU16(uint16_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU16(uint16_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readS16",
          "args": [
            "&gain"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "readS16",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "395-398",
          "snippet": "bool _AFfilehandle::readS16(int16_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readS16(int16_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readU8",
          "args": [
            "&highVelocity"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "readU8",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "387-387",
          "snippet": "bool _AFfilehandle::readU8(uint8_t *v) { return readValue(m_fh, v); }",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU8(uint8_t *v) { return readValue(m_fh, v); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readS8",
          "args": [
            "&detune"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "readS8",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "388-388",
          "snippet": "bool _AFfilehandle::readS8(int8_t *v) { return readValue(m_fh, v); }",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readS8(int8_t *v) { return readValue(m_fh, v); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_calloc",
          "args": [
            "2",
            "sizeof (Loop)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_calloc",
          "args": [
            "_AF_AIFF_NUM_INSTPARAMS",
            "sizeof (AFPVu)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_calloc",
          "args": [
            "1",
            "sizeof (Instrument)"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::parseINST(const Tag &type, size_t size)\n  {\n  \tuint8_t baseNote;\n  \tint8_t detune;\n  \tuint8_t lowNote, highNote, lowVelocity, highVelocity;\n  \tint16_t gain;\n  \n  \tuint16_t sustainLoopPlayMode, sustainLoopBegin, sustainLoopEnd;\n  \tuint16_t releaseLoopPlayMode, releaseLoopBegin, releaseLoopEnd;\n  \n  \tInstrument *instrument = (Instrument *) _af_calloc(1, sizeof (Instrument));\n  \tinstrument->id = AF_DEFAULT_INST;\n  \tinstrument->values = (AFPVu *) _af_calloc(_AF_AIFF_NUM_INSTPARAMS, sizeof (AFPVu));\n  \tinstrument->loopCount = 2;\n  \tinstrument->loops = (Loop *) _af_calloc(2, sizeof (Loop));\n  \n  \tm_instrumentCount = 1;\n  \tm_instruments = instrument;\n  \n  \treadU8(&baseNote);\n  \treadS8(&detune);\n  \treadU8(&lowNote);\n  \treadU8(&highNote);\n  \treadU8(&lowVelocity);\n  \treadU8(&highVelocity);\n  \treadS16(&gain);\n  \n  \tinstrument->values[0].l = baseNote;\n  \tinstrument->values[1].l = detune;\n  \tinstrument->values[2].l = lowVelocity;\n  \tinstrument->values[3].l = highVelocity;\n  \tinstrument->values[4].l = lowNote;\n  \tinstrument->values[5].l = highNote;\n  \tinstrument->values[6].l = gain;\n  \n  \tinstrument->values[7].l = 1;\t/* sustain loop id */\n  \tinstrument->values[8].l = 2;\t/* release loop id */\n  \n  \treadU16(&sustainLoopPlayMode);\n  \treadU16(&sustainLoopBegin);\n  \treadU16(&sustainLoopEnd);\n  \n  \treadU16(&releaseLoopPlayMode);\n  \treadU16(&releaseLoopBegin);\n  \treadU16(&releaseLoopEnd);\n  \n  \tinstrument->loops[0].id = 1;\n  \tinstrument->loops[0].mode = sustainLoopPlayMode;\n  \tinstrument->loops[0].beginMarker = sustainLoopBegin;\n  \tinstrument->loops[0].endMarker = sustainLoopEnd;\n  \tinstrument->loops[0].trackid = AF_DEFAULT_TRACK;\n  \n  \tinstrument->loops[1].id = 2;\n  \tinstrument->loops[1].mode = releaseLoopPlayMode;\n  \tinstrument->loops[1].beginMarker = releaseLoopBegin;\n  \tinstrument->loops[1].endMarker = releaseLoopEnd;\n  \tinstrument->loops[1].trackid = AF_DEFAULT_TRACK;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseMiscellaneous",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "158-198",
    "snippet": "status AIFFFile::parseMiscellaneous(const Tag &type, size_t size)\n{\n\tint misctype = AF_MISC_UNRECOGNIZED;\n\n\tassert(type == \"NAME\" ||\n\t\ttype == \"AUTH\" ||\n\t\ttype == \"(c) \" ||\n\t\ttype == \"ANNO\" ||\n\t\ttype == \"APPL\" ||\n\t\ttype == \"MIDI\");\n\n\t/* Skip zero-length miscellaneous chunks. */\n\tif (size == 0)\n\t\treturn AF_FAIL;\n\n\tm_miscellaneousCount++;\n\tm_miscellaneous = (Miscellaneous *) _af_realloc(m_miscellaneous,\n\t\tm_miscellaneousCount * sizeof (Miscellaneous));\n\n\tif (type == \"NAME\")\n\t\tmisctype = AF_MISC_NAME;\n\telse if (type == \"AUTH\")\n\t\tmisctype = AF_MISC_AUTH;\n\telse if (type == \"(c) \")\n\t\tmisctype = AF_MISC_COPY;\n\telse if (type == \"ANNO\")\n\t\tmisctype = AF_MISC_ANNO;\n\telse if (type == \"APPL\")\n\t\tmisctype = AF_MISC_APPL;\n\telse if (type == \"MIDI\")\n\t\tmisctype = AF_MISC_MIDI;\n\n\tm_miscellaneous[m_miscellaneousCount - 1].id = m_miscellaneousCount;\n\tm_miscellaneous[m_miscellaneousCount - 1].type = misctype;\n\tm_miscellaneous[m_miscellaneousCount - 1].size = size;\n\tm_miscellaneous[m_miscellaneousCount - 1].position = 0;\n\tm_miscellaneous[m_miscellaneousCount - 1].buffer = _af_malloc(size);\n\tm_fh->read(m_miscellaneous[m_miscellaneousCount - 1].buffer, size);\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->read",
          "args": [
            "m_miscellaneous[m_miscellaneousCount - 1].buffer",
            "size"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_malloc",
          "args": [
            "size"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_realloc",
          "args": [
            "m_miscellaneous",
            "m_miscellaneousCount * sizeof (Miscellaneous)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "type == \"NAME\" ||\n\t\ttype == \"AUTH\" ||\n\t\ttype == \"(c) \" ||\n\t\ttype == \"ANNO\" ||\n\t\ttype == \"APPL\" ||\n\t\ttype == \"MIDI\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::parseMiscellaneous(const Tag &type, size_t size)\n  {\n  \tint misctype = AF_MISC_UNRECOGNIZED;\n  \n  \tassert(type == \"NAME\" ||\n  \t\ttype == \"AUTH\" ||\n  \t\ttype == \"(c) \" ||\n  \t\ttype == \"ANNO\" ||\n  \t\ttype == \"APPL\" ||\n  \t\ttype == \"MIDI\");\n  \n  \t/* Skip zero-length miscellaneous chunks. */\n  \tif (size == 0)\n  \t\treturn AF_FAIL;\n  \n  \tm_miscellaneousCount++;\n  \tm_miscellaneous = (Miscellaneous *) _af_realloc(m_miscellaneous,\n  \t\tm_miscellaneousCount * sizeof (Miscellaneous));\n  \n  \tif (type == \"NAME\")\n  \t\tmisctype = AF_MISC_NAME;\n  \telse if (type == \"AUTH\")\n  \t\tmisctype = AF_MISC_AUTH;\n  \telse if (type == \"(c) \")\n  \t\tmisctype = AF_MISC_COPY;\n  \telse if (type == \"ANNO\")\n  \t\tmisctype = AF_MISC_ANNO;\n  \telse if (type == \"APPL\")\n  \t\tmisctype = AF_MISC_APPL;\n  \telse if (type == \"MIDI\")\n  \t\tmisctype = AF_MISC_MIDI;\n  \n  \tm_miscellaneous[m_miscellaneousCount - 1].id = m_miscellaneousCount;\n  \tm_miscellaneous[m_miscellaneousCount - 1].type = misctype;\n  \tm_miscellaneous[m_miscellaneousCount - 1].size = size;\n  \tm_miscellaneous[m_miscellaneousCount - 1].position = 0;\n  \tm_miscellaneous[m_miscellaneousCount - 1].buffer = _af_malloc(size);\n  \tm_fh->read(m_miscellaneous[m_miscellaneousCount - 1].buffer, size);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseAESD",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "131-152",
    "snippet": "status AIFFFile::parseAESD(const Tag &type, size_t size)\n{\n\tunsigned char aesChannelStatusData[24];\n\n\tassert(type == \"AESD\");\n\tassert(size == 24);\n\n\tTrack *track = getTrack();\n\n\ttrack->hasAESData = true;\n\n\t/*\n\t\tTry to read 24 bytes of AES nonaudio data from the file.\n\t\tFail if the file disappoints.\n\t*/\n\tif (m_fh->read(aesChannelStatusData, 24) != 24)\n\t\treturn AF_FAIL;\n\n\tmemcpy(track->aesData, aesChannelStatusData, 24);\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "track->aesData",
            "aesChannelStatusData",
            "24"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fh->read",
          "args": [
            "aesChannelStatusData",
            "24"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "size == 24"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "type == \"AESD\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::parseAESD(const Tag &type, size_t size)\n  {\n  \tunsigned char aesChannelStatusData[24];\n  \n  \tassert(type == \"AESD\");\n  \tassert(size == 24);\n  \n  \tTrack *track = getTrack();\n  \n  \ttrack->hasAESData = true;\n  \n  \t/*\n  \t\tTry to read 24 bytes of AES nonaudio data from the file.\n  \t\tFail if the file disappoints.\n  \t*/\n  \tif (m_fh->read(aesChannelStatusData, 24) != 24)\n  \t\treturn AF_FAIL;\n  \n  \tmemcpy(track->aesData, aesChannelStatusData, 24);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseFVER",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "117-126",
    "snippet": "status AIFFFile::parseFVER(const Tag &type, size_t size)\n{\n\tassert(type == \"FVER\");\n\n\tuint32_t timestamp;\n\treadU32(&timestamp);\n\t/* timestamp holds the number of seconds since January 1, 1904. */\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readU32",
          "args": [
            "&timestamp"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "readU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "400-403",
          "snippet": "bool _AFfilehandle::readU32(uint32_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU32(uint32_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "type == \"FVER\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  status AIFFFile::parseFVER(const Tag &type, size_t size)\n  {\n  \tassert(type == \"FVER\");\n  \n  \tuint32_t timestamp;\n  \treadU32(&timestamp);\n  \t/* timestamp holds the number of seconds since January 1, 1904. */\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "AIFFFile",
    "container": "AIFFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AIFF.cpp",
    "lines": "101-112",
    "snippet": "AIFFFile::AIFFFile()\n{\n\tsetFormatByteOrder(AF_BYTEORDER_BIGENDIAN);\n\n\tm_miscellaneousPosition = 0;\n\tm_FVER_offset = 0;\n\tm_COMM_offset = 0;\n\tm_MARK_offset = 0;\n\tm_INST_offset = 0;\n\tm_AESD_offset = 0;\n\tm_SSND_offset = 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"extended.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"AIFF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setFormatByteOrder",
          "args": [
            "AF_BYTEORDER_BIGENDIAN"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "setFormatByteOrder",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.h",
          "lines": "86-86",
          "snippet": "void setFormatByteOrder(int byteOrder) { m_formatByteOrder = byteOrder; }",
          "includes": [
            "#include <stdint.h>",
            "#include \"afinternal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include \"afinternal.h\"\n\n_AFfilehandle {\n  void setFormatByteOrder(int byteOrder) { m_formatByteOrder = byteOrder; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"extended.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"AIFF.h\"\n#include \"config.h\"\n\nAIFFFile {\n  AIFFFile::AIFFFile()\n  {\n  \tsetFormatByteOrder(AF_BYTEORDER_BIGENDIAN);\n  \n  \tm_miscellaneousPosition = 0;\n  \tm_FVER_offset = 0;\n  \tm_COMM_offset = 0;\n  \tm_MARK_offset = 0;\n  \tm_INST_offset = 0;\n  \tm_AESD_offset = 0;\n  \tm_SSND_offset = 0;\n  }\n}"
  }
]