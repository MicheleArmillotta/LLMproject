[
  {
    "function_name": "AddFiller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
    "lines": "1356-1419",
    "snippet": "static void AddFiller( BitBuffer * bits, int32_t numBytes )\n{\n\tuint8_t\t\ttag;\n\tuint32_t\t\tindex;\n\n\t// out of lameness, subtract 6 bytes to deal with header + alignment as required for fill/data elements\n\tnumBytes -= 6;\n\tif ( numBytes <= 0 )\n\t\treturn;\n\t\n\t// randomly pick Fill or Data Stream Element based on numBytes requested\n\ttag = (numBytes & 0x8) ? ID_FIL : ID_DSE;\n\n\tBitBufferWrite( bits, tag, 3 );\n\tif ( tag == ID_FIL )\n\t{\n\t\t// can't write more than 269 bytes in a fill element\n\t\tnumBytes = (numBytes > 269) ? 269 : numBytes;\n\n\t\t// fill element = 4-bit size unless >= 15 then 4-bit size + 8-bit extension size\n\t\tif ( numBytes >= 15 )\n\t\t{\n\t\t\tuint16_t\t\t\textensionSize;\n\n\t\t\tBitBufferWrite( bits, 15, 4 );\n\n\t\t\t// 8-bit extension count field is \"extra + 1\" which is weird but I didn't define the syntax\n\t\t\t// - otherwise, there's no way to represent 15\n\t\t\t// - for example, to really mean 15 bytes you must encode extensionSize = 1\n\t\t\t// - why it's not like data stream elements I have no idea\n\t\t\textensionSize = (numBytes - 15) + 1;\n\t\t\tAssert( extensionSize <= 255 );\n\t\t\tBitBufferWrite( bits, extensionSize, 8 );\n\t\t}\n\t\telse\n\t\t\tBitBufferWrite( bits, numBytes, 4 );\n\n\t\tBitBufferWrite( bits, 0x10, 8 );\t\t// extension_type = FILL_DATA = b0001 or'ed with fill_nibble = b0000\n\t\tfor ( index = 0; index < (numBytes - 1); index++ )\n\t\t\tBitBufferWrite( bits, 0xa5, 8 );\t// fill_byte = b10100101 = 0xa5\n\t}\n\telse\n\t{\n\t\t// can't write more than 510 bytes in a data stream element\n\t\tnumBytes = (numBytes > 510) ? 510 : numBytes;\n\n\t\tBitBufferWrite( bits, 0, 4 );\t\t\t// element instance tag\n\t\tBitBufferWrite( bits, 1, 1 );\t\t\t// byte-align flag = true\n\n\t\t// data stream element = 8-bit size unless >= 255 then 8-bit size + 8-bit size\n\t\tif ( numBytes >= 255 )\n\t\t{\n\t\t\tBitBufferWrite( bits, 255, 8 );\n\t\t\tBitBufferWrite( bits, numBytes - 255, 8 );\n\t\t}\n\t\telse\n\t\t\tBitBufferWrite( bits, numBytes, 8 );\n\t\t\n\t\tBitBufferByteAlign( bits, true );\t\t// byte-align with zeros\n\n\t\tfor ( index = 0; index < numBytes; index++ )\n\t\t\tBitBufferWrite( bits, 0x5a, 8 );\n\t}\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACAudioTypes.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"dplib.h\"",
      "#include \"aglib.h\"",
      "#include \"ALACEncoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bits",
            "0x5a",
            "8"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferByteAlign",
          "args": [
            "bits",
            "true"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bits",
            "numBytes",
            "8"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bits",
            "numBytes - 255",
            "8"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bits",
            "255",
            "8"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bits",
            "1",
            "1"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bits",
            "0",
            "4"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bits",
            "0xa5",
            "8"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bits",
            "0x10",
            "8"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bits",
            "numBytes",
            "4"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bits",
            "extensionSize",
            "8"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "extensionSize <= 255"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bits",
            "15",
            "4"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bits",
            "tag",
            "3"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void AddFiller( BitBuffer * bits, int32_t numBytes )\n{\n\tuint8_t\t\ttag;\n\tuint32_t\t\tindex;\n\n\t// out of lameness, subtract 6 bytes to deal with header + alignment as required for fill/data elements\n\tnumBytes -= 6;\n\tif ( numBytes <= 0 )\n\t\treturn;\n\t\n\t// randomly pick Fill or Data Stream Element based on numBytes requested\n\ttag = (numBytes & 0x8) ? ID_FIL : ID_DSE;\n\n\tBitBufferWrite( bits, tag, 3 );\n\tif ( tag == ID_FIL )\n\t{\n\t\t// can't write more than 269 bytes in a fill element\n\t\tnumBytes = (numBytes > 269) ? 269 : numBytes;\n\n\t\t// fill element = 4-bit size unless >= 15 then 4-bit size + 8-bit extension size\n\t\tif ( numBytes >= 15 )\n\t\t{\n\t\t\tuint16_t\t\t\textensionSize;\n\n\t\t\tBitBufferWrite( bits, 15, 4 );\n\n\t\t\t// 8-bit extension count field is \"extra + 1\" which is weird but I didn't define the syntax\n\t\t\t// - otherwise, there's no way to represent 15\n\t\t\t// - for example, to really mean 15 bytes you must encode extensionSize = 1\n\t\t\t// - why it's not like data stream elements I have no idea\n\t\t\textensionSize = (numBytes - 15) + 1;\n\t\t\tAssert( extensionSize <= 255 );\n\t\t\tBitBufferWrite( bits, extensionSize, 8 );\n\t\t}\n\t\telse\n\t\t\tBitBufferWrite( bits, numBytes, 4 );\n\n\t\tBitBufferWrite( bits, 0x10, 8 );\t\t// extension_type = FILL_DATA = b0001 or'ed with fill_nibble = b0000\n\t\tfor ( index = 0; index < (numBytes - 1); index++ )\n\t\t\tBitBufferWrite( bits, 0xa5, 8 );\t// fill_byte = b10100101 = 0xa5\n\t}\n\telse\n\t{\n\t\t// can't write more than 510 bytes in a data stream element\n\t\tnumBytes = (numBytes > 510) ? 510 : numBytes;\n\n\t\tBitBufferWrite( bits, 0, 4 );\t\t\t// element instance tag\n\t\tBitBufferWrite( bits, 1, 1 );\t\t\t// byte-align flag = true\n\n\t\t// data stream element = 8-bit size unless >= 255 then 8-bit size + 8-bit size\n\t\tif ( numBytes >= 255 )\n\t\t{\n\t\t\tBitBufferWrite( bits, 255, 8 );\n\t\t\tBitBufferWrite( bits, numBytes - 255, 8 );\n\t\t}\n\t\telse\n\t\t\tBitBufferWrite( bits, numBytes, 8 );\n\t\t\n\t\tBitBufferByteAlign( bits, true );\t\t// byte-align with zeros\n\n\t\tfor ( index = 0; index < numBytes; index++ )\n\t\t\tBitBufferWrite( bits, 0x5a, 8 );\n\t}\n}"
  },
  {
    "function_name": "GetSourceFormat",
    "container": "ALACEncoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
    "lines": "1321-1342",
    "snippet": "void ALACEncoder::GetSourceFormat( const AudioFormatDescription * source, AudioFormatDescription * output )\n{\n\t// default is 16-bit native endian\n\t// - note: for float input we assume that's coming from one of our decoders (mp3, aac) so it only makes sense\n\t//\t\t   to encode to 16-bit since the source was lossy in the first place\n\t// - note: if not a supported bit depth, find the closest supported bit depth to the input one\n\tif ( (source->mFormatID != kALACFormatLinearPCM) || ((source->mFormatFlags & kALACFormatFlagIsFloat) != 0) ||\n\t\t( source->mBitsPerChannel <= 16 ) )\n\t\tmBitDepth = 16;\n\telse if ( source->mBitsPerChannel <= 20 )\n\t\tmBitDepth = 20;\n\telse if ( source->mBitsPerChannel <= 24 )\n\t\tmBitDepth = 24;\n\telse\n\t\tmBitDepth = 32;\n\t\t\n\t// we support 16/20/24/32-bit integer data at any sample rate and our target number of channels\n\t// and sample rate were specified when we were configured\n\t/*\n    MakeUncompressedAudioFormat( mNumChannels, (float) mOutputSampleRate, mBitDepth, kAudioFormatFlagsNativeIntegerPacked, output );\n     */\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACAudioTypes.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"dplib.h\"",
      "#include \"aglib.h\"",
      "#include \"ALACEncoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nALACEncoder {\n  void ALACEncoder::GetSourceFormat( const AudioFormatDescription * source, AudioFormatDescription * output )\n  {\n  \t// default is 16-bit native endian\n  \t// - note: for float input we assume that's coming from one of our decoders (mp3, aac) so it only makes sense\n  \t//\t\t   to encode to 16-bit since the source was lossy in the first place\n  \t// - note: if not a supported bit depth, find the closest supported bit depth to the input one\n  \tif ( (source->mFormatID != kALACFormatLinearPCM) || ((source->mFormatFlags & kALACFormatFlagIsFloat) != 0) ||\n  \t\t( source->mBitsPerChannel <= 16 ) )\n  \t\tmBitDepth = 16;\n  \telse if ( source->mBitsPerChannel <= 20 )\n  \t\tmBitDepth = 20;\n  \telse if ( source->mBitsPerChannel <= 24 )\n  \t\tmBitDepth = 24;\n  \telse\n  \t\tmBitDepth = 32;\n  \t\t\n  \t// we support 16/20/24/32-bit integer data at any sample rate and our target number of channels\n  \t// and sample rate were specified when we were configured\n  \t/*\n      MakeUncompressedAudioFormat( mNumChannels, (float) mOutputSampleRate, mBitDepth, kAudioFormatFlagsNativeIntegerPacked, output );\n       */\n  }\n}"
  },
  {
    "function_name": "InitializeEncoder",
    "container": "ALACEncoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
    "lines": "1247-1315",
    "snippet": "int32_t ALACEncoder::InitializeEncoder(AudioFormatDescription theOutputFormat)\n{\n\tint32_t\t\t\tstatus;\n    \n    mOutputSampleRate = theOutputFormat.mSampleRate;\n    mNumChannels = theOutputFormat.mChannelsPerFrame;\n    switch(theOutputFormat.mFormatFlags)\n    {\n        case 1:\n            mBitDepth = 16;\n            break;\n        case 2:\n            mBitDepth = 20;\n            break;\n        case 3:\n            mBitDepth = 24;\n            break;\n        case 4:\n            mBitDepth = 32;\n            break;\n        default:\n            break;\n    }\n\n\t// set up default encoding parameters and state\n\t// - note: mFrameSize is set in the constructor or via SetFrameSize() which must be called before this routine\n\tfor ( uint32_t index = 0; index < kALACMaxChannels; index++ )\n\t\tmLastMixRes[index] = kDefaultMixRes;\n\n\t// the maximum output frame size can be no bigger than (samplesPerBlock * numChannels * ((10 + sampleSize)/8) + 1)\n\t// but note that this can be bigger than the input size!\n\t// - since we don't yet know what our input format will be, use our max allowed sample size in the calculation\n\tmMaxOutputBytes = mFrameSize * mNumChannels * ((10 + kMaxSampleSize) / 8)  + 1;\n\n\t// allocate mix buffers\n\tmMixBufferU = (int32_t *) calloc( mFrameSize * sizeof(int32_t), 1 );\n\tmMixBufferV = (int32_t *) calloc( mFrameSize * sizeof(int32_t), 1 );\n\n\t// allocate dynamic predictor buffers\n\tmPredictorU = (int32_t *) calloc( mFrameSize * sizeof(int32_t), 1 );\n\tmPredictorV = (int32_t *) calloc( mFrameSize * sizeof(int32_t), 1 );\n\t\n\t// allocate combined shift buffer\n\tmShiftBufferUV = (uint16_t *) calloc( mFrameSize * 2 * sizeof(uint16_t),1 );\n\t\n\t// allocate work buffer for search loop\n\tmWorkBuffer = (uint8_t *) calloc( mMaxOutputBytes, 1 );\n\n\tRequireAction( (mMixBufferU != nil) && (mMixBufferV != nil) &&\n\t\t\t\t\t(mPredictorU != nil) && (mPredictorV != nil) &&\n\t\t\t\t\t(mShiftBufferUV != nil) && (mWorkBuffer != nil ),\n\t\t\t\t\tstatus = kALAC_MemFullError; goto Exit; );\n\n\tstatus = ALAC_noErr;\n\n\n\t// initialize coefs arrays once b/c retaining state across blocks actually improves the encode ratio\n\tfor ( int32_t channel = 0; channel < (int32_t)mNumChannels; channel++ )\n\t{\n\t\tfor ( int32_t search = 0; search < kALACMaxSearches; search++ )\n\t\t{\n\t\t\tinit_coefs( mCoefsU[channel][search], DENSHIFT_DEFAULT, kALACMaxCoefs );\n\t\t\tinit_coefs( mCoefsV[channel][search], DENSHIFT_DEFAULT, kALACMaxCoefs );\n\t\t}\n\t}\n\nExit:\n\treturn status;\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACAudioTypes.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"dplib.h\"",
      "#include \"aglib.h\"",
      "#include \"ALACEncoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const uint32_t kMaxSampleSize\t\t= 32;",
      "const uint32_t kDefaultMixRes\t\t= 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_coefs",
          "args": [
            "mCoefsV[channel][search]",
            "DENSHIFT_DEFAULT",
            "kALACMaxCoefs"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_coefs",
          "args": [
            "mCoefsU[channel][search]",
            "DENSHIFT_DEFAULT",
            "kALACMaxCoefs"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RequireAction",
          "args": [
            "(mMixBufferU != nil) && (mMixBufferV != nil) &&\n\t\t\t\t\t(mPredictorU != nil) && (mPredictorV != nil) &&\n\t\t\t\t\t(mShiftBufferUV != nil) && (mWorkBuffer != nil )",
            "status = kALAC_MemFullError"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "mMaxOutputBytes",
            "1"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "mFrameSize * 2 * sizeof(uint16_t)",
            "1"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "mFrameSize * sizeof(int32_t)",
            "1"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "mFrameSize * sizeof(int32_t)",
            "1"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "mFrameSize * sizeof(int32_t)",
            "1"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "mFrameSize * sizeof(int32_t)",
            "1"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nconst uint32_t kMaxSampleSize\t\t= 32;\nconst uint32_t kDefaultMixRes\t\t= 0;\n\nALACEncoder {\n  int32_t ALACEncoder::InitializeEncoder(AudioFormatDescription theOutputFormat)\n  {\n  \tint32_t\t\t\tstatus;\n      \n      mOutputSampleRate = theOutputFormat.mSampleRate;\n      mNumChannels = theOutputFormat.mChannelsPerFrame;\n      switch(theOutputFormat.mFormatFlags)\n      {\n          case 1:\n              mBitDepth = 16;\n              break;\n          case 2:\n              mBitDepth = 20;\n              break;\n          case 3:\n              mBitDepth = 24;\n              break;\n          case 4:\n              mBitDepth = 32;\n              break;\n          default:\n              break;\n      }\n  \n  \t// set up default encoding parameters and state\n  \t// - note: mFrameSize is set in the constructor or via SetFrameSize() which must be called before this routine\n  \tfor ( uint32_t index = 0; index < kALACMaxChannels; index++ )\n  \t\tmLastMixRes[index] = kDefaultMixRes;\n  \n  \t// the maximum output frame size can be no bigger than (samplesPerBlock * numChannels * ((10 + sampleSize)/8) + 1)\n  \t// but note that this can be bigger than the input size!\n  \t// - since we don't yet know what our input format will be, use our max allowed sample size in the calculation\n  \tmMaxOutputBytes = mFrameSize * mNumChannels * ((10 + kMaxSampleSize) / 8)  + 1;\n  \n  \t// allocate mix buffers\n  \tmMixBufferU = (int32_t *) calloc( mFrameSize * sizeof(int32_t), 1 );\n  \tmMixBufferV = (int32_t *) calloc( mFrameSize * sizeof(int32_t), 1 );\n  \n  \t// allocate dynamic predictor buffers\n  \tmPredictorU = (int32_t *) calloc( mFrameSize * sizeof(int32_t), 1 );\n  \tmPredictorV = (int32_t *) calloc( mFrameSize * sizeof(int32_t), 1 );\n  \t\n  \t// allocate combined shift buffer\n  \tmShiftBufferUV = (uint16_t *) calloc( mFrameSize * 2 * sizeof(uint16_t),1 );\n  \t\n  \t// allocate work buffer for search loop\n  \tmWorkBuffer = (uint8_t *) calloc( mMaxOutputBytes, 1 );\n  \n  \tRequireAction( (mMixBufferU != nil) && (mMixBufferV != nil) &&\n  \t\t\t\t\t(mPredictorU != nil) && (mPredictorV != nil) &&\n  \t\t\t\t\t(mShiftBufferUV != nil) && (mWorkBuffer != nil ),\n  \t\t\t\t\tstatus = kALAC_MemFullError; goto Exit; );\n  \n  \tstatus = ALAC_noErr;\n  \n  \n  \t// initialize coefs arrays once b/c retaining state across blocks actually improves the encode ratio\n  \tfor ( int32_t channel = 0; channel < (int32_t)mNumChannels; channel++ )\n  \t{\n  \t\tfor ( int32_t search = 0; search < kALACMaxSearches; search++ )\n  \t\t{\n  \t\t\tinit_coefs( mCoefsU[channel][search], DENSHIFT_DEFAULT, kALACMaxCoefs );\n  \t\t\tinit_coefs( mCoefsV[channel][search], DENSHIFT_DEFAULT, kALACMaxCoefs );\n  \t\t}\n  \t}\n  \n  Exit:\n  \treturn status;\n  }\n}"
  },
  {
    "function_name": "GetMagicCookie",
    "container": "ALACEncoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
    "lines": "1210-1241",
    "snippet": "void ALACEncoder::GetMagicCookie(void * outCookie, uint32_t * ioSize)\n{\n    ALACSpecificConfig theConfig = {0};\n    ALACAudioChannelLayout theChannelLayout = {0};\n    uint8_t theChannelAtom[kChannelAtomSize] = {0, 0, 0, 0, 'c', 'h', 'a', 'n', 0, 0, 0, 0};\n    uint32_t theCookieSize = sizeof(ALACSpecificConfig);\n    uint8_t * theCookiePointer = (uint8_t *)outCookie;\n    \n    GetConfig(theConfig);\n    if (theConfig.numChannels > 2)\n    {\n        theChannelLayout.mChannelLayoutTag = Swap32NtoB(ALACChannelLayoutTags[theConfig.numChannels - 1]);\n        theCookieSize += (sizeof(ALACAudioChannelLayout) + kChannelAtomSize);\n    }\n     if (*ioSize >= theCookieSize)\n    {\n        memcpy(theCookiePointer, &theConfig, sizeof(ALACSpecificConfig));\n        theChannelAtom[3] = (sizeof(ALACAudioChannelLayout) + kChannelAtomSize);\n        if (theConfig.numChannels > 2)\n        {\n            theCookiePointer += sizeof(ALACSpecificConfig);\n            memcpy(theCookiePointer, theChannelAtom, kChannelAtomSize);\n            theCookiePointer += kChannelAtomSize;\n            memcpy(theCookiePointer, &theChannelLayout, sizeof(ALACAudioChannelLayout));\n        }\n        *ioSize = theCookieSize;\n    }\n    else\n    {\n        *ioSize = 0; // no incomplete cookies\n    }\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACAudioTypes.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"dplib.h\"",
      "#include \"aglib.h\"",
      "#include \"ALACEncoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "theCookiePointer",
            "&theChannelLayout",
            "sizeof(ALACAudioChannelLayout)"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "theCookiePointer",
            "theChannelAtom",
            "kChannelAtomSize"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "theCookiePointer",
            "&theConfig",
            "sizeof(ALACSpecificConfig)"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Swap32NtoB",
          "args": [
            "ALACChannelLayoutTags[theConfig.numChannels - 1]"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetConfig",
          "args": [
            "theConfig"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "GetConfig",
          "container": "ALACEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
          "lines": "1183-1196",
          "snippet": "void ALACEncoder::GetConfig( ALACSpecificConfig & config )\n{\n\tconfig.frameLength\t\t\t= Swap32NtoB(mFrameSize);\n\tconfig.compatibleVersion\t= (uint8_t) kALACCompatibleVersion;\n\tconfig.bitDepth\t\t\t\t= (uint8_t) mBitDepth;\n\tconfig.pb\t\t\t\t\t= (uint8_t) PB0;\n\tconfig.kb\t\t\t\t\t= (uint8_t) KB0;\n\tconfig.mb\t\t\t\t\t= (uint8_t) MB0;\n\tconfig.numChannels\t\t\t= (uint8_t) mNumChannels;\n\tconfig.maxRun\t\t\t\t= Swap16NtoB((uint16_t) MAX_RUN_DEFAULT);\n\tconfig.maxFrameBytes\t\t= Swap32NtoB(mMaxFrameBytes);\n\tconfig.avgBitRate\t\t\t= Swap32NtoB(mAvgBitRate);\n\tconfig.sampleRate\t\t\t= Swap32NtoB(mOutputSampleRate);\n}",
          "includes": [
            "#include \"EndianPortable.h\"",
            "#include \"ALACAudioTypes.h\"",
            "#include \"ALACBitUtilities.h\"",
            "#include \"matrixlib.h\"",
            "#include \"dplib.h\"",
            "#include \"aglib.h\"",
            "#include \"ALACEncoder.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nALACEncoder {\n  void ALACEncoder::GetConfig( ALACSpecificConfig & config )\n  {\n  \tconfig.frameLength\t\t\t= Swap32NtoB(mFrameSize);\n  \tconfig.compatibleVersion\t= (uint8_t) kALACCompatibleVersion;\n  \tconfig.bitDepth\t\t\t\t= (uint8_t) mBitDepth;\n  \tconfig.pb\t\t\t\t\t= (uint8_t) PB0;\n  \tconfig.kb\t\t\t\t\t= (uint8_t) KB0;\n  \tconfig.mb\t\t\t\t\t= (uint8_t) MB0;\n  \tconfig.numChannels\t\t\t= (uint8_t) mNumChannels;\n  \tconfig.maxRun\t\t\t\t= Swap16NtoB((uint16_t) MAX_RUN_DEFAULT);\n  \tconfig.maxFrameBytes\t\t= Swap32NtoB(mMaxFrameBytes);\n  \tconfig.avgBitRate\t\t\t= Swap32NtoB(mAvgBitRate);\n  \tconfig.sampleRate\t\t\t= Swap32NtoB(mOutputSampleRate);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nALACEncoder {\n  void ALACEncoder::GetMagicCookie(void * outCookie, uint32_t * ioSize)\n  {\n      ALACSpecificConfig theConfig = {0};\n      ALACAudioChannelLayout theChannelLayout = {0};\n      uint8_t theChannelAtom[kChannelAtomSize] = {0, 0, 0, 0, 'c', 'h', 'a', 'n', 0, 0, 0, 0};\n      uint32_t theCookieSize = sizeof(ALACSpecificConfig);\n      uint8_t * theCookiePointer = (uint8_t *)outCookie;\n      \n      GetConfig(theConfig);\n      if (theConfig.numChannels > 2)\n      {\n          theChannelLayout.mChannelLayoutTag = Swap32NtoB(ALACChannelLayoutTags[theConfig.numChannels - 1]);\n          theCookieSize += (sizeof(ALACAudioChannelLayout) + kChannelAtomSize);\n      }\n       if (*ioSize >= theCookieSize)\n      {\n          memcpy(theCookiePointer, &theConfig, sizeof(ALACSpecificConfig));\n          theChannelAtom[3] = (sizeof(ALACAudioChannelLayout) + kChannelAtomSize);\n          if (theConfig.numChannels > 2)\n          {\n              theCookiePointer += sizeof(ALACSpecificConfig);\n              memcpy(theCookiePointer, theChannelAtom, kChannelAtomSize);\n              theCookiePointer += kChannelAtomSize;\n              memcpy(theCookiePointer, &theChannelLayout, sizeof(ALACAudioChannelLayout));\n          }\n          *ioSize = theCookieSize;\n      }\n      else\n      {\n          *ioSize = 0; // no incomplete cookies\n      }\n  }\n}"
  },
  {
    "function_name": "GetMagicCookieSize",
    "container": "ALACEncoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
    "lines": "1198-1208",
    "snippet": "uint32_t ALACEncoder::GetMagicCookieSize(uint32_t inNumChannels)\n{\n    if (inNumChannels > 2)\n    {\n        return sizeof(ALACSpecificConfig) + kChannelAtomSize + sizeof(ALACAudioChannelLayout);\n    }\n    else\n    {\n        return sizeof(ALACSpecificConfig);\n    }\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACAudioTypes.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"dplib.h\"",
      "#include \"aglib.h\"",
      "#include \"ALACEncoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nALACEncoder {\n  uint32_t ALACEncoder::GetMagicCookieSize(uint32_t inNumChannels)\n  {\n      if (inNumChannels > 2)\n      {\n          return sizeof(ALACSpecificConfig) + kChannelAtomSize + sizeof(ALACAudioChannelLayout);\n      }\n      else\n      {\n          return sizeof(ALACSpecificConfig);\n      }\n  }\n}"
  },
  {
    "function_name": "GetConfig",
    "container": "ALACEncoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
    "lines": "1183-1196",
    "snippet": "void ALACEncoder::GetConfig( ALACSpecificConfig & config )\n{\n\tconfig.frameLength\t\t\t= Swap32NtoB(mFrameSize);\n\tconfig.compatibleVersion\t= (uint8_t) kALACCompatibleVersion;\n\tconfig.bitDepth\t\t\t\t= (uint8_t) mBitDepth;\n\tconfig.pb\t\t\t\t\t= (uint8_t) PB0;\n\tconfig.kb\t\t\t\t\t= (uint8_t) KB0;\n\tconfig.mb\t\t\t\t\t= (uint8_t) MB0;\n\tconfig.numChannels\t\t\t= (uint8_t) mNumChannels;\n\tconfig.maxRun\t\t\t\t= Swap16NtoB((uint16_t) MAX_RUN_DEFAULT);\n\tconfig.maxFrameBytes\t\t= Swap32NtoB(mMaxFrameBytes);\n\tconfig.avgBitRate\t\t\t= Swap32NtoB(mAvgBitRate);\n\tconfig.sampleRate\t\t\t= Swap32NtoB(mOutputSampleRate);\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACAudioTypes.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"dplib.h\"",
      "#include \"aglib.h\"",
      "#include \"ALACEncoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Swap32NtoB",
          "args": [
            "mOutputSampleRate"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Swap32NtoB",
          "args": [
            "mAvgBitRate"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Swap32NtoB",
          "args": [
            "mMaxFrameBytes"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Swap16NtoB",
          "args": [
            "(uint16_t) MAX_RUN_DEFAULT"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Swap32NtoB",
          "args": [
            "mFrameSize"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nALACEncoder {\n  void ALACEncoder::GetConfig( ALACSpecificConfig & config )\n  {\n  \tconfig.frameLength\t\t\t= Swap32NtoB(mFrameSize);\n  \tconfig.compatibleVersion\t= (uint8_t) kALACCompatibleVersion;\n  \tconfig.bitDepth\t\t\t\t= (uint8_t) mBitDepth;\n  \tconfig.pb\t\t\t\t\t= (uint8_t) PB0;\n  \tconfig.kb\t\t\t\t\t= (uint8_t) KB0;\n  \tconfig.mb\t\t\t\t\t= (uint8_t) MB0;\n  \tconfig.numChannels\t\t\t= (uint8_t) mNumChannels;\n  \tconfig.maxRun\t\t\t\t= Swap16NtoB((uint16_t) MAX_RUN_DEFAULT);\n  \tconfig.maxFrameBytes\t\t= Swap32NtoB(mMaxFrameBytes);\n  \tconfig.avgBitRate\t\t\t= Swap32NtoB(mAvgBitRate);\n  \tconfig.sampleRate\t\t\t= Swap32NtoB(mOutputSampleRate);\n  }\n}"
  },
  {
    "function_name": "Finish",
    "container": "ALACEncoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
    "lines": "1165-1174",
    "snippet": "int32_t ALACEncoder::Finish()\n{\n/*\t// finalize bit rate statistics\n\tif ( mSampleSize.numEntries != 0 )\n\t\tmAvgBitRate = (uint32_t)( (((float)mTotalBytesGenerated * 8.0f) / (float)mSampleSize.numEntries) * ((float)mSampleRate / (float)mFrameSize) );\n\telse\n\t\tmAvgBitRate = 0;\n*/\n\treturn ALAC_noErr;\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACAudioTypes.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"dplib.h\"",
      "#include \"aglib.h\"",
      "#include \"ALACEncoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nALACEncoder {\n  int32_t ALACEncoder::Finish()\n  {\n  /*\t// finalize bit rate statistics\n  \tif ( mSampleSize.numEntries != 0 )\n  \t\tmAvgBitRate = (uint32_t)( (((float)mTotalBytesGenerated * 8.0f) / (float)mSampleSize.numEntries) * ((float)mSampleRate / (float)mFrameSize) );\n  \telse\n  \t\tmAvgBitRate = 0;\n  */\n  \treturn ALAC_noErr;\n  }\n}"
  },
  {
    "function_name": "Encode",
    "container": "ALACEncoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
    "lines": "1020-1158",
    "snippet": "int32_t ALACEncoder::Encode(AudioFormatDescription theInputFormat, AudioFormatDescription theOutputFormat,\n                             unsigned char * theReadBuffer, unsigned char * theWriteBuffer, int32_t * ioNumBytes)\n{\n\tuint32_t\t\t\t\tnumFrames;\n\tuint32_t\t\t\t\toutputSize;\n\tBitBuffer\t\t\tbitstream;\n\tint32_t\t\t\tstatus;\n\n\tnumFrames = *ioNumBytes/theInputFormat.mBytesPerPacket;\n\n\t// create a bit buffer structure pointing to our output buffer\n\tBitBufferInit( &bitstream, theWriteBuffer, mMaxOutputBytes );\n\n\tif ( theInputFormat.mChannelsPerFrame == 2 )\n\t{\n\t\t// add 3-bit frame start tag ID_CPE = channel pair & 4-bit element instance tag = 0\n\t\tBitBufferWrite( &bitstream, ID_CPE, 3 );\n\t\tBitBufferWrite( &bitstream, 0, 4 );\n\n\t\t// encode stereo input buffer\n\t\tif ( mFastMode == false )\n\t\t\tstatus = this->EncodeStereo( &bitstream, theReadBuffer, 2, 0, numFrames );\n\t\telse\n\t\t\tstatus = this->EncodeStereoFast( &bitstream, theReadBuffer, 2, 0, numFrames );\n\t\tRequireNoErr( status, goto Exit; );\n\t}\n\telse if ( theInputFormat.mChannelsPerFrame == 1 )\n\t{\n\t\t// add 3-bit frame start tag ID_SCE = mono channel & 4-bit element instance tag = 0\n\t\tBitBufferWrite( &bitstream, ID_SCE, 3 );\n\t\tBitBufferWrite( &bitstream, 0, 4 );\n\n\t\t// encode mono input buffer\n\t\tstatus = this->EncodeMono( &bitstream, theReadBuffer, 1, 0, numFrames );\n\t\tRequireNoErr( status, goto Exit; );\n\t}\n\telse\n\t{\n\t\tchar *\t\t\t\t\tinputBuffer;\n\t\tuint32_t\t\t\t\ttag;\n\t\tuint32_t\t\t\t\tchannelIndex;\n\t\tuint32_t\t\t\t\tinputIncrement;\n\t\tuint8_t\t\t\t\tstereoElementTag;\n\t\tuint8_t\t\t\t\tmonoElementTag;\n\t\tuint8_t\t\t\t\tlfeElementTag;\n\t\t\n\t\tinputBuffer\t\t= (char *) theReadBuffer;\n\t\tinputIncrement\t= ((mBitDepth + 7) / 8);\n\t\t\n\t\tstereoElementTag\t= 0;\n\t\tmonoElementTag\t\t= 0;\n\t\tlfeElementTag\t\t= 0;\n\n\t\tfor ( channelIndex = 0; channelIndex < theInputFormat.mChannelsPerFrame; )\n\t\t{\n\t\t\ttag = (sChannelMaps[theInputFormat.mChannelsPerFrame - 1] & (0x7ul << (channelIndex * 3))) >> (channelIndex * 3);\n\t\n\t\t\tBitBufferWrite( &bitstream, tag, 3 );\n\t\t\tswitch ( tag )\n\t\t\t{\n\t\t\t\tcase ID_SCE:\n\t\t\t\t\t// mono\n\t\t\t\t\tBitBufferWrite( &bitstream, monoElementTag, 4 );\n\n\t\t\t\t\tstatus = this->EncodeMono( &bitstream, inputBuffer, theInputFormat.mChannelsPerFrame, channelIndex, numFrames );\n\t\t\t\t\t\n\t\t\t\t\tinputBuffer += inputIncrement;\n\t\t\t\t\tchannelIndex++;\n\t\t\t\t\tmonoElementTag++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ID_CPE:\n\t\t\t\t\t// stereo\n\t\t\t\t\tBitBufferWrite( &bitstream, stereoElementTag, 4 );\n\n\t\t\t\t\tstatus = this->EncodeStereo( &bitstream, inputBuffer, theInputFormat.mChannelsPerFrame, channelIndex, numFrames );\n\n\t\t\t\t\tinputBuffer += (inputIncrement * 2);\n\t\t\t\t\tchannelIndex += 2;\n\t\t\t\t\tstereoElementTag++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ID_LFE:\n\t\t\t\t\t// LFE channel (subwoofer)\n\t\t\t\t\tBitBufferWrite( &bitstream, lfeElementTag, 4 );\n\n\t\t\t\t\tstatus = this->EncodeMono( &bitstream, inputBuffer, theInputFormat.mChannelsPerFrame, channelIndex, numFrames );\n\n\t\t\t\t\tinputBuffer += inputIncrement;\n\t\t\t\t\tchannelIndex++;\n\t\t\t\t\tlfeElementTag++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tstatus = kALAC_ParamError;\n\t\t\t\t\tgoto Exit;\n\t\t\t}\n\n\t\t\tRequireNoErr( status, goto Exit; );\n\t\t}\n\t}\n\n#if VERBOSE_DEBUG\n{\n\t// if there is room left in the output buffer, add some random fill data to test decoder\n\tint32_t\t\t\tbitsLeft;\n\tint32_t\t\t\tbytesLeft;\n\t\n\tbitsLeft = BitBufferGetPosition( &bitstream ) - 3;\t// - 3 for ID_END tag\n\tbytesLeft = bitstream.byteSize - ((bitsLeft + 7) / 8);\n\t\n\tif ( (bytesLeft > 20) && ((bytesLeft & 0x4u) != 0) )\n\t\tAddFiller( &bitstream, bytesLeft );\n}\n#endif\n\n\t// add 3-bit frame end tag: ID_END\n\tBitBufferWrite( &bitstream, ID_END, 3 );\n\n\t// byte-align the output data\n\tBitBufferByteAlign( &bitstream, true );\n\n\toutputSize = BitBufferGetPosition( &bitstream ) / 8;\n\t//Assert( outputSize <= mMaxOutputBytes );\n\n\n\t// all good, let iTunes know what happened and remember the total number of input sample frames\n\t*ioNumBytes = outputSize;\n\t//mEncodedFrames\t\t   \t   += encodeMsg->numInputSamples;\n\n\t// gather encoding stats\n\tmTotalBytesGenerated += outputSize;\n\tmMaxFrameBytes = MAX( mMaxFrameBytes, outputSize );\n\n\tstatus = ALAC_noErr;\n\nExit:\n\treturn status;\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACAudioTypes.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"dplib.h\"",
      "#include \"aglib.h\"",
      "#include \"ALACEncoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define VERBOSE_DEBUG\t\t0"
    ],
    "globals_used": [
      "static const uint32_t\tsChannelMaps[kALACMaxChannels] =\n{\n\tID_SCE,\n\tID_CPE,\n\t(ID_CPE << 3) | (ID_SCE),\n\t(ID_SCE << 9) | (ID_CPE << 3) | (ID_SCE),\n\t(ID_CPE << 9) | (ID_CPE << 3) | (ID_SCE),\n\t(ID_SCE << 15) | (ID_CPE << 9) | (ID_CPE << 3) | (ID_SCE),\n\t(ID_SCE << 18) | (ID_SCE << 15) | (ID_CPE << 9) | (ID_CPE << 3) | (ID_SCE),\n\t(ID_SCE << 21) | (ID_CPE << 15) | (ID_CPE << 9) | (ID_CPE << 3) | (ID_SCE)\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "mMaxFrameBytes",
            "outputSize"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferGetPosition",
          "args": [
            "&bitstream"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferByteAlign",
          "args": [
            "&bitstream",
            "true"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "&bitstream",
            "ID_END",
            "3"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AddFiller",
          "args": [
            "&bitstream",
            "bytesLeft"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "AddFiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
          "lines": "1356-1419",
          "snippet": "static void AddFiller( BitBuffer * bits, int32_t numBytes )\n{\n\tuint8_t\t\ttag;\n\tuint32_t\t\tindex;\n\n\t// out of lameness, subtract 6 bytes to deal with header + alignment as required for fill/data elements\n\tnumBytes -= 6;\n\tif ( numBytes <= 0 )\n\t\treturn;\n\t\n\t// randomly pick Fill or Data Stream Element based on numBytes requested\n\ttag = (numBytes & 0x8) ? ID_FIL : ID_DSE;\n\n\tBitBufferWrite( bits, tag, 3 );\n\tif ( tag == ID_FIL )\n\t{\n\t\t// can't write more than 269 bytes in a fill element\n\t\tnumBytes = (numBytes > 269) ? 269 : numBytes;\n\n\t\t// fill element = 4-bit size unless >= 15 then 4-bit size + 8-bit extension size\n\t\tif ( numBytes >= 15 )\n\t\t{\n\t\t\tuint16_t\t\t\textensionSize;\n\n\t\t\tBitBufferWrite( bits, 15, 4 );\n\n\t\t\t// 8-bit extension count field is \"extra + 1\" which is weird but I didn't define the syntax\n\t\t\t// - otherwise, there's no way to represent 15\n\t\t\t// - for example, to really mean 15 bytes you must encode extensionSize = 1\n\t\t\t// - why it's not like data stream elements I have no idea\n\t\t\textensionSize = (numBytes - 15) + 1;\n\t\t\tAssert( extensionSize <= 255 );\n\t\t\tBitBufferWrite( bits, extensionSize, 8 );\n\t\t}\n\t\telse\n\t\t\tBitBufferWrite( bits, numBytes, 4 );\n\n\t\tBitBufferWrite( bits, 0x10, 8 );\t\t// extension_type = FILL_DATA = b0001 or'ed with fill_nibble = b0000\n\t\tfor ( index = 0; index < (numBytes - 1); index++ )\n\t\t\tBitBufferWrite( bits, 0xa5, 8 );\t// fill_byte = b10100101 = 0xa5\n\t}\n\telse\n\t{\n\t\t// can't write more than 510 bytes in a data stream element\n\t\tnumBytes = (numBytes > 510) ? 510 : numBytes;\n\n\t\tBitBufferWrite( bits, 0, 4 );\t\t\t// element instance tag\n\t\tBitBufferWrite( bits, 1, 1 );\t\t\t// byte-align flag = true\n\n\t\t// data stream element = 8-bit size unless >= 255 then 8-bit size + 8-bit size\n\t\tif ( numBytes >= 255 )\n\t\t{\n\t\t\tBitBufferWrite( bits, 255, 8 );\n\t\t\tBitBufferWrite( bits, numBytes - 255, 8 );\n\t\t}\n\t\telse\n\t\t\tBitBufferWrite( bits, numBytes, 8 );\n\t\t\n\t\tBitBufferByteAlign( bits, true );\t\t// byte-align with zeros\n\n\t\tfor ( index = 0; index < numBytes; index++ )\n\t\t\tBitBufferWrite( bits, 0x5a, 8 );\n\t}\n}",
          "includes": [
            "#include \"EndianPortable.h\"",
            "#include \"ALACAudioTypes.h\"",
            "#include \"ALACBitUtilities.h\"",
            "#include \"matrixlib.h\"",
            "#include \"dplib.h\"",
            "#include \"aglib.h\"",
            "#include \"ALACEncoder.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void AddFiller( BitBuffer * bits, int32_t numBytes )\n{\n\tuint8_t\t\ttag;\n\tuint32_t\t\tindex;\n\n\t// out of lameness, subtract 6 bytes to deal with header + alignment as required for fill/data elements\n\tnumBytes -= 6;\n\tif ( numBytes <= 0 )\n\t\treturn;\n\t\n\t// randomly pick Fill or Data Stream Element based on numBytes requested\n\ttag = (numBytes & 0x8) ? ID_FIL : ID_DSE;\n\n\tBitBufferWrite( bits, tag, 3 );\n\tif ( tag == ID_FIL )\n\t{\n\t\t// can't write more than 269 bytes in a fill element\n\t\tnumBytes = (numBytes > 269) ? 269 : numBytes;\n\n\t\t// fill element = 4-bit size unless >= 15 then 4-bit size + 8-bit extension size\n\t\tif ( numBytes >= 15 )\n\t\t{\n\t\t\tuint16_t\t\t\textensionSize;\n\n\t\t\tBitBufferWrite( bits, 15, 4 );\n\n\t\t\t// 8-bit extension count field is \"extra + 1\" which is weird but I didn't define the syntax\n\t\t\t// - otherwise, there's no way to represent 15\n\t\t\t// - for example, to really mean 15 bytes you must encode extensionSize = 1\n\t\t\t// - why it's not like data stream elements I have no idea\n\t\t\textensionSize = (numBytes - 15) + 1;\n\t\t\tAssert( extensionSize <= 255 );\n\t\t\tBitBufferWrite( bits, extensionSize, 8 );\n\t\t}\n\t\telse\n\t\t\tBitBufferWrite( bits, numBytes, 4 );\n\n\t\tBitBufferWrite( bits, 0x10, 8 );\t\t// extension_type = FILL_DATA = b0001 or'ed with fill_nibble = b0000\n\t\tfor ( index = 0; index < (numBytes - 1); index++ )\n\t\t\tBitBufferWrite( bits, 0xa5, 8 );\t// fill_byte = b10100101 = 0xa5\n\t}\n\telse\n\t{\n\t\t// can't write more than 510 bytes in a data stream element\n\t\tnumBytes = (numBytes > 510) ? 510 : numBytes;\n\n\t\tBitBufferWrite( bits, 0, 4 );\t\t\t// element instance tag\n\t\tBitBufferWrite( bits, 1, 1 );\t\t\t// byte-align flag = true\n\n\t\t// data stream element = 8-bit size unless >= 255 then 8-bit size + 8-bit size\n\t\tif ( numBytes >= 255 )\n\t\t{\n\t\t\tBitBufferWrite( bits, 255, 8 );\n\t\t\tBitBufferWrite( bits, numBytes - 255, 8 );\n\t\t}\n\t\telse\n\t\t\tBitBufferWrite( bits, numBytes, 8 );\n\t\t\n\t\tBitBufferByteAlign( bits, true );\t\t// byte-align with zeros\n\n\t\tfor ( index = 0; index < numBytes; index++ )\n\t\t\tBitBufferWrite( bits, 0x5a, 8 );\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BitBufferGetPosition",
          "args": [
            "&bitstream"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->EncodeMono",
          "args": [
            "&bitstream",
            "inputBuffer",
            "theInputFormat.mChannelsPerFrame",
            "channelIndex",
            "numFrames"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeMono",
          "container": "ALACEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
          "lines": "793-1010",
          "snippet": "int32_t ALACEncoder::EncodeMono( BitBuffer * bitstream, void * inputBuffer, uint32_t stride, uint32_t channelIndex, uint32_t numSamples )\n{\n\tBitBuffer\t\tstartBits = *bitstream;\t\t\t// squirrel away copy of current state in case we need to go back and do an escape packet\n\tAGParamRec\t\tagParams;\n\tuint32_t\tbits1;\n\tuint32_t\t\t\tnumU;\n\tSearchCoefs\t\tcoefsU;\n\tuint32_t\t\t\tdilate;\n\tuint32_t\t\t\tminBits, bestU;\n\tuint32_t\t\t\tminU, maxU;\n\tuint32_t\t\t\tindex, index2;\n\tuint8_t\t\t\tbytesShifted;\n\tuint32_t\t\t\tshift;\n\tuint32_t\t\t\tmask;\n\tuint32_t\t\t\tchanBits;\n\tuint8_t\t\t\tpbFactor;\n\tuint8_t\t\t\tpartialFrame;\n\tint16_t *\t\tinput16;\n\tint32_t *\t\tinput32;\n\tuint32_t\t\t\tescapeBits;\n\tbool\t\t\tdoEscape;\n\tint32_t\t\tstatus;\n\n\t// make sure we handle this bit-depth before we get going\n\tRequireAction( (mBitDepth == 16) || (mBitDepth == 20) || (mBitDepth == 24) || (mBitDepth == 32), return kALAC_ParamError; );\n\n\tstatus = ALAC_noErr;\n\t\n\t// reload coefs array from previous frame\n\tcoefsU = (SearchCoefs) mCoefsU[channelIndex];\n\n\t// pick bit depth for actual encoding\n\t// - we lop off the lower byte(s) for 24-/32-bit encodings\n\tif ( mBitDepth == 32 )\n\t\tbytesShifted = 2;\n\telse if ( mBitDepth >= 24 )\n\t\tbytesShifted = 1;\n\telse\n\t\tbytesShifted = 0;\n\n\tshift = bytesShifted * 8;\n\tmask = (1ul << shift) - 1;\n\tchanBits = mBitDepth - (bytesShifted * 8);\n\n\t// flag whether or not this is a partial frame\n\tpartialFrame = (numSamples == mFrameSize) ? 0 : 1;\n\n\t// convert N-bit data to 32-bit for predictor\n\tswitch ( mBitDepth )\n\t{\n\t\tcase 16:\n\t\t{\n\t\t\t// convert 16-bit data to 32-bit for predictor\n\t\t\tinput16 = (int16_t *) inputBuffer;\n\t\t\tfor ( index = 0, index2 = 0; index < numSamples; index++, index2 += stride )\n\t\t\t\tmMixBufferU[index] = (int32_t) input16[index2];\n\t\t\tbreak;\n\t\t}\n\t\tcase 20:\n\t\t\t// convert 20-bit data to 32-bit for predictor\n\t\t\tcopy20ToPredictor( (uint8_t *) inputBuffer, stride, mMixBufferU, numSamples );\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\t// convert 24-bit data to 32-bit for the predictor and extract the shifted off byte(s)\n\t\t\tcopy24ToPredictor( (uint8_t *) inputBuffer, stride, mMixBufferU, numSamples );\n\t\t\tfor ( index = 0; index < numSamples; index++ )\n\t\t\t{\n\t\t\t\tmShiftBufferUV[index] = (uint16_t)(mMixBufferU[index] & mask);\n\t\t\t\tmMixBufferU[index] >>= shift;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 32:\n\t\t{\n\t\t\t// just copy the 32-bit input data for the predictor and extract the shifted off byte(s)\n\t\t\tinput32 = (int32_t *) inputBuffer;\n\n\t\t\tfor ( index = 0, index2 = 0; index < numSamples; index++, index2 += stride )\n\t\t\t{\n\t\t\t\tint32_t\t\t\tval = input32[index2];\n\t\t\t\t\n\t\t\t\tmShiftBufferUV[index] = (uint16_t)(val & mask);\n\t\t\t\tmMixBufferU[index] = val >> shift;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// brute-force encode optimization loop (implied \"encode depth\" of 0 if comparing to cmd line tool)\n\t// - run over variations of the encoding params to find the best choice\n\tminU\t\t= 4;\n\tmaxU\t\t= 8;\n\tminBits\t\t= 1ul << 31;\n\tpbFactor\t= 4;\n\t\n\tminBits\t= 1ul << 31;\n\tbestU\t= minU;\n\n\tfor ( numU = minU; numU <= maxU; numU += 4 )\n\t{\n\t\tBitBuffer\t\tworkBits;\n\t\tuint32_t\t\t\tnumBits;\n\n\t\tBitBufferInit( &workBits, mWorkBuffer, mMaxOutputBytes );\n\t\n\t\tdilate = 32;\n\t\tfor ( uint32_t converge = 0; converge < 7; converge++ )\t\n\t\t\tpc_block( mMixBufferU, mPredictorU, numSamples/dilate, coefsU[numU-1], numU, chanBits, DENSHIFT_DEFAULT );\n\n\t\tdilate = 8;\n\t\tpc_block( mMixBufferU, mPredictorU, numSamples/dilate, coefsU[numU-1], numU, chanBits, DENSHIFT_DEFAULT );\n\n\t\tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n\t\tstatus = dyn_comp( &agParams, mPredictorU, &workBits, numSamples/dilate, chanBits, &bits1 );\n\t\tRequireNoErr( status, goto Exit; );\n\n\t\tnumBits = (dilate * bits1) + (16 * numU);\n\t\tif ( numBits < minBits )\n\t\t{\n\t\t\tbestU\t= numU;\n\t\t\tminBits = numBits;\n\t\t}\n\t}             \n\n\t// test for escape hatch if best calculated compressed size turns out to be more than the input size\n\t// - first, add bits for the header bytes mixRes/maxRes/shiftU/filterU\n\tminBits += (4 /* mixRes/maxRes/etc. */ * 8) + ((partialFrame == true) ? 32 : 0);\n\tif ( bytesShifted != 0 )\n\t\tminBits += (numSamples * (bytesShifted * 8));\n\n\tescapeBits = (numSamples * mBitDepth) + ((partialFrame == true) ? 32 : 0) + (2 * 8);\t/* 2 common header bytes */\n\n\tdoEscape = (minBits >= escapeBits) ? true : false;\n\n\tif ( doEscape == false )\n\t{\n\t\t// write bitstream header\n\t\tBitBufferWrite( bitstream, 0, 12 );\n\t\tBitBufferWrite( bitstream, (partialFrame << 3) | (bytesShifted << 1), 4 );\n\t\tif ( partialFrame )\n\t\t\tBitBufferWrite( bitstream, numSamples, 32 );\n\t\tBitBufferWrite( bitstream, 0, 16 );\t\t\t\t\t\t\t\t// mixBits = mixRes = 0\n\t\t\n\t\t// write the params and predictor coefs\n\t\tnumU = bestU;\n\t\tBitBufferWrite( bitstream, (0 << 4) | DENSHIFT_DEFAULT, 8 );\t// modeU = 0\n\t\tBitBufferWrite( bitstream, (pbFactor << 5) | numU, 8 );\n\t\tfor ( index = 0; index < numU; index++ )\n\t\t\tBitBufferWrite( bitstream, coefsU[numU-1][index], 16 );\n\n\t\t// if shift active, write the interleaved shift buffers\n\t\tif ( bytesShifted != 0 )\n\t\t{\n\t\t\tfor ( index = 0; index < numSamples; index++ )\n\t\t\t\tBitBufferWrite( bitstream, mShiftBufferUV[index], shift );\n\t\t}\n\n\t\t// run the dynamic predictor with the best result\n\t\tpc_block( mMixBufferU, mPredictorU, numSamples, coefsU[numU-1], numU, chanBits, DENSHIFT_DEFAULT );\n\n\t\t// do lossless compression\n\t\tset_standard_ag_params( &agParams, numSamples, numSamples );\n\t\tstatus = dyn_comp( &agParams, mPredictorU, bitstream, numSamples, chanBits, &bits1 );\n\t\t//AssertNoErr( status );\n\n\n\t\t/*\tif we happened to create a compressed packet that was actually bigger than an escape packet would be,\n\t\t\tchuck it and do an escape packet\n\t\t*/\n\t\tminBits = BitBufferGetPosition( bitstream ) - BitBufferGetPosition( &startBits );\n\t\tif ( minBits >= escapeBits )\n\t\t{\n\t\t\t*bitstream = startBits;\t\t// reset bitstream state\n\t\t\tdoEscape = true;\n\t\t}\n\t}\n\n\tif ( doEscape == true )\n\t{\n\t\t// write bitstream header and coefs\n\t\tBitBufferWrite( bitstream, 0, 12 );\n\t\tBitBufferWrite( bitstream, (partialFrame << 3) | 1, 4 );\t// LSB = 1 means \"frame not compressed\"\n\t\tif ( partialFrame )\n\t\t\tBitBufferWrite( bitstream, numSamples, 32 );\n\n\t\t// just copy the input data to the output buffer\n\t\tswitch ( mBitDepth )\n\t\t{\n\t\t\tcase 16:\n\t\t\t\tinput16 = (int16_t *) inputBuffer;\n\t\t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n\t\t\t\t\tBitBufferWrite( bitstream, input16[index], 16 );\n\t\t\t\tbreak;\n\t\t\tcase 20:\n\t\t\t\t// convert 20-bit data to 32-bit for simplicity\n\t\t\t\tcopy20ToPredictor( (uint8_t *) inputBuffer, stride, mMixBufferU, numSamples );\n\t\t\t\tfor ( index = 0; index < numSamples; index++ )\n\t\t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 20 );\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\t\t// convert 24-bit data to 32-bit for simplicity\n\t\t\t\tcopy24ToPredictor( (uint8_t *) inputBuffer, stride, mMixBufferU, numSamples );\n\t\t\t\tfor ( index = 0; index < numSamples; index++ )\n\t\t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 24 );\n\t\t\t\tbreak;\n\t\t\tcase 32:\n\t\t\t\tinput32 = (int32_t *) inputBuffer;\n\t\t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n\t\t\t\t\tBitBufferWrite( bitstream, input32[index], 32 );\n\t\t\t\tbreak;\n\t\t}\n#if VERBOSE_DEBUG\t\t\n\t\tDebugMsg( \"escape!: %lu vs %lu\", minBits, (numSamples * mBitDepth) );\n#endif\n\t}\n\nExit:\n\treturn status;\n}",
          "includes": [
            "#include \"EndianPortable.h\"",
            "#include \"ALACAudioTypes.h\"",
            "#include \"ALACBitUtilities.h\"",
            "#include \"matrixlib.h\"",
            "#include \"dplib.h\"",
            "#include \"aglib.h\"",
            "#include \"ALACEncoder.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define VERBOSE_DEBUG\t\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define VERBOSE_DEBUG\t\t0\n\nALACEncoder {\n  int32_t ALACEncoder::EncodeMono( BitBuffer * bitstream, void * inputBuffer, uint32_t stride, uint32_t channelIndex, uint32_t numSamples )\n  {\n  \tBitBuffer\t\tstartBits = *bitstream;\t\t\t// squirrel away copy of current state in case we need to go back and do an escape packet\n  \tAGParamRec\t\tagParams;\n  \tuint32_t\tbits1;\n  \tuint32_t\t\t\tnumU;\n  \tSearchCoefs\t\tcoefsU;\n  \tuint32_t\t\t\tdilate;\n  \tuint32_t\t\t\tminBits, bestU;\n  \tuint32_t\t\t\tminU, maxU;\n  \tuint32_t\t\t\tindex, index2;\n  \tuint8_t\t\t\tbytesShifted;\n  \tuint32_t\t\t\tshift;\n  \tuint32_t\t\t\tmask;\n  \tuint32_t\t\t\tchanBits;\n  \tuint8_t\t\t\tpbFactor;\n  \tuint8_t\t\t\tpartialFrame;\n  \tint16_t *\t\tinput16;\n  \tint32_t *\t\tinput32;\n  \tuint32_t\t\t\tescapeBits;\n  \tbool\t\t\tdoEscape;\n  \tint32_t\t\tstatus;\n  \n  \t// make sure we handle this bit-depth before we get going\n  \tRequireAction( (mBitDepth == 16) || (mBitDepth == 20) || (mBitDepth == 24) || (mBitDepth == 32), return kALAC_ParamError; );\n  \n  \tstatus = ALAC_noErr;\n  \t\n  \t// reload coefs array from previous frame\n  \tcoefsU = (SearchCoefs) mCoefsU[channelIndex];\n  \n  \t// pick bit depth for actual encoding\n  \t// - we lop off the lower byte(s) for 24-/32-bit encodings\n  \tif ( mBitDepth == 32 )\n  \t\tbytesShifted = 2;\n  \telse if ( mBitDepth >= 24 )\n  \t\tbytesShifted = 1;\n  \telse\n  \t\tbytesShifted = 0;\n  \n  \tshift = bytesShifted * 8;\n  \tmask = (1ul << shift) - 1;\n  \tchanBits = mBitDepth - (bytesShifted * 8);\n  \n  \t// flag whether or not this is a partial frame\n  \tpartialFrame = (numSamples == mFrameSize) ? 0 : 1;\n  \n  \t// convert N-bit data to 32-bit for predictor\n  \tswitch ( mBitDepth )\n  \t{\n  \t\tcase 16:\n  \t\t{\n  \t\t\t// convert 16-bit data to 32-bit for predictor\n  \t\t\tinput16 = (int16_t *) inputBuffer;\n  \t\t\tfor ( index = 0, index2 = 0; index < numSamples; index++, index2 += stride )\n  \t\t\t\tmMixBufferU[index] = (int32_t) input16[index2];\n  \t\t\tbreak;\n  \t\t}\n  \t\tcase 20:\n  \t\t\t// convert 20-bit data to 32-bit for predictor\n  \t\t\tcopy20ToPredictor( (uint8_t *) inputBuffer, stride, mMixBufferU, numSamples );\n  \t\t\tbreak;\n  \t\tcase 24:\n  \t\t\t// convert 24-bit data to 32-bit for the predictor and extract the shifted off byte(s)\n  \t\t\tcopy24ToPredictor( (uint8_t *) inputBuffer, stride, mMixBufferU, numSamples );\n  \t\t\tfor ( index = 0; index < numSamples; index++ )\n  \t\t\t{\n  \t\t\t\tmShiftBufferUV[index] = (uint16_t)(mMixBufferU[index] & mask);\n  \t\t\t\tmMixBufferU[index] >>= shift;\n  \t\t\t}\n  \t\t\tbreak;\n  \t\tcase 32:\n  \t\t{\n  \t\t\t// just copy the 32-bit input data for the predictor and extract the shifted off byte(s)\n  \t\t\tinput32 = (int32_t *) inputBuffer;\n  \n  \t\t\tfor ( index = 0, index2 = 0; index < numSamples; index++, index2 += stride )\n  \t\t\t{\n  \t\t\t\tint32_t\t\t\tval = input32[index2];\n  \t\t\t\t\n  \t\t\t\tmShiftBufferUV[index] = (uint16_t)(val & mask);\n  \t\t\t\tmMixBufferU[index] = val >> shift;\n  \t\t\t}\n  \t\t\tbreak;\n  \t\t}\n  \t}\n  \n  \t// brute-force encode optimization loop (implied \"encode depth\" of 0 if comparing to cmd line tool)\n  \t// - run over variations of the encoding params to find the best choice\n  \tminU\t\t= 4;\n  \tmaxU\t\t= 8;\n  \tminBits\t\t= 1ul << 31;\n  \tpbFactor\t= 4;\n  \t\n  \tminBits\t= 1ul << 31;\n  \tbestU\t= minU;\n  \n  \tfor ( numU = minU; numU <= maxU; numU += 4 )\n  \t{\n  \t\tBitBuffer\t\tworkBits;\n  \t\tuint32_t\t\t\tnumBits;\n  \n  \t\tBitBufferInit( &workBits, mWorkBuffer, mMaxOutputBytes );\n  \t\n  \t\tdilate = 32;\n  \t\tfor ( uint32_t converge = 0; converge < 7; converge++ )\t\n  \t\t\tpc_block( mMixBufferU, mPredictorU, numSamples/dilate, coefsU[numU-1], numU, chanBits, DENSHIFT_DEFAULT );\n  \n  \t\tdilate = 8;\n  \t\tpc_block( mMixBufferU, mPredictorU, numSamples/dilate, coefsU[numU-1], numU, chanBits, DENSHIFT_DEFAULT );\n  \n  \t\tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n  \t\tstatus = dyn_comp( &agParams, mPredictorU, &workBits, numSamples/dilate, chanBits, &bits1 );\n  \t\tRequireNoErr( status, goto Exit; );\n  \n  \t\tnumBits = (dilate * bits1) + (16 * numU);\n  \t\tif ( numBits < minBits )\n  \t\t{\n  \t\t\tbestU\t= numU;\n  \t\t\tminBits = numBits;\n  \t\t}\n  \t}             \n  \n  \t// test for escape hatch if best calculated compressed size turns out to be more than the input size\n  \t// - first, add bits for the header bytes mixRes/maxRes/shiftU/filterU\n  \tminBits += (4 /* mixRes/maxRes/etc. */ * 8) + ((partialFrame == true) ? 32 : 0);\n  \tif ( bytesShifted != 0 )\n  \t\tminBits += (numSamples * (bytesShifted * 8));\n  \n  \tescapeBits = (numSamples * mBitDepth) + ((partialFrame == true) ? 32 : 0) + (2 * 8);\t/* 2 common header bytes */\n  \n  \tdoEscape = (minBits >= escapeBits) ? true : false;\n  \n  \tif ( doEscape == false )\n  \t{\n  \t\t// write bitstream header\n  \t\tBitBufferWrite( bitstream, 0, 12 );\n  \t\tBitBufferWrite( bitstream, (partialFrame << 3) | (bytesShifted << 1), 4 );\n  \t\tif ( partialFrame )\n  \t\t\tBitBufferWrite( bitstream, numSamples, 32 );\n  \t\tBitBufferWrite( bitstream, 0, 16 );\t\t\t\t\t\t\t\t// mixBits = mixRes = 0\n  \t\t\n  \t\t// write the params and predictor coefs\n  \t\tnumU = bestU;\n  \t\tBitBufferWrite( bitstream, (0 << 4) | DENSHIFT_DEFAULT, 8 );\t// modeU = 0\n  \t\tBitBufferWrite( bitstream, (pbFactor << 5) | numU, 8 );\n  \t\tfor ( index = 0; index < numU; index++ )\n  \t\t\tBitBufferWrite( bitstream, coefsU[numU-1][index], 16 );\n  \n  \t\t// if shift active, write the interleaved shift buffers\n  \t\tif ( bytesShifted != 0 )\n  \t\t{\n  \t\t\tfor ( index = 0; index < numSamples; index++ )\n  \t\t\t\tBitBufferWrite( bitstream, mShiftBufferUV[index], shift );\n  \t\t}\n  \n  \t\t// run the dynamic predictor with the best result\n  \t\tpc_block( mMixBufferU, mPredictorU, numSamples, coefsU[numU-1], numU, chanBits, DENSHIFT_DEFAULT );\n  \n  \t\t// do lossless compression\n  \t\tset_standard_ag_params( &agParams, numSamples, numSamples );\n  \t\tstatus = dyn_comp( &agParams, mPredictorU, bitstream, numSamples, chanBits, &bits1 );\n  \t\t//AssertNoErr( status );\n  \n  \n  \t\t/*\tif we happened to create a compressed packet that was actually bigger than an escape packet would be,\n  \t\t\tchuck it and do an escape packet\n  \t\t*/\n  \t\tminBits = BitBufferGetPosition( bitstream ) - BitBufferGetPosition( &startBits );\n  \t\tif ( minBits >= escapeBits )\n  \t\t{\n  \t\t\t*bitstream = startBits;\t\t// reset bitstream state\n  \t\t\tdoEscape = true;\n  \t\t}\n  \t}\n  \n  \tif ( doEscape == true )\n  \t{\n  \t\t// write bitstream header and coefs\n  \t\tBitBufferWrite( bitstream, 0, 12 );\n  \t\tBitBufferWrite( bitstream, (partialFrame << 3) | 1, 4 );\t// LSB = 1 means \"frame not compressed\"\n  \t\tif ( partialFrame )\n  \t\t\tBitBufferWrite( bitstream, numSamples, 32 );\n  \n  \t\t// just copy the input data to the output buffer\n  \t\tswitch ( mBitDepth )\n  \t\t{\n  \t\t\tcase 16:\n  \t\t\t\tinput16 = (int16_t *) inputBuffer;\n  \t\t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n  \t\t\t\t\tBitBufferWrite( bitstream, input16[index], 16 );\n  \t\t\t\tbreak;\n  \t\t\tcase 20:\n  \t\t\t\t// convert 20-bit data to 32-bit for simplicity\n  \t\t\t\tcopy20ToPredictor( (uint8_t *) inputBuffer, stride, mMixBufferU, numSamples );\n  \t\t\t\tfor ( index = 0; index < numSamples; index++ )\n  \t\t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 20 );\n  \t\t\t\tbreak;\n  \t\t\tcase 24:\n  \t\t\t\t// convert 24-bit data to 32-bit for simplicity\n  \t\t\t\tcopy24ToPredictor( (uint8_t *) inputBuffer, stride, mMixBufferU, numSamples );\n  \t\t\t\tfor ( index = 0; index < numSamples; index++ )\n  \t\t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 24 );\n  \t\t\t\tbreak;\n  \t\t\tcase 32:\n  \t\t\t\tinput32 = (int32_t *) inputBuffer;\n  \t\t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n  \t\t\t\t\tBitBufferWrite( bitstream, input32[index], 32 );\n  \t\t\t\tbreak;\n  \t\t}\n  #if VERBOSE_DEBUG\t\t\n  \t\tDebugMsg( \"escape!: %lu vs %lu\", minBits, (numSamples * mBitDepth) );\n  #endif\n  \t}\n  \n  Exit:\n  \treturn status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "&bitstream",
            "lfeElementTag",
            "4"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->EncodeStereo",
          "args": [
            "&bitstream",
            "inputBuffer",
            "theInputFormat.mChannelsPerFrame",
            "channelIndex",
            "numFrames"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeStereo",
          "container": "ALACEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
          "lines": "266-541",
          "snippet": "int32_t ALACEncoder::EncodeStereo( BitBuffer * bitstream, void * inputBuffer, uint32_t stride, uint32_t channelIndex, uint32_t numSamples )\n{\n\tBitBuffer\t\tworkBits;\n\tBitBuffer\t\tstartBits = *bitstream;\t\t\t// squirrel away copy of current state in case we need to go back and do an escape packet\n\tAGParamRec\t\tagParams;\n\tuint32_t          bits1, bits2;\n\tuint32_t\t\t\tdilate;\n\tint32_t\t\t\tmixBits, mixRes, maxRes;\n\tuint32_t\t\t\tminBits, minBits1, minBits2;\n\tuint32_t\t\t\tnumU, numV;\n\tuint32_t\t\t\tmode;\n\tuint32_t\t\t\tpbFactor;\n\tuint32_t\t\t\tchanBits;\n\tuint32_t\t\t\tdenShift;\n\tuint8_t\t\t\tbytesShifted;\n\tSearchCoefs\t\tcoefsU;\n\tSearchCoefs\t\tcoefsV;\n\tuint32_t\t\t\tindex;\n\tuint8_t\t\t\tpartialFrame;\n\tuint32_t\t\t\tescapeBits;\n\tbool\t\t\tdoEscape;\n\tint32_t\t\tstatus = ALAC_noErr;\n\n\t// make sure we handle this bit-depth before we get going\n\tRequireAction( (mBitDepth == 16) || (mBitDepth == 20) || (mBitDepth == 24) || (mBitDepth == 32), return kALAC_ParamError; );\n\n\t// reload coefs pointers for this channel pair\n\t// - note that, while you might think they should be re-initialized per block, retaining state across blocks\n\t//\t actually results in better overall compression\n\t// - strangely, re-using the same coefs for the different passes of the \"mixRes\" search loop instead of using\n\t//\t different coefs for the different passes of \"mixRes\" results in even better compression\n\tcoefsU = (SearchCoefs) mCoefsU[channelIndex];\n\tcoefsV = (SearchCoefs) mCoefsV[channelIndex];\n\n\t// matrix encoding adds an extra bit but 32-bit inputs cannot be matrixed b/c 33 is too many\n\t// so enable 16-bit \"shift off\" and encode in 17-bit mode\n\t// - in addition, 24-bit mode really improves with one byte shifted off\n\tif ( mBitDepth == 32 )\n\t\tbytesShifted = 2;\n\telse if ( mBitDepth >= 24 )\n\t\tbytesShifted = 1;\n\telse\n\t\tbytesShifted = 0;\n\n\tchanBits = mBitDepth - (bytesShifted * 8) + 1;\n\t\n\t// flag whether or not this is a partial frame\n\tpartialFrame = (numSamples == mFrameSize) ? 0 : 1;\n\n\t// brute-force encode optimization loop\n\t// - run over variations of the encoding params to find the best choice\n\tmixBits\t\t= kDefaultMixBits;\n\tmaxRes\t\t= kMaxRes;\n\tnumU = numV = kDefaultNumUV;\n\tdenShift\t= DENSHIFT_DEFAULT;\n\tmode\t\t= 0;\n\tpbFactor\t= 4;\n\tdilate\t\t= 8;\n\n\tminBits\t= minBits1 = minBits2 = 1ul << 31;\n\t\n    int32_t\t\tbestRes = mLastMixRes[channelIndex];\n\n    for ( mixRes = 0; mixRes <= maxRes; mixRes++ )\n    {\n        // mix the stereo inputs\n        switch ( mBitDepth )\n        {\n            case 16:\n                mix16( (int16_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples/dilate, mixBits, mixRes );\n                break;\n            case 20:\n                mix20( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples/dilate, mixBits, mixRes );\n                break;\n            case 24:\n                // includes extraction of shifted-off bytes\n                mix24( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples/dilate,\n                        mixBits, mixRes, mShiftBufferUV, bytesShifted );\n                break;\n            case 32:\n                // includes extraction of shifted-off bytes\n                mix32( (int32_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples/dilate,\n                        mixBits, mixRes, mShiftBufferUV, bytesShifted );\n                break;\n        }\n\n        BitBufferInit( &workBits, mWorkBuffer, mMaxOutputBytes );\n        \n        // run the dynamic predictors\n        pc_block( mMixBufferU, mPredictorU, numSamples/dilate, coefsU[numU - 1], numU, chanBits, DENSHIFT_DEFAULT );\n        pc_block( mMixBufferV, mPredictorV, numSamples/dilate, coefsV[numV - 1], numV, chanBits, DENSHIFT_DEFAULT );\n\n        // run the lossless compressor on each channel\n        set_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n        status = dyn_comp( &agParams, mPredictorU, &workBits, numSamples/dilate, chanBits, &bits1 );\n        RequireNoErr( status, goto Exit; );\n\n        set_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n        status = dyn_comp( &agParams, mPredictorV, &workBits, numSamples/dilate, chanBits, &bits2 );\n        RequireNoErr( status, goto Exit; );\n\n        // look for best match\n        if ( (bits1 + bits2) < minBits1 )\n        {\n            minBits1 = bits1 + bits2;\n            bestRes = mixRes;\n        }\n    }\n    \n    mLastMixRes[channelIndex] = (int16_t)bestRes;\n\n\t// mix the stereo inputs with the current best mixRes\n\tmixRes = mLastMixRes[channelIndex];\n\tswitch ( mBitDepth )\n\t{\n\t\tcase 16:\n\t\t\tmix16( (int16_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, mixBits, mixRes );\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tmix20( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, mixBits, mixRes );\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\t// also extracts the shifted off bytes into the shift buffers\n\t\t\tmix24( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples,\n\t\t\t\t\tmixBits, mixRes, mShiftBufferUV, bytesShifted );\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\t// also extracts the shifted off bytes into the shift buffers\n\t\t\tmix32( (int32_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples,\n\t\t\t\t\tmixBits, mixRes, mShiftBufferUV, bytesShifted );\n\t\t\tbreak;\n\t}\n\n\t// now it's time for the predictor coefficient search loop\n\tnumU = numV = kMinUV;\n\tminBits1 = minBits2 = 1ul << 31;\n\n\tfor ( uint32_t numUV = kMinUV; numUV <= kMaxUV; numUV += 4 )\n\t{\n\t\tBitBufferInit( &workBits, mWorkBuffer, mMaxOutputBytes );\t\t\n\n\t\tdilate = 32;\n\n\t\t// run the predictor over the same data multiple times to help it converge\n\t\tfor ( uint32_t converge = 0; converge < 8; converge++ )\n\t\t{\n\t\t    pc_block( mMixBufferU, mPredictorU, numSamples/dilate, coefsU[numUV-1], numUV, chanBits, DENSHIFT_DEFAULT );\n\t\t    pc_block( mMixBufferV, mPredictorV, numSamples/dilate, coefsV[numUV-1], numUV, chanBits, DENSHIFT_DEFAULT );\n\t\t}\n\n\t\tdilate = 8;\n\n\t\tset_ag_params( &agParams, MB0, (pbFactor * PB0)/4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n\t\tstatus = dyn_comp( &agParams, mPredictorU, &workBits, numSamples/dilate, chanBits, &bits1 );\n\n\t\tif ( (bits1 * dilate + 16 * numUV) < minBits1 )\n\t\t{\n\t\t\tminBits1 = bits1 * dilate + 16 * numUV;\n\t\t\tnumU = numUV;\n\t\t}\n\n\t\tset_ag_params( &agParams, MB0, (pbFactor * PB0)/4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n\t\tstatus = dyn_comp( &agParams, mPredictorV, &workBits, numSamples/dilate, chanBits, &bits2 );\n\n\t\tif ( (bits2 * dilate + 16 * numUV) < minBits2 )\n\t\t{\n\t\t\tminBits2 = bits2 * dilate + 16 * numUV;\n\t\t\tnumV = numUV;\n\t\t}\n\t}\n\n\t// test for escape hatch if best calculated compressed size turns out to be more than the input size\n\tminBits = minBits1 + minBits2 + (8 /* mixRes/maxRes/etc. */ * 8) + ((partialFrame == true) ? 32 : 0);\n\tif ( bytesShifted != 0 )\n\t\tminBits += (numSamples * (bytesShifted * 8) * 2);\n\n\tescapeBits = (numSamples * mBitDepth * 2) + ((partialFrame == true) ? 32 : 0) + (2 * 8);\t/* 2 common header bytes */\n\n\tdoEscape = (minBits >= escapeBits) ? true : false;\n\n\tif ( doEscape == false )\n\t{\n\t\t// write bitstream header and coefs\n\t\tBitBufferWrite( bitstream, 0, 12 );\n\t\tBitBufferWrite( bitstream, (partialFrame << 3) | (bytesShifted << 1), 4 );\n\t\tif ( partialFrame )\n\t\t\tBitBufferWrite( bitstream, numSamples, 32 );\n\t\tBitBufferWrite( bitstream, mixBits, 8 );\n\t\tBitBufferWrite( bitstream, mixRes, 8 );\n\t\t\n\t\t//Assert( (mode < 16) && (DENSHIFT_DEFAULT < 16) );\n\t\t//Assert( (pbFactor < 8) && (numU < 32) );\n\t\t//Assert( (pbFactor < 8) && (numV < 32) );\n\n\t\tBitBufferWrite( bitstream, (mode << 4) | DENSHIFT_DEFAULT, 8 );\n\t\tBitBufferWrite( bitstream, (pbFactor << 5) | numU, 8 );\n\t\tfor ( index = 0; index < numU; index++ )\n\t\t\tBitBufferWrite( bitstream, coefsU[numU - 1][index], 16 );\n\n\t\tBitBufferWrite( bitstream, (mode << 4) | DENSHIFT_DEFAULT, 8 );\n\t\tBitBufferWrite( bitstream, (pbFactor << 5) | numV, 8 );\n\t\tfor ( index = 0; index < numV; index++ )\n\t\t\tBitBufferWrite( bitstream, coefsV[numV - 1][index], 16 );\n\n\t\t// if shift active, write the interleaved shift buffers\n\t\tif ( bytesShifted != 0 )\n\t\t{\n\t\t\tuint32_t\t\tbitShift = bytesShifted * 8;\n\n\t\t\t//Assert( bitShift <= 16 );\n\n\t\t\tfor ( index = 0; index < (numSamples * 2); index += 2 )\n\t\t\t{\n\t\t\t\tuint32_t\t\t\tshiftedVal;\n\t\t\t\t\n\t\t\t\tshiftedVal = ((uint32_t)mShiftBufferUV[index + 0] << bitShift) | (uint32_t)mShiftBufferUV[index + 1];\n\t\t\t\tBitBufferWrite( bitstream, shiftedVal, bitShift * 2 );\n\t\t\t}\n\t\t}\n\n\t\t// run the dynamic predictor and lossless compression for the \"left\" channel\n\t\t// - note: to avoid allocating more buffers, we're mixing and matching between the available buffers instead\n\t\t//\t\t   of only using \"U\" buffers for the U-channel and \"V\" buffers for the V-channel\n\t\tif ( mode == 0 )\n\t\t{\n\t\t\tpc_block( mMixBufferU, mPredictorU, numSamples, coefsU[numU - 1], numU, chanBits, DENSHIFT_DEFAULT );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpc_block( mMixBufferU, mPredictorV, numSamples, coefsU[numU - 1], numU, chanBits, DENSHIFT_DEFAULT );\n\t\t\tpc_block( mPredictorV, mPredictorU, numSamples, nil, 31, chanBits, 0 );\n\t\t}\n\n\t\tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT );\n\t\tstatus = dyn_comp( &agParams, mPredictorU, bitstream, numSamples, chanBits, &bits1 );\n\t\tRequireNoErr( status, goto Exit; );\n\n\t\t// run the dynamic predictor and lossless compression for the \"right\" channel\n\t\tif ( mode == 0 )\n\t\t{\n\t\t\tpc_block( mMixBufferV, mPredictorV, numSamples, coefsV[numV - 1], numV, chanBits, DENSHIFT_DEFAULT );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpc_block( mMixBufferV, mPredictorU, numSamples, coefsV[numV - 1], numV, chanBits, DENSHIFT_DEFAULT );\n\t\t\tpc_block( mPredictorU, mPredictorV, numSamples, nil, 31, chanBits, 0 );\n\t\t}\n\n\t\tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT );\n\t\tstatus = dyn_comp( &agParams, mPredictorV, bitstream, numSamples, chanBits, &bits2 );\n\t\tRequireNoErr( status, goto Exit; );\n\n\t\t/*\tif we happened to create a compressed packet that was actually bigger than an escape packet would be,\n\t\t\tchuck it and do an escape packet\n\t\t*/\n\t\tminBits = BitBufferGetPosition( bitstream ) - BitBufferGetPosition( &startBits );\n\t\tif ( minBits >= escapeBits )\n\t\t{\n\t\t\t*bitstream = startBits;\t\t// reset bitstream state\n\t\t\tdoEscape = true;\n\t\t}\n\t}\n\n\tif ( doEscape == true )\n\t{\n\t\t/* escape */\n\t\tstatus = this->EncodeStereoEscape( bitstream, inputBuffer, stride, numSamples );\n\n#if VERBOSE_DEBUG\t\t\n\t\tDebugMsg( \"escape!: %lu vs %lu\", minBits, escapeBits );\n#endif\n\t}\n\t\nExit:\n\treturn status;\n}",
          "includes": [
            "#include \"EndianPortable.h\"",
            "#include \"ALACAudioTypes.h\"",
            "#include \"ALACBitUtilities.h\"",
            "#include \"matrixlib.h\"",
            "#include \"dplib.h\"",
            "#include \"aglib.h\"",
            "#include \"ALACEncoder.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define VERBOSE_DEBUG\t\t0"
          ],
          "globals_used": [
            "const uint32_t kDefaultMixBits\t= 2;",
            "const uint32_t kMaxRes\t\t\t= 4;",
            "const uint32_t kDefaultNumUV\t\t= 8;",
            "const uint32_t kMinUV\t\t\t\t= 4;",
            "const uint32_t kMaxUV\t\t\t\t= 8;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define VERBOSE_DEBUG\t\t0\n\nconst uint32_t kDefaultMixBits\t= 2;\nconst uint32_t kMaxRes\t\t\t= 4;\nconst uint32_t kDefaultNumUV\t\t= 8;\nconst uint32_t kMinUV\t\t\t\t= 4;\nconst uint32_t kMaxUV\t\t\t\t= 8;\n\nALACEncoder {\n  int32_t ALACEncoder::EncodeStereo( BitBuffer * bitstream, void * inputBuffer, uint32_t stride, uint32_t channelIndex, uint32_t numSamples )\n  {\n  \tBitBuffer\t\tworkBits;\n  \tBitBuffer\t\tstartBits = *bitstream;\t\t\t// squirrel away copy of current state in case we need to go back and do an escape packet\n  \tAGParamRec\t\tagParams;\n  \tuint32_t          bits1, bits2;\n  \tuint32_t\t\t\tdilate;\n  \tint32_t\t\t\tmixBits, mixRes, maxRes;\n  \tuint32_t\t\t\tminBits, minBits1, minBits2;\n  \tuint32_t\t\t\tnumU, numV;\n  \tuint32_t\t\t\tmode;\n  \tuint32_t\t\t\tpbFactor;\n  \tuint32_t\t\t\tchanBits;\n  \tuint32_t\t\t\tdenShift;\n  \tuint8_t\t\t\tbytesShifted;\n  \tSearchCoefs\t\tcoefsU;\n  \tSearchCoefs\t\tcoefsV;\n  \tuint32_t\t\t\tindex;\n  \tuint8_t\t\t\tpartialFrame;\n  \tuint32_t\t\t\tescapeBits;\n  \tbool\t\t\tdoEscape;\n  \tint32_t\t\tstatus = ALAC_noErr;\n  \n  \t// make sure we handle this bit-depth before we get going\n  \tRequireAction( (mBitDepth == 16) || (mBitDepth == 20) || (mBitDepth == 24) || (mBitDepth == 32), return kALAC_ParamError; );\n  \n  \t// reload coefs pointers for this channel pair\n  \t// - note that, while you might think they should be re-initialized per block, retaining state across blocks\n  \t//\t actually results in better overall compression\n  \t// - strangely, re-using the same coefs for the different passes of the \"mixRes\" search loop instead of using\n  \t//\t different coefs for the different passes of \"mixRes\" results in even better compression\n  \tcoefsU = (SearchCoefs) mCoefsU[channelIndex];\n  \tcoefsV = (SearchCoefs) mCoefsV[channelIndex];\n  \n  \t// matrix encoding adds an extra bit but 32-bit inputs cannot be matrixed b/c 33 is too many\n  \t// so enable 16-bit \"shift off\" and encode in 17-bit mode\n  \t// - in addition, 24-bit mode really improves with one byte shifted off\n  \tif ( mBitDepth == 32 )\n  \t\tbytesShifted = 2;\n  \telse if ( mBitDepth >= 24 )\n  \t\tbytesShifted = 1;\n  \telse\n  \t\tbytesShifted = 0;\n  \n  \tchanBits = mBitDepth - (bytesShifted * 8) + 1;\n  \t\n  \t// flag whether or not this is a partial frame\n  \tpartialFrame = (numSamples == mFrameSize) ? 0 : 1;\n  \n  \t// brute-force encode optimization loop\n  \t// - run over variations of the encoding params to find the best choice\n  \tmixBits\t\t= kDefaultMixBits;\n  \tmaxRes\t\t= kMaxRes;\n  \tnumU = numV = kDefaultNumUV;\n  \tdenShift\t= DENSHIFT_DEFAULT;\n  \tmode\t\t= 0;\n  \tpbFactor\t= 4;\n  \tdilate\t\t= 8;\n  \n  \tminBits\t= minBits1 = minBits2 = 1ul << 31;\n  \t\n      int32_t\t\tbestRes = mLastMixRes[channelIndex];\n  \n      for ( mixRes = 0; mixRes <= maxRes; mixRes++ )\n      {\n          // mix the stereo inputs\n          switch ( mBitDepth )\n          {\n              case 16:\n                  mix16( (int16_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples/dilate, mixBits, mixRes );\n                  break;\n              case 20:\n                  mix20( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples/dilate, mixBits, mixRes );\n                  break;\n              case 24:\n                  // includes extraction of shifted-off bytes\n                  mix24( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples/dilate,\n                          mixBits, mixRes, mShiftBufferUV, bytesShifted );\n                  break;\n              case 32:\n                  // includes extraction of shifted-off bytes\n                  mix32( (int32_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples/dilate,\n                          mixBits, mixRes, mShiftBufferUV, bytesShifted );\n                  break;\n          }\n  \n          BitBufferInit( &workBits, mWorkBuffer, mMaxOutputBytes );\n          \n          // run the dynamic predictors\n          pc_block( mMixBufferU, mPredictorU, numSamples/dilate, coefsU[numU - 1], numU, chanBits, DENSHIFT_DEFAULT );\n          pc_block( mMixBufferV, mPredictorV, numSamples/dilate, coefsV[numV - 1], numV, chanBits, DENSHIFT_DEFAULT );\n  \n          // run the lossless compressor on each channel\n          set_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n          status = dyn_comp( &agParams, mPredictorU, &workBits, numSamples/dilate, chanBits, &bits1 );\n          RequireNoErr( status, goto Exit; );\n  \n          set_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n          status = dyn_comp( &agParams, mPredictorV, &workBits, numSamples/dilate, chanBits, &bits2 );\n          RequireNoErr( status, goto Exit; );\n  \n          // look for best match\n          if ( (bits1 + bits2) < minBits1 )\n          {\n              minBits1 = bits1 + bits2;\n              bestRes = mixRes;\n          }\n      }\n      \n      mLastMixRes[channelIndex] = (int16_t)bestRes;\n  \n  \t// mix the stereo inputs with the current best mixRes\n  \tmixRes = mLastMixRes[channelIndex];\n  \tswitch ( mBitDepth )\n  \t{\n  \t\tcase 16:\n  \t\t\tmix16( (int16_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, mixBits, mixRes );\n  \t\t\tbreak;\n  \t\tcase 20:\n  \t\t\tmix20( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, mixBits, mixRes );\n  \t\t\tbreak;\n  \t\tcase 24:\n  \t\t\t// also extracts the shifted off bytes into the shift buffers\n  \t\t\tmix24( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples,\n  \t\t\t\t\tmixBits, mixRes, mShiftBufferUV, bytesShifted );\n  \t\t\tbreak;\n  \t\tcase 32:\n  \t\t\t// also extracts the shifted off bytes into the shift buffers\n  \t\t\tmix32( (int32_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples,\n  \t\t\t\t\tmixBits, mixRes, mShiftBufferUV, bytesShifted );\n  \t\t\tbreak;\n  \t}\n  \n  \t// now it's time for the predictor coefficient search loop\n  \tnumU = numV = kMinUV;\n  \tminBits1 = minBits2 = 1ul << 31;\n  \n  \tfor ( uint32_t numUV = kMinUV; numUV <= kMaxUV; numUV += 4 )\n  \t{\n  \t\tBitBufferInit( &workBits, mWorkBuffer, mMaxOutputBytes );\t\t\n  \n  \t\tdilate = 32;\n  \n  \t\t// run the predictor over the same data multiple times to help it converge\n  \t\tfor ( uint32_t converge = 0; converge < 8; converge++ )\n  \t\t{\n  \t\t    pc_block( mMixBufferU, mPredictorU, numSamples/dilate, coefsU[numUV-1], numUV, chanBits, DENSHIFT_DEFAULT );\n  \t\t    pc_block( mMixBufferV, mPredictorV, numSamples/dilate, coefsV[numUV-1], numUV, chanBits, DENSHIFT_DEFAULT );\n  \t\t}\n  \n  \t\tdilate = 8;\n  \n  \t\tset_ag_params( &agParams, MB0, (pbFactor * PB0)/4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n  \t\tstatus = dyn_comp( &agParams, mPredictorU, &workBits, numSamples/dilate, chanBits, &bits1 );\n  \n  \t\tif ( (bits1 * dilate + 16 * numUV) < minBits1 )\n  \t\t{\n  \t\t\tminBits1 = bits1 * dilate + 16 * numUV;\n  \t\t\tnumU = numUV;\n  \t\t}\n  \n  \t\tset_ag_params( &agParams, MB0, (pbFactor * PB0)/4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n  \t\tstatus = dyn_comp( &agParams, mPredictorV, &workBits, numSamples/dilate, chanBits, &bits2 );\n  \n  \t\tif ( (bits2 * dilate + 16 * numUV) < minBits2 )\n  \t\t{\n  \t\t\tminBits2 = bits2 * dilate + 16 * numUV;\n  \t\t\tnumV = numUV;\n  \t\t}\n  \t}\n  \n  \t// test for escape hatch if best calculated compressed size turns out to be more than the input size\n  \tminBits = minBits1 + minBits2 + (8 /* mixRes/maxRes/etc. */ * 8) + ((partialFrame == true) ? 32 : 0);\n  \tif ( bytesShifted != 0 )\n  \t\tminBits += (numSamples * (bytesShifted * 8) * 2);\n  \n  \tescapeBits = (numSamples * mBitDepth * 2) + ((partialFrame == true) ? 32 : 0) + (2 * 8);\t/* 2 common header bytes */\n  \n  \tdoEscape = (minBits >= escapeBits) ? true : false;\n  \n  \tif ( doEscape == false )\n  \t{\n  \t\t// write bitstream header and coefs\n  \t\tBitBufferWrite( bitstream, 0, 12 );\n  \t\tBitBufferWrite( bitstream, (partialFrame << 3) | (bytesShifted << 1), 4 );\n  \t\tif ( partialFrame )\n  \t\t\tBitBufferWrite( bitstream, numSamples, 32 );\n  \t\tBitBufferWrite( bitstream, mixBits, 8 );\n  \t\tBitBufferWrite( bitstream, mixRes, 8 );\n  \t\t\n  \t\t//Assert( (mode < 16) && (DENSHIFT_DEFAULT < 16) );\n  \t\t//Assert( (pbFactor < 8) && (numU < 32) );\n  \t\t//Assert( (pbFactor < 8) && (numV < 32) );\n  \n  \t\tBitBufferWrite( bitstream, (mode << 4) | DENSHIFT_DEFAULT, 8 );\n  \t\tBitBufferWrite( bitstream, (pbFactor << 5) | numU, 8 );\n  \t\tfor ( index = 0; index < numU; index++ )\n  \t\t\tBitBufferWrite( bitstream, coefsU[numU - 1][index], 16 );\n  \n  \t\tBitBufferWrite( bitstream, (mode << 4) | DENSHIFT_DEFAULT, 8 );\n  \t\tBitBufferWrite( bitstream, (pbFactor << 5) | numV, 8 );\n  \t\tfor ( index = 0; index < numV; index++ )\n  \t\t\tBitBufferWrite( bitstream, coefsV[numV - 1][index], 16 );\n  \n  \t\t// if shift active, write the interleaved shift buffers\n  \t\tif ( bytesShifted != 0 )\n  \t\t{\n  \t\t\tuint32_t\t\tbitShift = bytesShifted * 8;\n  \n  \t\t\t//Assert( bitShift <= 16 );\n  \n  \t\t\tfor ( index = 0; index < (numSamples * 2); index += 2 )\n  \t\t\t{\n  \t\t\t\tuint32_t\t\t\tshiftedVal;\n  \t\t\t\t\n  \t\t\t\tshiftedVal = ((uint32_t)mShiftBufferUV[index + 0] << bitShift) | (uint32_t)mShiftBufferUV[index + 1];\n  \t\t\t\tBitBufferWrite( bitstream, shiftedVal, bitShift * 2 );\n  \t\t\t}\n  \t\t}\n  \n  \t\t// run the dynamic predictor and lossless compression for the \"left\" channel\n  \t\t// - note: to avoid allocating more buffers, we're mixing and matching between the available buffers instead\n  \t\t//\t\t   of only using \"U\" buffers for the U-channel and \"V\" buffers for the V-channel\n  \t\tif ( mode == 0 )\n  \t\t{\n  \t\t\tpc_block( mMixBufferU, mPredictorU, numSamples, coefsU[numU - 1], numU, chanBits, DENSHIFT_DEFAULT );\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tpc_block( mMixBufferU, mPredictorV, numSamples, coefsU[numU - 1], numU, chanBits, DENSHIFT_DEFAULT );\n  \t\t\tpc_block( mPredictorV, mPredictorU, numSamples, nil, 31, chanBits, 0 );\n  \t\t}\n  \n  \t\tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT );\n  \t\tstatus = dyn_comp( &agParams, mPredictorU, bitstream, numSamples, chanBits, &bits1 );\n  \t\tRequireNoErr( status, goto Exit; );\n  \n  \t\t// run the dynamic predictor and lossless compression for the \"right\" channel\n  \t\tif ( mode == 0 )\n  \t\t{\n  \t\t\tpc_block( mMixBufferV, mPredictorV, numSamples, coefsV[numV - 1], numV, chanBits, DENSHIFT_DEFAULT );\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tpc_block( mMixBufferV, mPredictorU, numSamples, coefsV[numV - 1], numV, chanBits, DENSHIFT_DEFAULT );\n  \t\t\tpc_block( mPredictorU, mPredictorV, numSamples, nil, 31, chanBits, 0 );\n  \t\t}\n  \n  \t\tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT );\n  \t\tstatus = dyn_comp( &agParams, mPredictorV, bitstream, numSamples, chanBits, &bits2 );\n  \t\tRequireNoErr( status, goto Exit; );\n  \n  \t\t/*\tif we happened to create a compressed packet that was actually bigger than an escape packet would be,\n  \t\t\tchuck it and do an escape packet\n  \t\t*/\n  \t\tminBits = BitBufferGetPosition( bitstream ) - BitBufferGetPosition( &startBits );\n  \t\tif ( minBits >= escapeBits )\n  \t\t{\n  \t\t\t*bitstream = startBits;\t\t// reset bitstream state\n  \t\t\tdoEscape = true;\n  \t\t}\n  \t}\n  \n  \tif ( doEscape == true )\n  \t{\n  \t\t/* escape */\n  \t\tstatus = this->EncodeStereoEscape( bitstream, inputBuffer, stride, numSamples );\n  \n  #if VERBOSE_DEBUG\t\t\n  \t\tDebugMsg( \"escape!: %lu vs %lu\", minBits, escapeBits );\n  #endif\n  \t}\n  \t\n  Exit:\n  \treturn status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "&bitstream",
            "stereoElementTag",
            "4"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "&bitstream",
            "monoElementTag",
            "4"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "&bitstream",
            "tag",
            "3"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "&bitstream",
            "0",
            "4"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "&bitstream",
            "ID_SCE",
            "3"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->EncodeStereoFast",
          "args": [
            "&bitstream",
            "theReadBuffer",
            "2",
            "0",
            "numFrames"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeStereoFast",
          "container": "ALACEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
          "lines": "547-723",
          "snippet": "int32_t ALACEncoder::EncodeStereoFast( BitBuffer * bitstream, void * inputBuffer, uint32_t stride, uint32_t channelIndex, uint32_t numSamples )\n{\n\tBitBuffer\t\tstartBits = *bitstream;\t\t\t// squirrel away current bit position in case we decide to use escape hatch\n\tAGParamRec\t\tagParams;\n\tuint32_t\tbits1, bits2;\n\tint32_t\t\t\tmixBits, mixRes;\n\tuint32_t\t\t\tminBits, minBits1, minBits2;\n\tuint32_t\t\t\tnumU, numV;\n\tuint32_t\t\t\tmode;\n\tuint32_t\t\t\tpbFactor;\n\tuint32_t\t\t\tchanBits;\n\tuint32_t\t\t\tdenShift;\n\tuint8_t\t\t\tbytesShifted;\n\tSearchCoefs\t\tcoefsU;\n\tSearchCoefs\t\tcoefsV;\n\tuint32_t\t\t\tindex;\n\tuint8_t\t\t\tpartialFrame;\n\tuint32_t\t\t\tescapeBits;\n\tbool\t\t\tdoEscape;\t\n\tint32_t\t\tstatus;\n\n\t// make sure we handle this bit-depth before we get going\n\tRequireAction( (mBitDepth == 16) || (mBitDepth == 20) || (mBitDepth == 24) || (mBitDepth == 32), return kALAC_ParamError; );\n\n\t// reload coefs pointers for this channel pair\n\t// - note that, while you might think they should be re-initialized per block, retaining state across blocks\n\t//\t actually results in better overall compression\n\t// - strangely, re-using the same coefs for the different passes of the \"mixRes\" search loop instead of using\n\t//\t different coefs for the different passes of \"mixRes\" results in even better compression\n\tcoefsU = (SearchCoefs) mCoefsU[channelIndex];\n\tcoefsV = (SearchCoefs) mCoefsV[channelIndex];\n\n\t// matrix encoding adds an extra bit but 32-bit inputs cannot be matrixed b/c 33 is too many\n\t// so enable 16-bit \"shift off\" and encode in 17-bit mode\n\t// - in addition, 24-bit mode really improves with one byte shifted off\n\tif ( mBitDepth == 32 )\n\t\tbytesShifted = 2;\n\telse if ( mBitDepth >= 24 )\n\t\tbytesShifted = 1;\n\telse\n\t\tbytesShifted = 0;\n\n\tchanBits = mBitDepth - (bytesShifted * 8) + 1;\n\t\n\t// flag whether or not this is a partial frame\n\tpartialFrame = (numSamples == mFrameSize) ? 0 : 1;\n\n\t// set up default encoding parameters for \"fast\" mode\n\tmixBits\t\t= kDefaultMixBits;\n\tmixRes\t\t= kDefaultMixRes;\n\tnumU = numV = kDefaultNumUV;\n\tdenShift\t= DENSHIFT_DEFAULT;\n\tmode\t\t= 0;\n\tpbFactor\t= 4;\n\n\tminBits\t= minBits1 = minBits2 = 1ul << 31;\n\t\n\t// mix the stereo inputs with default mixBits/mixRes\n\tswitch ( mBitDepth )\n\t{\n\t\tcase 16:\n\t\t\tmix16( (int16_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, mixBits, mixRes );\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tmix20( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, mixBits, mixRes );\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\t// also extracts the shifted off bytes into the shift buffers\n\t\t\tmix24( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples,\n\t\t\t\t\tmixBits, mixRes, mShiftBufferUV, bytesShifted );\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\t// also extracts the shifted off bytes into the shift buffers\n\t\t\tmix32( (int32_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples,\n\t\t\t\t\tmixBits, mixRes, mShiftBufferUV, bytesShifted );\n\t\t\tbreak;\n\t}\n\n\t/* speculatively write the bitstream assuming the compressed version will be smaller */\n\n\t// write bitstream header and coefs\n\tBitBufferWrite( bitstream, 0, 12 );\n\tBitBufferWrite( bitstream, (partialFrame << 3) | (bytesShifted << 1), 4 );\n\tif ( partialFrame )\n\t\tBitBufferWrite( bitstream, numSamples, 32 );\n\tBitBufferWrite( bitstream, mixBits, 8 );\n\tBitBufferWrite( bitstream, mixRes, 8 );\n\t\n\t//Assert( (mode < 16) && (DENSHIFT_DEFAULT < 16) );\n\t//Assert( (pbFactor < 8) && (numU < 32) );\n\t//Assert( (pbFactor < 8) && (numV < 32) );\n\n\tBitBufferWrite( bitstream, (mode << 4) | DENSHIFT_DEFAULT, 8 );\n\tBitBufferWrite( bitstream, (pbFactor << 5) | numU, 8 );\n\tfor ( index = 0; index < numU; index++ )\n\t\tBitBufferWrite( bitstream, coefsU[numU - 1][index], 16 );\n\n\tBitBufferWrite( bitstream, (mode << 4) | DENSHIFT_DEFAULT, 8 );\n\tBitBufferWrite( bitstream, (pbFactor << 5) | numV, 8 );\n\tfor ( index = 0; index < numV; index++ )\n\t\tBitBufferWrite( bitstream, coefsV[numV - 1][index], 16 );\n\n\t// if shift active, write the interleaved shift buffers\n\tif ( bytesShifted != 0 )\n\t{\n\t\tuint32_t\t\tbitShift = bytesShifted * 8;\n\n\t\t//Assert( bitShift <= 16 );\n\n\t\tfor ( index = 0; index < (numSamples * 2); index += 2 )\n\t\t{\n\t\t\tuint32_t\t\t\tshiftedVal;\n\t\t\t\n\t\t\tshiftedVal = ((uint32_t)mShiftBufferUV[index + 0] << bitShift) | (uint32_t)mShiftBufferUV[index + 1];\n\t\t\tBitBufferWrite( bitstream, shiftedVal, bitShift * 2 );\n\t\t}\n\t}\n\n\t// run the dynamic predictor and lossless compression for the \"left\" channel\n\t// - note: we always use mode 0 in the \"fast\" path so we don't need the code for mode != 0\n\tpc_block( mMixBufferU, mPredictorU, numSamples, coefsU[numU - 1], numU, chanBits, DENSHIFT_DEFAULT );\n\n\tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT );\n\tstatus = dyn_comp( &agParams, mPredictorU, bitstream, numSamples, chanBits, &bits1 );\n\tRequireNoErr( status, goto Exit; );\n\n\t// run the dynamic predictor and lossless compression for the \"right\" channel\n\tpc_block( mMixBufferV, mPredictorV, numSamples, coefsV[numV - 1], numV, chanBits, DENSHIFT_DEFAULT );\n\n\tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT );\n\tstatus = dyn_comp( &agParams, mPredictorV, bitstream, numSamples, chanBits, &bits2 );\n\tRequireNoErr( status, goto Exit; );\n\n\t// do bit requirement calculations\n\tminBits1 = bits1 + (numU * sizeof(int16_t) * 8);\n\tminBits2 = bits2 + (numV * sizeof(int16_t) * 8);\n\n\t// test for escape hatch if best calculated compressed size turns out to be more than the input size\n\tminBits = minBits1 + minBits2 + (8 /* mixRes/maxRes/etc. */ * 8) + ((partialFrame == true) ? 32 : 0);\n\tif ( bytesShifted != 0 )\n\t\tminBits += (numSamples * (bytesShifted * 8) * 2);\n\n\tescapeBits = (numSamples * mBitDepth * 2) + ((partialFrame == true) ? 32 : 0) + (2 * 8);\t/* 2 common header bytes */\n\n\tdoEscape = (minBits >= escapeBits) ? true : false;\n\n\tif ( doEscape == false )\n\t{\n\t\t/*\tif we happened to create a compressed packet that was actually bigger than an escape packet would be,\n\t\t\tchuck it and do an escape packet\n\t\t*/\n\t\tminBits = BitBufferGetPosition( bitstream ) - BitBufferGetPosition( &startBits );\n\t\tif ( minBits >= escapeBits )\n\t\t{\n\t\t\tdoEscape = true;\n\t\t}\n\n\t}\n\n\tif ( doEscape == true )\n\t{\n\t\t/* escape */\n\n\t\t// reset bitstream position since we speculatively wrote the compressed version\n\t\t*bitstream = startBits;\n\n\t\t// write escape frame\n\t\tstatus = this->EncodeStereoEscape( bitstream, inputBuffer, stride, numSamples );\n\n#if VERBOSE_DEBUG\t\t\n\t\tDebugMsg( \"escape!: %u vs %u\", minBits, (numSamples * mBitDepth * 2) );\n#endif\n\t}\n\t\nExit:\n\treturn status;\n}",
          "includes": [
            "#include \"EndianPortable.h\"",
            "#include \"ALACAudioTypes.h\"",
            "#include \"ALACBitUtilities.h\"",
            "#include \"matrixlib.h\"",
            "#include \"dplib.h\"",
            "#include \"aglib.h\"",
            "#include \"ALACEncoder.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define VERBOSE_DEBUG\t\t0"
          ],
          "globals_used": [
            "const uint32_t kDefaultMixBits\t= 2;",
            "const uint32_t kDefaultMixRes\t\t= 0;",
            "const uint32_t kDefaultNumUV\t\t= 8;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define VERBOSE_DEBUG\t\t0\n\nconst uint32_t kDefaultMixBits\t= 2;\nconst uint32_t kDefaultMixRes\t\t= 0;\nconst uint32_t kDefaultNumUV\t\t= 8;\n\nALACEncoder {\n  int32_t ALACEncoder::EncodeStereoFast( BitBuffer * bitstream, void * inputBuffer, uint32_t stride, uint32_t channelIndex, uint32_t numSamples )\n  {\n  \tBitBuffer\t\tstartBits = *bitstream;\t\t\t// squirrel away current bit position in case we decide to use escape hatch\n  \tAGParamRec\t\tagParams;\n  \tuint32_t\tbits1, bits2;\n  \tint32_t\t\t\tmixBits, mixRes;\n  \tuint32_t\t\t\tminBits, minBits1, minBits2;\n  \tuint32_t\t\t\tnumU, numV;\n  \tuint32_t\t\t\tmode;\n  \tuint32_t\t\t\tpbFactor;\n  \tuint32_t\t\t\tchanBits;\n  \tuint32_t\t\t\tdenShift;\n  \tuint8_t\t\t\tbytesShifted;\n  \tSearchCoefs\t\tcoefsU;\n  \tSearchCoefs\t\tcoefsV;\n  \tuint32_t\t\t\tindex;\n  \tuint8_t\t\t\tpartialFrame;\n  \tuint32_t\t\t\tescapeBits;\n  \tbool\t\t\tdoEscape;\t\n  \tint32_t\t\tstatus;\n  \n  \t// make sure we handle this bit-depth before we get going\n  \tRequireAction( (mBitDepth == 16) || (mBitDepth == 20) || (mBitDepth == 24) || (mBitDepth == 32), return kALAC_ParamError; );\n  \n  \t// reload coefs pointers for this channel pair\n  \t// - note that, while you might think they should be re-initialized per block, retaining state across blocks\n  \t//\t actually results in better overall compression\n  \t// - strangely, re-using the same coefs for the different passes of the \"mixRes\" search loop instead of using\n  \t//\t different coefs for the different passes of \"mixRes\" results in even better compression\n  \tcoefsU = (SearchCoefs) mCoefsU[channelIndex];\n  \tcoefsV = (SearchCoefs) mCoefsV[channelIndex];\n  \n  \t// matrix encoding adds an extra bit but 32-bit inputs cannot be matrixed b/c 33 is too many\n  \t// so enable 16-bit \"shift off\" and encode in 17-bit mode\n  \t// - in addition, 24-bit mode really improves with one byte shifted off\n  \tif ( mBitDepth == 32 )\n  \t\tbytesShifted = 2;\n  \telse if ( mBitDepth >= 24 )\n  \t\tbytesShifted = 1;\n  \telse\n  \t\tbytesShifted = 0;\n  \n  \tchanBits = mBitDepth - (bytesShifted * 8) + 1;\n  \t\n  \t// flag whether or not this is a partial frame\n  \tpartialFrame = (numSamples == mFrameSize) ? 0 : 1;\n  \n  \t// set up default encoding parameters for \"fast\" mode\n  \tmixBits\t\t= kDefaultMixBits;\n  \tmixRes\t\t= kDefaultMixRes;\n  \tnumU = numV = kDefaultNumUV;\n  \tdenShift\t= DENSHIFT_DEFAULT;\n  \tmode\t\t= 0;\n  \tpbFactor\t= 4;\n  \n  \tminBits\t= minBits1 = minBits2 = 1ul << 31;\n  \t\n  \t// mix the stereo inputs with default mixBits/mixRes\n  \tswitch ( mBitDepth )\n  \t{\n  \t\tcase 16:\n  \t\t\tmix16( (int16_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, mixBits, mixRes );\n  \t\t\tbreak;\n  \t\tcase 20:\n  \t\t\tmix20( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, mixBits, mixRes );\n  \t\t\tbreak;\n  \t\tcase 24:\n  \t\t\t// also extracts the shifted off bytes into the shift buffers\n  \t\t\tmix24( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples,\n  \t\t\t\t\tmixBits, mixRes, mShiftBufferUV, bytesShifted );\n  \t\t\tbreak;\n  \t\tcase 32:\n  \t\t\t// also extracts the shifted off bytes into the shift buffers\n  \t\t\tmix32( (int32_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples,\n  \t\t\t\t\tmixBits, mixRes, mShiftBufferUV, bytesShifted );\n  \t\t\tbreak;\n  \t}\n  \n  \t/* speculatively write the bitstream assuming the compressed version will be smaller */\n  \n  \t// write bitstream header and coefs\n  \tBitBufferWrite( bitstream, 0, 12 );\n  \tBitBufferWrite( bitstream, (partialFrame << 3) | (bytesShifted << 1), 4 );\n  \tif ( partialFrame )\n  \t\tBitBufferWrite( bitstream, numSamples, 32 );\n  \tBitBufferWrite( bitstream, mixBits, 8 );\n  \tBitBufferWrite( bitstream, mixRes, 8 );\n  \t\n  \t//Assert( (mode < 16) && (DENSHIFT_DEFAULT < 16) );\n  \t//Assert( (pbFactor < 8) && (numU < 32) );\n  \t//Assert( (pbFactor < 8) && (numV < 32) );\n  \n  \tBitBufferWrite( bitstream, (mode << 4) | DENSHIFT_DEFAULT, 8 );\n  \tBitBufferWrite( bitstream, (pbFactor << 5) | numU, 8 );\n  \tfor ( index = 0; index < numU; index++ )\n  \t\tBitBufferWrite( bitstream, coefsU[numU - 1][index], 16 );\n  \n  \tBitBufferWrite( bitstream, (mode << 4) | DENSHIFT_DEFAULT, 8 );\n  \tBitBufferWrite( bitstream, (pbFactor << 5) | numV, 8 );\n  \tfor ( index = 0; index < numV; index++ )\n  \t\tBitBufferWrite( bitstream, coefsV[numV - 1][index], 16 );\n  \n  \t// if shift active, write the interleaved shift buffers\n  \tif ( bytesShifted != 0 )\n  \t{\n  \t\tuint32_t\t\tbitShift = bytesShifted * 8;\n  \n  \t\t//Assert( bitShift <= 16 );\n  \n  \t\tfor ( index = 0; index < (numSamples * 2); index += 2 )\n  \t\t{\n  \t\t\tuint32_t\t\t\tshiftedVal;\n  \t\t\t\n  \t\t\tshiftedVal = ((uint32_t)mShiftBufferUV[index + 0] << bitShift) | (uint32_t)mShiftBufferUV[index + 1];\n  \t\t\tBitBufferWrite( bitstream, shiftedVal, bitShift * 2 );\n  \t\t}\n  \t}\n  \n  \t// run the dynamic predictor and lossless compression for the \"left\" channel\n  \t// - note: we always use mode 0 in the \"fast\" path so we don't need the code for mode != 0\n  \tpc_block( mMixBufferU, mPredictorU, numSamples, coefsU[numU - 1], numU, chanBits, DENSHIFT_DEFAULT );\n  \n  \tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT );\n  \tstatus = dyn_comp( &agParams, mPredictorU, bitstream, numSamples, chanBits, &bits1 );\n  \tRequireNoErr( status, goto Exit; );\n  \n  \t// run the dynamic predictor and lossless compression for the \"right\" channel\n  \tpc_block( mMixBufferV, mPredictorV, numSamples, coefsV[numV - 1], numV, chanBits, DENSHIFT_DEFAULT );\n  \n  \tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT );\n  \tstatus = dyn_comp( &agParams, mPredictorV, bitstream, numSamples, chanBits, &bits2 );\n  \tRequireNoErr( status, goto Exit; );\n  \n  \t// do bit requirement calculations\n  \tminBits1 = bits1 + (numU * sizeof(int16_t) * 8);\n  \tminBits2 = bits2 + (numV * sizeof(int16_t) * 8);\n  \n  \t// test for escape hatch if best calculated compressed size turns out to be more than the input size\n  \tminBits = minBits1 + minBits2 + (8 /* mixRes/maxRes/etc. */ * 8) + ((partialFrame == true) ? 32 : 0);\n  \tif ( bytesShifted != 0 )\n  \t\tminBits += (numSamples * (bytesShifted * 8) * 2);\n  \n  \tescapeBits = (numSamples * mBitDepth * 2) + ((partialFrame == true) ? 32 : 0) + (2 * 8);\t/* 2 common header bytes */\n  \n  \tdoEscape = (minBits >= escapeBits) ? true : false;\n  \n  \tif ( doEscape == false )\n  \t{\n  \t\t/*\tif we happened to create a compressed packet that was actually bigger than an escape packet would be,\n  \t\t\tchuck it and do an escape packet\n  \t\t*/\n  \t\tminBits = BitBufferGetPosition( bitstream ) - BitBufferGetPosition( &startBits );\n  \t\tif ( minBits >= escapeBits )\n  \t\t{\n  \t\t\tdoEscape = true;\n  \t\t}\n  \n  \t}\n  \n  \tif ( doEscape == true )\n  \t{\n  \t\t/* escape */\n  \n  \t\t// reset bitstream position since we speculatively wrote the compressed version\n  \t\t*bitstream = startBits;\n  \n  \t\t// write escape frame\n  \t\tstatus = this->EncodeStereoEscape( bitstream, inputBuffer, stride, numSamples );\n  \n  #if VERBOSE_DEBUG\t\t\n  \t\tDebugMsg( \"escape!: %u vs %u\", minBits, (numSamples * mBitDepth * 2) );\n  #endif\n  \t}\n  \t\n  Exit:\n  \treturn status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "&bitstream",
            "0",
            "4"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "&bitstream",
            "ID_CPE",
            "3"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferInit",
          "args": [
            "&bitstream",
            "theWriteBuffer",
            "mMaxOutputBytes"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define VERBOSE_DEBUG\t\t0\n\nstatic const uint32_t\tsChannelMaps[kALACMaxChannels] =\n{\n\tID_SCE,\n\tID_CPE,\n\t(ID_CPE << 3) | (ID_SCE),\n\t(ID_SCE << 9) | (ID_CPE << 3) | (ID_SCE),\n\t(ID_CPE << 9) | (ID_CPE << 3) | (ID_SCE),\n\t(ID_SCE << 15) | (ID_CPE << 9) | (ID_CPE << 3) | (ID_SCE),\n\t(ID_SCE << 18) | (ID_SCE << 15) | (ID_CPE << 9) | (ID_CPE << 3) | (ID_SCE),\n\t(ID_SCE << 21) | (ID_CPE << 15) | (ID_CPE << 9) | (ID_CPE << 3) | (ID_SCE)\n};\n\nALACEncoder {\n  int32_t ALACEncoder::Encode(AudioFormatDescription theInputFormat, AudioFormatDescription theOutputFormat,\n                               unsigned char * theReadBuffer, unsigned char * theWriteBuffer, int32_t * ioNumBytes)\n  {\n  \tuint32_t\t\t\t\tnumFrames;\n  \tuint32_t\t\t\t\toutputSize;\n  \tBitBuffer\t\t\tbitstream;\n  \tint32_t\t\t\tstatus;\n  \n  \tnumFrames = *ioNumBytes/theInputFormat.mBytesPerPacket;\n  \n  \t// create a bit buffer structure pointing to our output buffer\n  \tBitBufferInit( &bitstream, theWriteBuffer, mMaxOutputBytes );\n  \n  \tif ( theInputFormat.mChannelsPerFrame == 2 )\n  \t{\n  \t\t// add 3-bit frame start tag ID_CPE = channel pair & 4-bit element instance tag = 0\n  \t\tBitBufferWrite( &bitstream, ID_CPE, 3 );\n  \t\tBitBufferWrite( &bitstream, 0, 4 );\n  \n  \t\t// encode stereo input buffer\n  \t\tif ( mFastMode == false )\n  \t\t\tstatus = this->EncodeStereo( &bitstream, theReadBuffer, 2, 0, numFrames );\n  \t\telse\n  \t\t\tstatus = this->EncodeStereoFast( &bitstream, theReadBuffer, 2, 0, numFrames );\n  \t\tRequireNoErr( status, goto Exit; );\n  \t}\n  \telse if ( theInputFormat.mChannelsPerFrame == 1 )\n  \t{\n  \t\t// add 3-bit frame start tag ID_SCE = mono channel & 4-bit element instance tag = 0\n  \t\tBitBufferWrite( &bitstream, ID_SCE, 3 );\n  \t\tBitBufferWrite( &bitstream, 0, 4 );\n  \n  \t\t// encode mono input buffer\n  \t\tstatus = this->EncodeMono( &bitstream, theReadBuffer, 1, 0, numFrames );\n  \t\tRequireNoErr( status, goto Exit; );\n  \t}\n  \telse\n  \t{\n  \t\tchar *\t\t\t\t\tinputBuffer;\n  \t\tuint32_t\t\t\t\ttag;\n  \t\tuint32_t\t\t\t\tchannelIndex;\n  \t\tuint32_t\t\t\t\tinputIncrement;\n  \t\tuint8_t\t\t\t\tstereoElementTag;\n  \t\tuint8_t\t\t\t\tmonoElementTag;\n  \t\tuint8_t\t\t\t\tlfeElementTag;\n  \t\t\n  \t\tinputBuffer\t\t= (char *) theReadBuffer;\n  \t\tinputIncrement\t= ((mBitDepth + 7) / 8);\n  \t\t\n  \t\tstereoElementTag\t= 0;\n  \t\tmonoElementTag\t\t= 0;\n  \t\tlfeElementTag\t\t= 0;\n  \n  \t\tfor ( channelIndex = 0; channelIndex < theInputFormat.mChannelsPerFrame; )\n  \t\t{\n  \t\t\ttag = (sChannelMaps[theInputFormat.mChannelsPerFrame - 1] & (0x7ul << (channelIndex * 3))) >> (channelIndex * 3);\n  \t\n  \t\t\tBitBufferWrite( &bitstream, tag, 3 );\n  \t\t\tswitch ( tag )\n  \t\t\t{\n  \t\t\t\tcase ID_SCE:\n  \t\t\t\t\t// mono\n  \t\t\t\t\tBitBufferWrite( &bitstream, monoElementTag, 4 );\n  \n  \t\t\t\t\tstatus = this->EncodeMono( &bitstream, inputBuffer, theInputFormat.mChannelsPerFrame, channelIndex, numFrames );\n  \t\t\t\t\t\n  \t\t\t\t\tinputBuffer += inputIncrement;\n  \t\t\t\t\tchannelIndex++;\n  \t\t\t\t\tmonoElementTag++;\n  \t\t\t\t\tbreak;\n  \n  \t\t\t\tcase ID_CPE:\n  \t\t\t\t\t// stereo\n  \t\t\t\t\tBitBufferWrite( &bitstream, stereoElementTag, 4 );\n  \n  \t\t\t\t\tstatus = this->EncodeStereo( &bitstream, inputBuffer, theInputFormat.mChannelsPerFrame, channelIndex, numFrames );\n  \n  \t\t\t\t\tinputBuffer += (inputIncrement * 2);\n  \t\t\t\t\tchannelIndex += 2;\n  \t\t\t\t\tstereoElementTag++;\n  \t\t\t\t\tbreak;\n  \n  \t\t\t\tcase ID_LFE:\n  \t\t\t\t\t// LFE channel (subwoofer)\n  \t\t\t\t\tBitBufferWrite( &bitstream, lfeElementTag, 4 );\n  \n  \t\t\t\t\tstatus = this->EncodeMono( &bitstream, inputBuffer, theInputFormat.mChannelsPerFrame, channelIndex, numFrames );\n  \n  \t\t\t\t\tinputBuffer += inputIncrement;\n  \t\t\t\t\tchannelIndex++;\n  \t\t\t\t\tlfeElementTag++;\n  \t\t\t\t\tbreak;\n  \n  \t\t\t\tdefault:\n  \t\t\t\t\tstatus = kALAC_ParamError;\n  \t\t\t\t\tgoto Exit;\n  \t\t\t}\n  \n  \t\t\tRequireNoErr( status, goto Exit; );\n  \t\t}\n  \t}\n  \n  #if VERBOSE_DEBUG\n  {\n  \t// if there is room left in the output buffer, add some random fill data to test decoder\n  \tint32_t\t\t\tbitsLeft;\n  \tint32_t\t\t\tbytesLeft;\n  \t\n  \tbitsLeft = BitBufferGetPosition( &bitstream ) - 3;\t// - 3 for ID_END tag\n  \tbytesLeft = bitstream.byteSize - ((bitsLeft + 7) / 8);\n  \t\n  \tif ( (bytesLeft > 20) && ((bytesLeft & 0x4u) != 0) )\n  \t\tAddFiller( &bitstream, bytesLeft );\n  }\n  #endif\n  \n  \t// add 3-bit frame end tag: ID_END\n  \tBitBufferWrite( &bitstream, ID_END, 3 );\n  \n  \t// byte-align the output data\n  \tBitBufferByteAlign( &bitstream, true );\n  \n  \toutputSize = BitBufferGetPosition( &bitstream ) / 8;\n  \t//Assert( outputSize <= mMaxOutputBytes );\n  \n  \n  \t// all good, let iTunes know what happened and remember the total number of input sample frames\n  \t*ioNumBytes = outputSize;\n  \t//mEncodedFrames\t\t   \t   += encodeMsg->numInputSamples;\n  \n  \t// gather encoding stats\n  \tmTotalBytesGenerated += outputSize;\n  \tmMaxFrameBytes = MAX( mMaxFrameBytes, outputSize );\n  \n  \tstatus = ALAC_noErr;\n  \n  Exit:\n  \treturn status;\n  }\n}"
  },
  {
    "function_name": "EncodeMono",
    "container": "ALACEncoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
    "lines": "793-1010",
    "snippet": "int32_t ALACEncoder::EncodeMono( BitBuffer * bitstream, void * inputBuffer, uint32_t stride, uint32_t channelIndex, uint32_t numSamples )\n{\n\tBitBuffer\t\tstartBits = *bitstream;\t\t\t// squirrel away copy of current state in case we need to go back and do an escape packet\n\tAGParamRec\t\tagParams;\n\tuint32_t\tbits1;\n\tuint32_t\t\t\tnumU;\n\tSearchCoefs\t\tcoefsU;\n\tuint32_t\t\t\tdilate;\n\tuint32_t\t\t\tminBits, bestU;\n\tuint32_t\t\t\tminU, maxU;\n\tuint32_t\t\t\tindex, index2;\n\tuint8_t\t\t\tbytesShifted;\n\tuint32_t\t\t\tshift;\n\tuint32_t\t\t\tmask;\n\tuint32_t\t\t\tchanBits;\n\tuint8_t\t\t\tpbFactor;\n\tuint8_t\t\t\tpartialFrame;\n\tint16_t *\t\tinput16;\n\tint32_t *\t\tinput32;\n\tuint32_t\t\t\tescapeBits;\n\tbool\t\t\tdoEscape;\n\tint32_t\t\tstatus;\n\n\t// make sure we handle this bit-depth before we get going\n\tRequireAction( (mBitDepth == 16) || (mBitDepth == 20) || (mBitDepth == 24) || (mBitDepth == 32), return kALAC_ParamError; );\n\n\tstatus = ALAC_noErr;\n\t\n\t// reload coefs array from previous frame\n\tcoefsU = (SearchCoefs) mCoefsU[channelIndex];\n\n\t// pick bit depth for actual encoding\n\t// - we lop off the lower byte(s) for 24-/32-bit encodings\n\tif ( mBitDepth == 32 )\n\t\tbytesShifted = 2;\n\telse if ( mBitDepth >= 24 )\n\t\tbytesShifted = 1;\n\telse\n\t\tbytesShifted = 0;\n\n\tshift = bytesShifted * 8;\n\tmask = (1ul << shift) - 1;\n\tchanBits = mBitDepth - (bytesShifted * 8);\n\n\t// flag whether or not this is a partial frame\n\tpartialFrame = (numSamples == mFrameSize) ? 0 : 1;\n\n\t// convert N-bit data to 32-bit for predictor\n\tswitch ( mBitDepth )\n\t{\n\t\tcase 16:\n\t\t{\n\t\t\t// convert 16-bit data to 32-bit for predictor\n\t\t\tinput16 = (int16_t *) inputBuffer;\n\t\t\tfor ( index = 0, index2 = 0; index < numSamples; index++, index2 += stride )\n\t\t\t\tmMixBufferU[index] = (int32_t) input16[index2];\n\t\t\tbreak;\n\t\t}\n\t\tcase 20:\n\t\t\t// convert 20-bit data to 32-bit for predictor\n\t\t\tcopy20ToPredictor( (uint8_t *) inputBuffer, stride, mMixBufferU, numSamples );\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\t// convert 24-bit data to 32-bit for the predictor and extract the shifted off byte(s)\n\t\t\tcopy24ToPredictor( (uint8_t *) inputBuffer, stride, mMixBufferU, numSamples );\n\t\t\tfor ( index = 0; index < numSamples; index++ )\n\t\t\t{\n\t\t\t\tmShiftBufferUV[index] = (uint16_t)(mMixBufferU[index] & mask);\n\t\t\t\tmMixBufferU[index] >>= shift;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 32:\n\t\t{\n\t\t\t// just copy the 32-bit input data for the predictor and extract the shifted off byte(s)\n\t\t\tinput32 = (int32_t *) inputBuffer;\n\n\t\t\tfor ( index = 0, index2 = 0; index < numSamples; index++, index2 += stride )\n\t\t\t{\n\t\t\t\tint32_t\t\t\tval = input32[index2];\n\t\t\t\t\n\t\t\t\tmShiftBufferUV[index] = (uint16_t)(val & mask);\n\t\t\t\tmMixBufferU[index] = val >> shift;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// brute-force encode optimization loop (implied \"encode depth\" of 0 if comparing to cmd line tool)\n\t// - run over variations of the encoding params to find the best choice\n\tminU\t\t= 4;\n\tmaxU\t\t= 8;\n\tminBits\t\t= 1ul << 31;\n\tpbFactor\t= 4;\n\t\n\tminBits\t= 1ul << 31;\n\tbestU\t= minU;\n\n\tfor ( numU = minU; numU <= maxU; numU += 4 )\n\t{\n\t\tBitBuffer\t\tworkBits;\n\t\tuint32_t\t\t\tnumBits;\n\n\t\tBitBufferInit( &workBits, mWorkBuffer, mMaxOutputBytes );\n\t\n\t\tdilate = 32;\n\t\tfor ( uint32_t converge = 0; converge < 7; converge++ )\t\n\t\t\tpc_block( mMixBufferU, mPredictorU, numSamples/dilate, coefsU[numU-1], numU, chanBits, DENSHIFT_DEFAULT );\n\n\t\tdilate = 8;\n\t\tpc_block( mMixBufferU, mPredictorU, numSamples/dilate, coefsU[numU-1], numU, chanBits, DENSHIFT_DEFAULT );\n\n\t\tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n\t\tstatus = dyn_comp( &agParams, mPredictorU, &workBits, numSamples/dilate, chanBits, &bits1 );\n\t\tRequireNoErr( status, goto Exit; );\n\n\t\tnumBits = (dilate * bits1) + (16 * numU);\n\t\tif ( numBits < minBits )\n\t\t{\n\t\t\tbestU\t= numU;\n\t\t\tminBits = numBits;\n\t\t}\n\t}             \n\n\t// test for escape hatch if best calculated compressed size turns out to be more than the input size\n\t// - first, add bits for the header bytes mixRes/maxRes/shiftU/filterU\n\tminBits += (4 /* mixRes/maxRes/etc. */ * 8) + ((partialFrame == true) ? 32 : 0);\n\tif ( bytesShifted != 0 )\n\t\tminBits += (numSamples * (bytesShifted * 8));\n\n\tescapeBits = (numSamples * mBitDepth) + ((partialFrame == true) ? 32 : 0) + (2 * 8);\t/* 2 common header bytes */\n\n\tdoEscape = (minBits >= escapeBits) ? true : false;\n\n\tif ( doEscape == false )\n\t{\n\t\t// write bitstream header\n\t\tBitBufferWrite( bitstream, 0, 12 );\n\t\tBitBufferWrite( bitstream, (partialFrame << 3) | (bytesShifted << 1), 4 );\n\t\tif ( partialFrame )\n\t\t\tBitBufferWrite( bitstream, numSamples, 32 );\n\t\tBitBufferWrite( bitstream, 0, 16 );\t\t\t\t\t\t\t\t// mixBits = mixRes = 0\n\t\t\n\t\t// write the params and predictor coefs\n\t\tnumU = bestU;\n\t\tBitBufferWrite( bitstream, (0 << 4) | DENSHIFT_DEFAULT, 8 );\t// modeU = 0\n\t\tBitBufferWrite( bitstream, (pbFactor << 5) | numU, 8 );\n\t\tfor ( index = 0; index < numU; index++ )\n\t\t\tBitBufferWrite( bitstream, coefsU[numU-1][index], 16 );\n\n\t\t// if shift active, write the interleaved shift buffers\n\t\tif ( bytesShifted != 0 )\n\t\t{\n\t\t\tfor ( index = 0; index < numSamples; index++ )\n\t\t\t\tBitBufferWrite( bitstream, mShiftBufferUV[index], shift );\n\t\t}\n\n\t\t// run the dynamic predictor with the best result\n\t\tpc_block( mMixBufferU, mPredictorU, numSamples, coefsU[numU-1], numU, chanBits, DENSHIFT_DEFAULT );\n\n\t\t// do lossless compression\n\t\tset_standard_ag_params( &agParams, numSamples, numSamples );\n\t\tstatus = dyn_comp( &agParams, mPredictorU, bitstream, numSamples, chanBits, &bits1 );\n\t\t//AssertNoErr( status );\n\n\n\t\t/*\tif we happened to create a compressed packet that was actually bigger than an escape packet would be,\n\t\t\tchuck it and do an escape packet\n\t\t*/\n\t\tminBits = BitBufferGetPosition( bitstream ) - BitBufferGetPosition( &startBits );\n\t\tif ( minBits >= escapeBits )\n\t\t{\n\t\t\t*bitstream = startBits;\t\t// reset bitstream state\n\t\t\tdoEscape = true;\n\t\t}\n\t}\n\n\tif ( doEscape == true )\n\t{\n\t\t// write bitstream header and coefs\n\t\tBitBufferWrite( bitstream, 0, 12 );\n\t\tBitBufferWrite( bitstream, (partialFrame << 3) | 1, 4 );\t// LSB = 1 means \"frame not compressed\"\n\t\tif ( partialFrame )\n\t\t\tBitBufferWrite( bitstream, numSamples, 32 );\n\n\t\t// just copy the input data to the output buffer\n\t\tswitch ( mBitDepth )\n\t\t{\n\t\t\tcase 16:\n\t\t\t\tinput16 = (int16_t *) inputBuffer;\n\t\t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n\t\t\t\t\tBitBufferWrite( bitstream, input16[index], 16 );\n\t\t\t\tbreak;\n\t\t\tcase 20:\n\t\t\t\t// convert 20-bit data to 32-bit for simplicity\n\t\t\t\tcopy20ToPredictor( (uint8_t *) inputBuffer, stride, mMixBufferU, numSamples );\n\t\t\t\tfor ( index = 0; index < numSamples; index++ )\n\t\t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 20 );\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\t\t// convert 24-bit data to 32-bit for simplicity\n\t\t\t\tcopy24ToPredictor( (uint8_t *) inputBuffer, stride, mMixBufferU, numSamples );\n\t\t\t\tfor ( index = 0; index < numSamples; index++ )\n\t\t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 24 );\n\t\t\t\tbreak;\n\t\t\tcase 32:\n\t\t\t\tinput32 = (int32_t *) inputBuffer;\n\t\t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n\t\t\t\t\tBitBufferWrite( bitstream, input32[index], 32 );\n\t\t\t\tbreak;\n\t\t}\n#if VERBOSE_DEBUG\t\t\n\t\tDebugMsg( \"escape!: %lu vs %lu\", minBits, (numSamples * mBitDepth) );\n#endif\n\t}\n\nExit:\n\treturn status;\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACAudioTypes.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"dplib.h\"",
      "#include \"aglib.h\"",
      "#include \"ALACEncoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define VERBOSE_DEBUG\t\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DebugMsg",
          "args": [
            "\"escape!: %lu vs %lu\"",
            "minBits",
            "(numSamples * mBitDepth)"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "input32[index]",
            "32"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "mMixBufferU[index]",
            "24"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy24ToPredictor",
          "args": [
            "(uint8_t *) inputBuffer",
            "stride",
            "mMixBufferU",
            "numSamples"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "mMixBufferU[index]",
            "20"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy20ToPredictor",
          "args": [
            "(uint8_t *) inputBuffer",
            "stride",
            "mMixBufferU",
            "numSamples"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "input16[index]",
            "16"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "numSamples",
            "32"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "(partialFrame << 3) | 1",
            "4"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "0",
            "12"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferGetPosition",
          "args": [
            "&startBits"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferGetPosition",
          "args": [
            "bitstream"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dyn_comp",
          "args": [
            "&agParams",
            "mPredictorU",
            "bitstream",
            "numSamples",
            "chanBits",
            "&bits1"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_standard_ag_params",
          "args": [
            "&agParams",
            "numSamples",
            "numSamples"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc_block",
          "args": [
            "mMixBufferU",
            "mPredictorU",
            "numSamples",
            "coefsU[numU-1]",
            "numU",
            "chanBits",
            "DENSHIFT_DEFAULT"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "mShiftBufferUV[index]",
            "shift"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "coefsU[numU-1][index]",
            "16"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "(pbFactor << 5) | numU",
            "8"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "(0 << 4) | DENSHIFT_DEFAULT",
            "8"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "0",
            "16"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "numSamples",
            "32"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "(partialFrame << 3) | (bytesShifted << 1)",
            "4"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "0",
            "12"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dyn_comp",
          "args": [
            "&agParams",
            "mPredictorU",
            "&workBits",
            "numSamples/dilate",
            "chanBits",
            "&bits1"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ag_params",
          "args": [
            "&agParams",
            "MB0",
            "(pbFactor * PB0) / 4",
            "KB0",
            "numSamples/dilate",
            "numSamples/dilate",
            "MAX_RUN_DEFAULT"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc_block",
          "args": [
            "mMixBufferU",
            "mPredictorU",
            "numSamples/dilate",
            "coefsU[numU-1]",
            "numU",
            "chanBits",
            "DENSHIFT_DEFAULT"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc_block",
          "args": [
            "mMixBufferU",
            "mPredictorU",
            "numSamples/dilate",
            "coefsU[numU-1]",
            "numU",
            "chanBits",
            "DENSHIFT_DEFAULT"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferInit",
          "args": [
            "&workBits",
            "mWorkBuffer",
            "mMaxOutputBytes"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy24ToPredictor",
          "args": [
            "(uint8_t *) inputBuffer",
            "stride",
            "mMixBufferU",
            "numSamples"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy20ToPredictor",
          "args": [
            "(uint8_t *) inputBuffer",
            "stride",
            "mMixBufferU",
            "numSamples"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RequireAction",
          "args": [
            "(mBitDepth == 16) || (mBitDepth == 20) || (mBitDepth == 24) || (mBitDepth == 32)",
            "returnkALAC_ParamError;"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define VERBOSE_DEBUG\t\t0\n\nALACEncoder {\n  int32_t ALACEncoder::EncodeMono( BitBuffer * bitstream, void * inputBuffer, uint32_t stride, uint32_t channelIndex, uint32_t numSamples )\n  {\n  \tBitBuffer\t\tstartBits = *bitstream;\t\t\t// squirrel away copy of current state in case we need to go back and do an escape packet\n  \tAGParamRec\t\tagParams;\n  \tuint32_t\tbits1;\n  \tuint32_t\t\t\tnumU;\n  \tSearchCoefs\t\tcoefsU;\n  \tuint32_t\t\t\tdilate;\n  \tuint32_t\t\t\tminBits, bestU;\n  \tuint32_t\t\t\tminU, maxU;\n  \tuint32_t\t\t\tindex, index2;\n  \tuint8_t\t\t\tbytesShifted;\n  \tuint32_t\t\t\tshift;\n  \tuint32_t\t\t\tmask;\n  \tuint32_t\t\t\tchanBits;\n  \tuint8_t\t\t\tpbFactor;\n  \tuint8_t\t\t\tpartialFrame;\n  \tint16_t *\t\tinput16;\n  \tint32_t *\t\tinput32;\n  \tuint32_t\t\t\tescapeBits;\n  \tbool\t\t\tdoEscape;\n  \tint32_t\t\tstatus;\n  \n  \t// make sure we handle this bit-depth before we get going\n  \tRequireAction( (mBitDepth == 16) || (mBitDepth == 20) || (mBitDepth == 24) || (mBitDepth == 32), return kALAC_ParamError; );\n  \n  \tstatus = ALAC_noErr;\n  \t\n  \t// reload coefs array from previous frame\n  \tcoefsU = (SearchCoefs) mCoefsU[channelIndex];\n  \n  \t// pick bit depth for actual encoding\n  \t// - we lop off the lower byte(s) for 24-/32-bit encodings\n  \tif ( mBitDepth == 32 )\n  \t\tbytesShifted = 2;\n  \telse if ( mBitDepth >= 24 )\n  \t\tbytesShifted = 1;\n  \telse\n  \t\tbytesShifted = 0;\n  \n  \tshift = bytesShifted * 8;\n  \tmask = (1ul << shift) - 1;\n  \tchanBits = mBitDepth - (bytesShifted * 8);\n  \n  \t// flag whether or not this is a partial frame\n  \tpartialFrame = (numSamples == mFrameSize) ? 0 : 1;\n  \n  \t// convert N-bit data to 32-bit for predictor\n  \tswitch ( mBitDepth )\n  \t{\n  \t\tcase 16:\n  \t\t{\n  \t\t\t// convert 16-bit data to 32-bit for predictor\n  \t\t\tinput16 = (int16_t *) inputBuffer;\n  \t\t\tfor ( index = 0, index2 = 0; index < numSamples; index++, index2 += stride )\n  \t\t\t\tmMixBufferU[index] = (int32_t) input16[index2];\n  \t\t\tbreak;\n  \t\t}\n  \t\tcase 20:\n  \t\t\t// convert 20-bit data to 32-bit for predictor\n  \t\t\tcopy20ToPredictor( (uint8_t *) inputBuffer, stride, mMixBufferU, numSamples );\n  \t\t\tbreak;\n  \t\tcase 24:\n  \t\t\t// convert 24-bit data to 32-bit for the predictor and extract the shifted off byte(s)\n  \t\t\tcopy24ToPredictor( (uint8_t *) inputBuffer, stride, mMixBufferU, numSamples );\n  \t\t\tfor ( index = 0; index < numSamples; index++ )\n  \t\t\t{\n  \t\t\t\tmShiftBufferUV[index] = (uint16_t)(mMixBufferU[index] & mask);\n  \t\t\t\tmMixBufferU[index] >>= shift;\n  \t\t\t}\n  \t\t\tbreak;\n  \t\tcase 32:\n  \t\t{\n  \t\t\t// just copy the 32-bit input data for the predictor and extract the shifted off byte(s)\n  \t\t\tinput32 = (int32_t *) inputBuffer;\n  \n  \t\t\tfor ( index = 0, index2 = 0; index < numSamples; index++, index2 += stride )\n  \t\t\t{\n  \t\t\t\tint32_t\t\t\tval = input32[index2];\n  \t\t\t\t\n  \t\t\t\tmShiftBufferUV[index] = (uint16_t)(val & mask);\n  \t\t\t\tmMixBufferU[index] = val >> shift;\n  \t\t\t}\n  \t\t\tbreak;\n  \t\t}\n  \t}\n  \n  \t// brute-force encode optimization loop (implied \"encode depth\" of 0 if comparing to cmd line tool)\n  \t// - run over variations of the encoding params to find the best choice\n  \tminU\t\t= 4;\n  \tmaxU\t\t= 8;\n  \tminBits\t\t= 1ul << 31;\n  \tpbFactor\t= 4;\n  \t\n  \tminBits\t= 1ul << 31;\n  \tbestU\t= minU;\n  \n  \tfor ( numU = minU; numU <= maxU; numU += 4 )\n  \t{\n  \t\tBitBuffer\t\tworkBits;\n  \t\tuint32_t\t\t\tnumBits;\n  \n  \t\tBitBufferInit( &workBits, mWorkBuffer, mMaxOutputBytes );\n  \t\n  \t\tdilate = 32;\n  \t\tfor ( uint32_t converge = 0; converge < 7; converge++ )\t\n  \t\t\tpc_block( mMixBufferU, mPredictorU, numSamples/dilate, coefsU[numU-1], numU, chanBits, DENSHIFT_DEFAULT );\n  \n  \t\tdilate = 8;\n  \t\tpc_block( mMixBufferU, mPredictorU, numSamples/dilate, coefsU[numU-1], numU, chanBits, DENSHIFT_DEFAULT );\n  \n  \t\tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n  \t\tstatus = dyn_comp( &agParams, mPredictorU, &workBits, numSamples/dilate, chanBits, &bits1 );\n  \t\tRequireNoErr( status, goto Exit; );\n  \n  \t\tnumBits = (dilate * bits1) + (16 * numU);\n  \t\tif ( numBits < minBits )\n  \t\t{\n  \t\t\tbestU\t= numU;\n  \t\t\tminBits = numBits;\n  \t\t}\n  \t}             \n  \n  \t// test for escape hatch if best calculated compressed size turns out to be more than the input size\n  \t// - first, add bits for the header bytes mixRes/maxRes/shiftU/filterU\n  \tminBits += (4 /* mixRes/maxRes/etc. */ * 8) + ((partialFrame == true) ? 32 : 0);\n  \tif ( bytesShifted != 0 )\n  \t\tminBits += (numSamples * (bytesShifted * 8));\n  \n  \tescapeBits = (numSamples * mBitDepth) + ((partialFrame == true) ? 32 : 0) + (2 * 8);\t/* 2 common header bytes */\n  \n  \tdoEscape = (minBits >= escapeBits) ? true : false;\n  \n  \tif ( doEscape == false )\n  \t{\n  \t\t// write bitstream header\n  \t\tBitBufferWrite( bitstream, 0, 12 );\n  \t\tBitBufferWrite( bitstream, (partialFrame << 3) | (bytesShifted << 1), 4 );\n  \t\tif ( partialFrame )\n  \t\t\tBitBufferWrite( bitstream, numSamples, 32 );\n  \t\tBitBufferWrite( bitstream, 0, 16 );\t\t\t\t\t\t\t\t// mixBits = mixRes = 0\n  \t\t\n  \t\t// write the params and predictor coefs\n  \t\tnumU = bestU;\n  \t\tBitBufferWrite( bitstream, (0 << 4) | DENSHIFT_DEFAULT, 8 );\t// modeU = 0\n  \t\tBitBufferWrite( bitstream, (pbFactor << 5) | numU, 8 );\n  \t\tfor ( index = 0; index < numU; index++ )\n  \t\t\tBitBufferWrite( bitstream, coefsU[numU-1][index], 16 );\n  \n  \t\t// if shift active, write the interleaved shift buffers\n  \t\tif ( bytesShifted != 0 )\n  \t\t{\n  \t\t\tfor ( index = 0; index < numSamples; index++ )\n  \t\t\t\tBitBufferWrite( bitstream, mShiftBufferUV[index], shift );\n  \t\t}\n  \n  \t\t// run the dynamic predictor with the best result\n  \t\tpc_block( mMixBufferU, mPredictorU, numSamples, coefsU[numU-1], numU, chanBits, DENSHIFT_DEFAULT );\n  \n  \t\t// do lossless compression\n  \t\tset_standard_ag_params( &agParams, numSamples, numSamples );\n  \t\tstatus = dyn_comp( &agParams, mPredictorU, bitstream, numSamples, chanBits, &bits1 );\n  \t\t//AssertNoErr( status );\n  \n  \n  \t\t/*\tif we happened to create a compressed packet that was actually bigger than an escape packet would be,\n  \t\t\tchuck it and do an escape packet\n  \t\t*/\n  \t\tminBits = BitBufferGetPosition( bitstream ) - BitBufferGetPosition( &startBits );\n  \t\tif ( minBits >= escapeBits )\n  \t\t{\n  \t\t\t*bitstream = startBits;\t\t// reset bitstream state\n  \t\t\tdoEscape = true;\n  \t\t}\n  \t}\n  \n  \tif ( doEscape == true )\n  \t{\n  \t\t// write bitstream header and coefs\n  \t\tBitBufferWrite( bitstream, 0, 12 );\n  \t\tBitBufferWrite( bitstream, (partialFrame << 3) | 1, 4 );\t// LSB = 1 means \"frame not compressed\"\n  \t\tif ( partialFrame )\n  \t\t\tBitBufferWrite( bitstream, numSamples, 32 );\n  \n  \t\t// just copy the input data to the output buffer\n  \t\tswitch ( mBitDepth )\n  \t\t{\n  \t\t\tcase 16:\n  \t\t\t\tinput16 = (int16_t *) inputBuffer;\n  \t\t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n  \t\t\t\t\tBitBufferWrite( bitstream, input16[index], 16 );\n  \t\t\t\tbreak;\n  \t\t\tcase 20:\n  \t\t\t\t// convert 20-bit data to 32-bit for simplicity\n  \t\t\t\tcopy20ToPredictor( (uint8_t *) inputBuffer, stride, mMixBufferU, numSamples );\n  \t\t\t\tfor ( index = 0; index < numSamples; index++ )\n  \t\t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 20 );\n  \t\t\t\tbreak;\n  \t\t\tcase 24:\n  \t\t\t\t// convert 24-bit data to 32-bit for simplicity\n  \t\t\t\tcopy24ToPredictor( (uint8_t *) inputBuffer, stride, mMixBufferU, numSamples );\n  \t\t\t\tfor ( index = 0; index < numSamples; index++ )\n  \t\t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 24 );\n  \t\t\t\tbreak;\n  \t\t\tcase 32:\n  \t\t\t\tinput32 = (int32_t *) inputBuffer;\n  \t\t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n  \t\t\t\t\tBitBufferWrite( bitstream, input32[index], 32 );\n  \t\t\t\tbreak;\n  \t\t}\n  #if VERBOSE_DEBUG\t\t\n  \t\tDebugMsg( \"escape!: %lu vs %lu\", minBits, (numSamples * mBitDepth) );\n  #endif\n  \t}\n  \n  Exit:\n  \treturn status;\n  }\n}"
  },
  {
    "function_name": "EncodeStereoEscape",
    "container": "ALACEncoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
    "lines": "729-787",
    "snippet": "int32_t ALACEncoder::EncodeStereoEscape( BitBuffer * bitstream, void * inputBuffer, uint32_t stride, uint32_t numSamples )\n{\n\tint16_t *\t\tinput16;\n\tint32_t *\t\tinput32;\n\tuint8_t\t\t\tpartialFrame;\n\tuint32_t\t\t\tindex;\n\n\t// flag whether or not this is a partial frame\n\tpartialFrame = (numSamples == mFrameSize) ? 0 : 1;\n\n\t// write bitstream header\n\tBitBufferWrite( bitstream, 0, 12 );\n\tBitBufferWrite( bitstream, (partialFrame << 3) | 1, 4 );\t// LSB = 1 means \"frame not compressed\"\n\tif ( partialFrame )\n\t\tBitBufferWrite( bitstream, numSamples, 32 );\n\n\t// just copy the input data to the output buffer\n\tswitch ( mBitDepth )\n\t{\n\t\tcase 16:\n\t\t\tinput16 = (int16_t *) inputBuffer;\n\t\t\t\n\t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n\t\t\t{\n\t\t\t\tBitBufferWrite( bitstream, input16[index + 0], 16 );\n\t\t\t\tBitBufferWrite( bitstream, input16[index + 1], 16 );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\t// mix20() with mixres param = 0 means de-interleave so use it to simplify things\n\t\t\tmix20( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, 0, 0 );\n\t\t\tfor ( index = 0; index < numSamples; index++ )\n\t\t\t{\n\t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 20 );\n\t\t\t\tBitBufferWrite( bitstream, mMixBufferV[index], 20 );\n\t\t\t}\t\t\t\t\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\t// mix24() with mixres param = 0 means de-interleave so use it to simplify things\n\t\t\tmix24( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, 0, 0, mShiftBufferUV, 0 );\n\t\t\tfor ( index = 0; index < numSamples; index++ )\n\t\t\t{\n\t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 24 );\n\t\t\t\tBitBufferWrite( bitstream, mMixBufferV[index], 24 );\n\t\t\t}\t\t\t\t\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tinput32 = (int32_t *) inputBuffer;\n\n\t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n\t\t\t{\n\t\t\t\tBitBufferWrite( bitstream, input32[index + 0], 32 );\n\t\t\t\tBitBufferWrite( bitstream, input32[index + 1], 32 );\n\t\t\t}\t\t\t\t\n\t\t\tbreak;\n\t}\n\t\n\treturn ALAC_noErr;\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACAudioTypes.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"dplib.h\"",
      "#include \"aglib.h\"",
      "#include \"ALACEncoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "input32[index + 1]",
            "32"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "input32[index + 0]",
            "32"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "mMixBufferV[index]",
            "24"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "mMixBufferU[index]",
            "24"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mix24",
          "args": [
            "(uint8_t *) inputBuffer",
            "stride",
            "mMixBufferU",
            "mMixBufferV",
            "numSamples",
            "0",
            "0",
            "mShiftBufferUV",
            "0"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "mMixBufferV[index]",
            "20"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "mMixBufferU[index]",
            "20"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mix20",
          "args": [
            "(uint8_t *) inputBuffer",
            "stride",
            "mMixBufferU",
            "mMixBufferV",
            "numSamples",
            "0",
            "0"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "input16[index + 1]",
            "16"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "input16[index + 0]",
            "16"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "numSamples",
            "32"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "(partialFrame << 3) | 1",
            "4"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "0",
            "12"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nALACEncoder {\n  int32_t ALACEncoder::EncodeStereoEscape( BitBuffer * bitstream, void * inputBuffer, uint32_t stride, uint32_t numSamples )\n  {\n  \tint16_t *\t\tinput16;\n  \tint32_t *\t\tinput32;\n  \tuint8_t\t\t\tpartialFrame;\n  \tuint32_t\t\t\tindex;\n  \n  \t// flag whether or not this is a partial frame\n  \tpartialFrame = (numSamples == mFrameSize) ? 0 : 1;\n  \n  \t// write bitstream header\n  \tBitBufferWrite( bitstream, 0, 12 );\n  \tBitBufferWrite( bitstream, (partialFrame << 3) | 1, 4 );\t// LSB = 1 means \"frame not compressed\"\n  \tif ( partialFrame )\n  \t\tBitBufferWrite( bitstream, numSamples, 32 );\n  \n  \t// just copy the input data to the output buffer\n  \tswitch ( mBitDepth )\n  \t{\n  \t\tcase 16:\n  \t\t\tinput16 = (int16_t *) inputBuffer;\n  \t\t\t\n  \t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n  \t\t\t{\n  \t\t\t\tBitBufferWrite( bitstream, input16[index + 0], 16 );\n  \t\t\t\tBitBufferWrite( bitstream, input16[index + 1], 16 );\n  \t\t\t}\n  \t\t\tbreak;\n  \t\tcase 20:\n  \t\t\t// mix20() with mixres param = 0 means de-interleave so use it to simplify things\n  \t\t\tmix20( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, 0, 0 );\n  \t\t\tfor ( index = 0; index < numSamples; index++ )\n  \t\t\t{\n  \t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 20 );\n  \t\t\t\tBitBufferWrite( bitstream, mMixBufferV[index], 20 );\n  \t\t\t}\t\t\t\t\n  \t\t\tbreak;\n  \t\tcase 24:\n  \t\t\t// mix24() with mixres param = 0 means de-interleave so use it to simplify things\n  \t\t\tmix24( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, 0, 0, mShiftBufferUV, 0 );\n  \t\t\tfor ( index = 0; index < numSamples; index++ )\n  \t\t\t{\n  \t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 24 );\n  \t\t\t\tBitBufferWrite( bitstream, mMixBufferV[index], 24 );\n  \t\t\t}\t\t\t\t\n  \t\t\tbreak;\n  \t\tcase 32:\n  \t\t\tinput32 = (int32_t *) inputBuffer;\n  \n  \t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n  \t\t\t{\n  \t\t\t\tBitBufferWrite( bitstream, input32[index + 0], 32 );\n  \t\t\t\tBitBufferWrite( bitstream, input32[index + 1], 32 );\n  \t\t\t}\t\t\t\t\n  \t\t\tbreak;\n  \t}\n  \t\n  \treturn ALAC_noErr;\n  }\n}"
  },
  {
    "function_name": "EncodeStereoFast",
    "container": "ALACEncoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
    "lines": "547-723",
    "snippet": "int32_t ALACEncoder::EncodeStereoFast( BitBuffer * bitstream, void * inputBuffer, uint32_t stride, uint32_t channelIndex, uint32_t numSamples )\n{\n\tBitBuffer\t\tstartBits = *bitstream;\t\t\t// squirrel away current bit position in case we decide to use escape hatch\n\tAGParamRec\t\tagParams;\n\tuint32_t\tbits1, bits2;\n\tint32_t\t\t\tmixBits, mixRes;\n\tuint32_t\t\t\tminBits, minBits1, minBits2;\n\tuint32_t\t\t\tnumU, numV;\n\tuint32_t\t\t\tmode;\n\tuint32_t\t\t\tpbFactor;\n\tuint32_t\t\t\tchanBits;\n\tuint32_t\t\t\tdenShift;\n\tuint8_t\t\t\tbytesShifted;\n\tSearchCoefs\t\tcoefsU;\n\tSearchCoefs\t\tcoefsV;\n\tuint32_t\t\t\tindex;\n\tuint8_t\t\t\tpartialFrame;\n\tuint32_t\t\t\tescapeBits;\n\tbool\t\t\tdoEscape;\t\n\tint32_t\t\tstatus;\n\n\t// make sure we handle this bit-depth before we get going\n\tRequireAction( (mBitDepth == 16) || (mBitDepth == 20) || (mBitDepth == 24) || (mBitDepth == 32), return kALAC_ParamError; );\n\n\t// reload coefs pointers for this channel pair\n\t// - note that, while you might think they should be re-initialized per block, retaining state across blocks\n\t//\t actually results in better overall compression\n\t// - strangely, re-using the same coefs for the different passes of the \"mixRes\" search loop instead of using\n\t//\t different coefs for the different passes of \"mixRes\" results in even better compression\n\tcoefsU = (SearchCoefs) mCoefsU[channelIndex];\n\tcoefsV = (SearchCoefs) mCoefsV[channelIndex];\n\n\t// matrix encoding adds an extra bit but 32-bit inputs cannot be matrixed b/c 33 is too many\n\t// so enable 16-bit \"shift off\" and encode in 17-bit mode\n\t// - in addition, 24-bit mode really improves with one byte shifted off\n\tif ( mBitDepth == 32 )\n\t\tbytesShifted = 2;\n\telse if ( mBitDepth >= 24 )\n\t\tbytesShifted = 1;\n\telse\n\t\tbytesShifted = 0;\n\n\tchanBits = mBitDepth - (bytesShifted * 8) + 1;\n\t\n\t// flag whether or not this is a partial frame\n\tpartialFrame = (numSamples == mFrameSize) ? 0 : 1;\n\n\t// set up default encoding parameters for \"fast\" mode\n\tmixBits\t\t= kDefaultMixBits;\n\tmixRes\t\t= kDefaultMixRes;\n\tnumU = numV = kDefaultNumUV;\n\tdenShift\t= DENSHIFT_DEFAULT;\n\tmode\t\t= 0;\n\tpbFactor\t= 4;\n\n\tminBits\t= minBits1 = minBits2 = 1ul << 31;\n\t\n\t// mix the stereo inputs with default mixBits/mixRes\n\tswitch ( mBitDepth )\n\t{\n\t\tcase 16:\n\t\t\tmix16( (int16_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, mixBits, mixRes );\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tmix20( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, mixBits, mixRes );\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\t// also extracts the shifted off bytes into the shift buffers\n\t\t\tmix24( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples,\n\t\t\t\t\tmixBits, mixRes, mShiftBufferUV, bytesShifted );\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\t// also extracts the shifted off bytes into the shift buffers\n\t\t\tmix32( (int32_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples,\n\t\t\t\t\tmixBits, mixRes, mShiftBufferUV, bytesShifted );\n\t\t\tbreak;\n\t}\n\n\t/* speculatively write the bitstream assuming the compressed version will be smaller */\n\n\t// write bitstream header and coefs\n\tBitBufferWrite( bitstream, 0, 12 );\n\tBitBufferWrite( bitstream, (partialFrame << 3) | (bytesShifted << 1), 4 );\n\tif ( partialFrame )\n\t\tBitBufferWrite( bitstream, numSamples, 32 );\n\tBitBufferWrite( bitstream, mixBits, 8 );\n\tBitBufferWrite( bitstream, mixRes, 8 );\n\t\n\t//Assert( (mode < 16) && (DENSHIFT_DEFAULT < 16) );\n\t//Assert( (pbFactor < 8) && (numU < 32) );\n\t//Assert( (pbFactor < 8) && (numV < 32) );\n\n\tBitBufferWrite( bitstream, (mode << 4) | DENSHIFT_DEFAULT, 8 );\n\tBitBufferWrite( bitstream, (pbFactor << 5) | numU, 8 );\n\tfor ( index = 0; index < numU; index++ )\n\t\tBitBufferWrite( bitstream, coefsU[numU - 1][index], 16 );\n\n\tBitBufferWrite( bitstream, (mode << 4) | DENSHIFT_DEFAULT, 8 );\n\tBitBufferWrite( bitstream, (pbFactor << 5) | numV, 8 );\n\tfor ( index = 0; index < numV; index++ )\n\t\tBitBufferWrite( bitstream, coefsV[numV - 1][index], 16 );\n\n\t// if shift active, write the interleaved shift buffers\n\tif ( bytesShifted != 0 )\n\t{\n\t\tuint32_t\t\tbitShift = bytesShifted * 8;\n\n\t\t//Assert( bitShift <= 16 );\n\n\t\tfor ( index = 0; index < (numSamples * 2); index += 2 )\n\t\t{\n\t\t\tuint32_t\t\t\tshiftedVal;\n\t\t\t\n\t\t\tshiftedVal = ((uint32_t)mShiftBufferUV[index + 0] << bitShift) | (uint32_t)mShiftBufferUV[index + 1];\n\t\t\tBitBufferWrite( bitstream, shiftedVal, bitShift * 2 );\n\t\t}\n\t}\n\n\t// run the dynamic predictor and lossless compression for the \"left\" channel\n\t// - note: we always use mode 0 in the \"fast\" path so we don't need the code for mode != 0\n\tpc_block( mMixBufferU, mPredictorU, numSamples, coefsU[numU - 1], numU, chanBits, DENSHIFT_DEFAULT );\n\n\tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT );\n\tstatus = dyn_comp( &agParams, mPredictorU, bitstream, numSamples, chanBits, &bits1 );\n\tRequireNoErr( status, goto Exit; );\n\n\t// run the dynamic predictor and lossless compression for the \"right\" channel\n\tpc_block( mMixBufferV, mPredictorV, numSamples, coefsV[numV - 1], numV, chanBits, DENSHIFT_DEFAULT );\n\n\tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT );\n\tstatus = dyn_comp( &agParams, mPredictorV, bitstream, numSamples, chanBits, &bits2 );\n\tRequireNoErr( status, goto Exit; );\n\n\t// do bit requirement calculations\n\tminBits1 = bits1 + (numU * sizeof(int16_t) * 8);\n\tminBits2 = bits2 + (numV * sizeof(int16_t) * 8);\n\n\t// test for escape hatch if best calculated compressed size turns out to be more than the input size\n\tminBits = minBits1 + minBits2 + (8 /* mixRes/maxRes/etc. */ * 8) + ((partialFrame == true) ? 32 : 0);\n\tif ( bytesShifted != 0 )\n\t\tminBits += (numSamples * (bytesShifted * 8) * 2);\n\n\tescapeBits = (numSamples * mBitDepth * 2) + ((partialFrame == true) ? 32 : 0) + (2 * 8);\t/* 2 common header bytes */\n\n\tdoEscape = (minBits >= escapeBits) ? true : false;\n\n\tif ( doEscape == false )\n\t{\n\t\t/*\tif we happened to create a compressed packet that was actually bigger than an escape packet would be,\n\t\t\tchuck it and do an escape packet\n\t\t*/\n\t\tminBits = BitBufferGetPosition( bitstream ) - BitBufferGetPosition( &startBits );\n\t\tif ( minBits >= escapeBits )\n\t\t{\n\t\t\tdoEscape = true;\n\t\t}\n\n\t}\n\n\tif ( doEscape == true )\n\t{\n\t\t/* escape */\n\n\t\t// reset bitstream position since we speculatively wrote the compressed version\n\t\t*bitstream = startBits;\n\n\t\t// write escape frame\n\t\tstatus = this->EncodeStereoEscape( bitstream, inputBuffer, stride, numSamples );\n\n#if VERBOSE_DEBUG\t\t\n\t\tDebugMsg( \"escape!: %u vs %u\", minBits, (numSamples * mBitDepth * 2) );\n#endif\n\t}\n\t\nExit:\n\treturn status;\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACAudioTypes.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"dplib.h\"",
      "#include \"aglib.h\"",
      "#include \"ALACEncoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define VERBOSE_DEBUG\t\t0"
    ],
    "globals_used": [
      "const uint32_t kDefaultMixBits\t= 2;",
      "const uint32_t kDefaultMixRes\t\t= 0;",
      "const uint32_t kDefaultNumUV\t\t= 8;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DebugMsg",
          "args": [
            "\"escape!: %u vs %u\"",
            "minBits",
            "(numSamples * mBitDepth * 2)"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->EncodeStereoEscape",
          "args": [
            "bitstream",
            "inputBuffer",
            "stride",
            "numSamples"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeStereoEscape",
          "container": "ALACEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
          "lines": "729-787",
          "snippet": "int32_t ALACEncoder::EncodeStereoEscape( BitBuffer * bitstream, void * inputBuffer, uint32_t stride, uint32_t numSamples )\n{\n\tint16_t *\t\tinput16;\n\tint32_t *\t\tinput32;\n\tuint8_t\t\t\tpartialFrame;\n\tuint32_t\t\t\tindex;\n\n\t// flag whether or not this is a partial frame\n\tpartialFrame = (numSamples == mFrameSize) ? 0 : 1;\n\n\t// write bitstream header\n\tBitBufferWrite( bitstream, 0, 12 );\n\tBitBufferWrite( bitstream, (partialFrame << 3) | 1, 4 );\t// LSB = 1 means \"frame not compressed\"\n\tif ( partialFrame )\n\t\tBitBufferWrite( bitstream, numSamples, 32 );\n\n\t// just copy the input data to the output buffer\n\tswitch ( mBitDepth )\n\t{\n\t\tcase 16:\n\t\t\tinput16 = (int16_t *) inputBuffer;\n\t\t\t\n\t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n\t\t\t{\n\t\t\t\tBitBufferWrite( bitstream, input16[index + 0], 16 );\n\t\t\t\tBitBufferWrite( bitstream, input16[index + 1], 16 );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\t// mix20() with mixres param = 0 means de-interleave so use it to simplify things\n\t\t\tmix20( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, 0, 0 );\n\t\t\tfor ( index = 0; index < numSamples; index++ )\n\t\t\t{\n\t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 20 );\n\t\t\t\tBitBufferWrite( bitstream, mMixBufferV[index], 20 );\n\t\t\t}\t\t\t\t\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\t// mix24() with mixres param = 0 means de-interleave so use it to simplify things\n\t\t\tmix24( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, 0, 0, mShiftBufferUV, 0 );\n\t\t\tfor ( index = 0; index < numSamples; index++ )\n\t\t\t{\n\t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 24 );\n\t\t\t\tBitBufferWrite( bitstream, mMixBufferV[index], 24 );\n\t\t\t}\t\t\t\t\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tinput32 = (int32_t *) inputBuffer;\n\n\t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n\t\t\t{\n\t\t\t\tBitBufferWrite( bitstream, input32[index + 0], 32 );\n\t\t\t\tBitBufferWrite( bitstream, input32[index + 1], 32 );\n\t\t\t}\t\t\t\t\n\t\t\tbreak;\n\t}\n\t\n\treturn ALAC_noErr;\n}",
          "includes": [
            "#include \"EndianPortable.h\"",
            "#include \"ALACAudioTypes.h\"",
            "#include \"ALACBitUtilities.h\"",
            "#include \"matrixlib.h\"",
            "#include \"dplib.h\"",
            "#include \"aglib.h\"",
            "#include \"ALACEncoder.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nALACEncoder {\n  int32_t ALACEncoder::EncodeStereoEscape( BitBuffer * bitstream, void * inputBuffer, uint32_t stride, uint32_t numSamples )\n  {\n  \tint16_t *\t\tinput16;\n  \tint32_t *\t\tinput32;\n  \tuint8_t\t\t\tpartialFrame;\n  \tuint32_t\t\t\tindex;\n  \n  \t// flag whether or not this is a partial frame\n  \tpartialFrame = (numSamples == mFrameSize) ? 0 : 1;\n  \n  \t// write bitstream header\n  \tBitBufferWrite( bitstream, 0, 12 );\n  \tBitBufferWrite( bitstream, (partialFrame << 3) | 1, 4 );\t// LSB = 1 means \"frame not compressed\"\n  \tif ( partialFrame )\n  \t\tBitBufferWrite( bitstream, numSamples, 32 );\n  \n  \t// just copy the input data to the output buffer\n  \tswitch ( mBitDepth )\n  \t{\n  \t\tcase 16:\n  \t\t\tinput16 = (int16_t *) inputBuffer;\n  \t\t\t\n  \t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n  \t\t\t{\n  \t\t\t\tBitBufferWrite( bitstream, input16[index + 0], 16 );\n  \t\t\t\tBitBufferWrite( bitstream, input16[index + 1], 16 );\n  \t\t\t}\n  \t\t\tbreak;\n  \t\tcase 20:\n  \t\t\t// mix20() with mixres param = 0 means de-interleave so use it to simplify things\n  \t\t\tmix20( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, 0, 0 );\n  \t\t\tfor ( index = 0; index < numSamples; index++ )\n  \t\t\t{\n  \t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 20 );\n  \t\t\t\tBitBufferWrite( bitstream, mMixBufferV[index], 20 );\n  \t\t\t}\t\t\t\t\n  \t\t\tbreak;\n  \t\tcase 24:\n  \t\t\t// mix24() with mixres param = 0 means de-interleave so use it to simplify things\n  \t\t\tmix24( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, 0, 0, mShiftBufferUV, 0 );\n  \t\t\tfor ( index = 0; index < numSamples; index++ )\n  \t\t\t{\n  \t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 24 );\n  \t\t\t\tBitBufferWrite( bitstream, mMixBufferV[index], 24 );\n  \t\t\t}\t\t\t\t\n  \t\t\tbreak;\n  \t\tcase 32:\n  \t\t\tinput32 = (int32_t *) inputBuffer;\n  \n  \t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n  \t\t\t{\n  \t\t\t\tBitBufferWrite( bitstream, input32[index + 0], 32 );\n  \t\t\t\tBitBufferWrite( bitstream, input32[index + 1], 32 );\n  \t\t\t}\t\t\t\t\n  \t\t\tbreak;\n  \t}\n  \t\n  \treturn ALAC_noErr;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BitBufferGetPosition",
          "args": [
            "&startBits"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferGetPosition",
          "args": [
            "bitstream"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dyn_comp",
          "args": [
            "&agParams",
            "mPredictorV",
            "bitstream",
            "numSamples",
            "chanBits",
            "&bits2"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ag_params",
          "args": [
            "&agParams",
            "MB0",
            "(pbFactor * PB0) / 4",
            "KB0",
            "numSamples",
            "numSamples",
            "MAX_RUN_DEFAULT"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc_block",
          "args": [
            "mMixBufferV",
            "mPredictorV",
            "numSamples",
            "coefsV[numV - 1]",
            "numV",
            "chanBits",
            "DENSHIFT_DEFAULT"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dyn_comp",
          "args": [
            "&agParams",
            "mPredictorU",
            "bitstream",
            "numSamples",
            "chanBits",
            "&bits1"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ag_params",
          "args": [
            "&agParams",
            "MB0",
            "(pbFactor * PB0) / 4",
            "KB0",
            "numSamples",
            "numSamples",
            "MAX_RUN_DEFAULT"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc_block",
          "args": [
            "mMixBufferU",
            "mPredictorU",
            "numSamples",
            "coefsU[numU - 1]",
            "numU",
            "chanBits",
            "DENSHIFT_DEFAULT"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "shiftedVal",
            "bitShift * 2"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "coefsV[numV - 1][index]",
            "16"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "(pbFactor << 5) | numV",
            "8"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "(mode << 4) | DENSHIFT_DEFAULT",
            "8"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "coefsU[numU - 1][index]",
            "16"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "(pbFactor << 5) | numU",
            "8"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "(mode << 4) | DENSHIFT_DEFAULT",
            "8"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "mixRes",
            "8"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "mixBits",
            "8"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "numSamples",
            "32"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "(partialFrame << 3) | (bytesShifted << 1)",
            "4"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "0",
            "12"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mix32",
          "args": [
            "(int32_t *) inputBuffer",
            "stride",
            "mMixBufferU",
            "mMixBufferV",
            "numSamples",
            "mixBits",
            "mixRes",
            "mShiftBufferUV",
            "bytesShifted"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mix24",
          "args": [
            "(uint8_t *) inputBuffer",
            "stride",
            "mMixBufferU",
            "mMixBufferV",
            "numSamples",
            "mixBits",
            "mixRes",
            "mShiftBufferUV",
            "bytesShifted"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mix20",
          "args": [
            "(uint8_t *) inputBuffer",
            "stride",
            "mMixBufferU",
            "mMixBufferV",
            "numSamples",
            "mixBits",
            "mixRes"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mix16",
          "args": [
            "(int16_t *) inputBuffer",
            "stride",
            "mMixBufferU",
            "mMixBufferV",
            "numSamples",
            "mixBits",
            "mixRes"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RequireAction",
          "args": [
            "(mBitDepth == 16) || (mBitDepth == 20) || (mBitDepth == 24) || (mBitDepth == 32)",
            "returnkALAC_ParamError;"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define VERBOSE_DEBUG\t\t0\n\nconst uint32_t kDefaultMixBits\t= 2;\nconst uint32_t kDefaultMixRes\t\t= 0;\nconst uint32_t kDefaultNumUV\t\t= 8;\n\nALACEncoder {\n  int32_t ALACEncoder::EncodeStereoFast( BitBuffer * bitstream, void * inputBuffer, uint32_t stride, uint32_t channelIndex, uint32_t numSamples )\n  {\n  \tBitBuffer\t\tstartBits = *bitstream;\t\t\t// squirrel away current bit position in case we decide to use escape hatch\n  \tAGParamRec\t\tagParams;\n  \tuint32_t\tbits1, bits2;\n  \tint32_t\t\t\tmixBits, mixRes;\n  \tuint32_t\t\t\tminBits, minBits1, minBits2;\n  \tuint32_t\t\t\tnumU, numV;\n  \tuint32_t\t\t\tmode;\n  \tuint32_t\t\t\tpbFactor;\n  \tuint32_t\t\t\tchanBits;\n  \tuint32_t\t\t\tdenShift;\n  \tuint8_t\t\t\tbytesShifted;\n  \tSearchCoefs\t\tcoefsU;\n  \tSearchCoefs\t\tcoefsV;\n  \tuint32_t\t\t\tindex;\n  \tuint8_t\t\t\tpartialFrame;\n  \tuint32_t\t\t\tescapeBits;\n  \tbool\t\t\tdoEscape;\t\n  \tint32_t\t\tstatus;\n  \n  \t// make sure we handle this bit-depth before we get going\n  \tRequireAction( (mBitDepth == 16) || (mBitDepth == 20) || (mBitDepth == 24) || (mBitDepth == 32), return kALAC_ParamError; );\n  \n  \t// reload coefs pointers for this channel pair\n  \t// - note that, while you might think they should be re-initialized per block, retaining state across blocks\n  \t//\t actually results in better overall compression\n  \t// - strangely, re-using the same coefs for the different passes of the \"mixRes\" search loop instead of using\n  \t//\t different coefs for the different passes of \"mixRes\" results in even better compression\n  \tcoefsU = (SearchCoefs) mCoefsU[channelIndex];\n  \tcoefsV = (SearchCoefs) mCoefsV[channelIndex];\n  \n  \t// matrix encoding adds an extra bit but 32-bit inputs cannot be matrixed b/c 33 is too many\n  \t// so enable 16-bit \"shift off\" and encode in 17-bit mode\n  \t// - in addition, 24-bit mode really improves with one byte shifted off\n  \tif ( mBitDepth == 32 )\n  \t\tbytesShifted = 2;\n  \telse if ( mBitDepth >= 24 )\n  \t\tbytesShifted = 1;\n  \telse\n  \t\tbytesShifted = 0;\n  \n  \tchanBits = mBitDepth - (bytesShifted * 8) + 1;\n  \t\n  \t// flag whether or not this is a partial frame\n  \tpartialFrame = (numSamples == mFrameSize) ? 0 : 1;\n  \n  \t// set up default encoding parameters for \"fast\" mode\n  \tmixBits\t\t= kDefaultMixBits;\n  \tmixRes\t\t= kDefaultMixRes;\n  \tnumU = numV = kDefaultNumUV;\n  \tdenShift\t= DENSHIFT_DEFAULT;\n  \tmode\t\t= 0;\n  \tpbFactor\t= 4;\n  \n  \tminBits\t= minBits1 = minBits2 = 1ul << 31;\n  \t\n  \t// mix the stereo inputs with default mixBits/mixRes\n  \tswitch ( mBitDepth )\n  \t{\n  \t\tcase 16:\n  \t\t\tmix16( (int16_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, mixBits, mixRes );\n  \t\t\tbreak;\n  \t\tcase 20:\n  \t\t\tmix20( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, mixBits, mixRes );\n  \t\t\tbreak;\n  \t\tcase 24:\n  \t\t\t// also extracts the shifted off bytes into the shift buffers\n  \t\t\tmix24( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples,\n  \t\t\t\t\tmixBits, mixRes, mShiftBufferUV, bytesShifted );\n  \t\t\tbreak;\n  \t\tcase 32:\n  \t\t\t// also extracts the shifted off bytes into the shift buffers\n  \t\t\tmix32( (int32_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples,\n  \t\t\t\t\tmixBits, mixRes, mShiftBufferUV, bytesShifted );\n  \t\t\tbreak;\n  \t}\n  \n  \t/* speculatively write the bitstream assuming the compressed version will be smaller */\n  \n  \t// write bitstream header and coefs\n  \tBitBufferWrite( bitstream, 0, 12 );\n  \tBitBufferWrite( bitstream, (partialFrame << 3) | (bytesShifted << 1), 4 );\n  \tif ( partialFrame )\n  \t\tBitBufferWrite( bitstream, numSamples, 32 );\n  \tBitBufferWrite( bitstream, mixBits, 8 );\n  \tBitBufferWrite( bitstream, mixRes, 8 );\n  \t\n  \t//Assert( (mode < 16) && (DENSHIFT_DEFAULT < 16) );\n  \t//Assert( (pbFactor < 8) && (numU < 32) );\n  \t//Assert( (pbFactor < 8) && (numV < 32) );\n  \n  \tBitBufferWrite( bitstream, (mode << 4) | DENSHIFT_DEFAULT, 8 );\n  \tBitBufferWrite( bitstream, (pbFactor << 5) | numU, 8 );\n  \tfor ( index = 0; index < numU; index++ )\n  \t\tBitBufferWrite( bitstream, coefsU[numU - 1][index], 16 );\n  \n  \tBitBufferWrite( bitstream, (mode << 4) | DENSHIFT_DEFAULT, 8 );\n  \tBitBufferWrite( bitstream, (pbFactor << 5) | numV, 8 );\n  \tfor ( index = 0; index < numV; index++ )\n  \t\tBitBufferWrite( bitstream, coefsV[numV - 1][index], 16 );\n  \n  \t// if shift active, write the interleaved shift buffers\n  \tif ( bytesShifted != 0 )\n  \t{\n  \t\tuint32_t\t\tbitShift = bytesShifted * 8;\n  \n  \t\t//Assert( bitShift <= 16 );\n  \n  \t\tfor ( index = 0; index < (numSamples * 2); index += 2 )\n  \t\t{\n  \t\t\tuint32_t\t\t\tshiftedVal;\n  \t\t\t\n  \t\t\tshiftedVal = ((uint32_t)mShiftBufferUV[index + 0] << bitShift) | (uint32_t)mShiftBufferUV[index + 1];\n  \t\t\tBitBufferWrite( bitstream, shiftedVal, bitShift * 2 );\n  \t\t}\n  \t}\n  \n  \t// run the dynamic predictor and lossless compression for the \"left\" channel\n  \t// - note: we always use mode 0 in the \"fast\" path so we don't need the code for mode != 0\n  \tpc_block( mMixBufferU, mPredictorU, numSamples, coefsU[numU - 1], numU, chanBits, DENSHIFT_DEFAULT );\n  \n  \tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT );\n  \tstatus = dyn_comp( &agParams, mPredictorU, bitstream, numSamples, chanBits, &bits1 );\n  \tRequireNoErr( status, goto Exit; );\n  \n  \t// run the dynamic predictor and lossless compression for the \"right\" channel\n  \tpc_block( mMixBufferV, mPredictorV, numSamples, coefsV[numV - 1], numV, chanBits, DENSHIFT_DEFAULT );\n  \n  \tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT );\n  \tstatus = dyn_comp( &agParams, mPredictorV, bitstream, numSamples, chanBits, &bits2 );\n  \tRequireNoErr( status, goto Exit; );\n  \n  \t// do bit requirement calculations\n  \tminBits1 = bits1 + (numU * sizeof(int16_t) * 8);\n  \tminBits2 = bits2 + (numV * sizeof(int16_t) * 8);\n  \n  \t// test for escape hatch if best calculated compressed size turns out to be more than the input size\n  \tminBits = minBits1 + minBits2 + (8 /* mixRes/maxRes/etc. */ * 8) + ((partialFrame == true) ? 32 : 0);\n  \tif ( bytesShifted != 0 )\n  \t\tminBits += (numSamples * (bytesShifted * 8) * 2);\n  \n  \tescapeBits = (numSamples * mBitDepth * 2) + ((partialFrame == true) ? 32 : 0) + (2 * 8);\t/* 2 common header bytes */\n  \n  \tdoEscape = (minBits >= escapeBits) ? true : false;\n  \n  \tif ( doEscape == false )\n  \t{\n  \t\t/*\tif we happened to create a compressed packet that was actually bigger than an escape packet would be,\n  \t\t\tchuck it and do an escape packet\n  \t\t*/\n  \t\tminBits = BitBufferGetPosition( bitstream ) - BitBufferGetPosition( &startBits );\n  \t\tif ( minBits >= escapeBits )\n  \t\t{\n  \t\t\tdoEscape = true;\n  \t\t}\n  \n  \t}\n  \n  \tif ( doEscape == true )\n  \t{\n  \t\t/* escape */\n  \n  \t\t// reset bitstream position since we speculatively wrote the compressed version\n  \t\t*bitstream = startBits;\n  \n  \t\t// write escape frame\n  \t\tstatus = this->EncodeStereoEscape( bitstream, inputBuffer, stride, numSamples );\n  \n  #if VERBOSE_DEBUG\t\t\n  \t\tDebugMsg( \"escape!: %u vs %u\", minBits, (numSamples * mBitDepth * 2) );\n  #endif\n  \t}\n  \t\n  Exit:\n  \treturn status;\n  }\n}"
  },
  {
    "function_name": "EncodeStereo",
    "container": "ALACEncoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
    "lines": "266-541",
    "snippet": "int32_t ALACEncoder::EncodeStereo( BitBuffer * bitstream, void * inputBuffer, uint32_t stride, uint32_t channelIndex, uint32_t numSamples )\n{\n\tBitBuffer\t\tworkBits;\n\tBitBuffer\t\tstartBits = *bitstream;\t\t\t// squirrel away copy of current state in case we need to go back and do an escape packet\n\tAGParamRec\t\tagParams;\n\tuint32_t          bits1, bits2;\n\tuint32_t\t\t\tdilate;\n\tint32_t\t\t\tmixBits, mixRes, maxRes;\n\tuint32_t\t\t\tminBits, minBits1, minBits2;\n\tuint32_t\t\t\tnumU, numV;\n\tuint32_t\t\t\tmode;\n\tuint32_t\t\t\tpbFactor;\n\tuint32_t\t\t\tchanBits;\n\tuint32_t\t\t\tdenShift;\n\tuint8_t\t\t\tbytesShifted;\n\tSearchCoefs\t\tcoefsU;\n\tSearchCoefs\t\tcoefsV;\n\tuint32_t\t\t\tindex;\n\tuint8_t\t\t\tpartialFrame;\n\tuint32_t\t\t\tescapeBits;\n\tbool\t\t\tdoEscape;\n\tint32_t\t\tstatus = ALAC_noErr;\n\n\t// make sure we handle this bit-depth before we get going\n\tRequireAction( (mBitDepth == 16) || (mBitDepth == 20) || (mBitDepth == 24) || (mBitDepth == 32), return kALAC_ParamError; );\n\n\t// reload coefs pointers for this channel pair\n\t// - note that, while you might think they should be re-initialized per block, retaining state across blocks\n\t//\t actually results in better overall compression\n\t// - strangely, re-using the same coefs for the different passes of the \"mixRes\" search loop instead of using\n\t//\t different coefs for the different passes of \"mixRes\" results in even better compression\n\tcoefsU = (SearchCoefs) mCoefsU[channelIndex];\n\tcoefsV = (SearchCoefs) mCoefsV[channelIndex];\n\n\t// matrix encoding adds an extra bit but 32-bit inputs cannot be matrixed b/c 33 is too many\n\t// so enable 16-bit \"shift off\" and encode in 17-bit mode\n\t// - in addition, 24-bit mode really improves with one byte shifted off\n\tif ( mBitDepth == 32 )\n\t\tbytesShifted = 2;\n\telse if ( mBitDepth >= 24 )\n\t\tbytesShifted = 1;\n\telse\n\t\tbytesShifted = 0;\n\n\tchanBits = mBitDepth - (bytesShifted * 8) + 1;\n\t\n\t// flag whether or not this is a partial frame\n\tpartialFrame = (numSamples == mFrameSize) ? 0 : 1;\n\n\t// brute-force encode optimization loop\n\t// - run over variations of the encoding params to find the best choice\n\tmixBits\t\t= kDefaultMixBits;\n\tmaxRes\t\t= kMaxRes;\n\tnumU = numV = kDefaultNumUV;\n\tdenShift\t= DENSHIFT_DEFAULT;\n\tmode\t\t= 0;\n\tpbFactor\t= 4;\n\tdilate\t\t= 8;\n\n\tminBits\t= minBits1 = minBits2 = 1ul << 31;\n\t\n    int32_t\t\tbestRes = mLastMixRes[channelIndex];\n\n    for ( mixRes = 0; mixRes <= maxRes; mixRes++ )\n    {\n        // mix the stereo inputs\n        switch ( mBitDepth )\n        {\n            case 16:\n                mix16( (int16_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples/dilate, mixBits, mixRes );\n                break;\n            case 20:\n                mix20( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples/dilate, mixBits, mixRes );\n                break;\n            case 24:\n                // includes extraction of shifted-off bytes\n                mix24( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples/dilate,\n                        mixBits, mixRes, mShiftBufferUV, bytesShifted );\n                break;\n            case 32:\n                // includes extraction of shifted-off bytes\n                mix32( (int32_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples/dilate,\n                        mixBits, mixRes, mShiftBufferUV, bytesShifted );\n                break;\n        }\n\n        BitBufferInit( &workBits, mWorkBuffer, mMaxOutputBytes );\n        \n        // run the dynamic predictors\n        pc_block( mMixBufferU, mPredictorU, numSamples/dilate, coefsU[numU - 1], numU, chanBits, DENSHIFT_DEFAULT );\n        pc_block( mMixBufferV, mPredictorV, numSamples/dilate, coefsV[numV - 1], numV, chanBits, DENSHIFT_DEFAULT );\n\n        // run the lossless compressor on each channel\n        set_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n        status = dyn_comp( &agParams, mPredictorU, &workBits, numSamples/dilate, chanBits, &bits1 );\n        RequireNoErr( status, goto Exit; );\n\n        set_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n        status = dyn_comp( &agParams, mPredictorV, &workBits, numSamples/dilate, chanBits, &bits2 );\n        RequireNoErr( status, goto Exit; );\n\n        // look for best match\n        if ( (bits1 + bits2) < minBits1 )\n        {\n            minBits1 = bits1 + bits2;\n            bestRes = mixRes;\n        }\n    }\n    \n    mLastMixRes[channelIndex] = (int16_t)bestRes;\n\n\t// mix the stereo inputs with the current best mixRes\n\tmixRes = mLastMixRes[channelIndex];\n\tswitch ( mBitDepth )\n\t{\n\t\tcase 16:\n\t\t\tmix16( (int16_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, mixBits, mixRes );\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tmix20( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, mixBits, mixRes );\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\t// also extracts the shifted off bytes into the shift buffers\n\t\t\tmix24( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples,\n\t\t\t\t\tmixBits, mixRes, mShiftBufferUV, bytesShifted );\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\t// also extracts the shifted off bytes into the shift buffers\n\t\t\tmix32( (int32_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples,\n\t\t\t\t\tmixBits, mixRes, mShiftBufferUV, bytesShifted );\n\t\t\tbreak;\n\t}\n\n\t// now it's time for the predictor coefficient search loop\n\tnumU = numV = kMinUV;\n\tminBits1 = minBits2 = 1ul << 31;\n\n\tfor ( uint32_t numUV = kMinUV; numUV <= kMaxUV; numUV += 4 )\n\t{\n\t\tBitBufferInit( &workBits, mWorkBuffer, mMaxOutputBytes );\t\t\n\n\t\tdilate = 32;\n\n\t\t// run the predictor over the same data multiple times to help it converge\n\t\tfor ( uint32_t converge = 0; converge < 8; converge++ )\n\t\t{\n\t\t    pc_block( mMixBufferU, mPredictorU, numSamples/dilate, coefsU[numUV-1], numUV, chanBits, DENSHIFT_DEFAULT );\n\t\t    pc_block( mMixBufferV, mPredictorV, numSamples/dilate, coefsV[numUV-1], numUV, chanBits, DENSHIFT_DEFAULT );\n\t\t}\n\n\t\tdilate = 8;\n\n\t\tset_ag_params( &agParams, MB0, (pbFactor * PB0)/4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n\t\tstatus = dyn_comp( &agParams, mPredictorU, &workBits, numSamples/dilate, chanBits, &bits1 );\n\n\t\tif ( (bits1 * dilate + 16 * numUV) < minBits1 )\n\t\t{\n\t\t\tminBits1 = bits1 * dilate + 16 * numUV;\n\t\t\tnumU = numUV;\n\t\t}\n\n\t\tset_ag_params( &agParams, MB0, (pbFactor * PB0)/4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n\t\tstatus = dyn_comp( &agParams, mPredictorV, &workBits, numSamples/dilate, chanBits, &bits2 );\n\n\t\tif ( (bits2 * dilate + 16 * numUV) < minBits2 )\n\t\t{\n\t\t\tminBits2 = bits2 * dilate + 16 * numUV;\n\t\t\tnumV = numUV;\n\t\t}\n\t}\n\n\t// test for escape hatch if best calculated compressed size turns out to be more than the input size\n\tminBits = minBits1 + minBits2 + (8 /* mixRes/maxRes/etc. */ * 8) + ((partialFrame == true) ? 32 : 0);\n\tif ( bytesShifted != 0 )\n\t\tminBits += (numSamples * (bytesShifted * 8) * 2);\n\n\tescapeBits = (numSamples * mBitDepth * 2) + ((partialFrame == true) ? 32 : 0) + (2 * 8);\t/* 2 common header bytes */\n\n\tdoEscape = (minBits >= escapeBits) ? true : false;\n\n\tif ( doEscape == false )\n\t{\n\t\t// write bitstream header and coefs\n\t\tBitBufferWrite( bitstream, 0, 12 );\n\t\tBitBufferWrite( bitstream, (partialFrame << 3) | (bytesShifted << 1), 4 );\n\t\tif ( partialFrame )\n\t\t\tBitBufferWrite( bitstream, numSamples, 32 );\n\t\tBitBufferWrite( bitstream, mixBits, 8 );\n\t\tBitBufferWrite( bitstream, mixRes, 8 );\n\t\t\n\t\t//Assert( (mode < 16) && (DENSHIFT_DEFAULT < 16) );\n\t\t//Assert( (pbFactor < 8) && (numU < 32) );\n\t\t//Assert( (pbFactor < 8) && (numV < 32) );\n\n\t\tBitBufferWrite( bitstream, (mode << 4) | DENSHIFT_DEFAULT, 8 );\n\t\tBitBufferWrite( bitstream, (pbFactor << 5) | numU, 8 );\n\t\tfor ( index = 0; index < numU; index++ )\n\t\t\tBitBufferWrite( bitstream, coefsU[numU - 1][index], 16 );\n\n\t\tBitBufferWrite( bitstream, (mode << 4) | DENSHIFT_DEFAULT, 8 );\n\t\tBitBufferWrite( bitstream, (pbFactor << 5) | numV, 8 );\n\t\tfor ( index = 0; index < numV; index++ )\n\t\t\tBitBufferWrite( bitstream, coefsV[numV - 1][index], 16 );\n\n\t\t// if shift active, write the interleaved shift buffers\n\t\tif ( bytesShifted != 0 )\n\t\t{\n\t\t\tuint32_t\t\tbitShift = bytesShifted * 8;\n\n\t\t\t//Assert( bitShift <= 16 );\n\n\t\t\tfor ( index = 0; index < (numSamples * 2); index += 2 )\n\t\t\t{\n\t\t\t\tuint32_t\t\t\tshiftedVal;\n\t\t\t\t\n\t\t\t\tshiftedVal = ((uint32_t)mShiftBufferUV[index + 0] << bitShift) | (uint32_t)mShiftBufferUV[index + 1];\n\t\t\t\tBitBufferWrite( bitstream, shiftedVal, bitShift * 2 );\n\t\t\t}\n\t\t}\n\n\t\t// run the dynamic predictor and lossless compression for the \"left\" channel\n\t\t// - note: to avoid allocating more buffers, we're mixing and matching between the available buffers instead\n\t\t//\t\t   of only using \"U\" buffers for the U-channel and \"V\" buffers for the V-channel\n\t\tif ( mode == 0 )\n\t\t{\n\t\t\tpc_block( mMixBufferU, mPredictorU, numSamples, coefsU[numU - 1], numU, chanBits, DENSHIFT_DEFAULT );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpc_block( mMixBufferU, mPredictorV, numSamples, coefsU[numU - 1], numU, chanBits, DENSHIFT_DEFAULT );\n\t\t\tpc_block( mPredictorV, mPredictorU, numSamples, nil, 31, chanBits, 0 );\n\t\t}\n\n\t\tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT );\n\t\tstatus = dyn_comp( &agParams, mPredictorU, bitstream, numSamples, chanBits, &bits1 );\n\t\tRequireNoErr( status, goto Exit; );\n\n\t\t// run the dynamic predictor and lossless compression for the \"right\" channel\n\t\tif ( mode == 0 )\n\t\t{\n\t\t\tpc_block( mMixBufferV, mPredictorV, numSamples, coefsV[numV - 1], numV, chanBits, DENSHIFT_DEFAULT );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpc_block( mMixBufferV, mPredictorU, numSamples, coefsV[numV - 1], numV, chanBits, DENSHIFT_DEFAULT );\n\t\t\tpc_block( mPredictorU, mPredictorV, numSamples, nil, 31, chanBits, 0 );\n\t\t}\n\n\t\tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT );\n\t\tstatus = dyn_comp( &agParams, mPredictorV, bitstream, numSamples, chanBits, &bits2 );\n\t\tRequireNoErr( status, goto Exit; );\n\n\t\t/*\tif we happened to create a compressed packet that was actually bigger than an escape packet would be,\n\t\t\tchuck it and do an escape packet\n\t\t*/\n\t\tminBits = BitBufferGetPosition( bitstream ) - BitBufferGetPosition( &startBits );\n\t\tif ( minBits >= escapeBits )\n\t\t{\n\t\t\t*bitstream = startBits;\t\t// reset bitstream state\n\t\t\tdoEscape = true;\n\t\t}\n\t}\n\n\tif ( doEscape == true )\n\t{\n\t\t/* escape */\n\t\tstatus = this->EncodeStereoEscape( bitstream, inputBuffer, stride, numSamples );\n\n#if VERBOSE_DEBUG\t\t\n\t\tDebugMsg( \"escape!: %lu vs %lu\", minBits, escapeBits );\n#endif\n\t}\n\t\nExit:\n\treturn status;\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACAudioTypes.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"dplib.h\"",
      "#include \"aglib.h\"",
      "#include \"ALACEncoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define VERBOSE_DEBUG\t\t0"
    ],
    "globals_used": [
      "const uint32_t kDefaultMixBits\t= 2;",
      "const uint32_t kMaxRes\t\t\t= 4;",
      "const uint32_t kDefaultNumUV\t\t= 8;",
      "const uint32_t kMinUV\t\t\t\t= 4;",
      "const uint32_t kMaxUV\t\t\t\t= 8;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DebugMsg",
          "args": [
            "\"escape!: %lu vs %lu\"",
            "minBits",
            "escapeBits"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->EncodeStereoEscape",
          "args": [
            "bitstream",
            "inputBuffer",
            "stride",
            "numSamples"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeStereoEscape",
          "container": "ALACEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
          "lines": "729-787",
          "snippet": "int32_t ALACEncoder::EncodeStereoEscape( BitBuffer * bitstream, void * inputBuffer, uint32_t stride, uint32_t numSamples )\n{\n\tint16_t *\t\tinput16;\n\tint32_t *\t\tinput32;\n\tuint8_t\t\t\tpartialFrame;\n\tuint32_t\t\t\tindex;\n\n\t// flag whether or not this is a partial frame\n\tpartialFrame = (numSamples == mFrameSize) ? 0 : 1;\n\n\t// write bitstream header\n\tBitBufferWrite( bitstream, 0, 12 );\n\tBitBufferWrite( bitstream, (partialFrame << 3) | 1, 4 );\t// LSB = 1 means \"frame not compressed\"\n\tif ( partialFrame )\n\t\tBitBufferWrite( bitstream, numSamples, 32 );\n\n\t// just copy the input data to the output buffer\n\tswitch ( mBitDepth )\n\t{\n\t\tcase 16:\n\t\t\tinput16 = (int16_t *) inputBuffer;\n\t\t\t\n\t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n\t\t\t{\n\t\t\t\tBitBufferWrite( bitstream, input16[index + 0], 16 );\n\t\t\t\tBitBufferWrite( bitstream, input16[index + 1], 16 );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\t// mix20() with mixres param = 0 means de-interleave so use it to simplify things\n\t\t\tmix20( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, 0, 0 );\n\t\t\tfor ( index = 0; index < numSamples; index++ )\n\t\t\t{\n\t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 20 );\n\t\t\t\tBitBufferWrite( bitstream, mMixBufferV[index], 20 );\n\t\t\t}\t\t\t\t\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\t// mix24() with mixres param = 0 means de-interleave so use it to simplify things\n\t\t\tmix24( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, 0, 0, mShiftBufferUV, 0 );\n\t\t\tfor ( index = 0; index < numSamples; index++ )\n\t\t\t{\n\t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 24 );\n\t\t\t\tBitBufferWrite( bitstream, mMixBufferV[index], 24 );\n\t\t\t}\t\t\t\t\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tinput32 = (int32_t *) inputBuffer;\n\n\t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n\t\t\t{\n\t\t\t\tBitBufferWrite( bitstream, input32[index + 0], 32 );\n\t\t\t\tBitBufferWrite( bitstream, input32[index + 1], 32 );\n\t\t\t}\t\t\t\t\n\t\t\tbreak;\n\t}\n\t\n\treturn ALAC_noErr;\n}",
          "includes": [
            "#include \"EndianPortable.h\"",
            "#include \"ALACAudioTypes.h\"",
            "#include \"ALACBitUtilities.h\"",
            "#include \"matrixlib.h\"",
            "#include \"dplib.h\"",
            "#include \"aglib.h\"",
            "#include \"ALACEncoder.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nALACEncoder {\n  int32_t ALACEncoder::EncodeStereoEscape( BitBuffer * bitstream, void * inputBuffer, uint32_t stride, uint32_t numSamples )\n  {\n  \tint16_t *\t\tinput16;\n  \tint32_t *\t\tinput32;\n  \tuint8_t\t\t\tpartialFrame;\n  \tuint32_t\t\t\tindex;\n  \n  \t// flag whether or not this is a partial frame\n  \tpartialFrame = (numSamples == mFrameSize) ? 0 : 1;\n  \n  \t// write bitstream header\n  \tBitBufferWrite( bitstream, 0, 12 );\n  \tBitBufferWrite( bitstream, (partialFrame << 3) | 1, 4 );\t// LSB = 1 means \"frame not compressed\"\n  \tif ( partialFrame )\n  \t\tBitBufferWrite( bitstream, numSamples, 32 );\n  \n  \t// just copy the input data to the output buffer\n  \tswitch ( mBitDepth )\n  \t{\n  \t\tcase 16:\n  \t\t\tinput16 = (int16_t *) inputBuffer;\n  \t\t\t\n  \t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n  \t\t\t{\n  \t\t\t\tBitBufferWrite( bitstream, input16[index + 0], 16 );\n  \t\t\t\tBitBufferWrite( bitstream, input16[index + 1], 16 );\n  \t\t\t}\n  \t\t\tbreak;\n  \t\tcase 20:\n  \t\t\t// mix20() with mixres param = 0 means de-interleave so use it to simplify things\n  \t\t\tmix20( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, 0, 0 );\n  \t\t\tfor ( index = 0; index < numSamples; index++ )\n  \t\t\t{\n  \t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 20 );\n  \t\t\t\tBitBufferWrite( bitstream, mMixBufferV[index], 20 );\n  \t\t\t}\t\t\t\t\n  \t\t\tbreak;\n  \t\tcase 24:\n  \t\t\t// mix24() with mixres param = 0 means de-interleave so use it to simplify things\n  \t\t\tmix24( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, 0, 0, mShiftBufferUV, 0 );\n  \t\t\tfor ( index = 0; index < numSamples; index++ )\n  \t\t\t{\n  \t\t\t\tBitBufferWrite( bitstream, mMixBufferU[index], 24 );\n  \t\t\t\tBitBufferWrite( bitstream, mMixBufferV[index], 24 );\n  \t\t\t}\t\t\t\t\n  \t\t\tbreak;\n  \t\tcase 32:\n  \t\t\tinput32 = (int32_t *) inputBuffer;\n  \n  \t\t\tfor ( index = 0; index < (numSamples * stride); index += stride )\n  \t\t\t{\n  \t\t\t\tBitBufferWrite( bitstream, input32[index + 0], 32 );\n  \t\t\t\tBitBufferWrite( bitstream, input32[index + 1], 32 );\n  \t\t\t}\t\t\t\t\n  \t\t\tbreak;\n  \t}\n  \t\n  \treturn ALAC_noErr;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BitBufferGetPosition",
          "args": [
            "&startBits"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferGetPosition",
          "args": [
            "bitstream"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dyn_comp",
          "args": [
            "&agParams",
            "mPredictorV",
            "bitstream",
            "numSamples",
            "chanBits",
            "&bits2"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ag_params",
          "args": [
            "&agParams",
            "MB0",
            "(pbFactor * PB0) / 4",
            "KB0",
            "numSamples",
            "numSamples",
            "MAX_RUN_DEFAULT"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc_block",
          "args": [
            "mPredictorU",
            "mPredictorV",
            "numSamples",
            "nil",
            "31",
            "chanBits",
            "0"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc_block",
          "args": [
            "mMixBufferV",
            "mPredictorU",
            "numSamples",
            "coefsV[numV - 1]",
            "numV",
            "chanBits",
            "DENSHIFT_DEFAULT"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc_block",
          "args": [
            "mMixBufferV",
            "mPredictorV",
            "numSamples",
            "coefsV[numV - 1]",
            "numV",
            "chanBits",
            "DENSHIFT_DEFAULT"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dyn_comp",
          "args": [
            "&agParams",
            "mPredictorU",
            "bitstream",
            "numSamples",
            "chanBits",
            "&bits1"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ag_params",
          "args": [
            "&agParams",
            "MB0",
            "(pbFactor * PB0) / 4",
            "KB0",
            "numSamples",
            "numSamples",
            "MAX_RUN_DEFAULT"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc_block",
          "args": [
            "mPredictorV",
            "mPredictorU",
            "numSamples",
            "nil",
            "31",
            "chanBits",
            "0"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc_block",
          "args": [
            "mMixBufferU",
            "mPredictorV",
            "numSamples",
            "coefsU[numU - 1]",
            "numU",
            "chanBits",
            "DENSHIFT_DEFAULT"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc_block",
          "args": [
            "mMixBufferU",
            "mPredictorU",
            "numSamples",
            "coefsU[numU - 1]",
            "numU",
            "chanBits",
            "DENSHIFT_DEFAULT"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "shiftedVal",
            "bitShift * 2"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "coefsV[numV - 1][index]",
            "16"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "(pbFactor << 5) | numV",
            "8"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "(mode << 4) | DENSHIFT_DEFAULT",
            "8"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "coefsU[numU - 1][index]",
            "16"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "(pbFactor << 5) | numU",
            "8"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "(mode << 4) | DENSHIFT_DEFAULT",
            "8"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "mixRes",
            "8"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "mixBits",
            "8"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "numSamples",
            "32"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "(partialFrame << 3) | (bytesShifted << 1)",
            "4"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferWrite",
          "args": [
            "bitstream",
            "0",
            "12"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dyn_comp",
          "args": [
            "&agParams",
            "mPredictorV",
            "&workBits",
            "numSamples/dilate",
            "chanBits",
            "&bits2"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ag_params",
          "args": [
            "&agParams",
            "MB0",
            "(pbFactor * PB0)/4",
            "KB0",
            "numSamples/dilate",
            "numSamples/dilate",
            "MAX_RUN_DEFAULT"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dyn_comp",
          "args": [
            "&agParams",
            "mPredictorU",
            "&workBits",
            "numSamples/dilate",
            "chanBits",
            "&bits1"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ag_params",
          "args": [
            "&agParams",
            "MB0",
            "(pbFactor * PB0)/4",
            "KB0",
            "numSamples/dilate",
            "numSamples/dilate",
            "MAX_RUN_DEFAULT"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc_block",
          "args": [
            "mMixBufferV",
            "mPredictorV",
            "numSamples/dilate",
            "coefsV[numUV-1]",
            "numUV",
            "chanBits",
            "DENSHIFT_DEFAULT"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc_block",
          "args": [
            "mMixBufferU",
            "mPredictorU",
            "numSamples/dilate",
            "coefsU[numUV-1]",
            "numUV",
            "chanBits",
            "DENSHIFT_DEFAULT"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferInit",
          "args": [
            "&workBits",
            "mWorkBuffer",
            "mMaxOutputBytes"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mix32",
          "args": [
            "(int32_t *) inputBuffer",
            "stride",
            "mMixBufferU",
            "mMixBufferV",
            "numSamples",
            "mixBits",
            "mixRes",
            "mShiftBufferUV",
            "bytesShifted"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mix24",
          "args": [
            "(uint8_t *) inputBuffer",
            "stride",
            "mMixBufferU",
            "mMixBufferV",
            "numSamples",
            "mixBits",
            "mixRes",
            "mShiftBufferUV",
            "bytesShifted"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mix20",
          "args": [
            "(uint8_t *) inputBuffer",
            "stride",
            "mMixBufferU",
            "mMixBufferV",
            "numSamples",
            "mixBits",
            "mixRes"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mix16",
          "args": [
            "(int16_t *) inputBuffer",
            "stride",
            "mMixBufferU",
            "mMixBufferV",
            "numSamples",
            "mixBits",
            "mixRes"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dyn_comp",
          "args": [
            "&agParams",
            "mPredictorV",
            "&workBits",
            "numSamples/dilate",
            "chanBits",
            "&bits2"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ag_params",
          "args": [
            "&agParams",
            "MB0",
            "(pbFactor * PB0) / 4",
            "KB0",
            "numSamples/dilate",
            "numSamples/dilate",
            "MAX_RUN_DEFAULT"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dyn_comp",
          "args": [
            "&agParams",
            "mPredictorU",
            "&workBits",
            "numSamples/dilate",
            "chanBits",
            "&bits1"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ag_params",
          "args": [
            "&agParams",
            "MB0",
            "(pbFactor * PB0) / 4",
            "KB0",
            "numSamples/dilate",
            "numSamples/dilate",
            "MAX_RUN_DEFAULT"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc_block",
          "args": [
            "mMixBufferV",
            "mPredictorV",
            "numSamples/dilate",
            "coefsV[numV - 1]",
            "numV",
            "chanBits",
            "DENSHIFT_DEFAULT"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pc_block",
          "args": [
            "mMixBufferU",
            "mPredictorU",
            "numSamples/dilate",
            "coefsU[numU - 1]",
            "numU",
            "chanBits",
            "DENSHIFT_DEFAULT"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitBufferInit",
          "args": [
            "&workBits",
            "mWorkBuffer",
            "mMaxOutputBytes"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mix32",
          "args": [
            "(int32_t *) inputBuffer",
            "stride",
            "mMixBufferU",
            "mMixBufferV",
            "numSamples/dilate",
            "mixBits",
            "mixRes",
            "mShiftBufferUV",
            "bytesShifted"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mix24",
          "args": [
            "(uint8_t *) inputBuffer",
            "stride",
            "mMixBufferU",
            "mMixBufferV",
            "numSamples/dilate",
            "mixBits",
            "mixRes",
            "mShiftBufferUV",
            "bytesShifted"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mix20",
          "args": [
            "(uint8_t *) inputBuffer",
            "stride",
            "mMixBufferU",
            "mMixBufferV",
            "numSamples/dilate",
            "mixBits",
            "mixRes"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mix16",
          "args": [
            "(int16_t *) inputBuffer",
            "stride",
            "mMixBufferU",
            "mMixBufferV",
            "numSamples/dilate",
            "mixBits",
            "mixRes"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RequireAction",
          "args": [
            "(mBitDepth == 16) || (mBitDepth == 20) || (mBitDepth == 24) || (mBitDepth == 32)",
            "returnkALAC_ParamError;"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define VERBOSE_DEBUG\t\t0\n\nconst uint32_t kDefaultMixBits\t= 2;\nconst uint32_t kMaxRes\t\t\t= 4;\nconst uint32_t kDefaultNumUV\t\t= 8;\nconst uint32_t kMinUV\t\t\t\t= 4;\nconst uint32_t kMaxUV\t\t\t\t= 8;\n\nALACEncoder {\n  int32_t ALACEncoder::EncodeStereo( BitBuffer * bitstream, void * inputBuffer, uint32_t stride, uint32_t channelIndex, uint32_t numSamples )\n  {\n  \tBitBuffer\t\tworkBits;\n  \tBitBuffer\t\tstartBits = *bitstream;\t\t\t// squirrel away copy of current state in case we need to go back and do an escape packet\n  \tAGParamRec\t\tagParams;\n  \tuint32_t          bits1, bits2;\n  \tuint32_t\t\t\tdilate;\n  \tint32_t\t\t\tmixBits, mixRes, maxRes;\n  \tuint32_t\t\t\tminBits, minBits1, minBits2;\n  \tuint32_t\t\t\tnumU, numV;\n  \tuint32_t\t\t\tmode;\n  \tuint32_t\t\t\tpbFactor;\n  \tuint32_t\t\t\tchanBits;\n  \tuint32_t\t\t\tdenShift;\n  \tuint8_t\t\t\tbytesShifted;\n  \tSearchCoefs\t\tcoefsU;\n  \tSearchCoefs\t\tcoefsV;\n  \tuint32_t\t\t\tindex;\n  \tuint8_t\t\t\tpartialFrame;\n  \tuint32_t\t\t\tescapeBits;\n  \tbool\t\t\tdoEscape;\n  \tint32_t\t\tstatus = ALAC_noErr;\n  \n  \t// make sure we handle this bit-depth before we get going\n  \tRequireAction( (mBitDepth == 16) || (mBitDepth == 20) || (mBitDepth == 24) || (mBitDepth == 32), return kALAC_ParamError; );\n  \n  \t// reload coefs pointers for this channel pair\n  \t// - note that, while you might think they should be re-initialized per block, retaining state across blocks\n  \t//\t actually results in better overall compression\n  \t// - strangely, re-using the same coefs for the different passes of the \"mixRes\" search loop instead of using\n  \t//\t different coefs for the different passes of \"mixRes\" results in even better compression\n  \tcoefsU = (SearchCoefs) mCoefsU[channelIndex];\n  \tcoefsV = (SearchCoefs) mCoefsV[channelIndex];\n  \n  \t// matrix encoding adds an extra bit but 32-bit inputs cannot be matrixed b/c 33 is too many\n  \t// so enable 16-bit \"shift off\" and encode in 17-bit mode\n  \t// - in addition, 24-bit mode really improves with one byte shifted off\n  \tif ( mBitDepth == 32 )\n  \t\tbytesShifted = 2;\n  \telse if ( mBitDepth >= 24 )\n  \t\tbytesShifted = 1;\n  \telse\n  \t\tbytesShifted = 0;\n  \n  \tchanBits = mBitDepth - (bytesShifted * 8) + 1;\n  \t\n  \t// flag whether or not this is a partial frame\n  \tpartialFrame = (numSamples == mFrameSize) ? 0 : 1;\n  \n  \t// brute-force encode optimization loop\n  \t// - run over variations of the encoding params to find the best choice\n  \tmixBits\t\t= kDefaultMixBits;\n  \tmaxRes\t\t= kMaxRes;\n  \tnumU = numV = kDefaultNumUV;\n  \tdenShift\t= DENSHIFT_DEFAULT;\n  \tmode\t\t= 0;\n  \tpbFactor\t= 4;\n  \tdilate\t\t= 8;\n  \n  \tminBits\t= minBits1 = minBits2 = 1ul << 31;\n  \t\n      int32_t\t\tbestRes = mLastMixRes[channelIndex];\n  \n      for ( mixRes = 0; mixRes <= maxRes; mixRes++ )\n      {\n          // mix the stereo inputs\n          switch ( mBitDepth )\n          {\n              case 16:\n                  mix16( (int16_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples/dilate, mixBits, mixRes );\n                  break;\n              case 20:\n                  mix20( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples/dilate, mixBits, mixRes );\n                  break;\n              case 24:\n                  // includes extraction of shifted-off bytes\n                  mix24( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples/dilate,\n                          mixBits, mixRes, mShiftBufferUV, bytesShifted );\n                  break;\n              case 32:\n                  // includes extraction of shifted-off bytes\n                  mix32( (int32_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples/dilate,\n                          mixBits, mixRes, mShiftBufferUV, bytesShifted );\n                  break;\n          }\n  \n          BitBufferInit( &workBits, mWorkBuffer, mMaxOutputBytes );\n          \n          // run the dynamic predictors\n          pc_block( mMixBufferU, mPredictorU, numSamples/dilate, coefsU[numU - 1], numU, chanBits, DENSHIFT_DEFAULT );\n          pc_block( mMixBufferV, mPredictorV, numSamples/dilate, coefsV[numV - 1], numV, chanBits, DENSHIFT_DEFAULT );\n  \n          // run the lossless compressor on each channel\n          set_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n          status = dyn_comp( &agParams, mPredictorU, &workBits, numSamples/dilate, chanBits, &bits1 );\n          RequireNoErr( status, goto Exit; );\n  \n          set_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n          status = dyn_comp( &agParams, mPredictorV, &workBits, numSamples/dilate, chanBits, &bits2 );\n          RequireNoErr( status, goto Exit; );\n  \n          // look for best match\n          if ( (bits1 + bits2) < minBits1 )\n          {\n              minBits1 = bits1 + bits2;\n              bestRes = mixRes;\n          }\n      }\n      \n      mLastMixRes[channelIndex] = (int16_t)bestRes;\n  \n  \t// mix the stereo inputs with the current best mixRes\n  \tmixRes = mLastMixRes[channelIndex];\n  \tswitch ( mBitDepth )\n  \t{\n  \t\tcase 16:\n  \t\t\tmix16( (int16_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, mixBits, mixRes );\n  \t\t\tbreak;\n  \t\tcase 20:\n  \t\t\tmix20( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples, mixBits, mixRes );\n  \t\t\tbreak;\n  \t\tcase 24:\n  \t\t\t// also extracts the shifted off bytes into the shift buffers\n  \t\t\tmix24( (uint8_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples,\n  \t\t\t\t\tmixBits, mixRes, mShiftBufferUV, bytesShifted );\n  \t\t\tbreak;\n  \t\tcase 32:\n  \t\t\t// also extracts the shifted off bytes into the shift buffers\n  \t\t\tmix32( (int32_t *) inputBuffer, stride, mMixBufferU, mMixBufferV, numSamples,\n  \t\t\t\t\tmixBits, mixRes, mShiftBufferUV, bytesShifted );\n  \t\t\tbreak;\n  \t}\n  \n  \t// now it's time for the predictor coefficient search loop\n  \tnumU = numV = kMinUV;\n  \tminBits1 = minBits2 = 1ul << 31;\n  \n  \tfor ( uint32_t numUV = kMinUV; numUV <= kMaxUV; numUV += 4 )\n  \t{\n  \t\tBitBufferInit( &workBits, mWorkBuffer, mMaxOutputBytes );\t\t\n  \n  \t\tdilate = 32;\n  \n  \t\t// run the predictor over the same data multiple times to help it converge\n  \t\tfor ( uint32_t converge = 0; converge < 8; converge++ )\n  \t\t{\n  \t\t    pc_block( mMixBufferU, mPredictorU, numSamples/dilate, coefsU[numUV-1], numUV, chanBits, DENSHIFT_DEFAULT );\n  \t\t    pc_block( mMixBufferV, mPredictorV, numSamples/dilate, coefsV[numUV-1], numUV, chanBits, DENSHIFT_DEFAULT );\n  \t\t}\n  \n  \t\tdilate = 8;\n  \n  \t\tset_ag_params( &agParams, MB0, (pbFactor * PB0)/4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n  \t\tstatus = dyn_comp( &agParams, mPredictorU, &workBits, numSamples/dilate, chanBits, &bits1 );\n  \n  \t\tif ( (bits1 * dilate + 16 * numUV) < minBits1 )\n  \t\t{\n  \t\t\tminBits1 = bits1 * dilate + 16 * numUV;\n  \t\t\tnumU = numUV;\n  \t\t}\n  \n  \t\tset_ag_params( &agParams, MB0, (pbFactor * PB0)/4, KB0, numSamples/dilate, numSamples/dilate, MAX_RUN_DEFAULT );\n  \t\tstatus = dyn_comp( &agParams, mPredictorV, &workBits, numSamples/dilate, chanBits, &bits2 );\n  \n  \t\tif ( (bits2 * dilate + 16 * numUV) < minBits2 )\n  \t\t{\n  \t\t\tminBits2 = bits2 * dilate + 16 * numUV;\n  \t\t\tnumV = numUV;\n  \t\t}\n  \t}\n  \n  \t// test for escape hatch if best calculated compressed size turns out to be more than the input size\n  \tminBits = minBits1 + minBits2 + (8 /* mixRes/maxRes/etc. */ * 8) + ((partialFrame == true) ? 32 : 0);\n  \tif ( bytesShifted != 0 )\n  \t\tminBits += (numSamples * (bytesShifted * 8) * 2);\n  \n  \tescapeBits = (numSamples * mBitDepth * 2) + ((partialFrame == true) ? 32 : 0) + (2 * 8);\t/* 2 common header bytes */\n  \n  \tdoEscape = (minBits >= escapeBits) ? true : false;\n  \n  \tif ( doEscape == false )\n  \t{\n  \t\t// write bitstream header and coefs\n  \t\tBitBufferWrite( bitstream, 0, 12 );\n  \t\tBitBufferWrite( bitstream, (partialFrame << 3) | (bytesShifted << 1), 4 );\n  \t\tif ( partialFrame )\n  \t\t\tBitBufferWrite( bitstream, numSamples, 32 );\n  \t\tBitBufferWrite( bitstream, mixBits, 8 );\n  \t\tBitBufferWrite( bitstream, mixRes, 8 );\n  \t\t\n  \t\t//Assert( (mode < 16) && (DENSHIFT_DEFAULT < 16) );\n  \t\t//Assert( (pbFactor < 8) && (numU < 32) );\n  \t\t//Assert( (pbFactor < 8) && (numV < 32) );\n  \n  \t\tBitBufferWrite( bitstream, (mode << 4) | DENSHIFT_DEFAULT, 8 );\n  \t\tBitBufferWrite( bitstream, (pbFactor << 5) | numU, 8 );\n  \t\tfor ( index = 0; index < numU; index++ )\n  \t\t\tBitBufferWrite( bitstream, coefsU[numU - 1][index], 16 );\n  \n  \t\tBitBufferWrite( bitstream, (mode << 4) | DENSHIFT_DEFAULT, 8 );\n  \t\tBitBufferWrite( bitstream, (pbFactor << 5) | numV, 8 );\n  \t\tfor ( index = 0; index < numV; index++ )\n  \t\t\tBitBufferWrite( bitstream, coefsV[numV - 1][index], 16 );\n  \n  \t\t// if shift active, write the interleaved shift buffers\n  \t\tif ( bytesShifted != 0 )\n  \t\t{\n  \t\t\tuint32_t\t\tbitShift = bytesShifted * 8;\n  \n  \t\t\t//Assert( bitShift <= 16 );\n  \n  \t\t\tfor ( index = 0; index < (numSamples * 2); index += 2 )\n  \t\t\t{\n  \t\t\t\tuint32_t\t\t\tshiftedVal;\n  \t\t\t\t\n  \t\t\t\tshiftedVal = ((uint32_t)mShiftBufferUV[index + 0] << bitShift) | (uint32_t)mShiftBufferUV[index + 1];\n  \t\t\t\tBitBufferWrite( bitstream, shiftedVal, bitShift * 2 );\n  \t\t\t}\n  \t\t}\n  \n  \t\t// run the dynamic predictor and lossless compression for the \"left\" channel\n  \t\t// - note: to avoid allocating more buffers, we're mixing and matching between the available buffers instead\n  \t\t//\t\t   of only using \"U\" buffers for the U-channel and \"V\" buffers for the V-channel\n  \t\tif ( mode == 0 )\n  \t\t{\n  \t\t\tpc_block( mMixBufferU, mPredictorU, numSamples, coefsU[numU - 1], numU, chanBits, DENSHIFT_DEFAULT );\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tpc_block( mMixBufferU, mPredictorV, numSamples, coefsU[numU - 1], numU, chanBits, DENSHIFT_DEFAULT );\n  \t\t\tpc_block( mPredictorV, mPredictorU, numSamples, nil, 31, chanBits, 0 );\n  \t\t}\n  \n  \t\tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT );\n  \t\tstatus = dyn_comp( &agParams, mPredictorU, bitstream, numSamples, chanBits, &bits1 );\n  \t\tRequireNoErr( status, goto Exit; );\n  \n  \t\t// run the dynamic predictor and lossless compression for the \"right\" channel\n  \t\tif ( mode == 0 )\n  \t\t{\n  \t\t\tpc_block( mMixBufferV, mPredictorV, numSamples, coefsV[numV - 1], numV, chanBits, DENSHIFT_DEFAULT );\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tpc_block( mMixBufferV, mPredictorU, numSamples, coefsV[numV - 1], numV, chanBits, DENSHIFT_DEFAULT );\n  \t\t\tpc_block( mPredictorU, mPredictorV, numSamples, nil, 31, chanBits, 0 );\n  \t\t}\n  \n  \t\tset_ag_params( &agParams, MB0, (pbFactor * PB0) / 4, KB0, numSamples, numSamples, MAX_RUN_DEFAULT );\n  \t\tstatus = dyn_comp( &agParams, mPredictorV, bitstream, numSamples, chanBits, &bits2 );\n  \t\tRequireNoErr( status, goto Exit; );\n  \n  \t\t/*\tif we happened to create a compressed packet that was actually bigger than an escape packet would be,\n  \t\t\tchuck it and do an escape packet\n  \t\t*/\n  \t\tminBits = BitBufferGetPosition( bitstream ) - BitBufferGetPosition( &startBits );\n  \t\tif ( minBits >= escapeBits )\n  \t\t{\n  \t\t\t*bitstream = startBits;\t\t// reset bitstream state\n  \t\t\tdoEscape = true;\n  \t\t}\n  \t}\n  \n  \tif ( doEscape == true )\n  \t{\n  \t\t/* escape */\n  \t\tstatus = this->EncodeStereoEscape( bitstream, inputBuffer, stride, numSamples );\n  \n  #if VERBOSE_DEBUG\t\t\n  \t\tDebugMsg( \"escape!: %lu vs %lu\", minBits, escapeBits );\n  #endif\n  \t}\n  \t\n  Exit:\n  \treturn status;\n  }\n}"
  },
  {
    "function_name": "~ALACEncoder",
    "container": "ALACEncoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
    "lines": "124-163",
    "snippet": "ALACEncoder::~ALACEncoder()\n{\n\t// delete the matrix mixing buffers\n\tif ( mMixBufferU )\n    {\n\t\tfree(mMixBufferU);\n        mMixBufferU = NULL;\n    }\n\tif ( mMixBufferV )\n    {\n\t\tfree(mMixBufferV);\n        mMixBufferV = NULL;\n    }\n\t\n\t// delete the dynamic predictor's \"corrector\" buffers\n\tif ( mPredictorU )\n    {\n\t\tfree(mPredictorU);\n        mPredictorU = NULL;\n    }\n\tif ( mPredictorV )\n    {\n\t\tfree(mPredictorV);\n        mPredictorV = NULL;\n    }\n\n\t// delete the unused byte shift buffer\n\tif ( mShiftBufferUV )\n    {\n\t\tfree(mShiftBufferUV);\n        mShiftBufferUV = NULL;\n    }\n\n\t// delete the work buffer\n\tif ( mWorkBuffer )\n    {\n\t\tfree(mWorkBuffer);\n        mWorkBuffer = NULL;\n    }\t\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACAudioTypes.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"dplib.h\"",
      "#include \"aglib.h\"",
      "#include \"ALACEncoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mWorkBuffer"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "_af_setup_free_instruments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Setup.cpp",
          "lines": "251-263",
          "snippet": "void _af_setup_free_instruments (AFfilesetup setup)\n{\n\tif (setup->instruments)\n\t{\n\t\tfor (int i=0; i < setup->instrumentCount; i++)\n\t\t\tsetup->instruments[i].freeLoops();\n\n\t\tfree(setup->instruments);\n\t}\n\n\tsetup->instruments = NULL;\n\tsetup->instrumentCount = 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"audiofile.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"Setup.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"audiofile.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include <string.h>\n#include <stdlib.h>\n#include \"Setup.h\"\n#include \"config.h\"\n\nvoid _af_setup_free_instruments (AFfilesetup setup)\n{\n\tif (setup->instruments)\n\t{\n\t\tfor (int i=0; i < setup->instrumentCount; i++)\n\t\t\tsetup->instruments[i].freeLoops();\n\n\t\tfree(setup->instruments);\n\t}\n\n\tsetup->instruments = NULL;\n\tsetup->instrumentCount = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nALACEncoder {\n  ALACEncoder::~ALACEncoder()\n  {\n  \t// delete the matrix mixing buffers\n  \tif ( mMixBufferU )\n      {\n  \t\tfree(mMixBufferU);\n          mMixBufferU = NULL;\n      }\n  \tif ( mMixBufferV )\n      {\n  \t\tfree(mMixBufferV);\n          mMixBufferV = NULL;\n      }\n  \t\n  \t// delete the dynamic predictor's \"corrector\" buffers\n  \tif ( mPredictorU )\n      {\n  \t\tfree(mPredictorU);\n          mPredictorU = NULL;\n      }\n  \tif ( mPredictorV )\n      {\n  \t\tfree(mPredictorV);\n          mPredictorV = NULL;\n      }\n  \n  \t// delete the unused byte shift buffer\n  \tif ( mShiftBufferUV )\n      {\n  \t\tfree(mShiftBufferUV);\n          mShiftBufferUV = NULL;\n      }\n  \n  \t// delete the work buffer\n  \tif ( mWorkBuffer )\n      {\n  \t\tfree(mWorkBuffer);\n          mWorkBuffer = NULL;\n      }\t\n  }\n}"
  },
  {
    "function_name": "ALACEncoder",
    "container": "ALACEncoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/alac/ALACEncoder.cpp",
    "lines": "102-119",
    "snippet": "ALACEncoder::ALACEncoder() :\n\tmBitDepth( 0 ),\n    mFastMode( 0 ),\n\tmMixBufferU( nil ),\n\tmMixBufferV( nil ),\n\tmPredictorU( nil ),\n\tmPredictorV( nil ),\n\tmShiftBufferUV( nil ),\n\tmWorkBuffer( nil ),\n\n\n\tmTotalBytesGenerated( 0 ),\n\tmAvgBitRate( 0 ),\n\tmMaxFrameBytes( 0 )\n{\n\t// overrides\n\tmFrameSize = kALACDefaultFrameSize;\n}",
    "includes": [
      "#include \"EndianPortable.h\"",
      "#include \"ALACAudioTypes.h\"",
      "#include \"ALACBitUtilities.h\"",
      "#include \"matrixlib.h\"",
      "#include \"dplib.h\"",
      "#include \"aglib.h\"",
      "#include \"ALACEncoder.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"EndianPortable.h\"\n#include \"ALACAudioTypes.h\"\n#include \"ALACBitUtilities.h\"\n#include \"matrixlib.h\"\n#include \"dplib.h\"\n#include \"aglib.h\"\n#include \"ALACEncoder.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nALACEncoder {\n  ALACEncoder::ALACEncoder() :\n  \tmBitDepth( 0 ),\n      mFastMode( 0 ),\n  \tmMixBufferU( nil ),\n  \tmMixBufferV( nil ),\n  \tmPredictorU( nil ),\n  \tmPredictorV( nil ),\n  \tmShiftBufferUV( nil ),\n  \tmWorkBuffer( nil ),\n  \n  \n  \tmTotalBytesGenerated( 0 ),\n  \tmAvgBitRate( 0 ),\n  \tmMaxFrameBytes( 0 )\n  {\n  \t// overrides\n  \tmFrameSize = kALACDefaultFrameSize;\n  }\n}"
  }
]