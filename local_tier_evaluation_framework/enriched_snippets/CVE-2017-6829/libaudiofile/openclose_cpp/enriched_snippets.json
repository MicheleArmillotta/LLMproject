[
  {
    "function_name": "afCloseFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/openclose.cpp",
    "lines": "445-462",
    "snippet": "int afCloseFile (AFfilehandle file)\n{\n\tint\terr;\n\n\tif (!_af_filehandle_ok(file))\n\t\treturn -1;\n\n\tafSyncFile(file);\n\n\terr = file->m_fh->close();\n\tif (err < 0)\n\t\t_af_error(AF_BAD_CLOSE, \"close returned %d\", err);\n\n\tdelete file->m_fh;\n\tdelete file;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"modules/ModuleState.h\"",
      "#include \"modules/Module.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include <audiofile.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <assert.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_CLOSE",
            "\"close returned %d\"",
            "err"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->m_fh->close",
          "args": [],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "164-170",
          "snippet": "int FileVF::close()\n{\n\tif (m_vf)\n\t\taf_virtual_file_destroy(m_vf);\n\tm_vf = 0;\n\treturn 0;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  int FileVF::close()\n  {\n  \tif (m_vf)\n  \t\taf_virtual_file_destroy(m_vf);\n  \tm_vf = 0;\n  \treturn 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "afSyncFile",
          "args": [
            "file"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "afSyncFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/openclose.cpp",
          "lines": "408-443",
          "snippet": "int afSyncFile (AFfilehandle handle)\n{\n\tif (!_af_filehandle_ok(handle))\n\t\treturn -1;\n\n\tif (handle->m_access == _AF_WRITE_ACCESS)\n\t{\n\t\t/* Finish writes on all tracks. */\n\t\tfor (int trackno = 0; trackno < handle->m_trackCount; trackno++)\n\t\t{\n\t\t\tTrack *track = &handle->m_tracks[trackno];\n\n\t\t\tif (track->ms->isDirty() && track->ms->setup(handle, track) == AF_FAIL)\n\t\t\t\treturn -1;\n\n\t\t\tif (track->ms->sync(handle, track) != AF_SUCCEED)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\t/* Update file headers. */\n\t\tif (handle->update() != AF_SUCCEED)\n\t\t\treturn AF_FAIL;\n\t}\n\telse if (handle->m_access == _AF_READ_ACCESS)\n\t{\n\t\t/* Do nothing. */\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"unrecognized access mode %d\",\n\t\t\thandle->m_access);\n\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"modules/ModuleState.h\"",
            "#include \"modules/Module.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include <audiofile.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <audiofile.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint afSyncFile (AFfilehandle handle)\n{\n\tif (!_af_filehandle_ok(handle))\n\t\treturn -1;\n\n\tif (handle->m_access == _AF_WRITE_ACCESS)\n\t{\n\t\t/* Finish writes on all tracks. */\n\t\tfor (int trackno = 0; trackno < handle->m_trackCount; trackno++)\n\t\t{\n\t\t\tTrack *track = &handle->m_tracks[trackno];\n\n\t\t\tif (track->ms->isDirty() && track->ms->setup(handle, track) == AF_FAIL)\n\t\t\t\treturn -1;\n\n\t\t\tif (track->ms->sync(handle, track) != AF_SUCCEED)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\t/* Update file headers. */\n\t\tif (handle->update() != AF_SUCCEED)\n\t\t\treturn AF_FAIL;\n\t}\n\telse if (handle->m_access == _AF_READ_ACCESS)\n\t{\n\t\t/* Do nothing. */\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"unrecognized access mode %d\",\n\t\t\thandle->m_access);\n\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_filehandle_ok",
          "args": [
            "file"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "_af_filehandle_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "71-84",
          "snippet": "bool _af_filehandle_ok (AFfilehandle file)\n{\n\tif (file == AF_NULL_FILEHANDLE)\n\t{\n\t\t_af_error(AF_BAD_FILEHANDLE, \"null file handle\");\n\t\treturn false;\n\t}\n\tif (file->m_valid != _AF_VALID_FILEHANDLE)\n\t{\n\t\t_af_error(AF_BAD_FILEHANDLE, \"invalid file handle\");\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nbool _af_filehandle_ok (AFfilehandle file)\n{\n\tif (file == AF_NULL_FILEHANDLE)\n\t{\n\t\t_af_error(AF_BAD_FILEHANDLE, \"null file handle\");\n\t\treturn false;\n\t}\n\tif (file->m_valid != _AF_VALID_FILEHANDLE)\n\t{\n\t\t_af_error(AF_BAD_FILEHANDLE, \"invalid file handle\");\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <audiofile.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint afCloseFile (AFfilehandle file)\n{\n\tint\terr;\n\n\tif (!_af_filehandle_ok(file))\n\t\treturn -1;\n\n\tafSyncFile(file);\n\n\terr = file->m_fh->close();\n\tif (err < 0)\n\t\t_af_error(AF_BAD_CLOSE, \"close returned %d\", err);\n\n\tdelete file->m_fh;\n\tdelete file;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "afSyncFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/openclose.cpp",
    "lines": "408-443",
    "snippet": "int afSyncFile (AFfilehandle handle)\n{\n\tif (!_af_filehandle_ok(handle))\n\t\treturn -1;\n\n\tif (handle->m_access == _AF_WRITE_ACCESS)\n\t{\n\t\t/* Finish writes on all tracks. */\n\t\tfor (int trackno = 0; trackno < handle->m_trackCount; trackno++)\n\t\t{\n\t\t\tTrack *track = &handle->m_tracks[trackno];\n\n\t\t\tif (track->ms->isDirty() && track->ms->setup(handle, track) == AF_FAIL)\n\t\t\t\treturn -1;\n\n\t\t\tif (track->ms->sync(handle, track) != AF_SUCCEED)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\t/* Update file headers. */\n\t\tif (handle->update() != AF_SUCCEED)\n\t\t\treturn AF_FAIL;\n\t}\n\telse if (handle->m_access == _AF_READ_ACCESS)\n\t{\n\t\t/* Do nothing. */\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"unrecognized access mode %d\",\n\t\t\thandle->m_access);\n\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"modules/ModuleState.h\"",
      "#include \"modules/Module.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include <audiofile.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <assert.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_ACCMODE",
            "\"unrecognized access mode %d\"",
            "handle->m_access"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle->update",
          "args": [],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "update",
          "container": "IFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
          "lines": "337-354",
          "snippet": "status IFFFile::update()\n{\n\tuint32_t length;\n\n\twriteVHDR();\n\twriteMiscellaneous();\n\twriteBODY();\n\n\t/* Get the length of the file. */\n\tlength = m_fh->length();\n\tlength -= 8;\n\n\t/* Set the length of the FORM chunk. */\n\tm_fh->seek(4, File::SeekFromBeginning);\n\twriteU32(&length);\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"IFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::update()\n  {\n  \tuint32_t length;\n  \n  \twriteVHDR();\n  \twriteMiscellaneous();\n  \twriteBODY();\n  \n  \t/* Get the length of the file. */\n  \tlength = m_fh->length();\n  \tlength -= 8;\n  \n  \t/* Set the length of the FORM chunk. */\n  \tm_fh->seek(4, File::SeekFromBeginning);\n  \twriteU32(&length);\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->ms->sync",
          "args": [
            "handle",
            "track"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "sync",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "230-242",
          "snippet": "status ModuleState::sync(AFfilehandle file, Track *track)\n{\n\ttrack->filemodhappy = true;\n\tfor (std::vector<SharedPtr<Module> >::reverse_iterator i=m_modules.rbegin();\n\t\t\ti != m_modules.rend(); ++i)\n\t\t(*i)->sync1();\n\tif (!track->filemodhappy)\n\t\treturn AF_FAIL;\n\tfor (std::vector<SharedPtr<Module> >::iterator i=m_modules.begin();\n\t\t\ti != m_modules.end(); ++i)\n\t\t(*i)->sync2();\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  status ModuleState::sync(AFfilehandle file, Track *track)\n  {\n  \ttrack->filemodhappy = true;\n  \tfor (std::vector<SharedPtr<Module> >::reverse_iterator i=m_modules.rbegin();\n  \t\t\ti != m_modules.rend(); ++i)\n  \t\t(*i)->sync1();\n  \tif (!track->filemodhappy)\n  \t\treturn AF_FAIL;\n  \tfor (std::vector<SharedPtr<Module> >::iterator i=m_modules.begin();\n  \t\t\ti != m_modules.end(); ++i)\n  \t\t(*i)->sync2();\n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->ms->setup",
          "args": [
            "handle",
            "track"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "setup",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "109-201",
          "snippet": "status ModuleState::setup(AFfilehandle file, Track *track)\n{\n\tAFframecount fframepos = llrint(track->nextvframe * track->f.sampleRate / track->v.sampleRate);\n\tbool isReading = file->m_access == _AF_READ_ACCESS;\n\n\tif (!track->v.isUncompressed())\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\"library does not support compression in virtual format yet\");\n\t\treturn AF_FAIL;\n\t}\n\n\tif (arrange(file, track) == AF_FAIL)\n\t\treturn AF_FAIL;\n\n\ttrack->filemodhappy = true;\n\tint maxbufsize = 0;\n\tif (isReading)\n\t{\n\t\tm_chunks.back()->frameCount = _AF_ATOMIC_NVFRAMES;\n\t\tfor (int i=m_modules.size() - 1; i >= 0; i--)\n\t\t{\n\t\t\tSharedPtr<Chunk> inChunk = m_chunks[i];\n\t\t\tSharedPtr<Chunk> outChunk = m_chunks[i+1];\n\t\t\tint bufsize = outChunk->frameCount * outChunk->f.bytesPerFrame(true);\n\t\t\tif (bufsize > maxbufsize)\n\t\t\t\tmaxbufsize = bufsize;\n\t\t\tif (i != 0)\n\t\t\t\tm_modules[i]->setSource(m_modules[i-1].get());\n\t\t\tm_modules[i]->maxPull();\n\t\t}\n\n\t\tif (!track->filemodhappy)\n\t\t\treturn AF_FAIL;\n\t\tint bufsize = m_fileModule->bufferSize();\n\t\tif (bufsize > maxbufsize)\n\t\t\tmaxbufsize = bufsize;\n\t}\n\telse\n\t{\n\t\tm_chunks.front()->frameCount = _AF_ATOMIC_NVFRAMES;\n\t\tfor (size_t i=0; i<m_modules.size(); i++)\n\t\t{\n\t\t\tSharedPtr<Chunk> inChunk = m_chunks[i];\n\t\t\tSharedPtr<Chunk> outChunk = m_chunks[i+1];\n\t\t\tint bufsize = inChunk->frameCount * inChunk->f.bytesPerFrame(true);\n\t\t\tif (bufsize > maxbufsize)\n\t\t\t\tmaxbufsize = bufsize;\n\t\t\tif (i != m_modules.size() - 1)\n\t\t\t\tm_modules[i]->setSink(m_modules[i+1].get());\n\t\t\tm_modules[i]->maxPush();\n\t\t}\n\n\t\tif (!track->filemodhappy)\n\t\t\treturn AF_FAIL;\n\n\t\tint bufsize = m_fileModule->bufferSize();\n\t\tif (bufsize > maxbufsize)\n\t\t\tmaxbufsize = bufsize;\n\t}\n\n\tfor (size_t i=0; i<m_chunks.size(); i++)\n\t{\n\t\tif ((isReading && i==m_chunks.size() - 1) || (!isReading && i==0))\n\t\t\tcontinue;\n\t\tm_chunks[i]->allocate(maxbufsize);\n\t}\n\n\tif (isReading)\n\t{\n\t\tif (track->totalfframes == -1)\n\t\t\ttrack->totalvframes = -1;\n\t\telse\n\t\t\ttrack->totalvframes = llrint(track->totalfframes *\n\t\t\t\t(track->v.sampleRate / track->f.sampleRate));\n\n\t\ttrack->nextfframe = fframepos;\n\t\ttrack->nextvframe = llrint(fframepos * track->v.sampleRate / track->f.sampleRate);\n\n\t\tm_isDirty = false;\n\n\t\tif (reset(file, track) == AF_FAIL)\n\t\t\treturn AF_FAIL;\n\t}\n\telse\n\t{\n\t\ttrack->nextvframe = track->totalvframes =\n\t\t\t(AFframecount) (fframepos * track->v.sampleRate / track->f.sampleRate);\n\t\tm_isDirty = false;\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  status ModuleState::setup(AFfilehandle file, Track *track)\n  {\n  \tAFframecount fframepos = llrint(track->nextvframe * track->f.sampleRate / track->v.sampleRate);\n  \tbool isReading = file->m_access == _AF_READ_ACCESS;\n  \n  \tif (!track->v.isUncompressed())\n  \t{\n  \t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n  \t\t\t\"library does not support compression in virtual format yet\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \tif (arrange(file, track) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \n  \ttrack->filemodhappy = true;\n  \tint maxbufsize = 0;\n  \tif (isReading)\n  \t{\n  \t\tm_chunks.back()->frameCount = _AF_ATOMIC_NVFRAMES;\n  \t\tfor (int i=m_modules.size() - 1; i >= 0; i--)\n  \t\t{\n  \t\t\tSharedPtr<Chunk> inChunk = m_chunks[i];\n  \t\t\tSharedPtr<Chunk> outChunk = m_chunks[i+1];\n  \t\t\tint bufsize = outChunk->frameCount * outChunk->f.bytesPerFrame(true);\n  \t\t\tif (bufsize > maxbufsize)\n  \t\t\t\tmaxbufsize = bufsize;\n  \t\t\tif (i != 0)\n  \t\t\t\tm_modules[i]->setSource(m_modules[i-1].get());\n  \t\t\tm_modules[i]->maxPull();\n  \t\t}\n  \n  \t\tif (!track->filemodhappy)\n  \t\t\treturn AF_FAIL;\n  \t\tint bufsize = m_fileModule->bufferSize();\n  \t\tif (bufsize > maxbufsize)\n  \t\t\tmaxbufsize = bufsize;\n  \t}\n  \telse\n  \t{\n  \t\tm_chunks.front()->frameCount = _AF_ATOMIC_NVFRAMES;\n  \t\tfor (size_t i=0; i<m_modules.size(); i++)\n  \t\t{\n  \t\t\tSharedPtr<Chunk> inChunk = m_chunks[i];\n  \t\t\tSharedPtr<Chunk> outChunk = m_chunks[i+1];\n  \t\t\tint bufsize = inChunk->frameCount * inChunk->f.bytesPerFrame(true);\n  \t\t\tif (bufsize > maxbufsize)\n  \t\t\t\tmaxbufsize = bufsize;\n  \t\t\tif (i != m_modules.size() - 1)\n  \t\t\t\tm_modules[i]->setSink(m_modules[i+1].get());\n  \t\t\tm_modules[i]->maxPush();\n  \t\t}\n  \n  \t\tif (!track->filemodhappy)\n  \t\t\treturn AF_FAIL;\n  \n  \t\tint bufsize = m_fileModule->bufferSize();\n  \t\tif (bufsize > maxbufsize)\n  \t\t\tmaxbufsize = bufsize;\n  \t}\n  \n  \tfor (size_t i=0; i<m_chunks.size(); i++)\n  \t{\n  \t\tif ((isReading && i==m_chunks.size() - 1) || (!isReading && i==0))\n  \t\t\tcontinue;\n  \t\tm_chunks[i]->allocate(maxbufsize);\n  \t}\n  \n  \tif (isReading)\n  \t{\n  \t\tif (track->totalfframes == -1)\n  \t\t\ttrack->totalvframes = -1;\n  \t\telse\n  \t\t\ttrack->totalvframes = llrint(track->totalfframes *\n  \t\t\t\t(track->v.sampleRate / track->f.sampleRate));\n  \n  \t\ttrack->nextfframe = fframepos;\n  \t\ttrack->nextvframe = llrint(fframepos * track->v.sampleRate / track->f.sampleRate);\n  \n  \t\tm_isDirty = false;\n  \n  \t\tif (reset(file, track) == AF_FAIL)\n  \t\t\treturn AF_FAIL;\n  \t}\n  \telse\n  \t{\n  \t\ttrack->nextvframe = track->totalvframes =\n  \t\t\t(AFframecount) (fframepos * track->v.sampleRate / track->f.sampleRate);\n  \t\tm_isDirty = false;\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->ms->isDirty",
          "args": [],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "isDirty",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.h",
          "lines": "39-39",
          "snippet": "bool isDirty() const { return m_isDirty; }",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"Module.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"Module.h\"\n\nModuleState {\n  bool isDirty() const { return m_isDirty; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_filehandle_ok",
          "args": [
            "handle"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "_af_filehandle_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "71-84",
          "snippet": "bool _af_filehandle_ok (AFfilehandle file)\n{\n\tif (file == AF_NULL_FILEHANDLE)\n\t{\n\t\t_af_error(AF_BAD_FILEHANDLE, \"null file handle\");\n\t\treturn false;\n\t}\n\tif (file->m_valid != _AF_VALID_FILEHANDLE)\n\t{\n\t\t_af_error(AF_BAD_FILEHANDLE, \"invalid file handle\");\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nbool _af_filehandle_ok (AFfilehandle file)\n{\n\tif (file == AF_NULL_FILEHANDLE)\n\t{\n\t\t_af_error(AF_BAD_FILEHANDLE, \"null file handle\");\n\t\treturn false;\n\t}\n\tif (file->m_valid != _AF_VALID_FILEHANDLE)\n\t{\n\t\t_af_error(AF_BAD_FILEHANDLE, \"invalid file handle\");\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <audiofile.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint afSyncFile (AFfilehandle handle)\n{\n\tif (!_af_filehandle_ok(handle))\n\t\treturn -1;\n\n\tif (handle->m_access == _AF_WRITE_ACCESS)\n\t{\n\t\t/* Finish writes on all tracks. */\n\t\tfor (int trackno = 0; trackno < handle->m_trackCount; trackno++)\n\t\t{\n\t\t\tTrack *track = &handle->m_tracks[trackno];\n\n\t\t\tif (track->ms->isDirty() && track->ms->setup(handle, track) == AF_FAIL)\n\t\t\t\treturn -1;\n\n\t\t\tif (track->ms->sync(handle, track) != AF_SUCCEED)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\t/* Update file headers. */\n\t\tif (handle->update() != AF_SUCCEED)\n\t\t\treturn AF_FAIL;\n\t}\n\telse if (handle->m_access == _AF_READ_ACCESS)\n\t{\n\t\t/* Do nothing. */\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"unrecognized access mode %d\",\n\t\t\thandle->m_access);\n\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}"
  },
  {
    "function_name": "_afOpenFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/openclose.cpp",
    "lines": "272-406",
    "snippet": "static status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup)\n{\n\tint\tfileFormat = AF_FILE_UNKNOWN;\n\tint\timplemented = true;\n\n\tint\t\tuserSampleFormat = 0;\n\tdouble\t\tuserSampleRate = 0.0;\n\tPCMInfo\tuserPCM = {0};\n\tbool\t\tuserFormatSet = false;\n\n\tAFfilehandle\tfilehandle = AF_NULL_FILEHANDLE;\n\tAFfilesetup\tcompletesetup = AF_NULL_FILESETUP;\n\n\t*file = AF_NULL_FILEHANDLE;\n\n\tif (access == _AF_WRITE_ACCESS || filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tif (!_af_filesetup_ok(filesetup))\n\t\t\treturn AF_FAIL;\n\n\t\tfileFormat = filesetup->fileFormat;\n\t\tif (access == _AF_READ_ACCESS && fileFormat != AF_FILE_RAWDATA)\n\t\t{\n\t\t\t_af_error(AF_BAD_FILESETUP,\n\t\t\t\t\"warning: opening file for read access: \"\n\t\t\t\t\"ignoring file setup with non-raw file format\");\n\t\t\tfilesetup = AF_NULL_FILESETUP;\n\t\t\tfileFormat = _af_identify(f, &implemented);\n\t\t}\n\t}\n\telse if (filesetup == AF_NULL_FILESETUP)\n\t\tfileFormat = _af_identify(f, &implemented);\n\n\tif (fileFormat == AF_FILE_UNKNOWN)\n\t{\n\t\tif (filename != NULL)\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"'%s': unrecognized audio file format\",\n\t\t\t\tfilename);\n\t\telse\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"unrecognized audio file format\");\n\t\treturn AF_FAIL;\n\t}\n\n\tconst char *formatName = _af_units[fileFormat].name;\n\n\tif (!implemented)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\"%s format not currently supported\", formatName);\n\t}\n\n\tcompletesetup = NULL;\n\tif (filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tuserSampleFormat = filesetup->tracks[0].f.sampleFormat;\n\t\tuserPCM = filesetup->tracks[0].f.pcm;\n\t\tuserSampleRate = filesetup->tracks[0].f.sampleRate;\n\t\tuserFormatSet = true;\n\t\tif ((completesetup = _af_units[fileFormat].completesetup(filesetup)) == NULL)\n\t\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle = _AFfilehandle::create(fileFormat);\n\tif (!filehandle)\n\t{\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle->m_fh = f;\n\tfilehandle->m_access = access;\n\tfilehandle->m_seekok = f->canSeek();\n\tif (filename != NULL)\n\t\tfilehandle->m_fileName = strdup(filename);\n\telse\n\t\tfilehandle->m_fileName = NULL;\n\tfilehandle->m_fileFormat = fileFormat;\n\n\tstatus result = access == _AF_READ_ACCESS ?\n\t\tfilehandle->readInit(completesetup) :\n\t\tfilehandle->writeInit(completesetup);\n\n\tif (result != AF_SUCCEED)\n\t{\n\t\tdelete filehandle;\n\t\tfilehandle = AF_NULL_FILEHANDLE;\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tif (completesetup)\n\t\tafFreeFileSetup(completesetup);\n\n\t/*\n\t\tInitialize virtual format.\n\t*/\n\tfor (int t=0; t<filehandle->m_trackCount; t++)\n\t{\n\t\tTrack *track = &filehandle->m_tracks[t];\n\n\t\ttrack->v = track->f;\n\n\t\tif (userFormatSet)\n\t\t{\n\t\t\ttrack->v.sampleFormat = userSampleFormat;\n\t\t\ttrack->v.pcm = userPCM;\n\t\t\ttrack->v.sampleRate = userSampleRate;\n\t\t}\n\n\t\ttrack->v.compressionType = AF_COMPRESSION_NONE;\n\t\ttrack->v.compressionParams = NULL;\n\n#if WORDS_BIGENDIAN\n\t\ttrack->v.byteOrder = AF_BYTEORDER_BIGENDIAN;\n#else\n\t\ttrack->v.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n#endif\n\n\t\ttrack->ms = new ModuleState();\n\t\tif (track->ms->init(filehandle, track) == AF_FAIL)\n\t\t{\n\t\t\tdelete filehandle;\n\t\t\treturn AF_FAIL;\n\t\t}\n\t}\n\n\t*file = filehandle;\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"modules/ModuleState.h\"",
      "#include \"modules/Module.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include <audiofile.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <assert.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "track->ms->init",
          "args": [
            "filehandle",
            "track"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "96-102",
          "snippet": "status ModuleState::init(AFfilehandle file, Track *track)\n{\n\tif (initFileModule(file, track) == AF_FAIL)\n\t\treturn AF_FAIL;\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  status ModuleState::init(AFfilehandle file, Track *track)\n  {\n  \tif (initFileModule(file, track) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "afFreeFileSetup",
          "args": [
            "completesetup"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "afFreeFileSetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Setup.cpp",
          "lines": "265-283",
          "snippet": "void afFreeFileSetup (AFfilesetup setup)\n{\n\tif (!_af_filesetup_ok(setup))\n\t\treturn;\n\n\t_af_setup_free_tracks(setup);\n\n\t_af_setup_free_instruments(setup);\n\n\tif (setup->miscellaneousCount)\n\t{\n\t\tfree(setup->miscellaneous);\n\t\tsetup->miscellaneous = NULL;\n\t\tsetup->miscellaneousCount = 0;\n\t}\n\n\tmemset(setup, 0, sizeof (_AFfilesetup));\n\tfree(setup);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"audiofile.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"Setup.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"audiofile.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include <string.h>\n#include <stdlib.h>\n#include \"Setup.h\"\n#include \"config.h\"\n\nvoid afFreeFileSetup (AFfilesetup setup)\n{\n\tif (!_af_filesetup_ok(setup))\n\t\treturn;\n\n\t_af_setup_free_tracks(setup);\n\n\t_af_setup_free_instruments(setup);\n\n\tif (setup->miscellaneousCount)\n\t{\n\t\tfree(setup->miscellaneous);\n\t\tsetup->miscellaneous = NULL;\n\t\tsetup->miscellaneousCount = 0;\n\t}\n\n\tmemset(setup, 0, sizeof (_AFfilesetup));\n\tfree(setup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filehandle->writeInit",
          "args": [
            "completesetup"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "writeInit",
          "container": "IFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
          "lines": "318-335",
          "snippet": "status IFFFile::writeInit(AFfilesetup setup)\n{\n\tif (initFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\n\tuint32_t fileSize = 0;\n\n\tm_fh->write(\"FORM\", 4);\n\twriteU32(&fileSize);\n\n\tm_fh->write(\"8SVX\", 4);\n\n\twriteVHDR();\n\twriteMiscellaneous();\n\twriteBODY();\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"IFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::writeInit(AFfilesetup setup)\n  {\n  \tif (initFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \n  \tuint32_t fileSize = 0;\n  \n  \tm_fh->write(\"FORM\", 4);\n  \twriteU32(&fileSize);\n  \n  \tm_fh->write(\"8SVX\", 4);\n  \n  \twriteVHDR();\n  \twriteMiscellaneous();\n  \twriteBODY();\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "filehandle->readInit",
          "args": [
            "completesetup"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "readInit",
          "container": "IFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
          "lines": "177-243",
          "snippet": "status IFFFile::readInit(AFfilesetup setup)\n{\n\tm_fh->seek(0, File::SeekFromBeginning);\n\n\tTag type;\n\tuint32_t size;\n\tTag formtype;\n\n\treadTag(&type);\n\treadU32(&size);\n\treadTag(&formtype);\n\n\tif (type != \"FORM\" || formtype != \"8SVX\")\n\t\treturn AF_FAIL;\n\n\t/* IFF/8SVX files have only one track. */\n\tTrack *track = allocateTrack();\n\tif (!track)\n\t\treturn AF_FAIL;\n\n\t/* Set the index to include the form type ('8SVX' in this case). */\n\tsize_t index = 4;\n\twhile (index < size)\n\t{\n\t\tTag chunkid;\n\t\tuint32_t chunksize = 0;\n\t\tstatus result = AF_SUCCEED;\n\n\t\treadTag(&chunkid);\n\t\treadU32(&chunksize);\n\n\t\tif (chunkid == \"VHDR\")\n\t\t{\n\t\t\tresult = parseVHDR(chunkid, chunksize);\n\t\t}\n\t\telse if (chunkid == \"BODY\")\n\t\t{\n\t\t\tresult = parseBODY(chunkid, chunksize);\n\t\t}\n\t\telse if (chunkid == \"NAME\" ||\n\t\t\tchunkid == \"AUTH\" ||\n\t\t\tchunkid == \"(c) \" ||\n\t\t\tchunkid == \"ANNO\")\n\t\t{\n\t\t\tparseMiscellaneous(chunkid, chunksize);\n\t\t}\n\n\t\tif (result == AF_FAIL)\n\t\t\treturn AF_FAIL;\n\n\t\t/*\n\t\t\tIncrement the index by the size of the chunk\n\t\t\tplus the size of the chunk header.\n\t\t*/\n\t\tindex += chunksize + 8;\n\n\t\t/* All chunks must be aligned on an even number of bytes. */\n\t\tif ((index % 2) != 0)\n\t\t\tindex++;\n\n\t\t/* Set the seek position to the beginning of the next chunk. */\n\t\tm_fh->seek(index + 8, File::SeekFromBeginning);\n\t}\n\n\t/* The file has been successfully parsed. */\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"IFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  status IFFFile::readInit(AFfilesetup setup)\n  {\n  \tm_fh->seek(0, File::SeekFromBeginning);\n  \n  \tTag type;\n  \tuint32_t size;\n  \tTag formtype;\n  \n  \treadTag(&type);\n  \treadU32(&size);\n  \treadTag(&formtype);\n  \n  \tif (type != \"FORM\" || formtype != \"8SVX\")\n  \t\treturn AF_FAIL;\n  \n  \t/* IFF/8SVX files have only one track. */\n  \tTrack *track = allocateTrack();\n  \tif (!track)\n  \t\treturn AF_FAIL;\n  \n  \t/* Set the index to include the form type ('8SVX' in this case). */\n  \tsize_t index = 4;\n  \twhile (index < size)\n  \t{\n  \t\tTag chunkid;\n  \t\tuint32_t chunksize = 0;\n  \t\tstatus result = AF_SUCCEED;\n  \n  \t\treadTag(&chunkid);\n  \t\treadU32(&chunksize);\n  \n  \t\tif (chunkid == \"VHDR\")\n  \t\t{\n  \t\t\tresult = parseVHDR(chunkid, chunksize);\n  \t\t}\n  \t\telse if (chunkid == \"BODY\")\n  \t\t{\n  \t\t\tresult = parseBODY(chunkid, chunksize);\n  \t\t}\n  \t\telse if (chunkid == \"NAME\" ||\n  \t\t\tchunkid == \"AUTH\" ||\n  \t\t\tchunkid == \"(c) \" ||\n  \t\t\tchunkid == \"ANNO\")\n  \t\t{\n  \t\t\tparseMiscellaneous(chunkid, chunksize);\n  \t\t}\n  \n  \t\tif (result == AF_FAIL)\n  \t\t\treturn AF_FAIL;\n  \n  \t\t/*\n  \t\t\tIncrement the index by the size of the chunk\n  \t\t\tplus the size of the chunk header.\n  \t\t*/\n  \t\tindex += chunksize + 8;\n  \n  \t\t/* All chunks must be aligned on an even number of bytes. */\n  \t\tif ((index % 2) != 0)\n  \t\t\tindex++;\n  \n  \t\t/* Set the seek position to the beginning of the next chunk. */\n  \t\tm_fh->seek(index + 8, File::SeekFromBeginning);\n  \t}\n  \n  \t/* The file has been successfully parsed. */\n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "filename"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f->canSeek",
          "args": [],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "canSeek",
          "container": "File",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "109-112",
          "snippet": "bool File::canSeek()\n{\n\treturn seek(0, File::SeekFromCurrent) != -1;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFile {\n  bool File::canSeek()\n  {\n  \treturn seek(0, File::SeekFromCurrent) != -1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_AFfilehandle::create",
          "args": [
            "fileFormat"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_units[fileFormat].completesetup",
          "args": [
            "filesetup"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"%s format not currently supported\"",
            "formatName"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"unrecognized audio file format\""
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"'%s': unrecognized audio file format\"",
            "filename"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_identify",
          "args": [
            "f",
            "&implemented"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "_af_identify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/openclose.cpp",
          "lines": "48-76",
          "snippet": "int _af_identify (File *f, int *implemented)\n{\n\tif (!f->canSeek())\n\t{\n\t\t_af_error(AF_BAD_LSEEK, \"Cannot seek in file\");\n\t\treturn AF_FILE_UNKNOWN;\n\t}\n\n\tAFfileoffset curpos = f->tell();\n\n\tfor (int i=0; i<_AF_NUM_UNITS; i++)\n\t{\n\t\tif (_af_units[i].recognize &&\n\t\t\t_af_units[i].recognize(f))\n\t\t{\n\t\t\tif (implemented != NULL)\n\t\t\t\t*implemented = _af_units[i].implemented;\n\t\t\tf->seek(curpos, File::SeekFromBeginning);\n\t\t\treturn _af_units[i].fileFormat;\n\t\t}\n\t}\n\n\tf->seek(curpos, File::SeekFromBeginning);\n\n\tif (implemented != NULL)\n\t\t*implemented = false;\n\n\treturn AF_FILE_UNKNOWN;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"modules/ModuleState.h\"",
            "#include \"modules/Module.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include <audiofile.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <audiofile.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint _af_identify (File *f, int *implemented)\n{\n\tif (!f->canSeek())\n\t{\n\t\t_af_error(AF_BAD_LSEEK, \"Cannot seek in file\");\n\t\treturn AF_FILE_UNKNOWN;\n\t}\n\n\tAFfileoffset curpos = f->tell();\n\n\tfor (int i=0; i<_AF_NUM_UNITS; i++)\n\t{\n\t\tif (_af_units[i].recognize &&\n\t\t\t_af_units[i].recognize(f))\n\t\t{\n\t\t\tif (implemented != NULL)\n\t\t\t\t*implemented = _af_units[i].implemented;\n\t\t\tf->seek(curpos, File::SeekFromBeginning);\n\t\t\treturn _af_units[i].fileFormat;\n\t\t}\n\t}\n\n\tf->seek(curpos, File::SeekFromBeginning);\n\n\tif (implemented != NULL)\n\t\t*implemented = false;\n\n\treturn AF_FILE_UNKNOWN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_FILESETUP",
            "\"warning: opening file for read access: \"\n\t\t\t\t\"ignoring file setup with non-raw file format\""
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_filesetup_ok",
          "args": [
            "filesetup"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "_af_filesetup_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "56-69",
          "snippet": "bool _af_filesetup_ok (AFfilesetup setup)\n{\n\tif (setup == AF_NULL_FILESETUP)\n\t{\n\t\t_af_error(AF_BAD_FILESETUP, \"null file setup\");\n\t\treturn false;\n\t}\n\tif (setup->valid != _AF_VALID_FILESETUP)\n\t{\n\t\t_af_error(AF_BAD_FILESETUP, \"invalid file setup\");\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nbool _af_filesetup_ok (AFfilesetup setup)\n{\n\tif (setup == AF_NULL_FILESETUP)\n\t{\n\t\t_af_error(AF_BAD_FILESETUP, \"null file setup\");\n\t\treturn false;\n\t}\n\tif (setup->valid != _AF_VALID_FILESETUP)\n\t{\n\t\t_af_error(AF_BAD_FILESETUP, \"invalid file setup\");\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <audiofile.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nstatic status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup);\n\nstatic status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup)\n{\n\tint\tfileFormat = AF_FILE_UNKNOWN;\n\tint\timplemented = true;\n\n\tint\t\tuserSampleFormat = 0;\n\tdouble\t\tuserSampleRate = 0.0;\n\tPCMInfo\tuserPCM = {0};\n\tbool\t\tuserFormatSet = false;\n\n\tAFfilehandle\tfilehandle = AF_NULL_FILEHANDLE;\n\tAFfilesetup\tcompletesetup = AF_NULL_FILESETUP;\n\n\t*file = AF_NULL_FILEHANDLE;\n\n\tif (access == _AF_WRITE_ACCESS || filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tif (!_af_filesetup_ok(filesetup))\n\t\t\treturn AF_FAIL;\n\n\t\tfileFormat = filesetup->fileFormat;\n\t\tif (access == _AF_READ_ACCESS && fileFormat != AF_FILE_RAWDATA)\n\t\t{\n\t\t\t_af_error(AF_BAD_FILESETUP,\n\t\t\t\t\"warning: opening file for read access: \"\n\t\t\t\t\"ignoring file setup with non-raw file format\");\n\t\t\tfilesetup = AF_NULL_FILESETUP;\n\t\t\tfileFormat = _af_identify(f, &implemented);\n\t\t}\n\t}\n\telse if (filesetup == AF_NULL_FILESETUP)\n\t\tfileFormat = _af_identify(f, &implemented);\n\n\tif (fileFormat == AF_FILE_UNKNOWN)\n\t{\n\t\tif (filename != NULL)\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"'%s': unrecognized audio file format\",\n\t\t\t\tfilename);\n\t\telse\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"unrecognized audio file format\");\n\t\treturn AF_FAIL;\n\t}\n\n\tconst char *formatName = _af_units[fileFormat].name;\n\n\tif (!implemented)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\"%s format not currently supported\", formatName);\n\t}\n\n\tcompletesetup = NULL;\n\tif (filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tuserSampleFormat = filesetup->tracks[0].f.sampleFormat;\n\t\tuserPCM = filesetup->tracks[0].f.pcm;\n\t\tuserSampleRate = filesetup->tracks[0].f.sampleRate;\n\t\tuserFormatSet = true;\n\t\tif ((completesetup = _af_units[fileFormat].completesetup(filesetup)) == NULL)\n\t\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle = _AFfilehandle::create(fileFormat);\n\tif (!filehandle)\n\t{\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle->m_fh = f;\n\tfilehandle->m_access = access;\n\tfilehandle->m_seekok = f->canSeek();\n\tif (filename != NULL)\n\t\tfilehandle->m_fileName = strdup(filename);\n\telse\n\t\tfilehandle->m_fileName = NULL;\n\tfilehandle->m_fileFormat = fileFormat;\n\n\tstatus result = access == _AF_READ_ACCESS ?\n\t\tfilehandle->readInit(completesetup) :\n\t\tfilehandle->writeInit(completesetup);\n\n\tif (result != AF_SUCCEED)\n\t{\n\t\tdelete filehandle;\n\t\tfilehandle = AF_NULL_FILEHANDLE;\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tif (completesetup)\n\t\tafFreeFileSetup(completesetup);\n\n\t/*\n\t\tInitialize virtual format.\n\t*/\n\tfor (int t=0; t<filehandle->m_trackCount; t++)\n\t{\n\t\tTrack *track = &filehandle->m_tracks[t];\n\n\t\ttrack->v = track->f;\n\n\t\tif (userFormatSet)\n\t\t{\n\t\t\ttrack->v.sampleFormat = userSampleFormat;\n\t\t\ttrack->v.pcm = userPCM;\n\t\t\ttrack->v.sampleRate = userSampleRate;\n\t\t}\n\n\t\ttrack->v.compressionType = AF_COMPRESSION_NONE;\n\t\ttrack->v.compressionParams = NULL;\n\n#if WORDS_BIGENDIAN\n\t\ttrack->v.byteOrder = AF_BYTEORDER_BIGENDIAN;\n#else\n\t\ttrack->v.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n#endif\n\n\t\ttrack->ms = new ModuleState();\n\t\tif (track->ms->init(filehandle, track) == AF_FAIL)\n\t\t{\n\t\t\tdelete filehandle;\n\t\t\treturn AF_FAIL;\n\t\t}\n\t}\n\n\t*file = filehandle;\n\n\treturn AF_SUCCEED;\n}"
  },
  {
    "function_name": "afOpenVirtualFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/openclose.cpp",
    "lines": "225-270",
    "snippet": "AFfilehandle afOpenVirtualFile (AFvirtualfile *vf, const char *mode,\n\tAFfilesetup setup)\n{\n\tif (!vf)\n\t{\n\t\t_af_error(AF_BAD_OPEN, \"null virtual file\");\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tif (!mode)\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"null access mode\");\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tint access;\n\tif (mode[0] == 'r')\n\t{\n\t\taccess = _AF_READ_ACCESS;\n\t}\n\telse if (mode[0] == 'w')\n\t{\n\t\taccess = _AF_WRITE_ACCESS;\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"unrecognized access mode '%s'\", mode);\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tFile *f = File::create(vf,\n\t\taccess == _AF_READ_ACCESS ? File::ReadAccess : File::WriteAccess);\n\tif (!f)\n\t{\n\t\t_af_error(AF_BAD_OPEN, \"could not open virtual file\");\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tAFfilehandle filehandle;\n\tif (_afOpenFile(access, f, NULL, &filehandle, setup) != AF_SUCCEED)\n\t{\n\t\tdelete f;\n\t}\n\n\treturn filehandle;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"modules/ModuleState.h\"",
      "#include \"modules/Module.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include <audiofile.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <assert.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_afOpenFile",
          "args": [
            "access",
            "f",
            "NULL",
            "&filehandle",
            "setup"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "_afOpenFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/openclose.cpp",
          "lines": "272-406",
          "snippet": "static status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup)\n{\n\tint\tfileFormat = AF_FILE_UNKNOWN;\n\tint\timplemented = true;\n\n\tint\t\tuserSampleFormat = 0;\n\tdouble\t\tuserSampleRate = 0.0;\n\tPCMInfo\tuserPCM = {0};\n\tbool\t\tuserFormatSet = false;\n\n\tAFfilehandle\tfilehandle = AF_NULL_FILEHANDLE;\n\tAFfilesetup\tcompletesetup = AF_NULL_FILESETUP;\n\n\t*file = AF_NULL_FILEHANDLE;\n\n\tif (access == _AF_WRITE_ACCESS || filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tif (!_af_filesetup_ok(filesetup))\n\t\t\treturn AF_FAIL;\n\n\t\tfileFormat = filesetup->fileFormat;\n\t\tif (access == _AF_READ_ACCESS && fileFormat != AF_FILE_RAWDATA)\n\t\t{\n\t\t\t_af_error(AF_BAD_FILESETUP,\n\t\t\t\t\"warning: opening file for read access: \"\n\t\t\t\t\"ignoring file setup with non-raw file format\");\n\t\t\tfilesetup = AF_NULL_FILESETUP;\n\t\t\tfileFormat = _af_identify(f, &implemented);\n\t\t}\n\t}\n\telse if (filesetup == AF_NULL_FILESETUP)\n\t\tfileFormat = _af_identify(f, &implemented);\n\n\tif (fileFormat == AF_FILE_UNKNOWN)\n\t{\n\t\tif (filename != NULL)\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"'%s': unrecognized audio file format\",\n\t\t\t\tfilename);\n\t\telse\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"unrecognized audio file format\");\n\t\treturn AF_FAIL;\n\t}\n\n\tconst char *formatName = _af_units[fileFormat].name;\n\n\tif (!implemented)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\"%s format not currently supported\", formatName);\n\t}\n\n\tcompletesetup = NULL;\n\tif (filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tuserSampleFormat = filesetup->tracks[0].f.sampleFormat;\n\t\tuserPCM = filesetup->tracks[0].f.pcm;\n\t\tuserSampleRate = filesetup->tracks[0].f.sampleRate;\n\t\tuserFormatSet = true;\n\t\tif ((completesetup = _af_units[fileFormat].completesetup(filesetup)) == NULL)\n\t\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle = _AFfilehandle::create(fileFormat);\n\tif (!filehandle)\n\t{\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle->m_fh = f;\n\tfilehandle->m_access = access;\n\tfilehandle->m_seekok = f->canSeek();\n\tif (filename != NULL)\n\t\tfilehandle->m_fileName = strdup(filename);\n\telse\n\t\tfilehandle->m_fileName = NULL;\n\tfilehandle->m_fileFormat = fileFormat;\n\n\tstatus result = access == _AF_READ_ACCESS ?\n\t\tfilehandle->readInit(completesetup) :\n\t\tfilehandle->writeInit(completesetup);\n\n\tif (result != AF_SUCCEED)\n\t{\n\t\tdelete filehandle;\n\t\tfilehandle = AF_NULL_FILEHANDLE;\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tif (completesetup)\n\t\tafFreeFileSetup(completesetup);\n\n\t/*\n\t\tInitialize virtual format.\n\t*/\n\tfor (int t=0; t<filehandle->m_trackCount; t++)\n\t{\n\t\tTrack *track = &filehandle->m_tracks[t];\n\n\t\ttrack->v = track->f;\n\n\t\tif (userFormatSet)\n\t\t{\n\t\t\ttrack->v.sampleFormat = userSampleFormat;\n\t\t\ttrack->v.pcm = userPCM;\n\t\t\ttrack->v.sampleRate = userSampleRate;\n\t\t}\n\n\t\ttrack->v.compressionType = AF_COMPRESSION_NONE;\n\t\ttrack->v.compressionParams = NULL;\n\n#if WORDS_BIGENDIAN\n\t\ttrack->v.byteOrder = AF_BYTEORDER_BIGENDIAN;\n#else\n\t\ttrack->v.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n#endif\n\n\t\ttrack->ms = new ModuleState();\n\t\tif (track->ms->init(filehandle, track) == AF_FAIL)\n\t\t{\n\t\t\tdelete filehandle;\n\t\t\treturn AF_FAIL;\n\t\t}\n\t}\n\n\t*file = filehandle;\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"modules/ModuleState.h\"",
            "#include \"modules/Module.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include <audiofile.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <audiofile.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nstatic status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup);\n\nstatic status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup)\n{\n\tint\tfileFormat = AF_FILE_UNKNOWN;\n\tint\timplemented = true;\n\n\tint\t\tuserSampleFormat = 0;\n\tdouble\t\tuserSampleRate = 0.0;\n\tPCMInfo\tuserPCM = {0};\n\tbool\t\tuserFormatSet = false;\n\n\tAFfilehandle\tfilehandle = AF_NULL_FILEHANDLE;\n\tAFfilesetup\tcompletesetup = AF_NULL_FILESETUP;\n\n\t*file = AF_NULL_FILEHANDLE;\n\n\tif (access == _AF_WRITE_ACCESS || filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tif (!_af_filesetup_ok(filesetup))\n\t\t\treturn AF_FAIL;\n\n\t\tfileFormat = filesetup->fileFormat;\n\t\tif (access == _AF_READ_ACCESS && fileFormat != AF_FILE_RAWDATA)\n\t\t{\n\t\t\t_af_error(AF_BAD_FILESETUP,\n\t\t\t\t\"warning: opening file for read access: \"\n\t\t\t\t\"ignoring file setup with non-raw file format\");\n\t\t\tfilesetup = AF_NULL_FILESETUP;\n\t\t\tfileFormat = _af_identify(f, &implemented);\n\t\t}\n\t}\n\telse if (filesetup == AF_NULL_FILESETUP)\n\t\tfileFormat = _af_identify(f, &implemented);\n\n\tif (fileFormat == AF_FILE_UNKNOWN)\n\t{\n\t\tif (filename != NULL)\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"'%s': unrecognized audio file format\",\n\t\t\t\tfilename);\n\t\telse\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"unrecognized audio file format\");\n\t\treturn AF_FAIL;\n\t}\n\n\tconst char *formatName = _af_units[fileFormat].name;\n\n\tif (!implemented)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\"%s format not currently supported\", formatName);\n\t}\n\n\tcompletesetup = NULL;\n\tif (filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tuserSampleFormat = filesetup->tracks[0].f.sampleFormat;\n\t\tuserPCM = filesetup->tracks[0].f.pcm;\n\t\tuserSampleRate = filesetup->tracks[0].f.sampleRate;\n\t\tuserFormatSet = true;\n\t\tif ((completesetup = _af_units[fileFormat].completesetup(filesetup)) == NULL)\n\t\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle = _AFfilehandle::create(fileFormat);\n\tif (!filehandle)\n\t{\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle->m_fh = f;\n\tfilehandle->m_access = access;\n\tfilehandle->m_seekok = f->canSeek();\n\tif (filename != NULL)\n\t\tfilehandle->m_fileName = strdup(filename);\n\telse\n\t\tfilehandle->m_fileName = NULL;\n\tfilehandle->m_fileFormat = fileFormat;\n\n\tstatus result = access == _AF_READ_ACCESS ?\n\t\tfilehandle->readInit(completesetup) :\n\t\tfilehandle->writeInit(completesetup);\n\n\tif (result != AF_SUCCEED)\n\t{\n\t\tdelete filehandle;\n\t\tfilehandle = AF_NULL_FILEHANDLE;\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tif (completesetup)\n\t\tafFreeFileSetup(completesetup);\n\n\t/*\n\t\tInitialize virtual format.\n\t*/\n\tfor (int t=0; t<filehandle->m_trackCount; t++)\n\t{\n\t\tTrack *track = &filehandle->m_tracks[t];\n\n\t\ttrack->v = track->f;\n\n\t\tif (userFormatSet)\n\t\t{\n\t\t\ttrack->v.sampleFormat = userSampleFormat;\n\t\t\ttrack->v.pcm = userPCM;\n\t\t\ttrack->v.sampleRate = userSampleRate;\n\t\t}\n\n\t\ttrack->v.compressionType = AF_COMPRESSION_NONE;\n\t\ttrack->v.compressionParams = NULL;\n\n#if WORDS_BIGENDIAN\n\t\ttrack->v.byteOrder = AF_BYTEORDER_BIGENDIAN;\n#else\n\t\ttrack->v.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n#endif\n\n\t\ttrack->ms = new ModuleState();\n\t\tif (track->ms->init(filehandle, track) == AF_FAIL)\n\t\t{\n\t\t\tdelete filehandle;\n\t\t\treturn AF_FAIL;\n\t\t}\n\t}\n\n\t*file = filehandle;\n\n\treturn AF_SUCCEED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_OPEN",
            "\"could not open virtual file\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "File::create",
          "args": [
            "vf",
            "access == _AF_READ_ACCESS ? File::ReadAccess : File::WriteAccess"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_ACCMODE",
            "\"unrecognized access mode '%s'\"",
            "mode"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_ACCMODE",
            "\"null access mode\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_OPEN",
            "\"null virtual file\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <audiofile.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nAFfilehandle afOpenVirtualFile (AFvirtualfile *vf, const char *mode,\n\tAFfilesetup setup)\n{\n\tif (!vf)\n\t{\n\t\t_af_error(AF_BAD_OPEN, \"null virtual file\");\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tif (!mode)\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"null access mode\");\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tint access;\n\tif (mode[0] == 'r')\n\t{\n\t\taccess = _AF_READ_ACCESS;\n\t}\n\telse if (mode[0] == 'w')\n\t{\n\t\taccess = _AF_WRITE_ACCESS;\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"unrecognized access mode '%s'\", mode);\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tFile *f = File::create(vf,\n\t\taccess == _AF_READ_ACCESS ? File::ReadAccess : File::WriteAccess);\n\tif (!f)\n\t{\n\t\t_af_error(AF_BAD_OPEN, \"could not open virtual file\");\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tAFfilehandle filehandle;\n\tif (_afOpenFile(access, f, NULL, &filehandle, setup) != AF_SUCCEED)\n\t{\n\t\tdelete f;\n\t}\n\n\treturn filehandle;\n}"
  },
  {
    "function_name": "afOpenFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/openclose.cpp",
    "lines": "185-223",
    "snippet": "AFfilehandle afOpenFile (const char *filename, const char *mode, AFfilesetup setup)\n{\n\tif (!mode)\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"null access mode\");\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tint access;\n\tif (mode[0] == 'r')\n\t{\n\t\taccess = _AF_READ_ACCESS;\n\t}\n\telse if (mode[0] == 'w')\n\t{\n\t\taccess = _AF_WRITE_ACCESS;\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"unrecognized access mode '%s'\", mode);\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tFile *f = File::open(filename,\n\t\taccess == _AF_READ_ACCESS ? File::ReadAccess : File::WriteAccess);\n\tif (!f)\n\t{\n\t\t_af_error(AF_BAD_OPEN, \"could not open file '%s'\", filename);\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tAFfilehandle filehandle;\n\tif (_afOpenFile(access, f, filename, &filehandle, setup) != AF_SUCCEED)\n\t{\n\t\tdelete f;\n\t}\n\n\treturn filehandle;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"modules/ModuleState.h\"",
      "#include \"modules/Module.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include <audiofile.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <assert.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_afOpenFile",
          "args": [
            "access",
            "f",
            "filename",
            "&filehandle",
            "setup"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "_afOpenFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/openclose.cpp",
          "lines": "272-406",
          "snippet": "static status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup)\n{\n\tint\tfileFormat = AF_FILE_UNKNOWN;\n\tint\timplemented = true;\n\n\tint\t\tuserSampleFormat = 0;\n\tdouble\t\tuserSampleRate = 0.0;\n\tPCMInfo\tuserPCM = {0};\n\tbool\t\tuserFormatSet = false;\n\n\tAFfilehandle\tfilehandle = AF_NULL_FILEHANDLE;\n\tAFfilesetup\tcompletesetup = AF_NULL_FILESETUP;\n\n\t*file = AF_NULL_FILEHANDLE;\n\n\tif (access == _AF_WRITE_ACCESS || filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tif (!_af_filesetup_ok(filesetup))\n\t\t\treturn AF_FAIL;\n\n\t\tfileFormat = filesetup->fileFormat;\n\t\tif (access == _AF_READ_ACCESS && fileFormat != AF_FILE_RAWDATA)\n\t\t{\n\t\t\t_af_error(AF_BAD_FILESETUP,\n\t\t\t\t\"warning: opening file for read access: \"\n\t\t\t\t\"ignoring file setup with non-raw file format\");\n\t\t\tfilesetup = AF_NULL_FILESETUP;\n\t\t\tfileFormat = _af_identify(f, &implemented);\n\t\t}\n\t}\n\telse if (filesetup == AF_NULL_FILESETUP)\n\t\tfileFormat = _af_identify(f, &implemented);\n\n\tif (fileFormat == AF_FILE_UNKNOWN)\n\t{\n\t\tif (filename != NULL)\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"'%s': unrecognized audio file format\",\n\t\t\t\tfilename);\n\t\telse\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"unrecognized audio file format\");\n\t\treturn AF_FAIL;\n\t}\n\n\tconst char *formatName = _af_units[fileFormat].name;\n\n\tif (!implemented)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\"%s format not currently supported\", formatName);\n\t}\n\n\tcompletesetup = NULL;\n\tif (filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tuserSampleFormat = filesetup->tracks[0].f.sampleFormat;\n\t\tuserPCM = filesetup->tracks[0].f.pcm;\n\t\tuserSampleRate = filesetup->tracks[0].f.sampleRate;\n\t\tuserFormatSet = true;\n\t\tif ((completesetup = _af_units[fileFormat].completesetup(filesetup)) == NULL)\n\t\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle = _AFfilehandle::create(fileFormat);\n\tif (!filehandle)\n\t{\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle->m_fh = f;\n\tfilehandle->m_access = access;\n\tfilehandle->m_seekok = f->canSeek();\n\tif (filename != NULL)\n\t\tfilehandle->m_fileName = strdup(filename);\n\telse\n\t\tfilehandle->m_fileName = NULL;\n\tfilehandle->m_fileFormat = fileFormat;\n\n\tstatus result = access == _AF_READ_ACCESS ?\n\t\tfilehandle->readInit(completesetup) :\n\t\tfilehandle->writeInit(completesetup);\n\n\tif (result != AF_SUCCEED)\n\t{\n\t\tdelete filehandle;\n\t\tfilehandle = AF_NULL_FILEHANDLE;\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tif (completesetup)\n\t\tafFreeFileSetup(completesetup);\n\n\t/*\n\t\tInitialize virtual format.\n\t*/\n\tfor (int t=0; t<filehandle->m_trackCount; t++)\n\t{\n\t\tTrack *track = &filehandle->m_tracks[t];\n\n\t\ttrack->v = track->f;\n\n\t\tif (userFormatSet)\n\t\t{\n\t\t\ttrack->v.sampleFormat = userSampleFormat;\n\t\t\ttrack->v.pcm = userPCM;\n\t\t\ttrack->v.sampleRate = userSampleRate;\n\t\t}\n\n\t\ttrack->v.compressionType = AF_COMPRESSION_NONE;\n\t\ttrack->v.compressionParams = NULL;\n\n#if WORDS_BIGENDIAN\n\t\ttrack->v.byteOrder = AF_BYTEORDER_BIGENDIAN;\n#else\n\t\ttrack->v.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n#endif\n\n\t\ttrack->ms = new ModuleState();\n\t\tif (track->ms->init(filehandle, track) == AF_FAIL)\n\t\t{\n\t\t\tdelete filehandle;\n\t\t\treturn AF_FAIL;\n\t\t}\n\t}\n\n\t*file = filehandle;\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"modules/ModuleState.h\"",
            "#include \"modules/Module.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include <audiofile.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <audiofile.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nstatic status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup);\n\nstatic status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup)\n{\n\tint\tfileFormat = AF_FILE_UNKNOWN;\n\tint\timplemented = true;\n\n\tint\t\tuserSampleFormat = 0;\n\tdouble\t\tuserSampleRate = 0.0;\n\tPCMInfo\tuserPCM = {0};\n\tbool\t\tuserFormatSet = false;\n\n\tAFfilehandle\tfilehandle = AF_NULL_FILEHANDLE;\n\tAFfilesetup\tcompletesetup = AF_NULL_FILESETUP;\n\n\t*file = AF_NULL_FILEHANDLE;\n\n\tif (access == _AF_WRITE_ACCESS || filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tif (!_af_filesetup_ok(filesetup))\n\t\t\treturn AF_FAIL;\n\n\t\tfileFormat = filesetup->fileFormat;\n\t\tif (access == _AF_READ_ACCESS && fileFormat != AF_FILE_RAWDATA)\n\t\t{\n\t\t\t_af_error(AF_BAD_FILESETUP,\n\t\t\t\t\"warning: opening file for read access: \"\n\t\t\t\t\"ignoring file setup with non-raw file format\");\n\t\t\tfilesetup = AF_NULL_FILESETUP;\n\t\t\tfileFormat = _af_identify(f, &implemented);\n\t\t}\n\t}\n\telse if (filesetup == AF_NULL_FILESETUP)\n\t\tfileFormat = _af_identify(f, &implemented);\n\n\tif (fileFormat == AF_FILE_UNKNOWN)\n\t{\n\t\tif (filename != NULL)\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"'%s': unrecognized audio file format\",\n\t\t\t\tfilename);\n\t\telse\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"unrecognized audio file format\");\n\t\treturn AF_FAIL;\n\t}\n\n\tconst char *formatName = _af_units[fileFormat].name;\n\n\tif (!implemented)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\"%s format not currently supported\", formatName);\n\t}\n\n\tcompletesetup = NULL;\n\tif (filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tuserSampleFormat = filesetup->tracks[0].f.sampleFormat;\n\t\tuserPCM = filesetup->tracks[0].f.pcm;\n\t\tuserSampleRate = filesetup->tracks[0].f.sampleRate;\n\t\tuserFormatSet = true;\n\t\tif ((completesetup = _af_units[fileFormat].completesetup(filesetup)) == NULL)\n\t\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle = _AFfilehandle::create(fileFormat);\n\tif (!filehandle)\n\t{\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle->m_fh = f;\n\tfilehandle->m_access = access;\n\tfilehandle->m_seekok = f->canSeek();\n\tif (filename != NULL)\n\t\tfilehandle->m_fileName = strdup(filename);\n\telse\n\t\tfilehandle->m_fileName = NULL;\n\tfilehandle->m_fileFormat = fileFormat;\n\n\tstatus result = access == _AF_READ_ACCESS ?\n\t\tfilehandle->readInit(completesetup) :\n\t\tfilehandle->writeInit(completesetup);\n\n\tif (result != AF_SUCCEED)\n\t{\n\t\tdelete filehandle;\n\t\tfilehandle = AF_NULL_FILEHANDLE;\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tif (completesetup)\n\t\tafFreeFileSetup(completesetup);\n\n\t/*\n\t\tInitialize virtual format.\n\t*/\n\tfor (int t=0; t<filehandle->m_trackCount; t++)\n\t{\n\t\tTrack *track = &filehandle->m_tracks[t];\n\n\t\ttrack->v = track->f;\n\n\t\tif (userFormatSet)\n\t\t{\n\t\t\ttrack->v.sampleFormat = userSampleFormat;\n\t\t\ttrack->v.pcm = userPCM;\n\t\t\ttrack->v.sampleRate = userSampleRate;\n\t\t}\n\n\t\ttrack->v.compressionType = AF_COMPRESSION_NONE;\n\t\ttrack->v.compressionParams = NULL;\n\n#if WORDS_BIGENDIAN\n\t\ttrack->v.byteOrder = AF_BYTEORDER_BIGENDIAN;\n#else\n\t\ttrack->v.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n#endif\n\n\t\ttrack->ms = new ModuleState();\n\t\tif (track->ms->init(filehandle, track) == AF_FAIL)\n\t\t{\n\t\t\tdelete filehandle;\n\t\t\treturn AF_FAIL;\n\t\t}\n\t}\n\n\t*file = filehandle;\n\n\treturn AF_SUCCEED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_OPEN",
            "\"could not open file '%s'\"",
            "filename"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "File::open",
          "args": [
            "filename",
            "access == _AF_READ_ACCESS ? File::ReadAccess : File::WriteAccess"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_ACCMODE",
            "\"unrecognized access mode '%s'\"",
            "mode"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_ACCMODE",
            "\"null access mode\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <audiofile.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nAFfilehandle afOpenFile (const char *filename, const char *mode, AFfilesetup setup)\n{\n\tif (!mode)\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"null access mode\");\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tint access;\n\tif (mode[0] == 'r')\n\t{\n\t\taccess = _AF_READ_ACCESS;\n\t}\n\telse if (mode[0] == 'w')\n\t{\n\t\taccess = _AF_WRITE_ACCESS;\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"unrecognized access mode '%s'\", mode);\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tFile *f = File::open(filename,\n\t\taccess == _AF_READ_ACCESS ? File::ReadAccess : File::WriteAccess);\n\tif (!f)\n\t{\n\t\t_af_error(AF_BAD_OPEN, \"could not open file '%s'\", filename);\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tAFfilehandle filehandle;\n\tif (_afOpenFile(access, f, filename, &filehandle, setup) != AF_SUCCEED)\n\t{\n\t\tdelete f;\n\t}\n\n\treturn filehandle;\n}"
  },
  {
    "function_name": "afOpenNamedFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/openclose.cpp",
    "lines": "153-183",
    "snippet": "AFfilehandle afOpenNamedFD (int fd, const char *mode, AFfilesetup setup,\n\tconst char *filename)\n{\n\tif (!mode)\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"null access mode\");\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tint access;\n\tif (mode[0] == 'r')\n\t\taccess = _AF_READ_ACCESS;\n\telse if (mode[0] == 'w')\n\t\taccess = _AF_WRITE_ACCESS;\n\telse\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"unrecognized access mode '%s'\", mode);\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tFile *f = File::create(fd, access == _AF_READ_ACCESS ?\n\t\tFile::ReadAccess : File::WriteAccess);\n\n\tAFfilehandle filehandle;\n\tif (_afOpenFile(access, f, filename, &filehandle, setup) != AF_SUCCEED)\n\t{\n\t\tdelete f;\n\t}\n\n\treturn filehandle;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"modules/ModuleState.h\"",
      "#include \"modules/Module.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include <audiofile.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <assert.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_afOpenFile",
          "args": [
            "access",
            "f",
            "filename",
            "&filehandle",
            "setup"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "_afOpenFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/openclose.cpp",
          "lines": "272-406",
          "snippet": "static status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup)\n{\n\tint\tfileFormat = AF_FILE_UNKNOWN;\n\tint\timplemented = true;\n\n\tint\t\tuserSampleFormat = 0;\n\tdouble\t\tuserSampleRate = 0.0;\n\tPCMInfo\tuserPCM = {0};\n\tbool\t\tuserFormatSet = false;\n\n\tAFfilehandle\tfilehandle = AF_NULL_FILEHANDLE;\n\tAFfilesetup\tcompletesetup = AF_NULL_FILESETUP;\n\n\t*file = AF_NULL_FILEHANDLE;\n\n\tif (access == _AF_WRITE_ACCESS || filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tif (!_af_filesetup_ok(filesetup))\n\t\t\treturn AF_FAIL;\n\n\t\tfileFormat = filesetup->fileFormat;\n\t\tif (access == _AF_READ_ACCESS && fileFormat != AF_FILE_RAWDATA)\n\t\t{\n\t\t\t_af_error(AF_BAD_FILESETUP,\n\t\t\t\t\"warning: opening file for read access: \"\n\t\t\t\t\"ignoring file setup with non-raw file format\");\n\t\t\tfilesetup = AF_NULL_FILESETUP;\n\t\t\tfileFormat = _af_identify(f, &implemented);\n\t\t}\n\t}\n\telse if (filesetup == AF_NULL_FILESETUP)\n\t\tfileFormat = _af_identify(f, &implemented);\n\n\tif (fileFormat == AF_FILE_UNKNOWN)\n\t{\n\t\tif (filename != NULL)\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"'%s': unrecognized audio file format\",\n\t\t\t\tfilename);\n\t\telse\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"unrecognized audio file format\");\n\t\treturn AF_FAIL;\n\t}\n\n\tconst char *formatName = _af_units[fileFormat].name;\n\n\tif (!implemented)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\"%s format not currently supported\", formatName);\n\t}\n\n\tcompletesetup = NULL;\n\tif (filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tuserSampleFormat = filesetup->tracks[0].f.sampleFormat;\n\t\tuserPCM = filesetup->tracks[0].f.pcm;\n\t\tuserSampleRate = filesetup->tracks[0].f.sampleRate;\n\t\tuserFormatSet = true;\n\t\tif ((completesetup = _af_units[fileFormat].completesetup(filesetup)) == NULL)\n\t\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle = _AFfilehandle::create(fileFormat);\n\tif (!filehandle)\n\t{\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle->m_fh = f;\n\tfilehandle->m_access = access;\n\tfilehandle->m_seekok = f->canSeek();\n\tif (filename != NULL)\n\t\tfilehandle->m_fileName = strdup(filename);\n\telse\n\t\tfilehandle->m_fileName = NULL;\n\tfilehandle->m_fileFormat = fileFormat;\n\n\tstatus result = access == _AF_READ_ACCESS ?\n\t\tfilehandle->readInit(completesetup) :\n\t\tfilehandle->writeInit(completesetup);\n\n\tif (result != AF_SUCCEED)\n\t{\n\t\tdelete filehandle;\n\t\tfilehandle = AF_NULL_FILEHANDLE;\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tif (completesetup)\n\t\tafFreeFileSetup(completesetup);\n\n\t/*\n\t\tInitialize virtual format.\n\t*/\n\tfor (int t=0; t<filehandle->m_trackCount; t++)\n\t{\n\t\tTrack *track = &filehandle->m_tracks[t];\n\n\t\ttrack->v = track->f;\n\n\t\tif (userFormatSet)\n\t\t{\n\t\t\ttrack->v.sampleFormat = userSampleFormat;\n\t\t\ttrack->v.pcm = userPCM;\n\t\t\ttrack->v.sampleRate = userSampleRate;\n\t\t}\n\n\t\ttrack->v.compressionType = AF_COMPRESSION_NONE;\n\t\ttrack->v.compressionParams = NULL;\n\n#if WORDS_BIGENDIAN\n\t\ttrack->v.byteOrder = AF_BYTEORDER_BIGENDIAN;\n#else\n\t\ttrack->v.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n#endif\n\n\t\ttrack->ms = new ModuleState();\n\t\tif (track->ms->init(filehandle, track) == AF_FAIL)\n\t\t{\n\t\t\tdelete filehandle;\n\t\t\treturn AF_FAIL;\n\t\t}\n\t}\n\n\t*file = filehandle;\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"modules/ModuleState.h\"",
            "#include \"modules/Module.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include <audiofile.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <audiofile.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nstatic status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup);\n\nstatic status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup)\n{\n\tint\tfileFormat = AF_FILE_UNKNOWN;\n\tint\timplemented = true;\n\n\tint\t\tuserSampleFormat = 0;\n\tdouble\t\tuserSampleRate = 0.0;\n\tPCMInfo\tuserPCM = {0};\n\tbool\t\tuserFormatSet = false;\n\n\tAFfilehandle\tfilehandle = AF_NULL_FILEHANDLE;\n\tAFfilesetup\tcompletesetup = AF_NULL_FILESETUP;\n\n\t*file = AF_NULL_FILEHANDLE;\n\n\tif (access == _AF_WRITE_ACCESS || filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tif (!_af_filesetup_ok(filesetup))\n\t\t\treturn AF_FAIL;\n\n\t\tfileFormat = filesetup->fileFormat;\n\t\tif (access == _AF_READ_ACCESS && fileFormat != AF_FILE_RAWDATA)\n\t\t{\n\t\t\t_af_error(AF_BAD_FILESETUP,\n\t\t\t\t\"warning: opening file for read access: \"\n\t\t\t\t\"ignoring file setup with non-raw file format\");\n\t\t\tfilesetup = AF_NULL_FILESETUP;\n\t\t\tfileFormat = _af_identify(f, &implemented);\n\t\t}\n\t}\n\telse if (filesetup == AF_NULL_FILESETUP)\n\t\tfileFormat = _af_identify(f, &implemented);\n\n\tif (fileFormat == AF_FILE_UNKNOWN)\n\t{\n\t\tif (filename != NULL)\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"'%s': unrecognized audio file format\",\n\t\t\t\tfilename);\n\t\telse\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"unrecognized audio file format\");\n\t\treturn AF_FAIL;\n\t}\n\n\tconst char *formatName = _af_units[fileFormat].name;\n\n\tif (!implemented)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\"%s format not currently supported\", formatName);\n\t}\n\n\tcompletesetup = NULL;\n\tif (filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tuserSampleFormat = filesetup->tracks[0].f.sampleFormat;\n\t\tuserPCM = filesetup->tracks[0].f.pcm;\n\t\tuserSampleRate = filesetup->tracks[0].f.sampleRate;\n\t\tuserFormatSet = true;\n\t\tif ((completesetup = _af_units[fileFormat].completesetup(filesetup)) == NULL)\n\t\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle = _AFfilehandle::create(fileFormat);\n\tif (!filehandle)\n\t{\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle->m_fh = f;\n\tfilehandle->m_access = access;\n\tfilehandle->m_seekok = f->canSeek();\n\tif (filename != NULL)\n\t\tfilehandle->m_fileName = strdup(filename);\n\telse\n\t\tfilehandle->m_fileName = NULL;\n\tfilehandle->m_fileFormat = fileFormat;\n\n\tstatus result = access == _AF_READ_ACCESS ?\n\t\tfilehandle->readInit(completesetup) :\n\t\tfilehandle->writeInit(completesetup);\n\n\tif (result != AF_SUCCEED)\n\t{\n\t\tdelete filehandle;\n\t\tfilehandle = AF_NULL_FILEHANDLE;\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tif (completesetup)\n\t\tafFreeFileSetup(completesetup);\n\n\t/*\n\t\tInitialize virtual format.\n\t*/\n\tfor (int t=0; t<filehandle->m_trackCount; t++)\n\t{\n\t\tTrack *track = &filehandle->m_tracks[t];\n\n\t\ttrack->v = track->f;\n\n\t\tif (userFormatSet)\n\t\t{\n\t\t\ttrack->v.sampleFormat = userSampleFormat;\n\t\t\ttrack->v.pcm = userPCM;\n\t\t\ttrack->v.sampleRate = userSampleRate;\n\t\t}\n\n\t\ttrack->v.compressionType = AF_COMPRESSION_NONE;\n\t\ttrack->v.compressionParams = NULL;\n\n#if WORDS_BIGENDIAN\n\t\ttrack->v.byteOrder = AF_BYTEORDER_BIGENDIAN;\n#else\n\t\ttrack->v.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n#endif\n\n\t\ttrack->ms = new ModuleState();\n\t\tif (track->ms->init(filehandle, track) == AF_FAIL)\n\t\t{\n\t\t\tdelete filehandle;\n\t\t\treturn AF_FAIL;\n\t\t}\n\t}\n\n\t*file = filehandle;\n\n\treturn AF_SUCCEED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "File::create",
          "args": [
            "fd",
            "access == _AF_READ_ACCESS ?\n\t\tFile::ReadAccess : File::WriteAccess"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_ACCMODE",
            "\"unrecognized access mode '%s'\"",
            "mode"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_ACCMODE",
            "\"null access mode\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <audiofile.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nAFfilehandle afOpenNamedFD (int fd, const char *mode, AFfilesetup setup,\n\tconst char *filename)\n{\n\tif (!mode)\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"null access mode\");\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tint access;\n\tif (mode[0] == 'r')\n\t\taccess = _AF_READ_ACCESS;\n\telse if (mode[0] == 'w')\n\t\taccess = _AF_WRITE_ACCESS;\n\telse\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"unrecognized access mode '%s'\", mode);\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tFile *f = File::create(fd, access == _AF_READ_ACCESS ?\n\t\tFile::ReadAccess : File::WriteAccess);\n\n\tAFfilehandle filehandle;\n\tif (_afOpenFile(access, f, filename, &filehandle, setup) != AF_SUCCEED)\n\t{\n\t\tdelete f;\n\t}\n\n\treturn filehandle;\n}"
  },
  {
    "function_name": "afOpenFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/openclose.cpp",
    "lines": "118-151",
    "snippet": "AFfilehandle afOpenFD (int fd, const char *mode, AFfilesetup setup)\n{\n\tif (!mode)\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"null access mode\");\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tint access;\n\tif (mode[0] == 'r')\n\t{\n\t\taccess = _AF_READ_ACCESS;\n\t}\n\telse if (mode[0] == 'w')\n\t{\n\t\taccess = _AF_WRITE_ACCESS;\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"unrecognized access mode '%s'\", mode);\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tFile *f = File::create(fd, access == _AF_READ_ACCESS ?\n\t\tFile::ReadAccess : File::WriteAccess);\n\n\tAFfilehandle filehandle = NULL;\n\tif (_afOpenFile(access, f, NULL, &filehandle, setup) != AF_SUCCEED)\n\t{\n\t\tdelete f;\n\t}\n\n\treturn filehandle;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"modules/ModuleState.h\"",
      "#include \"modules/Module.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include <audiofile.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <assert.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_afOpenFile",
          "args": [
            "access",
            "f",
            "NULL",
            "&filehandle",
            "setup"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "_afOpenFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/openclose.cpp",
          "lines": "272-406",
          "snippet": "static status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup)\n{\n\tint\tfileFormat = AF_FILE_UNKNOWN;\n\tint\timplemented = true;\n\n\tint\t\tuserSampleFormat = 0;\n\tdouble\t\tuserSampleRate = 0.0;\n\tPCMInfo\tuserPCM = {0};\n\tbool\t\tuserFormatSet = false;\n\n\tAFfilehandle\tfilehandle = AF_NULL_FILEHANDLE;\n\tAFfilesetup\tcompletesetup = AF_NULL_FILESETUP;\n\n\t*file = AF_NULL_FILEHANDLE;\n\n\tif (access == _AF_WRITE_ACCESS || filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tif (!_af_filesetup_ok(filesetup))\n\t\t\treturn AF_FAIL;\n\n\t\tfileFormat = filesetup->fileFormat;\n\t\tif (access == _AF_READ_ACCESS && fileFormat != AF_FILE_RAWDATA)\n\t\t{\n\t\t\t_af_error(AF_BAD_FILESETUP,\n\t\t\t\t\"warning: opening file for read access: \"\n\t\t\t\t\"ignoring file setup with non-raw file format\");\n\t\t\tfilesetup = AF_NULL_FILESETUP;\n\t\t\tfileFormat = _af_identify(f, &implemented);\n\t\t}\n\t}\n\telse if (filesetup == AF_NULL_FILESETUP)\n\t\tfileFormat = _af_identify(f, &implemented);\n\n\tif (fileFormat == AF_FILE_UNKNOWN)\n\t{\n\t\tif (filename != NULL)\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"'%s': unrecognized audio file format\",\n\t\t\t\tfilename);\n\t\telse\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"unrecognized audio file format\");\n\t\treturn AF_FAIL;\n\t}\n\n\tconst char *formatName = _af_units[fileFormat].name;\n\n\tif (!implemented)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\"%s format not currently supported\", formatName);\n\t}\n\n\tcompletesetup = NULL;\n\tif (filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tuserSampleFormat = filesetup->tracks[0].f.sampleFormat;\n\t\tuserPCM = filesetup->tracks[0].f.pcm;\n\t\tuserSampleRate = filesetup->tracks[0].f.sampleRate;\n\t\tuserFormatSet = true;\n\t\tif ((completesetup = _af_units[fileFormat].completesetup(filesetup)) == NULL)\n\t\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle = _AFfilehandle::create(fileFormat);\n\tif (!filehandle)\n\t{\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle->m_fh = f;\n\tfilehandle->m_access = access;\n\tfilehandle->m_seekok = f->canSeek();\n\tif (filename != NULL)\n\t\tfilehandle->m_fileName = strdup(filename);\n\telse\n\t\tfilehandle->m_fileName = NULL;\n\tfilehandle->m_fileFormat = fileFormat;\n\n\tstatus result = access == _AF_READ_ACCESS ?\n\t\tfilehandle->readInit(completesetup) :\n\t\tfilehandle->writeInit(completesetup);\n\n\tif (result != AF_SUCCEED)\n\t{\n\t\tdelete filehandle;\n\t\tfilehandle = AF_NULL_FILEHANDLE;\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tif (completesetup)\n\t\tafFreeFileSetup(completesetup);\n\n\t/*\n\t\tInitialize virtual format.\n\t*/\n\tfor (int t=0; t<filehandle->m_trackCount; t++)\n\t{\n\t\tTrack *track = &filehandle->m_tracks[t];\n\n\t\ttrack->v = track->f;\n\n\t\tif (userFormatSet)\n\t\t{\n\t\t\ttrack->v.sampleFormat = userSampleFormat;\n\t\t\ttrack->v.pcm = userPCM;\n\t\t\ttrack->v.sampleRate = userSampleRate;\n\t\t}\n\n\t\ttrack->v.compressionType = AF_COMPRESSION_NONE;\n\t\ttrack->v.compressionParams = NULL;\n\n#if WORDS_BIGENDIAN\n\t\ttrack->v.byteOrder = AF_BYTEORDER_BIGENDIAN;\n#else\n\t\ttrack->v.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n#endif\n\n\t\ttrack->ms = new ModuleState();\n\t\tif (track->ms->init(filehandle, track) == AF_FAIL)\n\t\t{\n\t\t\tdelete filehandle;\n\t\t\treturn AF_FAIL;\n\t\t}\n\t}\n\n\t*file = filehandle;\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"modules/ModuleState.h\"",
            "#include \"modules/Module.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include <audiofile.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <audiofile.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nstatic status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup);\n\nstatic status _afOpenFile (int access, File *f, const char *filename,\n\tAFfilehandle *file, AFfilesetup filesetup)\n{\n\tint\tfileFormat = AF_FILE_UNKNOWN;\n\tint\timplemented = true;\n\n\tint\t\tuserSampleFormat = 0;\n\tdouble\t\tuserSampleRate = 0.0;\n\tPCMInfo\tuserPCM = {0};\n\tbool\t\tuserFormatSet = false;\n\n\tAFfilehandle\tfilehandle = AF_NULL_FILEHANDLE;\n\tAFfilesetup\tcompletesetup = AF_NULL_FILESETUP;\n\n\t*file = AF_NULL_FILEHANDLE;\n\n\tif (access == _AF_WRITE_ACCESS || filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tif (!_af_filesetup_ok(filesetup))\n\t\t\treturn AF_FAIL;\n\n\t\tfileFormat = filesetup->fileFormat;\n\t\tif (access == _AF_READ_ACCESS && fileFormat != AF_FILE_RAWDATA)\n\t\t{\n\t\t\t_af_error(AF_BAD_FILESETUP,\n\t\t\t\t\"warning: opening file for read access: \"\n\t\t\t\t\"ignoring file setup with non-raw file format\");\n\t\t\tfilesetup = AF_NULL_FILESETUP;\n\t\t\tfileFormat = _af_identify(f, &implemented);\n\t\t}\n\t}\n\telse if (filesetup == AF_NULL_FILESETUP)\n\t\tfileFormat = _af_identify(f, &implemented);\n\n\tif (fileFormat == AF_FILE_UNKNOWN)\n\t{\n\t\tif (filename != NULL)\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"'%s': unrecognized audio file format\",\n\t\t\t\tfilename);\n\t\telse\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\"unrecognized audio file format\");\n\t\treturn AF_FAIL;\n\t}\n\n\tconst char *formatName = _af_units[fileFormat].name;\n\n\tif (!implemented)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\"%s format not currently supported\", formatName);\n\t}\n\n\tcompletesetup = NULL;\n\tif (filesetup != AF_NULL_FILESETUP)\n\t{\n\t\tuserSampleFormat = filesetup->tracks[0].f.sampleFormat;\n\t\tuserPCM = filesetup->tracks[0].f.pcm;\n\t\tuserSampleRate = filesetup->tracks[0].f.sampleRate;\n\t\tuserFormatSet = true;\n\t\tif ((completesetup = _af_units[fileFormat].completesetup(filesetup)) == NULL)\n\t\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle = _AFfilehandle::create(fileFormat);\n\tif (!filehandle)\n\t{\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tfilehandle->m_fh = f;\n\tfilehandle->m_access = access;\n\tfilehandle->m_seekok = f->canSeek();\n\tif (filename != NULL)\n\t\tfilehandle->m_fileName = strdup(filename);\n\telse\n\t\tfilehandle->m_fileName = NULL;\n\tfilehandle->m_fileFormat = fileFormat;\n\n\tstatus result = access == _AF_READ_ACCESS ?\n\t\tfilehandle->readInit(completesetup) :\n\t\tfilehandle->writeInit(completesetup);\n\n\tif (result != AF_SUCCEED)\n\t{\n\t\tdelete filehandle;\n\t\tfilehandle = AF_NULL_FILEHANDLE;\n\t\tif (completesetup)\n\t\t\tafFreeFileSetup(completesetup);\n\t\treturn AF_FAIL;\n\t}\n\n\tif (completesetup)\n\t\tafFreeFileSetup(completesetup);\n\n\t/*\n\t\tInitialize virtual format.\n\t*/\n\tfor (int t=0; t<filehandle->m_trackCount; t++)\n\t{\n\t\tTrack *track = &filehandle->m_tracks[t];\n\n\t\ttrack->v = track->f;\n\n\t\tif (userFormatSet)\n\t\t{\n\t\t\ttrack->v.sampleFormat = userSampleFormat;\n\t\t\ttrack->v.pcm = userPCM;\n\t\t\ttrack->v.sampleRate = userSampleRate;\n\t\t}\n\n\t\ttrack->v.compressionType = AF_COMPRESSION_NONE;\n\t\ttrack->v.compressionParams = NULL;\n\n#if WORDS_BIGENDIAN\n\t\ttrack->v.byteOrder = AF_BYTEORDER_BIGENDIAN;\n#else\n\t\ttrack->v.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n#endif\n\n\t\ttrack->ms = new ModuleState();\n\t\tif (track->ms->init(filehandle, track) == AF_FAIL)\n\t\t{\n\t\t\tdelete filehandle;\n\t\t\treturn AF_FAIL;\n\t\t}\n\t}\n\n\t*file = filehandle;\n\n\treturn AF_SUCCEED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "File::create",
          "args": [
            "fd",
            "access == _AF_READ_ACCESS ?\n\t\tFile::ReadAccess : File::WriteAccess"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_ACCMODE",
            "\"unrecognized access mode '%s'\"",
            "mode"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_ACCMODE",
            "\"null access mode\""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <audiofile.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nAFfilehandle afOpenFD (int fd, const char *mode, AFfilesetup setup)\n{\n\tif (!mode)\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"null access mode\");\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tint access;\n\tif (mode[0] == 'r')\n\t{\n\t\taccess = _AF_READ_ACCESS;\n\t}\n\telse if (mode[0] == 'w')\n\t{\n\t\taccess = _AF_WRITE_ACCESS;\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"unrecognized access mode '%s'\", mode);\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\n\tFile *f = File::create(fd, access == _AF_READ_ACCESS ?\n\t\tFile::ReadAccess : File::WriteAccess);\n\n\tAFfilehandle filehandle = NULL;\n\tif (_afOpenFile(access, f, NULL, &filehandle, setup) != AF_SUCCEED)\n\t{\n\t\tdelete f;\n\t}\n\n\treturn filehandle;\n}"
  },
  {
    "function_name": "afIdentifyNamedFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/openclose.cpp",
    "lines": "95-116",
    "snippet": "int afIdentifyNamedFD (int fd, const char *filename, int *implemented)\n{\n\t/*\n\t\tDuplicate the file descriptor since otherwise the\n\t\toriginal file descriptor would get closed when we close\n\t\tthe virtual file below.\n\t*/\n\tfd = dup(fd);\n\n\tFile *f = File::create(fd, File::ReadAccess);\n\tif (!f)\n\t{\n\t\t_af_error(AF_BAD_OPEN, \"could not open file '%s'\", filename);\n\t\treturn AF_FILE_UNKNOWN;\n\t}\n\n\tint result = _af_identify(f, implemented);\n\n\tdelete f;\n\n\treturn result;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"modules/ModuleState.h\"",
      "#include \"modules/Module.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include <audiofile.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <assert.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_identify",
          "args": [
            "f",
            "implemented"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "_af_identify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/openclose.cpp",
          "lines": "48-76",
          "snippet": "int _af_identify (File *f, int *implemented)\n{\n\tif (!f->canSeek())\n\t{\n\t\t_af_error(AF_BAD_LSEEK, \"Cannot seek in file\");\n\t\treturn AF_FILE_UNKNOWN;\n\t}\n\n\tAFfileoffset curpos = f->tell();\n\n\tfor (int i=0; i<_AF_NUM_UNITS; i++)\n\t{\n\t\tif (_af_units[i].recognize &&\n\t\t\t_af_units[i].recognize(f))\n\t\t{\n\t\t\tif (implemented != NULL)\n\t\t\t\t*implemented = _af_units[i].implemented;\n\t\t\tf->seek(curpos, File::SeekFromBeginning);\n\t\t\treturn _af_units[i].fileFormat;\n\t\t}\n\t}\n\n\tf->seek(curpos, File::SeekFromBeginning);\n\n\tif (implemented != NULL)\n\t\t*implemented = false;\n\n\treturn AF_FILE_UNKNOWN;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"modules/ModuleState.h\"",
            "#include \"modules/Module.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include <audiofile.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <audiofile.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint _af_identify (File *f, int *implemented)\n{\n\tif (!f->canSeek())\n\t{\n\t\t_af_error(AF_BAD_LSEEK, \"Cannot seek in file\");\n\t\treturn AF_FILE_UNKNOWN;\n\t}\n\n\tAFfileoffset curpos = f->tell();\n\n\tfor (int i=0; i<_AF_NUM_UNITS; i++)\n\t{\n\t\tif (_af_units[i].recognize &&\n\t\t\t_af_units[i].recognize(f))\n\t\t{\n\t\t\tif (implemented != NULL)\n\t\t\t\t*implemented = _af_units[i].implemented;\n\t\t\tf->seek(curpos, File::SeekFromBeginning);\n\t\t\treturn _af_units[i].fileFormat;\n\t\t}\n\t}\n\n\tf->seek(curpos, File::SeekFromBeginning);\n\n\tif (implemented != NULL)\n\t\t*implemented = false;\n\n\treturn AF_FILE_UNKNOWN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_OPEN",
            "\"could not open file '%s'\"",
            "filename"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "File::create",
          "args": [
            "fd",
            "File::ReadAccess"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup",
          "args": [
            "fd"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <audiofile.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint afIdentifyNamedFD (int fd, const char *filename, int *implemented)\n{\n\t/*\n\t\tDuplicate the file descriptor since otherwise the\n\t\toriginal file descriptor would get closed when we close\n\t\tthe virtual file below.\n\t*/\n\tfd = dup(fd);\n\n\tFile *f = File::create(fd, File::ReadAccess);\n\tif (!f)\n\t{\n\t\t_af_error(AF_BAD_OPEN, \"could not open file '%s'\", filename);\n\t\treturn AF_FILE_UNKNOWN;\n\t}\n\n\tint result = _af_identify(f, implemented);\n\n\tdelete f;\n\n\treturn result;\n}"
  },
  {
    "function_name": "afIdentifyFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/openclose.cpp",
    "lines": "78-93",
    "snippet": "int afIdentifyFD (int fd)\n{\n\t/*\n\t\tDuplicate the file descriptor since otherwise the\n\t\toriginal file descriptor would get closed when we close\n\t\tthe virtual file below.\n\t*/\n\tfd = dup(fd);\n\tFile *f = File::create(fd, File::ReadAccess);\n\n\tint result = _af_identify(f, NULL);\n\n\tdelete f;\n\n\treturn result;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"modules/ModuleState.h\"",
      "#include \"modules/Module.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include <audiofile.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <assert.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_identify",
          "args": [
            "f",
            "NULL"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "_af_identify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/openclose.cpp",
          "lines": "48-76",
          "snippet": "int _af_identify (File *f, int *implemented)\n{\n\tif (!f->canSeek())\n\t{\n\t\t_af_error(AF_BAD_LSEEK, \"Cannot seek in file\");\n\t\treturn AF_FILE_UNKNOWN;\n\t}\n\n\tAFfileoffset curpos = f->tell();\n\n\tfor (int i=0; i<_AF_NUM_UNITS; i++)\n\t{\n\t\tif (_af_units[i].recognize &&\n\t\t\t_af_units[i].recognize(f))\n\t\t{\n\t\t\tif (implemented != NULL)\n\t\t\t\t*implemented = _af_units[i].implemented;\n\t\t\tf->seek(curpos, File::SeekFromBeginning);\n\t\t\treturn _af_units[i].fileFormat;\n\t\t}\n\t}\n\n\tf->seek(curpos, File::SeekFromBeginning);\n\n\tif (implemented != NULL)\n\t\t*implemented = false;\n\n\treturn AF_FILE_UNKNOWN;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"modules/ModuleState.h\"",
            "#include \"modules/Module.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include <audiofile.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <audiofile.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint _af_identify (File *f, int *implemented)\n{\n\tif (!f->canSeek())\n\t{\n\t\t_af_error(AF_BAD_LSEEK, \"Cannot seek in file\");\n\t\treturn AF_FILE_UNKNOWN;\n\t}\n\n\tAFfileoffset curpos = f->tell();\n\n\tfor (int i=0; i<_AF_NUM_UNITS; i++)\n\t{\n\t\tif (_af_units[i].recognize &&\n\t\t\t_af_units[i].recognize(f))\n\t\t{\n\t\t\tif (implemented != NULL)\n\t\t\t\t*implemented = _af_units[i].implemented;\n\t\t\tf->seek(curpos, File::SeekFromBeginning);\n\t\t\treturn _af_units[i].fileFormat;\n\t\t}\n\t}\n\n\tf->seek(curpos, File::SeekFromBeginning);\n\n\tif (implemented != NULL)\n\t\t*implemented = false;\n\n\treturn AF_FILE_UNKNOWN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "File::create",
          "args": [
            "fd",
            "File::ReadAccess"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup",
          "args": [
            "fd"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <audiofile.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint afIdentifyFD (int fd)\n{\n\t/*\n\t\tDuplicate the file descriptor since otherwise the\n\t\toriginal file descriptor would get closed when we close\n\t\tthe virtual file below.\n\t*/\n\tfd = dup(fd);\n\tFile *f = File::create(fd, File::ReadAccess);\n\n\tint result = _af_identify(f, NULL);\n\n\tdelete f;\n\n\treturn result;\n}"
  },
  {
    "function_name": "_af_identify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/openclose.cpp",
    "lines": "48-76",
    "snippet": "int _af_identify (File *f, int *implemented)\n{\n\tif (!f->canSeek())\n\t{\n\t\t_af_error(AF_BAD_LSEEK, \"Cannot seek in file\");\n\t\treturn AF_FILE_UNKNOWN;\n\t}\n\n\tAFfileoffset curpos = f->tell();\n\n\tfor (int i=0; i<_AF_NUM_UNITS; i++)\n\t{\n\t\tif (_af_units[i].recognize &&\n\t\t\t_af_units[i].recognize(f))\n\t\t{\n\t\t\tif (implemented != NULL)\n\t\t\t\t*implemented = _af_units[i].implemented;\n\t\t\tf->seek(curpos, File::SeekFromBeginning);\n\t\t\treturn _af_units[i].fileFormat;\n\t\t}\n\t}\n\n\tf->seek(curpos, File::SeekFromBeginning);\n\n\tif (implemented != NULL)\n\t\t*implemented = false;\n\n\treturn AF_FILE_UNKNOWN;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"modules/ModuleState.h\"",
      "#include \"modules/Module.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"Marker.h\"",
      "#include \"Instrument.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include <audiofile.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <assert.h>",
      "#include <stdlib.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f->seek",
          "args": [
            "curpos",
            "File::SeekFromBeginning"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_units[i].recognize",
          "args": [
            "f"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "recognize",
          "container": "IFFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/IFF.cpp",
          "lines": "61-73",
          "snippet": "bool IFFFile::recognize(File *fh)\n{\n\tuint8_t buffer[8];\n\n\tfh->seek(0, File::SeekFromBeginning);\n\n\tif (fh->read(buffer, 8) != 8 || memcmp(buffer, \"FORM\", 4) != 0)\n\t\treturn false;\n\tif (fh->read(buffer, 4) != 4 || memcmp(buffer, \"8SVX\", 4) != 0)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Marker.h\"",
            "#include \"File.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"IFF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"IFF.h\"\n#include \"config.h\"\n\nIFFFile {\n  bool IFFFile::recognize(File *fh)\n  {\n  \tuint8_t buffer[8];\n  \n  \tfh->seek(0, File::SeekFromBeginning);\n  \n  \tif (fh->read(buffer, 8) != 8 || memcmp(buffer, \"FORM\", 4) != 0)\n  \t\treturn false;\n  \tif (fh->read(buffer, 4) != 4 || memcmp(buffer, \"8SVX\", 4) != 0)\n  \t\treturn false;\n  \n  \treturn true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "f->tell",
          "args": [],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_LSEEK",
            "\"Cannot seek in file\""
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f->canSeek",
          "args": [],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "canSeek",
          "container": "File",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "109-112",
          "snippet": "bool File::canSeek()\n{\n\treturn seek(0, File::SeekFromCurrent) != -1;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFile {\n  bool File::canSeek()\n  {\n  \treturn seek(0, File::SeekFromCurrent) != -1;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <audiofile.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"config.h\"\n\nint _af_identify (File *f, int *implemented)\n{\n\tif (!f->canSeek())\n\t{\n\t\t_af_error(AF_BAD_LSEEK, \"Cannot seek in file\");\n\t\treturn AF_FILE_UNKNOWN;\n\t}\n\n\tAFfileoffset curpos = f->tell();\n\n\tfor (int i=0; i<_AF_NUM_UNITS; i++)\n\t{\n\t\tif (_af_units[i].recognize &&\n\t\t\t_af_units[i].recognize(f))\n\t\t{\n\t\t\tif (implemented != NULL)\n\t\t\t\t*implemented = _af_units[i].implemented;\n\t\t\tf->seek(curpos, File::SeekFromBeginning);\n\t\t\treturn _af_units[i].fileFormat;\n\t\t}\n\t}\n\n\tf->seek(curpos, File::SeekFromBeginning);\n\n\tif (implemented != NULL)\n\t\t*implemented = false;\n\n\treturn AF_FILE_UNKNOWN;\n}"
  }
]