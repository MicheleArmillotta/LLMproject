[
  {
    "function_name": "sync2",
    "container": "BlockCodec",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/BlockCodec.cpp",
    "lines": "121-127",
    "snippet": "void BlockCodec::sync2()\n{\n\tassert(tell() == m_track->fpos_next_frame);\n\tm_track->fpos_after_data = tell();\n\tm_track->fpos_next_frame = m_savedPositionNextFrame;\n\tm_track->nextfframe = m_savedNextFrame;\n}",
    "includes": [
      "#include <assert.h>",
      "#include \"Track.h\"",
      "#include \"BlockCodec.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tell",
          "args": [],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "66-69",
          "snippet": "off_t FileModule::tell()\n{\n\treturn m_fh->tell();\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  off_t FileModule::tell()\n  {\n  \treturn m_fh->tell();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tell() == m_track->fpos_next_frame"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"Track.h\"\n#include \"BlockCodec.h\"\n#include \"config.h\"\n\nBlockCodec {\n  void BlockCodec::sync2()\n  {\n  \tassert(tell() == m_track->fpos_next_frame);\n  \tm_track->fpos_after_data = tell();\n  \tm_track->fpos_next_frame = m_savedPositionNextFrame;\n  \tm_track->nextfframe = m_savedNextFrame;\n  }\n}"
  },
  {
    "function_name": "sync1",
    "container": "BlockCodec",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/BlockCodec.cpp",
    "lines": "115-119",
    "snippet": "void BlockCodec::sync1()\n{\n\tm_savedPositionNextFrame = m_track->fpos_next_frame;\n\tm_savedNextFrame = m_track->nextfframe;\n}",
    "includes": [
      "#include <assert.h>",
      "#include \"Track.h\"",
      "#include \"BlockCodec.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"Track.h\"\n#include \"BlockCodec.h\"\n#include \"config.h\"\n\nBlockCodec {\n  void BlockCodec::sync1()\n  {\n  \tm_savedPositionNextFrame = m_track->fpos_next_frame;\n  \tm_savedNextFrame = m_track->nextfframe;\n  }\n}"
  },
  {
    "function_name": "runPush",
    "container": "BlockCodec",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/BlockCodec.cpp",
    "lines": "90-113",
    "snippet": "void BlockCodec::runPush()\n{\n\tAFframecount framesToWrite = m_inChunk->frameCount;\n\tint channelCount = m_inChunk->f.channelCount;\n\n\tint blockCount = (framesToWrite + m_framesPerPacket - 1) / m_framesPerPacket;\n\tfor (int i=0; i<blockCount; i++)\n\t{\n\t\tencodeBlock(static_cast<const int16_t *>(m_inChunk->buffer) + i * m_framesPerPacket * channelCount,\n\t\t\tstatic_cast<uint8_t *>(m_outChunk->buffer) + i * m_bytesPerPacket);\n\t}\n\n\tssize_t bytesWritten = write(m_outChunk->buffer, m_bytesPerPacket * blockCount);\n\tssize_t blocksWritten = bytesWritten >= 0 ? bytesWritten / m_bytesPerPacket : 0;\n\tAFframecount framesWritten = std::min((AFframecount) blocksWritten * m_framesPerPacket, framesToWrite);\n\n\tm_track->nextfframe += framesWritten;\n\tm_track->totalfframes = m_track->nextfframe;\n\n\tassert(tell() == m_track->fpos_next_frame);\n\n\tif (framesWritten < framesToWrite)\n\t\treportWriteError(framesWritten, framesToWrite);\n}",
    "includes": [
      "#include <assert.h>",
      "#include \"Track.h\"",
      "#include \"BlockCodec.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reportWriteError",
          "args": [
            "framesWritten",
            "framesToWrite"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "reportWriteError",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "90-117",
          "snippet": "void FileModule::reportWriteError(AFframecount framesWritten,\n\tAFframecount framesToWrite)\n{\n\t// Report error if we haven't already.\n\tif (!m_track->filemodhappy)\n\t\treturn;\n\n\tif (framesWritten < 0)\n\t{\n\t\t// Signal I/O error.\n\t\t_af_error(AF_BAD_WRITE,\n\t\t\t\"unable to write data (%s) -- wrote %jd out of %jd frames\",\n\t\t\tstrerror(errno),\n\t\t\tstatic_cast<intmax_t>(m_track->nextfframe),\n\t\t\tstatic_cast<intmax_t>(m_track->nextfframe + framesToWrite));\n\t}\n\telse\n\t{\n\t\t// Signal disk full error.\n\t\t_af_error(AF_BAD_WRITE,\n\t\t\t\"unable to write data (disk full) -- \"\n\t\t\t\"wrote %jd out of %jd frames\",\n\t\t\tstatic_cast<intmax_t>(m_track->nextfframe + framesWritten),\n\t\t\tstatic_cast<intmax_t>(m_track->nextfframe + framesToWrite));\n\t}\n\n\tm_track->filemodhappy = false;\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  void FileModule::reportWriteError(AFframecount framesWritten,\n  \tAFframecount framesToWrite)\n  {\n  \t// Report error if we haven't already.\n  \tif (!m_track->filemodhappy)\n  \t\treturn;\n  \n  \tif (framesWritten < 0)\n  \t{\n  \t\t// Signal I/O error.\n  \t\t_af_error(AF_BAD_WRITE,\n  \t\t\t\"unable to write data (%s) -- wrote %jd out of %jd frames\",\n  \t\t\tstrerror(errno),\n  \t\t\tstatic_cast<intmax_t>(m_track->nextfframe),\n  \t\t\tstatic_cast<intmax_t>(m_track->nextfframe + framesToWrite));\n  \t}\n  \telse\n  \t{\n  \t\t// Signal disk full error.\n  \t\t_af_error(AF_BAD_WRITE,\n  \t\t\t\"unable to write data (disk full) -- \"\n  \t\t\t\"wrote %jd out of %jd frames\",\n  \t\t\tstatic_cast<intmax_t>(m_track->nextfframe + framesWritten),\n  \t\t\tstatic_cast<intmax_t>(m_track->nextfframe + framesToWrite));\n  \t}\n  \n  \tm_track->filemodhappy = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tell() == m_track->fpos_next_frame"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tell",
          "args": [],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "66-69",
          "snippet": "off_t FileModule::tell()\n{\n\treturn m_fh->tell();\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  off_t FileModule::tell()\n  {\n  \treturn m_fh->tell();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::min",
          "args": [
            "(AFframecount) blocksWritten * m_framesPerPacket",
            "framesToWrite"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "m_outChunk->buffer",
            "m_bytesPerPacket * blockCount"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "50-59",
          "snippet": "ssize_t FileModule::write(const void *data, size_t nbytes)\n{\n\tssize_t bytesWritten = m_fh->write(data, nbytes);\n\tif (bytesWritten > 0)\n\t{\n\t\tm_track->fpos_next_frame += bytesWritten;\n\t\tm_track->data_size += bytesWritten;\n\t}\n\treturn bytesWritten;\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  ssize_t FileModule::write(const void *data, size_t nbytes)\n  {\n  \tssize_t bytesWritten = m_fh->write(data, nbytes);\n  \tif (bytesWritten > 0)\n  \t{\n  \t\tm_track->fpos_next_frame += bytesWritten;\n  \t\tm_track->data_size += bytesWritten;\n  \t}\n  \treturn bytesWritten;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "encodeBlock",
          "args": [
            "static_cast<const int16_t *>(m_inChunk->buffer) + i * m_framesPerPacket * channelCount",
            "static_cast<uint8_t *>(m_outChunk->buffer) + i * m_bytesPerPacket"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "encodeBlock",
          "container": "MSADPCM",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
          "lines": "270-324",
          "snippet": "int MSADPCM::encodeBlock(const int16_t *decoded, uint8_t *encoded)\n{\n\tchoosePredictorForBlock(decoded);\n\n\tint channelCount = m_track->f.channelCount;\n\n\t// Encode predictor.\n\tfor (int c=0; c<channelCount; c++)\n\t\t*encoded++ = m_state[c].predictorIndex;\n\n\t// Encode delta.\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\t*encoded++ = m_state[c].delta & 0xff;\n\t\t*encoded++ = m_state[c].delta >> 8;\n\t}\n\n\t// Enccode first two samples.\n\tfor (int c=0; c<channelCount; c++)\n\t\tm_state[c].sample2 = *decoded++;\n\n\tfor (int c=0; c<channelCount; c++)\n\t\tm_state[c].sample1 = *decoded++;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\t*encoded++ = m_state[c].sample1 & 0xff;\n\t\t*encoded++ = m_state[c].sample1 >> 8;\n\t}\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\t*encoded++ = m_state[c].sample2 & 0xff;\n\t\t*encoded++ = m_state[c].sample2 >> 8;\n\t}\n\n\tms_adpcm_state *state[2] = { &m_state[0], &m_state[channelCount - 1] };\n\tconst int16_t *coefficient[2] =\n\t{\n\t\tm_coefficients[state[0]->predictorIndex],\n\t\tm_coefficients[state[1]->predictorIndex]\n\t};\n\n\tint samplesRemaining = (m_framesPerPacket - 2) * m_track->f.channelCount;\n\twhile (samplesRemaining > 0)\n\t{\n\t\tuint8_t code1 = encodeSample(*state[0], *decoded++, coefficient[0]);\n\t\tuint8_t code2 = encodeSample(*state[1], *decoded++, coefficient[1]);\n\n\t\t*encoded++ = (code1 << 4) | code2;\n\t\tsamplesRemaining -= 2;\n\t}\n\n\treturn m_bytesPerPacket;\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <string.h>",
            "#include <limits>",
            "#include <cstdlib>",
            "#include <assert.h>",
            "#include \"MSADPCM.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nMSADPCM {\n  int MSADPCM::encodeBlock(const int16_t *decoded, uint8_t *encoded)\n  {\n  \tchoosePredictorForBlock(decoded);\n  \n  \tint channelCount = m_track->f.channelCount;\n  \n  \t// Encode predictor.\n  \tfor (int c=0; c<channelCount; c++)\n  \t\t*encoded++ = m_state[c].predictorIndex;\n  \n  \t// Encode delta.\n  \tfor (int c=0; c<channelCount; c++)\n  \t{\n  \t\t*encoded++ = m_state[c].delta & 0xff;\n  \t\t*encoded++ = m_state[c].delta >> 8;\n  \t}\n  \n  \t// Enccode first two samples.\n  \tfor (int c=0; c<channelCount; c++)\n  \t\tm_state[c].sample2 = *decoded++;\n  \n  \tfor (int c=0; c<channelCount; c++)\n  \t\tm_state[c].sample1 = *decoded++;\n  \n  \tfor (int c=0; c<channelCount; c++)\n  \t{\n  \t\t*encoded++ = m_state[c].sample1 & 0xff;\n  \t\t*encoded++ = m_state[c].sample1 >> 8;\n  \t}\n  \n  \tfor (int c=0; c<channelCount; c++)\n  \t{\n  \t\t*encoded++ = m_state[c].sample2 & 0xff;\n  \t\t*encoded++ = m_state[c].sample2 >> 8;\n  \t}\n  \n  \tms_adpcm_state *state[2] = { &m_state[0], &m_state[channelCount - 1] };\n  \tconst int16_t *coefficient[2] =\n  \t{\n  \t\tm_coefficients[state[0]->predictorIndex],\n  \t\tm_coefficients[state[1]->predictorIndex]\n  \t};\n  \n  \tint samplesRemaining = (m_framesPerPacket - 2) * m_track->f.channelCount;\n  \twhile (samplesRemaining > 0)\n  \t{\n  \t\tuint8_t code1 = encodeSample(*state[0], *decoded++, coefficient[0]);\n  \t\tuint8_t code2 = encodeSample(*state[1], *decoded++, coefficient[1]);\n  \n  \t\t*encoded++ = (code1 << 4) | code2;\n  \t\tsamplesRemaining -= 2;\n  \t}\n  \n  \treturn m_bytesPerPacket;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<uint8_t *>",
          "args": [
            "m_outChunk->buffer"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<const int16_t *>",
          "args": [
            "m_inChunk->buffer"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"Track.h\"\n#include \"BlockCodec.h\"\n#include \"config.h\"\n\nBlockCodec {\n  void BlockCodec::runPush()\n  {\n  \tAFframecount framesToWrite = m_inChunk->frameCount;\n  \tint channelCount = m_inChunk->f.channelCount;\n  \n  \tint blockCount = (framesToWrite + m_framesPerPacket - 1) / m_framesPerPacket;\n  \tfor (int i=0; i<blockCount; i++)\n  \t{\n  \t\tencodeBlock(static_cast<const int16_t *>(m_inChunk->buffer) + i * m_framesPerPacket * channelCount,\n  \t\t\tstatic_cast<uint8_t *>(m_outChunk->buffer) + i * m_bytesPerPacket);\n  \t}\n  \n  \tssize_t bytesWritten = write(m_outChunk->buffer, m_bytesPerPacket * blockCount);\n  \tssize_t blocksWritten = bytesWritten >= 0 ? bytesWritten / m_bytesPerPacket : 0;\n  \tAFframecount framesWritten = std::min((AFframecount) blocksWritten * m_framesPerPacket, framesToWrite);\n  \n  \tm_track->nextfframe += framesWritten;\n  \tm_track->totalfframes = m_track->nextfframe;\n  \n  \tassert(tell() == m_track->fpos_next_frame);\n  \n  \tif (framesWritten < framesToWrite)\n  \t\treportWriteError(framesWritten, framesToWrite);\n  }\n}"
  },
  {
    "function_name": "reset2",
    "container": "BlockCodec",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/BlockCodec.cpp",
    "lines": "81-88",
    "snippet": "void BlockCodec::reset2()\n{\n\tm_track->fpos_next_frame = m_track->fpos_first_frame +\n\t\tm_bytesPerPacket * (m_track->nextfframe / m_framesPerPacket);\n\tm_track->frames2ignore += m_framesToIgnore;\n\n\tassert(m_track->nextfframe % m_framesPerPacket == 0);\n}",
    "includes": [
      "#include <assert.h>",
      "#include \"Track.h\"",
      "#include \"BlockCodec.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_track->nextfframe % m_framesPerPacket == 0"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"Track.h\"\n#include \"BlockCodec.h\"\n#include \"config.h\"\n\nBlockCodec {\n  void BlockCodec::reset2()\n  {\n  \tm_track->fpos_next_frame = m_track->fpos_first_frame +\n  \t\tm_bytesPerPacket * (m_track->nextfframe / m_framesPerPacket);\n  \tm_track->frames2ignore += m_framesToIgnore;\n  \n  \tassert(m_track->nextfframe % m_framesPerPacket == 0);\n  }\n}"
  },
  {
    "function_name": "reset1",
    "container": "BlockCodec",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/BlockCodec.cpp",
    "lines": "72-79",
    "snippet": "void BlockCodec::reset1()\n{\n\tAFframecount nextTrackFrame = m_track->nextfframe;\n\tm_track->nextfframe = (nextTrackFrame / m_framesPerPacket) *\n\t\tm_framesPerPacket;\n\n\tm_framesToIgnore = nextTrackFrame - m_track->nextfframe;\n}",
    "includes": [
      "#include <assert.h>",
      "#include \"Track.h\"",
      "#include \"BlockCodec.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"Track.h\"\n#include \"BlockCodec.h\"\n#include \"config.h\"\n\nBlockCodec {\n  void BlockCodec::reset1()\n  {\n  \tAFframecount nextTrackFrame = m_track->nextfframe;\n  \tm_track->nextfframe = (nextTrackFrame / m_framesPerPacket) *\n  \t\tm_framesPerPacket;\n  \n  \tm_framesToIgnore = nextTrackFrame - m_track->nextfframe;\n  }\n}"
  },
  {
    "function_name": "runPull",
    "container": "BlockCodec",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/BlockCodec.cpp",
    "lines": "40-70",
    "snippet": "void BlockCodec::runPull()\n{\n\tAFframecount framesToRead = m_outChunk->frameCount;\n\tAFframecount framesRead = 0;\n\n\tassert(framesToRead % m_framesPerPacket == 0);\n\tint blockCount = framesToRead / m_framesPerPacket;\n\n\t// Read the compressed data.\n\tssize_t bytesRead = read(m_inChunk->buffer, m_bytesPerPacket * blockCount);\n\tint blocksRead = bytesRead >= 0 ? bytesRead / m_bytesPerPacket : 0;\n\n\t// Decompress into m_outChunk.\n\tfor (int i=0; i<blocksRead; i++)\n\t{\n\t\tif (decodeBlock(static_cast<const uint8_t *>(m_inChunk->buffer) + i * m_bytesPerPacket,\n\t\t\tstatic_cast<int16_t *>(m_outChunk->buffer) + i * m_framesPerPacket * m_track->f.channelCount)==0)\n\t\t\tbreak;\n\n\t\tframesRead += m_framesPerPacket;\n\t}\n\n\tm_track->nextfframe += framesRead;\n\n\tassert(tell() == m_track->fpos_next_frame);\n\n\tif (framesRead < framesToRead)\n\t\treportReadError(framesRead, framesToRead);\n\n\tm_outChunk->frameCount = framesRead;\n}",
    "includes": [
      "#include <assert.h>",
      "#include \"Track.h\"",
      "#include \"BlockCodec.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reportReadError",
          "args": [
            "framesRead",
            "framesToRead"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "reportReadError",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "76-88",
          "snippet": "void FileModule::reportReadError(AFframecount framesRead,\n\tAFframecount framesToRead)\n{\n\t// Report error if we haven't already.\n\tif (!m_track->filemodhappy)\n\t\treturn;\n\n\t_af_error(AF_BAD_READ,\n\t\t\"file missing data -- read %jd frames, should be %jd\",\n\t\tstatic_cast<intmax_t>(m_track->nextfframe),\n\t\tstatic_cast<intmax_t>(m_track->totalfframes));\n\tm_track->filemodhappy = false;\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  void FileModule::reportReadError(AFframecount framesRead,\n  \tAFframecount framesToRead)\n  {\n  \t// Report error if we haven't already.\n  \tif (!m_track->filemodhappy)\n  \t\treturn;\n  \n  \t_af_error(AF_BAD_READ,\n  \t\t\"file missing data -- read %jd frames, should be %jd\",\n  \t\tstatic_cast<intmax_t>(m_track->nextfframe),\n  \t\tstatic_cast<intmax_t>(m_track->totalfframes));\n  \tm_track->filemodhappy = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tell() == m_track->fpos_next_frame"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tell",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "66-69",
          "snippet": "off_t FileModule::tell()\n{\n\treturn m_fh->tell();\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  off_t FileModule::tell()\n  {\n  \treturn m_fh->tell();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "decodeBlock",
          "args": [
            "static_cast<const uint8_t *>(m_inChunk->buffer) + i * m_bytesPerPacket",
            "static_cast<int16_t *>(m_outChunk->buffer) + i * m_framesPerPacket * m_track->f.channelCount"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "decodeBlock",
          "container": "MSADPCM",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/MSADPCM.cpp",
          "lines": "186-268",
          "snippet": "int MSADPCM::decodeBlock(const uint8_t *encoded, int16_t *decoded)\n{\n\tms_adpcm_state decoderState[2];\n\tms_adpcm_state *state[2];\n\n\tint channelCount = m_track->f.channelCount;\n\n\t// Calculate the number of bytes needed for decoded data.\n\tint outputLength = m_framesPerPacket * sizeof (int16_t) * channelCount;\n\n\tstate[0] = &decoderState[0];\n\tif (channelCount == 2)\n\t\tstate[1] = &decoderState[1];\n\telse\n\t\tstate[1] = &decoderState[0];\n\n\t// Initialize block predictor.\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->predictorIndex = *encoded++;\n\t\tassert(state[i]->predictorIndex < m_numCoefficients);\n\t}\n\n\t// Initialize delta.\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->delta = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\t// Initialize first two samples.\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample1 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample2 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\tconst int16_t *coefficient[2] =\n\t{\n\t\tm_coefficients[state[0]->predictorIndex],\n\t\tm_coefficients[state[1]->predictorIndex]\n\t};\n\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample2;\n\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample1;\n\n\t/*\n\t\tThe first two samples have already been 'decoded' in\n\t\tthe block header.\n\t*/\n\tint samplesRemaining = (m_framesPerPacket - 2) * m_track->f.channelCount;\n\n\twhile (samplesRemaining > 0)\n\t{\n\t\tuint8_t code;\n\t\tint16_t newSample;\n\t\tbool ok;\n\n\t\tcode = *encoded >> 4;\n\t\tnewSample = decodeSample(*state[0], code, coefficient[0], &ok);\n\t\tif (!ok) return 0;\n\t\t*decoded++ = newSample;\n\n\t\tcode = *encoded & 0x0f;\n\t\tnewSample = decodeSample(*state[1], code, coefficient[1], &ok);\n\t\tif (!ok) return 0;\n\t\t*decoded++ = newSample;\n\n\t\tencoded++;\n\t\tsamplesRemaining -= 2;\n\t}\n\n\treturn outputLength;\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"BlockCodec.h\"",
            "#include <string.h>",
            "#include <limits>",
            "#include <cstdlib>",
            "#include <assert.h>",
            "#include \"MSADPCM.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <string.h>\n#include <limits>\n#include <cstdlib>\n#include <assert.h>\n#include \"MSADPCM.h\"\n#include \"config.h\"\n\nMSADPCM {\n  int MSADPCM::decodeBlock(const uint8_t *encoded, int16_t *decoded)\n  {\n  \tms_adpcm_state decoderState[2];\n  \tms_adpcm_state *state[2];\n  \n  \tint channelCount = m_track->f.channelCount;\n  \n  \t// Calculate the number of bytes needed for decoded data.\n  \tint outputLength = m_framesPerPacket * sizeof (int16_t) * channelCount;\n  \n  \tstate[0] = &decoderState[0];\n  \tif (channelCount == 2)\n  \t\tstate[1] = &decoderState[1];\n  \telse\n  \t\tstate[1] = &decoderState[0];\n  \n  \t// Initialize block predictor.\n  \tfor (int i=0; i<channelCount; i++)\n  \t{\n  \t\tstate[i]->predictorIndex = *encoded++;\n  \t\tassert(state[i]->predictorIndex < m_numCoefficients);\n  \t}\n  \n  \t// Initialize delta.\n  \tfor (int i=0; i<channelCount; i++)\n  \t{\n  \t\tstate[i]->delta = (encoded[1]<<8) | encoded[0];\n  \t\tencoded += sizeof (uint16_t);\n  \t}\n  \n  \t// Initialize first two samples.\n  \tfor (int i=0; i<channelCount; i++)\n  \t{\n  \t\tstate[i]->sample1 = (encoded[1]<<8) | encoded[0];\n  \t\tencoded += sizeof (uint16_t);\n  \t}\n  \n  \tfor (int i=0; i<channelCount; i++)\n  \t{\n  \t\tstate[i]->sample2 = (encoded[1]<<8) | encoded[0];\n  \t\tencoded += sizeof (uint16_t);\n  \t}\n  \n  \tconst int16_t *coefficient[2] =\n  \t{\n  \t\tm_coefficients[state[0]->predictorIndex],\n  \t\tm_coefficients[state[1]->predictorIndex]\n  \t};\n  \n  \tfor (int i=0; i<channelCount; i++)\n  \t\t*decoded++ = state[i]->sample2;\n  \n  \tfor (int i=0; i<channelCount; i++)\n  \t\t*decoded++ = state[i]->sample1;\n  \n  \t/*\n  \t\tThe first two samples have already been 'decoded' in\n  \t\tthe block header.\n  \t*/\n  \tint samplesRemaining = (m_framesPerPacket - 2) * m_track->f.channelCount;\n  \n  \twhile (samplesRemaining > 0)\n  \t{\n  \t\tuint8_t code;\n  \t\tint16_t newSample;\n  \t\tbool ok;\n  \n  \t\tcode = *encoded >> 4;\n  \t\tnewSample = decodeSample(*state[0], code, coefficient[0], &ok);\n  \t\tif (!ok) return 0;\n  \t\t*decoded++ = newSample;\n  \n  \t\tcode = *encoded & 0x0f;\n  \t\tnewSample = decodeSample(*state[1], code, coefficient[1], &ok);\n  \t\tif (!ok) return 0;\n  \t\t*decoded++ = newSample;\n  \n  \t\tencoded++;\n  \t\tsamplesRemaining -= 2;\n  \t}\n  \n  \treturn outputLength;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<int16_t *>",
          "args": [
            "m_outChunk->buffer"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<const uint8_t *>",
          "args": [
            "m_inChunk->buffer"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "m_inChunk->buffer",
            "m_bytesPerPacket * blockCount"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileModule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FileModule.cpp",
          "lines": "40-48",
          "snippet": "ssize_t FileModule::read(void *data, size_t nbytes)\n{\n\tssize_t bytesRead = m_fh->read(data, nbytes);\n\tif (bytesRead > 0)\n\t{\n\t\tm_track->fpos_next_frame += bytesRead;\n\t}\n\treturn bytesRead;\n}",
          "includes": [
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"Track.h\"",
            "#include \"File.h\"",
            "#include \"FileModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <errno.h>\n#include \"Track.h\"\n#include \"File.h\"\n#include \"FileModule.h\"\n#include \"config.h\"\n\nFileModule {\n  ssize_t FileModule::read(void *data, size_t nbytes)\n  {\n  \tssize_t bytesRead = m_fh->read(data, nbytes);\n  \tif (bytesRead > 0)\n  \t{\n  \t\tm_track->fpos_next_frame += bytesRead;\n  \t}\n  \treturn bytesRead;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "framesToRead % m_framesPerPacket == 0"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"Track.h\"\n#include \"BlockCodec.h\"\n#include \"config.h\"\n\nBlockCodec {\n  void BlockCodec::runPull()\n  {\n  \tAFframecount framesToRead = m_outChunk->frameCount;\n  \tAFframecount framesRead = 0;\n  \n  \tassert(framesToRead % m_framesPerPacket == 0);\n  \tint blockCount = framesToRead / m_framesPerPacket;\n  \n  \t// Read the compressed data.\n  \tssize_t bytesRead = read(m_inChunk->buffer, m_bytesPerPacket * blockCount);\n  \tint blocksRead = bytesRead >= 0 ? bytesRead / m_bytesPerPacket : 0;\n  \n  \t// Decompress into m_outChunk.\n  \tfor (int i=0; i<blocksRead; i++)\n  \t{\n  \t\tif (decodeBlock(static_cast<const uint8_t *>(m_inChunk->buffer) + i * m_bytesPerPacket,\n  \t\t\tstatic_cast<int16_t *>(m_outChunk->buffer) + i * m_framesPerPacket * m_track->f.channelCount)==0)\n  \t\t\tbreak;\n  \n  \t\tframesRead += m_framesPerPacket;\n  \t}\n  \n  \tm_track->nextfframe += framesRead;\n  \n  \tassert(tell() == m_track->fpos_next_frame);\n  \n  \tif (framesRead < framesToRead)\n  \t\treportReadError(framesRead, framesToRead);\n  \n  \tm_outChunk->frameCount = framesRead;\n  }\n}"
  },
  {
    "function_name": "BlockCodec",
    "container": "BlockCodec",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/BlockCodec.cpp",
    "lines": "28-38",
    "snippet": "BlockCodec::BlockCodec(Mode mode, Track *track, File *fh, bool canSeek) :\n\tFileModule(mode, track, fh, canSeek),\n\tm_bytesPerPacket(-1),\n\tm_framesPerPacket(-1),\n\tm_framesToIgnore(-1),\n\tm_savedPositionNextFrame(-1),\n\tm_savedNextFrame(-1)\n{\n\tm_framesPerPacket = track->f.framesPerPacket;\n\tm_bytesPerPacket = track->f.bytesPerPacket;\n}",
    "includes": [
      "#include <assert.h>",
      "#include \"Track.h\"",
      "#include \"BlockCodec.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"Track.h\"\n#include \"BlockCodec.h\"\n#include \"config.h\"\n\nBlockCodec {\n  BlockCodec::BlockCodec(Mode mode, Track *track, File *fh, bool canSeek) :\n  \tFileModule(mode, track, fh, canSeek),\n  \tm_bytesPerPacket(-1),\n  \tm_framesPerPacket(-1),\n  \tm_framesToIgnore(-1),\n  \tm_savedPositionNextFrame(-1),\n  \tm_savedNextFrame(-1)\n  {\n  \tm_framesPerPacket = track->f.framesPerPacket;\n  \tm_bytesPerPacket = track->f.bytesPerPacket;\n  }\n}"
  }
]