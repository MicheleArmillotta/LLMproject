[
  {
    "function_name": "afReadFrames",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/data.cpp",
    "lines": "125-236",
    "snippet": "int afReadFrames (AFfilehandle file, int trackid, void *samples,\n\tint nvframeswanted)\n{\n\tSharedPtr<Module> firstmod;\n\tSharedPtr<Chunk> userc;\n\tAFframecount\tnvframesleft, nvframes2read;\n\tint\t\tbytes_per_vframe;\n\tAFframecount\tvframe;\n\n\tif (!_af_filehandle_ok(file))\n\t\treturn -1;\n\n\tif (!file->checkCanRead())\n\t\treturn -1;\n\n\tTrack *track = file->getTrack(trackid);\n\tif (!track)\n\t\treturn -1;\n\n\tif (track->ms->isDirty() && track->ms->setup(file, track) == AF_FAIL)\n\t\treturn -1;\n\n\tif (!track->ms->fileModuleHandlesSeeking() &&\n\t\tfile->m_seekok &&\n\t\tfile->m_fh->seek(track->fpos_next_frame, File::SeekFromBeginning) !=\n\t\t\ttrack->fpos_next_frame)\n\t{\n\t\t_af_error(AF_BAD_LSEEK, \"unable to position read pointer at next frame\");\n\t\treturn -1;\n\t}\n\n\tif (track->totalvframes == -1)\n\t\tnvframes2read = nvframeswanted;\n\telse\n\t{\n\t\tnvframesleft = track->totalvframes - track->nextvframe;\n\t\tnvframes2read = (nvframeswanted > nvframesleft) ?\n\t\t\tnvframesleft : nvframeswanted;\n\t}\n\tbytes_per_vframe = _af_format_frame_size(&track->v, true);\n\n\tfirstmod = track->ms->modules().back();\n\tuserc = track->ms->chunks().back();\n\n\ttrack->filemodhappy = true;\n\n\tvframe = 0;\n\n\tif (!track->ms->mustUseAtomicNVFrames())\n\t{\n\t\tassert(track->frames2ignore == 0);\n\t\tuserc->buffer = samples;\n\t\tuserc->frameCount = nvframes2read;\n\n\t\tfirstmod->runPull();\n\t\tif (track->filemodhappy)\n\t\t\tvframe += userc->frameCount;\n\t}\n\telse\n\t{\n\t\tbool\teof = false;\n\n\t\tif (track->frames2ignore != 0)\n\t\t{\n\t\t\tuserc->frameCount = track->frames2ignore;\n\t\t\tuserc->allocate(track->frames2ignore * bytes_per_vframe);\n\t\t\tif (!userc->buffer)\n\t\t\t\treturn 0;\n\n\t\t\tfirstmod->runPull();\n\n\t\t\t/* Have we hit EOF? */\n\t\t\tif (static_cast<ssize_t>(userc->frameCount) < track->frames2ignore)\n\t\t\t\teof = true;\n\n\t\t\ttrack->frames2ignore = 0;\n\n\t\t\tuserc->deallocate();\n\t\t}\n\n\t\t/*\n\t\t\tNow start reading useful frames, until EOF or\n\t\t\tpremature EOF.\n\t\t*/\n\n\t\twhile (track->filemodhappy && !eof && vframe < nvframes2read)\n\t\t{\n\t\t\tAFframecount\tnvframes2pull;\n\t\t\tuserc->buffer = (char *) samples + bytes_per_vframe * vframe;\n\n\t\t\tif (vframe <= nvframes2read - _AF_ATOMIC_NVFRAMES)\n\t\t\t\tnvframes2pull = _AF_ATOMIC_NVFRAMES;\n\t\t\telse\n\t\t\t\tnvframes2pull = nvframes2read - vframe;\n\n\t\t\tuserc->frameCount = nvframes2pull;\n\n\t\t\tfirstmod->runPull();\n\n\t\t\tif (track->filemodhappy)\n\t\t\t{\n\t\t\t\tvframe += userc->frameCount;\n\t\t\t\tif (static_cast<ssize_t>(userc->frameCount) < nvframes2pull)\n\t\t\t\t\teof = true;\n\t\t\t}\n\t\t}\n\t}\n\n\ttrack->nextvframe += vframe;\n\n\treturn vframe;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"modules/ModuleState.h\"",
      "#include \"modules/Module.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<ssize_t>",
          "args": [
            "userc->frameCount"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "firstmod->runPull",
          "args": [],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "runPull",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.cpp",
          "lines": "60-62",
          "snippet": "void Module::runPull()\n{\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"File.h\"",
            "#include \"Module.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"SimpleModule.h\"\n#include \"File.h\"\n#include \"Module.h\"\n#include \"config.h\"\n\nModule {\n  void Module::runPull()\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "userc->deallocate",
          "args": [],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "deallocate",
          "container": "Chunk",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.h",
          "lines": "61-67",
          "snippet": "void deallocate()\n\t{\n\t\tif (ownsMemory)\n\t\t\t::operator delete(buffer);\n\t\townsMemory = false;\n\t\tbuffer = NULL;\n\t}",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"AudioFormat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"AudioFormat.h\"\n\nChunk {\n  void deallocate()\n  \t{\n  \t\tif (ownsMemory)\n  \t\t\t::operator delete(buffer);\n  \t\townsMemory = false;\n  \t\tbuffer = NULL;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<ssize_t>",
          "args": [
            "userc->frameCount"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userc->allocate",
          "args": [
            "track->frames2ignore * bytes_per_vframe"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "allocate",
          "container": "Chunk",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.h",
          "lines": "55-60",
          "snippet": "void allocate(size_t capacity)\n\t{\n\t\tdeallocate();\n\t\townsMemory = true;\n\t\tbuffer = ::operator new(capacity);\n\t}",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"AudioFormat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"AudioFormat.h\"\n\nChunk {\n  void allocate(size_t capacity)\n  \t{\n  \t\tdeallocate();\n  \t\townsMemory = true;\n  \t\tbuffer = ::operator new(capacity);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "track->frames2ignore == 0"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track->ms->mustUseAtomicNVFrames",
          "args": [],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "mustUseAtomicNVFrames",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.h",
          "lines": "50-50",
          "snippet": "bool mustUseAtomicNVFrames() const { return true; }",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"Module.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"Module.h\"\n\nModuleState {\n  bool mustUseAtomicNVFrames() const { return true; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->ms->chunks",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track->ms->chunks",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track->ms->modules",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track->ms->modules",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_format_frame_size",
          "args": [
            "&track->v",
            "true"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "_af_format_frame_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "301-308",
          "snippet": "float _af_format_frame_size (const AudioFormat *fmt, bool stretch3to4)\n{\n\tconst CompressionUnit *unit = _af_compression_unit_from_id(fmt->compressionType);\n\tfloat squishFactor = unit->squishFactor;\n\n\treturn _af_format_frame_size_uncompressed(fmt, stretch3to4) /\n\t\tsquishFactor;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nfloat _af_format_frame_size (const AudioFormat *fmt, bool stretch3to4)\n{\n\tconst CompressionUnit *unit = _af_compression_unit_from_id(fmt->compressionType);\n\tfloat squishFactor = unit->squishFactor;\n\n\treturn _af_format_frame_size_uncompressed(fmt, stretch3to4) /\n\t\tsquishFactor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_LSEEK",
            "\"unable to position read pointer at next frame\""
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->m_fh->seek",
          "args": [
            "track->fpos_next_frame",
            "File::SeekFromBeginning"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->ms->fileModuleHandlesSeeking",
          "args": [],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "fileModuleHandlesSeeking",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "104-107",
          "snippet": "bool ModuleState::fileModuleHandlesSeeking() const\n{\n\treturn m_fileModule->handlesSeeking();\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  bool ModuleState::fileModuleHandlesSeeking() const\n  {\n  \treturn m_fileModule->handlesSeeking();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->ms->setup",
          "args": [
            "file",
            "track"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "setup",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "109-201",
          "snippet": "status ModuleState::setup(AFfilehandle file, Track *track)\n{\n\tAFframecount fframepos = llrint(track->nextvframe * track->f.sampleRate / track->v.sampleRate);\n\tbool isReading = file->m_access == _AF_READ_ACCESS;\n\n\tif (!track->v.isUncompressed())\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\"library does not support compression in virtual format yet\");\n\t\treturn AF_FAIL;\n\t}\n\n\tif (arrange(file, track) == AF_FAIL)\n\t\treturn AF_FAIL;\n\n\ttrack->filemodhappy = true;\n\tint maxbufsize = 0;\n\tif (isReading)\n\t{\n\t\tm_chunks.back()->frameCount = _AF_ATOMIC_NVFRAMES;\n\t\tfor (int i=m_modules.size() - 1; i >= 0; i--)\n\t\t{\n\t\t\tSharedPtr<Chunk> inChunk = m_chunks[i];\n\t\t\tSharedPtr<Chunk> outChunk = m_chunks[i+1];\n\t\t\tint bufsize = outChunk->frameCount * outChunk->f.bytesPerFrame(true);\n\t\t\tif (bufsize > maxbufsize)\n\t\t\t\tmaxbufsize = bufsize;\n\t\t\tif (i != 0)\n\t\t\t\tm_modules[i]->setSource(m_modules[i-1].get());\n\t\t\tm_modules[i]->maxPull();\n\t\t}\n\n\t\tif (!track->filemodhappy)\n\t\t\treturn AF_FAIL;\n\t\tint bufsize = m_fileModule->bufferSize();\n\t\tif (bufsize > maxbufsize)\n\t\t\tmaxbufsize = bufsize;\n\t}\n\telse\n\t{\n\t\tm_chunks.front()->frameCount = _AF_ATOMIC_NVFRAMES;\n\t\tfor (size_t i=0; i<m_modules.size(); i++)\n\t\t{\n\t\t\tSharedPtr<Chunk> inChunk = m_chunks[i];\n\t\t\tSharedPtr<Chunk> outChunk = m_chunks[i+1];\n\t\t\tint bufsize = inChunk->frameCount * inChunk->f.bytesPerFrame(true);\n\t\t\tif (bufsize > maxbufsize)\n\t\t\t\tmaxbufsize = bufsize;\n\t\t\tif (i != m_modules.size() - 1)\n\t\t\t\tm_modules[i]->setSink(m_modules[i+1].get());\n\t\t\tm_modules[i]->maxPush();\n\t\t}\n\n\t\tif (!track->filemodhappy)\n\t\t\treturn AF_FAIL;\n\n\t\tint bufsize = m_fileModule->bufferSize();\n\t\tif (bufsize > maxbufsize)\n\t\t\tmaxbufsize = bufsize;\n\t}\n\n\tfor (size_t i=0; i<m_chunks.size(); i++)\n\t{\n\t\tif ((isReading && i==m_chunks.size() - 1) || (!isReading && i==0))\n\t\t\tcontinue;\n\t\tm_chunks[i]->allocate(maxbufsize);\n\t}\n\n\tif (isReading)\n\t{\n\t\tif (track->totalfframes == -1)\n\t\t\ttrack->totalvframes = -1;\n\t\telse\n\t\t\ttrack->totalvframes = llrint(track->totalfframes *\n\t\t\t\t(track->v.sampleRate / track->f.sampleRate));\n\n\t\ttrack->nextfframe = fframepos;\n\t\ttrack->nextvframe = llrint(fframepos * track->v.sampleRate / track->f.sampleRate);\n\n\t\tm_isDirty = false;\n\n\t\tif (reset(file, track) == AF_FAIL)\n\t\t\treturn AF_FAIL;\n\t}\n\telse\n\t{\n\t\ttrack->nextvframe = track->totalvframes =\n\t\t\t(AFframecount) (fframepos * track->v.sampleRate / track->f.sampleRate);\n\t\tm_isDirty = false;\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  status ModuleState::setup(AFfilehandle file, Track *track)\n  {\n  \tAFframecount fframepos = llrint(track->nextvframe * track->f.sampleRate / track->v.sampleRate);\n  \tbool isReading = file->m_access == _AF_READ_ACCESS;\n  \n  \tif (!track->v.isUncompressed())\n  \t{\n  \t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n  \t\t\t\"library does not support compression in virtual format yet\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \tif (arrange(file, track) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \n  \ttrack->filemodhappy = true;\n  \tint maxbufsize = 0;\n  \tif (isReading)\n  \t{\n  \t\tm_chunks.back()->frameCount = _AF_ATOMIC_NVFRAMES;\n  \t\tfor (int i=m_modules.size() - 1; i >= 0; i--)\n  \t\t{\n  \t\t\tSharedPtr<Chunk> inChunk = m_chunks[i];\n  \t\t\tSharedPtr<Chunk> outChunk = m_chunks[i+1];\n  \t\t\tint bufsize = outChunk->frameCount * outChunk->f.bytesPerFrame(true);\n  \t\t\tif (bufsize > maxbufsize)\n  \t\t\t\tmaxbufsize = bufsize;\n  \t\t\tif (i != 0)\n  \t\t\t\tm_modules[i]->setSource(m_modules[i-1].get());\n  \t\t\tm_modules[i]->maxPull();\n  \t\t}\n  \n  \t\tif (!track->filemodhappy)\n  \t\t\treturn AF_FAIL;\n  \t\tint bufsize = m_fileModule->bufferSize();\n  \t\tif (bufsize > maxbufsize)\n  \t\t\tmaxbufsize = bufsize;\n  \t}\n  \telse\n  \t{\n  \t\tm_chunks.front()->frameCount = _AF_ATOMIC_NVFRAMES;\n  \t\tfor (size_t i=0; i<m_modules.size(); i++)\n  \t\t{\n  \t\t\tSharedPtr<Chunk> inChunk = m_chunks[i];\n  \t\t\tSharedPtr<Chunk> outChunk = m_chunks[i+1];\n  \t\t\tint bufsize = inChunk->frameCount * inChunk->f.bytesPerFrame(true);\n  \t\t\tif (bufsize > maxbufsize)\n  \t\t\t\tmaxbufsize = bufsize;\n  \t\t\tif (i != m_modules.size() - 1)\n  \t\t\t\tm_modules[i]->setSink(m_modules[i+1].get());\n  \t\t\tm_modules[i]->maxPush();\n  \t\t}\n  \n  \t\tif (!track->filemodhappy)\n  \t\t\treturn AF_FAIL;\n  \n  \t\tint bufsize = m_fileModule->bufferSize();\n  \t\tif (bufsize > maxbufsize)\n  \t\t\tmaxbufsize = bufsize;\n  \t}\n  \n  \tfor (size_t i=0; i<m_chunks.size(); i++)\n  \t{\n  \t\tif ((isReading && i==m_chunks.size() - 1) || (!isReading && i==0))\n  \t\t\tcontinue;\n  \t\tm_chunks[i]->allocate(maxbufsize);\n  \t}\n  \n  \tif (isReading)\n  \t{\n  \t\tif (track->totalfframes == -1)\n  \t\t\ttrack->totalvframes = -1;\n  \t\telse\n  \t\t\ttrack->totalvframes = llrint(track->totalfframes *\n  \t\t\t\t(track->v.sampleRate / track->f.sampleRate));\n  \n  \t\ttrack->nextfframe = fframepos;\n  \t\ttrack->nextvframe = llrint(fframepos * track->v.sampleRate / track->f.sampleRate);\n  \n  \t\tm_isDirty = false;\n  \n  \t\tif (reset(file, track) == AF_FAIL)\n  \t\t\treturn AF_FAIL;\n  \t}\n  \telse\n  \t{\n  \t\ttrack->nextvframe = track->totalvframes =\n  \t\t\t(AFframecount) (fframepos * track->v.sampleRate / track->f.sampleRate);\n  \t\tm_isDirty = false;\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->ms->isDirty",
          "args": [],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "isDirty",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.h",
          "lines": "39-39",
          "snippet": "bool isDirty() const { return m_isDirty; }",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"Module.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"Module.h\"\n\nModuleState {\n  bool isDirty() const { return m_isDirty; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->getTrack",
          "args": [
            "trackid"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->checkCanRead",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "checkCanRead",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "177-186",
          "snippet": "bool _AFfilehandle::checkCanRead()\n{\n\tif (m_access != _AF_READ_ACCESS)\n\t{\n\t\t_af_error(AF_BAD_NOREADACC, \"file not opened for read access\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::checkCanRead()\n  {\n  \tif (m_access != _AF_READ_ACCESS)\n  \t{\n  \t\t_af_error(AF_BAD_NOREADACC, \"file not opened for read access\");\n  \t\treturn false;\n  \t}\n  \n  \treturn true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_filehandle_ok",
          "args": [
            "file"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "_af_filehandle_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "71-84",
          "snippet": "bool _af_filehandle_ok (AFfilehandle file)\n{\n\tif (file == AF_NULL_FILEHANDLE)\n\t{\n\t\t_af_error(AF_BAD_FILEHANDLE, \"null file handle\");\n\t\treturn false;\n\t}\n\tif (file->m_valid != _AF_VALID_FILEHANDLE)\n\t{\n\t\t_af_error(AF_BAD_FILEHANDLE, \"invalid file handle\");\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nbool _af_filehandle_ok (AFfilehandle file)\n{\n\tif (file == AF_NULL_FILEHANDLE)\n\t{\n\t\t_af_error(AF_BAD_FILEHANDLE, \"null file handle\");\n\t\treturn false;\n\t}\n\tif (file->m_valid != _AF_VALID_FILEHANDLE)\n\t{\n\t\t_af_error(AF_BAD_FILEHANDLE, \"invalid file handle\");\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint afReadFrames (AFfilehandle file, int trackid, void *samples,\n\tint nvframeswanted)\n{\n\tSharedPtr<Module> firstmod;\n\tSharedPtr<Chunk> userc;\n\tAFframecount\tnvframesleft, nvframes2read;\n\tint\t\tbytes_per_vframe;\n\tAFframecount\tvframe;\n\n\tif (!_af_filehandle_ok(file))\n\t\treturn -1;\n\n\tif (!file->checkCanRead())\n\t\treturn -1;\n\n\tTrack *track = file->getTrack(trackid);\n\tif (!track)\n\t\treturn -1;\n\n\tif (track->ms->isDirty() && track->ms->setup(file, track) == AF_FAIL)\n\t\treturn -1;\n\n\tif (!track->ms->fileModuleHandlesSeeking() &&\n\t\tfile->m_seekok &&\n\t\tfile->m_fh->seek(track->fpos_next_frame, File::SeekFromBeginning) !=\n\t\t\ttrack->fpos_next_frame)\n\t{\n\t\t_af_error(AF_BAD_LSEEK, \"unable to position read pointer at next frame\");\n\t\treturn -1;\n\t}\n\n\tif (track->totalvframes == -1)\n\t\tnvframes2read = nvframeswanted;\n\telse\n\t{\n\t\tnvframesleft = track->totalvframes - track->nextvframe;\n\t\tnvframes2read = (nvframeswanted > nvframesleft) ?\n\t\t\tnvframesleft : nvframeswanted;\n\t}\n\tbytes_per_vframe = _af_format_frame_size(&track->v, true);\n\n\tfirstmod = track->ms->modules().back();\n\tuserc = track->ms->chunks().back();\n\n\ttrack->filemodhappy = true;\n\n\tvframe = 0;\n\n\tif (!track->ms->mustUseAtomicNVFrames())\n\t{\n\t\tassert(track->frames2ignore == 0);\n\t\tuserc->buffer = samples;\n\t\tuserc->frameCount = nvframes2read;\n\n\t\tfirstmod->runPull();\n\t\tif (track->filemodhappy)\n\t\t\tvframe += userc->frameCount;\n\t}\n\telse\n\t{\n\t\tbool\teof = false;\n\n\t\tif (track->frames2ignore != 0)\n\t\t{\n\t\t\tuserc->frameCount = track->frames2ignore;\n\t\t\tuserc->allocate(track->frames2ignore * bytes_per_vframe);\n\t\t\tif (!userc->buffer)\n\t\t\t\treturn 0;\n\n\t\t\tfirstmod->runPull();\n\n\t\t\t/* Have we hit EOF? */\n\t\t\tif (static_cast<ssize_t>(userc->frameCount) < track->frames2ignore)\n\t\t\t\teof = true;\n\n\t\t\ttrack->frames2ignore = 0;\n\n\t\t\tuserc->deallocate();\n\t\t}\n\n\t\t/*\n\t\t\tNow start reading useful frames, until EOF or\n\t\t\tpremature EOF.\n\t\t*/\n\n\t\twhile (track->filemodhappy && !eof && vframe < nvframes2read)\n\t\t{\n\t\t\tAFframecount\tnvframes2pull;\n\t\t\tuserc->buffer = (char *) samples + bytes_per_vframe * vframe;\n\n\t\t\tif (vframe <= nvframes2read - _AF_ATOMIC_NVFRAMES)\n\t\t\t\tnvframes2pull = _AF_ATOMIC_NVFRAMES;\n\t\t\telse\n\t\t\t\tnvframes2pull = nvframes2read - vframe;\n\n\t\t\tuserc->frameCount = nvframes2pull;\n\n\t\t\tfirstmod->runPull();\n\n\t\t\tif (track->filemodhappy)\n\t\t\t{\n\t\t\t\tvframe += userc->frameCount;\n\t\t\t\tif (static_cast<ssize_t>(userc->frameCount) < nvframes2pull)\n\t\t\t\t\teof = true;\n\t\t\t}\n\t\t}\n\t}\n\n\ttrack->nextvframe += vframe;\n\n\treturn vframe;\n}"
  },
  {
    "function_name": "afWriteFrames",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/data.cpp",
    "lines": "42-123",
    "snippet": "int afWriteFrames (AFfilehandle file, int trackid, const void *samples,\n\tint nvframes2write)\n{\n\tSharedPtr<Module> firstmod;\n\tSharedPtr<Chunk> userc;\n\tint bytes_per_vframe;\n\tAFframecount vframe;\n\n\tif (!_af_filehandle_ok(file))\n\t\treturn -1;\n\n\tif (!file->checkCanWrite())\n\t\treturn -1;\n\n\tTrack *track = file->getTrack(trackid);\n\tif (!track)\n\t\treturn -1;\n\n\tif (track->ms->isDirty() && track->ms->setup(file, track) == AF_FAIL)\n\t\treturn -1;\n\n\tif (!track->ms->fileModuleHandlesSeeking() &&\n\t\tfile->m_seekok &&\n\t\tfile->m_fh->seek(track->fpos_next_frame, File::SeekFromBeginning) !=\n\t\t\ttrack->fpos_next_frame)\n\t{\n\t\t_af_error(AF_BAD_LSEEK, \"unable to position write pointer at next frame\");\n\t\treturn -1;\n\t}\n\n\tbytes_per_vframe = _af_format_frame_size(&track->v, true);\n\n\tfirstmod = track->ms->modules().front();\n\tuserc = track->ms->chunks().front();\n\n\ttrack->filemodhappy = true;\n\n\tvframe = 0;\n#ifdef UNLIMITED_CHUNK_NVFRAMES\n\t/*\n\t\tOPTIMIZATION: see the comment at the very end of\n\t\tarrangemodules() in modules.c for an explanation of this:\n\t*/\n\tif (!trk->ms->mustUseAtomicNVFrames())\n\t{\n\t\tuserc->buffer = (char *) samples;\n\t\tuserc->frameCount = nvframes2write;\n\n\t\tfirstmod->runPush();\n\n\t\t/* Count this chunk if there was no i/o error. */\n\t\tif (trk->filemodhappy)\n\t\t\tvframe += userc->frameCount;\n\t}\n\telse\n#else\n\t/* Optimization must be off. */\n\tassert(track->ms->mustUseAtomicNVFrames());\n#endif\n\t{\n\t\twhile (vframe < nvframes2write)\n\t\t{\n\t\t\tuserc->buffer = (char *) samples + bytes_per_vframe * vframe;\n\t\t\tif (vframe <= nvframes2write - _AF_ATOMIC_NVFRAMES)\n\t\t\t\tuserc->frameCount = _AF_ATOMIC_NVFRAMES;\n\t\t\telse\n\t\t\t\tuserc->frameCount = nvframes2write - vframe;\n\n\t\t\tfirstmod->runPush();\n\n\t\t\tif (!track->filemodhappy)\n\t\t\t\tbreak;\n\n\t\t\tvframe += userc->frameCount;\n\t\t}\n\t}\n\n\ttrack->nextvframe += vframe;\n\ttrack->totalvframes += vframe;\n\n\treturn vframe;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"modules/ModuleState.h\"",
      "#include \"modules/Module.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "firstmod->runPush",
          "args": [],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "runPush",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.cpp",
          "lines": "64-66",
          "snippet": "void Module::runPush()\n{\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"File.h\"",
            "#include \"Module.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"SimpleModule.h\"\n#include \"File.h\"\n#include \"Module.h\"\n#include \"config.h\"\n\nModule {\n  void Module::runPush()\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "track->ms->mustUseAtomicNVFrames()"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track->ms->mustUseAtomicNVFrames",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "mustUseAtomicNVFrames",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.h",
          "lines": "50-50",
          "snippet": "bool mustUseAtomicNVFrames() const { return true; }",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"Module.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"Module.h\"\n\nModuleState {\n  bool mustUseAtomicNVFrames() const { return true; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->ms->chunks",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track->ms->chunks",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track->ms->modules",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track->ms->modules",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_format_frame_size",
          "args": [
            "&track->v",
            "true"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "_af_format_frame_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "301-308",
          "snippet": "float _af_format_frame_size (const AudioFormat *fmt, bool stretch3to4)\n{\n\tconst CompressionUnit *unit = _af_compression_unit_from_id(fmt->compressionType);\n\tfloat squishFactor = unit->squishFactor;\n\n\treturn _af_format_frame_size_uncompressed(fmt, stretch3to4) /\n\t\tsquishFactor;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nfloat _af_format_frame_size (const AudioFormat *fmt, bool stretch3to4)\n{\n\tconst CompressionUnit *unit = _af_compression_unit_from_id(fmt->compressionType);\n\tfloat squishFactor = unit->squishFactor;\n\n\treturn _af_format_frame_size_uncompressed(fmt, stretch3to4) /\n\t\tsquishFactor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_LSEEK",
            "\"unable to position write pointer at next frame\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->m_fh->seek",
          "args": [
            "track->fpos_next_frame",
            "File::SeekFromBeginning"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->ms->fileModuleHandlesSeeking",
          "args": [],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "fileModuleHandlesSeeking",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "104-107",
          "snippet": "bool ModuleState::fileModuleHandlesSeeking() const\n{\n\treturn m_fileModule->handlesSeeking();\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  bool ModuleState::fileModuleHandlesSeeking() const\n  {\n  \treturn m_fileModule->handlesSeeking();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->ms->setup",
          "args": [
            "file",
            "track"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "setup",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "109-201",
          "snippet": "status ModuleState::setup(AFfilehandle file, Track *track)\n{\n\tAFframecount fframepos = llrint(track->nextvframe * track->f.sampleRate / track->v.sampleRate);\n\tbool isReading = file->m_access == _AF_READ_ACCESS;\n\n\tif (!track->v.isUncompressed())\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\"library does not support compression in virtual format yet\");\n\t\treturn AF_FAIL;\n\t}\n\n\tif (arrange(file, track) == AF_FAIL)\n\t\treturn AF_FAIL;\n\n\ttrack->filemodhappy = true;\n\tint maxbufsize = 0;\n\tif (isReading)\n\t{\n\t\tm_chunks.back()->frameCount = _AF_ATOMIC_NVFRAMES;\n\t\tfor (int i=m_modules.size() - 1; i >= 0; i--)\n\t\t{\n\t\t\tSharedPtr<Chunk> inChunk = m_chunks[i];\n\t\t\tSharedPtr<Chunk> outChunk = m_chunks[i+1];\n\t\t\tint bufsize = outChunk->frameCount * outChunk->f.bytesPerFrame(true);\n\t\t\tif (bufsize > maxbufsize)\n\t\t\t\tmaxbufsize = bufsize;\n\t\t\tif (i != 0)\n\t\t\t\tm_modules[i]->setSource(m_modules[i-1].get());\n\t\t\tm_modules[i]->maxPull();\n\t\t}\n\n\t\tif (!track->filemodhappy)\n\t\t\treturn AF_FAIL;\n\t\tint bufsize = m_fileModule->bufferSize();\n\t\tif (bufsize > maxbufsize)\n\t\t\tmaxbufsize = bufsize;\n\t}\n\telse\n\t{\n\t\tm_chunks.front()->frameCount = _AF_ATOMIC_NVFRAMES;\n\t\tfor (size_t i=0; i<m_modules.size(); i++)\n\t\t{\n\t\t\tSharedPtr<Chunk> inChunk = m_chunks[i];\n\t\t\tSharedPtr<Chunk> outChunk = m_chunks[i+1];\n\t\t\tint bufsize = inChunk->frameCount * inChunk->f.bytesPerFrame(true);\n\t\t\tif (bufsize > maxbufsize)\n\t\t\t\tmaxbufsize = bufsize;\n\t\t\tif (i != m_modules.size() - 1)\n\t\t\t\tm_modules[i]->setSink(m_modules[i+1].get());\n\t\t\tm_modules[i]->maxPush();\n\t\t}\n\n\t\tif (!track->filemodhappy)\n\t\t\treturn AF_FAIL;\n\n\t\tint bufsize = m_fileModule->bufferSize();\n\t\tif (bufsize > maxbufsize)\n\t\t\tmaxbufsize = bufsize;\n\t}\n\n\tfor (size_t i=0; i<m_chunks.size(); i++)\n\t{\n\t\tif ((isReading && i==m_chunks.size() - 1) || (!isReading && i==0))\n\t\t\tcontinue;\n\t\tm_chunks[i]->allocate(maxbufsize);\n\t}\n\n\tif (isReading)\n\t{\n\t\tif (track->totalfframes == -1)\n\t\t\ttrack->totalvframes = -1;\n\t\telse\n\t\t\ttrack->totalvframes = llrint(track->totalfframes *\n\t\t\t\t(track->v.sampleRate / track->f.sampleRate));\n\n\t\ttrack->nextfframe = fframepos;\n\t\ttrack->nextvframe = llrint(fframepos * track->v.sampleRate / track->f.sampleRate);\n\n\t\tm_isDirty = false;\n\n\t\tif (reset(file, track) == AF_FAIL)\n\t\t\treturn AF_FAIL;\n\t}\n\telse\n\t{\n\t\ttrack->nextvframe = track->totalvframes =\n\t\t\t(AFframecount) (fframepos * track->v.sampleRate / track->f.sampleRate);\n\t\tm_isDirty = false;\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  status ModuleState::setup(AFfilehandle file, Track *track)\n  {\n  \tAFframecount fframepos = llrint(track->nextvframe * track->f.sampleRate / track->v.sampleRate);\n  \tbool isReading = file->m_access == _AF_READ_ACCESS;\n  \n  \tif (!track->v.isUncompressed())\n  \t{\n  \t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n  \t\t\t\"library does not support compression in virtual format yet\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \tif (arrange(file, track) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \n  \ttrack->filemodhappy = true;\n  \tint maxbufsize = 0;\n  \tif (isReading)\n  \t{\n  \t\tm_chunks.back()->frameCount = _AF_ATOMIC_NVFRAMES;\n  \t\tfor (int i=m_modules.size() - 1; i >= 0; i--)\n  \t\t{\n  \t\t\tSharedPtr<Chunk> inChunk = m_chunks[i];\n  \t\t\tSharedPtr<Chunk> outChunk = m_chunks[i+1];\n  \t\t\tint bufsize = outChunk->frameCount * outChunk->f.bytesPerFrame(true);\n  \t\t\tif (bufsize > maxbufsize)\n  \t\t\t\tmaxbufsize = bufsize;\n  \t\t\tif (i != 0)\n  \t\t\t\tm_modules[i]->setSource(m_modules[i-1].get());\n  \t\t\tm_modules[i]->maxPull();\n  \t\t}\n  \n  \t\tif (!track->filemodhappy)\n  \t\t\treturn AF_FAIL;\n  \t\tint bufsize = m_fileModule->bufferSize();\n  \t\tif (bufsize > maxbufsize)\n  \t\t\tmaxbufsize = bufsize;\n  \t}\n  \telse\n  \t{\n  \t\tm_chunks.front()->frameCount = _AF_ATOMIC_NVFRAMES;\n  \t\tfor (size_t i=0; i<m_modules.size(); i++)\n  \t\t{\n  \t\t\tSharedPtr<Chunk> inChunk = m_chunks[i];\n  \t\t\tSharedPtr<Chunk> outChunk = m_chunks[i+1];\n  \t\t\tint bufsize = inChunk->frameCount * inChunk->f.bytesPerFrame(true);\n  \t\t\tif (bufsize > maxbufsize)\n  \t\t\t\tmaxbufsize = bufsize;\n  \t\t\tif (i != m_modules.size() - 1)\n  \t\t\t\tm_modules[i]->setSink(m_modules[i+1].get());\n  \t\t\tm_modules[i]->maxPush();\n  \t\t}\n  \n  \t\tif (!track->filemodhappy)\n  \t\t\treturn AF_FAIL;\n  \n  \t\tint bufsize = m_fileModule->bufferSize();\n  \t\tif (bufsize > maxbufsize)\n  \t\t\tmaxbufsize = bufsize;\n  \t}\n  \n  \tfor (size_t i=0; i<m_chunks.size(); i++)\n  \t{\n  \t\tif ((isReading && i==m_chunks.size() - 1) || (!isReading && i==0))\n  \t\t\tcontinue;\n  \t\tm_chunks[i]->allocate(maxbufsize);\n  \t}\n  \n  \tif (isReading)\n  \t{\n  \t\tif (track->totalfframes == -1)\n  \t\t\ttrack->totalvframes = -1;\n  \t\telse\n  \t\t\ttrack->totalvframes = llrint(track->totalfframes *\n  \t\t\t\t(track->v.sampleRate / track->f.sampleRate));\n  \n  \t\ttrack->nextfframe = fframepos;\n  \t\ttrack->nextvframe = llrint(fframepos * track->v.sampleRate / track->f.sampleRate);\n  \n  \t\tm_isDirty = false;\n  \n  \t\tif (reset(file, track) == AF_FAIL)\n  \t\t\treturn AF_FAIL;\n  \t}\n  \telse\n  \t{\n  \t\ttrack->nextvframe = track->totalvframes =\n  \t\t\t(AFframecount) (fframepos * track->v.sampleRate / track->f.sampleRate);\n  \t\tm_isDirty = false;\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->ms->isDirty",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "isDirty",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.h",
          "lines": "39-39",
          "snippet": "bool isDirty() const { return m_isDirty; }",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"Module.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"Module.h\"\n\nModuleState {\n  bool isDirty() const { return m_isDirty; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->getTrack",
          "args": [
            "trackid"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->checkCanWrite",
          "args": [],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "checkCanWrite",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "188-197",
          "snippet": "bool _AFfilehandle::checkCanWrite()\n{\n\tif (m_access != _AF_WRITE_ACCESS)\n\t{\n\t\t_af_error(AF_BAD_NOWRITEACC, \"file not opened for write access\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::checkCanWrite()\n  {\n  \tif (m_access != _AF_WRITE_ACCESS)\n  \t{\n  \t\t_af_error(AF_BAD_NOWRITEACC, \"file not opened for write access\");\n  \t\treturn false;\n  \t}\n  \n  \treturn true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_filehandle_ok",
          "args": [
            "file"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "_af_filehandle_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "71-84",
          "snippet": "bool _af_filehandle_ok (AFfilehandle file)\n{\n\tif (file == AF_NULL_FILEHANDLE)\n\t{\n\t\t_af_error(AF_BAD_FILEHANDLE, \"null file handle\");\n\t\treturn false;\n\t}\n\tif (file->m_valid != _AF_VALID_FILEHANDLE)\n\t{\n\t\t_af_error(AF_BAD_FILEHANDLE, \"invalid file handle\");\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nbool _af_filehandle_ok (AFfilehandle file)\n{\n\tif (file == AF_NULL_FILEHANDLE)\n\t{\n\t\t_af_error(AF_BAD_FILEHANDLE, \"null file handle\");\n\t\treturn false;\n\t}\n\tif (file->m_valid != _AF_VALID_FILEHANDLE)\n\t{\n\t\t_af_error(AF_BAD_FILEHANDLE, \"invalid file handle\");\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint afWriteFrames (AFfilehandle file, int trackid, const void *samples,\n\tint nvframes2write)\n{\n\tSharedPtr<Module> firstmod;\n\tSharedPtr<Chunk> userc;\n\tint bytes_per_vframe;\n\tAFframecount vframe;\n\n\tif (!_af_filehandle_ok(file))\n\t\treturn -1;\n\n\tif (!file->checkCanWrite())\n\t\treturn -1;\n\n\tTrack *track = file->getTrack(trackid);\n\tif (!track)\n\t\treturn -1;\n\n\tif (track->ms->isDirty() && track->ms->setup(file, track) == AF_FAIL)\n\t\treturn -1;\n\n\tif (!track->ms->fileModuleHandlesSeeking() &&\n\t\tfile->m_seekok &&\n\t\tfile->m_fh->seek(track->fpos_next_frame, File::SeekFromBeginning) !=\n\t\t\ttrack->fpos_next_frame)\n\t{\n\t\t_af_error(AF_BAD_LSEEK, \"unable to position write pointer at next frame\");\n\t\treturn -1;\n\t}\n\n\tbytes_per_vframe = _af_format_frame_size(&track->v, true);\n\n\tfirstmod = track->ms->modules().front();\n\tuserc = track->ms->chunks().front();\n\n\ttrack->filemodhappy = true;\n\n\tvframe = 0;\n#ifdef UNLIMITED_CHUNK_NVFRAMES\n\t/*\n\t\tOPTIMIZATION: see the comment at the very end of\n\t\tarrangemodules() in modules.c for an explanation of this:\n\t*/\n\tif (!trk->ms->mustUseAtomicNVFrames())\n\t{\n\t\tuserc->buffer = (char *) samples;\n\t\tuserc->frameCount = nvframes2write;\n\n\t\tfirstmod->runPush();\n\n\t\t/* Count this chunk if there was no i/o error. */\n\t\tif (trk->filemodhappy)\n\t\t\tvframe += userc->frameCount;\n\t}\n\telse\n#else\n\t/* Optimization must be off. */\n\tassert(track->ms->mustUseAtomicNVFrames());\n#endif\n\t{\n\t\twhile (vframe < nvframes2write)\n\t\t{\n\t\t\tuserc->buffer = (char *) samples + bytes_per_vframe * vframe;\n\t\t\tif (vframe <= nvframes2write - _AF_ATOMIC_NVFRAMES)\n\t\t\t\tuserc->frameCount = _AF_ATOMIC_NVFRAMES;\n\t\t\telse\n\t\t\t\tuserc->frameCount = nvframes2write - vframe;\n\n\t\t\tfirstmod->runPush();\n\n\t\t\tif (!track->filemodhappy)\n\t\t\t\tbreak;\n\n\t\t\tvframe += userc->frameCount;\n\t\t}\n\t}\n\n\ttrack->nextvframe += vframe;\n\ttrack->totalvframes += vframe;\n\n\treturn vframe;\n}"
  }
]