[
  {
    "function_name": "initDefaultMatrix",
    "container": "ApplyChannelMatrix",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/SimpleModule.cpp",
    "lines": "130-174",
    "snippet": "void ApplyChannelMatrix::initDefaultMatrix()\n{\n\tconst double *matrix = NULL;\n\tif (m_inChannels==1 && m_outChannels==2)\n\t{\n\t\tstatic const double m[]={1,1};\n\t\tmatrix = m;\n\t}\n\telse if (m_inChannels==1 && m_outChannels==4)\n\t{\n\t\tstatic const double m[]={1,1,0,0};\n\t\tmatrix = m;\n\t}\n\telse if (m_inChannels==2 && m_outChannels==1)\n\t{\n\t\tstatic const double m[]={.5,.5};\n\t\tmatrix = m;\n\t}\n\telse if (m_inChannels==2 && m_outChannels==4)\n\t{\n\t\tstatic const double m[]={1,0,0,1,0,0,0,0};\n\t\tmatrix = m;\n\t}\n\telse if (m_inChannels==4 && m_outChannels==1)\n\t{\n\t\tstatic const double m[]={.5,.5,.5,.5};\n\t\tmatrix = m;\n\t}\n\telse if (m_inChannels==4 && m_outChannels==2)\n\t{\n\t\tstatic const double m[]={1,0,1,0,0,1,0,1};\n\t\tmatrix = m;\n\t}\n\n\tif (matrix)\n\t{\n\t\tstd::copy(matrix, matrix + m_inChannels * m_outChannels, m_matrix);\n\t}\n\telse\n\t{\n\t\tfor (int i=0; i < m_inChannels; i++)\n\t\t\tfor (int j=0; j < m_outChannels; j++)\n\t\t\t\tm_matrix[j*m_inChannels + i] = (i==j) ? 1 : 0;\n\t}\n}",
    "includes": [
      "#include <algorithm>",
      "#include \"SimpleModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::copy",
          "args": [
            "matrix",
            "matrix + m_inChannels * m_outChannels",
            "m_matrix"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include \"SimpleModule.h\"\n#include \"config.h\"\n\nApplyChannelMatrix {\n  void ApplyChannelMatrix::initDefaultMatrix()\n  {\n  \tconst double *matrix = NULL;\n  \tif (m_inChannels==1 && m_outChannels==2)\n  \t{\n  \t\tstatic const double m[]={1,1};\n  \t\tmatrix = m;\n  \t}\n  \telse if (m_inChannels==1 && m_outChannels==4)\n  \t{\n  \t\tstatic const double m[]={1,1,0,0};\n  \t\tmatrix = m;\n  \t}\n  \telse if (m_inChannels==2 && m_outChannels==1)\n  \t{\n  \t\tstatic const double m[]={.5,.5};\n  \t\tmatrix = m;\n  \t}\n  \telse if (m_inChannels==2 && m_outChannels==4)\n  \t{\n  \t\tstatic const double m[]={1,0,0,1,0,0,0,0};\n  \t\tmatrix = m;\n  \t}\n  \telse if (m_inChannels==4 && m_outChannels==1)\n  \t{\n  \t\tstatic const double m[]={.5,.5,.5,.5};\n  \t\tmatrix = m;\n  \t}\n  \telse if (m_inChannels==4 && m_outChannels==2)\n  \t{\n  \t\tstatic const double m[]={1,0,1,0,0,1,0,1};\n  \t\tmatrix = m;\n  \t}\n  \n  \tif (matrix)\n  \t{\n  \t\tstd::copy(matrix, matrix + m_inChannels * m_outChannels, m_matrix);\n  \t}\n  \telse\n  \t{\n  \t\tfor (int i=0; i < m_inChannels; i++)\n  \t\t\tfor (int j=0; j < m_outChannels; j++)\n  \t\t\t\tm_matrix[j*m_inChannels + i] = (i==j) ? 1 : 0;\n  \t}\n  }\n}"
  },
  {
    "function_name": "run",
    "container": "ApplyChannelMatrix",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/SimpleModule.cpp",
    "lines": "111-128",
    "snippet": "void ApplyChannelMatrix::run(const void *inputData, void *outputData, int frameCount)\n{\n\tconst T *input = reinterpret_cast<const T *>(inputData);\n\tT *output = reinterpret_cast<T *>(outputData);\n\tfor (int frame=0; frame<frameCount; frame++)\n\t{\n\t\tconst T *inputSave = input;\n\t\tconst double *m = m_matrix;\n\t\tfor (int outChannel=0; outChannel < m_outChannels; outChannel++)\n\t\t{\n\t\t\tinput = inputSave;\n\t\t\tdouble t = 0;\n\t\t\tfor (int inChannel=0; inChannel < m_inChannels; inChannel++)\n\t\t\t\tt += *input++ * *m++;\n\t\t\t*output++ = t;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <algorithm>",
      "#include \"SimpleModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<T *>",
          "args": [
            "outputData"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const T *>",
          "args": [
            "inputData"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include \"SimpleModule.h\"\n#include \"config.h\"\n\nApplyChannelMatrix {\n  void ApplyChannelMatrix::run(const void *inputData, void *outputData, int frameCount)\n  {\n  \tconst T *input = reinterpret_cast<const T *>(inputData);\n  \tT *output = reinterpret_cast<T *>(outputData);\n  \tfor (int frame=0; frame<frameCount; frame++)\n  \t{\n  \t\tconst T *inputSave = input;\n  \t\tconst double *m = m_matrix;\n  \t\tfor (int outChannel=0; outChannel < m_outChannels; outChannel++)\n  \t\t{\n  \t\t\tinput = inputSave;\n  \t\t\tdouble t = 0;\n  \t\t\tfor (int inChannel=0; inChannel < m_inChannels; inChannel++)\n  \t\t\t\tt += *input++ * *m++;\n  \t\t\t*output++ = t;\n  \t\t}\n  \t}\n  }\n}"
  },
  {
    "function_name": "run",
    "container": "ApplyChannelMatrix",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/SimpleModule.cpp",
    "lines": "85-108",
    "snippet": "void ApplyChannelMatrix::run(Chunk &inChunk, Chunk &outChunk)\n{\n\tswitch (m_format)\n\t{\n\t\tcase kInt8:\n\t\t\trun<int8_t>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n\t\t\tbreak;\n\t\tcase kInt16:\n\t\t\trun<int16_t>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n\t\t\tbreak;\n\t\tcase kInt24:\n\t\tcase kInt32:\n\t\t\trun<int32_t>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n\t\t\tbreak;\n\t\tcase kFloat:\n\t\t\trun<float>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n\t\t\tbreak;\n\t\tcase kDouble:\n\t\t\trun<double>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t}\n}",
    "includes": [
      "#include <algorithm>",
      "#include \"SimpleModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "false"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run<double>",
          "args": [
            "inChunk.buffer",
            "outChunk.buffer",
            "inChunk.frameCount"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": "ApplyChannelMatrix",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/SimpleModule.cpp",
          "lines": "111-128",
          "snippet": "void ApplyChannelMatrix::run(const void *inputData, void *outputData, int frameCount)\n{\n\tconst T *input = reinterpret_cast<const T *>(inputData);\n\tT *output = reinterpret_cast<T *>(outputData);\n\tfor (int frame=0; frame<frameCount; frame++)\n\t{\n\t\tconst T *inputSave = input;\n\t\tconst double *m = m_matrix;\n\t\tfor (int outChannel=0; outChannel < m_outChannels; outChannel++)\n\t\t{\n\t\t\tinput = inputSave;\n\t\t\tdouble t = 0;\n\t\t\tfor (int inChannel=0; inChannel < m_inChannels; inChannel++)\n\t\t\t\tt += *input++ * *m++;\n\t\t\t*output++ = t;\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include \"SimpleModule.h\"\n#include \"config.h\"\n\nApplyChannelMatrix {\n  void ApplyChannelMatrix::run(Chunk &inChunk, Chunk &outChunk)\n  {\n  \tswitch (m_format)\n  \t{\n  \t\tcase kInt8:\n  \t\t\trun<int8_t>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n  \t\t\tbreak;\n  \t\tcase kInt16:\n  \t\t\trun<int16_t>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n  \t\t\tbreak;\n  \t\tcase kInt24:\n  \t\tcase kInt32:\n  \t\t\trun<int32_t>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n  \t\t\tbreak;\n  \t\tcase kFloat:\n  \t\t\trun<float>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n  \t\t\tbreak;\n  \t\tcase kDouble:\n  \t\t\trun<double>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n  \t\t\tbreak;\n  \t\tdefault:\n  \t\t\tassert(false);\n  \t}\n  }\n}"
  },
  {
    "function_name": "describe",
    "container": "ApplyChannelMatrix",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/SimpleModule.cpp",
    "lines": "78-83",
    "snippet": "void ApplyChannelMatrix::describe()\n{\n\tm_outChunk->f.channelCount = m_outChannels;\n\tm_outChunk->f.pcm.minClip = m_minClip;\n\tm_outChunk->f.pcm.maxClip = m_maxClip;\n}",
    "includes": [
      "#include <algorithm>",
      "#include \"SimpleModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <algorithm>\n#include \"SimpleModule.h\"\n#include \"config.h\"\n\nApplyChannelMatrix {\n  void ApplyChannelMatrix::describe()\n  {\n  \tm_outChunk->f.channelCount = m_outChannels;\n  \tm_outChunk->f.pcm.minClip = m_minClip;\n  \tm_outChunk->f.pcm.maxClip = m_maxClip;\n  }\n}"
  },
  {
    "function_name": "~ApplyChannelMatrix",
    "container": "ApplyChannelMatrix",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/SimpleModule.cpp",
    "lines": "71-74",
    "snippet": "ApplyChannelMatrix::~ApplyChannelMatrix()\n{\n\tdelete [] m_matrix;\n}",
    "includes": [
      "#include <algorithm>",
      "#include \"SimpleModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <algorithm>\n#include \"SimpleModule.h\"\n#include \"config.h\"\n\nApplyChannelMatrix {\n  ApplyChannelMatrix::~ApplyChannelMatrix()\n  {\n  \tdelete [] m_matrix;\n  }\n}"
  },
  {
    "function_name": "ApplyChannelMatrix",
    "container": "ApplyChannelMatrix",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/SimpleModule.cpp",
    "lines": "39-69",
    "snippet": "ApplyChannelMatrix::ApplyChannelMatrix(FormatCode format, bool isReading,\n\tint inChannels, int outChannels,\n\tdouble minClip, double maxClip, const double *matrix) :\n\tm_format(format),\n\tm_inChannels(inChannels),\n\tm_outChannels(outChannels),\n\tm_minClip(minClip),\n\tm_maxClip(maxClip),\n\tm_matrix(NULL)\n{\n\tm_matrix = new double[m_inChannels * m_outChannels];\n\tif (matrix)\n\t{\n\t\tif (isReading)\n\t\t{\n\t\t\t// Copy channel matrix for reading.\n\t\t\tstd::copy(matrix, matrix + m_inChannels * m_outChannels, m_matrix);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Transpose channel matrix for writing.\n\t\t\tfor (int i=0; i < inChannels; i++)\n\t\t\t\tfor (int j=0; j < outChannels; j++)\n\t\t\t\t\tm_matrix[j*inChannels + i] = matrix[i*outChannels + j];\n\t\t}\n\t}\n\telse\n\t{\n\t\tinitDefaultMatrix();\n\t}\n}",
    "includes": [
      "#include <algorithm>",
      "#include \"SimpleModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "initDefaultMatrix",
          "args": [],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "initDefaultMatrix",
          "container": "ApplyChannelMatrix",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/SimpleModule.cpp",
          "lines": "130-174",
          "snippet": "void ApplyChannelMatrix::initDefaultMatrix()\n{\n\tconst double *matrix = NULL;\n\tif (m_inChannels==1 && m_outChannels==2)\n\t{\n\t\tstatic const double m[]={1,1};\n\t\tmatrix = m;\n\t}\n\telse if (m_inChannels==1 && m_outChannels==4)\n\t{\n\t\tstatic const double m[]={1,1,0,0};\n\t\tmatrix = m;\n\t}\n\telse if (m_inChannels==2 && m_outChannels==1)\n\t{\n\t\tstatic const double m[]={.5,.5};\n\t\tmatrix = m;\n\t}\n\telse if (m_inChannels==2 && m_outChannels==4)\n\t{\n\t\tstatic const double m[]={1,0,0,1,0,0,0,0};\n\t\tmatrix = m;\n\t}\n\telse if (m_inChannels==4 && m_outChannels==1)\n\t{\n\t\tstatic const double m[]={.5,.5,.5,.5};\n\t\tmatrix = m;\n\t}\n\telse if (m_inChannels==4 && m_outChannels==2)\n\t{\n\t\tstatic const double m[]={1,0,1,0,0,1,0,1};\n\t\tmatrix = m;\n\t}\n\n\tif (matrix)\n\t{\n\t\tstd::copy(matrix, matrix + m_inChannels * m_outChannels, m_matrix);\n\t}\n\telse\n\t{\n\t\tfor (int i=0; i < m_inChannels; i++)\n\t\t\tfor (int j=0; j < m_outChannels; j++)\n\t\t\t\tm_matrix[j*m_inChannels + i] = (i==j) ? 1 : 0;\n\t}\n}",
          "includes": [
            "#include <algorithm>",
            "#include \"SimpleModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"SimpleModule.h\"\n#include \"config.h\"\n\nApplyChannelMatrix {\n  void ApplyChannelMatrix::initDefaultMatrix()\n  {\n  \tconst double *matrix = NULL;\n  \tif (m_inChannels==1 && m_outChannels==2)\n  \t{\n  \t\tstatic const double m[]={1,1};\n  \t\tmatrix = m;\n  \t}\n  \telse if (m_inChannels==1 && m_outChannels==4)\n  \t{\n  \t\tstatic const double m[]={1,1,0,0};\n  \t\tmatrix = m;\n  \t}\n  \telse if (m_inChannels==2 && m_outChannels==1)\n  \t{\n  \t\tstatic const double m[]={.5,.5};\n  \t\tmatrix = m;\n  \t}\n  \telse if (m_inChannels==2 && m_outChannels==4)\n  \t{\n  \t\tstatic const double m[]={1,0,0,1,0,0,0,0};\n  \t\tmatrix = m;\n  \t}\n  \telse if (m_inChannels==4 && m_outChannels==1)\n  \t{\n  \t\tstatic const double m[]={.5,.5,.5,.5};\n  \t\tmatrix = m;\n  \t}\n  \telse if (m_inChannels==4 && m_outChannels==2)\n  \t{\n  \t\tstatic const double m[]={1,0,1,0,0,1,0,1};\n  \t\tmatrix = m;\n  \t}\n  \n  \tif (matrix)\n  \t{\n  \t\tstd::copy(matrix, matrix + m_inChannels * m_outChannels, m_matrix);\n  \t}\n  \telse\n  \t{\n  \t\tfor (int i=0; i < m_inChannels; i++)\n  \t\t\tfor (int j=0; j < m_outChannels; j++)\n  \t\t\t\tm_matrix[j*m_inChannels + i] = (i==j) ? 1 : 0;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::copy",
          "args": [
            "matrix",
            "matrix + m_inChannels * m_outChannels",
            "m_matrix"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include \"SimpleModule.h\"\n#include \"config.h\"\n\nApplyChannelMatrix {\n  ApplyChannelMatrix::ApplyChannelMatrix(FormatCode format, bool isReading,\n  \tint inChannels, int outChannels,\n  \tdouble minClip, double maxClip, const double *matrix) :\n  \tm_format(format),\n  \tm_inChannels(inChannels),\n  \tm_outChannels(outChannels),\n  \tm_minClip(minClip),\n  \tm_maxClip(maxClip),\n  \tm_matrix(NULL)\n  {\n  \tm_matrix = new double[m_inChannels * m_outChannels];\n  \tif (matrix)\n  \t{\n  \t\tif (isReading)\n  \t\t{\n  \t\t\t// Copy channel matrix for reading.\n  \t\t\tstd::copy(matrix, matrix + m_inChannels * m_outChannels, m_matrix);\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\t// Transpose channel matrix for writing.\n  \t\t\tfor (int i=0; i < inChannels; i++)\n  \t\t\t\tfor (int j=0; j < outChannels; j++)\n  \t\t\t\t\tm_matrix[j*inChannels + i] = matrix[i*outChannels + j];\n  \t\t}\n  \t}\n  \telse\n  \t{\n  \t\tinitDefaultMatrix();\n  \t}\n  }\n}"
  },
  {
    "function_name": "runPush",
    "container": "SimpleModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/SimpleModule.cpp",
    "lines": "32-37",
    "snippet": "void SimpleModule::runPush()\n{\n\tm_outChunk->frameCount = m_inChunk->frameCount;\n\trun(*m_inChunk, *m_outChunk);\n\tpush(m_outChunk->frameCount);\n}",
    "includes": [
      "#include <algorithm>",
      "#include \"SimpleModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "push",
          "args": [
            "m_outChunk->frameCount"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "push",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.cpp",
          "lines": "74-78",
          "snippet": "void Module::push(size_t frames)\n{\n\tm_outChunk->frameCount = frames;\n\tm_sink->runPush();\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"File.h\"",
            "#include \"Module.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"SimpleModule.h\"\n#include \"File.h\"\n#include \"Module.h\"\n#include \"config.h\"\n\nModule {\n  void Module::push(size_t frames)\n  {\n  \tm_outChunk->frameCount = frames;\n  \tm_sink->runPush();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "run",
          "args": [
            "*m_inChunk",
            "*m_outChunk"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": "ApplyChannelMatrix",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/SimpleModule.cpp",
          "lines": "85-108",
          "snippet": "void ApplyChannelMatrix::run(Chunk &inChunk, Chunk &outChunk)\n{\n\tswitch (m_format)\n\t{\n\t\tcase kInt8:\n\t\t\trun<int8_t>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n\t\t\tbreak;\n\t\tcase kInt16:\n\t\t\trun<int16_t>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n\t\t\tbreak;\n\t\tcase kInt24:\n\t\tcase kInt32:\n\t\t\trun<int32_t>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n\t\t\tbreak;\n\t\tcase kFloat:\n\t\t\trun<float>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n\t\t\tbreak;\n\t\tcase kDouble:\n\t\t\trun<double>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t}\n}",
          "includes": [
            "#include <algorithm>",
            "#include \"SimpleModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"SimpleModule.h\"\n#include \"config.h\"\n\nApplyChannelMatrix {\n  void ApplyChannelMatrix::run(Chunk &inChunk, Chunk &outChunk)\n  {\n  \tswitch (m_format)\n  \t{\n  \t\tcase kInt8:\n  \t\t\trun<int8_t>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n  \t\t\tbreak;\n  \t\tcase kInt16:\n  \t\t\trun<int16_t>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n  \t\t\tbreak;\n  \t\tcase kInt24:\n  \t\tcase kInt32:\n  \t\t\trun<int32_t>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n  \t\t\tbreak;\n  \t\tcase kFloat:\n  \t\t\trun<float>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n  \t\t\tbreak;\n  \t\tcase kDouble:\n  \t\t\trun<double>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n  \t\t\tbreak;\n  \t\tdefault:\n  \t\t\tassert(false);\n  \t}\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include \"SimpleModule.h\"\n#include \"config.h\"\n\nSimpleModule {\n  void SimpleModule::runPush()\n  {\n  \tm_outChunk->frameCount = m_inChunk->frameCount;\n  \trun(*m_inChunk, *m_outChunk);\n  \tpush(m_outChunk->frameCount);\n  }\n}"
  },
  {
    "function_name": "runPull",
    "container": "SimpleModule",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/SimpleModule.cpp",
    "lines": "26-30",
    "snippet": "void SimpleModule::runPull()\n{\n\tpull(m_outChunk->frameCount);\n\trun(*m_inChunk, *m_outChunk);\n}",
    "includes": [
      "#include <algorithm>",
      "#include \"SimpleModule.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "run",
          "args": [
            "*m_inChunk",
            "*m_outChunk"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": "ApplyChannelMatrix",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/SimpleModule.cpp",
          "lines": "85-108",
          "snippet": "void ApplyChannelMatrix::run(Chunk &inChunk, Chunk &outChunk)\n{\n\tswitch (m_format)\n\t{\n\t\tcase kInt8:\n\t\t\trun<int8_t>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n\t\t\tbreak;\n\t\tcase kInt16:\n\t\t\trun<int16_t>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n\t\t\tbreak;\n\t\tcase kInt24:\n\t\tcase kInt32:\n\t\t\trun<int32_t>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n\t\t\tbreak;\n\t\tcase kFloat:\n\t\t\trun<float>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n\t\t\tbreak;\n\t\tcase kDouble:\n\t\t\trun<double>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t}\n}",
          "includes": [
            "#include <algorithm>",
            "#include \"SimpleModule.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"SimpleModule.h\"\n#include \"config.h\"\n\nApplyChannelMatrix {\n  void ApplyChannelMatrix::run(Chunk &inChunk, Chunk &outChunk)\n  {\n  \tswitch (m_format)\n  \t{\n  \t\tcase kInt8:\n  \t\t\trun<int8_t>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n  \t\t\tbreak;\n  \t\tcase kInt16:\n  \t\t\trun<int16_t>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n  \t\t\tbreak;\n  \t\tcase kInt24:\n  \t\tcase kInt32:\n  \t\t\trun<int32_t>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n  \t\t\tbreak;\n  \t\tcase kFloat:\n  \t\t\trun<float>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n  \t\t\tbreak;\n  \t\tcase kDouble:\n  \t\t\trun<double>(inChunk.buffer, outChunk.buffer, inChunk.frameCount);\n  \t\t\tbreak;\n  \t\tdefault:\n  \t\t\tassert(false);\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pull",
          "args": [
            "m_outChunk->frameCount"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "pull",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.cpp",
          "lines": "68-72",
          "snippet": "void Module::pull(size_t frames)\n{\n\tm_inChunk->frameCount = frames;\n\tm_source->runPull();\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"File.h\"",
            "#include \"Module.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"SimpleModule.h\"\n#include \"File.h\"\n#include \"Module.h\"\n#include \"config.h\"\n\nModule {\n  void Module::pull(size_t frames)\n  {\n  \tm_inChunk->frameCount = frames;\n  \tm_source->runPull();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include \"SimpleModule.h\"\n#include \"config.h\"\n\nSimpleModule {\n  void SimpleModule::runPull()\n  {\n  \tpull(m_outChunk->frameCount);\n  \trun(*m_inChunk, *m_outChunk);\n  }\n}"
  }
]