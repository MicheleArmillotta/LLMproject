[
  {
    "function_name": "update",
    "container": "NISTFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/NIST.cpp",
    "lines": "456-462",
    "snippet": "status NISTFile::update()\n{\n\tm_fh->seek(0, File::SeekFromBeginning);\n\twriteHeader();\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"File.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"NIST.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeHeader",
          "args": [],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "writeHeader",
          "container": "NISTFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/NIST.cpp",
          "lines": "411-439",
          "snippet": "status NISTFile::writeHeader()\n{\n\tTrack *track = getTrack();\n\n\tchar header[NIST_SPHERE_HEADER_LENGTH];\n\tint printed = snprintf(header, NIST_SPHERE_HEADER_LENGTH,\n\t\t\"NIST_1A\\n   1024\\n\"\n\t\t\"channel_count -i %d\\n\"\n\t\t\"sample_count -i %d\\n\"\n\t\t\"sample_rate -i %d\\n\"\n\t\t\"sample_n_bytes -i %d\\n\"\n\t\t\"sample_byte_format -s%d %s\\n\"\n\t\t\"sample_sig_bits -i %d\\n\"\n\t\t\"sample_coding -s%d %s\\n\"\n\t\t\"end_head\\n\",\n\t\ttrack->f.channelCount,\n\t\t(int) track->totalfframes,\n\t\t(int) track->f.sampleRate,\n\t\t(int) _af_format_sample_size(&track->f, false),\n\t\t(int) _af_format_sample_size(&track->f, false), sample_byte_format(&track->f),\n\t\ttrack->f.sampleWidth,\n\t\t(int) strlen(sample_coding(&track->f)), sample_coding(&track->f));\n\n\t/* Fill the remaining space in the buffer with space characters. */\n\tif (printed < NIST_SPHERE_HEADER_LENGTH)\n\t\tmemset(header + printed, ' ', NIST_SPHERE_HEADER_LENGTH - printed);\n\n\treturn m_fh->write(header, NIST_SPHERE_HEADER_LENGTH) == NIST_SPHERE_HEADER_LENGTH ? AF_SUCCEED : AF_FAIL;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"File.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"NIST.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NIST_SPHERE_HEADER_LENGTH 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"File.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"NIST.h\"\n#include \"config.h\"\n\n#define NIST_SPHERE_HEADER_LENGTH 1024\n\nNISTFile {\n  status NISTFile::writeHeader()\n  {\n  \tTrack *track = getTrack();\n  \n  \tchar header[NIST_SPHERE_HEADER_LENGTH];\n  \tint printed = snprintf(header, NIST_SPHERE_HEADER_LENGTH,\n  \t\t\"NIST_1A\\n   1024\\n\"\n  \t\t\"channel_count -i %d\\n\"\n  \t\t\"sample_count -i %d\\n\"\n  \t\t\"sample_rate -i %d\\n\"\n  \t\t\"sample_n_bytes -i %d\\n\"\n  \t\t\"sample_byte_format -s%d %s\\n\"\n  \t\t\"sample_sig_bits -i %d\\n\"\n  \t\t\"sample_coding -s%d %s\\n\"\n  \t\t\"end_head\\n\",\n  \t\ttrack->f.channelCount,\n  \t\t(int) track->totalfframes,\n  \t\t(int) track->f.sampleRate,\n  \t\t(int) _af_format_sample_size(&track->f, false),\n  \t\t(int) _af_format_sample_size(&track->f, false), sample_byte_format(&track->f),\n  \t\ttrack->f.sampleWidth,\n  \t\t(int) strlen(sample_coding(&track->f)), sample_coding(&track->f));\n  \n  \t/* Fill the remaining space in the buffer with space characters. */\n  \tif (printed < NIST_SPHERE_HEADER_LENGTH)\n  \t\tmemset(header + printed, ' ', NIST_SPHERE_HEADER_LENGTH - printed);\n  \n  \treturn m_fh->write(header, NIST_SPHERE_HEADER_LENGTH) == NIST_SPHERE_HEADER_LENGTH ? AF_SUCCEED : AF_FAIL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "0",
            "File::SeekFromBeginning"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"File.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"NIST.h\"\n#include \"config.h\"\n\nNISTFile {\n  status NISTFile::update()\n  {\n  \tm_fh->seek(0, File::SeekFromBeginning);\n  \twriteHeader();\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeInit",
    "container": "NISTFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/NIST.cpp",
    "lines": "441-454",
    "snippet": "status NISTFile::writeInit(AFfilesetup setup)\n{\n\tif (initFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\n\tTrack *track = getTrack();\n\n\ttrack->fpos_first_frame = NIST_SPHERE_HEADER_LENGTH;\n\n\tm_fh->seek(0, File::SeekFromBeginning);\n\twriteHeader();\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"File.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"NIST.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NIST_SPHERE_HEADER_LENGTH 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeHeader",
          "args": [],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "writeHeader",
          "container": "NISTFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/NIST.cpp",
          "lines": "411-439",
          "snippet": "status NISTFile::writeHeader()\n{\n\tTrack *track = getTrack();\n\n\tchar header[NIST_SPHERE_HEADER_LENGTH];\n\tint printed = snprintf(header, NIST_SPHERE_HEADER_LENGTH,\n\t\t\"NIST_1A\\n   1024\\n\"\n\t\t\"channel_count -i %d\\n\"\n\t\t\"sample_count -i %d\\n\"\n\t\t\"sample_rate -i %d\\n\"\n\t\t\"sample_n_bytes -i %d\\n\"\n\t\t\"sample_byte_format -s%d %s\\n\"\n\t\t\"sample_sig_bits -i %d\\n\"\n\t\t\"sample_coding -s%d %s\\n\"\n\t\t\"end_head\\n\",\n\t\ttrack->f.channelCount,\n\t\t(int) track->totalfframes,\n\t\t(int) track->f.sampleRate,\n\t\t(int) _af_format_sample_size(&track->f, false),\n\t\t(int) _af_format_sample_size(&track->f, false), sample_byte_format(&track->f),\n\t\ttrack->f.sampleWidth,\n\t\t(int) strlen(sample_coding(&track->f)), sample_coding(&track->f));\n\n\t/* Fill the remaining space in the buffer with space characters. */\n\tif (printed < NIST_SPHERE_HEADER_LENGTH)\n\t\tmemset(header + printed, ' ', NIST_SPHERE_HEADER_LENGTH - printed);\n\n\treturn m_fh->write(header, NIST_SPHERE_HEADER_LENGTH) == NIST_SPHERE_HEADER_LENGTH ? AF_SUCCEED : AF_FAIL;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"File.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"NIST.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NIST_SPHERE_HEADER_LENGTH 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"File.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"NIST.h\"\n#include \"config.h\"\n\n#define NIST_SPHERE_HEADER_LENGTH 1024\n\nNISTFile {\n  status NISTFile::writeHeader()\n  {\n  \tTrack *track = getTrack();\n  \n  \tchar header[NIST_SPHERE_HEADER_LENGTH];\n  \tint printed = snprintf(header, NIST_SPHERE_HEADER_LENGTH,\n  \t\t\"NIST_1A\\n   1024\\n\"\n  \t\t\"channel_count -i %d\\n\"\n  \t\t\"sample_count -i %d\\n\"\n  \t\t\"sample_rate -i %d\\n\"\n  \t\t\"sample_n_bytes -i %d\\n\"\n  \t\t\"sample_byte_format -s%d %s\\n\"\n  \t\t\"sample_sig_bits -i %d\\n\"\n  \t\t\"sample_coding -s%d %s\\n\"\n  \t\t\"end_head\\n\",\n  \t\ttrack->f.channelCount,\n  \t\t(int) track->totalfframes,\n  \t\t(int) track->f.sampleRate,\n  \t\t(int) _af_format_sample_size(&track->f, false),\n  \t\t(int) _af_format_sample_size(&track->f, false), sample_byte_format(&track->f),\n  \t\ttrack->f.sampleWidth,\n  \t\t(int) strlen(sample_coding(&track->f)), sample_coding(&track->f));\n  \n  \t/* Fill the remaining space in the buffer with space characters. */\n  \tif (printed < NIST_SPHERE_HEADER_LENGTH)\n  \t\tmemset(header + printed, ' ', NIST_SPHERE_HEADER_LENGTH - printed);\n  \n  \treturn m_fh->write(header, NIST_SPHERE_HEADER_LENGTH) == NIST_SPHERE_HEADER_LENGTH ? AF_SUCCEED : AF_FAIL;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "0",
            "File::SeekFromBeginning"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initFromSetup",
          "args": [
            "setup"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "initFromSetup",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "222-231",
          "snippet": "status _AFfilehandle::initFromSetup(AFfilesetup setup)\n{\n\tif (copyTracksFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\tif (copyInstrumentsFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\tif (copyMiscellaneousFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  status _AFfilehandle::initFromSetup(AFfilesetup setup)\n  {\n  \tif (copyTracksFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \tif (copyInstrumentsFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \tif (copyMiscellaneousFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \treturn AF_SUCCEED;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"File.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"NIST.h\"\n#include \"config.h\"\n\n#define NIST_SPHERE_HEADER_LENGTH 1024\n\nNISTFile {\n  status NISTFile::writeInit(AFfilesetup setup)\n  {\n  \tif (initFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \n  \tTrack *track = getTrack();\n  \n  \ttrack->fpos_first_frame = NIST_SPHERE_HEADER_LENGTH;\n  \n  \tm_fh->seek(0, File::SeekFromBeginning);\n  \twriteHeader();\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeHeader",
    "container": "NISTFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/NIST.cpp",
    "lines": "411-439",
    "snippet": "status NISTFile::writeHeader()\n{\n\tTrack *track = getTrack();\n\n\tchar header[NIST_SPHERE_HEADER_LENGTH];\n\tint printed = snprintf(header, NIST_SPHERE_HEADER_LENGTH,\n\t\t\"NIST_1A\\n   1024\\n\"\n\t\t\"channel_count -i %d\\n\"\n\t\t\"sample_count -i %d\\n\"\n\t\t\"sample_rate -i %d\\n\"\n\t\t\"sample_n_bytes -i %d\\n\"\n\t\t\"sample_byte_format -s%d %s\\n\"\n\t\t\"sample_sig_bits -i %d\\n\"\n\t\t\"sample_coding -s%d %s\\n\"\n\t\t\"end_head\\n\",\n\t\ttrack->f.channelCount,\n\t\t(int) track->totalfframes,\n\t\t(int) track->f.sampleRate,\n\t\t(int) _af_format_sample_size(&track->f, false),\n\t\t(int) _af_format_sample_size(&track->f, false), sample_byte_format(&track->f),\n\t\ttrack->f.sampleWidth,\n\t\t(int) strlen(sample_coding(&track->f)), sample_coding(&track->f));\n\n\t/* Fill the remaining space in the buffer with space characters. */\n\tif (printed < NIST_SPHERE_HEADER_LENGTH)\n\t\tmemset(header + printed, ' ', NIST_SPHERE_HEADER_LENGTH - printed);\n\n\treturn m_fh->write(header, NIST_SPHERE_HEADER_LENGTH) == NIST_SPHERE_HEADER_LENGTH ? AF_SUCCEED : AF_FAIL;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"File.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"NIST.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NIST_SPHERE_HEADER_LENGTH 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "header",
            "NIST_SPHERE_HEADER_LENGTH"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "header + printed",
            "' '",
            "NIST_SPHERE_HEADER_LENGTH - printed"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "header",
            "NIST_SPHERE_HEADER_LENGTH",
            "\"NIST_1A\\n   1024\\n\"\n\t\t\"channel_count -i %d\\n\"\n\t\t\"sample_count -i %d\\n\"\n\t\t\"sample_rate -i %d\\n\"\n\t\t\"sample_n_bytes -i %d\\n\"\n\t\t\"sample_byte_format -s%d %s\\n\"\n\t\t\"sample_sig_bits -i %d\\n\"\n\t\t\"sample_coding -s%d %s\\n\"\n\t\t\"end_head\\n\"",
            "track->f.channelCount",
            "(int) track->totalfframes",
            "(int) track->f.sampleRate",
            "(int) _af_format_sample_size(&track->f, false)",
            "(int) _af_format_sample_size(&track->f, false)",
            "sample_byte_format(&track->f)",
            "track->f.sampleWidth",
            "(int) strlen(sample_coding(&track->f))",
            "sample_coding(&track->f)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sample_coding",
          "args": [
            "&track->f"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sample_coding(&track->f)"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sample_coding",
          "args": [
            "&track->f"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sample_byte_format",
          "args": [
            "&track->f"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_format_sample_size",
          "args": [
            "&track->f",
            "false"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "_af_format_sample_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "286-293",
          "snippet": "float _af_format_sample_size (const AudioFormat *fmt, bool stretch3to4)\n{\n\tconst CompressionUnit *unit = _af_compression_unit_from_id(fmt->compressionType);\n\tfloat squishFactor = unit->squishFactor;\n\n\treturn _af_format_sample_size_uncompressed(fmt, stretch3to4) /\n\t\tsquishFactor;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nfloat _af_format_sample_size (const AudioFormat *fmt, bool stretch3to4)\n{\n\tconst CompressionUnit *unit = _af_compression_unit_from_id(fmt->compressionType);\n\tfloat squishFactor = unit->squishFactor;\n\n\treturn _af_format_sample_size_uncompressed(fmt, stretch3to4) /\n\t\tsquishFactor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"File.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"NIST.h\"\n#include \"config.h\"\n\n#define NIST_SPHERE_HEADER_LENGTH 1024\n\nNISTFile {\n  status NISTFile::writeHeader()\n  {\n  \tTrack *track = getTrack();\n  \n  \tchar header[NIST_SPHERE_HEADER_LENGTH];\n  \tint printed = snprintf(header, NIST_SPHERE_HEADER_LENGTH,\n  \t\t\"NIST_1A\\n   1024\\n\"\n  \t\t\"channel_count -i %d\\n\"\n  \t\t\"sample_count -i %d\\n\"\n  \t\t\"sample_rate -i %d\\n\"\n  \t\t\"sample_n_bytes -i %d\\n\"\n  \t\t\"sample_byte_format -s%d %s\\n\"\n  \t\t\"sample_sig_bits -i %d\\n\"\n  \t\t\"sample_coding -s%d %s\\n\"\n  \t\t\"end_head\\n\",\n  \t\ttrack->f.channelCount,\n  \t\t(int) track->totalfframes,\n  \t\t(int) track->f.sampleRate,\n  \t\t(int) _af_format_sample_size(&track->f, false),\n  \t\t(int) _af_format_sample_size(&track->f, false), sample_byte_format(&track->f),\n  \t\ttrack->f.sampleWidth,\n  \t\t(int) strlen(sample_coding(&track->f)), sample_coding(&track->f));\n  \n  \t/* Fill the remaining space in the buffer with space characters. */\n  \tif (printed < NIST_SPHERE_HEADER_LENGTH)\n  \t\tmemset(header + printed, ' ', NIST_SPHERE_HEADER_LENGTH - printed);\n  \n  \treturn m_fh->write(header, NIST_SPHERE_HEADER_LENGTH) == NIST_SPHERE_HEADER_LENGTH ? AF_SUCCEED : AF_FAIL;\n  }\n}"
  },
  {
    "function_name": "readInit",
    "container": "NISTFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/NIST.cpp",
    "lines": "195-376",
    "snippet": "status NISTFile::readInit(AFfilesetup setup)\n{\n\tchar header[NIST_SPHERE_HEADER_LENGTH + 1];\n\tint intval;\n\tchar strval[NIST_SPHERE_MAX_FIELD_LENGTH];\n\tint sample_n_bytes;\n\n\tm_fh->seek(0, File::SeekFromBeginning);\n\n\tif (m_fh->read(header, NIST_SPHERE_HEADER_LENGTH) != NIST_SPHERE_HEADER_LENGTH)\n\t{\n\t\t_af_error(AF_BAD_READ, \"Could not read NIST SPHERE file header\");\n\t\treturn AF_FAIL;\n\t}\n\n\theader[NIST_SPHERE_HEADER_LENGTH] = '\\0';\n\n\tif (memcmp(header, \"NIST_1A\\n   1024\\n\", 16) != 0)\n\t{\n\t\t_af_error(AF_BAD_FILEFMT, \"Bad NIST SPHERE file header\");\n\t\treturn AF_FAIL;\n\t}\n\n\tTrack *track = allocateTrack();\n\tif (!track)\n\t\treturn AF_FAIL;\n\n\t// Read channel count.\n\tif (nist_header_read_int(header, \"channel_count\", &intval))\n\t{\n\t\tif (intval < 1)\n\t\t{\n\t\t\t_af_error(AF_BAD_CHANNELS, \"invalid number of channels %d\",\n\t\t\t\tintval);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\ttrack->f.channelCount = intval;\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_HEADER, \"number of channels not specified\");\n\t\treturn AF_FAIL;\n\t}\n\n\t// Read number of bytes per sample.\n\tif (!nist_header_read_int(header, \"sample_n_bytes\", &sample_n_bytes))\n\t{\n\t\t_af_error(AF_BAD_HEADER, \"bytes per sample not specified\");\n\t\treturn AF_FAIL;\n\t}\n\n\ttrack->f.framesPerPacket = 1;\n\n\t/*\n\t\tSince some older NIST SPHERE files lack a sample_coding\n\t\tfield, if sample_n_bytes is 1, assume mu-law;\n\t\totherwise assume linear PCM.\n\t*/\n\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\tif (sample_n_bytes == 1)\n\t{\n\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n\t\ttrack->f.sampleWidth = 16;\n\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n\t}\n\telse\n\t{\n\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\t\ttrack->f.sampleWidth = sample_n_bytes * 8;\n\t\ttrack->f.computeBytesPerPacketPCM();\n\t}\n\n\tif (nist_header_read_string(header, \"sample_coding\", &intval, strval))\n\t{\n\t\tif (strcmp(strval, \"pcm\") == 0)\n\t\t\t;\n\t\telse if (strcmp(strval, \"ulaw\") == 0 || strcmp(strval, \"mu-law\") == 0)\n\t\t{\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t}\n\t\telse if (strcmp(strval, \"alaw\") == 0)\n\t\t{\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"unrecognized NIST SPHERE sample format %s\", strval);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t}\n\n\t// Read string representing byte order.\n\tif (nist_header_read_string(header, \"sample_byte_format\", &intval, strval))\n\t{\n\t\tif (intval > 1)\n\t\t{\n\t\t\tif (strncmp(strval, \"01\", 2) == 0)\n\t\t\t\ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n\t\t\telse\n\t\t\t\ttrack->f.byteOrder = AF_BYTEORDER_BIGENDIAN;\n\t\t}\n\t\telse\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t\tFail if this field is not present and sample\n\t\t\twidth is more than one byte.\n\t\t*/\n\t\tif (track->f.compressionType == AF_COMPRESSION_NONE &&\n\t\t\ttrack->f.sampleWidth > 8)\n\t\t{\n\t\t\t_af_error(AF_BAD_HEADER, \"sample byte order not specified\");\n\t\t\treturn AF_FAIL;\n\t\t}\n\t}\n\n\t// Read significant bits per sample.\n\tif (nist_header_read_int(header, \"sample_sig_bits\", &intval))\n\t{\n\t\tif (intval < 1 || intval > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_WIDTH, \"invalid sample width %d bits\\n\",\n\t\t\t\tintval);\n\t\t\treturn AF_FAIL;\n\t\t}\n\n\t\t/*\n\t\t\tUse specified significant bits value as the\n\t\t\tsample width for uncompressed data as long\n\t\t\tas the number of bytes per sample remains\n\t\t\tunchanged.\n\t\t*/\n\t\tif (track->f.compressionType == AF_COMPRESSION_NONE &&\n\t\t\t(intval + 7) / 8 == sample_n_bytes)\n\t\t{\n\t\t\ttrack->f.sampleWidth = intval;\n\t\t}\n\t}\n\n\t// Read sample rate.\n\tif (nist_header_read_int(header, \"sample_rate\", &intval))\n\t{\n\t\tif (intval <= 0)\n\t\t{\n\t\t\t_af_error(AF_BAD_RATE, \"invalid sample rate %d Hz\\n\", intval);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\ttrack->f.sampleRate = intval;\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_HEADER, \"sample rate not specified\");\n\t\treturn AF_FAIL;\n\t}\n\n\t// Read sample count.\n\tif (nist_header_read_int(header, \"sample_count\", &intval))\n\t{\n\t\ttrack->totalfframes = intval;\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_HEADER, \"number of samples not specified\");\n\t\treturn AF_FAIL;\n\t}\n\n\tif (_af_set_sample_format(&track->f, track->f.sampleFormat,\n\t\ttrack->f.sampleWidth) == AF_FAIL)\n\t{\n\t\treturn AF_FAIL;\n\t}\n\n\ttrack->fpos_first_frame = NIST_SPHERE_HEADER_LENGTH;\n\ttrack->data_size = m_fh->length() - NIST_SPHERE_HEADER_LENGTH;\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"File.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"NIST.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NIST_SPHERE_MAX_FIELD_LENGTH 80",
      "#define NIST_SPHERE_HEADER_LENGTH 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->length",
          "args": [],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "182-185",
          "snippet": "off_t FileVF::length()\n{\n\treturn m_vf->length(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::length()\n  {\n  \treturn m_vf->length(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_set_sample_format",
          "args": [
            "&track->f",
            "track->f.sampleFormat",
            "track->f.sampleWidth"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "_af_set_sample_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "315-361",
          "snippet": "status _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatus _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_HEADER",
            "\"number of samples not specified\""
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nist_header_read_int",
          "args": [
            "header",
            "\"sample_count\"",
            "&intval"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "nist_header_read_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/NIST.cpp",
          "lines": "161-176",
          "snippet": "static bool nist_header_read_int (const char *header, const char *key, int *val)\n{\n\tconst char *cp;\n\tchar keystring[256], scanstring[256];\n\n\tsnprintf(keystring, 256, \"\\n%s -i\", key);\n\n\tif ((cp = strstr(header, keystring)) != NULL)\n\t{\n\t\tsnprintf(scanstring, 256, \"\\n%s -i %%d\", key);\n\t\tsscanf(cp, scanstring, val);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"File.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"NIST.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"File.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"NIST.h\"\n#include \"config.h\"\n\nstatic bool nist_header_read_int (const char *header, const char *key, int *val)\n{\n\tconst char *cp;\n\tchar keystring[256], scanstring[256];\n\n\tsnprintf(keystring, 256, \"\\n%s -i\", key);\n\n\tif ((cp = strstr(header, keystring)) != NULL)\n\t{\n\t\tsnprintf(scanstring, 256, \"\\n%s -i %%d\", key);\n\t\tsscanf(cp, scanstring, val);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_HEADER",
            "\"sample rate not specified\""
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_RATE",
            "\"invalid sample rate %d Hz\\n\"",
            "intval"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_WIDTH",
            "\"invalid sample width %d bits\\n\"",
            "intval"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_HEADER",
            "\"sample byte order not specified\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "strval",
            "\"01\"",
            "2"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nist_header_read_string",
          "args": [
            "header",
            "\"sample_byte_format\"",
            "&intval",
            "strval"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "nist_header_read_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/NIST.cpp",
          "lines": "178-193",
          "snippet": "static bool nist_header_read_string (const char *header, const char *key, int *length, char *val)\n{\n\tconst char *cp;\n\tchar keystring[256], scanstring[256];\n\n\tsnprintf(keystring, 256, \"\\n%s -s\", key);\n\n\tif ((cp = strstr(header, keystring)) != NULL)\n\t{\n\t\tsnprintf(scanstring, 256, \"\\n%s -s%%d %%79s\", key);\n\t\tsscanf(cp, scanstring, length, val);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"File.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <assert.h>",
            "#include \"NIST.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"File.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"NIST.h\"\n#include \"config.h\"\n\nstatic bool nist_header_read_string (const char *header, const char *key, int *length, char *val)\n{\n\tconst char *cp;\n\tchar keystring[256], scanstring[256];\n\n\tsnprintf(keystring, 256, \"\\n%s -s\", key);\n\n\tif ((cp = strstr(header, keystring)) != NULL)\n\t{\n\t\tsnprintf(scanstring, 256, \"\\n%s -s%%d %%79s\", key);\n\t\tsscanf(cp, scanstring, length, val);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_SAMPFMT",
            "\"unrecognized NIST SPHERE sample format %s\"",
            "strval"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "strval",
            "\"alaw\""
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "strval",
            "\"mu-law\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "strval",
            "\"ulaw\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "strval",
            "\"pcm\""
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track->f.computeBytesPerPacketPCM",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "computeBytesPerPacketPCM",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "98-103",
          "snippet": "void AudioFormat::computeBytesPerPacketPCM()\n{\n\tassert(isUncompressed());\n\tint bytesPerSample = (sampleWidth + 7) / 8;\n\tbytesPerPacket = bytesPerSample * channelCount;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  void AudioFormat::computeBytesPerPacketPCM()\n  {\n  \tassert(isUncompressed());\n  \tint bytesPerSample = (sampleWidth + 7) / 8;\n  \tbytesPerPacket = bytesPerSample * channelCount;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_HEADER",
            "\"bytes per sample not specified\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_HEADER",
            "\"number of channels not specified\""
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_CHANNELS",
            "\"invalid number of channels %d\"",
            "intval"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocateTrack",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_FILEFMT",
            "\"Bad NIST SPHERE file header\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "header",
            "\"NIST_1A\\n   1024\\n\"",
            "16"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_READ",
            "\"Could not read NIST SPHERE file header\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fh->read",
          "args": [
            "header",
            "NIST_SPHERE_HEADER_LENGTH"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "0",
            "File::SeekFromBeginning"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"File.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"NIST.h\"\n#include \"config.h\"\n\n#define NIST_SPHERE_MAX_FIELD_LENGTH 80\n#define NIST_SPHERE_HEADER_LENGTH 1024\n\nNISTFile {\n  status NISTFile::readInit(AFfilesetup setup)\n  {\n  \tchar header[NIST_SPHERE_HEADER_LENGTH + 1];\n  \tint intval;\n  \tchar strval[NIST_SPHERE_MAX_FIELD_LENGTH];\n  \tint sample_n_bytes;\n  \n  \tm_fh->seek(0, File::SeekFromBeginning);\n  \n  \tif (m_fh->read(header, NIST_SPHERE_HEADER_LENGTH) != NIST_SPHERE_HEADER_LENGTH)\n  \t{\n  \t\t_af_error(AF_BAD_READ, \"Could not read NIST SPHERE file header\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \theader[NIST_SPHERE_HEADER_LENGTH] = '\\0';\n  \n  \tif (memcmp(header, \"NIST_1A\\n   1024\\n\", 16) != 0)\n  \t{\n  \t\t_af_error(AF_BAD_FILEFMT, \"Bad NIST SPHERE file header\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \tTrack *track = allocateTrack();\n  \tif (!track)\n  \t\treturn AF_FAIL;\n  \n  \t// Read channel count.\n  \tif (nist_header_read_int(header, \"channel_count\", &intval))\n  \t{\n  \t\tif (intval < 1)\n  \t\t{\n  \t\t\t_af_error(AF_BAD_CHANNELS, \"invalid number of channels %d\",\n  \t\t\t\tintval);\n  \t\t\treturn AF_FAIL;\n  \t\t}\n  \t\ttrack->f.channelCount = intval;\n  \t}\n  \telse\n  \t{\n  \t\t_af_error(AF_BAD_HEADER, \"number of channels not specified\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \t// Read number of bytes per sample.\n  \tif (!nist_header_read_int(header, \"sample_n_bytes\", &sample_n_bytes))\n  \t{\n  \t\t_af_error(AF_BAD_HEADER, \"bytes per sample not specified\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \ttrack->f.framesPerPacket = 1;\n  \n  \t/*\n  \t\tSince some older NIST SPHERE files lack a sample_coding\n  \t\tfield, if sample_n_bytes is 1, assume mu-law;\n  \t\totherwise assume linear PCM.\n  \t*/\n  \ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \tif (sample_n_bytes == 1)\n  \t{\n  \t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n  \t\ttrack->f.sampleWidth = 16;\n  \t\ttrack->f.bytesPerPacket = track->f.channelCount;\n  \t}\n  \telse\n  \t{\n  \t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \t\ttrack->f.sampleWidth = sample_n_bytes * 8;\n  \t\ttrack->f.computeBytesPerPacketPCM();\n  \t}\n  \n  \tif (nist_header_read_string(header, \"sample_coding\", &intval, strval))\n  \t{\n  \t\tif (strcmp(strval, \"pcm\") == 0)\n  \t\t\t;\n  \t\telse if (strcmp(strval, \"ulaw\") == 0 || strcmp(strval, \"mu-law\") == 0)\n  \t\t{\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n  \t\t\ttrack->f.sampleWidth = 16;\n  \t\t}\n  \t\telse if (strcmp(strval, \"alaw\") == 0)\n  \t\t{\n  \t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n  \t\t\ttrack->f.sampleWidth = 16;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\t_af_error(AF_BAD_SAMPFMT,\n  \t\t\t\t\"unrecognized NIST SPHERE sample format %s\", strval);\n  \t\t\treturn AF_FAIL;\n  \t\t}\n  \t}\n  \n  \t// Read string representing byte order.\n  \tif (nist_header_read_string(header, \"sample_byte_format\", &intval, strval))\n  \t{\n  \t\tif (intval > 1)\n  \t\t{\n  \t\t\tif (strncmp(strval, \"01\", 2) == 0)\n  \t\t\t\ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n  \t\t\telse\n  \t\t\t\ttrack->f.byteOrder = AF_BYTEORDER_BIGENDIAN;\n  \t\t}\n  \t\telse\n  \t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t}\n  \telse\n  \t{\n  \t\t/*\n  \t\t\tFail if this field is not present and sample\n  \t\t\twidth is more than one byte.\n  \t\t*/\n  \t\tif (track->f.compressionType == AF_COMPRESSION_NONE &&\n  \t\t\ttrack->f.sampleWidth > 8)\n  \t\t{\n  \t\t\t_af_error(AF_BAD_HEADER, \"sample byte order not specified\");\n  \t\t\treturn AF_FAIL;\n  \t\t}\n  \t}\n  \n  \t// Read significant bits per sample.\n  \tif (nist_header_read_int(header, \"sample_sig_bits\", &intval))\n  \t{\n  \t\tif (intval < 1 || intval > 32)\n  \t\t{\n  \t\t\t_af_error(AF_BAD_WIDTH, \"invalid sample width %d bits\\n\",\n  \t\t\t\tintval);\n  \t\t\treturn AF_FAIL;\n  \t\t}\n  \n  \t\t/*\n  \t\t\tUse specified significant bits value as the\n  \t\t\tsample width for uncompressed data as long\n  \t\t\tas the number of bytes per sample remains\n  \t\t\tunchanged.\n  \t\t*/\n  \t\tif (track->f.compressionType == AF_COMPRESSION_NONE &&\n  \t\t\t(intval + 7) / 8 == sample_n_bytes)\n  \t\t{\n  \t\t\ttrack->f.sampleWidth = intval;\n  \t\t}\n  \t}\n  \n  \t// Read sample rate.\n  \tif (nist_header_read_int(header, \"sample_rate\", &intval))\n  \t{\n  \t\tif (intval <= 0)\n  \t\t{\n  \t\t\t_af_error(AF_BAD_RATE, \"invalid sample rate %d Hz\\n\", intval);\n  \t\t\treturn AF_FAIL;\n  \t\t}\n  \t\ttrack->f.sampleRate = intval;\n  \t}\n  \telse\n  \t{\n  \t\t_af_error(AF_BAD_HEADER, \"sample rate not specified\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \t// Read sample count.\n  \tif (nist_header_read_int(header, \"sample_count\", &intval))\n  \t{\n  \t\ttrack->totalfframes = intval;\n  \t}\n  \telse\n  \t{\n  \t\t_af_error(AF_BAD_HEADER, \"number of samples not specified\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \tif (_af_set_sample_format(&track->f, track->f.sampleFormat,\n  \t\ttrack->f.sampleWidth) == AF_FAIL)\n  \t{\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \ttrack->fpos_first_frame = NIST_SPHERE_HEADER_LENGTH;\n  \ttrack->data_size = m_fh->length() - NIST_SPHERE_HEADER_LENGTH;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "nist_header_read_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/NIST.cpp",
    "lines": "178-193",
    "snippet": "static bool nist_header_read_string (const char *header, const char *key, int *length, char *val)\n{\n\tconst char *cp;\n\tchar keystring[256], scanstring[256];\n\n\tsnprintf(keystring, 256, \"\\n%s -s\", key);\n\n\tif ((cp = strstr(header, keystring)) != NULL)\n\t{\n\t\tsnprintf(scanstring, 256, \"\\n%s -s%%d %%79s\", key);\n\t\tsscanf(cp, scanstring, length, val);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"File.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"NIST.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "cp",
            "scanstring",
            "length",
            "val"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "scanstring",
            "256",
            "\"\\n%s -s%%d %%79s\"",
            "key"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "header",
            "keystring"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "keystring",
            "256",
            "\"\\n%s -s\"",
            "key"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"File.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"NIST.h\"\n#include \"config.h\"\n\nstatic bool nist_header_read_string (const char *header, const char *key, int *length, char *val)\n{\n\tconst char *cp;\n\tchar keystring[256], scanstring[256];\n\n\tsnprintf(keystring, 256, \"\\n%s -s\", key);\n\n\tif ((cp = strstr(header, keystring)) != NULL)\n\t{\n\t\tsnprintf(scanstring, 256, \"\\n%s -s%%d %%79s\", key);\n\t\tsscanf(cp, scanstring, length, val);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "nist_header_read_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/NIST.cpp",
    "lines": "161-176",
    "snippet": "static bool nist_header_read_int (const char *header, const char *key, int *val)\n{\n\tconst char *cp;\n\tchar keystring[256], scanstring[256];\n\n\tsnprintf(keystring, 256, \"\\n%s -i\", key);\n\n\tif ((cp = strstr(header, keystring)) != NULL)\n\t{\n\t\tsnprintf(scanstring, 256, \"\\n%s -i %%d\", key);\n\t\tsscanf(cp, scanstring, val);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"File.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"NIST.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "cp",
            "scanstring",
            "val"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "scanstring",
            "256",
            "\"\\n%s -i %%d\"",
            "key"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "header",
            "keystring"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "keystring",
            "256",
            "\"\\n%s -i\"",
            "key"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"File.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"NIST.h\"\n#include \"config.h\"\n\nstatic bool nist_header_read_int (const char *header, const char *key, int *val)\n{\n\tconst char *cp;\n\tchar keystring[256], scanstring[256];\n\n\tsnprintf(keystring, 256, \"\\n%s -i\", key);\n\n\tif ((cp = strstr(header, keystring)) != NULL)\n\t{\n\t\tsnprintf(scanstring, 256, \"\\n%s -i %%d\", key);\n\t\tsscanf(cp, scanstring, val);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "completeSetup",
    "container": "NISTFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/NIST.cpp",
    "lines": "78-159",
    "snippet": "AFfilesetup NISTFile::completeSetup(AFfilesetup setup)\n{\n\tif (setup->trackSet && setup->trackCount != 1)\n\t{\n\t\t_af_error(AF_BAD_NUMTRACKS, \"NIST SPHERE file must have 1 track\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tTrackSetup *track = setup->getTrack();\n\tif (!track)\n\t\treturn AF_NULL_FILESETUP;\n\n\tif (track->sampleFormatSet)\n\t{\n\t\t/* XXXmpruett: Currently we allow only 1-16 bit sample width. */\n\t\tif (track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP &&\n\t\t\t(track->f.sampleWidth < 1 || track->f.sampleWidth > 16))\n\t\t{\n\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\"invalid sample width %d bits for NIST SPHERE format\",\n\t\t\t\ttrack->f.sampleWidth);\n\t\t\treturn AF_NULL_FILESETUP;\n\t\t}\n\t\telse if (track->f.sampleFormat == AF_SAMPFMT_UNSIGNED)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"NIST SPHERE format does not support unsigned data\");\n\t\t\treturn AF_NULL_FILESETUP;\n\t\t}\n\t\telse if (track->f.sampleFormat == AF_SAMPFMT_FLOAT ||\n\t\t\ttrack->f.sampleFormat == AF_SAMPFMT_DOUBLE)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"NIST SPHERE format does not support floating-point data\");\n\t\t\treturn AF_NULL_FILESETUP;\n\t\t}\n\t}\n\n\tif (track->rateSet && track->f.sampleRate <= 0.0)\n\t{\n\t\t_af_error(AF_BAD_RATE,\n\t\t\t\"invalid sample rate %.30g for NIST SPHERE file\",\n\t\t\ttrack->f.sampleRate);\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->compressionSet && track->f.compressionType != AF_COMPRESSION_NONE &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_G711_ULAW &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_G711_ALAW)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\"NIST SPHERE format supports only G.711 u-law or A-law compression\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->aesDataSet)\n\t{\n\t\t_af_error(AF_BAD_FILESETUP, \"NIST SPHERE file cannot have AES data\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->markersSet && track->markerCount != 0)\n\t{\n\t\t_af_error(AF_BAD_NUMMARKS, \"NIST SPHERE format does not support markers\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (setup->instrumentSet && setup->instrumentCount != 0)\n\t{\n\t\t_af_error(AF_BAD_NUMINSTS, \"NIST SPHERE format does not support instruments\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\t/* XXXmpruett: We don't support miscellaneous chunks for now. */\n\tif (setup->miscellaneousSet && setup->miscellaneousCount != 0)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"NIST SPHERE format does not currently support miscellaneous chunks\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\treturn _af_filesetup_copy(setup, &nistDefaultFileSetup, true);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"File.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"NIST.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const _AFfilesetup nistDefaultFileSetup =\n{\n\t_AF_VALID_FILESETUP,\t/* valid */\n\tAF_FILE_NIST_SPHERE,\t/* fileFormat */\n\ttrue,\t\t\t/* trackSet */\n\ttrue,\t\t\t/* instrumentSet */\n\ttrue,\t\t\t/* miscellaneousSet */\n\t1,\t\t\t/* trackCount */\n\tNULL,\t\t\t/* tracks */\n\t0,\t\t\t/* instrumentCount */\n\tNULL,\t\t\t/* instruments */\n\t0,\t\t\t/* miscellaneousCount */\n\tNULL\t\t\t/* miscellaneous */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_filesetup_copy",
          "args": [
            "setup",
            "&nistDefaultFileSetup",
            "true"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "_af_filesetup_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Setup.cpp",
          "lines": "440-525",
          "snippet": "AFfilesetup _af_filesetup_copy (const _AFfilesetup *setup,\n\tconst _AFfilesetup *defaultSetup, bool copyMarks)\n{\n\tAFfilesetup newsetup;\n\tint instrumentCount, miscellaneousCount, trackCount;\n\n\tnewsetup = (_AFfilesetup *) _af_malloc(sizeof (_AFfilesetup));\n\tif (newsetup == AF_NULL_FILESETUP)\n\t\treturn AF_NULL_FILESETUP;\n\n\t*newsetup = *defaultSetup;\n\n\tnewsetup->tracks = NULL;\n\tnewsetup->instruments = NULL;\n\tnewsetup->miscellaneous = NULL;\n\n\t/* Copy tracks. */\n\ttrackCount = setup->trackSet ? setup->trackCount :\n\t\tnewsetup->trackSet ? newsetup->trackCount : 0;\n\talloccopy(TrackSetup, trackCount, newsetup->tracks, setup->tracks);\n\tnewsetup->trackCount = trackCount;\n\n\t/* Copy instruments. */\n\tinstrumentCount = setup->instrumentSet ? setup->instrumentCount :\n\t\tnewsetup->instrumentSet ? newsetup->instrumentCount : 0;\n\talloccopy(InstrumentSetup, instrumentCount, newsetup->instruments, setup->instruments);\n\tnewsetup->instrumentCount = instrumentCount;\n\n\t/* Copy miscellaneous information. */\n\tmiscellaneousCount = setup->miscellaneousSet ? setup->miscellaneousCount :\n\t\tnewsetup->miscellaneousSet ? newsetup->miscellaneousCount : 0;\n\talloccopy(MiscellaneousSetup, miscellaneousCount, newsetup->miscellaneous, setup->miscellaneous);\n\tnewsetup->miscellaneousCount = miscellaneousCount;\n\n\tfor (int i=0; i<setup->trackCount; i++)\n\t{\n\t\tTrackSetup\t*track = &newsetup->tracks[i];\n\n\t\t/* XXXmpruett set compression information */\n\n\t\tif (!setup->tracks[i].markersSet && !copyMarks)\n\t\t{\n\t\t\ttrack->markers = NULL;\n\t\t\ttrack->markerCount = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\talloccopy(MarkerSetup, setup->tracks[i].markerCount,\n\t\t\ttrack->markers, setup->tracks[i].markers);\n\t\ttrack->markerCount = setup->tracks[i].markerCount;\n\n\t\tfor (int j=0; j<setup->tracks[i].markerCount; j++)\n\t\t{\n\t\t\ttrack->markers[j].name =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].name);\n\t\t\tif (track->markers[j].name == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\ttrack->markers[j].comment =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].comment);\n\t\t\tif (track->markers[j].comment == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (int i=0; i<newsetup->instrumentCount; i++)\n\t{\n\t\tInstrumentSetup\t*instrument = &newsetup->instruments[i];\n\t\talloccopy(LoopSetup, setup->instruments[i].loopCount,\n\t\t\tinstrument->loops, setup->instruments[i].loops);\n\t}\n\n\treturn newsetup;\n\n\tfail:\n\t\tif (newsetup->miscellaneous)\n\t\t\tfree(newsetup->miscellaneous);\n\t\tif (newsetup->instruments)\n\t\t\tfree(newsetup->instruments);\n\t\tif (newsetup->tracks)\n\t\t\tfree(newsetup->tracks);\n\t\tif (newsetup)\n\t\t\tfree(newsetup);\n\n\treturn AF_NULL_FILESETUP;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"audiofile.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"Setup.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"audiofile.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include <string.h>\n#include <stdlib.h>\n#include \"Setup.h\"\n#include \"config.h\"\n\nAFfilesetup _af_filesetup_copy (const _AFfilesetup *setup,\n\tconst _AFfilesetup *defaultSetup, bool copyMarks)\n{\n\tAFfilesetup newsetup;\n\tint instrumentCount, miscellaneousCount, trackCount;\n\n\tnewsetup = (_AFfilesetup *) _af_malloc(sizeof (_AFfilesetup));\n\tif (newsetup == AF_NULL_FILESETUP)\n\t\treturn AF_NULL_FILESETUP;\n\n\t*newsetup = *defaultSetup;\n\n\tnewsetup->tracks = NULL;\n\tnewsetup->instruments = NULL;\n\tnewsetup->miscellaneous = NULL;\n\n\t/* Copy tracks. */\n\ttrackCount = setup->trackSet ? setup->trackCount :\n\t\tnewsetup->trackSet ? newsetup->trackCount : 0;\n\talloccopy(TrackSetup, trackCount, newsetup->tracks, setup->tracks);\n\tnewsetup->trackCount = trackCount;\n\n\t/* Copy instruments. */\n\tinstrumentCount = setup->instrumentSet ? setup->instrumentCount :\n\t\tnewsetup->instrumentSet ? newsetup->instrumentCount : 0;\n\talloccopy(InstrumentSetup, instrumentCount, newsetup->instruments, setup->instruments);\n\tnewsetup->instrumentCount = instrumentCount;\n\n\t/* Copy miscellaneous information. */\n\tmiscellaneousCount = setup->miscellaneousSet ? setup->miscellaneousCount :\n\t\tnewsetup->miscellaneousSet ? newsetup->miscellaneousCount : 0;\n\talloccopy(MiscellaneousSetup, miscellaneousCount, newsetup->miscellaneous, setup->miscellaneous);\n\tnewsetup->miscellaneousCount = miscellaneousCount;\n\n\tfor (int i=0; i<setup->trackCount; i++)\n\t{\n\t\tTrackSetup\t*track = &newsetup->tracks[i];\n\n\t\t/* XXXmpruett set compression information */\n\n\t\tif (!setup->tracks[i].markersSet && !copyMarks)\n\t\t{\n\t\t\ttrack->markers = NULL;\n\t\t\ttrack->markerCount = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\talloccopy(MarkerSetup, setup->tracks[i].markerCount,\n\t\t\ttrack->markers, setup->tracks[i].markers);\n\t\ttrack->markerCount = setup->tracks[i].markerCount;\n\n\t\tfor (int j=0; j<setup->tracks[i].markerCount; j++)\n\t\t{\n\t\t\ttrack->markers[j].name =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].name);\n\t\t\tif (track->markers[j].name == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\ttrack->markers[j].comment =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].comment);\n\t\t\tif (track->markers[j].comment == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (int i=0; i<newsetup->instrumentCount; i++)\n\t{\n\t\tInstrumentSetup\t*instrument = &newsetup->instruments[i];\n\t\talloccopy(LoopSetup, setup->instruments[i].loopCount,\n\t\t\tinstrument->loops, setup->instruments[i].loops);\n\t}\n\n\treturn newsetup;\n\n\tfail:\n\t\tif (newsetup->miscellaneous)\n\t\t\tfree(newsetup->miscellaneous);\n\t\tif (newsetup->instruments)\n\t\t\tfree(newsetup->instruments);\n\t\tif (newsetup->tracks)\n\t\t\tfree(newsetup->tracks);\n\t\tif (newsetup)\n\t\t\tfree(newsetup);\n\n\treturn AF_NULL_FILESETUP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"NIST SPHERE format does not currently support miscellaneous chunks\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NUMINSTS",
            "\"NIST SPHERE format does not support instruments\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NUMMARKS",
            "\"NIST SPHERE format does not support markers\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_FILESETUP",
            "\"NIST SPHERE file cannot have AES data\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"NIST SPHERE format supports only G.711 u-law or A-law compression\""
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_RATE",
            "\"invalid sample rate %.30g for NIST SPHERE file\"",
            "track->f.sampleRate"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_SAMPFMT",
            "\"NIST SPHERE format does not support floating-point data\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_SAMPFMT",
            "\"NIST SPHERE format does not support unsigned data\""
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_WIDTH",
            "\"invalid sample width %d bits for NIST SPHERE format\"",
            "track->f.sampleWidth"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup->getTrack",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NUMTRACKS",
            "\"NIST SPHERE file must have 1 track\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"File.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"NIST.h\"\n#include \"config.h\"\n\nstatic const _AFfilesetup nistDefaultFileSetup =\n{\n\t_AF_VALID_FILESETUP,\t/* valid */\n\tAF_FILE_NIST_SPHERE,\t/* fileFormat */\n\ttrue,\t\t\t/* trackSet */\n\ttrue,\t\t\t/* instrumentSet */\n\ttrue,\t\t\t/* miscellaneousSet */\n\t1,\t\t\t/* trackCount */\n\tNULL,\t\t\t/* tracks */\n\t0,\t\t\t/* instrumentCount */\n\tNULL,\t\t\t/* instruments */\n\t0,\t\t\t/* miscellaneousCount */\n\tNULL\t\t\t/* miscellaneous */\n};\n\nNISTFile {\n  AFfilesetup NISTFile::completeSetup(AFfilesetup setup)\n  {\n  \tif (setup->trackSet && setup->trackCount != 1)\n  \t{\n  \t\t_af_error(AF_BAD_NUMTRACKS, \"NIST SPHERE file must have 1 track\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tTrackSetup *track = setup->getTrack();\n  \tif (!track)\n  \t\treturn AF_NULL_FILESETUP;\n  \n  \tif (track->sampleFormatSet)\n  \t{\n  \t\t/* XXXmpruett: Currently we allow only 1-16 bit sample width. */\n  \t\tif (track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP &&\n  \t\t\t(track->f.sampleWidth < 1 || track->f.sampleWidth > 16))\n  \t\t{\n  \t\t\t_af_error(AF_BAD_WIDTH,\n  \t\t\t\t\"invalid sample width %d bits for NIST SPHERE format\",\n  \t\t\t\ttrack->f.sampleWidth);\n  \t\t\treturn AF_NULL_FILESETUP;\n  \t\t}\n  \t\telse if (track->f.sampleFormat == AF_SAMPFMT_UNSIGNED)\n  \t\t{\n  \t\t\t_af_error(AF_BAD_SAMPFMT,\n  \t\t\t\t\"NIST SPHERE format does not support unsigned data\");\n  \t\t\treturn AF_NULL_FILESETUP;\n  \t\t}\n  \t\telse if (track->f.sampleFormat == AF_SAMPFMT_FLOAT ||\n  \t\t\ttrack->f.sampleFormat == AF_SAMPFMT_DOUBLE)\n  \t\t{\n  \t\t\t_af_error(AF_BAD_SAMPFMT,\n  \t\t\t\t\"NIST SPHERE format does not support floating-point data\");\n  \t\t\treturn AF_NULL_FILESETUP;\n  \t\t}\n  \t}\n  \n  \tif (track->rateSet && track->f.sampleRate <= 0.0)\n  \t{\n  \t\t_af_error(AF_BAD_RATE,\n  \t\t\t\"invalid sample rate %.30g for NIST SPHERE file\",\n  \t\t\ttrack->f.sampleRate);\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (track->compressionSet && track->f.compressionType != AF_COMPRESSION_NONE &&\n  \t\ttrack->f.compressionType != AF_COMPRESSION_G711_ULAW &&\n  \t\ttrack->f.compressionType != AF_COMPRESSION_G711_ALAW)\n  \t{\n  \t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n  \t\t\t\"NIST SPHERE format supports only G.711 u-law or A-law compression\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (track->aesDataSet)\n  \t{\n  \t\t_af_error(AF_BAD_FILESETUP, \"NIST SPHERE file cannot have AES data\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (track->markersSet && track->markerCount != 0)\n  \t{\n  \t\t_af_error(AF_BAD_NUMMARKS, \"NIST SPHERE format does not support markers\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (setup->instrumentSet && setup->instrumentCount != 0)\n  \t{\n  \t\t_af_error(AF_BAD_NUMINSTS, \"NIST SPHERE format does not support instruments\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \t/* XXXmpruett: We don't support miscellaneous chunks for now. */\n  \tif (setup->miscellaneousSet && setup->miscellaneousCount != 0)\n  \t{\n  \t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"NIST SPHERE format does not currently support miscellaneous chunks\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \treturn _af_filesetup_copy(setup, &nistDefaultFileSetup, true);\n  }\n}"
  },
  {
    "function_name": "recognize",
    "container": "NISTFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/NIST.cpp",
    "lines": "62-76",
    "snippet": "bool NISTFile::recognize(File *fh)\n{\n\tuint8_t buffer[16];\n\n\tfh->seek(0, File::SeekFromBeginning);\n\n\tif (fh->read(buffer, 16) != 16)\n\t\treturn false;\n\n\t/* Check to see if the file's magic number matches. */\n\tif (memcmp(buffer, \"NIST_1A\\n   1024\\n\", 16) == 0)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"audiofile.h\"",
      "#include \"afinternal.h\"",
      "#include \"File.h\"",
      "#include \"Track.h\"",
      "#include \"Setup.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <assert.h>",
      "#include \"NIST.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"NIST_1A\\n   1024\\n\"",
            "16"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh->read",
          "args": [
            "buffer",
            "16"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh->seek",
          "args": [
            "0",
            "File::SeekFromBeginning"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"File.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <assert.h>\n#include \"NIST.h\"\n#include \"config.h\"\n\nNISTFile {\n  bool NISTFile::recognize(File *fh)\n  {\n  \tuint8_t buffer[16];\n  \n  \tfh->seek(0, File::SeekFromBeginning);\n  \n  \tif (fh->read(buffer, 16) != 16)\n  \t\treturn false;\n  \n  \t/* Check to see if the file's magic number matches. */\n  \tif (memcmp(buffer, \"NIST_1A\\n   1024\\n\", 16) == 0)\n  \t\treturn true;\n  \n  \treturn false;\n  }\n}"
  }
]