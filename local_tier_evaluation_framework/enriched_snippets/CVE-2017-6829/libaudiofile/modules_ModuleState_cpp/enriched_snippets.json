[
  {
    "function_name": "print",
    "container": "ModuleState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "491-504",
    "snippet": "void ModuleState::print()\n{\n\tfprintf(stderr, \"modules:\\n\");\n\tfor (size_t i=0; i<m_modules.size(); i++)\n\t\tfprintf(stderr, \" %s (%p) in %p out %p\\n\",\n\t\t\tm_modules[i]->name(), m_modules[i].get(),\n\t\t\tm_modules[i]->inChunk(),\n\t\t\tm_modules[i]->outChunk());\n\tfprintf(stderr, \"chunks:\\n\");\n\tfor (size_t i=0; i<m_chunks.size(); i++)\n\t\tfprintf(stderr, \" %p %s\\n\",\n\t\t\tm_chunks[i].get(),\n\t\t\tm_chunks[i]->f.description().c_str());\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" %p %s\\n\"",
            "m_chunks[i].get()",
            "m_chunks[i]->f.description().c_str()"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_chunks[i]->f.description",
          "args": [],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "description",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "105-164",
          "snippet": "std::string AudioFormat::description() const\n{\n\tstd::string d;\n\tchar s[1024];\n\t/* sampleRate, channelCount */\n\tsprintf(s, \"{ %7.2f Hz %d ch \", sampleRate, channelCount);\n\td += s;\n\n\t/* sampleFormat, sampleWidth */\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\t\tsprintf(s, \"%db 2 \", sampleWidth);\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\t\tsprintf(s, \"%db u \", sampleWidth);\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tsprintf(s, \"flt \");\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tsprintf(s, \"dbl \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t\tbreak;\n\t}\n\n\td += s;\n\n\t/* pcm */\n\tsprintf(s, \"(%.30g+-%.30g [%.30g,%.30g]) \",\n\t\tpcm.intercept, pcm.slope,\n\t\tpcm.minClip, pcm.maxClip);\n\td += s;\n\n\t/* byteOrder */\n\tswitch (byteOrder)\n\t{\n\t\tcase AF_BYTEORDER_BIGENDIAN:\n\t\t\td += \"big \";\n\t\t\tbreak;\n\t\tcase AF_BYTEORDER_LITTLEENDIAN:\n\t\t\td += \"little \";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t\tbreak;\n\t}\n\n\tif (isCompressed())\n\t{\n\t\tconst CompressionUnit *unit = _af_compression_unit_from_id(compressionType);\n\t\tassert(unit);\n\t\td += \"compression: \";\n\t\td += unit->label;\n\t}\n\n\treturn d;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  std::string AudioFormat::description() const\n  {\n  \tstd::string d;\n  \tchar s[1024];\n  \t/* sampleRate, channelCount */\n  \tsprintf(s, \"{ %7.2f Hz %d ch \", sampleRate, channelCount);\n  \td += s;\n  \n  \t/* sampleFormat, sampleWidth */\n  \tswitch (sampleFormat)\n  \t{\n  \t\tcase AF_SAMPFMT_TWOSCOMP:\n  \t\t\tsprintf(s, \"%db 2 \", sampleWidth);\n  \t\t\tbreak;\n  \t\tcase AF_SAMPFMT_UNSIGNED:\n  \t\t\tsprintf(s, \"%db u \", sampleWidth);\n  \t\t\tbreak;\n  \t\tcase AF_SAMPFMT_FLOAT:\n  \t\t\tsprintf(s, \"flt \");\n  \t\t\tbreak;\n  \t\tcase AF_SAMPFMT_DOUBLE:\n  \t\t\tsprintf(s, \"dbl \");\n  \t\t\tbreak;\n  \t\tdefault:\n  \t\t\tassert(false);\n  \t\t\tbreak;\n  \t}\n  \n  \td += s;\n  \n  \t/* pcm */\n  \tsprintf(s, \"(%.30g+-%.30g [%.30g,%.30g]) \",\n  \t\tpcm.intercept, pcm.slope,\n  \t\tpcm.minClip, pcm.maxClip);\n  \td += s;\n  \n  \t/* byteOrder */\n  \tswitch (byteOrder)\n  \t{\n  \t\tcase AF_BYTEORDER_BIGENDIAN:\n  \t\t\td += \"big \";\n  \t\t\tbreak;\n  \t\tcase AF_BYTEORDER_LITTLEENDIAN:\n  \t\t\td += \"little \";\n  \t\t\tbreak;\n  \t\tdefault:\n  \t\t\tassert(false);\n  \t\t\tbreak;\n  \t}\n  \n  \tif (isCompressed())\n  \t{\n  \t\tconst CompressionUnit *unit = _af_compression_unit_from_id(compressionType);\n  \t\tassert(unit);\n  \t\td += \"compression: \";\n  \t\td += unit->label;\n  \t}\n  \n  \treturn d;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_chunks[i].get",
          "args": [],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_chunks.size",
          "args": [],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Buffer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Buffer.h",
          "lines": "39-39",
          "snippet": "size_t size() const { return m_size; }",
          "includes": [
            "#include <sys/types.h>",
            "#include \"Shared.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"Shared.h\"\n\nBuffer {\n  size_t size() const { return m_size; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"chunks:\\n\""
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" %s (%p) in %p out %p\\n\"",
            "m_modules[i]->name()",
            "m_modules[i].get()",
            "m_modules[i]->inChunk()",
            "m_modules[i]->outChunk()"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_modules[i]->outChunk",
          "args": [],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_modules[i]->inChunk",
          "args": [],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_modules[i].get",
          "args": [],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_modules[i]->name",
          "args": [],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Tag",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Tag.h",
          "lines": "45-51",
          "snippet": "std::string name() const\n\t{\n\t\tchar s[5];\n\t\tmemcpy(s, &m_value, 4);\n\t\ts[4] = '\\0';\n\t\treturn std::string(s);\n\t}",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stdint.h>\n#include <assert.h>\n\nTag {\n  std::string name() const\n  \t{\n  \t\tchar s[5];\n  \t\tmemcpy(s, &m_value, 4);\n  \t\ts[4] = '\\0';\n  \t\treturn std::string(s);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"modules:\\n\""
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  void ModuleState::print()\n  {\n  \tfprintf(stderr, \"modules:\\n\");\n  \tfor (size_t i=0; i<m_modules.size(); i++)\n  \t\tfprintf(stderr, \" %s (%p) in %p out %p\\n\",\n  \t\t\tm_modules[i]->name(), m_modules[i].get(),\n  \t\t\tm_modules[i]->inChunk(),\n  \t\t\tm_modules[i]->outChunk());\n  \tfprintf(stderr, \"chunks:\\n\");\n  \tfor (size_t i=0; i<m_chunks.size(); i++)\n  \t\tfprintf(stderr, \" %p %s\\n\",\n  \t\t\tm_chunks[i].get(),\n  \t\t\tm_chunks[i]->f.description().c_str());\n  }\n}"
  },
  {
    "function_name": "addConvertFloatToFloat",
    "container": "ModuleState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "481-489",
    "snippet": "void ModuleState::addConvertFloatToFloat(FormatCode input, FormatCode output)\n{\n\tif (input == output)\n\t\treturn;\n\n\tassert((input == kFloat && output == kDouble) ||\n\t\t(input == kDouble && output == kFloat));\n\taddModule(new ConvertFloat(input, output));\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addModule",
          "args": [
            "new ConvertFloat(input, output)"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "addModule",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "446-458",
          "snippet": "void ModuleState::addModule(Module *module)\n{\n\tif (!module)\n\t\treturn;\n\n\tm_modules.push_back(module);\n\tmodule->setInChunk(m_chunks.back().get());\n\tChunk *chunk = new Chunk();\n\tchunk->f = m_chunks.back()->f;\n\tm_chunks.push_back(chunk);\n\tmodule->setOutChunk(chunk);\n\tmodule->describe();\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  void ModuleState::addModule(Module *module)\n  {\n  \tif (!module)\n  \t\treturn;\n  \n  \tm_modules.push_back(module);\n  \tmodule->setInChunk(m_chunks.back().get());\n  \tChunk *chunk = new Chunk();\n  \tchunk->f = m_chunks.back()->f;\n  \tm_chunks.push_back(chunk);\n  \tmodule->setOutChunk(chunk);\n  \tmodule->describe();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "(input == kFloat && output == kDouble) ||\n\t\t(input == kDouble && output == kFloat)"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  void ModuleState::addConvertFloatToFloat(FormatCode input, FormatCode output)\n  {\n  \tif (input == output)\n  \t\treturn;\n  \n  \tassert((input == kFloat && output == kDouble) ||\n  \t\t(input == kDouble && output == kFloat));\n  \taddModule(new ConvertFloat(input, output));\n  }\n}"
  },
  {
    "function_name": "addConvertFloatToInt",
    "container": "ModuleState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "475-479",
    "snippet": "void ModuleState::addConvertFloatToInt(FormatCode input, FormatCode output,\n\tconst PCMInfo &inputMapping, const PCMInfo &outputMapping)\n{\n\taddModule(new ConvertFloatToIntClip(input, output, inputMapping, outputMapping));\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addModule",
          "args": [
            "new ConvertFloatToIntClip(input, output, inputMapping, outputMapping)"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "addModule",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "446-458",
          "snippet": "void ModuleState::addModule(Module *module)\n{\n\tif (!module)\n\t\treturn;\n\n\tm_modules.push_back(module);\n\tmodule->setInChunk(m_chunks.back().get());\n\tChunk *chunk = new Chunk();\n\tchunk->f = m_chunks.back()->f;\n\tm_chunks.push_back(chunk);\n\tmodule->setOutChunk(chunk);\n\tmodule->describe();\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  void ModuleState::addModule(Module *module)\n  {\n  \tif (!module)\n  \t\treturn;\n  \n  \tm_modules.push_back(module);\n  \tmodule->setInChunk(m_chunks.back().get());\n  \tChunk *chunk = new Chunk();\n  \tchunk->f = m_chunks.back()->f;\n  \tm_chunks.push_back(chunk);\n  \tmodule->setOutChunk(chunk);\n  \tmodule->describe();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  void ModuleState::addConvertFloatToInt(FormatCode input, FormatCode output,\n  \tconst PCMInfo &inputMapping, const PCMInfo &outputMapping)\n  {\n  \taddModule(new ConvertFloatToIntClip(input, output, inputMapping, outputMapping));\n  }\n}"
  },
  {
    "function_name": "addConvertIntToFloat",
    "container": "ModuleState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "470-473",
    "snippet": "void ModuleState::addConvertIntToFloat(FormatCode input, FormatCode output)\n{\n\taddModule(new ConvertIntToFloat(input, output));\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addModule",
          "args": [
            "new ConvertIntToFloat(input, output)"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "addModule",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "446-458",
          "snippet": "void ModuleState::addModule(Module *module)\n{\n\tif (!module)\n\t\treturn;\n\n\tm_modules.push_back(module);\n\tmodule->setInChunk(m_chunks.back().get());\n\tChunk *chunk = new Chunk();\n\tchunk->f = m_chunks.back()->f;\n\tm_chunks.push_back(chunk);\n\tmodule->setOutChunk(chunk);\n\tmodule->describe();\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  void ModuleState::addModule(Module *module)\n  {\n  \tif (!module)\n  \t\treturn;\n  \n  \tm_modules.push_back(module);\n  \tmodule->setInChunk(m_chunks.back().get());\n  \tChunk *chunk = new Chunk();\n  \tchunk->f = m_chunks.back()->f;\n  \tm_chunks.push_back(chunk);\n  \tmodule->setOutChunk(chunk);\n  \tmodule->describe();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  void ModuleState::addConvertIntToFloat(FormatCode input, FormatCode output)\n  {\n  \taddModule(new ConvertIntToFloat(input, output));\n  }\n}"
  },
  {
    "function_name": "addConvertIntToInt",
    "container": "ModuleState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "460-468",
    "snippet": "void ModuleState::addConvertIntToInt(FormatCode input, FormatCode output)\n{\n\tif (input == output)\n\t\treturn;\n\n\tassert(isInteger(input));\n\tassert(isInteger(output));\n\taddModule(new ConvertInt(input, output));\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addModule",
          "args": [
            "new ConvertInt(input, output)"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "addModule",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "446-458",
          "snippet": "void ModuleState::addModule(Module *module)\n{\n\tif (!module)\n\t\treturn;\n\n\tm_modules.push_back(module);\n\tmodule->setInChunk(m_chunks.back().get());\n\tChunk *chunk = new Chunk();\n\tchunk->f = m_chunks.back()->f;\n\tm_chunks.push_back(chunk);\n\tmodule->setOutChunk(chunk);\n\tmodule->describe();\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  void ModuleState::addModule(Module *module)\n  {\n  \tif (!module)\n  \t\treturn;\n  \n  \tm_modules.push_back(module);\n  \tmodule->setInChunk(m_chunks.back().get());\n  \tChunk *chunk = new Chunk();\n  \tchunk->f = m_chunks.back()->f;\n  \tm_chunks.push_back(chunk);\n  \tmodule->setOutChunk(chunk);\n  \tmodule->describe();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "isInteger(output)"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isInteger",
          "args": [
            "output"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "isInteger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "276-276",
          "snippet": "static bool isInteger(FormatCode code) { return code >= kInt8 && code <= kInt32; }",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nstatic bool isInteger(FormatCode code) { return code >= kInt8 && code <= kInt32; }"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "isInteger(input)"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  void ModuleState::addConvertIntToInt(FormatCode input, FormatCode output)\n  {\n  \tif (input == output)\n  \t\treturn;\n  \n  \tassert(isInteger(input));\n  \tassert(isInteger(output));\n  \taddModule(new ConvertInt(input, output));\n  }\n}"
  },
  {
    "function_name": "addModule",
    "container": "ModuleState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "446-458",
    "snippet": "void ModuleState::addModule(Module *module)\n{\n\tif (!module)\n\t\treturn;\n\n\tm_modules.push_back(module);\n\tmodule->setInChunk(m_chunks.back().get());\n\tChunk *chunk = new Chunk();\n\tchunk->f = m_chunks.back()->f;\n\tm_chunks.push_back(chunk);\n\tmodule->setOutChunk(chunk);\n\tmodule->describe();\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module->describe",
          "args": [],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "describe",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.cpp",
          "lines": "46-48",
          "snippet": "void Module::describe()\n{\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"File.h\"",
            "#include \"Module.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"SimpleModule.h\"\n#include \"File.h\"\n#include \"Module.h\"\n#include \"config.h\"\n\nModule {\n  void Module::describe()\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "module->setOutChunk",
          "args": [
            "chunk"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "setOutChunk",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.h",
          "lines": "81-81",
          "snippet": "void setOutChunk(Chunk *chunk) { m_outChunk = chunk; }",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"AudioFormat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"AudioFormat.h\"\n\nModule {\n  void setOutChunk(Chunk *chunk) { m_outChunk = chunk; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_chunks.push_back",
          "args": [
            "chunk"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_chunks.back",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module->setInChunk",
          "args": [
            "m_chunks.back().get()"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "setInChunk",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.h",
          "lines": "79-79",
          "snippet": "void setInChunk(Chunk *chunk) { m_inChunk = chunk; }",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"AudioFormat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"AudioFormat.h\"\n\nModule {\n  void setInChunk(Chunk *chunk) { m_inChunk = chunk; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_chunks.back",
          "args": [],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_chunks.back",
          "args": [],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_modules.push_back",
          "args": [
            "module"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  void ModuleState::addModule(Module *module)\n  {\n  \tif (!module)\n  \t\treturn;\n  \n  \tm_modules.push_back(module);\n  \tmodule->setInChunk(m_chunks.back().get());\n  \tChunk *chunk = new Chunk();\n  \tchunk->f = m_chunks.back()->f;\n  \tm_chunks.push_back(chunk);\n  \tmodule->setOutChunk(chunk);\n  \tmodule->describe();\n  }\n}"
  },
  {
    "function_name": "arrange",
    "container": "ModuleState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "293-444",
    "snippet": "status ModuleState::arrange(AFfilehandle file, Track *track)\n{\n\tbool isReading = file->m_access == _AF_READ_ACCESS;\n\tAudioFormat in, out;\n\tif (isReading)\n\t{\n\t\tin = track->f;\n\t\tout = track->v;\n\t}\n\telse\n\t{\n\t\tin = track->v;\n\t\tout = track->f;\n\t}\n\n\tFormatCode infc = getFormatCode(in);\n\tFormatCode outfc = getFormatCode(out);\n\tif (infc == kUndefined || outfc == kUndefined)\n\t\treturn AF_FAIL;\n\n\tm_chunks.clear();\n\tm_chunks.push_back(new Chunk());\n\tm_chunks.back()->f = in;\n\n\tm_modules.clear();\n\n\tif (isReading)\n\t{\n\t\taddModule(m_fileModule.get());\n\t\taddModule(m_fileRebufferModule.get());\n\t}\n\n\t// Convert to native byte order.\n\tif (in.byteOrder != _AF_BYTEORDER_NATIVE)\n\t{\n\t\tsize_t bytesPerSample = in.bytesPerSample(!isReading);\n\t\tif (bytesPerSample > 1 && in.compressionType == AF_COMPRESSION_NONE)\n\t\t\taddModule(new SwapModule());\n\t\telse\n\t\t\tin.byteOrder = _AF_BYTEORDER_NATIVE;\n\t}\n\n\t// Handle 24-bit integer input format.\n\tif (in.isInteger() && in.bytesPerSample(false) == 3)\n\t{\n\t\tif (isReading || in.compressionType != AF_COMPRESSION_NONE)\n\t\t\taddModule(new Expand3To4Module(in.isSigned()));\n\t}\n\n\t// Make data signed.\n\tif (in.isUnsigned())\n\t\taddModule(new ConvertSign(infc, false));\n\n\tin.pcm = m_chunks.back()->f.pcm;\n\n\t// Reverse the unsigned shift for output.\n\tif (out.isUnsigned())\n\t{\n\t\tconst double shift = intmappings[outfc]->minClip;\n\t\tout.pcm.intercept += shift;\n\t\tout.pcm.minClip += shift;\n\t\tout.pcm.maxClip += shift;\n\t}\n\n\t// Clip input samples if necessary.\n\tif (in.pcm.minClip < in.pcm.maxClip && !isTrivialIntClip(in, infc))\n\t\taddModule(new Clip(infc, in.pcm));\n\n\tbool alreadyClippedOutput = false;\n\tbool alreadyTransformedOutput = false;\n\t// Perform range transformation if input and output PCM mappings differ.\n\tbool transforming = (in.pcm.slope != out.pcm.slope ||\n\t\tin.pcm.intercept != out.pcm.intercept) &&\n\t\t!(isTrivialIntMapping(in, infc) &&\n\t\tisTrivialIntMapping(out, outfc));\n\n\t// Range transformation requires input to be floating-point.\n\tif (isInteger(infc) && transforming)\n\t{\n\t\tif (infc == kInt32 || outfc == kDouble || outfc == kInt32)\n\t\t{\n\t\t\taddConvertIntToFloat(infc, kDouble);\n\t\t\tinfc = kDouble;\n\t\t}\n\t\telse\n\t\t{\n\t\t\taddConvertIntToFloat(infc, kFloat);\n\t\t\tinfc = kFloat;\n\t\t}\n\t}\n\n\tif (transforming && infc == kDouble && isFloat(outfc))\n\t\taddModule(new Transform(infc, in.pcm, out.pcm));\n\n\t// Add format conversion if needed.\n\tif (isInteger(infc) && isInteger(outfc))\n\t\taddConvertIntToInt(infc, outfc);\n\telse if (isInteger(infc) && isFloat(outfc))\n\t\taddConvertIntToFloat(infc, outfc);\n\telse if (isFloat(infc) && isInteger(outfc))\n\t{\n\t\taddConvertFloatToInt(infc, outfc, in.pcm, out.pcm);\n\t\talreadyClippedOutput = true;\n\t\talreadyTransformedOutput = true;\n\t}\n\telse if (isFloat(infc) && isFloat(outfc))\n\t\taddConvertFloatToFloat(infc, outfc);\n\n\tif (transforming && !alreadyTransformedOutput && infc != kDouble)\n\t\taddModule(new Transform(outfc, in.pcm, out.pcm));\n\n\tif (in.channelCount != out.channelCount)\n\t\taddModule(new ApplyChannelMatrix(outfc, isReading,\n\t\t\tin.channelCount, out.channelCount,\n\t\t\tin.pcm.minClip, in.pcm.maxClip,\n\t\t\ttrack->channelMatrix));\n\n\t// Perform clipping if necessary.\n\tif (!alreadyClippedOutput)\n\t{\n\t\tif (out.pcm.minClip < out.pcm.maxClip && !isTrivialIntClip(out, outfc))\n\t\t\taddModule(new Clip(outfc, out.pcm));\n\t}\n\n\t// Make data unsigned if necessary.\n\tif (out.isUnsigned())\n\t\taddModule(new ConvertSign(outfc, true));\n\n\t// Handle 24-bit integer output format.\n\tif (out.isInteger() && out.bytesPerSample(false) == 3)\n\t{\n\t\tif (!isReading || out.compressionType != AF_COMPRESSION_NONE)\n\t\t\taddModule(new Compress4To3Module(out.isSigned()));\n\t}\n\n\tif (out.byteOrder != _AF_BYTEORDER_NATIVE)\n\t{\n\t\tsize_t bytesPerSample = out.bytesPerSample(isReading);\n\t\tif (bytesPerSample > 1 && out.compressionType == AF_COMPRESSION_NONE)\n\t\t\taddModule(new SwapModule());\n\t\telse\n\t\t\tout.byteOrder = _AF_BYTEORDER_NATIVE;\n\t}\n\n\tif (!isReading)\n\t{\n\t\taddModule(m_fileRebufferModule.get());\n\t\taddModule(m_fileModule.get());\n\t}\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const PCMInfo * const intmappings[6] =\n{\n\t&_af_default_signed_integer_pcm_mappings[1],\n\t&_af_default_signed_integer_pcm_mappings[2],\n\t&_af_default_signed_integer_pcm_mappings[3],\n\t&_af_default_signed_integer_pcm_mappings[4],\n\tNULL,\n\tNULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "addModule",
          "args": [
            "m_fileModule.get()"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "addModule",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "446-458",
          "snippet": "void ModuleState::addModule(Module *module)\n{\n\tif (!module)\n\t\treturn;\n\n\tm_modules.push_back(module);\n\tmodule->setInChunk(m_chunks.back().get());\n\tChunk *chunk = new Chunk();\n\tchunk->f = m_chunks.back()->f;\n\tm_chunks.push_back(chunk);\n\tmodule->setOutChunk(chunk);\n\tmodule->describe();\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  void ModuleState::addModule(Module *module)\n  {\n  \tif (!module)\n  \t\treturn;\n  \n  \tm_modules.push_back(module);\n  \tmodule->setInChunk(m_chunks.back().get());\n  \tChunk *chunk = new Chunk();\n  \tchunk->f = m_chunks.back()->f;\n  \tm_chunks.push_back(chunk);\n  \tmodule->setOutChunk(chunk);\n  \tmodule->describe();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fileModule.get",
          "args": [],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fileRebufferModule.get",
          "args": [],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.bytesPerSample",
          "args": [
            "isReading"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "bytesPerSample",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "32-49",
          "snippet": "size_t AudioFormat::bytesPerSample(bool stretch3to4) const\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\treturn sizeof (float);\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\treturn sizeof (double);\n\t\tdefault:\n\t\t{\n\t\t\tint size = (sampleWidth + 7) / 8;\n\t\t\tif (compressionType == AF_COMPRESSION_NONE &&\n\t\t\t\tsize == 3 && stretch3to4)\n\t\t\t\tsize = 4;\n\t\t\treturn size;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  size_t AudioFormat::bytesPerSample(bool stretch3to4) const\n  {\n  \tswitch (sampleFormat)\n  \t{\n  \t\tcase AF_SAMPFMT_FLOAT:\n  \t\t\treturn sizeof (float);\n  \t\tcase AF_SAMPFMT_DOUBLE:\n  \t\t\treturn sizeof (double);\n  \t\tdefault:\n  \t\t{\n  \t\t\tint size = (sampleWidth + 7) / 8;\n  \t\t\tif (compressionType == AF_COMPRESSION_NONE &&\n  \t\t\t\tsize == 3 && stretch3to4)\n  \t\t\t\tsize = 4;\n  \t\t\treturn size;\n  \t\t}\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "out.isSigned",
          "args": [],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "isSigned",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "72-75",
          "snippet": "bool AudioFormat::isSigned() const\n{\n\treturn sampleFormat == AF_SAMPFMT_TWOSCOMP;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  bool AudioFormat::isSigned() const\n  {\n  \treturn sampleFormat == AF_SAMPFMT_TWOSCOMP;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "out.isInteger",
          "args": [],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "isInteger",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "66-70",
          "snippet": "bool AudioFormat::isInteger() const\n{\n\treturn sampleFormat == AF_SAMPFMT_TWOSCOMP ||\n\t\tsampleFormat == AF_SAMPFMT_UNSIGNED;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  bool AudioFormat::isInteger() const\n  {\n  \treturn sampleFormat == AF_SAMPFMT_TWOSCOMP ||\n  \t\tsampleFormat == AF_SAMPFMT_UNSIGNED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "out.isUnsigned",
          "args": [],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "isUnsigned",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "77-80",
          "snippet": "bool AudioFormat::isUnsigned() const\n{\n\treturn sampleFormat == AF_SAMPFMT_UNSIGNED;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  bool AudioFormat::isUnsigned() const\n  {\n  \treturn sampleFormat == AF_SAMPFMT_UNSIGNED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isTrivialIntClip",
          "args": [
            "out",
            "outfc"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "isTrivialIntClip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "286-291",
          "snippet": "static bool isTrivialIntClip(const AudioFormat &format, FormatCode code)\n{\n\treturn intmappings[code] != NULL &&\n\t\tformat.pcm.minClip == intmappings[code]->minClip &&\n\t\tformat.pcm.maxClip == intmappings[code]->maxClip;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const PCMInfo * const intmappings[6] =\n{\n\t&_af_default_signed_integer_pcm_mappings[1],\n\t&_af_default_signed_integer_pcm_mappings[2],\n\t&_af_default_signed_integer_pcm_mappings[3],\n\t&_af_default_signed_integer_pcm_mappings[4],\n\tNULL,\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nstatic const PCMInfo * const intmappings[6] =\n{\n\t&_af_default_signed_integer_pcm_mappings[1],\n\t&_af_default_signed_integer_pcm_mappings[2],\n\t&_af_default_signed_integer_pcm_mappings[3],\n\t&_af_default_signed_integer_pcm_mappings[4],\n\tNULL,\n\tNULL\n};\n\nstatic bool isTrivialIntClip(const AudioFormat &format, FormatCode code)\n{\n\treturn intmappings[code] != NULL &&\n\t\tformat.pcm.minClip == intmappings[code]->minClip &&\n\t\tformat.pcm.maxClip == intmappings[code]->maxClip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addConvertFloatToFloat",
          "args": [
            "infc",
            "outfc"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "addConvertFloatToFloat",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "481-489",
          "snippet": "void ModuleState::addConvertFloatToFloat(FormatCode input, FormatCode output)\n{\n\tif (input == output)\n\t\treturn;\n\n\tassert((input == kFloat && output == kDouble) ||\n\t\t(input == kDouble && output == kFloat));\n\taddModule(new ConvertFloat(input, output));\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  void ModuleState::addConvertFloatToFloat(FormatCode input, FormatCode output)\n  {\n  \tif (input == output)\n  \t\treturn;\n  \n  \tassert((input == kFloat && output == kDouble) ||\n  \t\t(input == kDouble && output == kFloat));\n  \taddModule(new ConvertFloat(input, output));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isFloat",
          "args": [
            "outfc"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "isFloat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "277-277",
          "snippet": "static bool isFloat(FormatCode code) { return code >= kFloat && code <= kDouble; }",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nstatic bool isFloat(FormatCode code) { return code >= kFloat && code <= kDouble; }"
        }
      },
      {
        "call_info": {
          "callee": "addConvertFloatToInt",
          "args": [
            "infc",
            "outfc",
            "in.pcm",
            "out.pcm"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "addConvertFloatToInt",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "475-479",
          "snippet": "void ModuleState::addConvertFloatToInt(FormatCode input, FormatCode output,\n\tconst PCMInfo &inputMapping, const PCMInfo &outputMapping)\n{\n\taddModule(new ConvertFloatToIntClip(input, output, inputMapping, outputMapping));\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  void ModuleState::addConvertFloatToInt(FormatCode input, FormatCode output,\n  \tconst PCMInfo &inputMapping, const PCMInfo &outputMapping)\n  {\n  \taddModule(new ConvertFloatToIntClip(input, output, inputMapping, outputMapping));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isInteger",
          "args": [
            "outfc"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "isInteger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "276-276",
          "snippet": "static bool isInteger(FormatCode code) { return code >= kInt8 && code <= kInt32; }",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nstatic bool isInteger(FormatCode code) { return code >= kInt8 && code <= kInt32; }"
        }
      },
      {
        "call_info": {
          "callee": "addConvertIntToFloat",
          "args": [
            "infc",
            "outfc"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "addConvertIntToFloat",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "470-473",
          "snippet": "void ModuleState::addConvertIntToFloat(FormatCode input, FormatCode output)\n{\n\taddModule(new ConvertIntToFloat(input, output));\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  void ModuleState::addConvertIntToFloat(FormatCode input, FormatCode output)\n  {\n  \taddModule(new ConvertIntToFloat(input, output));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addConvertIntToInt",
          "args": [
            "infc",
            "outfc"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "addConvertIntToInt",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "460-468",
          "snippet": "void ModuleState::addConvertIntToInt(FormatCode input, FormatCode output)\n{\n\tif (input == output)\n\t\treturn;\n\n\tassert(isInteger(input));\n\tassert(isInteger(output));\n\taddModule(new ConvertInt(input, output));\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  void ModuleState::addConvertIntToInt(FormatCode input, FormatCode output)\n  {\n  \tif (input == output)\n  \t\treturn;\n  \n  \tassert(isInteger(input));\n  \tassert(isInteger(output));\n  \taddModule(new ConvertInt(input, output));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isTrivialIntMapping",
          "args": [
            "out",
            "outfc"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "isTrivialIntMapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "279-284",
          "snippet": "static bool isTrivialIntMapping(const AudioFormat &format, FormatCode code)\n{\n\treturn intmappings[code] != NULL &&\n\t\tformat.pcm.slope == intmappings[code]->slope &&\n\t\tformat.pcm.intercept == intmappings[code]->intercept;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const PCMInfo * const intmappings[6] =\n{\n\t&_af_default_signed_integer_pcm_mappings[1],\n\t&_af_default_signed_integer_pcm_mappings[2],\n\t&_af_default_signed_integer_pcm_mappings[3],\n\t&_af_default_signed_integer_pcm_mappings[4],\n\tNULL,\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nstatic const PCMInfo * const intmappings[6] =\n{\n\t&_af_default_signed_integer_pcm_mappings[1],\n\t&_af_default_signed_integer_pcm_mappings[2],\n\t&_af_default_signed_integer_pcm_mappings[3],\n\t&_af_default_signed_integer_pcm_mappings[4],\n\tNULL,\n\tNULL\n};\n\nstatic bool isTrivialIntMapping(const AudioFormat &format, FormatCode code)\n{\n\treturn intmappings[code] != NULL &&\n\t\tformat.pcm.slope == intmappings[code]->slope &&\n\t\tformat.pcm.intercept == intmappings[code]->intercept;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_chunks.back",
          "args": [],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fileRebufferModule.get",
          "args": [],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fileModule.get",
          "args": [],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_modules.clear",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_chunks.back",
          "args": [],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_chunks.push_back",
          "args": [
            "new Chunk()"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_chunks.clear",
          "args": [],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getFormatCode",
          "args": [
            "out"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "getFormatCode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "254-274",
          "snippet": "static FormatCode getFormatCode(const AudioFormat &format)\n{\n\tif (format.sampleFormat == AF_SAMPFMT_FLOAT)\n\t\treturn kFloat;\n\tif (format.sampleFormat == AF_SAMPFMT_DOUBLE)\n\t\treturn kDouble;\n\tif (format.isInteger())\n\t{\n\t\tswitch (format.bytesPerSample(false))\n\t\t{\n\t\t\tcase 1: return kInt8;\n\t\t\tcase 2: return kInt16;\n\t\t\tcase 3: return kInt24;\n\t\t\tcase 4: return kInt32;\n\t\t}\n\t}\n\n\t/* NOTREACHED */\n\tassert(false);\n\treturn kUndefined;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nstatic FormatCode getFormatCode(const AudioFormat &format)\n{\n\tif (format.sampleFormat == AF_SAMPFMT_FLOAT)\n\t\treturn kFloat;\n\tif (format.sampleFormat == AF_SAMPFMT_DOUBLE)\n\t\treturn kDouble;\n\tif (format.isInteger())\n\t{\n\t\tswitch (format.bytesPerSample(false))\n\t\t{\n\t\t\tcase 1: return kInt8;\n\t\t\tcase 2: return kInt16;\n\t\t\tcase 3: return kInt24;\n\t\t\tcase 4: return kInt32;\n\t\t}\n\t}\n\n\t/* NOTREACHED */\n\tassert(false);\n\treturn kUndefined;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nstatic const PCMInfo * const intmappings[6] =\n{\n\t&_af_default_signed_integer_pcm_mappings[1],\n\t&_af_default_signed_integer_pcm_mappings[2],\n\t&_af_default_signed_integer_pcm_mappings[3],\n\t&_af_default_signed_integer_pcm_mappings[4],\n\tNULL,\n\tNULL\n};\n\nModuleState {\n  status ModuleState::arrange(AFfilehandle file, Track *track)\n  {\n  \tbool isReading = file->m_access == _AF_READ_ACCESS;\n  \tAudioFormat in, out;\n  \tif (isReading)\n  \t{\n  \t\tin = track->f;\n  \t\tout = track->v;\n  \t}\n  \telse\n  \t{\n  \t\tin = track->v;\n  \t\tout = track->f;\n  \t}\n  \n  \tFormatCode infc = getFormatCode(in);\n  \tFormatCode outfc = getFormatCode(out);\n  \tif (infc == kUndefined || outfc == kUndefined)\n  \t\treturn AF_FAIL;\n  \n  \tm_chunks.clear();\n  \tm_chunks.push_back(new Chunk());\n  \tm_chunks.back()->f = in;\n  \n  \tm_modules.clear();\n  \n  \tif (isReading)\n  \t{\n  \t\taddModule(m_fileModule.get());\n  \t\taddModule(m_fileRebufferModule.get());\n  \t}\n  \n  \t// Convert to native byte order.\n  \tif (in.byteOrder != _AF_BYTEORDER_NATIVE)\n  \t{\n  \t\tsize_t bytesPerSample = in.bytesPerSample(!isReading);\n  \t\tif (bytesPerSample > 1 && in.compressionType == AF_COMPRESSION_NONE)\n  \t\t\taddModule(new SwapModule());\n  \t\telse\n  \t\t\tin.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t}\n  \n  \t// Handle 24-bit integer input format.\n  \tif (in.isInteger() && in.bytesPerSample(false) == 3)\n  \t{\n  \t\tif (isReading || in.compressionType != AF_COMPRESSION_NONE)\n  \t\t\taddModule(new Expand3To4Module(in.isSigned()));\n  \t}\n  \n  \t// Make data signed.\n  \tif (in.isUnsigned())\n  \t\taddModule(new ConvertSign(infc, false));\n  \n  \tin.pcm = m_chunks.back()->f.pcm;\n  \n  \t// Reverse the unsigned shift for output.\n  \tif (out.isUnsigned())\n  \t{\n  \t\tconst double shift = intmappings[outfc]->minClip;\n  \t\tout.pcm.intercept += shift;\n  \t\tout.pcm.minClip += shift;\n  \t\tout.pcm.maxClip += shift;\n  \t}\n  \n  \t// Clip input samples if necessary.\n  \tif (in.pcm.minClip < in.pcm.maxClip && !isTrivialIntClip(in, infc))\n  \t\taddModule(new Clip(infc, in.pcm));\n  \n  \tbool alreadyClippedOutput = false;\n  \tbool alreadyTransformedOutput = false;\n  \t// Perform range transformation if input and output PCM mappings differ.\n  \tbool transforming = (in.pcm.slope != out.pcm.slope ||\n  \t\tin.pcm.intercept != out.pcm.intercept) &&\n  \t\t!(isTrivialIntMapping(in, infc) &&\n  \t\tisTrivialIntMapping(out, outfc));\n  \n  \t// Range transformation requires input to be floating-point.\n  \tif (isInteger(infc) && transforming)\n  \t{\n  \t\tif (infc == kInt32 || outfc == kDouble || outfc == kInt32)\n  \t\t{\n  \t\t\taddConvertIntToFloat(infc, kDouble);\n  \t\t\tinfc = kDouble;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\taddConvertIntToFloat(infc, kFloat);\n  \t\t\tinfc = kFloat;\n  \t\t}\n  \t}\n  \n  \tif (transforming && infc == kDouble && isFloat(outfc))\n  \t\taddModule(new Transform(infc, in.pcm, out.pcm));\n  \n  \t// Add format conversion if needed.\n  \tif (isInteger(infc) && isInteger(outfc))\n  \t\taddConvertIntToInt(infc, outfc);\n  \telse if (isInteger(infc) && isFloat(outfc))\n  \t\taddConvertIntToFloat(infc, outfc);\n  \telse if (isFloat(infc) && isInteger(outfc))\n  \t{\n  \t\taddConvertFloatToInt(infc, outfc, in.pcm, out.pcm);\n  \t\talreadyClippedOutput = true;\n  \t\talreadyTransformedOutput = true;\n  \t}\n  \telse if (isFloat(infc) && isFloat(outfc))\n  \t\taddConvertFloatToFloat(infc, outfc);\n  \n  \tif (transforming && !alreadyTransformedOutput && infc != kDouble)\n  \t\taddModule(new Transform(outfc, in.pcm, out.pcm));\n  \n  \tif (in.channelCount != out.channelCount)\n  \t\taddModule(new ApplyChannelMatrix(outfc, isReading,\n  \t\t\tin.channelCount, out.channelCount,\n  \t\t\tin.pcm.minClip, in.pcm.maxClip,\n  \t\t\ttrack->channelMatrix));\n  \n  \t// Perform clipping if necessary.\n  \tif (!alreadyClippedOutput)\n  \t{\n  \t\tif (out.pcm.minClip < out.pcm.maxClip && !isTrivialIntClip(out, outfc))\n  \t\t\taddModule(new Clip(outfc, out.pcm));\n  \t}\n  \n  \t// Make data unsigned if necessary.\n  \tif (out.isUnsigned())\n  \t\taddModule(new ConvertSign(outfc, true));\n  \n  \t// Handle 24-bit integer output format.\n  \tif (out.isInteger() && out.bytesPerSample(false) == 3)\n  \t{\n  \t\tif (!isReading || out.compressionType != AF_COMPRESSION_NONE)\n  \t\t\taddModule(new Compress4To3Module(out.isSigned()));\n  \t}\n  \n  \tif (out.byteOrder != _AF_BYTEORDER_NATIVE)\n  \t{\n  \t\tsize_t bytesPerSample = out.bytesPerSample(isReading);\n  \t\tif (bytesPerSample > 1 && out.compressionType == AF_COMPRESSION_NONE)\n  \t\t\taddModule(new SwapModule());\n  \t\telse\n  \t\t\tout.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t}\n  \n  \tif (!isReading)\n  \t{\n  \t\taddModule(m_fileRebufferModule.get());\n  \t\taddModule(m_fileModule.get());\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "isTrivialIntClip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "286-291",
    "snippet": "static bool isTrivialIntClip(const AudioFormat &format, FormatCode code)\n{\n\treturn intmappings[code] != NULL &&\n\t\tformat.pcm.minClip == intmappings[code]->minClip &&\n\t\tformat.pcm.maxClip == intmappings[code]->maxClip;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const PCMInfo * const intmappings[6] =\n{\n\t&_af_default_signed_integer_pcm_mappings[1],\n\t&_af_default_signed_integer_pcm_mappings[2],\n\t&_af_default_signed_integer_pcm_mappings[3],\n\t&_af_default_signed_integer_pcm_mappings[4],\n\tNULL,\n\tNULL\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nstatic const PCMInfo * const intmappings[6] =\n{\n\t&_af_default_signed_integer_pcm_mappings[1],\n\t&_af_default_signed_integer_pcm_mappings[2],\n\t&_af_default_signed_integer_pcm_mappings[3],\n\t&_af_default_signed_integer_pcm_mappings[4],\n\tNULL,\n\tNULL\n};\n\nstatic bool isTrivialIntClip(const AudioFormat &format, FormatCode code)\n{\n\treturn intmappings[code] != NULL &&\n\t\tformat.pcm.minClip == intmappings[code]->minClip &&\n\t\tformat.pcm.maxClip == intmappings[code]->maxClip;\n}"
  },
  {
    "function_name": "isTrivialIntMapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "279-284",
    "snippet": "static bool isTrivialIntMapping(const AudioFormat &format, FormatCode code)\n{\n\treturn intmappings[code] != NULL &&\n\t\tformat.pcm.slope == intmappings[code]->slope &&\n\t\tformat.pcm.intercept == intmappings[code]->intercept;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const PCMInfo * const intmappings[6] =\n{\n\t&_af_default_signed_integer_pcm_mappings[1],\n\t&_af_default_signed_integer_pcm_mappings[2],\n\t&_af_default_signed_integer_pcm_mappings[3],\n\t&_af_default_signed_integer_pcm_mappings[4],\n\tNULL,\n\tNULL\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nstatic const PCMInfo * const intmappings[6] =\n{\n\t&_af_default_signed_integer_pcm_mappings[1],\n\t&_af_default_signed_integer_pcm_mappings[2],\n\t&_af_default_signed_integer_pcm_mappings[3],\n\t&_af_default_signed_integer_pcm_mappings[4],\n\tNULL,\n\tNULL\n};\n\nstatic bool isTrivialIntMapping(const AudioFormat &format, FormatCode code)\n{\n\treturn intmappings[code] != NULL &&\n\t\tformat.pcm.slope == intmappings[code]->slope &&\n\t\tformat.pcm.intercept == intmappings[code]->intercept;\n}"
  },
  {
    "function_name": "isFloat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "277-277",
    "snippet": "static bool isFloat(FormatCode code) { return code >= kFloat && code <= kDouble; }",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nstatic bool isFloat(FormatCode code) { return code >= kFloat && code <= kDouble; }"
  },
  {
    "function_name": "isInteger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "276-276",
    "snippet": "static bool isInteger(FormatCode code) { return code >= kInt8 && code <= kInt32; }",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nstatic bool isInteger(FormatCode code) { return code >= kInt8 && code <= kInt32; }"
  },
  {
    "function_name": "getFormatCode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "254-274",
    "snippet": "static FormatCode getFormatCode(const AudioFormat &format)\n{\n\tif (format.sampleFormat == AF_SAMPFMT_FLOAT)\n\t\treturn kFloat;\n\tif (format.sampleFormat == AF_SAMPFMT_DOUBLE)\n\t\treturn kDouble;\n\tif (format.isInteger())\n\t{\n\t\tswitch (format.bytesPerSample(false))\n\t\t{\n\t\t\tcase 1: return kInt8;\n\t\t\tcase 2: return kInt16;\n\t\t\tcase 3: return kInt24;\n\t\t\tcase 4: return kInt32;\n\t\t}\n\t}\n\n\t/* NOTREACHED */\n\tassert(false);\n\treturn kUndefined;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "false"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format.bytesPerSample",
          "args": [
            "false"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "bytesPerSample",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "32-49",
          "snippet": "size_t AudioFormat::bytesPerSample(bool stretch3to4) const\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\treturn sizeof (float);\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\treturn sizeof (double);\n\t\tdefault:\n\t\t{\n\t\t\tint size = (sampleWidth + 7) / 8;\n\t\t\tif (compressionType == AF_COMPRESSION_NONE &&\n\t\t\t\tsize == 3 && stretch3to4)\n\t\t\t\tsize = 4;\n\t\t\treturn size;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  size_t AudioFormat::bytesPerSample(bool stretch3to4) const\n  {\n  \tswitch (sampleFormat)\n  \t{\n  \t\tcase AF_SAMPFMT_FLOAT:\n  \t\t\treturn sizeof (float);\n  \t\tcase AF_SAMPFMT_DOUBLE:\n  \t\t\treturn sizeof (double);\n  \t\tdefault:\n  \t\t{\n  \t\t\tint size = (sampleWidth + 7) / 8;\n  \t\t\tif (compressionType == AF_COMPRESSION_NONE &&\n  \t\t\t\tsize == 3 && stretch3to4)\n  \t\t\t\tsize = 4;\n  \t\t\treturn size;\n  \t\t}\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "format.isInteger",
          "args": [],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "isInteger",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "66-70",
          "snippet": "bool AudioFormat::isInteger() const\n{\n\treturn sampleFormat == AF_SAMPFMT_TWOSCOMP ||\n\t\tsampleFormat == AF_SAMPFMT_UNSIGNED;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  bool AudioFormat::isInteger() const\n  {\n  \treturn sampleFormat == AF_SAMPFMT_TWOSCOMP ||\n  \t\tsampleFormat == AF_SAMPFMT_UNSIGNED;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nstatic FormatCode getFormatCode(const AudioFormat &format)\n{\n\tif (format.sampleFormat == AF_SAMPFMT_FLOAT)\n\t\treturn kFloat;\n\tif (format.sampleFormat == AF_SAMPFMT_DOUBLE)\n\t\treturn kDouble;\n\tif (format.isInteger())\n\t{\n\t\tswitch (format.bytesPerSample(false))\n\t\t{\n\t\t\tcase 1: return kInt8;\n\t\t\tcase 2: return kInt16;\n\t\t\tcase 3: return kInt24;\n\t\t\tcase 4: return kInt32;\n\t\t}\n\t}\n\n\t/* NOTREACHED */\n\tassert(false);\n\treturn kUndefined;\n}"
  },
  {
    "function_name": "sync",
    "container": "ModuleState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "230-242",
    "snippet": "status ModuleState::sync(AFfilehandle file, Track *track)\n{\n\ttrack->filemodhappy = true;\n\tfor (std::vector<SharedPtr<Module> >::reverse_iterator i=m_modules.rbegin();\n\t\t\ti != m_modules.rend(); ++i)\n\t\t(*i)->sync1();\n\tif (!track->filemodhappy)\n\t\treturn AF_FAIL;\n\tfor (std::vector<SharedPtr<Module> >::iterator i=m_modules.begin();\n\t\t\ti != m_modules.end(); ++i)\n\t\t(*i)->sync2();\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_modules.end",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_modules.begin",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_modules.rend",
          "args": [],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_modules.rbegin",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  status ModuleState::sync(AFfilehandle file, Track *track)\n  {\n  \ttrack->filemodhappy = true;\n  \tfor (std::vector<SharedPtr<Module> >::reverse_iterator i=m_modules.rbegin();\n  \t\t\ti != m_modules.rend(); ++i)\n  \t\t(*i)->sync1();\n  \tif (!track->filemodhappy)\n  \t\treturn AF_FAIL;\n  \tfor (std::vector<SharedPtr<Module> >::iterator i=m_modules.begin();\n  \t\t\ti != m_modules.end(); ++i)\n  \t\t(*i)->sync2();\n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "reset",
    "container": "ModuleState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "213-228",
    "snippet": "status ModuleState::reset(AFfilehandle file, Track *track)\n{\n\ttrack->filemodhappy = true;\n\tfor (std::vector<SharedPtr<Module> >::reverse_iterator i=m_modules.rbegin();\n\t\t\ti != m_modules.rend(); ++i)\n\t\t(*i)->reset1();\n\ttrack->frames2ignore = 0;\n\tif (!track->filemodhappy)\n\t\treturn AF_FAIL;\n\tfor (std::vector<SharedPtr<Module> >::iterator i=m_modules.begin();\n\t\t\ti != m_modules.end(); ++i)\n\t\t(*i)->reset2();\n\tif (!track->filemodhappy)\n\t\treturn AF_FAIL;\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_modules.end",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_modules.begin",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_modules.rend",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_modules.rbegin",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  status ModuleState::reset(AFfilehandle file, Track *track)\n  {\n  \ttrack->filemodhappy = true;\n  \tfor (std::vector<SharedPtr<Module> >::reverse_iterator i=m_modules.rbegin();\n  \t\t\ti != m_modules.rend(); ++i)\n  \t\t(*i)->reset1();\n  \ttrack->frames2ignore = 0;\n  \tif (!track->filemodhappy)\n  \t\treturn AF_FAIL;\n  \tfor (std::vector<SharedPtr<Module> >::iterator i=m_modules.begin();\n  \t\t\ti != m_modules.end(); ++i)\n  \t\t(*i)->reset2();\n  \tif (!track->filemodhappy)\n  \t\treturn AF_FAIL;\n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "setup",
    "container": "ModuleState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "109-201",
    "snippet": "status ModuleState::setup(AFfilehandle file, Track *track)\n{\n\tAFframecount fframepos = llrint(track->nextvframe * track->f.sampleRate / track->v.sampleRate);\n\tbool isReading = file->m_access == _AF_READ_ACCESS;\n\n\tif (!track->v.isUncompressed())\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\"library does not support compression in virtual format yet\");\n\t\treturn AF_FAIL;\n\t}\n\n\tif (arrange(file, track) == AF_FAIL)\n\t\treturn AF_FAIL;\n\n\ttrack->filemodhappy = true;\n\tint maxbufsize = 0;\n\tif (isReading)\n\t{\n\t\tm_chunks.back()->frameCount = _AF_ATOMIC_NVFRAMES;\n\t\tfor (int i=m_modules.size() - 1; i >= 0; i--)\n\t\t{\n\t\t\tSharedPtr<Chunk> inChunk = m_chunks[i];\n\t\t\tSharedPtr<Chunk> outChunk = m_chunks[i+1];\n\t\t\tint bufsize = outChunk->frameCount * outChunk->f.bytesPerFrame(true);\n\t\t\tif (bufsize > maxbufsize)\n\t\t\t\tmaxbufsize = bufsize;\n\t\t\tif (i != 0)\n\t\t\t\tm_modules[i]->setSource(m_modules[i-1].get());\n\t\t\tm_modules[i]->maxPull();\n\t\t}\n\n\t\tif (!track->filemodhappy)\n\t\t\treturn AF_FAIL;\n\t\tint bufsize = m_fileModule->bufferSize();\n\t\tif (bufsize > maxbufsize)\n\t\t\tmaxbufsize = bufsize;\n\t}\n\telse\n\t{\n\t\tm_chunks.front()->frameCount = _AF_ATOMIC_NVFRAMES;\n\t\tfor (size_t i=0; i<m_modules.size(); i++)\n\t\t{\n\t\t\tSharedPtr<Chunk> inChunk = m_chunks[i];\n\t\t\tSharedPtr<Chunk> outChunk = m_chunks[i+1];\n\t\t\tint bufsize = inChunk->frameCount * inChunk->f.bytesPerFrame(true);\n\t\t\tif (bufsize > maxbufsize)\n\t\t\t\tmaxbufsize = bufsize;\n\t\t\tif (i != m_modules.size() - 1)\n\t\t\t\tm_modules[i]->setSink(m_modules[i+1].get());\n\t\t\tm_modules[i]->maxPush();\n\t\t}\n\n\t\tif (!track->filemodhappy)\n\t\t\treturn AF_FAIL;\n\n\t\tint bufsize = m_fileModule->bufferSize();\n\t\tif (bufsize > maxbufsize)\n\t\t\tmaxbufsize = bufsize;\n\t}\n\n\tfor (size_t i=0; i<m_chunks.size(); i++)\n\t{\n\t\tif ((isReading && i==m_chunks.size() - 1) || (!isReading && i==0))\n\t\t\tcontinue;\n\t\tm_chunks[i]->allocate(maxbufsize);\n\t}\n\n\tif (isReading)\n\t{\n\t\tif (track->totalfframes == -1)\n\t\t\ttrack->totalvframes = -1;\n\t\telse\n\t\t\ttrack->totalvframes = llrint(track->totalfframes *\n\t\t\t\t(track->v.sampleRate / track->f.sampleRate));\n\n\t\ttrack->nextfframe = fframepos;\n\t\ttrack->nextvframe = llrint(fframepos * track->v.sampleRate / track->f.sampleRate);\n\n\t\tm_isDirty = false;\n\n\t\tif (reset(file, track) == AF_FAIL)\n\t\t\treturn AF_FAIL;\n\t}\n\telse\n\t{\n\t\ttrack->nextvframe = track->totalvframes =\n\t\t\t(AFframecount) (fframepos * track->v.sampleRate / track->f.sampleRate);\n\t\tm_isDirty = false;\n\t}\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "fframepos * track->v.sampleRate / track->f.sampleRate"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reset",
          "args": [
            "file",
            "track"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "reset",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "213-228",
          "snippet": "status ModuleState::reset(AFfilehandle file, Track *track)\n{\n\ttrack->filemodhappy = true;\n\tfor (std::vector<SharedPtr<Module> >::reverse_iterator i=m_modules.rbegin();\n\t\t\ti != m_modules.rend(); ++i)\n\t\t(*i)->reset1();\n\ttrack->frames2ignore = 0;\n\tif (!track->filemodhappy)\n\t\treturn AF_FAIL;\n\tfor (std::vector<SharedPtr<Module> >::iterator i=m_modules.begin();\n\t\t\ti != m_modules.end(); ++i)\n\t\t(*i)->reset2();\n\tif (!track->filemodhappy)\n\t\treturn AF_FAIL;\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  status ModuleState::reset(AFfilehandle file, Track *track)\n  {\n  \ttrack->filemodhappy = true;\n  \tfor (std::vector<SharedPtr<Module> >::reverse_iterator i=m_modules.rbegin();\n  \t\t\ti != m_modules.rend(); ++i)\n  \t\t(*i)->reset1();\n  \ttrack->frames2ignore = 0;\n  \tif (!track->filemodhappy)\n  \t\treturn AF_FAIL;\n  \tfor (std::vector<SharedPtr<Module> >::iterator i=m_modules.begin();\n  \t\t\ti != m_modules.end(); ++i)\n  \t\t(*i)->reset2();\n  \tif (!track->filemodhappy)\n  \t\treturn AF_FAIL;\n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "llrint",
          "args": [
            "fframepos * track->v.sampleRate / track->f.sampleRate"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llrint",
          "args": [
            "track->totalfframes *\n\t\t\t\t(track->v.sampleRate / track->f.sampleRate)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_chunks[i]->allocate",
          "args": [
            "maxbufsize"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "allocate",
          "container": "Chunk",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.h",
          "lines": "55-60",
          "snippet": "void allocate(size_t capacity)\n\t{\n\t\tdeallocate();\n\t\townsMemory = true;\n\t\tbuffer = ::operator new(capacity);\n\t}",
          "includes": [
            "#include <vector>",
            "#include \"afinternal.h\"",
            "#include \"Shared.h\"",
            "#include \"AudioFormat.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"afinternal.h\"\n#include \"Shared.h\"\n#include \"AudioFormat.h\"\n\nChunk {\n  void allocate(size_t capacity)\n  \t{\n  \t\tdeallocate();\n  \t\townsMemory = true;\n  \t\tbuffer = ::operator new(capacity);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_chunks.size",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Buffer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Buffer.h",
          "lines": "39-39",
          "snippet": "size_t size() const { return m_size; }",
          "includes": [
            "#include <sys/types.h>",
            "#include \"Shared.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"Shared.h\"\n\nBuffer {\n  size_t size() const { return m_size; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fileModule->bufferSize",
          "args": [],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "bufferSize",
          "container": "ALAC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ALAC.cpp",
          "lines": "273-277",
          "snippet": "int ALAC::bufferSize() const\n{\n\treturn m_track->f.framesPerPacket * m_track->f.channelCount *\n\t\t((10 + m_track->f.sampleWidth) / 8) + 1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"../alac/ALACEncoder.h\"",
            "#include \"../alac/ALACDecoder.h\"",
            "#include \"../alac/ALACBitUtilities.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"PacketTable.h\"",
            "#include \"FileModule.h\"",
            "#include \"File.h\"",
            "#include \"Compiler.h\"",
            "#include \"Buffer.h\"",
            "#include \"ALAC.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"../alac/ALACEncoder.h\"\n#include \"../alac/ALACDecoder.h\"\n#include \"../alac/ALACBitUtilities.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"PacketTable.h\"\n#include \"FileModule.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"Buffer.h\"\n#include \"ALAC.h\"\n#include \"config.h\"\n\nALAC {\n  int ALAC::bufferSize() const\n  {\n  \treturn m_track->f.framesPerPacket * m_track->f.channelCount *\n  \t\t((10 + m_track->f.sampleWidth) / 8) + 1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_modules[i]->maxPush",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "maxPush",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.cpp",
          "lines": "55-58",
          "snippet": "void Module::maxPush()\n{\n\tm_outChunk->frameCount = m_inChunk->frameCount;\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"File.h\"",
            "#include \"Module.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"SimpleModule.h\"\n#include \"File.h\"\n#include \"Module.h\"\n#include \"config.h\"\n\nModule {\n  void Module::maxPush()\n  {\n  \tm_outChunk->frameCount = m_inChunk->frameCount;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_modules[i]->setSink",
          "args": [
            "m_modules[i+1].get()"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "setSink",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.cpp",
          "lines": "41-41",
          "snippet": "void Module::setSink(Module *module) { m_sink = module; }",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"File.h\"",
            "#include \"Module.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"SimpleModule.h\"\n#include \"File.h\"\n#include \"Module.h\"\n#include \"config.h\"\n\nModule {\n  void Module::setSink(Module *module) { m_sink = module; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_modules[i+1].get",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inChunk->f.bytesPerFrame",
          "args": [
            "true"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "bytesPerFrame",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "51-54",
          "snippet": "size_t AudioFormat::bytesPerFrame(bool stretch3to4) const\n{\n\treturn bytesPerSample(stretch3to4) * channelCount;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  size_t AudioFormat::bytesPerFrame(bool stretch3to4) const\n  {\n  \treturn bytesPerSample(stretch3to4) * channelCount;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_chunks.front",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_modules[i]->maxPull",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "maxPull",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.cpp",
          "lines": "50-53",
          "snippet": "void Module::maxPull()\n{\n\tm_inChunk->frameCount = m_outChunk->frameCount;\n}",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"File.h\"",
            "#include \"Module.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"SimpleModule.h\"\n#include \"File.h\"\n#include \"Module.h\"\n#include \"config.h\"\n\nModule {\n  void Module::maxPull()\n  {\n  \tm_inChunk->frameCount = m_outChunk->frameCount;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_modules[i]->setSource",
          "args": [
            "m_modules[i-1].get()"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "setSource",
          "container": "Module",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/Module.cpp",
          "lines": "42-42",
          "snippet": "void Module::setSource(Module *module) { m_source = module; }",
          "includes": [
            "#include \"../pcm.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"File.h\"",
            "#include \"Module.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pcm.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"SimpleModule.h\"\n#include \"File.h\"\n#include \"Module.h\"\n#include \"config.h\"\n\nModule {\n  void Module::setSource(Module *module) { m_source = module; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_modules[i-1].get",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_chunks.back",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arrange",
          "args": [
            "file",
            "track"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "arrange",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "293-444",
          "snippet": "status ModuleState::arrange(AFfilehandle file, Track *track)\n{\n\tbool isReading = file->m_access == _AF_READ_ACCESS;\n\tAudioFormat in, out;\n\tif (isReading)\n\t{\n\t\tin = track->f;\n\t\tout = track->v;\n\t}\n\telse\n\t{\n\t\tin = track->v;\n\t\tout = track->f;\n\t}\n\n\tFormatCode infc = getFormatCode(in);\n\tFormatCode outfc = getFormatCode(out);\n\tif (infc == kUndefined || outfc == kUndefined)\n\t\treturn AF_FAIL;\n\n\tm_chunks.clear();\n\tm_chunks.push_back(new Chunk());\n\tm_chunks.back()->f = in;\n\n\tm_modules.clear();\n\n\tif (isReading)\n\t{\n\t\taddModule(m_fileModule.get());\n\t\taddModule(m_fileRebufferModule.get());\n\t}\n\n\t// Convert to native byte order.\n\tif (in.byteOrder != _AF_BYTEORDER_NATIVE)\n\t{\n\t\tsize_t bytesPerSample = in.bytesPerSample(!isReading);\n\t\tif (bytesPerSample > 1 && in.compressionType == AF_COMPRESSION_NONE)\n\t\t\taddModule(new SwapModule());\n\t\telse\n\t\t\tin.byteOrder = _AF_BYTEORDER_NATIVE;\n\t}\n\n\t// Handle 24-bit integer input format.\n\tif (in.isInteger() && in.bytesPerSample(false) == 3)\n\t{\n\t\tif (isReading || in.compressionType != AF_COMPRESSION_NONE)\n\t\t\taddModule(new Expand3To4Module(in.isSigned()));\n\t}\n\n\t// Make data signed.\n\tif (in.isUnsigned())\n\t\taddModule(new ConvertSign(infc, false));\n\n\tin.pcm = m_chunks.back()->f.pcm;\n\n\t// Reverse the unsigned shift for output.\n\tif (out.isUnsigned())\n\t{\n\t\tconst double shift = intmappings[outfc]->minClip;\n\t\tout.pcm.intercept += shift;\n\t\tout.pcm.minClip += shift;\n\t\tout.pcm.maxClip += shift;\n\t}\n\n\t// Clip input samples if necessary.\n\tif (in.pcm.minClip < in.pcm.maxClip && !isTrivialIntClip(in, infc))\n\t\taddModule(new Clip(infc, in.pcm));\n\n\tbool alreadyClippedOutput = false;\n\tbool alreadyTransformedOutput = false;\n\t// Perform range transformation if input and output PCM mappings differ.\n\tbool transforming = (in.pcm.slope != out.pcm.slope ||\n\t\tin.pcm.intercept != out.pcm.intercept) &&\n\t\t!(isTrivialIntMapping(in, infc) &&\n\t\tisTrivialIntMapping(out, outfc));\n\n\t// Range transformation requires input to be floating-point.\n\tif (isInteger(infc) && transforming)\n\t{\n\t\tif (infc == kInt32 || outfc == kDouble || outfc == kInt32)\n\t\t{\n\t\t\taddConvertIntToFloat(infc, kDouble);\n\t\t\tinfc = kDouble;\n\t\t}\n\t\telse\n\t\t{\n\t\t\taddConvertIntToFloat(infc, kFloat);\n\t\t\tinfc = kFloat;\n\t\t}\n\t}\n\n\tif (transforming && infc == kDouble && isFloat(outfc))\n\t\taddModule(new Transform(infc, in.pcm, out.pcm));\n\n\t// Add format conversion if needed.\n\tif (isInteger(infc) && isInteger(outfc))\n\t\taddConvertIntToInt(infc, outfc);\n\telse if (isInteger(infc) && isFloat(outfc))\n\t\taddConvertIntToFloat(infc, outfc);\n\telse if (isFloat(infc) && isInteger(outfc))\n\t{\n\t\taddConvertFloatToInt(infc, outfc, in.pcm, out.pcm);\n\t\talreadyClippedOutput = true;\n\t\talreadyTransformedOutput = true;\n\t}\n\telse if (isFloat(infc) && isFloat(outfc))\n\t\taddConvertFloatToFloat(infc, outfc);\n\n\tif (transforming && !alreadyTransformedOutput && infc != kDouble)\n\t\taddModule(new Transform(outfc, in.pcm, out.pcm));\n\n\tif (in.channelCount != out.channelCount)\n\t\taddModule(new ApplyChannelMatrix(outfc, isReading,\n\t\t\tin.channelCount, out.channelCount,\n\t\t\tin.pcm.minClip, in.pcm.maxClip,\n\t\t\ttrack->channelMatrix));\n\n\t// Perform clipping if necessary.\n\tif (!alreadyClippedOutput)\n\t{\n\t\tif (out.pcm.minClip < out.pcm.maxClip && !isTrivialIntClip(out, outfc))\n\t\t\taddModule(new Clip(outfc, out.pcm));\n\t}\n\n\t// Make data unsigned if necessary.\n\tif (out.isUnsigned())\n\t\taddModule(new ConvertSign(outfc, true));\n\n\t// Handle 24-bit integer output format.\n\tif (out.isInteger() && out.bytesPerSample(false) == 3)\n\t{\n\t\tif (!isReading || out.compressionType != AF_COMPRESSION_NONE)\n\t\t\taddModule(new Compress4To3Module(out.isSigned()));\n\t}\n\n\tif (out.byteOrder != _AF_BYTEORDER_NATIVE)\n\t{\n\t\tsize_t bytesPerSample = out.bytesPerSample(isReading);\n\t\tif (bytesPerSample > 1 && out.compressionType == AF_COMPRESSION_NONE)\n\t\t\taddModule(new SwapModule());\n\t\telse\n\t\t\tout.byteOrder = _AF_BYTEORDER_NATIVE;\n\t}\n\n\tif (!isReading)\n\t{\n\t\taddModule(m_fileRebufferModule.get());\n\t\taddModule(m_fileModule.get());\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const PCMInfo * const intmappings[6] =\n{\n\t&_af_default_signed_integer_pcm_mappings[1],\n\t&_af_default_signed_integer_pcm_mappings[2],\n\t&_af_default_signed_integer_pcm_mappings[3],\n\t&_af_default_signed_integer_pcm_mappings[4],\n\tNULL,\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nstatic const PCMInfo * const intmappings[6] =\n{\n\t&_af_default_signed_integer_pcm_mappings[1],\n\t&_af_default_signed_integer_pcm_mappings[2],\n\t&_af_default_signed_integer_pcm_mappings[3],\n\t&_af_default_signed_integer_pcm_mappings[4],\n\tNULL,\n\tNULL\n};\n\nModuleState {\n  status ModuleState::arrange(AFfilehandle file, Track *track)\n  {\n  \tbool isReading = file->m_access == _AF_READ_ACCESS;\n  \tAudioFormat in, out;\n  \tif (isReading)\n  \t{\n  \t\tin = track->f;\n  \t\tout = track->v;\n  \t}\n  \telse\n  \t{\n  \t\tin = track->v;\n  \t\tout = track->f;\n  \t}\n  \n  \tFormatCode infc = getFormatCode(in);\n  \tFormatCode outfc = getFormatCode(out);\n  \tif (infc == kUndefined || outfc == kUndefined)\n  \t\treturn AF_FAIL;\n  \n  \tm_chunks.clear();\n  \tm_chunks.push_back(new Chunk());\n  \tm_chunks.back()->f = in;\n  \n  \tm_modules.clear();\n  \n  \tif (isReading)\n  \t{\n  \t\taddModule(m_fileModule.get());\n  \t\taddModule(m_fileRebufferModule.get());\n  \t}\n  \n  \t// Convert to native byte order.\n  \tif (in.byteOrder != _AF_BYTEORDER_NATIVE)\n  \t{\n  \t\tsize_t bytesPerSample = in.bytesPerSample(!isReading);\n  \t\tif (bytesPerSample > 1 && in.compressionType == AF_COMPRESSION_NONE)\n  \t\t\taddModule(new SwapModule());\n  \t\telse\n  \t\t\tin.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t}\n  \n  \t// Handle 24-bit integer input format.\n  \tif (in.isInteger() && in.bytesPerSample(false) == 3)\n  \t{\n  \t\tif (isReading || in.compressionType != AF_COMPRESSION_NONE)\n  \t\t\taddModule(new Expand3To4Module(in.isSigned()));\n  \t}\n  \n  \t// Make data signed.\n  \tif (in.isUnsigned())\n  \t\taddModule(new ConvertSign(infc, false));\n  \n  \tin.pcm = m_chunks.back()->f.pcm;\n  \n  \t// Reverse the unsigned shift for output.\n  \tif (out.isUnsigned())\n  \t{\n  \t\tconst double shift = intmappings[outfc]->minClip;\n  \t\tout.pcm.intercept += shift;\n  \t\tout.pcm.minClip += shift;\n  \t\tout.pcm.maxClip += shift;\n  \t}\n  \n  \t// Clip input samples if necessary.\n  \tif (in.pcm.minClip < in.pcm.maxClip && !isTrivialIntClip(in, infc))\n  \t\taddModule(new Clip(infc, in.pcm));\n  \n  \tbool alreadyClippedOutput = false;\n  \tbool alreadyTransformedOutput = false;\n  \t// Perform range transformation if input and output PCM mappings differ.\n  \tbool transforming = (in.pcm.slope != out.pcm.slope ||\n  \t\tin.pcm.intercept != out.pcm.intercept) &&\n  \t\t!(isTrivialIntMapping(in, infc) &&\n  \t\tisTrivialIntMapping(out, outfc));\n  \n  \t// Range transformation requires input to be floating-point.\n  \tif (isInteger(infc) && transforming)\n  \t{\n  \t\tif (infc == kInt32 || outfc == kDouble || outfc == kInt32)\n  \t\t{\n  \t\t\taddConvertIntToFloat(infc, kDouble);\n  \t\t\tinfc = kDouble;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\taddConvertIntToFloat(infc, kFloat);\n  \t\t\tinfc = kFloat;\n  \t\t}\n  \t}\n  \n  \tif (transforming && infc == kDouble && isFloat(outfc))\n  \t\taddModule(new Transform(infc, in.pcm, out.pcm));\n  \n  \t// Add format conversion if needed.\n  \tif (isInteger(infc) && isInteger(outfc))\n  \t\taddConvertIntToInt(infc, outfc);\n  \telse if (isInteger(infc) && isFloat(outfc))\n  \t\taddConvertIntToFloat(infc, outfc);\n  \telse if (isFloat(infc) && isInteger(outfc))\n  \t{\n  \t\taddConvertFloatToInt(infc, outfc, in.pcm, out.pcm);\n  \t\talreadyClippedOutput = true;\n  \t\talreadyTransformedOutput = true;\n  \t}\n  \telse if (isFloat(infc) && isFloat(outfc))\n  \t\taddConvertFloatToFloat(infc, outfc);\n  \n  \tif (transforming && !alreadyTransformedOutput && infc != kDouble)\n  \t\taddModule(new Transform(outfc, in.pcm, out.pcm));\n  \n  \tif (in.channelCount != out.channelCount)\n  \t\taddModule(new ApplyChannelMatrix(outfc, isReading,\n  \t\t\tin.channelCount, out.channelCount,\n  \t\t\tin.pcm.minClip, in.pcm.maxClip,\n  \t\t\ttrack->channelMatrix));\n  \n  \t// Perform clipping if necessary.\n  \tif (!alreadyClippedOutput)\n  \t{\n  \t\tif (out.pcm.minClip < out.pcm.maxClip && !isTrivialIntClip(out, outfc))\n  \t\t\taddModule(new Clip(outfc, out.pcm));\n  \t}\n  \n  \t// Make data unsigned if necessary.\n  \tif (out.isUnsigned())\n  \t\taddModule(new ConvertSign(outfc, true));\n  \n  \t// Handle 24-bit integer output format.\n  \tif (out.isInteger() && out.bytesPerSample(false) == 3)\n  \t{\n  \t\tif (!isReading || out.compressionType != AF_COMPRESSION_NONE)\n  \t\t\taddModule(new Compress4To3Module(out.isSigned()));\n  \t}\n  \n  \tif (out.byteOrder != _AF_BYTEORDER_NATIVE)\n  \t{\n  \t\tsize_t bytesPerSample = out.bytesPerSample(isReading);\n  \t\tif (bytesPerSample > 1 && out.compressionType == AF_COMPRESSION_NONE)\n  \t\t\taddModule(new SwapModule());\n  \t\telse\n  \t\t\tout.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t}\n  \n  \tif (!isReading)\n  \t{\n  \t\taddModule(m_fileRebufferModule.get());\n  \t\taddModule(m_fileModule.get());\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"library does not support compression in virtual format yet\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track->v.isUncompressed",
          "args": [],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "isUncompressed",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "93-96",
          "snippet": "bool AudioFormat::isUncompressed() const\n{\n\treturn compressionType == AF_COMPRESSION_NONE;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  bool AudioFormat::isUncompressed() const\n  {\n  \treturn compressionType == AF_COMPRESSION_NONE;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "llrint",
          "args": [
            "track->nextvframe * track->f.sampleRate / track->v.sampleRate"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  status ModuleState::setup(AFfilehandle file, Track *track)\n  {\n  \tAFframecount fframepos = llrint(track->nextvframe * track->f.sampleRate / track->v.sampleRate);\n  \tbool isReading = file->m_access == _AF_READ_ACCESS;\n  \n  \tif (!track->v.isUncompressed())\n  \t{\n  \t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n  \t\t\t\"library does not support compression in virtual format yet\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \tif (arrange(file, track) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \n  \ttrack->filemodhappy = true;\n  \tint maxbufsize = 0;\n  \tif (isReading)\n  \t{\n  \t\tm_chunks.back()->frameCount = _AF_ATOMIC_NVFRAMES;\n  \t\tfor (int i=m_modules.size() - 1; i >= 0; i--)\n  \t\t{\n  \t\t\tSharedPtr<Chunk> inChunk = m_chunks[i];\n  \t\t\tSharedPtr<Chunk> outChunk = m_chunks[i+1];\n  \t\t\tint bufsize = outChunk->frameCount * outChunk->f.bytesPerFrame(true);\n  \t\t\tif (bufsize > maxbufsize)\n  \t\t\t\tmaxbufsize = bufsize;\n  \t\t\tif (i != 0)\n  \t\t\t\tm_modules[i]->setSource(m_modules[i-1].get());\n  \t\t\tm_modules[i]->maxPull();\n  \t\t}\n  \n  \t\tif (!track->filemodhappy)\n  \t\t\treturn AF_FAIL;\n  \t\tint bufsize = m_fileModule->bufferSize();\n  \t\tif (bufsize > maxbufsize)\n  \t\t\tmaxbufsize = bufsize;\n  \t}\n  \telse\n  \t{\n  \t\tm_chunks.front()->frameCount = _AF_ATOMIC_NVFRAMES;\n  \t\tfor (size_t i=0; i<m_modules.size(); i++)\n  \t\t{\n  \t\t\tSharedPtr<Chunk> inChunk = m_chunks[i];\n  \t\t\tSharedPtr<Chunk> outChunk = m_chunks[i+1];\n  \t\t\tint bufsize = inChunk->frameCount * inChunk->f.bytesPerFrame(true);\n  \t\t\tif (bufsize > maxbufsize)\n  \t\t\t\tmaxbufsize = bufsize;\n  \t\t\tif (i != m_modules.size() - 1)\n  \t\t\t\tm_modules[i]->setSink(m_modules[i+1].get());\n  \t\t\tm_modules[i]->maxPush();\n  \t\t}\n  \n  \t\tif (!track->filemodhappy)\n  \t\t\treturn AF_FAIL;\n  \n  \t\tint bufsize = m_fileModule->bufferSize();\n  \t\tif (bufsize > maxbufsize)\n  \t\t\tmaxbufsize = bufsize;\n  \t}\n  \n  \tfor (size_t i=0; i<m_chunks.size(); i++)\n  \t{\n  \t\tif ((isReading && i==m_chunks.size() - 1) || (!isReading && i==0))\n  \t\t\tcontinue;\n  \t\tm_chunks[i]->allocate(maxbufsize);\n  \t}\n  \n  \tif (isReading)\n  \t{\n  \t\tif (track->totalfframes == -1)\n  \t\t\ttrack->totalvframes = -1;\n  \t\telse\n  \t\t\ttrack->totalvframes = llrint(track->totalfframes *\n  \t\t\t\t(track->v.sampleRate / track->f.sampleRate));\n  \n  \t\ttrack->nextfframe = fframepos;\n  \t\ttrack->nextvframe = llrint(fframepos * track->v.sampleRate / track->f.sampleRate);\n  \n  \t\tm_isDirty = false;\n  \n  \t\tif (reset(file, track) == AF_FAIL)\n  \t\t\treturn AF_FAIL;\n  \t}\n  \telse\n  \t{\n  \t\ttrack->nextvframe = track->totalvframes =\n  \t\t\t(AFframecount) (fframepos * track->v.sampleRate / track->f.sampleRate);\n  \t\tm_isDirty = false;\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "fileModuleHandlesSeeking",
    "container": "ModuleState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "104-107",
    "snippet": "bool ModuleState::fileModuleHandlesSeeking() const\n{\n\treturn m_fileModule->handlesSeeking();\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fileModule->handlesSeeking",
          "args": [],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "handlesSeeking",
          "container": "FLACEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/FLAC.cpp",
          "lines": "290-290",
          "snippet": "virtual bool handlesSeeking() const OVERRIDE { return true; }",
          "includes": [
            "#include <vector>",
            "#include <algorithm>",
            "#include <string.h>",
            "#include <assert.h>",
            "#include <FLAC/stream_encoder.h>",
            "#include <FLAC/stream_decoder.h>",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Features.h\"",
            "#include \"FileModule.h\"",
            "#include \"Compiler.h\"",
            "#include \"FLAC.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <assert.h>\n#include <FLAC/stream_encoder.h>\n#include <FLAC/stream_decoder.h>\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Features.h\"\n#include \"FileModule.h\"\n#include \"Compiler.h\"\n#include \"FLAC.h\"\n#include \"config.h\"\n\nFLACEncoder {\n  virtual bool handlesSeeking() const OVERRIDE { return true; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  bool ModuleState::fileModuleHandlesSeeking() const\n  {\n  \treturn m_fileModule->handlesSeeking();\n  }\n}"
  },
  {
    "function_name": "init",
    "container": "ModuleState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "96-102",
    "snippet": "status ModuleState::init(AFfilehandle file, Track *track)\n{\n\tif (initFileModule(file, track) == AF_FAIL)\n\t\treturn AF_FAIL;\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "initFileModule",
          "args": [
            "file",
            "track"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "initFileModule",
          "container": "ModuleState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
          "lines": "52-94",
          "snippet": "status ModuleState::initFileModule(AFfilehandle file, Track *track)\n{\n\tconst CompressionUnit *unit = _af_compression_unit_from_id(track->f.compressionType);\n\tif (!unit)\n\t\treturn AF_FAIL;\n\n\t// Validate compression format and parameters.\n\tif (!unit->fmtok(&track->f))\n\t\treturn AF_FAIL;\n\n\tif (file->m_seekok &&\n\t\tfile->m_fh->seek(track->fpos_first_frame, File::SeekFromBeginning) !=\n\t\t\ttrack->fpos_first_frame)\n\t{\n\t\t_af_error(AF_BAD_LSEEK, \"unable to position file handle at beginning of sound data\");\n\t\treturn AF_FAIL;\n\t}\n\n\tAFframecount chunkFrames;\n\tif (file->m_access == _AF_READ_ACCESS)\n\t\tm_fileModule = unit->initdecompress(track, file->m_fh, file->m_seekok,\n\t\t\tfile->m_fileFormat == AF_FILE_RAWDATA, &chunkFrames);\n\telse\n\t\tm_fileModule = unit->initcompress(track, file->m_fh, file->m_seekok,\n\t\t\tfile->m_fileFormat == AF_FILE_RAWDATA, &chunkFrames);\n\n\tif (unit->needsRebuffer)\n\t{\n\t\tassert(unit->nativeSampleFormat == AF_SAMPFMT_TWOSCOMP);\n\n\t\tRebufferModule::Direction direction =\n\t\t\tfile->m_access == _AF_WRITE_ACCESS ?\n\t\t\t\tRebufferModule::VariableToFixed : RebufferModule::FixedToVariable;\n\n\t\tm_fileRebufferModule = new RebufferModule(direction,\n\t\t\ttrack->f.bytesPerFrame(false), chunkFrames,\n\t\t\tunit->multiple_of);\n\t}\n\n\ttrack->filemodhappy = true;\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <functional>",
            "#include <cmath>",
            "#include <cassert>",
            "#include <algorithm>",
            "#include \"../pcm.h\"",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"SimpleModule.h\"",
            "#include \"RebufferModule.h\"",
            "#include \"FileModule.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"ModuleState.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  status ModuleState::initFileModule(AFfilehandle file, Track *track)\n  {\n  \tconst CompressionUnit *unit = _af_compression_unit_from_id(track->f.compressionType);\n  \tif (!unit)\n  \t\treturn AF_FAIL;\n  \n  \t// Validate compression format and parameters.\n  \tif (!unit->fmtok(&track->f))\n  \t\treturn AF_FAIL;\n  \n  \tif (file->m_seekok &&\n  \t\tfile->m_fh->seek(track->fpos_first_frame, File::SeekFromBeginning) !=\n  \t\t\ttrack->fpos_first_frame)\n  \t{\n  \t\t_af_error(AF_BAD_LSEEK, \"unable to position file handle at beginning of sound data\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \tAFframecount chunkFrames;\n  \tif (file->m_access == _AF_READ_ACCESS)\n  \t\tm_fileModule = unit->initdecompress(track, file->m_fh, file->m_seekok,\n  \t\t\tfile->m_fileFormat == AF_FILE_RAWDATA, &chunkFrames);\n  \telse\n  \t\tm_fileModule = unit->initcompress(track, file->m_fh, file->m_seekok,\n  \t\t\tfile->m_fileFormat == AF_FILE_RAWDATA, &chunkFrames);\n  \n  \tif (unit->needsRebuffer)\n  \t{\n  \t\tassert(unit->nativeSampleFormat == AF_SAMPFMT_TWOSCOMP);\n  \n  \t\tRebufferModule::Direction direction =\n  \t\t\tfile->m_access == _AF_WRITE_ACCESS ?\n  \t\t\t\tRebufferModule::VariableToFixed : RebufferModule::FixedToVariable;\n  \n  \t\tm_fileRebufferModule = new RebufferModule(direction,\n  \t\t\ttrack->f.bytesPerFrame(false), chunkFrames,\n  \t\t\tunit->multiple_of);\n  \t}\n  \n  \ttrack->filemodhappy = true;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  status ModuleState::init(AFfilehandle file, Track *track)\n  {\n  \tif (initFileModule(file, track) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "initFileModule",
    "container": "ModuleState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "52-94",
    "snippet": "status ModuleState::initFileModule(AFfilehandle file, Track *track)\n{\n\tconst CompressionUnit *unit = _af_compression_unit_from_id(track->f.compressionType);\n\tif (!unit)\n\t\treturn AF_FAIL;\n\n\t// Validate compression format and parameters.\n\tif (!unit->fmtok(&track->f))\n\t\treturn AF_FAIL;\n\n\tif (file->m_seekok &&\n\t\tfile->m_fh->seek(track->fpos_first_frame, File::SeekFromBeginning) !=\n\t\t\ttrack->fpos_first_frame)\n\t{\n\t\t_af_error(AF_BAD_LSEEK, \"unable to position file handle at beginning of sound data\");\n\t\treturn AF_FAIL;\n\t}\n\n\tAFframecount chunkFrames;\n\tif (file->m_access == _AF_READ_ACCESS)\n\t\tm_fileModule = unit->initdecompress(track, file->m_fh, file->m_seekok,\n\t\t\tfile->m_fileFormat == AF_FILE_RAWDATA, &chunkFrames);\n\telse\n\t\tm_fileModule = unit->initcompress(track, file->m_fh, file->m_seekok,\n\t\t\tfile->m_fileFormat == AF_FILE_RAWDATA, &chunkFrames);\n\n\tif (unit->needsRebuffer)\n\t{\n\t\tassert(unit->nativeSampleFormat == AF_SAMPFMT_TWOSCOMP);\n\n\t\tRebufferModule::Direction direction =\n\t\t\tfile->m_access == _AF_WRITE_ACCESS ?\n\t\t\t\tRebufferModule::VariableToFixed : RebufferModule::FixedToVariable;\n\n\t\tm_fileRebufferModule = new RebufferModule(direction,\n\t\t\ttrack->f.bytesPerFrame(false), chunkFrames,\n\t\t\tunit->multiple_of);\n\t}\n\n\ttrack->filemodhappy = true;\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "track->f.bytesPerFrame",
          "args": [
            "false"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "bytesPerFrame",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "51-54",
          "snippet": "size_t AudioFormat::bytesPerFrame(bool stretch3to4) const\n{\n\treturn bytesPerSample(stretch3to4) * channelCount;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  size_t AudioFormat::bytesPerFrame(bool stretch3to4) const\n  {\n  \treturn bytesPerSample(stretch3to4) * channelCount;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "unit->nativeSampleFormat == AF_SAMPFMT_TWOSCOMP"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unit->initcompress",
          "args": [
            "track",
            "file->m_fh",
            "file->m_seekok",
            "file->m_fileFormat == AF_FILE_RAWDATA",
            "&chunkFrames"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unit->initdecompress",
          "args": [
            "track",
            "file->m_fh",
            "file->m_seekok",
            "file->m_fileFormat == AF_FILE_RAWDATA",
            "&chunkFrames"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_LSEEK",
            "\"unable to position file handle at beginning of sound data\""
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->m_fh->seek",
          "args": [
            "track->fpos_first_frame",
            "File::SeekFromBeginning"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unit->fmtok",
          "args": [
            "&track->f"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_compression_unit_from_id",
          "args": [
            "track->f.compressionType"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  status ModuleState::initFileModule(AFfilehandle file, Track *track)\n  {\n  \tconst CompressionUnit *unit = _af_compression_unit_from_id(track->f.compressionType);\n  \tif (!unit)\n  \t\treturn AF_FAIL;\n  \n  \t// Validate compression format and parameters.\n  \tif (!unit->fmtok(&track->f))\n  \t\treturn AF_FAIL;\n  \n  \tif (file->m_seekok &&\n  \t\tfile->m_fh->seek(track->fpos_first_frame, File::SeekFromBeginning) !=\n  \t\t\ttrack->fpos_first_frame)\n  \t{\n  \t\t_af_error(AF_BAD_LSEEK, \"unable to position file handle at beginning of sound data\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \tAFframecount chunkFrames;\n  \tif (file->m_access == _AF_READ_ACCESS)\n  \t\tm_fileModule = unit->initdecompress(track, file->m_fh, file->m_seekok,\n  \t\t\tfile->m_fileFormat == AF_FILE_RAWDATA, &chunkFrames);\n  \telse\n  \t\tm_fileModule = unit->initcompress(track, file->m_fh, file->m_seekok,\n  \t\t\tfile->m_fileFormat == AF_FILE_RAWDATA, &chunkFrames);\n  \n  \tif (unit->needsRebuffer)\n  \t{\n  \t\tassert(unit->nativeSampleFormat == AF_SAMPFMT_TWOSCOMP);\n  \n  \t\tRebufferModule::Direction direction =\n  \t\t\tfile->m_access == _AF_WRITE_ACCESS ?\n  \t\t\t\tRebufferModule::VariableToFixed : RebufferModule::FixedToVariable;\n  \n  \t\tm_fileRebufferModule = new RebufferModule(direction,\n  \t\t\ttrack->f.bytesPerFrame(false), chunkFrames,\n  \t\t\tunit->multiple_of);\n  \t}\n  \n  \ttrack->filemodhappy = true;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "~ModuleState",
    "container": "ModuleState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "48-50",
    "snippet": "ModuleState::~ModuleState()\n{\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  ModuleState::~ModuleState()\n  {\n  }\n}"
  },
  {
    "function_name": "ModuleState",
    "container": "ModuleState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/ModuleState.cpp",
    "lines": "43-46",
    "snippet": "ModuleState::ModuleState() :\n\tm_isDirty(true)\n{\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <functional>",
      "#include <cmath>",
      "#include <cassert>",
      "#include <algorithm>",
      "#include \"../pcm.h\"",
      "#include \"util.h\"",
      "#include \"units.h\"",
      "#include \"compression.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"SimpleModule.h\"",
      "#include \"RebufferModule.h\"",
      "#include \"FileModule.h\"",
      "#include \"FileHandle.h\"",
      "#include \"File.h\"",
      "#include \"ModuleState.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdio.h>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"SimpleModule.h\"\n#include \"RebufferModule.h\"\n#include \"FileModule.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"ModuleState.h\"\n#include \"config.h\"\n\nModuleState {\n  ModuleState::ModuleState() :\n  \tm_isDirty(true)\n  {\n  }\n}"
  }
]