[
  {
    "function_name": "initALACCompressionParams",
    "container": "CAFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "703-738",
    "snippet": "void CAFFile::initALACCompressionParams()\n{\n\tif (m_access == _AF_READ_ACCESS)\n\t\treturn;\n\n\tTrack *track = getTrack();\n\n\ttrack->f.bytesPerPacket = 0;\n\ttrack->f.framesPerPacket = kALACDefaultFramesPerPacket;\n\n\tconst unsigned kALACSpecificConfigSize = 24;\n\tconst unsigned kChannelAtomSize = 12;\n\tconst unsigned kALACAudioChannelLayoutSize = 12;\n\n\tunsigned codecDataSize = kALACSpecificConfigSize;\n\tif (track->f.channelCount > 2)\n\t\tcodecDataSize += kChannelAtomSize + kALACAudioChannelLayoutSize;\n\tm_codecData = new Buffer(codecDataSize);\n\tmemset(m_codecData->data(), 0, m_codecData->size());\n\n\tAUpvlist pv = AUpvnew(2);\n\n\tAUpvsetparam(pv, 0, _AF_CODEC_DATA_SIZE);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = codecDataSize;\n\tAUpvsetval(pv, 0, &l);\n\n\tAUpvsetparam(pv, 1, _AF_CODEC_DATA);\n\tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n\tvoid *v = m_codecData->data();\n\tAUpvsetval(pv, 1, &v);\n\n\ttrack->f.compressionParams = pv;\n\n\ttrack->m_packetTable = new PacketTable();\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned kALACDefaultFramesPerPacket = 4096;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AUpvsetval",
          "args": [
            "pv",
            "1",
            "&v"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_codecData->data",
          "args": [],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetvaltype",
          "args": [
            "pv",
            "1",
            "AU_PVTYPE_PTR"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetparam",
          "args": [
            "pv",
            "1",
            "_AF_CODEC_DATA"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetval",
          "args": [
            "pv",
            "0",
            "&l"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetvaltype",
          "args": [
            "pv",
            "0",
            "AU_PVTYPE_LONG"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetparam",
          "args": [
            "pv",
            "0",
            "_AF_CODEC_DATA_SIZE"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvnew",
          "args": [
            "2"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "m_codecData->data()",
            "0",
            "m_codecData->size()"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_codecData->size",
          "args": [],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Buffer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Buffer.h",
          "lines": "39-39",
          "snippet": "size_t size() const { return m_size; }",
          "includes": [
            "#include <sys/types.h>",
            "#include \"Shared.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"Shared.h\"\n\nBuffer {\n  size_t size() const { return m_size; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_codecData->data",
          "args": [],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nstatic const unsigned kALACDefaultFramesPerPacket = 4096;\n\nCAFFile {\n  void CAFFile::initALACCompressionParams()\n  {\n  \tif (m_access == _AF_READ_ACCESS)\n  \t\treturn;\n  \n  \tTrack *track = getTrack();\n  \n  \ttrack->f.bytesPerPacket = 0;\n  \ttrack->f.framesPerPacket = kALACDefaultFramesPerPacket;\n  \n  \tconst unsigned kALACSpecificConfigSize = 24;\n  \tconst unsigned kChannelAtomSize = 12;\n  \tconst unsigned kALACAudioChannelLayoutSize = 12;\n  \n  \tunsigned codecDataSize = kALACSpecificConfigSize;\n  \tif (track->f.channelCount > 2)\n  \t\tcodecDataSize += kChannelAtomSize + kALACAudioChannelLayoutSize;\n  \tm_codecData = new Buffer(codecDataSize);\n  \tmemset(m_codecData->data(), 0, m_codecData->size());\n  \n  \tAUpvlist pv = AUpvnew(2);\n  \n  \tAUpvsetparam(pv, 0, _AF_CODEC_DATA_SIZE);\n  \tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n  \tlong l = codecDataSize;\n  \tAUpvsetval(pv, 0, &l);\n  \n  \tAUpvsetparam(pv, 1, _AF_CODEC_DATA);\n  \tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n  \tvoid *v = m_codecData->data();\n  \tAUpvsetval(pv, 1, &v);\n  \n  \ttrack->f.compressionParams = pv;\n  \n  \ttrack->m_packetTable = new PacketTable();\n  }\n}"
  },
  {
    "function_name": "initIMACompressionParams",
    "container": "CAFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "687-701",
    "snippet": "void CAFFile::initIMACompressionParams()\n{\n\tTrack *track = getTrack();\n\n\ttrack->f.bytesPerPacket = 34 * track->f.channelCount;\n\ttrack->f.framesPerPacket = 64;\n\n\tAUpvlist pv = AUpvnew(1);\n\tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = _AF_IMA_ADPCM_TYPE_QT;\n\tAUpvsetval(pv, 0, &l);\n\n\ttrack->f.compressionParams = pv;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AUpvsetval",
          "args": [
            "pv",
            "0",
            "&l"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetvaltype",
          "args": [
            "pv",
            "0",
            "AU_PVTYPE_LONG"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetparam",
          "args": [
            "pv",
            "0",
            "_AF_IMA_ADPCM_TYPE"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvnew",
          "args": [
            "1"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  void CAFFile::initIMACompressionParams()\n  {\n  \tTrack *track = getTrack();\n  \n  \ttrack->f.bytesPerPacket = 34 * track->f.channelCount;\n  \ttrack->f.framesPerPacket = 64;\n  \n  \tAUpvlist pv = AUpvnew(1);\n  \tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n  \tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n  \tlong l = _AF_IMA_ADPCM_TYPE_QT;\n  \tAUpvsetval(pv, 0, &l);\n  \n  \ttrack->f.compressionParams = pv;\n  }\n}"
  },
  {
    "function_name": "initCompressionParams",
    "container": "CAFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "678-685",
    "snippet": "void CAFFile::initCompressionParams()\n{\n\tTrack *track = getTrack();\n\tif (track->f.compressionType == AF_COMPRESSION_IMA)\n\t\tinitIMACompressionParams();\n\telse if (track->f.compressionType == AF_COMPRESSION_ALAC)\n\t\tinitALACCompressionParams();\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "initALACCompressionParams",
          "args": [],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "initALACCompressionParams",
          "container": "CAFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
          "lines": "703-738",
          "snippet": "void CAFFile::initALACCompressionParams()\n{\n\tif (m_access == _AF_READ_ACCESS)\n\t\treturn;\n\n\tTrack *track = getTrack();\n\n\ttrack->f.bytesPerPacket = 0;\n\ttrack->f.framesPerPacket = kALACDefaultFramesPerPacket;\n\n\tconst unsigned kALACSpecificConfigSize = 24;\n\tconst unsigned kChannelAtomSize = 12;\n\tconst unsigned kALACAudioChannelLayoutSize = 12;\n\n\tunsigned codecDataSize = kALACSpecificConfigSize;\n\tif (track->f.channelCount > 2)\n\t\tcodecDataSize += kChannelAtomSize + kALACAudioChannelLayoutSize;\n\tm_codecData = new Buffer(codecDataSize);\n\tmemset(m_codecData->data(), 0, m_codecData->size());\n\n\tAUpvlist pv = AUpvnew(2);\n\n\tAUpvsetparam(pv, 0, _AF_CODEC_DATA_SIZE);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = codecDataSize;\n\tAUpvsetval(pv, 0, &l);\n\n\tAUpvsetparam(pv, 1, _AF_CODEC_DATA);\n\tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n\tvoid *v = m_codecData->data();\n\tAUpvsetval(pv, 1, &v);\n\n\ttrack->f.compressionParams = pv;\n\n\ttrack->m_packetTable = new PacketTable();\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"PacketTable.h\"",
            "#include \"File.h\"",
            "#include \"Buffer.h\"",
            "#include \"CAF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned kALACDefaultFramesPerPacket = 4096;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nstatic const unsigned kALACDefaultFramesPerPacket = 4096;\n\nCAFFile {\n  void CAFFile::initALACCompressionParams()\n  {\n  \tif (m_access == _AF_READ_ACCESS)\n  \t\treturn;\n  \n  \tTrack *track = getTrack();\n  \n  \ttrack->f.bytesPerPacket = 0;\n  \ttrack->f.framesPerPacket = kALACDefaultFramesPerPacket;\n  \n  \tconst unsigned kALACSpecificConfigSize = 24;\n  \tconst unsigned kChannelAtomSize = 12;\n  \tconst unsigned kALACAudioChannelLayoutSize = 12;\n  \n  \tunsigned codecDataSize = kALACSpecificConfigSize;\n  \tif (track->f.channelCount > 2)\n  \t\tcodecDataSize += kChannelAtomSize + kALACAudioChannelLayoutSize;\n  \tm_codecData = new Buffer(codecDataSize);\n  \tmemset(m_codecData->data(), 0, m_codecData->size());\n  \n  \tAUpvlist pv = AUpvnew(2);\n  \n  \tAUpvsetparam(pv, 0, _AF_CODEC_DATA_SIZE);\n  \tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n  \tlong l = codecDataSize;\n  \tAUpvsetval(pv, 0, &l);\n  \n  \tAUpvsetparam(pv, 1, _AF_CODEC_DATA);\n  \tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n  \tvoid *v = m_codecData->data();\n  \tAUpvsetval(pv, 1, &v);\n  \n  \ttrack->f.compressionParams = pv;\n  \n  \ttrack->m_packetTable = new PacketTable();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "initIMACompressionParams",
          "args": [],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "initIMACompressionParams",
          "container": "CAFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
          "lines": "687-701",
          "snippet": "void CAFFile::initIMACompressionParams()\n{\n\tTrack *track = getTrack();\n\n\ttrack->f.bytesPerPacket = 34 * track->f.channelCount;\n\ttrack->f.framesPerPacket = 64;\n\n\tAUpvlist pv = AUpvnew(1);\n\tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = _AF_IMA_ADPCM_TYPE_QT;\n\tAUpvsetval(pv, 0, &l);\n\n\ttrack->f.compressionParams = pv;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"PacketTable.h\"",
            "#include \"File.h\"",
            "#include \"Buffer.h\"",
            "#include \"CAF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  void CAFFile::initIMACompressionParams()\n  {\n  \tTrack *track = getTrack();\n  \n  \ttrack->f.bytesPerPacket = 34 * track->f.channelCount;\n  \ttrack->f.framesPerPacket = 64;\n  \n  \tAUpvlist pv = AUpvnew(1);\n  \tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n  \tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n  \tlong l = _AF_IMA_ADPCM_TYPE_QT;\n  \tAUpvsetval(pv, 0, &l);\n  \n  \ttrack->f.compressionParams = pv;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  void CAFFile::initCompressionParams()\n  {\n  \tTrack *track = getTrack();\n  \tif (track->f.compressionType == AF_COMPRESSION_IMA)\n  \t\tinitIMACompressionParams();\n  \telse if (track->f.compressionType == AF_COMPRESSION_ALAC)\n  \t\tinitALACCompressionParams();\n  }\n}"
  },
  {
    "function_name": "writeCookieData",
    "container": "CAFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "656-676",
    "snippet": "status CAFFile::writeCookieData()\n{\n\tif (!m_codecData)\n\t\treturn AF_SUCCEED;\n\n\tif (m_cookieDataOffset == -1)\n\t\tm_cookieDataOffset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_cookieDataOffset, File::SeekFromBeginning);\n\n\tTag kuki(\"kuki\");\n\tint64_t cookieDataLength = m_codecData->size();\n\tif (!writeTag(&kuki) ||\n\t\t!writeS64(&cookieDataLength) ||\n\t\tm_fh->write(m_codecData->data(), m_codecData->size()) != static_cast<ssize_t>(m_codecData->size()))\n\t{\n\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<ssize_t>",
          "args": [
            "m_codecData->size()"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_codecData->size",
          "args": [],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Buffer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Buffer.h",
          "lines": "39-39",
          "snippet": "size_t size() const { return m_size; }",
          "includes": [
            "#include <sys/types.h>",
            "#include \"Shared.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"Shared.h\"\n\nBuffer {\n  size_t size() const { return m_size; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "m_codecData->data()",
            "m_codecData->size()"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_codecData->data",
          "args": [],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeS64",
          "args": [
            "&cookieDataLength"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "writeS64",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "458-461",
          "snippet": "bool _AFfilehandle::writeS64(const int64_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeS64(const int64_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeTag",
          "args": [
            "&kuki"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "writeTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "484-488",
          "snippet": "bool _AFfilehandle::writeTag(const Tag *t)\n{\n\tuint32_t v = t->value();\n\treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeTag(const Tag *t)\n  {\n  \tuint32_t v = t->value();\n  \treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "m_cookieDataOffset",
            "File::SeekFromBeginning"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::writeCookieData()\n  {\n  \tif (!m_codecData)\n  \t\treturn AF_SUCCEED;\n  \n  \tif (m_cookieDataOffset == -1)\n  \t\tm_cookieDataOffset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_cookieDataOffset, File::SeekFromBeginning);\n  \n  \tTag kuki(\"kuki\");\n  \tint64_t cookieDataLength = m_codecData->size();\n  \tif (!writeTag(&kuki) ||\n  \t\t!writeS64(&cookieDataLength) ||\n  \t\tm_fh->write(m_codecData->data(), m_codecData->size()) != static_cast<ssize_t>(m_codecData->size()))\n  \t{\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writePacketTable",
    "container": "CAFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "612-654",
    "snippet": "status CAFFile::writePacketTable()\n{\n\tTrack *track = getTrack();\n\n\tm_fh->seek(track->fpos_after_data, File::SeekFromBeginning);\n\n\tSharedPtr<PacketTable> packetTable = track->m_packetTable;\n\tif (!packetTable)\n\t\treturn AF_SUCCEED;\n\n\tint64_t numPackets = packetTable->numPackets();\n\tint64_t numValidFrames = packetTable->numValidFrames();\n\tint32_t primingFrames = packetTable->primingFrames();\n\tint32_t remainderFrames = packetTable->remainderFrames();\n\n\tSharedPtr<Buffer> buffer = new Buffer(packetTable->numPackets() * 5);\n\n\tuint8_t *data = static_cast<uint8_t *>(buffer->data());\n\tsize_t position = 0;\n\tfor (unsigned i=0; i<packetTable->numPackets(); i++)\n\t{\n\t\tuint32_t bytesPerPacket = packetTable->bytesPerPacket(i);\n\t\tsize_t numBytes = 0;\n\t\tencodeBERInteger(bytesPerPacket, data + position, &numBytes);\n\t\tposition += numBytes;\n\t}\n\n\tTag pakt(\"pakt\");\n\tint64_t packetTableLength = 24 + position;\n\n\tif (!writeTag(&pakt) ||\n\t\t!writeS64(&packetTableLength) ||\n\t\t!writeS64(&numPackets) ||\n\t\t!writeS64(&numValidFrames) ||\n\t\t!writeS32(&primingFrames) ||\n\t\t!writeS32(&remainderFrames) ||\n\t\tm_fh->write(buffer->data(), position) != static_cast<ssize_t>(position))\n\t{\n\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<ssize_t>",
          "args": [
            "position"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "buffer->data()",
            "position"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer->data",
          "args": [],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeS32",
          "args": [
            "&remainderFrames"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "writeS32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "448-451",
          "snippet": "bool _AFfilehandle::writeS32(const int32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeS32(const int32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeS64",
          "args": [
            "&numValidFrames"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "writeS64",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "458-461",
          "snippet": "bool _AFfilehandle::writeS64(const int64_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeS64(const int64_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeTag",
          "args": [
            "&pakt"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "writeTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "484-488",
          "snippet": "bool _AFfilehandle::writeTag(const Tag *t)\n{\n\tuint32_t v = t->value();\n\treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeTag(const Tag *t)\n  {\n  \tuint32_t v = t->value();\n  \treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "encodeBERInteger",
          "args": [
            "bytesPerPacket",
            "data + position",
            "&numBytes"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "encodeBERInteger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
          "lines": "408-445",
          "snippet": "static void encodeBERInteger(uint32_t value, uint8_t *buffer, size_t *numBytes)\n{\n\tif ((value & 0x7f) == value)\n\t{\n\t\t*numBytes = 1;\n\t\tbuffer[0] = value;\n\t}\n\telse if ((value & 0x3fff) == value)\n\t{\n\t\t*numBytes = 2;\n\t\tbuffer[0] = (value >> 7) | 0x80;\n\t\tbuffer[1] = value & 0x7f;\n\t}\n\telse if ((value & 0x1fffff) == value)\n\t{\n\t\t*numBytes = 3;\n\t\tbuffer[0] = (value >> 14) | 0x80;\n\t\tbuffer[1] = ((value >> 7) & 0x7f) | 0x80;\n\t\tbuffer[2] = value & 0x7f;\n\t}\n\telse if ((value & 0x0fffffff) == value)\n\t{\n\t\t*numBytes = 4;\n\t\tbuffer[0] = (value >> 21) | 0x80;\n\t\tbuffer[1] = ((value >> 14) & 0x7f) | 0x80;\n\t\tbuffer[2] = ((value >> 7) & 0x7f) | 0x80;\n\t\tbuffer[3] = value & 0x7f;\n\t}\n\telse\n\t{\n\t\t*numBytes = 5;\n\t\tbuffer[0] = (value >> 28) | 0x80;\n\t\tbuffer[1] = ((value >> 21) & 0x7f) | 0x80;\n\t\tbuffer[2] = ((value >> 14) & 0x7f) | 0x80;\n\t\tbuffer[3] = ((value >> 7) & 0x7f) | 0x80;\n\t\tbuffer[4] = value & 0x7f;\n\t}\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"PacketTable.h\"",
            "#include \"File.h\"",
            "#include \"Buffer.h\"",
            "#include \"CAF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nstatic void encodeBERInteger(uint32_t value, uint8_t *buffer, size_t *numBytes)\n{\n\tif ((value & 0x7f) == value)\n\t{\n\t\t*numBytes = 1;\n\t\tbuffer[0] = value;\n\t}\n\telse if ((value & 0x3fff) == value)\n\t{\n\t\t*numBytes = 2;\n\t\tbuffer[0] = (value >> 7) | 0x80;\n\t\tbuffer[1] = value & 0x7f;\n\t}\n\telse if ((value & 0x1fffff) == value)\n\t{\n\t\t*numBytes = 3;\n\t\tbuffer[0] = (value >> 14) | 0x80;\n\t\tbuffer[1] = ((value >> 7) & 0x7f) | 0x80;\n\t\tbuffer[2] = value & 0x7f;\n\t}\n\telse if ((value & 0x0fffffff) == value)\n\t{\n\t\t*numBytes = 4;\n\t\tbuffer[0] = (value >> 21) | 0x80;\n\t\tbuffer[1] = ((value >> 14) & 0x7f) | 0x80;\n\t\tbuffer[2] = ((value >> 7) & 0x7f) | 0x80;\n\t\tbuffer[3] = value & 0x7f;\n\t}\n\telse\n\t{\n\t\t*numBytes = 5;\n\t\tbuffer[0] = (value >> 28) | 0x80;\n\t\tbuffer[1] = ((value >> 21) & 0x7f) | 0x80;\n\t\tbuffer[2] = ((value >> 14) & 0x7f) | 0x80;\n\t\tbuffer[3] = ((value >> 7) & 0x7f) | 0x80;\n\t\tbuffer[4] = value & 0x7f;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "packetTable->bytesPerPacket",
          "args": [
            "i"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "bytesPerPacket",
          "container": "PacketTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/PacketTable.h",
          "lines": "50-50",
          "snippet": "size_t bytesPerPacket(size_t packet) const { return m_bytesPerPacket[packet]; }",
          "includes": [
            "#include <vector>",
            "#include <sys/types.h>",
            "#include <stdint.h>",
            "#include <audiofile.h>",
            "#include \"Shared.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <sys/types.h>\n#include <stdint.h>\n#include <audiofile.h>\n#include \"Shared.h\"\n\nPacketTable {\n  size_t bytesPerPacket(size_t packet) const { return m_bytesPerPacket[packet]; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "packetTable->numPackets",
          "args": [],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "numPackets",
          "container": "PacketTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/PacketTable.h",
          "lines": "41-41",
          "snippet": "size_t numPackets() const { return m_bytesPerPacket.size(); }",
          "includes": [
            "#include <vector>",
            "#include <sys/types.h>",
            "#include <stdint.h>",
            "#include <audiofile.h>",
            "#include \"Shared.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <sys/types.h>\n#include <stdint.h>\n#include <audiofile.h>\n#include \"Shared.h\"\n\nPacketTable {\n  size_t numPackets() const { return m_bytesPerPacket.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<uint8_t *>",
          "args": [
            "buffer->data()"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer->data",
          "args": [],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packetTable->remainderFrames",
          "args": [],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "remainderFrames",
          "container": "PacketTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/PacketTable.h",
          "lines": "46-46",
          "snippet": "int32_t remainderFrames() const { return m_remainderFrames; }",
          "includes": [
            "#include <vector>",
            "#include <sys/types.h>",
            "#include <stdint.h>",
            "#include <audiofile.h>",
            "#include \"Shared.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <sys/types.h>\n#include <stdint.h>\n#include <audiofile.h>\n#include \"Shared.h\"\n\nPacketTable {\n  int32_t remainderFrames() const { return m_remainderFrames; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "packetTable->primingFrames",
          "args": [],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "primingFrames",
          "container": "PacketTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/PacketTable.h",
          "lines": "44-44",
          "snippet": "int32_t primingFrames() const { return m_primingFrames; }",
          "includes": [
            "#include <vector>",
            "#include <sys/types.h>",
            "#include <stdint.h>",
            "#include <audiofile.h>",
            "#include \"Shared.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <sys/types.h>\n#include <stdint.h>\n#include <audiofile.h>\n#include \"Shared.h\"\n\nPacketTable {\n  int32_t primingFrames() const { return m_primingFrames; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "packetTable->numValidFrames",
          "args": [],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "numValidFrames",
          "container": "PacketTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/PacketTable.h",
          "lines": "42-42",
          "snippet": "int64_t numValidFrames() const { return m_numValidFrames; }",
          "includes": [
            "#include <vector>",
            "#include <sys/types.h>",
            "#include <stdint.h>",
            "#include <audiofile.h>",
            "#include \"Shared.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <sys/types.h>\n#include <stdint.h>\n#include <audiofile.h>\n#include \"Shared.h\"\n\nPacketTable {\n  int64_t numValidFrames() const { return m_numValidFrames; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "track->fpos_after_data",
            "File::SeekFromBeginning"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::writePacketTable()\n  {\n  \tTrack *track = getTrack();\n  \n  \tm_fh->seek(track->fpos_after_data, File::SeekFromBeginning);\n  \n  \tSharedPtr<PacketTable> packetTable = track->m_packetTable;\n  \tif (!packetTable)\n  \t\treturn AF_SUCCEED;\n  \n  \tint64_t numPackets = packetTable->numPackets();\n  \tint64_t numValidFrames = packetTable->numValidFrames();\n  \tint32_t primingFrames = packetTable->primingFrames();\n  \tint32_t remainderFrames = packetTable->remainderFrames();\n  \n  \tSharedPtr<Buffer> buffer = new Buffer(packetTable->numPackets() * 5);\n  \n  \tuint8_t *data = static_cast<uint8_t *>(buffer->data());\n  \tsize_t position = 0;\n  \tfor (unsigned i=0; i<packetTable->numPackets(); i++)\n  \t{\n  \t\tuint32_t bytesPerPacket = packetTable->bytesPerPacket(i);\n  \t\tsize_t numBytes = 0;\n  \t\tencodeBERInteger(bytesPerPacket, data + position, &numBytes);\n  \t\tposition += numBytes;\n  \t}\n  \n  \tTag pakt(\"pakt\");\n  \tint64_t packetTableLength = 24 + position;\n  \n  \tif (!writeTag(&pakt) ||\n  \t\t!writeS64(&packetTableLength) ||\n  \t\t!writeS64(&numPackets) ||\n  \t\t!writeS64(&numValidFrames) ||\n  \t\t!writeS32(&primingFrames) ||\n  \t\t!writeS32(&remainderFrames) ||\n  \t\tm_fh->write(buffer->data(), position) != static_cast<ssize_t>(position))\n  \t{\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeData",
    "container": "CAFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "588-610",
    "snippet": "status CAFFile::writeData(bool update)\n{\n\tTrack *track = getTrack();\n\n\tif (m_dataOffset == -1)\n\t\tm_dataOffset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_dataOffset, File::SeekFromBeginning);\n\n\tTag data(\"data\");\n\tint64_t dataLength = -1;\n\tuint32_t editCount = 0;\n\tif (update)\n\t\tdataLength = track->data_size + 4;\n\n\tif (!writeTag(&data) ||\n\t\t!writeS64(&dataLength) ||\n\t\t!writeU32(&editCount))\n\t\treturn AF_FAIL;\n\tif (track->fpos_first_frame == 0)\n\t\ttrack->fpos_first_frame = m_fh->tell();\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&editCount"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeS64",
          "args": [
            "&dataLength"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "writeS64",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "458-461",
          "snippet": "bool _AFfilehandle::writeS64(const int64_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeS64(const int64_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeTag",
          "args": [
            "&data"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "writeTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "484-488",
          "snippet": "bool _AFfilehandle::writeTag(const Tag *t)\n{\n\tuint32_t v = t->value();\n\treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeTag(const Tag *t)\n  {\n  \tuint32_t v = t->value();\n  \treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "m_dataOffset",
            "File::SeekFromBeginning"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::writeData(bool update)\n  {\n  \tTrack *track = getTrack();\n  \n  \tif (m_dataOffset == -1)\n  \t\tm_dataOffset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_dataOffset, File::SeekFromBeginning);\n  \n  \tTag data(\"data\");\n  \tint64_t dataLength = -1;\n  \tuint32_t editCount = 0;\n  \tif (update)\n  \t\tdataLength = track->data_size + 4;\n  \n  \tif (!writeTag(&data) ||\n  \t\t!writeS64(&dataLength) ||\n  \t\t!writeU32(&editCount))\n  \t\treturn AF_FAIL;\n  \tif (track->fpos_first_frame == 0)\n  \t\ttrack->fpos_first_frame = m_fh->tell();\n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "writeDescription",
    "container": "CAFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "521-586",
    "snippet": "status CAFFile::writeDescription()\n{\n\tTrack *track = getTrack();\n\n\tTag desc(\"desc\");\n\tint64_t chunkLength = 32;\n\tdouble sampleRate = track->f.sampleRate;\n\tTag formatID(\"lpcm\");\n\tuint32_t formatFlags = 0;\n\tif (track->f.byteOrder == AF_BYTEORDER_LITTLEENDIAN)\n\t\tformatFlags |= kCAFLinearPCMFormatFlagIsLittleEndian;\n\tif (track->f.isFloat())\n\t\tformatFlags |= kCAFLinearPCMFormatFlagIsFloat;\n\tuint32_t bytesPerPacket = track->f.bytesPerFrame(false);\n\tuint32_t framesPerPacket = 1;\n\tuint32_t channelsPerFrame = track->f.channelCount;\n\tuint32_t bitsPerChannel = track->f.sampleWidth;\n\n\tif (track->f.compressionType == AF_COMPRESSION_G711_ULAW)\n\t{\n\t\tformatID = \"ulaw\";\n\t\tformatFlags = 0;\n\t\tbytesPerPacket = channelsPerFrame;\n\t\tbitsPerChannel = 8;\n\t}\n\telse if (track->f.compressionType == AF_COMPRESSION_G711_ALAW)\n\t{\n\t\tformatID = \"alaw\";\n\t\tformatFlags = 0;\n\t\tbytesPerPacket = channelsPerFrame;\n\t\tbitsPerChannel = 8;\n\t}\n\telse if (track->f.compressionType == AF_COMPRESSION_IMA)\n\t{\n\t\tformatID = \"ima4\";\n\t\tformatFlags = 0;\n\t\tbytesPerPacket = track->f.bytesPerPacket;\n\t\tframesPerPacket = track->f.framesPerPacket;\n\t\tbitsPerChannel = 16;\n\t}\n\telse if (track->f.compressionType == AF_COMPRESSION_ALAC)\n\t{\n\t\tformatID = \"alac\";\n\t\tswitch (track->f.sampleWidth)\n\t\t{\n\t\t\tcase 16: formatFlags = kALACFormatFlag_16BitSourceData; break;\n\t\t\tcase 20: formatFlags = kALACFormatFlag_20BitSourceData; break;\n\t\t\tcase 24: formatFlags = kALACFormatFlag_24BitSourceData; break;\n\t\t\tcase 32: formatFlags = kALACFormatFlag_32BitSourceData; break;\n\t\t}\n\t\tbytesPerPacket = track->f.bytesPerPacket;\n\t\tframesPerPacket = track->f.framesPerPacket;\n\t}\n\n\tif (!writeTag(&desc) ||\n\t\t!writeS64(&chunkLength) ||\n\t\t!writeDouble(&sampleRate) ||\n\t\t!writeTag(&formatID) ||\n\t\t!writeU32(&formatFlags) ||\n\t\t!writeU32(&bytesPerPacket) ||\n\t\t!writeU32(&framesPerPacket) ||\n\t\t!writeU32(&channelsPerFrame) ||\n\t\t!writeU32(&bitsPerChannel))\n\t\treturn AF_FAIL;\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeU32",
          "args": [
            "&bitsPerChannel"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "writeU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "443-446",
          "snippet": "bool _AFfilehandle::writeU32(const uint32_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeU32(const uint32_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeTag",
          "args": [
            "&formatID"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "writeTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "484-488",
          "snippet": "bool _AFfilehandle::writeTag(const Tag *t)\n{\n\tuint32_t v = t->value();\n\treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeTag(const Tag *t)\n  {\n  \tuint32_t v = t->value();\n  \treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeDouble",
          "args": [
            "&sampleRate"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "writeDouble",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "468-471",
          "snippet": "bool _AFfilehandle::writeDouble(const double *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeDouble(const double *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeS64",
          "args": [
            "&chunkLength"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "writeS64",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "458-461",
          "snippet": "bool _AFfilehandle::writeS64(const int64_t *v)\n{\n\treturn writeSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeS64(const int64_t *v)\n  {\n  \treturn writeSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->f.bytesPerFrame",
          "args": [
            "false"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "bytesPerFrame",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "51-54",
          "snippet": "size_t AudioFormat::bytesPerFrame(bool stretch3to4) const\n{\n\treturn bytesPerSample(stretch3to4) * channelCount;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  size_t AudioFormat::bytesPerFrame(bool stretch3to4) const\n  {\n  \treturn bytesPerSample(stretch3to4) * channelCount;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->f.isFloat",
          "args": [],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "isFloat",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "82-86",
          "snippet": "bool AudioFormat::isFloat() const\n{\n\treturn sampleFormat == AF_SAMPFMT_FLOAT ||\n\t\tsampleFormat == AF_SAMPFMT_DOUBLE;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  bool AudioFormat::isFloat() const\n  {\n  \treturn sampleFormat == AF_SAMPFMT_FLOAT ||\n  \t\tsampleFormat == AF_SAMPFMT_DOUBLE;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::writeDescription()\n  {\n  \tTrack *track = getTrack();\n  \n  \tTag desc(\"desc\");\n  \tint64_t chunkLength = 32;\n  \tdouble sampleRate = track->f.sampleRate;\n  \tTag formatID(\"lpcm\");\n  \tuint32_t formatFlags = 0;\n  \tif (track->f.byteOrder == AF_BYTEORDER_LITTLEENDIAN)\n  \t\tformatFlags |= kCAFLinearPCMFormatFlagIsLittleEndian;\n  \tif (track->f.isFloat())\n  \t\tformatFlags |= kCAFLinearPCMFormatFlagIsFloat;\n  \tuint32_t bytesPerPacket = track->f.bytesPerFrame(false);\n  \tuint32_t framesPerPacket = 1;\n  \tuint32_t channelsPerFrame = track->f.channelCount;\n  \tuint32_t bitsPerChannel = track->f.sampleWidth;\n  \n  \tif (track->f.compressionType == AF_COMPRESSION_G711_ULAW)\n  \t{\n  \t\tformatID = \"ulaw\";\n  \t\tformatFlags = 0;\n  \t\tbytesPerPacket = channelsPerFrame;\n  \t\tbitsPerChannel = 8;\n  \t}\n  \telse if (track->f.compressionType == AF_COMPRESSION_G711_ALAW)\n  \t{\n  \t\tformatID = \"alaw\";\n  \t\tformatFlags = 0;\n  \t\tbytesPerPacket = channelsPerFrame;\n  \t\tbitsPerChannel = 8;\n  \t}\n  \telse if (track->f.compressionType == AF_COMPRESSION_IMA)\n  \t{\n  \t\tformatID = \"ima4\";\n  \t\tformatFlags = 0;\n  \t\tbytesPerPacket = track->f.bytesPerPacket;\n  \t\tframesPerPacket = track->f.framesPerPacket;\n  \t\tbitsPerChannel = 16;\n  \t}\n  \telse if (track->f.compressionType == AF_COMPRESSION_ALAC)\n  \t{\n  \t\tformatID = \"alac\";\n  \t\tswitch (track->f.sampleWidth)\n  \t\t{\n  \t\t\tcase 16: formatFlags = kALACFormatFlag_16BitSourceData; break;\n  \t\t\tcase 20: formatFlags = kALACFormatFlag_20BitSourceData; break;\n  \t\t\tcase 24: formatFlags = kALACFormatFlag_24BitSourceData; break;\n  \t\t\tcase 32: formatFlags = kALACFormatFlag_32BitSourceData; break;\n  \t\t}\n  \t\tbytesPerPacket = track->f.bytesPerPacket;\n  \t\tframesPerPacket = track->f.framesPerPacket;\n  \t}\n  \n  \tif (!writeTag(&desc) ||\n  \t\t!writeS64(&chunkLength) ||\n  \t\t!writeDouble(&sampleRate) ||\n  \t\t!writeTag(&formatID) ||\n  \t\t!writeU32(&formatFlags) ||\n  \t\t!writeU32(&bytesPerPacket) ||\n  \t\t!writeU32(&framesPerPacket) ||\n  \t\t!writeU32(&channelsPerFrame) ||\n  \t\t!writeU32(&bitsPerChannel))\n  \t\treturn AF_FAIL;\n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseCookieData",
    "container": "CAFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "497-519",
    "snippet": "status CAFFile::parseCookieData(const Tag &tag, int64_t length)\n{\n\tm_codecData = new Buffer(length);\n\tif (m_fh->read(m_codecData->data(), length) != length)\n\t\treturn AF_FAIL;\n\n\tAUpvlist pv = AUpvnew(2);\n\n\tAUpvsetparam(pv, 0, _AF_CODEC_DATA_SIZE);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = length;\n\tAUpvsetval(pv, 0, &l);\n\n\tAUpvsetparam(pv, 1, _AF_CODEC_DATA);\n\tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n\tvoid *v = m_codecData->data();\n\tAUpvsetval(pv, 1, &v);\n\n\tTrack *track = getTrack();\n\ttrack->f.compressionParams = pv;\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetval",
          "args": [
            "pv",
            "1",
            "&v"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_codecData->data",
          "args": [],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetvaltype",
          "args": [
            "pv",
            "1",
            "AU_PVTYPE_PTR"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetparam",
          "args": [
            "pv",
            "1",
            "_AF_CODEC_DATA"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetval",
          "args": [
            "pv",
            "0",
            "&l"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetvaltype",
          "args": [
            "pv",
            "0",
            "AU_PVTYPE_LONG"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvsetparam",
          "args": [
            "pv",
            "0",
            "_AF_CODEC_DATA_SIZE"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUpvnew",
          "args": [
            "2"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fh->read",
          "args": [
            "m_codecData->data()",
            "length"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_codecData->data",
          "args": [],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::parseCookieData(const Tag &tag, int64_t length)\n  {\n  \tm_codecData = new Buffer(length);\n  \tif (m_fh->read(m_codecData->data(), length) != length)\n  \t\treturn AF_FAIL;\n  \n  \tAUpvlist pv = AUpvnew(2);\n  \n  \tAUpvsetparam(pv, 0, _AF_CODEC_DATA_SIZE);\n  \tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n  \tlong l = length;\n  \tAUpvsetval(pv, 0, &l);\n  \n  \tAUpvsetparam(pv, 1, _AF_CODEC_DATA);\n  \tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n  \tvoid *v = m_codecData->data();\n  \tAUpvsetval(pv, 1, &v);\n  \n  \tTrack *track = getTrack();\n  \ttrack->f.compressionParams = pv;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parsePacketTable",
    "container": "CAFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "447-495",
    "snippet": "status CAFFile::parsePacketTable(const Tag &tag, int64_t length)\n{\n\tif (length < 24)\n\t\treturn AF_FAIL;\n\n\tint64_t numPackets;\n\tint64_t numValidFrames;\n\tint32_t primingFrames;\n\tint32_t remainderFrames;\n\tif (!readS64(&numPackets) ||\n\t\t!readS64(&numValidFrames) ||\n\t\t!readS32(&primingFrames) ||\n\t\t!readS32(&remainderFrames))\n\t{\n\t\treturn AF_FAIL;\n\t}\n\n\tif (!numPackets)\n\t\treturn AF_SUCCEED;\n\n\tint64_t tableLength = length - 24;\n\n\tSharedPtr<Buffer> buffer = new Buffer(tableLength);\n\tif (m_fh->read(buffer->data(), tableLength) != tableLength)\n\t\treturn AF_FAIL;\n\n\tSharedPtr<PacketTable> packetTable = new PacketTable(numValidFrames,\n\t\tprimingFrames, remainderFrames);\n\n\tconst uint8_t *data = static_cast<const uint8_t *>(buffer->data());\n\tsize_t position = 0;\n\twhile (position < buffer->size())\n\t{\n\t\tsize_t sizeRemaining = buffer->size() - position;\n\t\tuint32_t bytesPerPacket = readBERInteger(data + position, &sizeRemaining);\n\t\tif (bytesPerPacket == 0)\n\t\t\tbreak;\n\t\tpacketTable->append(bytesPerPacket);\n\t\tposition += sizeRemaining;\n\t}\n\n\tassert(numPackets == packetTable->numPackets());\n\n\tTrack *track = getTrack();\n\ttrack->m_packetTable = packetTable;\n\ttrack->totalfframes = numValidFrames;\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "numPackets == packetTable->numPackets()"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packetTable->numPackets",
          "args": [],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "numPackets",
          "container": "PacketTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/PacketTable.h",
          "lines": "41-41",
          "snippet": "size_t numPackets() const { return m_bytesPerPacket.size(); }",
          "includes": [
            "#include <vector>",
            "#include <sys/types.h>",
            "#include <stdint.h>",
            "#include <audiofile.h>",
            "#include \"Shared.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <sys/types.h>\n#include <stdint.h>\n#include <audiofile.h>\n#include \"Shared.h\"\n\nPacketTable {\n  size_t numPackets() const { return m_bytesPerPacket.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "packetTable->append",
          "args": [
            "bytesPerPacket"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "append",
          "container": "PacketTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/PacketTable.cpp",
          "lines": "58-61",
          "snippet": "void PacketTable::append(size_t bytesPerPacket)\n{\n\tm_bytesPerPacket.push_back(bytesPerPacket);\n}",
          "includes": [
            "#include \"PacketTable.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"PacketTable.h\"\n#include \"config.h\"\n\nPacketTable {\n  void PacketTable::append(size_t bytesPerPacket)\n  {\n  \tm_bytesPerPacket.push_back(bytesPerPacket);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readBERInteger",
          "args": [
            "data + position",
            "&sizeRemaining"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "readBERInteger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
          "lines": "392-406",
          "snippet": "static uint32_t readBERInteger(const uint8_t *input, size_t *numBytes)\n{\n\tuint32_t result = 0;\n\tuint8_t data;\n\tsize_t size = 0;\n\tdo\n\t{\n\t\tdata = input[size];\n\t\tresult = (result << 7) | (data & 0x7f);\n\t\tif (++size > 5)\n\t\t\treturn 0;\n\t} while ((data & 0x80) && size < *numBytes);\n\t*numBytes = size;\n\treturn result;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"PacketTable.h\"",
            "#include \"File.h\"",
            "#include \"Buffer.h\"",
            "#include \"CAF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nstatic uint32_t readBERInteger(const uint8_t *input, size_t *numBytes)\n{\n\tuint32_t result = 0;\n\tuint8_t data;\n\tsize_t size = 0;\n\tdo\n\t{\n\t\tdata = input[size];\n\t\tresult = (result << 7) | (data & 0x7f);\n\t\tif (++size > 5)\n\t\t\treturn 0;\n\t} while ((data & 0x80) && size < *numBytes);\n\t*numBytes = size;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer->size",
          "args": [],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Buffer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Buffer.h",
          "lines": "39-39",
          "snippet": "size_t size() const { return m_size; }",
          "includes": [
            "#include <sys/types.h>",
            "#include \"Shared.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include \"Shared.h\"\n\nBuffer {\n  size_t size() const { return m_size; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<const uint8_t *>",
          "args": [
            "buffer->data()"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer->data",
          "args": [],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fh->read",
          "args": [
            "buffer->data()",
            "tableLength"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer->data",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readS32",
          "args": [
            "&remainderFrames"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "readS32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "405-408",
          "snippet": "bool _AFfilehandle::readS32(int32_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readS32(int32_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readS64",
          "args": [
            "&numValidFrames"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "readS64",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "415-418",
          "snippet": "bool _AFfilehandle::readS64(int64_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readS64(int64_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::parsePacketTable(const Tag &tag, int64_t length)\n  {\n  \tif (length < 24)\n  \t\treturn AF_FAIL;\n  \n  \tint64_t numPackets;\n  \tint64_t numValidFrames;\n  \tint32_t primingFrames;\n  \tint32_t remainderFrames;\n  \tif (!readS64(&numPackets) ||\n  \t\t!readS64(&numValidFrames) ||\n  \t\t!readS32(&primingFrames) ||\n  \t\t!readS32(&remainderFrames))\n  \t{\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \tif (!numPackets)\n  \t\treturn AF_SUCCEED;\n  \n  \tint64_t tableLength = length - 24;\n  \n  \tSharedPtr<Buffer> buffer = new Buffer(tableLength);\n  \tif (m_fh->read(buffer->data(), tableLength) != tableLength)\n  \t\treturn AF_FAIL;\n  \n  \tSharedPtr<PacketTable> packetTable = new PacketTable(numValidFrames,\n  \t\tprimingFrames, remainderFrames);\n  \n  \tconst uint8_t *data = static_cast<const uint8_t *>(buffer->data());\n  \tsize_t position = 0;\n  \twhile (position < buffer->size())\n  \t{\n  \t\tsize_t sizeRemaining = buffer->size() - position;\n  \t\tuint32_t bytesPerPacket = readBERInteger(data + position, &sizeRemaining);\n  \t\tif (bytesPerPacket == 0)\n  \t\t\tbreak;\n  \t\tpacketTable->append(bytesPerPacket);\n  \t\tposition += sizeRemaining;\n  \t}\n  \n  \tassert(numPackets == packetTable->numPackets());\n  \n  \tTrack *track = getTrack();\n  \ttrack->m_packetTable = packetTable;\n  \ttrack->totalfframes = numValidFrames;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "encodeBERInteger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "408-445",
    "snippet": "static void encodeBERInteger(uint32_t value, uint8_t *buffer, size_t *numBytes)\n{\n\tif ((value & 0x7f) == value)\n\t{\n\t\t*numBytes = 1;\n\t\tbuffer[0] = value;\n\t}\n\telse if ((value & 0x3fff) == value)\n\t{\n\t\t*numBytes = 2;\n\t\tbuffer[0] = (value >> 7) | 0x80;\n\t\tbuffer[1] = value & 0x7f;\n\t}\n\telse if ((value & 0x1fffff) == value)\n\t{\n\t\t*numBytes = 3;\n\t\tbuffer[0] = (value >> 14) | 0x80;\n\t\tbuffer[1] = ((value >> 7) & 0x7f) | 0x80;\n\t\tbuffer[2] = value & 0x7f;\n\t}\n\telse if ((value & 0x0fffffff) == value)\n\t{\n\t\t*numBytes = 4;\n\t\tbuffer[0] = (value >> 21) | 0x80;\n\t\tbuffer[1] = ((value >> 14) & 0x7f) | 0x80;\n\t\tbuffer[2] = ((value >> 7) & 0x7f) | 0x80;\n\t\tbuffer[3] = value & 0x7f;\n\t}\n\telse\n\t{\n\t\t*numBytes = 5;\n\t\tbuffer[0] = (value >> 28) | 0x80;\n\t\tbuffer[1] = ((value >> 21) & 0x7f) | 0x80;\n\t\tbuffer[2] = ((value >> 14) & 0x7f) | 0x80;\n\t\tbuffer[3] = ((value >> 7) & 0x7f) | 0x80;\n\t\tbuffer[4] = value & 0x7f;\n\t}\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nstatic void encodeBERInteger(uint32_t value, uint8_t *buffer, size_t *numBytes)\n{\n\tif ((value & 0x7f) == value)\n\t{\n\t\t*numBytes = 1;\n\t\tbuffer[0] = value;\n\t}\n\telse if ((value & 0x3fff) == value)\n\t{\n\t\t*numBytes = 2;\n\t\tbuffer[0] = (value >> 7) | 0x80;\n\t\tbuffer[1] = value & 0x7f;\n\t}\n\telse if ((value & 0x1fffff) == value)\n\t{\n\t\t*numBytes = 3;\n\t\tbuffer[0] = (value >> 14) | 0x80;\n\t\tbuffer[1] = ((value >> 7) & 0x7f) | 0x80;\n\t\tbuffer[2] = value & 0x7f;\n\t}\n\telse if ((value & 0x0fffffff) == value)\n\t{\n\t\t*numBytes = 4;\n\t\tbuffer[0] = (value >> 21) | 0x80;\n\t\tbuffer[1] = ((value >> 14) & 0x7f) | 0x80;\n\t\tbuffer[2] = ((value >> 7) & 0x7f) | 0x80;\n\t\tbuffer[3] = value & 0x7f;\n\t}\n\telse\n\t{\n\t\t*numBytes = 5;\n\t\tbuffer[0] = (value >> 28) | 0x80;\n\t\tbuffer[1] = ((value >> 21) & 0x7f) | 0x80;\n\t\tbuffer[2] = ((value >> 14) & 0x7f) | 0x80;\n\t\tbuffer[3] = ((value >> 7) & 0x7f) | 0x80;\n\t\tbuffer[4] = value & 0x7f;\n\t}\n}"
  },
  {
    "function_name": "readBERInteger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "392-406",
    "snippet": "static uint32_t readBERInteger(const uint8_t *input, size_t *numBytes)\n{\n\tuint32_t result = 0;\n\tuint8_t data;\n\tsize_t size = 0;\n\tdo\n\t{\n\t\tdata = input[size];\n\t\tresult = (result << 7) | (data & 0x7f);\n\t\tif (++size > 5)\n\t\t\treturn 0;\n\t} while ((data & 0x80) && size < *numBytes);\n\t*numBytes = size;\n\treturn result;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nstatic uint32_t readBERInteger(const uint8_t *input, size_t *numBytes)\n{\n\tuint32_t result = 0;\n\tuint8_t data;\n\tsize_t size = 0;\n\tdo\n\t{\n\t\tdata = input[size];\n\t\tresult = (result << 7) | (data & 0x7f);\n\t\tif (++size > 5)\n\t\t\treturn 0;\n\t} while ((data & 0x80) && size < *numBytes);\n\t*numBytes = size;\n\treturn result;\n}"
  },
  {
    "function_name": "parseData",
    "container": "CAFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "375-390",
    "snippet": "status CAFFile::parseData(const Tag &tag, int64_t length)\n{\n\tuint32_t editCount;\n\tif (!readU32(&editCount))\n\t\treturn AF_FAIL;\n\n\tTrack *track = getTrack();\n\tif (length == -1)\n\t\ttrack->data_size = m_fh->length() - m_fh->tell();\n\telse\n\t\ttrack->data_size = length - 4;\n\ttrack->fpos_first_frame = m_fh->tell();\n\n\ttrack->computeTotalFileFrames();\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "track->computeTotalFileFrames",
          "args": [],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "computeTotalFileFrames",
          "container": "Track",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Track.cpp",
          "lines": "173-177",
          "snippet": "void Track::computeTotalFileFrames()\n{\n\tif (f.bytesPerPacket && f.framesPerPacket)\n\t\ttotalfframes = (data_size / f.bytesPerPacket) * f.framesPerPacket;\n}",
          "includes": [
            "#include \"modules/ModuleState.h\"",
            "#include \"modules/Module.h\"",
            "#include \"PacketTable.h\"",
            "#include \"Marker.h\"",
            "#include \"util.h\"",
            "#include \"afinternal.h\"",
            "#include \"audiofile.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <assert.h>",
            "#include \"Track.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modules/ModuleState.h\"\n#include \"modules/Module.h\"\n#include \"PacketTable.h\"\n#include \"Marker.h\"\n#include \"util.h\"\n#include \"afinternal.h\"\n#include \"audiofile.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <assert.h>\n#include \"Track.h\"\n#include \"config.h\"\n\nTrack {\n  void Track::computeTotalFileFrames()\n  {\n  \tif (f.bytesPerPacket && f.framesPerPacket)\n  \t\ttotalfframes = (data_size / f.bytesPerPacket) * f.framesPerPacket;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->length",
          "args": [],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "182-185",
          "snippet": "off_t FileVF::length()\n{\n\treturn m_vf->length(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::length()\n  {\n  \treturn m_vf->length(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readU32",
          "args": [
            "&editCount"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "readU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "400-403",
          "snippet": "bool _AFfilehandle::readU32(uint32_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU32(uint32_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::parseData(const Tag &tag, int64_t length)\n  {\n  \tuint32_t editCount;\n  \tif (!readU32(&editCount))\n  \t\treturn AF_FAIL;\n  \n  \tTrack *track = getTrack();\n  \tif (length == -1)\n  \t\ttrack->data_size = m_fh->length() - m_fh->tell();\n  \telse\n  \t\ttrack->data_size = length - 4;\n  \ttrack->fpos_first_frame = m_fh->tell();\n  \n  \ttrack->computeTotalFileFrames();\n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "parseDescription",
    "container": "CAFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "262-373",
    "snippet": "status CAFFile::parseDescription(const Tag &, int64_t)\n{\n\tdouble sampleRate;\n\tTag formatID;\n\tuint32_t formatFlags;\n\tuint32_t bytesPerPacket;\n\tuint32_t framesPerPacket;\n\tuint32_t channelsPerFrame;\n\tuint32_t bitsPerChannel;\n\tif (!readDouble(&sampleRate) ||\n\t\t!readTag(&formatID) ||\n\t\t!readU32(&formatFlags) ||\n\t\t!readU32(&bytesPerPacket) ||\n\t\t!readU32(&framesPerPacket) ||\n\t\t!readU32(&channelsPerFrame) ||\n\t\t!readU32(&bitsPerChannel))\n\t\treturn AF_FAIL;\n\n\tif (!channelsPerFrame)\n\t{\n\t\t_af_error(AF_BAD_CHANNELS, \"invalid file with 0 channels\");\n\t\treturn AF_FAIL;\n\t}\n\n\tTrack *track = getTrack();\n\ttrack->f.channelCount = channelsPerFrame;\n\ttrack->f.sampleWidth = bitsPerChannel;\n\ttrack->f.sampleRate = sampleRate;\n\ttrack->f.framesPerPacket = 1;\n\n\tif (formatID == \"lpcm\")\n\t{\n\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\t\tif (formatFlags & kCAFLinearPCMFormatFlagIsFloat)\n\t\t{\n\t\t\tif (bitsPerChannel != 32 && bitsPerChannel != 64)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_WIDTH, \"invalid bits per sample %d for floating-point audio data\", bitsPerChannel);\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\t\t\ttrack->f.sampleFormat = bitsPerChannel == 32 ? AF_SAMPFMT_FLOAT :\n\t\t\t\tAF_SAMPFMT_DOUBLE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t}\n\t\ttrack->f.byteOrder = (formatFlags & kCAFLinearPCMFormatFlagIsLittleEndian) ?\n\t\t\tAF_BYTEORDER_LITTLEENDIAN : AF_BYTEORDER_BIGENDIAN;\n\n\t\tif (_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth) == AF_FAIL)\n\t\t\treturn AF_FAIL;\n\n\t\ttrack->f.computeBytesPerPacketPCM();\n\t\treturn AF_SUCCEED;\n\t}\n\telse if (formatID == \"ulaw\")\n\t{\n\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, 16);\n\t\ttrack->f.bytesPerPacket = channelsPerFrame;\n\t\treturn AF_SUCCEED;\n\t}\n\telse if (formatID == \"alaw\")\n\t{\n\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, 16);\n\t\ttrack->f.bytesPerPacket = channelsPerFrame;\n\t\treturn AF_SUCCEED;\n\t}\n\telse if (formatID == \"ima4\")\n\t{\n\t\ttrack->f.compressionType = AF_COMPRESSION_IMA;\n\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, 16);\n\t\tinitIMACompressionParams();\n\t\treturn AF_SUCCEED;\n\t}\n\telse if (formatID == \"alac\")\n\t{\n\t\ttrack->f.compressionType = AF_COMPRESSION_ALAC;\n\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\tswitch (formatFlags)\n\t\t{\n\t\t\tcase kALACFormatFlag_16BitSourceData:\n\t\t\t\ttrack->f.sampleWidth = 16; break;\n\t\t\tcase kALACFormatFlag_20BitSourceData:\n\t\t\t\ttrack->f.sampleWidth = 20; break;\n\t\t\tcase kALACFormatFlag_24BitSourceData:\n\t\t\t\ttrack->f.sampleWidth = 24; break;\n\t\t\tcase kALACFormatFlag_32BitSourceData:\n\t\t\t\ttrack->f.sampleWidth = 32; break;\n\t\t\tdefault:\n\t\t\t\t_af_error(AF_BAD_CODEC_TYPE,\n\t\t\t\t\t\"unsupported format flags for ALAC: %u\", formatFlags);\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP,\n\t\t\ttrack->f.sampleWidth);\n\t\ttrack->f.framesPerPacket = framesPerPacket;\n\t\ttrack->f.bytesPerPacket = 0;\n\t\treturn AF_SUCCEED;\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"Compression type %s not supported\",\n\t\t\tformatID.name().c_str());\n\t\treturn AF_FAIL;\n\t}\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"Compression type %s not supported\"",
            "formatID.name().c_str()"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "formatID.name",
          "args": [],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Tag",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Tag.h",
          "lines": "45-51",
          "snippet": "std::string name() const\n\t{\n\t\tchar s[5];\n\t\tmemcpy(s, &m_value, 4);\n\t\ts[4] = '\\0';\n\t\treturn std::string(s);\n\t}",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stdint.h>\n#include <assert.h>\n\nTag {\n  std::string name() const\n  \t{\n  \t\tchar s[5];\n  \t\tmemcpy(s, &m_value, 4);\n  \t\ts[4] = '\\0';\n  \t\treturn std::string(s);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_set_sample_format",
          "args": [
            "&track->f",
            "AF_SAMPFMT_TWOSCOMP",
            "track->f.sampleWidth"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "_af_set_sample_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "315-361",
          "snippet": "status _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatus _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_CODEC_TYPE",
            "\"unsupported format flags for ALAC: %u\"",
            "formatFlags"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initIMACompressionParams",
          "args": [],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "initIMACompressionParams",
          "container": "CAFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
          "lines": "687-701",
          "snippet": "void CAFFile::initIMACompressionParams()\n{\n\tTrack *track = getTrack();\n\n\ttrack->f.bytesPerPacket = 34 * track->f.channelCount;\n\ttrack->f.framesPerPacket = 64;\n\n\tAUpvlist pv = AUpvnew(1);\n\tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = _AF_IMA_ADPCM_TYPE_QT;\n\tAUpvsetval(pv, 0, &l);\n\n\ttrack->f.compressionParams = pv;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"PacketTable.h\"",
            "#include \"File.h\"",
            "#include \"Buffer.h\"",
            "#include \"CAF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  void CAFFile::initIMACompressionParams()\n  {\n  \tTrack *track = getTrack();\n  \n  \ttrack->f.bytesPerPacket = 34 * track->f.channelCount;\n  \ttrack->f.framesPerPacket = 64;\n  \n  \tAUpvlist pv = AUpvnew(1);\n  \tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n  \tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n  \tlong l = _AF_IMA_ADPCM_TYPE_QT;\n  \tAUpvsetval(pv, 0, &l);\n  \n  \ttrack->f.compressionParams = pv;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "track->f.computeBytesPerPacketPCM",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "computeBytesPerPacketPCM",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "98-103",
          "snippet": "void AudioFormat::computeBytesPerPacketPCM()\n{\n\tassert(isUncompressed());\n\tint bytesPerSample = (sampleWidth + 7) / 8;\n\tbytesPerPacket = bytesPerSample * channelCount;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  void AudioFormat::computeBytesPerPacketPCM()\n  {\n  \tassert(isUncompressed());\n  \tint bytesPerSample = (sampleWidth + 7) / 8;\n  \tbytesPerPacket = bytesPerSample * channelCount;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_WIDTH",
            "\"invalid bits per sample %d for floating-point audio data\"",
            "bitsPerChannel"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getTrack",
          "args": [],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_CHANNELS",
            "\"invalid file with 0 channels\""
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readU32",
          "args": [
            "&bitsPerChannel"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "readU32",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "400-403",
          "snippet": "bool _AFfilehandle::readU32(uint32_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readU32(uint32_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readTag",
          "args": [
            "&formatID"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "readTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "473-482",
          "snippet": "bool _AFfilehandle::readTag(Tag *t)\n{\n\tuint32_t v;\n\tif (m_fh->read(&v, sizeof (v)) == sizeof (v))\n\t{\n\t\t*t = Tag(v);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readTag(Tag *t)\n  {\n  \tuint32_t v;\n  \tif (m_fh->read(&v, sizeof (v)) == sizeof (v))\n  \t{\n  \t\t*t = Tag(v);\n  \t\treturn true;\n  \t}\n  \treturn false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readDouble",
          "args": [
            "&sampleRate"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "readDouble",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "425-428",
          "snippet": "bool _AFfilehandle::readDouble(double *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readDouble(double *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::parseDescription(const Tag &, int64_t)\n  {\n  \tdouble sampleRate;\n  \tTag formatID;\n  \tuint32_t formatFlags;\n  \tuint32_t bytesPerPacket;\n  \tuint32_t framesPerPacket;\n  \tuint32_t channelsPerFrame;\n  \tuint32_t bitsPerChannel;\n  \tif (!readDouble(&sampleRate) ||\n  \t\t!readTag(&formatID) ||\n  \t\t!readU32(&formatFlags) ||\n  \t\t!readU32(&bytesPerPacket) ||\n  \t\t!readU32(&framesPerPacket) ||\n  \t\t!readU32(&channelsPerFrame) ||\n  \t\t!readU32(&bitsPerChannel))\n  \t\treturn AF_FAIL;\n  \n  \tif (!channelsPerFrame)\n  \t{\n  \t\t_af_error(AF_BAD_CHANNELS, \"invalid file with 0 channels\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \tTrack *track = getTrack();\n  \ttrack->f.channelCount = channelsPerFrame;\n  \ttrack->f.sampleWidth = bitsPerChannel;\n  \ttrack->f.sampleRate = sampleRate;\n  \ttrack->f.framesPerPacket = 1;\n  \n  \tif (formatID == \"lpcm\")\n  \t{\n  \t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \t\tif (formatFlags & kCAFLinearPCMFormatFlagIsFloat)\n  \t\t{\n  \t\t\tif (bitsPerChannel != 32 && bitsPerChannel != 64)\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_WIDTH, \"invalid bits per sample %d for floating-point audio data\", bitsPerChannel);\n  \t\t\t\treturn AF_FAIL;\n  \t\t\t}\n  \t\t\ttrack->f.sampleFormat = bitsPerChannel == 32 ? AF_SAMPFMT_FLOAT :\n  \t\t\t\tAF_SAMPFMT_DOUBLE;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t}\n  \t\ttrack->f.byteOrder = (formatFlags & kCAFLinearPCMFormatFlagIsLittleEndian) ?\n  \t\t\tAF_BYTEORDER_LITTLEENDIAN : AF_BYTEORDER_BIGENDIAN;\n  \n  \t\tif (_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth) == AF_FAIL)\n  \t\t\treturn AF_FAIL;\n  \n  \t\ttrack->f.computeBytesPerPacketPCM();\n  \t\treturn AF_SUCCEED;\n  \t}\n  \telse if (formatID == \"ulaw\")\n  \t{\n  \t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n  \t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, 16);\n  \t\ttrack->f.bytesPerPacket = channelsPerFrame;\n  \t\treturn AF_SUCCEED;\n  \t}\n  \telse if (formatID == \"alaw\")\n  \t{\n  \t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n  \t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, 16);\n  \t\ttrack->f.bytesPerPacket = channelsPerFrame;\n  \t\treturn AF_SUCCEED;\n  \t}\n  \telse if (formatID == \"ima4\")\n  \t{\n  \t\ttrack->f.compressionType = AF_COMPRESSION_IMA;\n  \t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, 16);\n  \t\tinitIMACompressionParams();\n  \t\treturn AF_SUCCEED;\n  \t}\n  \telse if (formatID == \"alac\")\n  \t{\n  \t\ttrack->f.compressionType = AF_COMPRESSION_ALAC;\n  \t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t\tswitch (formatFlags)\n  \t\t{\n  \t\t\tcase kALACFormatFlag_16BitSourceData:\n  \t\t\t\ttrack->f.sampleWidth = 16; break;\n  \t\t\tcase kALACFormatFlag_20BitSourceData:\n  \t\t\t\ttrack->f.sampleWidth = 20; break;\n  \t\t\tcase kALACFormatFlag_24BitSourceData:\n  \t\t\t\ttrack->f.sampleWidth = 24; break;\n  \t\t\tcase kALACFormatFlag_32BitSourceData:\n  \t\t\t\ttrack->f.sampleWidth = 32; break;\n  \t\t\tdefault:\n  \t\t\t\t_af_error(AF_BAD_CODEC_TYPE,\n  \t\t\t\t\t\"unsupported format flags for ALAC: %u\", formatFlags);\n  \t\t\t\treturn AF_FAIL;\n  \t\t}\n  \t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP,\n  \t\t\ttrack->f.sampleWidth);\n  \t\ttrack->f.framesPerPacket = framesPerPacket;\n  \t\ttrack->f.bytesPerPacket = 0;\n  \t\treturn AF_SUCCEED;\n  \t}\n  \telse\n  \t{\n  \t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"Compression type %s not supported\",\n  \t\t\tformatID.name().c_str());\n  \t\treturn AF_FAIL;\n  \t}\n  }\n}"
  },
  {
    "function_name": "update",
    "container": "CAFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "251-260",
    "snippet": "status CAFFile::update()\n{\n\tif (writeCookieData() == AF_FAIL)\n\t\treturn AF_FAIL;\n\tif (writeData(true) == AF_FAIL)\n\t\treturn AF_FAIL;\n\tif (writePacketTable() == AF_FAIL)\n\t\treturn AF_FAIL;\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writePacketTable",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "writePacketTable",
          "container": "CAFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
          "lines": "612-654",
          "snippet": "status CAFFile::writePacketTable()\n{\n\tTrack *track = getTrack();\n\n\tm_fh->seek(track->fpos_after_data, File::SeekFromBeginning);\n\n\tSharedPtr<PacketTable> packetTable = track->m_packetTable;\n\tif (!packetTable)\n\t\treturn AF_SUCCEED;\n\n\tint64_t numPackets = packetTable->numPackets();\n\tint64_t numValidFrames = packetTable->numValidFrames();\n\tint32_t primingFrames = packetTable->primingFrames();\n\tint32_t remainderFrames = packetTable->remainderFrames();\n\n\tSharedPtr<Buffer> buffer = new Buffer(packetTable->numPackets() * 5);\n\n\tuint8_t *data = static_cast<uint8_t *>(buffer->data());\n\tsize_t position = 0;\n\tfor (unsigned i=0; i<packetTable->numPackets(); i++)\n\t{\n\t\tuint32_t bytesPerPacket = packetTable->bytesPerPacket(i);\n\t\tsize_t numBytes = 0;\n\t\tencodeBERInteger(bytesPerPacket, data + position, &numBytes);\n\t\tposition += numBytes;\n\t}\n\n\tTag pakt(\"pakt\");\n\tint64_t packetTableLength = 24 + position;\n\n\tif (!writeTag(&pakt) ||\n\t\t!writeS64(&packetTableLength) ||\n\t\t!writeS64(&numPackets) ||\n\t\t!writeS64(&numValidFrames) ||\n\t\t!writeS32(&primingFrames) ||\n\t\t!writeS32(&remainderFrames) ||\n\t\tm_fh->write(buffer->data(), position) != static_cast<ssize_t>(position))\n\t{\n\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"PacketTable.h\"",
            "#include \"File.h\"",
            "#include \"Buffer.h\"",
            "#include \"CAF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::writePacketTable()\n  {\n  \tTrack *track = getTrack();\n  \n  \tm_fh->seek(track->fpos_after_data, File::SeekFromBeginning);\n  \n  \tSharedPtr<PacketTable> packetTable = track->m_packetTable;\n  \tif (!packetTable)\n  \t\treturn AF_SUCCEED;\n  \n  \tint64_t numPackets = packetTable->numPackets();\n  \tint64_t numValidFrames = packetTable->numValidFrames();\n  \tint32_t primingFrames = packetTable->primingFrames();\n  \tint32_t remainderFrames = packetTable->remainderFrames();\n  \n  \tSharedPtr<Buffer> buffer = new Buffer(packetTable->numPackets() * 5);\n  \n  \tuint8_t *data = static_cast<uint8_t *>(buffer->data());\n  \tsize_t position = 0;\n  \tfor (unsigned i=0; i<packetTable->numPackets(); i++)\n  \t{\n  \t\tuint32_t bytesPerPacket = packetTable->bytesPerPacket(i);\n  \t\tsize_t numBytes = 0;\n  \t\tencodeBERInteger(bytesPerPacket, data + position, &numBytes);\n  \t\tposition += numBytes;\n  \t}\n  \n  \tTag pakt(\"pakt\");\n  \tint64_t packetTableLength = 24 + position;\n  \n  \tif (!writeTag(&pakt) ||\n  \t\t!writeS64(&packetTableLength) ||\n  \t\t!writeS64(&numPackets) ||\n  \t\t!writeS64(&numValidFrames) ||\n  \t\t!writeS32(&primingFrames) ||\n  \t\t!writeS32(&remainderFrames) ||\n  \t\tm_fh->write(buffer->data(), position) != static_cast<ssize_t>(position))\n  \t{\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeData",
          "args": [
            "true"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "writeData",
          "container": "CAFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
          "lines": "588-610",
          "snippet": "status CAFFile::writeData(bool update)\n{\n\tTrack *track = getTrack();\n\n\tif (m_dataOffset == -1)\n\t\tm_dataOffset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_dataOffset, File::SeekFromBeginning);\n\n\tTag data(\"data\");\n\tint64_t dataLength = -1;\n\tuint32_t editCount = 0;\n\tif (update)\n\t\tdataLength = track->data_size + 4;\n\n\tif (!writeTag(&data) ||\n\t\t!writeS64(&dataLength) ||\n\t\t!writeU32(&editCount))\n\t\treturn AF_FAIL;\n\tif (track->fpos_first_frame == 0)\n\t\ttrack->fpos_first_frame = m_fh->tell();\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"PacketTable.h\"",
            "#include \"File.h\"",
            "#include \"Buffer.h\"",
            "#include \"CAF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::writeData(bool update)\n  {\n  \tTrack *track = getTrack();\n  \n  \tif (m_dataOffset == -1)\n  \t\tm_dataOffset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_dataOffset, File::SeekFromBeginning);\n  \n  \tTag data(\"data\");\n  \tint64_t dataLength = -1;\n  \tuint32_t editCount = 0;\n  \tif (update)\n  \t\tdataLength = track->data_size + 4;\n  \n  \tif (!writeTag(&data) ||\n  \t\t!writeS64(&dataLength) ||\n  \t\t!writeU32(&editCount))\n  \t\treturn AF_FAIL;\n  \tif (track->fpos_first_frame == 0)\n  \t\ttrack->fpos_first_frame = m_fh->tell();\n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeCookieData",
          "args": [],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "writeCookieData",
          "container": "CAFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
          "lines": "656-676",
          "snippet": "status CAFFile::writeCookieData()\n{\n\tif (!m_codecData)\n\t\treturn AF_SUCCEED;\n\n\tif (m_cookieDataOffset == -1)\n\t\tm_cookieDataOffset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_cookieDataOffset, File::SeekFromBeginning);\n\n\tTag kuki(\"kuki\");\n\tint64_t cookieDataLength = m_codecData->size();\n\tif (!writeTag(&kuki) ||\n\t\t!writeS64(&cookieDataLength) ||\n\t\tm_fh->write(m_codecData->data(), m_codecData->size()) != static_cast<ssize_t>(m_codecData->size()))\n\t{\n\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"PacketTable.h\"",
            "#include \"File.h\"",
            "#include \"Buffer.h\"",
            "#include \"CAF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::writeCookieData()\n  {\n  \tif (!m_codecData)\n  \t\treturn AF_SUCCEED;\n  \n  \tif (m_cookieDataOffset == -1)\n  \t\tm_cookieDataOffset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_cookieDataOffset, File::SeekFromBeginning);\n  \n  \tTag kuki(\"kuki\");\n  \tint64_t cookieDataLength = m_codecData->size();\n  \tif (!writeTag(&kuki) ||\n  \t\t!writeS64(&cookieDataLength) ||\n  \t\tm_fh->write(m_codecData->data(), m_codecData->size()) != static_cast<ssize_t>(m_codecData->size()))\n  \t{\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::update()\n  {\n  \tif (writeCookieData() == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \tif (writeData(true) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \tif (writePacketTable() == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "completeSetup",
    "container": "CAFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "177-249",
    "snippet": "AFfilesetup CAFFile::completeSetup(AFfilesetup setup)\n{\n\tif (setup->trackSet && setup->trackCount != 1)\n\t{\n\t\t_af_error(AF_BAD_NUMTRACKS, \"CAF file must have 1 track\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tTrackSetup *track = setup->getTrack();\n\tif (!track)\n\t\treturn AF_NULL_FILESETUP;\n\n\tif (track->sampleFormatSet)\n\t{\n\t\tif (track->f.isUnsigned())\n\t\t{\n\t\t\t_af_error(AF_BAD_FILEFMT, \"CAF format does not support unsigned data\");\n\t\t\treturn AF_NULL_FILESETUP;\n\t\t}\n\t}\n\telse\n\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP,\n\t\t\ttrack->f.sampleWidth);\n\n\tif (track->f.isSigned() && (track->f.sampleWidth < 1 || track->f.sampleWidth > 32))\n\t{\n\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\"invalid sample width %d for CAF file (must be 1-32)\",\n\t\t\ttrack->f.sampleWidth);\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (!track->byteOrderSet)\n\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\tif (track->f.compressionType != AF_COMPRESSION_NONE &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_G711_ULAW &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_G711_ALAW &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_IMA &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_ALAC)\n\t{\n\t\t_af_error(AF_BAD_COMPTYPE,\n\t\t\t\"compression format %d not supported in CAF file\",\n\t\t\ttrack->f.compressionType);\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->markersSet && track->markerCount)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"CAF does not yet support markers\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->aesDataSet)\n\t{\n\t\t_af_error(AF_BAD_FILESETUP, \"CAF does not support AES data\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (setup->instrumentSet && setup->instrumentCount)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"CAF does not yet support instruments\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (setup->miscellaneousSet && setup->miscellaneousCount)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"CAF does not yet support miscellaneous data\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\treturn _af_filesetup_copy(setup, &cafDefaultFileSetup, true);\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const _AFfilesetup cafDefaultFileSetup =\n{\n\t_AF_VALID_FILESETUP,\t// valid\n\tAF_FILE_CAF,\t\t\t// fileFormat\n\ttrue,\t\t\t\t\t// trackSet\n\ttrue,\t\t\t\t\t// instrumentSet\n\ttrue,\t\t\t\t\t// miscellaneousSet\n\t1,\t\t\t\t\t\t// trackCount\n\tNULL,\t\t\t\t\t// tracks\n\t1,\t\t\t\t\t\t// instrumentCount\n\tNULL,\t\t\t\t\t// instruments\n\t0,\t\t\t\t\t\t// miscellaneousCount\n\tNULL\t\t\t\t\t// miscellaneous\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_af_filesetup_copy",
          "args": [
            "setup",
            "&cafDefaultFileSetup",
            "true"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "_af_filesetup_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Setup.cpp",
          "lines": "440-525",
          "snippet": "AFfilesetup _af_filesetup_copy (const _AFfilesetup *setup,\n\tconst _AFfilesetup *defaultSetup, bool copyMarks)\n{\n\tAFfilesetup newsetup;\n\tint instrumentCount, miscellaneousCount, trackCount;\n\n\tnewsetup = (_AFfilesetup *) _af_malloc(sizeof (_AFfilesetup));\n\tif (newsetup == AF_NULL_FILESETUP)\n\t\treturn AF_NULL_FILESETUP;\n\n\t*newsetup = *defaultSetup;\n\n\tnewsetup->tracks = NULL;\n\tnewsetup->instruments = NULL;\n\tnewsetup->miscellaneous = NULL;\n\n\t/* Copy tracks. */\n\ttrackCount = setup->trackSet ? setup->trackCount :\n\t\tnewsetup->trackSet ? newsetup->trackCount : 0;\n\talloccopy(TrackSetup, trackCount, newsetup->tracks, setup->tracks);\n\tnewsetup->trackCount = trackCount;\n\n\t/* Copy instruments. */\n\tinstrumentCount = setup->instrumentSet ? setup->instrumentCount :\n\t\tnewsetup->instrumentSet ? newsetup->instrumentCount : 0;\n\talloccopy(InstrumentSetup, instrumentCount, newsetup->instruments, setup->instruments);\n\tnewsetup->instrumentCount = instrumentCount;\n\n\t/* Copy miscellaneous information. */\n\tmiscellaneousCount = setup->miscellaneousSet ? setup->miscellaneousCount :\n\t\tnewsetup->miscellaneousSet ? newsetup->miscellaneousCount : 0;\n\talloccopy(MiscellaneousSetup, miscellaneousCount, newsetup->miscellaneous, setup->miscellaneous);\n\tnewsetup->miscellaneousCount = miscellaneousCount;\n\n\tfor (int i=0; i<setup->trackCount; i++)\n\t{\n\t\tTrackSetup\t*track = &newsetup->tracks[i];\n\n\t\t/* XXXmpruett set compression information */\n\n\t\tif (!setup->tracks[i].markersSet && !copyMarks)\n\t\t{\n\t\t\ttrack->markers = NULL;\n\t\t\ttrack->markerCount = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\talloccopy(MarkerSetup, setup->tracks[i].markerCount,\n\t\t\ttrack->markers, setup->tracks[i].markers);\n\t\ttrack->markerCount = setup->tracks[i].markerCount;\n\n\t\tfor (int j=0; j<setup->tracks[i].markerCount; j++)\n\t\t{\n\t\t\ttrack->markers[j].name =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].name);\n\t\t\tif (track->markers[j].name == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\ttrack->markers[j].comment =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].comment);\n\t\t\tif (track->markers[j].comment == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (int i=0; i<newsetup->instrumentCount; i++)\n\t{\n\t\tInstrumentSetup\t*instrument = &newsetup->instruments[i];\n\t\talloccopy(LoopSetup, setup->instruments[i].loopCount,\n\t\t\tinstrument->loops, setup->instruments[i].loops);\n\t}\n\n\treturn newsetup;\n\n\tfail:\n\t\tif (newsetup->miscellaneous)\n\t\t\tfree(newsetup->miscellaneous);\n\t\tif (newsetup->instruments)\n\t\t\tfree(newsetup->instruments);\n\t\tif (newsetup->tracks)\n\t\t\tfree(newsetup->tracks);\n\t\tif (newsetup)\n\t\t\tfree(newsetup);\n\n\treturn AF_NULL_FILESETUP;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"audiofile.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Marker.h\"",
            "#include \"Instrument.h\"",
            "#include \"FileHandle.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"Setup.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"audiofile.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Marker.h\"\n#include \"Instrument.h\"\n#include \"FileHandle.h\"\n#include <string.h>\n#include <stdlib.h>\n#include \"Setup.h\"\n#include \"config.h\"\n\nAFfilesetup _af_filesetup_copy (const _AFfilesetup *setup,\n\tconst _AFfilesetup *defaultSetup, bool copyMarks)\n{\n\tAFfilesetup newsetup;\n\tint instrumentCount, miscellaneousCount, trackCount;\n\n\tnewsetup = (_AFfilesetup *) _af_malloc(sizeof (_AFfilesetup));\n\tif (newsetup == AF_NULL_FILESETUP)\n\t\treturn AF_NULL_FILESETUP;\n\n\t*newsetup = *defaultSetup;\n\n\tnewsetup->tracks = NULL;\n\tnewsetup->instruments = NULL;\n\tnewsetup->miscellaneous = NULL;\n\n\t/* Copy tracks. */\n\ttrackCount = setup->trackSet ? setup->trackCount :\n\t\tnewsetup->trackSet ? newsetup->trackCount : 0;\n\talloccopy(TrackSetup, trackCount, newsetup->tracks, setup->tracks);\n\tnewsetup->trackCount = trackCount;\n\n\t/* Copy instruments. */\n\tinstrumentCount = setup->instrumentSet ? setup->instrumentCount :\n\t\tnewsetup->instrumentSet ? newsetup->instrumentCount : 0;\n\talloccopy(InstrumentSetup, instrumentCount, newsetup->instruments, setup->instruments);\n\tnewsetup->instrumentCount = instrumentCount;\n\n\t/* Copy miscellaneous information. */\n\tmiscellaneousCount = setup->miscellaneousSet ? setup->miscellaneousCount :\n\t\tnewsetup->miscellaneousSet ? newsetup->miscellaneousCount : 0;\n\talloccopy(MiscellaneousSetup, miscellaneousCount, newsetup->miscellaneous, setup->miscellaneous);\n\tnewsetup->miscellaneousCount = miscellaneousCount;\n\n\tfor (int i=0; i<setup->trackCount; i++)\n\t{\n\t\tTrackSetup\t*track = &newsetup->tracks[i];\n\n\t\t/* XXXmpruett set compression information */\n\n\t\tif (!setup->tracks[i].markersSet && !copyMarks)\n\t\t{\n\t\t\ttrack->markers = NULL;\n\t\t\ttrack->markerCount = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\talloccopy(MarkerSetup, setup->tracks[i].markerCount,\n\t\t\ttrack->markers, setup->tracks[i].markers);\n\t\ttrack->markerCount = setup->tracks[i].markerCount;\n\n\t\tfor (int j=0; j<setup->tracks[i].markerCount; j++)\n\t\t{\n\t\t\ttrack->markers[j].name =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].name);\n\t\t\tif (track->markers[j].name == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\ttrack->markers[j].comment =\n\t\t\t\t_af_strdup(setup->tracks[i].markers[j].comment);\n\t\t\tif (track->markers[j].comment == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (int i=0; i<newsetup->instrumentCount; i++)\n\t{\n\t\tInstrumentSetup\t*instrument = &newsetup->instruments[i];\n\t\talloccopy(LoopSetup, setup->instruments[i].loopCount,\n\t\t\tinstrument->loops, setup->instruments[i].loops);\n\t}\n\n\treturn newsetup;\n\n\tfail:\n\t\tif (newsetup->miscellaneous)\n\t\t\tfree(newsetup->miscellaneous);\n\t\tif (newsetup->instruments)\n\t\t\tfree(newsetup->instruments);\n\t\tif (newsetup->tracks)\n\t\t\tfree(newsetup->tracks);\n\t\tif (newsetup)\n\t\t\tfree(newsetup);\n\n\treturn AF_NULL_FILESETUP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"CAF does not yet support miscellaneous data\""
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"CAF does not yet support instruments\""
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_FILESETUP",
            "\"CAF does not support AES data\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NOT_IMPLEMENTED",
            "\"CAF does not yet support markers\""
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_COMPTYPE",
            "\"compression format %d not supported in CAF file\"",
            "track->f.compressionType"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_WIDTH",
            "\"invalid sample width %d for CAF file (must be 1-32)\"",
            "track->f.sampleWidth"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track->f.isSigned",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "isSigned",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "72-75",
          "snippet": "bool AudioFormat::isSigned() const\n{\n\treturn sampleFormat == AF_SAMPFMT_TWOSCOMP;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  bool AudioFormat::isSigned() const\n  {\n  \treturn sampleFormat == AF_SAMPFMT_TWOSCOMP;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_set_sample_format",
          "args": [
            "&track->f",
            "AF_SAMPFMT_TWOSCOMP",
            "track->f.sampleWidth"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "_af_set_sample_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/util.cpp",
          "lines": "315-361",
          "snippet": "status _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"pcm.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"aupvinternal.h\"",
            "#include \"afinternal.h\"",
            "#include \"Track.h\"",
            "#include \"Setup.h\"",
            "#include \"FileHandle.h\"",
            "#include \"File.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"aupvlist.h\"",
            "#include \"audiofile.h\"",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"pcm.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"aupvinternal.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"Setup.h\"\n#include \"FileHandle.h\"\n#include \"File.h\"\n#include \"AudioFormat.h\"\n#include \"aupvlist.h\"\n#include \"audiofile.h\"\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\nstatus _af_set_sample_format (AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      /*for convenience */\n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_FILEFMT",
            "\"CAF format does not support unsigned data\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "track->f.isUnsigned",
          "args": [],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "isUnsigned",
          "container": "AudioFormat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/AudioFormat.cpp",
          "lines": "77-80",
          "snippet": "bool AudioFormat::isUnsigned() const\n{\n\treturn sampleFormat == AF_SAMPFMT_UNSIGNED;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"compression.h\"",
            "#include \"byteorder.h\"",
            "#include \"afinternal.h\"",
            "#include \"AudioFormat.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <assert.h>\n#include \"util.h\"\n#include \"units.h\"\n#include \"compression.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"AudioFormat.h\"\n#include \"config.h\"\n\nAudioFormat {\n  bool AudioFormat::isUnsigned() const\n  {\n  \treturn sampleFormat == AF_SAMPFMT_UNSIGNED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup->getTrack",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_NUMTRACKS",
            "\"CAF file must have 1 track\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nstatic const _AFfilesetup cafDefaultFileSetup =\n{\n\t_AF_VALID_FILESETUP,\t// valid\n\tAF_FILE_CAF,\t\t\t// fileFormat\n\ttrue,\t\t\t\t\t// trackSet\n\ttrue,\t\t\t\t\t// instrumentSet\n\ttrue,\t\t\t\t\t// miscellaneousSet\n\t1,\t\t\t\t\t\t// trackCount\n\tNULL,\t\t\t\t\t// tracks\n\t1,\t\t\t\t\t\t// instrumentCount\n\tNULL,\t\t\t\t\t// instruments\n\t0,\t\t\t\t\t\t// miscellaneousCount\n\tNULL\t\t\t\t\t// miscellaneous\n};\n\nCAFFile {\n  AFfilesetup CAFFile::completeSetup(AFfilesetup setup)\n  {\n  \tif (setup->trackSet && setup->trackCount != 1)\n  \t{\n  \t\t_af_error(AF_BAD_NUMTRACKS, \"CAF file must have 1 track\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tTrackSetup *track = setup->getTrack();\n  \tif (!track)\n  \t\treturn AF_NULL_FILESETUP;\n  \n  \tif (track->sampleFormatSet)\n  \t{\n  \t\tif (track->f.isUnsigned())\n  \t\t{\n  \t\t\t_af_error(AF_BAD_FILEFMT, \"CAF format does not support unsigned data\");\n  \t\t\treturn AF_NULL_FILESETUP;\n  \t\t}\n  \t}\n  \telse\n  \t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP,\n  \t\t\ttrack->f.sampleWidth);\n  \n  \tif (track->f.isSigned() && (track->f.sampleWidth < 1 || track->f.sampleWidth > 32))\n  \t{\n  \t\t_af_error(AF_BAD_WIDTH,\n  \t\t\t\"invalid sample width %d for CAF file (must be 1-32)\",\n  \t\t\ttrack->f.sampleWidth);\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (!track->byteOrderSet)\n  \t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \n  \tif (track->f.compressionType != AF_COMPRESSION_NONE &&\n  \t\ttrack->f.compressionType != AF_COMPRESSION_G711_ULAW &&\n  \t\ttrack->f.compressionType != AF_COMPRESSION_G711_ALAW &&\n  \t\ttrack->f.compressionType != AF_COMPRESSION_IMA &&\n  \t\ttrack->f.compressionType != AF_COMPRESSION_ALAC)\n  \t{\n  \t\t_af_error(AF_BAD_COMPTYPE,\n  \t\t\t\"compression format %d not supported in CAF file\",\n  \t\t\ttrack->f.compressionType);\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (track->markersSet && track->markerCount)\n  \t{\n  \t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"CAF does not yet support markers\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (track->aesDataSet)\n  \t{\n  \t\t_af_error(AF_BAD_FILESETUP, \"CAF does not support AES data\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (setup->instrumentSet && setup->instrumentCount)\n  \t{\n  \t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"CAF does not yet support instruments\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \tif (setup->miscellaneousSet && setup->miscellaneousCount)\n  \t{\n  \t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"CAF does not yet support miscellaneous data\");\n  \t\treturn AF_NULL_FILESETUP;\n  \t}\n  \n  \treturn _af_filesetup_copy(setup, &cafDefaultFileSetup, true);\n  }\n}"
  },
  {
    "function_name": "writeInit",
    "container": "CAFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "155-175",
    "snippet": "status CAFFile::writeInit(AFfilesetup setup)\n{\n\tif (initFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\n\tinitCompressionParams();\n\n\tTag caff(\"caff\");\n\tif (!writeTag(&caff)) return AF_FAIL;\n\tconst uint8_t versionAndFlags[4] = { 0, 1, 0, 0 };\n\tif (m_fh->write(versionAndFlags, 4) != 4) return AF_FAIL;\n\n\tif (writeDescription() == AF_FAIL)\n\t\treturn AF_FAIL;\n\tif (writeCookieData() == AF_FAIL)\n\t\treturn AF_FAIL;\n\tif (writeData(false) == AF_FAIL)\n\t\treturn AF_FAIL;\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeData",
          "args": [
            "false"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "writeData",
          "container": "CAFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
          "lines": "588-610",
          "snippet": "status CAFFile::writeData(bool update)\n{\n\tTrack *track = getTrack();\n\n\tif (m_dataOffset == -1)\n\t\tm_dataOffset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_dataOffset, File::SeekFromBeginning);\n\n\tTag data(\"data\");\n\tint64_t dataLength = -1;\n\tuint32_t editCount = 0;\n\tif (update)\n\t\tdataLength = track->data_size + 4;\n\n\tif (!writeTag(&data) ||\n\t\t!writeS64(&dataLength) ||\n\t\t!writeU32(&editCount))\n\t\treturn AF_FAIL;\n\tif (track->fpos_first_frame == 0)\n\t\ttrack->fpos_first_frame = m_fh->tell();\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"PacketTable.h\"",
            "#include \"File.h\"",
            "#include \"Buffer.h\"",
            "#include \"CAF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::writeData(bool update)\n  {\n  \tTrack *track = getTrack();\n  \n  \tif (m_dataOffset == -1)\n  \t\tm_dataOffset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_dataOffset, File::SeekFromBeginning);\n  \n  \tTag data(\"data\");\n  \tint64_t dataLength = -1;\n  \tuint32_t editCount = 0;\n  \tif (update)\n  \t\tdataLength = track->data_size + 4;\n  \n  \tif (!writeTag(&data) ||\n  \t\t!writeS64(&dataLength) ||\n  \t\t!writeU32(&editCount))\n  \t\treturn AF_FAIL;\n  \tif (track->fpos_first_frame == 0)\n  \t\ttrack->fpos_first_frame = m_fh->tell();\n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeCookieData",
          "args": [],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "writeCookieData",
          "container": "CAFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
          "lines": "656-676",
          "snippet": "status CAFFile::writeCookieData()\n{\n\tif (!m_codecData)\n\t\treturn AF_SUCCEED;\n\n\tif (m_cookieDataOffset == -1)\n\t\tm_cookieDataOffset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_cookieDataOffset, File::SeekFromBeginning);\n\n\tTag kuki(\"kuki\");\n\tint64_t cookieDataLength = m_codecData->size();\n\tif (!writeTag(&kuki) ||\n\t\t!writeS64(&cookieDataLength) ||\n\t\tm_fh->write(m_codecData->data(), m_codecData->size()) != static_cast<ssize_t>(m_codecData->size()))\n\t{\n\t\treturn AF_FAIL;\n\t}\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"PacketTable.h\"",
            "#include \"File.h\"",
            "#include \"Buffer.h\"",
            "#include \"CAF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::writeCookieData()\n  {\n  \tif (!m_codecData)\n  \t\treturn AF_SUCCEED;\n  \n  \tif (m_cookieDataOffset == -1)\n  \t\tm_cookieDataOffset = m_fh->tell();\n  \telse\n  \t\tm_fh->seek(m_cookieDataOffset, File::SeekFromBeginning);\n  \n  \tTag kuki(\"kuki\");\n  \tint64_t cookieDataLength = m_codecData->size();\n  \tif (!writeTag(&kuki) ||\n  \t\t!writeS64(&cookieDataLength) ||\n  \t\tm_fh->write(m_codecData->data(), m_codecData->size()) != static_cast<ssize_t>(m_codecData->size()))\n  \t{\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeDescription",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "writeDescription",
          "container": "CAFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
          "lines": "521-586",
          "snippet": "status CAFFile::writeDescription()\n{\n\tTrack *track = getTrack();\n\n\tTag desc(\"desc\");\n\tint64_t chunkLength = 32;\n\tdouble sampleRate = track->f.sampleRate;\n\tTag formatID(\"lpcm\");\n\tuint32_t formatFlags = 0;\n\tif (track->f.byteOrder == AF_BYTEORDER_LITTLEENDIAN)\n\t\tformatFlags |= kCAFLinearPCMFormatFlagIsLittleEndian;\n\tif (track->f.isFloat())\n\t\tformatFlags |= kCAFLinearPCMFormatFlagIsFloat;\n\tuint32_t bytesPerPacket = track->f.bytesPerFrame(false);\n\tuint32_t framesPerPacket = 1;\n\tuint32_t channelsPerFrame = track->f.channelCount;\n\tuint32_t bitsPerChannel = track->f.sampleWidth;\n\n\tif (track->f.compressionType == AF_COMPRESSION_G711_ULAW)\n\t{\n\t\tformatID = \"ulaw\";\n\t\tformatFlags = 0;\n\t\tbytesPerPacket = channelsPerFrame;\n\t\tbitsPerChannel = 8;\n\t}\n\telse if (track->f.compressionType == AF_COMPRESSION_G711_ALAW)\n\t{\n\t\tformatID = \"alaw\";\n\t\tformatFlags = 0;\n\t\tbytesPerPacket = channelsPerFrame;\n\t\tbitsPerChannel = 8;\n\t}\n\telse if (track->f.compressionType == AF_COMPRESSION_IMA)\n\t{\n\t\tformatID = \"ima4\";\n\t\tformatFlags = 0;\n\t\tbytesPerPacket = track->f.bytesPerPacket;\n\t\tframesPerPacket = track->f.framesPerPacket;\n\t\tbitsPerChannel = 16;\n\t}\n\telse if (track->f.compressionType == AF_COMPRESSION_ALAC)\n\t{\n\t\tformatID = \"alac\";\n\t\tswitch (track->f.sampleWidth)\n\t\t{\n\t\t\tcase 16: formatFlags = kALACFormatFlag_16BitSourceData; break;\n\t\t\tcase 20: formatFlags = kALACFormatFlag_20BitSourceData; break;\n\t\t\tcase 24: formatFlags = kALACFormatFlag_24BitSourceData; break;\n\t\t\tcase 32: formatFlags = kALACFormatFlag_32BitSourceData; break;\n\t\t}\n\t\tbytesPerPacket = track->f.bytesPerPacket;\n\t\tframesPerPacket = track->f.framesPerPacket;\n\t}\n\n\tif (!writeTag(&desc) ||\n\t\t!writeS64(&chunkLength) ||\n\t\t!writeDouble(&sampleRate) ||\n\t\t!writeTag(&formatID) ||\n\t\t!writeU32(&formatFlags) ||\n\t\t!writeU32(&bytesPerPacket) ||\n\t\t!writeU32(&framesPerPacket) ||\n\t\t!writeU32(&channelsPerFrame) ||\n\t\t!writeU32(&bitsPerChannel))\n\t\treturn AF_FAIL;\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"PacketTable.h\"",
            "#include \"File.h\"",
            "#include \"Buffer.h\"",
            "#include \"CAF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::writeDescription()\n  {\n  \tTrack *track = getTrack();\n  \n  \tTag desc(\"desc\");\n  \tint64_t chunkLength = 32;\n  \tdouble sampleRate = track->f.sampleRate;\n  \tTag formatID(\"lpcm\");\n  \tuint32_t formatFlags = 0;\n  \tif (track->f.byteOrder == AF_BYTEORDER_LITTLEENDIAN)\n  \t\tformatFlags |= kCAFLinearPCMFormatFlagIsLittleEndian;\n  \tif (track->f.isFloat())\n  \t\tformatFlags |= kCAFLinearPCMFormatFlagIsFloat;\n  \tuint32_t bytesPerPacket = track->f.bytesPerFrame(false);\n  \tuint32_t framesPerPacket = 1;\n  \tuint32_t channelsPerFrame = track->f.channelCount;\n  \tuint32_t bitsPerChannel = track->f.sampleWidth;\n  \n  \tif (track->f.compressionType == AF_COMPRESSION_G711_ULAW)\n  \t{\n  \t\tformatID = \"ulaw\";\n  \t\tformatFlags = 0;\n  \t\tbytesPerPacket = channelsPerFrame;\n  \t\tbitsPerChannel = 8;\n  \t}\n  \telse if (track->f.compressionType == AF_COMPRESSION_G711_ALAW)\n  \t{\n  \t\tformatID = \"alaw\";\n  \t\tformatFlags = 0;\n  \t\tbytesPerPacket = channelsPerFrame;\n  \t\tbitsPerChannel = 8;\n  \t}\n  \telse if (track->f.compressionType == AF_COMPRESSION_IMA)\n  \t{\n  \t\tformatID = \"ima4\";\n  \t\tformatFlags = 0;\n  \t\tbytesPerPacket = track->f.bytesPerPacket;\n  \t\tframesPerPacket = track->f.framesPerPacket;\n  \t\tbitsPerChannel = 16;\n  \t}\n  \telse if (track->f.compressionType == AF_COMPRESSION_ALAC)\n  \t{\n  \t\tformatID = \"alac\";\n  \t\tswitch (track->f.sampleWidth)\n  \t\t{\n  \t\t\tcase 16: formatFlags = kALACFormatFlag_16BitSourceData; break;\n  \t\t\tcase 20: formatFlags = kALACFormatFlag_20BitSourceData; break;\n  \t\t\tcase 24: formatFlags = kALACFormatFlag_24BitSourceData; break;\n  \t\t\tcase 32: formatFlags = kALACFormatFlag_32BitSourceData; break;\n  \t\t}\n  \t\tbytesPerPacket = track->f.bytesPerPacket;\n  \t\tframesPerPacket = track->f.framesPerPacket;\n  \t}\n  \n  \tif (!writeTag(&desc) ||\n  \t\t!writeS64(&chunkLength) ||\n  \t\t!writeDouble(&sampleRate) ||\n  \t\t!writeTag(&formatID) ||\n  \t\t!writeU32(&formatFlags) ||\n  \t\t!writeU32(&bytesPerPacket) ||\n  \t\t!writeU32(&framesPerPacket) ||\n  \t\t!writeU32(&channelsPerFrame) ||\n  \t\t!writeU32(&bitsPerChannel))\n  \t\treturn AF_FAIL;\n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->write",
          "args": [
            "versionAndFlags",
            "4"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "177-180",
          "snippet": "ssize_t FileVF::write(const void *data, size_t nbytes)\n{\n\treturn m_vf->write(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::write(const void *data, size_t nbytes)\n  {\n  \treturn m_vf->write(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeTag",
          "args": [
            "&caff"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "writeTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "484-488",
          "snippet": "bool _AFfilehandle::writeTag(const Tag *t)\n{\n\tuint32_t v = t->value();\n\treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::writeTag(const Tag *t)\n  {\n  \tuint32_t v = t->value();\n  \treturn m_fh->write(&v, sizeof (v)) == sizeof (v);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "initCompressionParams",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "initCompressionParams",
          "container": "CAFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
          "lines": "678-685",
          "snippet": "void CAFFile::initCompressionParams()\n{\n\tTrack *track = getTrack();\n\tif (track->f.compressionType == AF_COMPRESSION_IMA)\n\t\tinitIMACompressionParams();\n\telse if (track->f.compressionType == AF_COMPRESSION_ALAC)\n\t\tinitALACCompressionParams();\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"PacketTable.h\"",
            "#include \"File.h\"",
            "#include \"Buffer.h\"",
            "#include \"CAF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  void CAFFile::initCompressionParams()\n  {\n  \tTrack *track = getTrack();\n  \tif (track->f.compressionType == AF_COMPRESSION_IMA)\n  \t\tinitIMACompressionParams();\n  \telse if (track->f.compressionType == AF_COMPRESSION_ALAC)\n  \t\tinitALACCompressionParams();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "initFromSetup",
          "args": [
            "setup"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "initFromSetup",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "222-231",
          "snippet": "status _AFfilehandle::initFromSetup(AFfilesetup setup)\n{\n\tif (copyTracksFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\tif (copyInstrumentsFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\tif (copyMiscellaneousFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  status _AFfilehandle::initFromSetup(AFfilesetup setup)\n  {\n  \tif (copyTracksFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \tif (copyInstrumentsFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \tif (copyMiscellaneousFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \treturn AF_SUCCEED;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::writeInit(AFfilesetup setup)\n  {\n  \tif (initFromSetup(setup) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \n  \tinitCompressionParams();\n  \n  \tTag caff(\"caff\");\n  \tif (!writeTag(&caff)) return AF_FAIL;\n  \tconst uint8_t versionAndFlags[4] = { 0, 1, 0, 0 };\n  \tif (m_fh->write(versionAndFlags, 4) != 4) return AF_FAIL;\n  \n  \tif (writeDescription() == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \tif (writeCookieData() == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \tif (writeData(false) == AF_FAIL)\n  \t\treturn AF_FAIL;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "readInit",
    "container": "CAFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "100-153",
    "snippet": "status CAFFile::readInit(AFfilesetup setup)\n{\n\tm_fh->seek(8, File::SeekFromBeginning);\n\n\tif (!allocateTrack())\n\t\treturn AF_FAIL;\n\n\toff_t currentOffset = m_fh->tell();\n\toff_t fileLength = m_fh->length();\n\n\twhile (currentOffset < fileLength)\n\t{\n\t\tTag chunkType;\n\t\tint64_t chunkLength;\n\t\tif (!readTag(&chunkType) ||\n\t\t\t!readS64(&chunkLength))\n\t\t\treturn AF_FAIL;\n\n\t\tcurrentOffset += 12;\n\n\t\tif (chunkType == \"data\" && chunkLength == -1)\n\t\t\tchunkLength = fileLength - currentOffset;\n\t\telse if (chunkLength < 0)\n\t\t\t_af_error(AF_BAD_HEADER,\n\t\t\t\t\"invalid chunk length %jd for chunk type %s\\n\",\n\t\t\t\tstatic_cast<intmax_t>(chunkLength), chunkType.name().c_str());\n\n\t\tif (chunkType == \"desc\")\n\t\t{\n\t\t\tif (parseDescription(chunkType, chunkLength) == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (chunkType == \"data\")\n\t\t{\n\t\t\tif (parseData(chunkType, chunkLength) == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (chunkType == \"pakt\")\n\t\t{\n\t\t\tif (parsePacketTable(chunkType, chunkLength) == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (chunkType == \"kuki\")\n\t\t{\n\t\t\tif (parseCookieData(chunkType, chunkLength) == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\n\t\tcurrentOffset = m_fh->seek(currentOffset + chunkLength,\n\t\t\tFile::SeekFromBeginning);\n\t}\n\n\treturn AF_SUCCEED;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fh->seek",
          "args": [
            "currentOffset + chunkLength",
            "File::SeekFromBeginning"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseCookieData",
          "args": [
            "chunkType",
            "chunkLength"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "parseCookieData",
          "container": "CAFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
          "lines": "497-519",
          "snippet": "status CAFFile::parseCookieData(const Tag &tag, int64_t length)\n{\n\tm_codecData = new Buffer(length);\n\tif (m_fh->read(m_codecData->data(), length) != length)\n\t\treturn AF_FAIL;\n\n\tAUpvlist pv = AUpvnew(2);\n\n\tAUpvsetparam(pv, 0, _AF_CODEC_DATA_SIZE);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = length;\n\tAUpvsetval(pv, 0, &l);\n\n\tAUpvsetparam(pv, 1, _AF_CODEC_DATA);\n\tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n\tvoid *v = m_codecData->data();\n\tAUpvsetval(pv, 1, &v);\n\n\tTrack *track = getTrack();\n\ttrack->f.compressionParams = pv;\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"PacketTable.h\"",
            "#include \"File.h\"",
            "#include \"Buffer.h\"",
            "#include \"CAF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::parseCookieData(const Tag &tag, int64_t length)\n  {\n  \tm_codecData = new Buffer(length);\n  \tif (m_fh->read(m_codecData->data(), length) != length)\n  \t\treturn AF_FAIL;\n  \n  \tAUpvlist pv = AUpvnew(2);\n  \n  \tAUpvsetparam(pv, 0, _AF_CODEC_DATA_SIZE);\n  \tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n  \tlong l = length;\n  \tAUpvsetval(pv, 0, &l);\n  \n  \tAUpvsetparam(pv, 1, _AF_CODEC_DATA);\n  \tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n  \tvoid *v = m_codecData->data();\n  \tAUpvsetval(pv, 1, &v);\n  \n  \tTrack *track = getTrack();\n  \ttrack->f.compressionParams = pv;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parsePacketTable",
          "args": [
            "chunkType",
            "chunkLength"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "parsePacketTable",
          "container": "CAFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
          "lines": "447-495",
          "snippet": "status CAFFile::parsePacketTable(const Tag &tag, int64_t length)\n{\n\tif (length < 24)\n\t\treturn AF_FAIL;\n\n\tint64_t numPackets;\n\tint64_t numValidFrames;\n\tint32_t primingFrames;\n\tint32_t remainderFrames;\n\tif (!readS64(&numPackets) ||\n\t\t!readS64(&numValidFrames) ||\n\t\t!readS32(&primingFrames) ||\n\t\t!readS32(&remainderFrames))\n\t{\n\t\treturn AF_FAIL;\n\t}\n\n\tif (!numPackets)\n\t\treturn AF_SUCCEED;\n\n\tint64_t tableLength = length - 24;\n\n\tSharedPtr<Buffer> buffer = new Buffer(tableLength);\n\tif (m_fh->read(buffer->data(), tableLength) != tableLength)\n\t\treturn AF_FAIL;\n\n\tSharedPtr<PacketTable> packetTable = new PacketTable(numValidFrames,\n\t\tprimingFrames, remainderFrames);\n\n\tconst uint8_t *data = static_cast<const uint8_t *>(buffer->data());\n\tsize_t position = 0;\n\twhile (position < buffer->size())\n\t{\n\t\tsize_t sizeRemaining = buffer->size() - position;\n\t\tuint32_t bytesPerPacket = readBERInteger(data + position, &sizeRemaining);\n\t\tif (bytesPerPacket == 0)\n\t\t\tbreak;\n\t\tpacketTable->append(bytesPerPacket);\n\t\tposition += sizeRemaining;\n\t}\n\n\tassert(numPackets == packetTable->numPackets());\n\n\tTrack *track = getTrack();\n\ttrack->m_packetTable = packetTable;\n\ttrack->totalfframes = numValidFrames;\n\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"PacketTable.h\"",
            "#include \"File.h\"",
            "#include \"Buffer.h\"",
            "#include \"CAF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::parsePacketTable(const Tag &tag, int64_t length)\n  {\n  \tif (length < 24)\n  \t\treturn AF_FAIL;\n  \n  \tint64_t numPackets;\n  \tint64_t numValidFrames;\n  \tint32_t primingFrames;\n  \tint32_t remainderFrames;\n  \tif (!readS64(&numPackets) ||\n  \t\t!readS64(&numValidFrames) ||\n  \t\t!readS32(&primingFrames) ||\n  \t\t!readS32(&remainderFrames))\n  \t{\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \tif (!numPackets)\n  \t\treturn AF_SUCCEED;\n  \n  \tint64_t tableLength = length - 24;\n  \n  \tSharedPtr<Buffer> buffer = new Buffer(tableLength);\n  \tif (m_fh->read(buffer->data(), tableLength) != tableLength)\n  \t\treturn AF_FAIL;\n  \n  \tSharedPtr<PacketTable> packetTable = new PacketTable(numValidFrames,\n  \t\tprimingFrames, remainderFrames);\n  \n  \tconst uint8_t *data = static_cast<const uint8_t *>(buffer->data());\n  \tsize_t position = 0;\n  \twhile (position < buffer->size())\n  \t{\n  \t\tsize_t sizeRemaining = buffer->size() - position;\n  \t\tuint32_t bytesPerPacket = readBERInteger(data + position, &sizeRemaining);\n  \t\tif (bytesPerPacket == 0)\n  \t\t\tbreak;\n  \t\tpacketTable->append(bytesPerPacket);\n  \t\tposition += sizeRemaining;\n  \t}\n  \n  \tassert(numPackets == packetTable->numPackets());\n  \n  \tTrack *track = getTrack();\n  \ttrack->m_packetTable = packetTable;\n  \ttrack->totalfframes = numValidFrames;\n  \n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseData",
          "args": [
            "chunkType",
            "chunkLength"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "parseData",
          "container": "CAFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
          "lines": "375-390",
          "snippet": "status CAFFile::parseData(const Tag &tag, int64_t length)\n{\n\tuint32_t editCount;\n\tif (!readU32(&editCount))\n\t\treturn AF_FAIL;\n\n\tTrack *track = getTrack();\n\tif (length == -1)\n\t\ttrack->data_size = m_fh->length() - m_fh->tell();\n\telse\n\t\ttrack->data_size = length - 4;\n\ttrack->fpos_first_frame = m_fh->tell();\n\n\ttrack->computeTotalFileFrames();\n\treturn AF_SUCCEED;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"PacketTable.h\"",
            "#include \"File.h\"",
            "#include \"Buffer.h\"",
            "#include \"CAF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::parseData(const Tag &tag, int64_t length)\n  {\n  \tuint32_t editCount;\n  \tif (!readU32(&editCount))\n  \t\treturn AF_FAIL;\n  \n  \tTrack *track = getTrack();\n  \tif (length == -1)\n  \t\ttrack->data_size = m_fh->length() - m_fh->tell();\n  \telse\n  \t\ttrack->data_size = length - 4;\n  \ttrack->fpos_first_frame = m_fh->tell();\n  \n  \ttrack->computeTotalFileFrames();\n  \treturn AF_SUCCEED;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseDescription",
          "args": [
            "chunkType",
            "chunkLength"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "parseDescription",
          "container": "CAFFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
          "lines": "262-373",
          "snippet": "status CAFFile::parseDescription(const Tag &, int64_t)\n{\n\tdouble sampleRate;\n\tTag formatID;\n\tuint32_t formatFlags;\n\tuint32_t bytesPerPacket;\n\tuint32_t framesPerPacket;\n\tuint32_t channelsPerFrame;\n\tuint32_t bitsPerChannel;\n\tif (!readDouble(&sampleRate) ||\n\t\t!readTag(&formatID) ||\n\t\t!readU32(&formatFlags) ||\n\t\t!readU32(&bytesPerPacket) ||\n\t\t!readU32(&framesPerPacket) ||\n\t\t!readU32(&channelsPerFrame) ||\n\t\t!readU32(&bitsPerChannel))\n\t\treturn AF_FAIL;\n\n\tif (!channelsPerFrame)\n\t{\n\t\t_af_error(AF_BAD_CHANNELS, \"invalid file with 0 channels\");\n\t\treturn AF_FAIL;\n\t}\n\n\tTrack *track = getTrack();\n\ttrack->f.channelCount = channelsPerFrame;\n\ttrack->f.sampleWidth = bitsPerChannel;\n\ttrack->f.sampleRate = sampleRate;\n\ttrack->f.framesPerPacket = 1;\n\n\tif (formatID == \"lpcm\")\n\t{\n\t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\t\tif (formatFlags & kCAFLinearPCMFormatFlagIsFloat)\n\t\t{\n\t\t\tif (bitsPerChannel != 32 && bitsPerChannel != 64)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_WIDTH, \"invalid bits per sample %d for floating-point audio data\", bitsPerChannel);\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\t\t\ttrack->f.sampleFormat = bitsPerChannel == 32 ? AF_SAMPFMT_FLOAT :\n\t\t\t\tAF_SAMPFMT_DOUBLE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t}\n\t\ttrack->f.byteOrder = (formatFlags & kCAFLinearPCMFormatFlagIsLittleEndian) ?\n\t\t\tAF_BYTEORDER_LITTLEENDIAN : AF_BYTEORDER_BIGENDIAN;\n\n\t\tif (_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth) == AF_FAIL)\n\t\t\treturn AF_FAIL;\n\n\t\ttrack->f.computeBytesPerPacketPCM();\n\t\treturn AF_SUCCEED;\n\t}\n\telse if (formatID == \"ulaw\")\n\t{\n\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, 16);\n\t\ttrack->f.bytesPerPacket = channelsPerFrame;\n\t\treturn AF_SUCCEED;\n\t}\n\telse if (formatID == \"alaw\")\n\t{\n\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, 16);\n\t\ttrack->f.bytesPerPacket = channelsPerFrame;\n\t\treturn AF_SUCCEED;\n\t}\n\telse if (formatID == \"ima4\")\n\t{\n\t\ttrack->f.compressionType = AF_COMPRESSION_IMA;\n\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, 16);\n\t\tinitIMACompressionParams();\n\t\treturn AF_SUCCEED;\n\t}\n\telse if (formatID == \"alac\")\n\t{\n\t\ttrack->f.compressionType = AF_COMPRESSION_ALAC;\n\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\tswitch (formatFlags)\n\t\t{\n\t\t\tcase kALACFormatFlag_16BitSourceData:\n\t\t\t\ttrack->f.sampleWidth = 16; break;\n\t\t\tcase kALACFormatFlag_20BitSourceData:\n\t\t\t\ttrack->f.sampleWidth = 20; break;\n\t\t\tcase kALACFormatFlag_24BitSourceData:\n\t\t\t\ttrack->f.sampleWidth = 24; break;\n\t\t\tcase kALACFormatFlag_32BitSourceData:\n\t\t\t\ttrack->f.sampleWidth = 32; break;\n\t\t\tdefault:\n\t\t\t\t_af_error(AF_BAD_CODEC_TYPE,\n\t\t\t\t\t\"unsupported format flags for ALAC: %u\", formatFlags);\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP,\n\t\t\ttrack->f.sampleWidth);\n\t\ttrack->f.framesPerPacket = framesPerPacket;\n\t\ttrack->f.bytesPerPacket = 0;\n\t\treturn AF_SUCCEED;\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"Compression type %s not supported\",\n\t\t\tformatID.name().c_str());\n\t\treturn AF_FAIL;\n\t}\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include \"util.h\"",
            "#include \"byteorder.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"PacketTable.h\"",
            "#include \"File.h\"",
            "#include \"Buffer.h\"",
            "#include \"CAF.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::parseDescription(const Tag &, int64_t)\n  {\n  \tdouble sampleRate;\n  \tTag formatID;\n  \tuint32_t formatFlags;\n  \tuint32_t bytesPerPacket;\n  \tuint32_t framesPerPacket;\n  \tuint32_t channelsPerFrame;\n  \tuint32_t bitsPerChannel;\n  \tif (!readDouble(&sampleRate) ||\n  \t\t!readTag(&formatID) ||\n  \t\t!readU32(&formatFlags) ||\n  \t\t!readU32(&bytesPerPacket) ||\n  \t\t!readU32(&framesPerPacket) ||\n  \t\t!readU32(&channelsPerFrame) ||\n  \t\t!readU32(&bitsPerChannel))\n  \t\treturn AF_FAIL;\n  \n  \tif (!channelsPerFrame)\n  \t{\n  \t\t_af_error(AF_BAD_CHANNELS, \"invalid file with 0 channels\");\n  \t\treturn AF_FAIL;\n  \t}\n  \n  \tTrack *track = getTrack();\n  \ttrack->f.channelCount = channelsPerFrame;\n  \ttrack->f.sampleWidth = bitsPerChannel;\n  \ttrack->f.sampleRate = sampleRate;\n  \ttrack->f.framesPerPacket = 1;\n  \n  \tif (formatID == \"lpcm\")\n  \t{\n  \t\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n  \t\tif (formatFlags & kCAFLinearPCMFormatFlagIsFloat)\n  \t\t{\n  \t\t\tif (bitsPerChannel != 32 && bitsPerChannel != 64)\n  \t\t\t{\n  \t\t\t\t_af_error(AF_BAD_WIDTH, \"invalid bits per sample %d for floating-point audio data\", bitsPerChannel);\n  \t\t\t\treturn AF_FAIL;\n  \t\t\t}\n  \t\t\ttrack->f.sampleFormat = bitsPerChannel == 32 ? AF_SAMPFMT_FLOAT :\n  \t\t\t\tAF_SAMPFMT_DOUBLE;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n  \t\t}\n  \t\ttrack->f.byteOrder = (formatFlags & kCAFLinearPCMFormatFlagIsLittleEndian) ?\n  \t\t\tAF_BYTEORDER_LITTLEENDIAN : AF_BYTEORDER_BIGENDIAN;\n  \n  \t\tif (_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth) == AF_FAIL)\n  \t\t\treturn AF_FAIL;\n  \n  \t\ttrack->f.computeBytesPerPacketPCM();\n  \t\treturn AF_SUCCEED;\n  \t}\n  \telse if (formatID == \"ulaw\")\n  \t{\n  \t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n  \t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, 16);\n  \t\ttrack->f.bytesPerPacket = channelsPerFrame;\n  \t\treturn AF_SUCCEED;\n  \t}\n  \telse if (formatID == \"alaw\")\n  \t{\n  \t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n  \t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, 16);\n  \t\ttrack->f.bytesPerPacket = channelsPerFrame;\n  \t\treturn AF_SUCCEED;\n  \t}\n  \telse if (formatID == \"ima4\")\n  \t{\n  \t\ttrack->f.compressionType = AF_COMPRESSION_IMA;\n  \t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, 16);\n  \t\tinitIMACompressionParams();\n  \t\treturn AF_SUCCEED;\n  \t}\n  \telse if (formatID == \"alac\")\n  \t{\n  \t\ttrack->f.compressionType = AF_COMPRESSION_ALAC;\n  \t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n  \t\tswitch (formatFlags)\n  \t\t{\n  \t\t\tcase kALACFormatFlag_16BitSourceData:\n  \t\t\t\ttrack->f.sampleWidth = 16; break;\n  \t\t\tcase kALACFormatFlag_20BitSourceData:\n  \t\t\t\ttrack->f.sampleWidth = 20; break;\n  \t\t\tcase kALACFormatFlag_24BitSourceData:\n  \t\t\t\ttrack->f.sampleWidth = 24; break;\n  \t\t\tcase kALACFormatFlag_32BitSourceData:\n  \t\t\t\ttrack->f.sampleWidth = 32; break;\n  \t\t\tdefault:\n  \t\t\t\t_af_error(AF_BAD_CODEC_TYPE,\n  \t\t\t\t\t\"unsupported format flags for ALAC: %u\", formatFlags);\n  \t\t\t\treturn AF_FAIL;\n  \t\t}\n  \t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP,\n  \t\t\ttrack->f.sampleWidth);\n  \t\ttrack->f.framesPerPacket = framesPerPacket;\n  \t\ttrack->f.bytesPerPacket = 0;\n  \t\treturn AF_SUCCEED;\n  \t}\n  \telse\n  \t{\n  \t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"Compression type %s not supported\",\n  \t\t\tformatID.name().c_str());\n  \t\treturn AF_FAIL;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_af_error",
          "args": [
            "AF_BAD_HEADER",
            "\"invalid chunk length %jd for chunk type %s\\n\"",
            "static_cast<intmax_t>(chunkLength)",
            "chunkType.name().c_str()"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chunkType.name",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "Tag",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/Tag.h",
          "lines": "45-51",
          "snippet": "std::string name() const\n\t{\n\t\tchar s[5];\n\t\tmemcpy(s, &m_value, 4);\n\t\ts[4] = '\\0';\n\t\treturn std::string(s);\n\t}",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stdint.h>\n#include <assert.h>\n\nTag {\n  std::string name() const\n  \t{\n  \t\tchar s[5];\n  \t\tmemcpy(s, &m_value, 4);\n  \t\ts[4] = '\\0';\n  \t\treturn std::string(s);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<intmax_t>",
          "args": [
            "chunkLength"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readS64",
          "args": [
            "&chunkLength"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "readS64",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "415-418",
          "snippet": "bool _AFfilehandle::readS64(int64_t *v)\n{\n\treturn readSwap(m_fh, v, m_formatByteOrder);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readS64(int64_t *v)\n  {\n  \treturn readSwap(m_fh, v, m_formatByteOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "readTag",
          "args": [
            "&chunkType"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "readTag",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.cpp",
          "lines": "473-482",
          "snippet": "bool _AFfilehandle::readTag(Tag *t)\n{\n\tuint32_t v;\n\tif (m_fh->read(&v, sizeof (v)) == sizeof (v))\n\t{\n\t\t*t = Tag(v);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"units.h\"",
            "#include \"Track.h\"",
            "#include \"Tag.h\"",
            "#include \"Setup.h\"",
            "#include \"Instrument.h\"",
            "#include \"File.h\"",
            "#include \"WAVE.h\"",
            "#include \"VOC.h\"",
            "#include \"SampleVision.h\"",
            "#include \"Raw.h\"",
            "#include \"NIST.h\"",
            "#include \"NeXT.h\"",
            "#include \"IRCAM.h\"",
            "#include \"IFF.h\"",
            "#include \"FLACFile.h\"",
            "#include \"CAF.h\"",
            "#include \"AVR.h\"",
            "#include \"AIFF.h\"",
            "#include <assert.h>",
            "#include <stdlib.h>",
            "#include \"byteorder.h\"",
            "#include \"audiofile.h\"",
            "#include \"afinternal.h\"",
            "#include \"FileHandle.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"units.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"Instrument.h\"\n#include \"File.h\"\n#include \"WAVE.h\"\n#include \"VOC.h\"\n#include \"SampleVision.h\"\n#include \"Raw.h\"\n#include \"NIST.h\"\n#include \"NeXT.h\"\n#include \"IRCAM.h\"\n#include \"IFF.h\"\n#include \"FLACFile.h\"\n#include \"CAF.h\"\n#include \"AVR.h\"\n#include \"AIFF.h\"\n#include <assert.h>\n#include <stdlib.h>\n#include \"byteorder.h\"\n#include \"audiofile.h\"\n#include \"afinternal.h\"\n#include \"FileHandle.h\"\n#include \"config.h\"\n\n_AFfilehandle {\n  bool _AFfilehandle::readTag(Tag *t)\n  {\n  \tuint32_t v;\n  \tif (m_fh->read(&v, sizeof (v)) == sizeof (v))\n  \t{\n  \t\t*t = Tag(v);\n  \t\treturn true;\n  \t}\n  \treturn false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->length",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "length",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "182-185",
          "snippet": "off_t FileVF::length()\n{\n\treturn m_vf->length(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::length()\n  {\n  \treturn m_vf->length(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_fh->tell",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "tell",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "194-197",
          "snippet": "off_t FileVF::tell()\n{\n\treturn m_vf->tell(m_vf);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::tell()\n  {\n  \treturn m_vf->tell(m_vf);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocateTrack",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  status CAFFile::readInit(AFfilesetup setup)\n  {\n  \tm_fh->seek(8, File::SeekFromBeginning);\n  \n  \tif (!allocateTrack())\n  \t\treturn AF_FAIL;\n  \n  \toff_t currentOffset = m_fh->tell();\n  \toff_t fileLength = m_fh->length();\n  \n  \twhile (currentOffset < fileLength)\n  \t{\n  \t\tTag chunkType;\n  \t\tint64_t chunkLength;\n  \t\tif (!readTag(&chunkType) ||\n  \t\t\t!readS64(&chunkLength))\n  \t\t\treturn AF_FAIL;\n  \n  \t\tcurrentOffset += 12;\n  \n  \t\tif (chunkType == \"data\" && chunkLength == -1)\n  \t\t\tchunkLength = fileLength - currentOffset;\n  \t\telse if (chunkLength < 0)\n  \t\t\t_af_error(AF_BAD_HEADER,\n  \t\t\t\t\"invalid chunk length %jd for chunk type %s\\n\",\n  \t\t\t\tstatic_cast<intmax_t>(chunkLength), chunkType.name().c_str());\n  \n  \t\tif (chunkType == \"desc\")\n  \t\t{\n  \t\t\tif (parseDescription(chunkType, chunkLength) == AF_FAIL)\n  \t\t\t\treturn AF_FAIL;\n  \t\t}\n  \t\telse if (chunkType == \"data\")\n  \t\t{\n  \t\t\tif (parseData(chunkType, chunkLength) == AF_FAIL)\n  \t\t\t\treturn AF_FAIL;\n  \t\t}\n  \t\telse if (chunkType == \"pakt\")\n  \t\t{\n  \t\t\tif (parsePacketTable(chunkType, chunkLength) == AF_FAIL)\n  \t\t\t\treturn AF_FAIL;\n  \t\t}\n  \t\telse if (chunkType == \"kuki\")\n  \t\t{\n  \t\t\tif (parseCookieData(chunkType, chunkLength) == AF_FAIL)\n  \t\t\t\treturn AF_FAIL;\n  \t\t}\n  \n  \t\tcurrentOffset = m_fh->seek(currentOffset + chunkLength,\n  \t\t\tFile::SeekFromBeginning);\n  \t}\n  \n  \treturn AF_SUCCEED;\n  }\n}"
  },
  {
    "function_name": "recognize",
    "container": "CAFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "88-98",
    "snippet": "bool CAFFile::recognize(File *file)\n{\n\tfile->seek(0, File::SeekFromBeginning);\n\tuint8_t buffer[8];\n\tif (file->read(buffer, 8) != 8 || memcmp(buffer, \"caff\", 4) != 0)\n\t\treturn false;\n\tconst uint8_t versionAndFlags[4] = { 0, 1, 0, 0 };\n\tif (memcmp(buffer + 4, versionAndFlags, 4) != 0)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer + 4",
            "versionAndFlags",
            "4"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "\"caff\"",
            "4"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->read",
          "args": [
            "buffer",
            "8"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "172-175",
          "snippet": "ssize_t FileVF::read(void *data, size_t nbytes)\n{\n\treturn m_vf->read(m_vf, data, nbytes);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  ssize_t FileVF::read(void *data, size_t nbytes)\n  {\n  \treturn m_vf->read(m_vf, data, nbytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->seek",
          "args": [
            "0",
            "File::SeekFromBeginning"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "seek",
          "container": "FileVF",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/File.cpp",
          "lines": "187-192",
          "snippet": "off_t FileVF::seek(off_t offset, SeekOrigin origin)\n{\n\tif (origin == SeekFromEnd)\n\t\toffset += length();\n\treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"af_vfs.h\"",
            "#include \"Compiler.h\"",
            "#include \"File.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"af_vfs.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"config.h\"\n\nFileVF {\n  off_t FileVF::seek(off_t offset, SeekOrigin origin)\n  {\n  \tif (origin == SeekFromEnd)\n  \t\toffset += length();\n  \treturn m_vf->seek(m_vf, offset, origin == SeekFromCurrent);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  bool CAFFile::recognize(File *file)\n  {\n  \tfile->seek(0, File::SeekFromBeginning);\n  \tuint8_t buffer[8];\n  \tif (file->read(buffer, 8) != 8 || memcmp(buffer, \"caff\", 4) != 0)\n  \t\treturn false;\n  \tconst uint8_t versionAndFlags[4] = { 0, 1, 0, 0 };\n  \tif (memcmp(buffer + 4, versionAndFlags, 4) != 0)\n  \t\treturn false;\n  \treturn true;\n  }\n}"
  },
  {
    "function_name": "~CAFFile",
    "container": "CAFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "84-86",
    "snippet": "CAFFile::~CAFFile()\n{\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  CAFFile::~CAFFile()\n  {\n  }\n}"
  },
  {
    "function_name": "CAFFile",
    "container": "CAFFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/CAF.cpp",
    "lines": "77-82",
    "snippet": "CAFFile::CAFFile() :\n\tm_dataOffset(-1),\n\tm_cookieDataOffset(-1)\n{\n\tsetFormatByteOrder(AF_BYTEORDER_BIGENDIAN);\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdint.h>",
      "#include \"util.h\"",
      "#include \"byteorder.h\"",
      "#include \"Track.h\"",
      "#include \"Tag.h\"",
      "#include \"Setup.h\"",
      "#include \"PacketTable.h\"",
      "#include \"File.h\"",
      "#include \"Buffer.h\"",
      "#include \"CAF.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setFormatByteOrder",
          "args": [
            "AF_BYTEORDER_BIGENDIAN"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "setFormatByteOrder",
          "container": "_AFfilehandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/FileHandle.h",
          "lines": "86-86",
          "snippet": "void setFormatByteOrder(int byteOrder) { m_formatByteOrder = byteOrder; }",
          "includes": [
            "#include <stdint.h>",
            "#include \"afinternal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include \"afinternal.h\"\n\n_AFfilehandle {\n  void setFormatByteOrder(int byteOrder) { m_formatByteOrder = byteOrder; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdint.h>\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"Track.h\"\n#include \"Tag.h\"\n#include \"Setup.h\"\n#include \"PacketTable.h\"\n#include \"File.h\"\n#include \"Buffer.h\"\n#include \"CAF.h\"\n#include \"config.h\"\n\nCAFFile {\n  CAFFile::CAFFile() :\n  \tm_dataOffset(-1),\n  \tm_cookieDataOffset(-1)\n  {\n  \tsetFormatByteOrder(AF_BYTEORDER_BIGENDIAN);\n  }\n}"
  }
]