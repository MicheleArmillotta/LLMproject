[
  {
    "function_name": "MainBuilder::MainImpl::wrapText",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "770-816",
    "snippet": "void MainBuilder::MainImpl::wrapText(Vector<char>& output, StringPtr indent, StringPtr text) {\n  uint width = 80 - indent.size();\n\n  while (text.size() > 0) {\n    output.addAll(indent);\n\n    KJ_IF_MAYBE(lineEnd, text.findFirst('\\n')) {\n      if (*lineEnd <= width) {\n        output.addAll(text.slice(0, *lineEnd + 1));\n        text = text.slice(*lineEnd + 1);\n        continue;\n      }\n    }\n\n    if (text.size() <= width) {\n      output.addAll(text);\n      output.add('\\n');\n      break;\n    }\n\n    uint wrapPos = width;\n    for (;; wrapPos--) {\n      if (wrapPos == 0) {\n        // Hmm, no good place to break words.  Just break in the middle.\n        wrapPos = width;\n        break;\n      } else if (text[wrapPos] == ' ' && text[wrapPos - 1] != ' ') {\n        // This position is a space and is preceded by a non-space.  Wrap here.\n        break;\n      }\n    }\n\n    output.addAll(text.slice(0, wrapPos));\n    output.add('\\n');\n\n    // Skip spaces after the text that was printed.\n    while (text[wrapPos] == ' ') {\n      ++wrapPos;\n    }\n    if (text[wrapPos] == '\\n') {\n      // Huh, apparently there were a whole bunch of spaces at the end of the line followed by a\n      // newline.  Skip the newline as well so we don't print a blank line.\n      ++wrapPos;\n    }\n    text = text.slice(wrapPos);\n  }\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "text.slice",
          "args": [
            "wrapPos"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "177-177",
          "snippet": "inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "output.add",
          "args": [
            "'\\n'"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "output.addAll",
          "args": [
            "text.slice(0, wrapPos)"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "addAll",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "357-359",
          "snippet": "void addAll(Container&& container) {\n    addAll(container.begin(), container.end());\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  void addAll(Container&& container) {\n      addAll(container.begin(), container.end());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.slice",
          "args": [
            "0",
            "wrapPos"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.size",
          "args": [],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "lineEnd",
            "text.findFirst('\\n')"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "text.findFirst",
          "args": [
            "'\\n'"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "findFirst",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "182-182",
          "snippet": "inline Maybe<size_t> findFirst(char c) const { return StringPtr(*this).findFirst(c); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline Maybe<size_t> findFirst(char c) const { return StringPtr(*this).findFirst(c); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid MainBuilder::MainImpl::wrapText(Vector<char>& output, StringPtr indent, StringPtr text) {\n  uint width = 80 - indent.size();\n\n  while (text.size() > 0) {\n    output.addAll(indent);\n\n    KJ_IF_MAYBE(lineEnd, text.findFirst('\\n')) {\n      if (*lineEnd <= width) {\n        output.addAll(text.slice(0, *lineEnd + 1));\n        text = text.slice(*lineEnd + 1);\n        continue;\n      }\n    }\n\n    if (text.size() <= width) {\n      output.addAll(text);\n      output.add('\\n');\n      break;\n    }\n\n    uint wrapPos = width;\n    for (;; wrapPos--) {\n      if (wrapPos == 0) {\n        // Hmm, no good place to break words.  Just break in the middle.\n        wrapPos = width;\n        break;\n      } else if (text[wrapPos] == ' ' && text[wrapPos - 1] != ' ') {\n        // This position is a space and is preceded by a non-space.  Wrap here.\n        break;\n      }\n    }\n\n    output.addAll(text.slice(0, wrapPos));\n    output.add('\\n');\n\n    // Skip spaces after the text that was printed.\n    while (text[wrapPos] == ' ') {\n      ++wrapPos;\n    }\n    if (text[wrapPos] == '\\n') {\n      // Huh, apparently there were a whole bunch of spaces at the end of the line followed by a\n      // newline.  Skip the newline as well so we don't print a blank line.\n      ++wrapPos;\n    }\n    text = text.slice(wrapPos);\n  }\n}"
  },
  {
    "function_name": "MainBuilder::MainImpl::printHelp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "679-768",
    "snippet": "void MainBuilder::MainImpl::printHelp(StringPtr programName) {\n  Vector<char> text(1024);\n\n  std::set<const Impl::Option*, Impl::OptionDisplayOrder> sortedOptions;\n\n  for (auto& entry: impl->shortOptions) {\n    sortedOptions.insert(entry.second);\n  }\n  for (auto& entry: impl->longOptions) {\n    sortedOptions.insert(entry.second);\n  }\n\n  text.addAll(str(\"Usage: \", programName, sortedOptions.empty() ? \"\" : \" [<option>...]\"));\n\n  if (impl->subCommands.empty()) {\n    for (auto& arg: impl->args) {\n      text.add(' ');\n      if (arg.minCount == 0) {\n        text.addAll(str(\"[\", arg.title, arg.maxCount > 1 ? \"...]\" : \"]\"));\n      } else {\n        text.addAll(str(arg.title, arg.maxCount > 1 ? \"...\" : \"\"));\n      }\n    }\n  } else {\n    text.addAll(StringPtr(\" <command> [<arg>...]\"));\n  }\n  text.addAll(StringPtr(\"\\n\\n\"));\n\n  wrapText(text, \"\", impl->briefDescription);\n\n  if (!impl->subCommands.empty()) {\n    text.addAll(StringPtr(\"\\nCommands:\\n\"));\n    size_t maxLen = 0;\n    for (auto& command: impl->subCommands) {\n      maxLen = kj::max(maxLen, command.first.size());\n    }\n    for (auto& command: impl->subCommands) {\n      text.addAll(StringPtr(\"  \"));\n      text.addAll(command.first);\n      for (size_t i = command.first.size(); i < maxLen; i++) {\n        text.add(' ');\n      }\n      text.addAll(StringPtr(\"  \"));\n      text.addAll(command.second.helpText);\n      text.add('\\n');\n    }\n    text.addAll(str(\n        \"\\nSee '\", programName, \" help <command>' for more information on a specific command.\\n\"));\n  }\n\n  if (!sortedOptions.empty()) {\n    text.addAll(StringPtr(\"\\nOptions:\\n\"));\n\n    for (auto opt: sortedOptions) {\n      text.addAll(StringPtr(\"    \"));\n      bool isFirst = true;\n      for (auto& name: opt->names) {\n        if (isFirst) {\n          isFirst = false;\n        } else {\n          text.addAll(StringPtr(\", \"));\n        }\n        if (name.isLong) {\n          text.addAll(str(\"--\", name.longName));\n          if (opt->hasArg) {\n            text.addAll(str(\"=\", opt->argTitle));\n          }\n        } else {\n          text.addAll(str(\"-\", name.shortName));\n          if (opt->hasArg) {\n            text.addAll(opt->argTitle);\n          }\n        }\n      }\n      text.add('\\n');\n      wrapText(text, \"        \", opt->helpText);\n    }\n\n    text.addAll(StringPtr(\"    --help\\n        Display this help text and exit.\\n\"));\n  }\n\n  if (impl->extendedDescription.size() > 0) {\n    text.add('\\n');\n    wrapText(text, \"\", impl->extendedDescription);\n  }\n\n  text.add('\\0');\n  impl->context.exitInfo(String(text.releaseAsArray()));\n  KJ_CLANG_KNOWS_THIS_IS_UNREACHABLE_BUT_GCC_DOESNT\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "impl->context.exitInfo",
          "args": [
            "String(text.releaseAsArray())"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String",
          "args": [
            "text.releaseAsArray()"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "branchCount",
          "container": "StringTree",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string-tree.h",
          "lines": "98-98",
          "snippet": "static inline size_t branchCount(StringTree&& s) { return 1; }",
          "includes": [
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n\nStringTree {\n  static inline size_t branchCount(StringTree&& s) { return 1; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.releaseAsArray",
          "args": [],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "releaseAsArray",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "66-72",
          "snippet": "inline Array<T> releaseAsArray() {\n    // TODO(perf):  Avoid a copy/move by allowing Array<T> to point to incomplete space?\n    if (!builder.isFull()) {\n      setCapacity(size());\n    }\n    return builder.finish();\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline Array<T> releaseAsArray() {\n      // TODO(perf):  Avoid a copy/move by allowing Array<T> to point to incomplete space?\n      if (!builder.isFull()) {\n        setCapacity(size());\n      }\n      return builder.finish();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.add",
          "args": [
            "'\\0'"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "wrapText",
          "args": [
            "text",
            "\"\"",
            "impl->extendedDescription"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "MainBuilder::MainImpl::wrapText",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
          "lines": "770-816",
          "snippet": "void MainBuilder::MainImpl::wrapText(Vector<char>& output, StringPtr indent, StringPtr text) {\n  uint width = 80 - indent.size();\n\n  while (text.size() > 0) {\n    output.addAll(indent);\n\n    KJ_IF_MAYBE(lineEnd, text.findFirst('\\n')) {\n      if (*lineEnd <= width) {\n        output.addAll(text.slice(0, *lineEnd + 1));\n        text = text.slice(*lineEnd + 1);\n        continue;\n      }\n    }\n\n    if (text.size() <= width) {\n      output.addAll(text);\n      output.add('\\n');\n      break;\n    }\n\n    uint wrapPos = width;\n    for (;; wrapPos--) {\n      if (wrapPos == 0) {\n        // Hmm, no good place to break words.  Just break in the middle.\n        wrapPos = width;\n        break;\n      } else if (text[wrapPos] == ' ' && text[wrapPos - 1] != ' ') {\n        // This position is a space and is preceded by a non-space.  Wrap here.\n        break;\n      }\n    }\n\n    output.addAll(text.slice(0, wrapPos));\n    output.add('\\n');\n\n    // Skip spaces after the text that was printed.\n    while (text[wrapPos] == ' ') {\n      ++wrapPos;\n    }\n    if (text[wrapPos] == '\\n') {\n      // Huh, apparently there were a whole bunch of spaces at the end of the line followed by a\n      // newline.  Skip the newline as well so we don't print a blank line.\n      ++wrapPos;\n    }\n    text = text.slice(wrapPos);\n  }\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <windows.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <set>",
            "#include <map>",
            "#include \"arena.h\"",
            "#include \"debug.h\"",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid MainBuilder::MainImpl::wrapText(Vector<char>& output, StringPtr indent, StringPtr text) {\n  uint width = 80 - indent.size();\n\n  while (text.size() > 0) {\n    output.addAll(indent);\n\n    KJ_IF_MAYBE(lineEnd, text.findFirst('\\n')) {\n      if (*lineEnd <= width) {\n        output.addAll(text.slice(0, *lineEnd + 1));\n        text = text.slice(*lineEnd + 1);\n        continue;\n      }\n    }\n\n    if (text.size() <= width) {\n      output.addAll(text);\n      output.add('\\n');\n      break;\n    }\n\n    uint wrapPos = width;\n    for (;; wrapPos--) {\n      if (wrapPos == 0) {\n        // Hmm, no good place to break words.  Just break in the middle.\n        wrapPos = width;\n        break;\n      } else if (text[wrapPos] == ' ' && text[wrapPos - 1] != ' ') {\n        // This position is a space and is preceded by a non-space.  Wrap here.\n        break;\n      }\n    }\n\n    output.addAll(text.slice(0, wrapPos));\n    output.add('\\n');\n\n    // Skip spaces after the text that was printed.\n    while (text[wrapPos] == ' ') {\n      ++wrapPos;\n    }\n    if (text[wrapPos] == '\\n') {\n      // Huh, apparently there were a whole bunch of spaces at the end of the line followed by a\n      // newline.  Skip the newline as well so we don't print a blank line.\n      ++wrapPos;\n    }\n    text = text.slice(wrapPos);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "impl->extendedDescription.size",
          "args": [],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.addAll",
          "args": [
            "StringPtr(\"    --help\\n        Display this help text and exit.\\n\")"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "addAll",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "357-359",
          "snippet": "void addAll(Container&& container) {\n    addAll(container.begin(), container.end());\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  void addAll(Container&& container) {\n      addAll(container.begin(), container.end());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "StringPtr",
          "args": [
            "\"    --help\\n        Display this help text and exit.\\n\""
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "StringPtr",
          "container": "StringPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "116-116",
          "snippet": "inline StringPtr(ArrayPtr<const char> content): content(content) {}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(ArrayPtr<const char> content): content(content) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"-\"",
            "name.shortName"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"=\"",
            "opt->argTitle"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"--\"",
            "name.longName"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sortedOptions.empty",
          "args": [],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "53-53",
          "snippet": "inline bool empty() const { return size() == 0; }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline bool empty() const { return size() == 0; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"\\nSee '\"",
            "programName",
            "\" help <command>' for more information on a specific command.\\n\""
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::max",
          "args": [
            "maxLen",
            "command.first.size()"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "486-488",
          "snippet": "auto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "arg.title",
            "arg.maxCount > 1 ? \"...\" : \"\""
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"[\"",
            "arg.title",
            "arg.maxCount > 1 ? \"...]\" : \"]\""
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"Usage: \"",
            "programName",
            "sortedOptions.empty() ? \"\" : \" [<option>...]\""
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sortedOptions.insert",
          "args": [
            "entry.second"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sortedOptions.insert",
          "args": [
            "entry.second"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid MainBuilder::MainImpl::printHelp(StringPtr programName) {\n  Vector<char> text(1024);\n\n  std::set<const Impl::Option*, Impl::OptionDisplayOrder> sortedOptions;\n\n  for (auto& entry: impl->shortOptions) {\n    sortedOptions.insert(entry.second);\n  }\n  for (auto& entry: impl->longOptions) {\n    sortedOptions.insert(entry.second);\n  }\n\n  text.addAll(str(\"Usage: \", programName, sortedOptions.empty() ? \"\" : \" [<option>...]\"));\n\n  if (impl->subCommands.empty()) {\n    for (auto& arg: impl->args) {\n      text.add(' ');\n      if (arg.minCount == 0) {\n        text.addAll(str(\"[\", arg.title, arg.maxCount > 1 ? \"...]\" : \"]\"));\n      } else {\n        text.addAll(str(arg.title, arg.maxCount > 1 ? \"...\" : \"\"));\n      }\n    }\n  } else {\n    text.addAll(StringPtr(\" <command> [<arg>...]\"));\n  }\n  text.addAll(StringPtr(\"\\n\\n\"));\n\n  wrapText(text, \"\", impl->briefDescription);\n\n  if (!impl->subCommands.empty()) {\n    text.addAll(StringPtr(\"\\nCommands:\\n\"));\n    size_t maxLen = 0;\n    for (auto& command: impl->subCommands) {\n      maxLen = kj::max(maxLen, command.first.size());\n    }\n    for (auto& command: impl->subCommands) {\n      text.addAll(StringPtr(\"  \"));\n      text.addAll(command.first);\n      for (size_t i = command.first.size(); i < maxLen; i++) {\n        text.add(' ');\n      }\n      text.addAll(StringPtr(\"  \"));\n      text.addAll(command.second.helpText);\n      text.add('\\n');\n    }\n    text.addAll(str(\n        \"\\nSee '\", programName, \" help <command>' for more information on a specific command.\\n\"));\n  }\n\n  if (!sortedOptions.empty()) {\n    text.addAll(StringPtr(\"\\nOptions:\\n\"));\n\n    for (auto opt: sortedOptions) {\n      text.addAll(StringPtr(\"    \"));\n      bool isFirst = true;\n      for (auto& name: opt->names) {\n        if (isFirst) {\n          isFirst = false;\n        } else {\n          text.addAll(StringPtr(\", \"));\n        }\n        if (name.isLong) {\n          text.addAll(str(\"--\", name.longName));\n          if (opt->hasArg) {\n            text.addAll(str(\"=\", opt->argTitle));\n          }\n        } else {\n          text.addAll(str(\"-\", name.shortName));\n          if (opt->hasArg) {\n            text.addAll(opt->argTitle);\n          }\n        }\n      }\n      text.add('\\n');\n      wrapText(text, \"        \", opt->helpText);\n    }\n\n    text.addAll(StringPtr(\"    --help\\n        Display this help text and exit.\\n\"));\n  }\n\n  if (impl->extendedDescription.size() > 0) {\n    text.add('\\n');\n    wrapText(text, \"\", impl->extendedDescription);\n  }\n\n  text.add('\\0');\n  impl->context.exitInfo(String(text.releaseAsArray()));\n  KJ_CLANG_KNOWS_THIS_IS_UNREACHABLE_BUT_GCC_DOESNT\n}"
  },
  {
    "function_name": "MainBuilder::MainImpl::usageError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "620-625",
    "snippet": "void MainBuilder::MainImpl::usageError(StringPtr programName, StringPtr message) {\n  impl->context.exitError(kj::str(\n      programName, \": \", message,\n      \"\\nTry '\", programName, \" --help' for more information.\"));\n  KJ_CLANG_KNOWS_THIS_IS_UNREACHABLE_BUT_GCC_DOESNT\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "impl->context.exitError",
          "args": [
            "kj::str(\n      programName, \": \", message,\n      \"\\nTry '\", programName, \" --help' for more information.\")"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "programName",
            "\": \"",
            "message",
            "\"\\nTry '\"",
            "programName",
            "\" --help' for more information.\""
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid MainBuilder::MainImpl::usageError(StringPtr programName, StringPtr message) {\n  impl->context.exitError(kj::str(\n      programName, \": \", message,\n      \"\\nTry '\", programName, \" --help' for more information.\"));\n  KJ_CLANG_KNOWS_THIS_IS_UNREACHABLE_BUT_GCC_DOESNT\n}"
  },
  {
    "function_name": "MainBuilder::MainImpl::operator()",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "414-470",
    "snippet": "void MainBuilder::MainImpl::operator()(StringPtr programName, ArrayPtr<const StringPtr> params) {\n  Vector<StringPtr> arguments;\n\n  for (size_t i = 0; i < params.size(); i++) {\n    StringPtr param = params[i];\n    if (param == \"--\") {\n      // \"--\" ends option parsing.\n      arguments.addAll(params.begin() + i + 1, params.end());\n      break;\n    } else if (param.startsWith(\"--\")) {\n      // Long option.\n      ArrayPtr<const char> name;\n      Maybe<StringPtr> maybeArg;\n      KJ_IF_MAYBE(pos, param.findFirst('=')) {\n        name = param.slice(2, *pos);\n        maybeArg = param.slice(*pos + 1);\n      } else {\n        name = param.slice(2);\n      }\n      auto iter = impl->longOptions.find(name);\n      if (iter == impl->longOptions.end()) {\n        if (param == \"--help\") {\n          printHelp(programName);\n        } else {\n          usageError(programName, str(\"--\", name, \": unrecognized option\"));\n        }\n      } else {\n        const Impl::Option& option = *iter->second;\n        if (option.hasArg) {\n          // Argument expected.\n          KJ_IF_MAYBE(arg, maybeArg) {\n            // \"--foo=blah\": \"blah\" is the argument.\n            KJ_IF_MAYBE(error, (*option.funcWithArg)(*arg).releaseError()) {\n              usageError(programName, str(param, \": \", *error));\n            }\n          } else if (i + 1 < params.size() &&\n                     !(params[i + 1].startsWith(\"-\") && params[i + 1].size() > 1)) {\n            // \"--foo blah\": \"blah\" is the argument.\n            ++i;\n            KJ_IF_MAYBE(error, (*option.funcWithArg)(params[i]).releaseError()) {\n              usageError(programName, str(param, \"=\", params[i], \": \", *error));\n            }\n          } else {\n            usageError(programName, str(\"--\", name, \": missing argument\"));\n          }\n        } else {\n          // No argument expected.\n          if (maybeArg == nullptr) {\n            KJ_IF_MAYBE(error, (*option.func)().releaseError()) {\n              usageError(programName, str(param, \": \", *error));\n            }\n          } else {\n            usageError(programName, str(\"--\", name, \": option does not accept an argument\"));\n          }\n        }\n      }\n    }",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usageError",
          "args": [
            "programName",
            "str(\"--\", name, \": option does not accept an argument\")"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "MainBuilder::MainImpl::usageError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
          "lines": "620-625",
          "snippet": "void MainBuilder::MainImpl::usageError(StringPtr programName, StringPtr message) {\n  impl->context.exitError(kj::str(\n      programName, \": \", message,\n      \"\\nTry '\", programName, \" --help' for more information.\"));\n  KJ_CLANG_KNOWS_THIS_IS_UNREACHABLE_BUT_GCC_DOESNT\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <windows.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <set>",
            "#include <map>",
            "#include \"arena.h\"",
            "#include \"debug.h\"",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid MainBuilder::MainImpl::usageError(StringPtr programName, StringPtr message) {\n  impl->context.exitError(kj::str(\n      programName, \": \", message,\n      \"\\nTry '\", programName, \" --help' for more information.\"));\n  KJ_CLANG_KNOWS_THIS_IS_UNREACHABLE_BUT_GCC_DOESNT\n}"
        }
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"--\"",
            "name",
            "\": option does not accept an argument\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "param",
            "\": \"",
            "*error"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "error",
            "(*option.func)().releaseError()"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if",
          "args": [
            "maybeArg == nullptr"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "if",
          "container": "RpcPipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1516-1518",
          "snippet": "else if (state.is<Resolved>()) {\n        return state.get<Resolved>()->getResults().getPipelinedCap(ops);\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcPipeline {\n  else if (state.is<Resolved>()) {\n          return state.get<Resolved>()->getResults().getPipelinedCap(ops);\n        }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"--\"",
            "name",
            "\": missing argument\""
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "param",
            "\"=\"",
            "params[i]",
            "\": \"",
            "*error"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "params[i]"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[i + 1].size",
          "args": [],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "params[i + 1].startsWith",
          "args": [
            "\"-\""
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "startsWith",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "174-174",
          "snippet": "inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "param",
            "\": \"",
            "*error"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "*arg"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"--\"",
            "name",
            "\": unrecognized option\""
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printHelp",
          "args": [
            "programName"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "MainBuilder::MainImpl::printHelp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
          "lines": "679-768",
          "snippet": "void MainBuilder::MainImpl::printHelp(StringPtr programName) {\n  Vector<char> text(1024);\n\n  std::set<const Impl::Option*, Impl::OptionDisplayOrder> sortedOptions;\n\n  for (auto& entry: impl->shortOptions) {\n    sortedOptions.insert(entry.second);\n  }\n  for (auto& entry: impl->longOptions) {\n    sortedOptions.insert(entry.second);\n  }\n\n  text.addAll(str(\"Usage: \", programName, sortedOptions.empty() ? \"\" : \" [<option>...]\"));\n\n  if (impl->subCommands.empty()) {\n    for (auto& arg: impl->args) {\n      text.add(' ');\n      if (arg.minCount == 0) {\n        text.addAll(str(\"[\", arg.title, arg.maxCount > 1 ? \"...]\" : \"]\"));\n      } else {\n        text.addAll(str(arg.title, arg.maxCount > 1 ? \"...\" : \"\"));\n      }\n    }\n  } else {\n    text.addAll(StringPtr(\" <command> [<arg>...]\"));\n  }\n  text.addAll(StringPtr(\"\\n\\n\"));\n\n  wrapText(text, \"\", impl->briefDescription);\n\n  if (!impl->subCommands.empty()) {\n    text.addAll(StringPtr(\"\\nCommands:\\n\"));\n    size_t maxLen = 0;\n    for (auto& command: impl->subCommands) {\n      maxLen = kj::max(maxLen, command.first.size());\n    }\n    for (auto& command: impl->subCommands) {\n      text.addAll(StringPtr(\"  \"));\n      text.addAll(command.first);\n      for (size_t i = command.first.size(); i < maxLen; i++) {\n        text.add(' ');\n      }\n      text.addAll(StringPtr(\"  \"));\n      text.addAll(command.second.helpText);\n      text.add('\\n');\n    }\n    text.addAll(str(\n        \"\\nSee '\", programName, \" help <command>' for more information on a specific command.\\n\"));\n  }\n\n  if (!sortedOptions.empty()) {\n    text.addAll(StringPtr(\"\\nOptions:\\n\"));\n\n    for (auto opt: sortedOptions) {\n      text.addAll(StringPtr(\"    \"));\n      bool isFirst = true;\n      for (auto& name: opt->names) {\n        if (isFirst) {\n          isFirst = false;\n        } else {\n          text.addAll(StringPtr(\", \"));\n        }\n        if (name.isLong) {\n          text.addAll(str(\"--\", name.longName));\n          if (opt->hasArg) {\n            text.addAll(str(\"=\", opt->argTitle));\n          }\n        } else {\n          text.addAll(str(\"-\", name.shortName));\n          if (opt->hasArg) {\n            text.addAll(opt->argTitle);\n          }\n        }\n      }\n      text.add('\\n');\n      wrapText(text, \"        \", opt->helpText);\n    }\n\n    text.addAll(StringPtr(\"    --help\\n        Display this help text and exit.\\n\"));\n  }\n\n  if (impl->extendedDescription.size() > 0) {\n    text.add('\\n');\n    wrapText(text, \"\", impl->extendedDescription);\n  }\n\n  text.add('\\0');\n  impl->context.exitInfo(String(text.releaseAsArray()));\n  KJ_CLANG_KNOWS_THIS_IS_UNREACHABLE_BUT_GCC_DOESNT\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <windows.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <set>",
            "#include <map>",
            "#include \"arena.h\"",
            "#include \"debug.h\"",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid MainBuilder::MainImpl::printHelp(StringPtr programName) {\n  Vector<char> text(1024);\n\n  std::set<const Impl::Option*, Impl::OptionDisplayOrder> sortedOptions;\n\n  for (auto& entry: impl->shortOptions) {\n    sortedOptions.insert(entry.second);\n  }\n  for (auto& entry: impl->longOptions) {\n    sortedOptions.insert(entry.second);\n  }\n\n  text.addAll(str(\"Usage: \", programName, sortedOptions.empty() ? \"\" : \" [<option>...]\"));\n\n  if (impl->subCommands.empty()) {\n    for (auto& arg: impl->args) {\n      text.add(' ');\n      if (arg.minCount == 0) {\n        text.addAll(str(\"[\", arg.title, arg.maxCount > 1 ? \"...]\" : \"]\"));\n      } else {\n        text.addAll(str(arg.title, arg.maxCount > 1 ? \"...\" : \"\"));\n      }\n    }\n  } else {\n    text.addAll(StringPtr(\" <command> [<arg>...]\"));\n  }\n  text.addAll(StringPtr(\"\\n\\n\"));\n\n  wrapText(text, \"\", impl->briefDescription);\n\n  if (!impl->subCommands.empty()) {\n    text.addAll(StringPtr(\"\\nCommands:\\n\"));\n    size_t maxLen = 0;\n    for (auto& command: impl->subCommands) {\n      maxLen = kj::max(maxLen, command.first.size());\n    }\n    for (auto& command: impl->subCommands) {\n      text.addAll(StringPtr(\"  \"));\n      text.addAll(command.first);\n      for (size_t i = command.first.size(); i < maxLen; i++) {\n        text.add(' ');\n      }\n      text.addAll(StringPtr(\"  \"));\n      text.addAll(command.second.helpText);\n      text.add('\\n');\n    }\n    text.addAll(str(\n        \"\\nSee '\", programName, \" help <command>' for more information on a specific command.\\n\"));\n  }\n\n  if (!sortedOptions.empty()) {\n    text.addAll(StringPtr(\"\\nOptions:\\n\"));\n\n    for (auto opt: sortedOptions) {\n      text.addAll(StringPtr(\"    \"));\n      bool isFirst = true;\n      for (auto& name: opt->names) {\n        if (isFirst) {\n          isFirst = false;\n        } else {\n          text.addAll(StringPtr(\", \"));\n        }\n        if (name.isLong) {\n          text.addAll(str(\"--\", name.longName));\n          if (opt->hasArg) {\n            text.addAll(str(\"=\", opt->argTitle));\n          }\n        } else {\n          text.addAll(str(\"-\", name.shortName));\n          if (opt->hasArg) {\n            text.addAll(opt->argTitle);\n          }\n        }\n      }\n      text.add('\\n');\n      wrapText(text, \"        \", opt->helpText);\n    }\n\n    text.addAll(StringPtr(\"    --help\\n        Display this help text and exit.\\n\"));\n  }\n\n  if (impl->extendedDescription.size() > 0) {\n    text.add('\\n');\n    wrapText(text, \"\", impl->extendedDescription);\n  }\n\n  text.add('\\0');\n  impl->context.exitInfo(String(text.releaseAsArray()));\n  KJ_CLANG_KNOWS_THIS_IS_UNREACHABLE_BUT_GCC_DOESNT\n}"
        }
      },
      {
        "call_info": {
          "callee": "impl->longOptions.end",
          "args": [],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "693-693",
          "snippet": "inline Iterator end() const { return Iterator(value, count); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator end() const { return Iterator(value, count); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "impl->longOptions.find",
          "args": [
            "name"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "191-202",
          "snippet": "kj::Maybe<T&> find(Id id) {\n    if (id < kj::size(low)) {\n      return low[id];\n    } else {\n      auto iter = high.find(id);\n      if (iter == high.end()) {\n        return nullptr;\n      } else {\n        return iter->second;\n      }\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  kj::Maybe<T&> find(Id id) {\n      if (id < kj::size(low)) {\n        return low[id];\n      } else {\n        auto iter = high.find(id);\n        if (iter == high.end()) {\n          return nullptr;\n        } else {\n          return iter->second;\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "param.slice",
          "args": [
            "2"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "177-177",
          "snippet": "inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "param.slice",
          "args": [
            "2",
            "*pos"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "param.findFirst",
          "args": [
            "'='"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "findFirst",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "182-182",
          "snippet": "inline Maybe<size_t> findFirst(char c) const { return StringPtr(*this).findFirst(c); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline Maybe<size_t> findFirst(char c) const { return StringPtr(*this).findFirst(c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arguments.addAll",
          "args": [
            "params.begin() + i + 1",
            "params.end()"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "addAll",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "81-85",
          "snippet": "inline void addAll(Iterator begin, Iterator end) {\n    size_t needed = builder.size() + (end - begin);\n    if (needed > builder.capacity()) grow(needed);\n    builder.addAll(begin, end);\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline void addAll(Iterator begin, Iterator end) {\n      size_t needed = builder.size() + (end - begin);\n      if (needed > builder.capacity()) grow(needed);\n      builder.addAll(begin, end);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.begin",
          "args": [],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid MainBuilder::MainImpl::operator()(StringPtr programName, ArrayPtr<const StringPtr> params) {\n  Vector<StringPtr> arguments;\n\n  for (size_t i = 0; i < params.size(); i++) {\n    StringPtr param = params[i];\n    if (param == \"--\") {\n      // \"--\" ends option parsing.\n      arguments.addAll(params.begin() + i + 1, params.end());\n      break;\n    } else if (param.startsWith(\"--\")) {\n      // Long option.\n      ArrayPtr<const char> name;\n      Maybe<StringPtr> maybeArg;\n      KJ_IF_MAYBE(pos, param.findFirst('=')) {\n        name = param.slice(2, *pos);\n        maybeArg = param.slice(*pos + 1);\n      } else {\n        name = param.slice(2);\n      }\n      auto iter = impl->longOptions.find(name);\n      if (iter == impl->longOptions.end()) {\n        if (param == \"--help\") {\n          printHelp(programName);\n        } else {\n          usageError(programName, str(\"--\", name, \": unrecognized option\"));\n        }\n      } else {\n        const Impl::Option& option = *iter->second;\n        if (option.hasArg) {\n          // Argument expected.\n          KJ_IF_MAYBE(arg, maybeArg) {\n            // \"--foo=blah\": \"blah\" is the argument.\n            KJ_IF_MAYBE(error, (*option.funcWithArg)(*arg).releaseError()) {\n              usageError(programName, str(param, \": \", *error));\n            }\n          } else if (i + 1 < params.size() &&\n                     !(params[i + 1].startsWith(\"-\") && params[i + 1].size() > 1)) {\n            // \"--foo blah\": \"blah\" is the argument.\n            ++i;\n            KJ_IF_MAYBE(error, (*option.funcWithArg)(params[i]).releaseError()) {\n              usageError(programName, str(param, \"=\", params[i], \": \", *error));\n            }\n          } else {\n            usageError(programName, str(\"--\", name, \": missing argument\"));\n          }\n        } else {\n          // No argument expected.\n          if (maybeArg == nullptr) {\n            KJ_IF_MAYBE(error, (*option.func)().releaseError()) {\n              usageError(programName, str(param, \": \", *error));\n            }\n          } else {\n            usageError(programName, str(\"--\", name, \": option does not accept an argument\"));\n          }\n        }\n      }\n    }"
  },
  {
    "function_name": "MainBuilder::build",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "410-412",
    "snippet": "MainFunc MainBuilder::build() {\n  return MainImpl(kj::mv(impl));\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MainImpl",
          "args": [
            "kj::mv(impl)"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "MainImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
          "lines": "398-398",
          "snippet": "MainImpl(Own<Impl>&& impl): impl(kj::mv(impl)) {}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <windows.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <set>",
            "#include <map>",
            "#include \"arena.h\"",
            "#include \"debug.h\"",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nMainImpl(Own<Impl>&& impl): impl(kj::mv(impl)) {}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "impl"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nMainFunc MainBuilder::build() {\n  return MainImpl(kj::mv(impl));\n}"
  },
  {
    "function_name": "MainImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "398-398",
    "snippet": "MainImpl(Own<Impl>&& impl): impl(kj::mv(impl)) {}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "impl"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nMainImpl(Own<Impl>&& impl): impl(kj::mv(impl)) {}"
  },
  {
    "function_name": "MainBuilder::~MainBuilder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "335-335",
    "snippet": "MainBuilder::~MainBuilder() noexcept(false) {}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nMainBuilder::~MainBuilder() noexcept(false) {}"
  },
  {
    "function_name": "MainBuilder::MainBuilder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "326-333",
    "snippet": "MainBuilder::MainBuilder(ProcessContext& context, StringPtr version,\n                         StringPtr briefDescription, StringPtr extendedDescription)\n    : impl(heap<Impl>(context, version, briefDescription, extendedDescription)) {\n  addOption({\"verbose\"}, KJ_BIND_METHOD(*impl, increaseVerbosity),\n            \"Log informational messages to stderr; useful for debugging.\");\n  addOption({\"version\"}, KJ_BIND_METHOD(*impl, printVersion),\n            \"Print version information and exit.\");\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addOption",
          "args": [
            "{\"version\"}",
            "KJ_BIND_METHOD(*impl, printVersion)",
            "\"Print version information and exit.\""
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*impl",
            "printVersion"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addOption",
          "args": [
            "{\"verbose\"}",
            "KJ_BIND_METHOD(*impl, increaseVerbosity)",
            "\"Log informational messages to stderr; useful for debugging.\""
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*impl",
            "increaseVerbosity"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap<Impl>",
          "args": [
            "context",
            "version",
            "briefDescription",
            "extendedDescription"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nMainBuilder::MainBuilder(ProcessContext& context, StringPtr version,\n                         StringPtr briefDescription, StringPtr extendedDescription)\n    : impl(heap<Impl>(context, version, briefDescription, extendedDescription)) {\n  addOption({\"verbose\"}, KJ_BIND_METHOD(*impl, increaseVerbosity),\n            \"Log informational messages to stderr; useful for debugging.\");\n  addOption({\"version\"}, KJ_BIND_METHOD(*impl, printVersion),\n            \"Print version information and exit.\");\n}"
  },
  {
    "function_name": "increaseVerbosity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "320-323",
    "snippet": "Validity increaseVerbosity() {\n    context.increaseLoggingVerbosity();\n    return true;\n  }",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.increaseLoggingVerbosity",
          "args": [],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nValidity increaseVerbosity() {\n    context.increaseLoggingVerbosity();\n    return true;\n  }"
  },
  {
    "function_name": "printVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "315-318",
    "snippet": "Validity printVersion() {\n    context.exitInfo(version);\n    return true;\n  }",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.exitInfo",
          "args": [
            "version"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nValidity printVersion() {\n    context.exitInfo(version);\n    return true;\n  }"
  },
  {
    "function_name": "Impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "236-239",
    "snippet": "inline Impl(ProcessContext& context, StringPtr version,\n              StringPtr briefDescription, StringPtr extendedDescription)\n      : context(context), version(version),\n        briefDescription(briefDescription), extendedDescription(extendedDescription) {}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\ninline Impl(ProcessContext& context, StringPtr version,\n              StringPtr briefDescription, StringPtr extendedDescription)\n      : context(context), version(version),\n        briefDescription(briefDescription), extendedDescription(extendedDescription) {}"
  },
  {
    "function_name": "runMainAndExit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "204-231",
    "snippet": "int runMainAndExit(ProcessContext& context, MainFunc&& func, int argc, char* argv[]) {\n  setStandardIoMode(STDIN_FILENO);\n  setStandardIoMode(STDOUT_FILENO);\n  setStandardIoMode(STDERR_FILENO);\n\n#if !KJ_NO_EXCEPTIONS\n  try {\n#endif\n    KJ_ASSERT(argc > 0);\n\n    KJ_STACK_ARRAY(StringPtr, params, argc - 1, 8, 32);\n    for (int i = 1; i < argc; i++) {\n      params[i - 1] = argv[i];\n    }\n\n    KJ_IF_MAYBE(exception, runCatchingExceptions([&]() {\n      func(argv[0], params);\n    })) {\n      context.error(str(\"*** Uncaught exception ***\\n\", *exception));\n    }\n    context.exit();\n#if !KJ_NO_EXCEPTIONS\n  } catch (const TopLevelProcessContext::CleanShutdownException& e) {\n    return e.exitCode;\n  }\n#endif\n  KJ_CLANG_KNOWS_THIS_IS_UNREACHABLE_BUT_GCC_DOESNT\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.exit",
          "args": [],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.error",
          "args": [
            "str(\"*** Uncaught exception ***\\n\", *exception)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"*** Uncaught exception ***\\n\"",
            "*exception"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exception",
            "runCatchingExceptions([&]() {\n      func(argv[0], params);\n    })"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "runCatchingExceptions",
          "args": [
            "[&]() {\n      func(argv[0], params);\n    }"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "argv[0]",
            "params"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_STACK_ARRAY",
          "args": [
            "StringPtr",
            "params",
            "argc - 1",
            "8",
            "32"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "argc > 0"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setStandardIoMode",
          "args": [
            "STDERR_FILENO"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "setStandardIoMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
          "lines": "79-79",
          "snippet": "void setStandardIoMode(int fd) {}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <windows.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <set>",
            "#include <map>",
            "#include \"arena.h\"",
            "#include \"debug.h\"",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid setStandardIoMode(int fd) {}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nint runMainAndExit(ProcessContext& context, MainFunc&& func, int argc, char* argv[]) {\n  setStandardIoMode(STDIN_FILENO);\n  setStandardIoMode(STDOUT_FILENO);\n  setStandardIoMode(STDERR_FILENO);\n\n#if !KJ_NO_EXCEPTIONS\n  try {\n#endif\n    KJ_ASSERT(argc > 0);\n\n    KJ_STACK_ARRAY(StringPtr, params, argc - 1, 8, 32);\n    for (int i = 1; i < argc; i++) {\n      params[i - 1] = argv[i];\n    }\n\n    KJ_IF_MAYBE(exception, runCatchingExceptions([&]() {\n      func(argv[0], params);\n    })) {\n      context.error(str(\"*** Uncaught exception ***\\n\", *exception));\n    }\n    context.exit();\n#if !KJ_NO_EXCEPTIONS\n  } catch (const TopLevelProcessContext::CleanShutdownException& e) {\n    return e.exitCode;\n  }\n#endif\n  KJ_CLANG_KNOWS_THIS_IS_UNREACHABLE_BUT_GCC_DOESNT\n}"
  },
  {
    "function_name": "TopLevelProcessContext::increaseLoggingVerbosity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "197-200",
    "snippet": "void TopLevelProcessContext::increaseLoggingVerbosity() {\n  // At the moment, there is only one log level that isn't enabled by default.\n  _::Debug::setLogLevel(_::Debug::Severity::INFO);\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_::Debug::setLogLevel",
          "args": [
            "_::Debug::Severity::INFO"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "setLogLevel",
          "container": "Debug",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.h",
          "lines": "281-281",
          "snippet": "static inline void setLogLevel(LogSeverity severity) { minSeverity = severity; }",
          "includes": [
            "#include \"exception.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exception.h\"\n#include \"string.h\"\n\nDebug {\n  static inline void setLogLevel(LogSeverity severity) { minSeverity = severity; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid TopLevelProcessContext::increaseLoggingVerbosity() {\n  // At the moment, there is only one log level that isn't enabled by default.\n  _::Debug::setLogLevel(_::Debug::Severity::INFO);\n}"
  },
  {
    "function_name": "TopLevelProcessContext::exitInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "192-195",
    "snippet": "void TopLevelProcessContext::exitInfo(StringPtr message) {\n  writeLineToFd(STDOUT_FILENO, message);\n  exit();\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "TopLevelProcessContext::exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
          "lines": "52-65",
          "snippet": "void TopLevelProcessContext::exit() {\n  int exitCode = hadErrors ? 1 : 0;\n  if (cleanShutdown) {\n#if KJ_NO_EXCEPTIONS\n    // This is the best we can do.\n    warning(\"warning: KJ_CLEAN_SHUTDOWN may not work correctly when compiled \"\n            \"with -fno-exceptions.\");\n    ::exit(exitCode);\n#else\n    throw CleanShutdownException { exitCode };\n#endif\n  }\n  _exit(exitCode);\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <windows.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <set>",
            "#include <map>",
            "#include \"arena.h\"",
            "#include \"debug.h\"",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid TopLevelProcessContext::exit() {\n  int exitCode = hadErrors ? 1 : 0;\n  if (cleanShutdown) {\n#if KJ_NO_EXCEPTIONS\n    // This is the best we can do.\n    warning(\"warning: KJ_CLEAN_SHUTDOWN may not work correctly when compiled \"\n            \"with -fno-exceptions.\");\n    ::exit(exitCode);\n#else\n    throw CleanShutdownException { exitCode };\n#endif\n  }\n  _exit(exitCode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeLineToFd",
          "args": [
            "STDOUT_FILENO",
            "message"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid TopLevelProcessContext::exitInfo(StringPtr message) {\n  writeLineToFd(STDOUT_FILENO, message);\n  exit();\n}"
  },
  {
    "function_name": "TopLevelProcessContext::exitError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "187-190",
    "snippet": "void TopLevelProcessContext::exitError(StringPtr message) {\n  error(message);\n  exit();\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "TopLevelProcessContext::exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
          "lines": "52-65",
          "snippet": "void TopLevelProcessContext::exit() {\n  int exitCode = hadErrors ? 1 : 0;\n  if (cleanShutdown) {\n#if KJ_NO_EXCEPTIONS\n    // This is the best we can do.\n    warning(\"warning: KJ_CLEAN_SHUTDOWN may not work correctly when compiled \"\n            \"with -fno-exceptions.\");\n    ::exit(exitCode);\n#else\n    throw CleanShutdownException { exitCode };\n#endif\n  }\n  _exit(exitCode);\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <windows.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <set>",
            "#include <map>",
            "#include \"arena.h\"",
            "#include \"debug.h\"",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid TopLevelProcessContext::exit() {\n  int exitCode = hadErrors ? 1 : 0;\n  if (cleanShutdown) {\n#if KJ_NO_EXCEPTIONS\n    // This is the best we can do.\n    warning(\"warning: KJ_CLEAN_SHUTDOWN may not work correctly when compiled \"\n            \"with -fno-exceptions.\");\n    ::exit(exitCode);\n#else\n    throw CleanShutdownException { exitCode };\n#endif\n  }\n  _exit(exitCode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "message"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "TopLevelProcessContext::error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
          "lines": "182-185",
          "snippet": "void TopLevelProcessContext::error(StringPtr message) {\n  hadErrors = true;\n  writeLineToFd(STDERR_FILENO, message);\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <windows.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <set>",
            "#include <map>",
            "#include \"arena.h\"",
            "#include \"debug.h\"",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid TopLevelProcessContext::error(StringPtr message) {\n  hadErrors = true;\n  writeLineToFd(STDERR_FILENO, message);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid TopLevelProcessContext::exitError(StringPtr message) {\n  error(message);\n  exit();\n}"
  },
  {
    "function_name": "TopLevelProcessContext::error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "182-185",
    "snippet": "void TopLevelProcessContext::error(StringPtr message) {\n  hadErrors = true;\n  writeLineToFd(STDERR_FILENO, message);\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeLineToFd",
          "args": [
            "STDERR_FILENO",
            "message"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid TopLevelProcessContext::error(StringPtr message) {\n  hadErrors = true;\n  writeLineToFd(STDERR_FILENO, message);\n}"
  },
  {
    "function_name": "TopLevelProcessContext::warning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "178-180",
    "snippet": "void TopLevelProcessContext::warning(StringPtr message) {\n  writeLineToFd(STDERR_FILENO, message);\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeLineToFd",
          "args": [
            "STDERR_FILENO",
            "message"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid TopLevelProcessContext::warning(StringPtr message) {\n  writeLineToFd(STDERR_FILENO, message);\n}"
  },
  {
    "function_name": "writeLineToFd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "82-176",
    "snippet": "static void writeLineToFd(int fd, StringPtr message) {\n  // Write the given message to the given file descriptor with a trailing newline iff the message\n  // is non-empty and doesn't already have a trailing newline.  We use writev() to do this in a\n  // single system call without any copying (OS permitting).\n\n  if (message.size() == 0) {\n    return;\n  }\n\n#if _WIN32\n  KJ_STACK_ARRAY(char, newlineExpansionBuffer, 2 * (message.size() + 1), 128, 512);\n  char* p = newlineExpansionBuffer.begin();\n  for(char ch : message) {\n    if(ch == '\\n') {\n      *(p++) = '\\r';\n    }\n    *(p++) = ch;\n  }\n  if(!message.endsWith(\"\\n\")) {\n    *(p++) = '\\r';\n    *(p++) = '\\n';\n  }\n\n  size_t newlineExpandedSize = p - newlineExpansionBuffer.begin();\n\n  KJ_ASSERT(newlineExpandedSize <= newlineExpansionBuffer.size());\n\n  HANDLE handle = reinterpret_cast<HANDLE>(_get_osfhandle(fd));\n  DWORD consoleMode;\n  bool redirectedToFile = !GetConsoleMode(handle, &consoleMode);\n\n  DWORD writtenSize;\n  if(redirectedToFile) {\n    WriteFile(handle, newlineExpansionBuffer.begin(), newlineExpandedSize, &writtenSize, nullptr);\n  } else {\n    KJ_STACK_ARRAY(wchar_t, buffer, newlineExpandedSize, 128, 512);\n\n    size_t finalSize = MultiByteToWideChar(\n      CP_UTF8,\n      0,\n      newlineExpansionBuffer.begin(),\n      newlineExpandedSize,\n      buffer.begin(),\n      buffer.size());\n\n    KJ_ASSERT(finalSize <= buffer.size());\n\n    WriteConsoleW(handle, buffer.begin(), finalSize, &writtenSize, nullptr);\n  }\n#else\n  // Unfortunately the writev interface requires non-const pointers even though it won't modify\n  // the data.\n  struct iovec vec[2];\n  vec[0].iov_base = const_cast<char*>(message.begin());\n  vec[0].iov_len = message.size();\n  vec[1].iov_base = const_cast<char*>(\"\\n\");\n  vec[1].iov_len = 1;\n\n  struct iovec* pos = vec;\n\n  // Only use the second item in the vec if the message doesn't already end with \\n.\n  uint count = message.endsWith(\"\\n\") ? 1 : 2;\n\n  for (;;) {\n    ssize_t n = writev(fd, pos, count);\n    if (n < 0) {\n      if (errno == EINTR) {\n        continue;\n      } else {\n        // This function is meant for writing to stdout and stderr.  If writes fail on those FDs\n        // there's not a whole lot we can reasonably do, so just ignore it.\n        return;\n      }\n    }\n\n    // Update chunks to discard what was successfully written.\n    for (;;) {\n      if (count == 0) {\n        // Done writing.\n        return;\n      } else if (pos->iov_len <= implicitCast<size_t>(n)) {\n        // Wrote this entire chunk.\n        n -= pos->iov_len;\n        ++pos;\n        --count;\n      } else {\n        // Wrote only part of this chunk.  Adjust the pointer and then retry.\n        pos->iov_base = reinterpret_cast<byte*>(pos->iov_base) + n;\n        pos->iov_len -= n;\n        break;\n      }\n    }\n  }\n#endif\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "pos->iov_base"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "implicitCast<size_t>",
          "args": [
            "n"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "implicitCast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1203-1207",
          "snippet": "To implicitCast(From&& from) {\n  // `implicitCast<T>(value)` casts `value` to type `T` only if the conversion is implicit.  Useful\n  // for e.g. resolving ambiguous overloads without sacrificing type-safety.\n  return kj::fwd<From>(from);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nTo implicitCast(From&& from) {\n  // `implicitCast<T>(value)` casts `value` to type `T` only if the conversion is implicit.  Useful\n  // for e.g. resolving ambiguous overloads without sacrificing type-safety.\n  return kj::fwd<From>(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "writev",
          "args": [
            "fd",
            "pos",
            "count"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.endsWith",
          "args": [
            "\"\\n\""
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "endsWith",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "175-175",
          "snippet": "inline bool endsWith(const StringPtr& other) const { return StringPtr(*this).endsWith(other); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline bool endsWith(const StringPtr& other) const { return StringPtr(*this).endsWith(other); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "const_cast<char*>",
          "args": [
            "\"\\n\""
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.size",
          "args": [],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "const_cast<char*>",
          "args": [
            "message.begin()"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.begin",
          "args": [],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteConsoleW",
          "args": [
            "handle",
            "buffer.begin()",
            "finalSize",
            "&writtenSize",
            "nullptr"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "finalSize <= buffer.size()"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MultiByteToWideChar",
          "args": [
            "CP_UTF8",
            "0",
            "newlineExpansionBuffer.begin()",
            "newlineExpandedSize",
            "buffer.begin()",
            "buffer.size()"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_STACK_ARRAY",
          "args": [
            "wchar_t",
            "buffer",
            "newlineExpandedSize",
            "128",
            "512"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WriteFile",
          "args": [
            "handle",
            "newlineExpansionBuffer.begin()",
            "newlineExpandedSize",
            "&writtenSize",
            "nullptr"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetConsoleMode",
          "args": [
            "handle",
            "&consoleMode"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<HANDLE>",
          "args": [
            "_get_osfhandle(fd)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_get_osfhandle",
          "args": [
            "fd"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "newlineExpandedSize <= newlineExpansionBuffer.size()"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nstatic void writeLineToFd(int fd, StringPtr message) {\n  // Write the given message to the given file descriptor with a trailing newline iff the message\n  // is non-empty and doesn't already have a trailing newline.  We use writev() to do this in a\n  // single system call without any copying (OS permitting).\n\n  if (message.size() == 0) {\n    return;\n  }\n\n#if _WIN32\n  KJ_STACK_ARRAY(char, newlineExpansionBuffer, 2 * (message.size() + 1), 128, 512);\n  char* p = newlineExpansionBuffer.begin();\n  for(char ch : message) {\n    if(ch == '\\n') {\n      *(p++) = '\\r';\n    }\n    *(p++) = ch;\n  }\n  if(!message.endsWith(\"\\n\")) {\n    *(p++) = '\\r';\n    *(p++) = '\\n';\n  }\n\n  size_t newlineExpandedSize = p - newlineExpansionBuffer.begin();\n\n  KJ_ASSERT(newlineExpandedSize <= newlineExpansionBuffer.size());\n\n  HANDLE handle = reinterpret_cast<HANDLE>(_get_osfhandle(fd));\n  DWORD consoleMode;\n  bool redirectedToFile = !GetConsoleMode(handle, &consoleMode);\n\n  DWORD writtenSize;\n  if(redirectedToFile) {\n    WriteFile(handle, newlineExpansionBuffer.begin(), newlineExpandedSize, &writtenSize, nullptr);\n  } else {\n    KJ_STACK_ARRAY(wchar_t, buffer, newlineExpandedSize, 128, 512);\n\n    size_t finalSize = MultiByteToWideChar(\n      CP_UTF8,\n      0,\n      newlineExpansionBuffer.begin(),\n      newlineExpandedSize,\n      buffer.begin(),\n      buffer.size());\n\n    KJ_ASSERT(finalSize <= buffer.size());\n\n    WriteConsoleW(handle, buffer.begin(), finalSize, &writtenSize, nullptr);\n  }\n#else\n  // Unfortunately the writev interface requires non-const pointers even though it won't modify\n  // the data.\n  struct iovec vec[2];\n  vec[0].iov_base = const_cast<char*>(message.begin());\n  vec[0].iov_len = message.size();\n  vec[1].iov_base = const_cast<char*>(\"\\n\");\n  vec[1].iov_len = 1;\n\n  struct iovec* pos = vec;\n\n  // Only use the second item in the vec if the message doesn't already end with \\n.\n  uint count = message.endsWith(\"\\n\") ? 1 : 2;\n\n  for (;;) {\n    ssize_t n = writev(fd, pos, count);\n    if (n < 0) {\n      if (errno == EINTR) {\n        continue;\n      } else {\n        // This function is meant for writing to stdout and stderr.  If writes fail on those FDs\n        // there's not a whole lot we can reasonably do, so just ignore it.\n        return;\n      }\n    }\n\n    // Update chunks to discard what was successfully written.\n    for (;;) {\n      if (count == 0) {\n        // Done writing.\n        return;\n      } else if (pos->iov_len <= implicitCast<size_t>(n)) {\n        // Wrote this entire chunk.\n        n -= pos->iov_len;\n        ++pos;\n        --count;\n      } else {\n        // Wrote only part of this chunk.  Adjust the pointer and then retry.\n        pos->iov_base = reinterpret_cast<byte*>(pos->iov_base) + n;\n        pos->iov_len -= n;\n        break;\n      }\n    }\n  }\n#endif\n}"
  },
  {
    "function_name": "setStandardIoMode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "79-79",
    "snippet": "void setStandardIoMode(int fd) {}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid setStandardIoMode(int fd) {}"
  },
  {
    "function_name": "setStandardIoMode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "68-77",
    "snippet": "void setStandardIoMode(int fd) {\n  // Set mode to binary if the fd is not a console.\n  HANDLE handle = reinterpret_cast<HANDLE>(_get_osfhandle(fd));\n  DWORD consoleMode;\n  if (GetConsoleMode(handle, &consoleMode)) {\n    // It's a console.\n  } else {\n    KJ_SYSCALL(_setmode(fd, _O_BINARY));\n  }\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "_setmode(fd, _O_BINARY)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_setmode",
          "args": [
            "fd",
            "_O_BINARY"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetConsoleMode",
          "args": [
            "handle",
            "&consoleMode"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<HANDLE>",
          "args": [
            "_get_osfhandle(fd)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_get_osfhandle",
          "args": [
            "fd"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid setStandardIoMode(int fd) {\n  // Set mode to binary if the fd is not a console.\n  HANDLE handle = reinterpret_cast<HANDLE>(_get_osfhandle(fd));\n  DWORD consoleMode;\n  if (GetConsoleMode(handle, &consoleMode)) {\n    // It's a console.\n  } else {\n    KJ_SYSCALL(_setmode(fd, _O_BINARY));\n  }\n}"
  },
  {
    "function_name": "TopLevelProcessContext::exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "52-65",
    "snippet": "void TopLevelProcessContext::exit() {\n  int exitCode = hadErrors ? 1 : 0;\n  if (cleanShutdown) {\n#if KJ_NO_EXCEPTIONS\n    // This is the best we can do.\n    warning(\"warning: KJ_CLEAN_SHUTDOWN may not work correctly when compiled \"\n            \"with -fno-exceptions.\");\n    ::exit(exitCode);\n#else\n    throw CleanShutdownException { exitCode };\n#endif\n  }\n  _exit(exitCode);\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "exitCode"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::exit",
          "args": [
            "exitCode"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warning",
          "args": [
            "\"warning: KJ_CLEAN_SHUTDOWN may not work correctly when compiled \"\n            \"with -fno-exceptions.\""
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "TopLevelProcessContext::warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
          "lines": "178-180",
          "snippet": "void TopLevelProcessContext::warning(StringPtr message) {\n  writeLineToFd(STDERR_FILENO, message);\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <windows.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <set>",
            "#include <map>",
            "#include \"arena.h\"",
            "#include \"debug.h\"",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid TopLevelProcessContext::warning(StringPtr message) {\n  writeLineToFd(STDERR_FILENO, message);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nvoid TopLevelProcessContext::exit() {\n  int exitCode = hadErrors ? 1 : 0;\n  if (cleanShutdown) {\n#if KJ_NO_EXCEPTIONS\n    // This is the best we can do.\n    warning(\"warning: KJ_CLEAN_SHUTDOWN may not work correctly when compiled \"\n            \"with -fno-exceptions.\");\n    ::exit(exitCode);\n#else\n    throw CleanShutdownException { exitCode };\n#endif\n  }\n  _exit(exitCode);\n}"
  },
  {
    "function_name": "TopLevelProcessContext::getProgramName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "48-50",
    "snippet": "StringPtr TopLevelProcessContext::getProgramName() {\n  return programName;\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nStringPtr TopLevelProcessContext::getProgramName() {\n  return programName;\n}"
  },
  {
    "function_name": "TopLevelProcessContext::TopLevelProcessContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
    "lines": "44-46",
    "snippet": "TopLevelProcessContext::TopLevelProcessContext(StringPtr programName)\n    : programName(programName),\n      cleanShutdown(getenv(\"KJ_CLEAN_SHUTDOWN\") != nullptr) {}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <set>",
      "#include <map>",
      "#include \"arena.h\"",
      "#include \"debug.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"KJ_CLEAN_SHUTDOWN\""
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nTopLevelProcessContext::TopLevelProcessContext(StringPtr programName)\n    : programName(programName),\n      cleanShutdown(getenv(\"KJ_CLEAN_SHUTDOWN\") != nullptr) {}"
  }
]