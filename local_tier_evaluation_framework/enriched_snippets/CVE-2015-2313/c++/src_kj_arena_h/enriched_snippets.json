[
  {
    "function_name": "Arena::allocateOwnArrayBuilder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.h",
    "lines": "205-209",
    "snippet": "ArrayBuilder<T> Arena::allocateOwnArrayBuilder(size_t capacity) {\n  return ArrayBuilder<T>(\n      reinterpret_cast<T*>(allocateBytes(sizeof(T) * capacity, alignof(T), false)),\n      capacity, DestructorOnlyArrayDisposer::instance);\n}",
    "includes": [
      "#include \"string.h\"",
      "#include \"array.h\"",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ArrayBuilder<T>",
          "args": [
            "reinterpret_cast<T*>(allocateBytes(sizeof(T) * capacity, alignof(T), false))",
            "capacity",
            "DestructorOnlyArrayDisposer::instance"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayBuilder",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "291-294",
          "snippet": "explicit ArrayBuilder(RemoveConst<T>* firstElement, size_t capacity,\n                        const ArrayDisposer& disposer)\n      : ptr(firstElement), pos(firstElement), endPtr(firstElement + capacity),\n        disposer(&disposer) {}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  explicit ArrayBuilder(RemoveConst<T>* firstElement, size_t capacity,\n                          const ArrayDisposer& disposer)\n        : ptr(firstElement), pos(firstElement), endPtr(firstElement + capacity),\n          disposer(&disposer) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<T*>",
          "args": [
            "allocateBytes(sizeof(T) * capacity, alignof(T), false)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocateBytes",
          "args": [
            "sizeof(T) * capacity",
            "alignof(T)",
            "false"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nArrayBuilder<T> Arena::allocateOwnArrayBuilder(size_t capacity) {\n  return ArrayBuilder<T>(\n      reinterpret_cast<T*>(allocateBytes(sizeof(T) * capacity, alignof(T), false)),\n      capacity, DestructorOnlyArrayDisposer::instance);\n}"
  },
  {
    "function_name": "Arena::allocateOwnArray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.h",
    "lines": "196-202",
    "snippet": "Array<T> Arena::allocateOwnArray(size_t size) {\n  ArrayBuilder<T> result = allocateOwnArrayBuilder<T>(size);\n  for (size_t i = 0; i < size; i++) {\n    result.add();\n  }\n  return result.finish();\n}",
    "includes": [
      "#include \"string.h\"",
      "#include \"array.h\"",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.finish",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.add",
          "args": [],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocateOwnArrayBuilder<T>",
          "args": [
            "size"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "Arena::allocateOwnArrayBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.h",
          "lines": "205-209",
          "snippet": "ArrayBuilder<T> Arena::allocateOwnArrayBuilder(size_t capacity) {\n  return ArrayBuilder<T>(\n      reinterpret_cast<T*>(allocateBytes(sizeof(T) * capacity, alignof(T), false)),\n      capacity, DestructorOnlyArrayDisposer::instance);\n}",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nArrayBuilder<T> Arena::allocateOwnArrayBuilder(size_t capacity) {\n  return ArrayBuilder<T>(\n      reinterpret_cast<T*>(allocateBytes(sizeof(T) * capacity, alignof(T), false)),\n      capacity, DestructorOnlyArrayDisposer::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nArray<T> Arena::allocateOwnArray(size_t size) {\n  ArrayBuilder<T> result = allocateOwnArrayBuilder<T>(size);\n  for (size_t i = 0; i < size; i++) {\n    result.add();\n  }\n  return result.finish();\n}"
  },
  {
    "function_name": "Arena::allocateOwn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.h",
    "lines": "187-193",
    "snippet": "Own<T> Arena::allocateOwn(Params&&... params) {\n  T& result = *reinterpret_cast<T*>(allocateBytes(sizeof(T), alignof(T), false));\n  if (!__has_trivial_constructor(T) || sizeof...(Params) > 0) {\n    ctor(result, kj::fwd<Params>(params)...);\n  }\n  return Own<T>(&result, DestructorOnlyDisposer<T>::instance);\n}",
    "includes": [
      "#include \"string.h\"",
      "#include \"array.h\"",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Own<T>",
          "args": [
            "&result",
            "DestructorOnlyDisposer<T>::instance"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "OwnedFileDescriptor",
          "container": "OwnedFileDescriptor",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "78-93",
          "snippet": "OwnedFileDescriptor(int fd, uint flags): fd(fd), flags(flags) {\n    if (flags & LowLevelAsyncIoProvider::ALREADY_NONBLOCK) {\n      KJ_DREQUIRE(fcntl(fd, F_GETFL) & O_NONBLOCK, \"You claimed you set NONBLOCK, but you didn't.\");\n    } else {\n      setNonblocking(fd);\n    }\n\n    if (flags & LowLevelAsyncIoProvider::TAKE_OWNERSHIP) {\n      if (flags & LowLevelAsyncIoProvider::ALREADY_CLOEXEC) {\n        KJ_DREQUIRE(fcntl(fd, F_GETFD) & FD_CLOEXEC,\n                    \"You claimed you set CLOEXEC, but you didn't.\");\n      } else {\n        setCloseOnExec(fd);\n      }\n    }\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nOwnedFileDescriptor {\n  OwnedFileDescriptor(int fd, uint flags): fd(fd), flags(flags) {\n      if (flags & LowLevelAsyncIoProvider::ALREADY_NONBLOCK) {\n        KJ_DREQUIRE(fcntl(fd, F_GETFL) & O_NONBLOCK, \"You claimed you set NONBLOCK, but you didn't.\");\n      } else {\n        setNonblocking(fd);\n      }\n  \n      if (flags & LowLevelAsyncIoProvider::TAKE_OWNERSHIP) {\n        if (flags & LowLevelAsyncIoProvider::ALREADY_CLOEXEC) {\n          KJ_DREQUIRE(fcntl(fd, F_GETFD) & FD_CLOEXEC,\n                      \"You claimed you set CLOEXEC, but you didn't.\");\n        } else {\n          setCloseOnExec(fd);\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctor",
          "args": [
            "result",
            "kj::fwd<Params>(params)..."
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "addAll",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "81-85",
          "snippet": "inline void addAll(Iterator begin, Iterator end) {\n    size_t needed = builder.size() + (end - begin);\n    if (needed > builder.capacity()) grow(needed);\n    builder.addAll(begin, end);\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline void addAll(Iterator begin, Iterator end) {\n      size_t needed = builder.size() + (end - begin);\n      if (needed > builder.capacity()) grow(needed);\n      builder.addAll(begin, end);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<Params>",
          "args": [
            "params"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__has_trivial_constructor",
          "args": [
            "T"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<T*>",
          "args": [
            "allocateBytes(sizeof(T), alignof(T), false)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocateBytes",
          "args": [
            "sizeof(T)",
            "alignof(T)",
            "false"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nOwn<T> Arena::allocateOwn(Params&&... params) {\n  T& result = *reinterpret_cast<T*>(allocateBytes(sizeof(T), alignof(T), false));\n  if (!__has_trivial_constructor(T) || sizeof...(Params) > 0) {\n    ctor(result, kj::fwd<Params>(params)...);\n  }\n  return Own<T>(&result, DestructorOnlyDisposer<T>::instance);\n}"
  },
  {
    "function_name": "Arena::allocateArray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.h",
    "lines": "151-184",
    "snippet": "ArrayPtr<T> Arena::allocateArray(size_t size) {\n  if (__has_trivial_destructor(T)) {\n    ArrayPtr<T> result =\n        arrayPtr(reinterpret_cast<T*>(allocateBytes(\n            sizeof(T) * size, alignof(T), false)), size);\n    if (!__has_trivial_constructor(T)) {\n      for (size_t i = 0; i < size; i++) {\n        ctor(result[i]);\n      }\n    }\n    return result;\n  } else {\n    // Allocate with a 64-bit prefix in which we store the array size.\n    constexpr size_t prefixSize = kj::max(alignof(T), sizeof(size_t));\n    void* base = allocateBytes(sizeof(T) * size + prefixSize, alignof(T), true);\n    size_t& tag = *reinterpret_cast<size_t*>(base);\n    ArrayPtr<T> result =\n        arrayPtr(reinterpret_cast<T*>(reinterpret_cast<byte*>(base) + prefixSize), size);\n    setDestructor(base, &destroyArray<T>);\n\n    if (__has_trivial_constructor(T)) {\n      tag = size;\n    } else {\n      // In case of constructor exceptions, we need the tag to end up storing the number of objects\n      // that were successfully constructed, so that they'll be properly destroyed.\n      tag = 0;\n      for (size_t i = 0; i < size; i++) {\n        ctor(result[i]);\n        tag = i + 1;\n      }\n    }\n    return result;\n  }\n}",
    "includes": [
      "#include \"string.h\"",
      "#include \"array.h\"",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctor",
          "args": [
            "result[i]"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "ctor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "733-735",
          "snippet": "inline void ctor(T& location, Params&&... params) {\n  new (_::PlacementNew(), &location) T(kj::fwd<Params>(params)...);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline void ctor(T& location, Params&&... params) {\n  new (_::PlacementNew(), &location) T(kj::fwd<Params>(params)...);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__has_trivial_constructor",
          "args": [
            "T"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setDestructor",
          "args": [
            "base",
            "&destroyArray<T>"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arrayPtr",
          "args": [
            "reinterpret_cast<T*>(reinterpret_cast<byte*>(base) + prefixSize)",
            "size"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<T*>",
          "args": [
            "reinterpret_cast<byte*>(base) + prefixSize"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "base"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<size_t*>",
          "args": [
            "base"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocateBytes",
          "args": [
            "sizeof(T) * size + prefixSize",
            "alignof(T)",
            "true"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::max",
          "args": [
            "alignof(T)",
            "sizeof(size_t)"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "486-488",
          "snippet": "auto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__has_trivial_constructor",
          "args": [
            "T"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<T*>",
          "args": [
            "allocateBytes(\n            sizeof(T) * size, alignof(T), false)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocateBytes",
          "args": [
            "sizeof(T) * size",
            "alignof(T)",
            "false"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__has_trivial_destructor",
          "args": [
            "T"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nArrayPtr<T> Arena::allocateArray(size_t size) {\n  if (__has_trivial_destructor(T)) {\n    ArrayPtr<T> result =\n        arrayPtr(reinterpret_cast<T*>(allocateBytes(\n            sizeof(T) * size, alignof(T), false)), size);\n    if (!__has_trivial_constructor(T)) {\n      for (size_t i = 0; i < size; i++) {\n        ctor(result[i]);\n      }\n    }\n    return result;\n  } else {\n    // Allocate with a 64-bit prefix in which we store the array size.\n    constexpr size_t prefixSize = kj::max(alignof(T), sizeof(size_t));\n    void* base = allocateBytes(sizeof(T) * size + prefixSize, alignof(T), true);\n    size_t& tag = *reinterpret_cast<size_t*>(base);\n    ArrayPtr<T> result =\n        arrayPtr(reinterpret_cast<T*>(reinterpret_cast<byte*>(base) + prefixSize), size);\n    setDestructor(base, &destroyArray<T>);\n\n    if (__has_trivial_constructor(T)) {\n      tag = size;\n    } else {\n      // In case of constructor exceptions, we need the tag to end up storing the number of objects\n      // that were successfully constructed, so that they'll be properly destroyed.\n      tag = 0;\n      for (size_t i = 0; i < size; i++) {\n        ctor(result[i]);\n        tag = i + 1;\n      }\n    }\n    return result;\n  }\n}"
  },
  {
    "function_name": "destroyObject",
    "container": "Arena",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.h",
    "lines": "129-131",
    "snippet": "static void destroyObject(void* pointer) {\n    dtor(*reinterpret_cast<T*>(pointer));\n  }",
    "includes": [
      "#include \"string.h\"",
      "#include \"array.h\"",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dtor",
          "args": [
            "*reinterpret_cast<T*>(pointer)"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "dtor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "738-740",
          "snippet": "inline void dtor(T& location) {\n  location.~T();\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline void dtor(T& location) {\n  location.~T();\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<T*>",
          "args": [
            "pointer"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nArena {\n  static void destroyObject(void* pointer) {\n      dtor(*reinterpret_cast<T*>(pointer));\n    }\n}"
  },
  {
    "function_name": "destroyArray",
    "container": "Arena",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.h",
    "lines": "120-126",
    "snippet": "static void destroyArray(void* pointer) {\n    size_t elementCount = *reinterpret_cast<size_t*>(pointer);\n    constexpr size_t prefixSize = kj::max(alignof(T), sizeof(size_t));\n    DestructorOnlyArrayDisposer::instance.disposeImpl(\n        reinterpret_cast<byte*>(pointer) + prefixSize,\n        sizeof(T), elementCount, elementCount, &destroyObject<T>);\n  }",
    "includes": [
      "#include \"string.h\"",
      "#include \"array.h\"",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DestructorOnlyArrayDisposer::instance.disposeImpl",
          "args": [
            "reinterpret_cast<byte*>(pointer) + prefixSize",
            "sizeof(T)",
            "elementCount",
            "elementCount",
            "&destroyObject<T>"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "pointer"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::max",
          "args": [
            "alignof(T)",
            "sizeof(size_t)"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "486-488",
          "snippet": "auto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<size_t*>",
          "args": [
            "pointer"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nArena {\n  static void destroyArray(void* pointer) {\n      size_t elementCount = *reinterpret_cast<size_t*>(pointer);\n      constexpr size_t prefixSize = kj::max(alignof(T), sizeof(size_t));\n      DestructorOnlyArrayDisposer::instance.disposeImpl(\n          reinterpret_cast<byte*>(pointer) + prefixSize,\n          sizeof(T), elementCount, elementCount, &destroyObject<T>);\n    }\n}"
  }
]