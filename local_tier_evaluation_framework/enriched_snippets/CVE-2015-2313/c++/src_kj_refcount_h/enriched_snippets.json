[
  {
    "function_name": "Refcounted::addRefInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
    "lines": "95-99",
    "snippet": "Own<T> Refcounted::addRefInternal(T* object) {\n  Refcounted* refcounted = object;\n  ++refcounted->refcount;\n  return Own<T>(object, *refcounted);\n}",
    "includes": [
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Own<T>",
          "args": [
            "object",
            "*refcounted"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "OwnedFileDescriptor",
          "container": "OwnedFileDescriptor",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "78-93",
          "snippet": "OwnedFileDescriptor(int fd, uint flags): fd(fd), flags(flags) {\n    if (flags & LowLevelAsyncIoProvider::ALREADY_NONBLOCK) {\n      KJ_DREQUIRE(fcntl(fd, F_GETFL) & O_NONBLOCK, \"You claimed you set NONBLOCK, but you didn't.\");\n    } else {\n      setNonblocking(fd);\n    }\n\n    if (flags & LowLevelAsyncIoProvider::TAKE_OWNERSHIP) {\n      if (flags & LowLevelAsyncIoProvider::ALREADY_CLOEXEC) {\n        KJ_DREQUIRE(fcntl(fd, F_GETFD) & FD_CLOEXEC,\n                    \"You claimed you set CLOEXEC, but you didn't.\");\n      } else {\n        setCloseOnExec(fd);\n      }\n    }\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nOwnedFileDescriptor {\n  OwnedFileDescriptor(int fd, uint flags): fd(fd), flags(flags) {\n      if (flags & LowLevelAsyncIoProvider::ALREADY_NONBLOCK) {\n        KJ_DREQUIRE(fcntl(fd, F_GETFL) & O_NONBLOCK, \"You claimed you set NONBLOCK, but you didn't.\");\n      } else {\n        setNonblocking(fd);\n      }\n  \n      if (flags & LowLevelAsyncIoProvider::TAKE_OWNERSHIP) {\n        if (flags & LowLevelAsyncIoProvider::ALREADY_CLOEXEC) {\n          KJ_DREQUIRE(fcntl(fd, F_GETFD) & FD_CLOEXEC,\n                      \"You claimed you set CLOEXEC, but you didn't.\");\n        } else {\n          setCloseOnExec(fd);\n        }\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> Refcounted::addRefInternal(T* object) {\n  Refcounted* refcounted = object;\n  ++refcounted->refcount;\n  return Own<T>(object, *refcounted);\n}"
  },
  {
    "function_name": "addRef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
    "lines": "85-92",
    "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
    "includes": [
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Refcounted::addRefInternal",
          "args": [
            "&object"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "Refcounted::addRefInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "95-99",
          "snippet": "Own<T> Refcounted::addRefInternal(T* object) {\n  Refcounted* refcounted = object;\n  ++refcounted->refcount;\n  return Own<T>(object, *refcounted);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> Refcounted::addRefInternal(T* object) {\n  Refcounted* refcounted = object;\n  ++refcounted->refcount;\n  return Own<T>(object, *refcounted);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IREQUIRE",
          "args": [
            "object.Refcounted::refcount > 0",
            "\"Object not allocated with kj::refcounted().\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
  },
  {
    "function_name": "refcounted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
    "lines": "77-82",
    "snippet": "inline Own<T> refcounted(Params&&... params) {\n  // Allocate a new refcounted instance of T, passing `params` to its constructor.  Returns an\n  // initial reference to the object.  More references can be created with `kj::addRef()`.\n\n  return Refcounted::addRefInternal(new T(kj::fwd<Params>(params)...));\n}",
    "includes": [
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Refcounted::addRefInternal",
          "args": [
            "new T(kj::fwd<Params>(params)...)"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "Refcounted::addRefInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "95-99",
          "snippet": "Own<T> Refcounted::addRefInternal(T* object) {\n  Refcounted* refcounted = object;\n  ++refcounted->refcount;\n  return Own<T>(object, *refcounted);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> Refcounted::addRefInternal(T* object) {\n  Refcounted* refcounted = object;\n  ++refcounted->refcount;\n  return Own<T>(object, *refcounted);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<Params>",
          "args": [
            "params"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"memory.h\"\n\ninline Own<T> refcounted(Params&&... params) {\n  // Allocate a new refcounted instance of T, passing `params` to its constructor.  Returns an\n  // initial reference to the object.  More references can be created with `kj::addRef()`.\n\n  return Refcounted::addRefInternal(new T(kj::fwd<Params>(params)...));\n}"
  }
]