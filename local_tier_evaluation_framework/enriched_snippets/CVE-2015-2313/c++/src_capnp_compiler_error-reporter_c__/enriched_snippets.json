[
  {
    "function_name": "LineBreakTable::toSourcePos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.c++",
    "lines": "61-65",
    "snippet": "GlobalErrorReporter::SourcePos LineBreakTable::toSourcePos(uint32_t byteOffset) const {\n  uint line = findLargestElementBefore(lineBreaks, byteOffset);\n  uint col = byteOffset - lineBreaks[line];\n  return GlobalErrorReporter::SourcePos { byteOffset, line, col };\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"error-reporter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "findLargestElementBefore",
          "args": [
            "lineBreaks",
            "byteOffset"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "findLargestElementBefore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.c++",
          "lines": "31-47",
          "snippet": "static size_t findLargestElementBefore(const kj::Vector<T>& vec, const T& key) {\n  KJ_REQUIRE(vec.size() > 0 && vec[0] <= key);\n\n  size_t lower = 0;\n  size_t upper = vec.size();\n\n  while (upper - lower > 1) {\n    size_t mid = (lower + upper) / 2;\n    if (vec[mid] > key) {\n      upper = mid;\n    } else {\n      lower = mid;\n    }\n  }\n\n  return lower;\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"error-reporter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"error-reporter.h\"\n\nstatic size_t findLargestElementBefore(const kj::Vector<T>& vec, const T& key) {\n  KJ_REQUIRE(vec.size() > 0 && vec[0] <= key);\n\n  size_t lower = 0;\n  size_t upper = vec.size();\n\n  while (upper - lower > 1) {\n    size_t mid = (lower + upper) / 2;\n    if (vec[mid] > key) {\n      upper = mid;\n    } else {\n      lower = mid;\n    }\n  }\n\n  return lower;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"error-reporter.h\"\n\nGlobalErrorReporter::SourcePos LineBreakTable::toSourcePos(uint32_t byteOffset) const {\n  uint line = findLargestElementBefore(lineBreaks, byteOffset);\n  uint col = byteOffset - lineBreaks[line];\n  return GlobalErrorReporter::SourcePos { byteOffset, line, col };\n}"
  },
  {
    "function_name": "LineBreakTable::LineBreakTable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.c++",
    "lines": "51-59",
    "snippet": "LineBreakTable::LineBreakTable(kj::ArrayPtr<const char> content)\n    : lineBreaks(content.size() / 40) {\n  lineBreaks.add(0);\n  for (const char* pos = content.begin(); pos < content.end(); ++pos) {\n    if (*pos == '\\n') {\n      lineBreaks.add(pos + 1 - content.begin());\n    }\n  }\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"error-reporter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lineBreaks.add",
          "args": [
            "pos + 1 - content.begin()"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "content.begin",
          "args": [],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "76-76",
          "snippet": "inline Iterator begin() const { return Iterator(0); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "content.end",
          "args": [],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "77-77",
          "snippet": "inline Iterator end() const { return Iterator(amount); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator end() const { return Iterator(amount); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "content.size",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"error-reporter.h\"\n\nLineBreakTable::LineBreakTable(kj::ArrayPtr<const char> content)\n    : lineBreaks(content.size() / 40) {\n  lineBreaks.add(0);\n  for (const char* pos = content.begin(); pos < content.end(); ++pos) {\n    if (*pos == '\\n') {\n      lineBreaks.add(pos + 1 - content.begin());\n    }\n  }\n}"
  },
  {
    "function_name": "findLargestElementBefore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.c++",
    "lines": "31-47",
    "snippet": "static size_t findLargestElementBefore(const kj::Vector<T>& vec, const T& key) {\n  KJ_REQUIRE(vec.size() > 0 && vec[0] <= key);\n\n  size_t lower = 0;\n  size_t upper = vec.size();\n\n  while (upper - lower > 1) {\n    size_t mid = (lower + upper) / 2;\n    if (vec[mid] > key) {\n      upper = mid;\n    } else {\n      lower = mid;\n    }\n  }\n\n  return lower;\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"error-reporter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vec.size",
          "args": [],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "vec.size() > 0 && vec[0] <= key"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"error-reporter.h\"\n\nstatic size_t findLargestElementBefore(const kj::Vector<T>& vec, const T& key) {\n  KJ_REQUIRE(vec.size() > 0 && vec[0] <= key);\n\n  size_t lower = 0;\n  size_t upper = vec.size();\n\n  while (upper - lower > 1) {\n    size_t mid = (lower + upper) / 2;\n    if (vec[mid] > key) {\n      upper = mid;\n    } else {\n      lower = mid;\n    }\n  }\n\n  return lower;\n}"
  }
]