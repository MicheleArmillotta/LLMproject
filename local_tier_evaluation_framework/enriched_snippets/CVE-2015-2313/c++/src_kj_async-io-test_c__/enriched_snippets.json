[
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io-test.c++",
    "lines": "223-367",
    "snippet": "TEST(AsyncIo, Udp) {\n  auto ioContext = setupAsyncIo();\n\n  auto addr = ioContext.provider->getNetwork().parseAddress(\"127.0.0.1\").wait(ioContext.waitScope);\n\n  auto port1 = addr->bindDatagramPort();\n  auto port2 = addr->bindDatagramPort();\n\n  auto addr1 = ioContext.provider->getNetwork().parseAddress(\"127.0.0.1\", port1->getPort())\n      .wait(ioContext.waitScope);\n  auto addr2 = ioContext.provider->getNetwork().parseAddress(\"127.0.0.1\", port2->getPort())\n      .wait(ioContext.waitScope);\n\n  Own<NetworkAddress> receivedAddr;\n\n  {\n    // Send a message and receive it.\n    EXPECT_EQ(3, port1->send(\"foo\", 3, *addr2).wait(ioContext.waitScope));\n    auto receiver = port2->makeReceiver();\n\n    receiver->receive().wait(ioContext.waitScope);\n    {\n      auto content = receiver->getContent();\n      EXPECT_EQ(\"foo\", kj::heapString(content.value.asChars()));\n      EXPECT_FALSE(content.isTruncated);\n    }\n    receivedAddr = receiver->getSource().clone();\n    EXPECT_EQ(addr1->toString(), receivedAddr->toString());\n    {\n      auto ancillary = receiver->getAncillary();\n      EXPECT_EQ(0, ancillary.value.size());\n      EXPECT_FALSE(ancillary.isTruncated);\n    }\n\n    // Receive a second message with the same receiver.\n    {\n      auto promise = receiver->receive();  // This time, start receiving before sending\n      EXPECT_EQ(6, port1->send(\"barbaz\", 6, *addr2).wait(ioContext.waitScope));\n      promise.wait(ioContext.waitScope);\n      auto content = receiver->getContent();\n      EXPECT_EQ(\"barbaz\", kj::heapString(content.value.asChars()));\n      EXPECT_FALSE(content.isTruncated);\n    }\n  }\n\n  DatagramReceiver::Capacity capacity;\n  capacity.content = 8;\n  capacity.ancillary = 1024;\n\n  {\n    // Send a reply that will be truncated.\n    EXPECT_EQ(16, port2->send(\"0123456789abcdef\", 16, *receivedAddr).wait(ioContext.waitScope));\n    auto recv1 = port1->makeReceiver(capacity);\n\n    recv1->receive().wait(ioContext.waitScope);\n    {\n      auto content = recv1->getContent();\n      EXPECT_EQ(\"01234567\", kj::heapString(content.value.asChars()));\n      EXPECT_TRUE(content.isTruncated);\n    }\n    EXPECT_EQ(addr2->toString(), recv1->getSource().toString());\n    {\n      auto ancillary = recv1->getAncillary();\n      EXPECT_EQ(0, ancillary.value.size());\n      EXPECT_FALSE(ancillary.isTruncated);\n    }\n\n#ifdef IP_PKTINFO\n    // Set IP_PKTINFO header and try to receive it.\n    int one = 1;\n    port1->setsockopt(IPPROTO_IP, IP_PKTINFO, &one, sizeof(one));\n\n    EXPECT_EQ(3, port2->send(\"foo\", 3, *addr1).wait(ioContext.waitScope));\n\n    recv1->receive().wait(ioContext.waitScope);\n    {\n      auto content = recv1->getContent();\n      EXPECT_EQ(\"foo\", kj::heapString(content.value.asChars()));\n      EXPECT_FALSE(content.isTruncated);\n    }\n    EXPECT_EQ(addr2->toString(), recv1->getSource().toString());\n    {\n      auto ancillary = recv1->getAncillary();\n      EXPECT_FALSE(ancillary.isTruncated);\n      ASSERT_EQ(1, ancillary.value.size());\n\n      auto message = ancillary.value[0];\n      EXPECT_EQ(IPPROTO_IP, message.getLevel());\n      EXPECT_EQ(IP_PKTINFO, message.getType());\n      EXPECT_EQ(sizeof(struct in_pktinfo), message.asArray<byte>().size());\n      auto& pktinfo = KJ_ASSERT_NONNULL(message.as<struct in_pktinfo>());\n      EXPECT_EQ(htonl(0x7F000001), pktinfo.ipi_addr.s_addr);  // 127.0.0.1\n    }\n\n    // See what happens if there's not quite enough space for in_pktinfo.\n    capacity.ancillary = CMSG_SPACE(sizeof(struct in_pktinfo)) - 8;\n    recv1 = port1->makeReceiver(capacity);\n\n    EXPECT_EQ(3, port2->send(\"bar\", 3, *addr1).wait(ioContext.waitScope));\n\n    recv1->receive().wait(ioContext.waitScope);\n    {\n      auto content = recv1->getContent();\n      EXPECT_EQ(\"bar\", kj::heapString(content.value.asChars()));\n      EXPECT_FALSE(content.isTruncated);\n    }\n    EXPECT_EQ(addr2->toString(), recv1->getSource().toString());\n    {\n      auto ancillary = recv1->getAncillary();\n      EXPECT_TRUE(ancillary.isTruncated);\n\n      // We might get a message, but it will be truncated.\n      if (ancillary.value.size() != 0) {\n        EXPECT_EQ(1, ancillary.value.size());\n\n        auto message = ancillary.value[0];\n        EXPECT_EQ(IPPROTO_IP, message.getLevel());\n        EXPECT_EQ(IP_PKTINFO, message.getType());\n\n        EXPECT_TRUE(message.as<struct in_pktinfo>() == nullptr);\n        EXPECT_LT(message.asArray<byte>().size(), sizeof(struct in_pktinfo));\n      }\n    }\n\n    // See what happens if there's not enough space even for the cmsghdr.\n    capacity.ancillary = CMSG_SPACE(0) - 8;\n    recv1 = port1->makeReceiver(capacity);\n\n    EXPECT_EQ(3, port2->send(\"baz\", 3, *addr1).wait(ioContext.waitScope));\n\n    recv1->receive().wait(ioContext.waitScope);\n    {\n      auto content = recv1->getContent();\n      EXPECT_EQ(\"baz\", kj::heapString(content.value.asChars()));\n      EXPECT_FALSE(content.isTruncated);\n    }\n    EXPECT_EQ(addr2->toString(), recv1->getSource().toString());\n    {\n      auto ancillary = recv1->getAncillary();\n      EXPECT_TRUE(ancillary.isTruncated);\n      EXPECT_EQ(0, ancillary.value.size());\n    }\n#endif\n  }\n}",
    "includes": [
      "#include <netdb.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "ancillary.value.size()"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ancillary.value.size",
          "args": [],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "ancillary.isTruncated"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv1->getAncillary",
          "args": [],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "getAncillary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1236-1238",
          "snippet": "MaybeTruncated<ArrayPtr<const AncillaryMessage>> getAncillary() override {\n    return { ancillaryList.asPtr(), ancillaryTruncated };\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nMaybeTruncated<ArrayPtr<const AncillaryMessage>> getAncillary() override {\n    return { ancillaryList.asPtr(), ancillaryTruncated };\n  }"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "addr2->toString()",
            "recv1->getSource().toString()"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv1->getSource",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv1->getSource",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr2->toString",
          "args": [],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1012-1014",
          "snippet": "String toString() override {\n    return strArray(KJ_MAP(addr, addrs) { return addr.toString(); }, \",\");\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nNetworkAddressImpl {\n  String toString() override {\n      return strArray(KJ_MAP(addr, addrs) { return addr.toString(); }, \",\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "content.isTruncated"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"baz\"",
            "kj::heapString(content.value.asChars())"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "content.value.asChars()"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "content.value.asChars",
          "args": [],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "asChars",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1164-1168",
          "snippet": "inline ArrayPtr<PropagateConst<T, char>> asChars() const {\n    // Reinterpret the array as a char array. This is explicitly legal under C++ aliasing\n    // rules.\n    return { reinterpret_cast<PropagateConst<T, char>*>(ptr), size_ * sizeof(T) };\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr<PropagateConst<T, char>> asChars() const {\n      // Reinterpret the array as a char array. This is explicitly legal under C++ aliasing\n      // rules.\n      return { reinterpret_cast<PropagateConst<T, char>*>(ptr), size_ * sizeof(T) };\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "recv1->getContent",
          "args": [],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "getContent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1232-1234",
          "snippet": "MaybeTruncated<ArrayPtr<const byte>> getContent() override {\n    return { contentBuffer.slice(0, receivedSize), contentTruncated };\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nMaybeTruncated<ArrayPtr<const byte>> getContent() override {\n    return { contentBuffer.slice(0, receivedSize), contentTruncated };\n  }"
        }
      },
      {
        "call_info": {
          "callee": "recv1->receive",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv1->receive",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "receive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1167-1230",
          "snippet": "Promise<void> receive() override {\n    struct msghdr msg;\n    memset(&msg, 0, sizeof(msg));\n\n    struct sockaddr_storage addr;\n    memset(&addr, 0, sizeof(addr));\n    msg.msg_name = &addr;\n    msg.msg_namelen = sizeof(addr);\n\n    struct iovec iov;\n    iov.iov_base = contentBuffer.begin();\n    iov.iov_len = contentBuffer.size();\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    msg.msg_control = ancillaryBuffer.begin();\n    msg.msg_controllen = ancillaryBuffer.size();\n\n    ssize_t n;\n    KJ_NONBLOCKING_SYSCALL(n = recvmsg(port.fd, &msg, 0));\n\n    if (n < 0) {\n      // No data available. Wait.\n      return port.observer.whenBecomesReadable().then([this]() {\n        return receive();\n      });\n    } else {\n      receivedSize = n;\n      contentTruncated = msg.msg_flags & MSG_TRUNC;\n\n      source.emplace(port.lowLevel, msg.msg_name, msg.msg_namelen);\n\n      ancillaryList.resize(0);\n      ancillaryTruncated = msg.msg_flags & MSG_CTRUNC;\n\n      for (struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg); cmsg != nullptr;\n           cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n        // On some platforms (OSX), a cmsghdr's length may cross the end of the ancillary buffer\n        // when truncated. On other platforms (Linux) the length in cmsghdr will itself be\n        // truncated to fit within the buffer.\n\n        const byte* pos = reinterpret_cast<const byte*>(cmsg);\n        size_t available = ancillaryBuffer.end() - pos;\n        if (available < CMSG_SPACE(0)) {\n          // The buffer ends in the middle of the header. We can't use this message.\n          // (On Linux, this never happens, because the message is not included if there isn't\n          // space for a header. I'm not sure how other systems behave, though, so let's be safe.)\n          break;\n        }\n\n        // OK, we know the cmsghdr is valid, at least.\n\n        // Find the start of the message payload.\n        const byte* begin = CMSG_DATA(cmsg);\n\n        // Cap the message length to the available space.\n        const byte* end = pos + kj::min(available, cmsg->cmsg_len);\n\n        ancillaryList.add(AncillaryMessage(\n            cmsg->cmsg_level, cmsg->cmsg_type, arrayPtr(begin, end)));\n      }\n\n      return READY_NOW;\n    }\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nPromise<void> receive() override {\n    struct msghdr msg;\n    memset(&msg, 0, sizeof(msg));\n\n    struct sockaddr_storage addr;\n    memset(&addr, 0, sizeof(addr));\n    msg.msg_name = &addr;\n    msg.msg_namelen = sizeof(addr);\n\n    struct iovec iov;\n    iov.iov_base = contentBuffer.begin();\n    iov.iov_len = contentBuffer.size();\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    msg.msg_control = ancillaryBuffer.begin();\n    msg.msg_controllen = ancillaryBuffer.size();\n\n    ssize_t n;\n    KJ_NONBLOCKING_SYSCALL(n = recvmsg(port.fd, &msg, 0));\n\n    if (n < 0) {\n      // No data available. Wait.\n      return port.observer.whenBecomesReadable().then([this]() {\n        return receive();\n      });\n    } else {\n      receivedSize = n;\n      contentTruncated = msg.msg_flags & MSG_TRUNC;\n\n      source.emplace(port.lowLevel, msg.msg_name, msg.msg_namelen);\n\n      ancillaryList.resize(0);\n      ancillaryTruncated = msg.msg_flags & MSG_CTRUNC;\n\n      for (struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg); cmsg != nullptr;\n           cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n        // On some platforms (OSX), a cmsghdr's length may cross the end of the ancillary buffer\n        // when truncated. On other platforms (Linux) the length in cmsghdr will itself be\n        // truncated to fit within the buffer.\n\n        const byte* pos = reinterpret_cast<const byte*>(cmsg);\n        size_t available = ancillaryBuffer.end() - pos;\n        if (available < CMSG_SPACE(0)) {\n          // The buffer ends in the middle of the header. We can't use this message.\n          // (On Linux, this never happens, because the message is not included if there isn't\n          // space for a header. I'm not sure how other systems behave, though, so let's be safe.)\n          break;\n        }\n\n        // OK, we know the cmsghdr is valid, at least.\n\n        // Find the start of the message payload.\n        const byte* begin = CMSG_DATA(cmsg);\n\n        // Cap the message length to the available space.\n        const byte* end = pos + kj::min(available, cmsg->cmsg_len);\n\n        ancillaryList.add(AncillaryMessage(\n            cmsg->cmsg_level, cmsg->cmsg_type, arrayPtr(begin, end)));\n      }\n\n      return READY_NOW;\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "port2->send(\"baz\", 3, *addr1).wait(ioContext.waitScope)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port2->send",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1329-1364",
          "snippet": "RemotePromise<AnyPointer> send() override {\n      if (!connectionState->connection.is<Connected>()) {\n        // Connection is broken.\n        const kj::Exception& e = connectionState->connection.get<Disconnected>();\n        return RemotePromise<AnyPointer>(\n            kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n            AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n      }\n\n      KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n        // Whoops, this capability has been redirected while we were building the request!\n        // We'll have to make a new request and do a copy.  Ick.\n\n        auto replacement = redirect->get()->newCall(\n            callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n        replacement.set(paramsBuilder);\n        return replacement.send();\n      } else {\n        auto sendResult = sendInternal(false);\n\n        auto forkedPromise = sendResult.promise.fork();\n\n        // The pipeline must get notified of resolution before the app does to maintain ordering.\n        auto pipeline = kj::refcounted<RpcPipeline>(\n            *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n\n        auto appPromise = forkedPromise.addBranch().then(\n            [=](kj::Own<RpcResponse>&& response) {\n              auto reader = response->getResults();\n              return Response<AnyPointer>(reader, kj::mv(response));\n            });\n\n        return RemotePromise<AnyPointer>(\n            kj::mv(appPromise),\n            AnyPointer::Pipeline(kj::mv(pipeline)));\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
            "kj::Maybe<kj::Own<RpcServerResponse>> response;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nkj::Maybe<kj::Own<RpcServerResponse>> response;\n\nRpcRequest {\n  RemotePromise<AnyPointer> send() override {\n        if (!connectionState->connection.is<Connected>()) {\n          // Connection is broken.\n          const kj::Exception& e = connectionState->connection.get<Disconnected>();\n          return RemotePromise<AnyPointer>(\n              kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n              AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n        }\n  \n        KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n          // Whoops, this capability has been redirected while we were building the request!\n          // We'll have to make a new request and do a copy.  Ick.\n  \n          auto replacement = redirect->get()->newCall(\n              callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n          replacement.set(paramsBuilder);\n          return replacement.send();\n        } else {\n          auto sendResult = sendInternal(false);\n  \n          auto forkedPromise = sendResult.promise.fork();\n  \n          // The pipeline must get notified of resolution before the app does to maintain ordering.\n          auto pipeline = kj::refcounted<RpcPipeline>(\n              *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n  \n          auto appPromise = forkedPromise.addBranch().then(\n              [=](kj::Own<RpcResponse>&& response) {\n                auto reader = response->getResults();\n                return Response<AnyPointer>(reader, kj::mv(response));\n              });\n  \n          return RemotePromise<AnyPointer>(\n              kj::mv(appPromise),\n              AnyPointer::Pipeline(kj::mv(pipeline)));\n        }\n}"
        }
      },
      {
        "call_info": {
          "callee": "port2->send",
          "args": [
            "\"baz\"",
            "3",
            "*addr1"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port1->makeReceiver",
          "args": [
            "capacity"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_SPACE",
          "args": [
            "0"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_LT",
          "args": [
            "message.asArray<byte>().size()",
            "sizeof(struct in_pktinfo)"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.asArray<byte>",
          "args": [],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.asArray<byte>",
          "args": [],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "message.as<struct in_pktinfo>() == nullptr"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.as<struct in_pktinfo>",
          "args": [],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "as",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "601-604",
          "snippet": "BuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nBuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "IP_PKTINFO",
            "message.getType()"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getType",
          "args": [],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "80-80",
          "snippet": "Type getType() const { return type; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  Type getType() const { return type; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "IPPROTO_IP",
            "message.getLevel()"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getLevel",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "ancillary.value.size()"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "ancillary.isTruncated"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "addr2->toString()",
            "recv1->getSource().toString()"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv1->getSource",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv1->getSource",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "content.isTruncated"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "kj::heapString(content.value.asChars())"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv1->receive",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "port2->send(\"bar\", 3, *addr1).wait(ioContext.waitScope)"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port2->send",
          "args": [
            "\"bar\"",
            "3",
            "*addr1"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port1->makeReceiver",
          "args": [
            "capacity"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_SPACE",
          "args": [
            "sizeof(struct in_pktinfo)"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "htonl(0x7F000001)",
            "pktinfo.ipi_addr.s_addr"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "0x7F000001"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "message.as<struct in_pktinfo>()"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "sizeof(struct in_pktinfo)",
            "message.asArray<byte>().size()"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.asArray<byte>",
          "args": [],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.asArray<byte>",
          "args": [],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "IP_PKTINFO",
            "message.getType()"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "IPPROTO_IP",
            "message.getLevel()"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getLevel",
          "args": [],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "1",
            "ancillary.value.size()"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "ancillary.isTruncated"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "addr2->toString()",
            "recv1->getSource().toString()"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv1->getSource",
          "args": [],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv1->getSource",
          "args": [],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "content.isTruncated"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "kj::heapString(content.value.asChars())"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv1->receive",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "port2->send(\"foo\", 3, *addr1).wait(ioContext.waitScope)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port2->send",
          "args": [
            "\"foo\"",
            "3",
            "*addr1"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port1->setsockopt",
          "args": [
            "IPPROTO_IP",
            "IP_PKTINFO",
            "&one",
            "sizeof(one)"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "setsockopt",
          "container": "DatagramPortImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "872-874",
          "snippet": "void setsockopt(int level, int option, const void* value, uint length) override {\n    KJ_SYSCALL(::setsockopt(fd, level, option, value, length));\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nDatagramPortImpl {\n  void setsockopt(int level, int option, const void* value, uint length) override {\n      KJ_SYSCALL(::setsockopt(fd, level, option, value, length));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "ancillary.isTruncated"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "ancillary.value.size()"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "addr2->toString()",
            "recv1->getSource().toString()"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv1->getSource",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv1->getSource",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "content.isTruncated"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"01234567\"",
            "kj::heapString(content.value.asChars())"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv1->receive",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port1->makeReceiver",
          "args": [
            "capacity"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "16",
            "port2->send(\"0123456789abcdef\", 16, *receivedAddr).wait(ioContext.waitScope)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port2->send",
          "args": [
            "\"0123456789abcdef\"",
            "16",
            "*receivedAddr"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "content.isTruncated"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"barbaz\"",
            "kj::heapString(content.value.asChars())"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "6",
            "port1->send(\"barbaz\", 6, *addr2).wait(ioContext.waitScope)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port1->send",
          "args": [
            "\"barbaz\"",
            "6",
            "*addr2"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "ancillary.isTruncated"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "ancillary.value.size()"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "addr1->toString()",
            "receivedAddr->toString()"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiver->getSource",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiver->getSource",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "content.isTruncated"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "kj::heapString(content.value.asChars())"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiver->receive",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port2->makeReceiver",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "port1->send(\"foo\", 3, *addr2).wait(ioContext.waitScope)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port1->send",
          "args": [
            "\"foo\"",
            "3",
            "*addr2"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [
            "\"127.0.0.1\"",
            "port2->getPort()"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port2->getPort",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "getPort",
          "container": "DatagramPortImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "863-865",
          "snippet": "uint getPort() override {\n    return SocketAddress::getLocalAddress(fd).getPort();\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nDatagramPortImpl {\n  uint getPort() override {\n      return SocketAddress::getLocalAddress(fd).getPort();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [
            "\"127.0.0.1\"",
            "port1->getPort()"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr->bindDatagramPort",
          "args": [],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "bindDatagramPort",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "985-1006",
          "snippet": "Own<DatagramPort> bindDatagramPort() override {\n    if (addrs.size() > 1) {\n      KJ_LOG(WARNING, \"Bind address resolved to multiple addresses.  Only the first address will \"\n          \"be used.  If this is incorrect, specify the address numerically.  This may be fixed \"\n          \"in the future.\", addrs[0].toString());\n    }\n\n    int fd = addrs[0].socket(SOCK_DGRAM);\n\n    {\n      KJ_ON_SCOPE_FAILURE(close(fd));\n\n      // We always enable SO_REUSEADDR because having to take your server down for five minutes\n      // before it can restart really sucks.\n      int optval = 1;\n      KJ_SYSCALL(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)));\n\n      addrs[0].bind(fd);\n    }\n\n    return lowLevel.wrapDatagramSocketFd(fd, NEW_FD_FLAGS);\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Own<DatagramPort> bindDatagramPort() override {\n      if (addrs.size() > 1) {\n        KJ_LOG(WARNING, \"Bind address resolved to multiple addresses.  Only the first address will \"\n            \"be used.  If this is incorrect, specify the address numerically.  This may be fixed \"\n            \"in the future.\", addrs[0].toString());\n      }\n  \n      int fd = addrs[0].socket(SOCK_DGRAM);\n  \n      {\n        KJ_ON_SCOPE_FAILURE(close(fd));\n  \n        // We always enable SO_REUSEADDR because having to take your server down for five minutes\n        // before it can restart really sucks.\n        int optval = 1;\n        KJ_SYSCALL(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)));\n  \n        addrs[0].bind(fd);\n      }\n  \n      return lowLevel.wrapDatagramSocketFd(fd, NEW_FD_FLAGS);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [
            "\"127.0.0.1\""
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setupAsyncIo",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "setupAsyncIo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1379-1385",
          "snippet": "AsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nTEST(AsyncIo, Udp) {\n  auto ioContext = setupAsyncIo();\n\n  auto addr = ioContext.provider->getNetwork().parseAddress(\"127.0.0.1\").wait(ioContext.waitScope);\n\n  auto port1 = addr->bindDatagramPort();\n  auto port2 = addr->bindDatagramPort();\n\n  auto addr1 = ioContext.provider->getNetwork().parseAddress(\"127.0.0.1\", port1->getPort())\n      .wait(ioContext.waitScope);\n  auto addr2 = ioContext.provider->getNetwork().parseAddress(\"127.0.0.1\", port2->getPort())\n      .wait(ioContext.waitScope);\n\n  Own<NetworkAddress> receivedAddr;\n\n  {\n    // Send a message and receive it.\n    EXPECT_EQ(3, port1->send(\"foo\", 3, *addr2).wait(ioContext.waitScope));\n    auto receiver = port2->makeReceiver();\n\n    receiver->receive().wait(ioContext.waitScope);\n    {\n      auto content = receiver->getContent();\n      EXPECT_EQ(\"foo\", kj::heapString(content.value.asChars()));\n      EXPECT_FALSE(content.isTruncated);\n    }\n    receivedAddr = receiver->getSource().clone();\n    EXPECT_EQ(addr1->toString(), receivedAddr->toString());\n    {\n      auto ancillary = receiver->getAncillary();\n      EXPECT_EQ(0, ancillary.value.size());\n      EXPECT_FALSE(ancillary.isTruncated);\n    }\n\n    // Receive a second message with the same receiver.\n    {\n      auto promise = receiver->receive();  // This time, start receiving before sending\n      EXPECT_EQ(6, port1->send(\"barbaz\", 6, *addr2).wait(ioContext.waitScope));\n      promise.wait(ioContext.waitScope);\n      auto content = receiver->getContent();\n      EXPECT_EQ(\"barbaz\", kj::heapString(content.value.asChars()));\n      EXPECT_FALSE(content.isTruncated);\n    }\n  }\n\n  DatagramReceiver::Capacity capacity;\n  capacity.content = 8;\n  capacity.ancillary = 1024;\n\n  {\n    // Send a reply that will be truncated.\n    EXPECT_EQ(16, port2->send(\"0123456789abcdef\", 16, *receivedAddr).wait(ioContext.waitScope));\n    auto recv1 = port1->makeReceiver(capacity);\n\n    recv1->receive().wait(ioContext.waitScope);\n    {\n      auto content = recv1->getContent();\n      EXPECT_EQ(\"01234567\", kj::heapString(content.value.asChars()));\n      EXPECT_TRUE(content.isTruncated);\n    }\n    EXPECT_EQ(addr2->toString(), recv1->getSource().toString());\n    {\n      auto ancillary = recv1->getAncillary();\n      EXPECT_EQ(0, ancillary.value.size());\n      EXPECT_FALSE(ancillary.isTruncated);\n    }\n\n#ifdef IP_PKTINFO\n    // Set IP_PKTINFO header and try to receive it.\n    int one = 1;\n    port1->setsockopt(IPPROTO_IP, IP_PKTINFO, &one, sizeof(one));\n\n    EXPECT_EQ(3, port2->send(\"foo\", 3, *addr1).wait(ioContext.waitScope));\n\n    recv1->receive().wait(ioContext.waitScope);\n    {\n      auto content = recv1->getContent();\n      EXPECT_EQ(\"foo\", kj::heapString(content.value.asChars()));\n      EXPECT_FALSE(content.isTruncated);\n    }\n    EXPECT_EQ(addr2->toString(), recv1->getSource().toString());\n    {\n      auto ancillary = recv1->getAncillary();\n      EXPECT_FALSE(ancillary.isTruncated);\n      ASSERT_EQ(1, ancillary.value.size());\n\n      auto message = ancillary.value[0];\n      EXPECT_EQ(IPPROTO_IP, message.getLevel());\n      EXPECT_EQ(IP_PKTINFO, message.getType());\n      EXPECT_EQ(sizeof(struct in_pktinfo), message.asArray<byte>().size());\n      auto& pktinfo = KJ_ASSERT_NONNULL(message.as<struct in_pktinfo>());\n      EXPECT_EQ(htonl(0x7F000001), pktinfo.ipi_addr.s_addr);  // 127.0.0.1\n    }\n\n    // See what happens if there's not quite enough space for in_pktinfo.\n    capacity.ancillary = CMSG_SPACE(sizeof(struct in_pktinfo)) - 8;\n    recv1 = port1->makeReceiver(capacity);\n\n    EXPECT_EQ(3, port2->send(\"bar\", 3, *addr1).wait(ioContext.waitScope));\n\n    recv1->receive().wait(ioContext.waitScope);\n    {\n      auto content = recv1->getContent();\n      EXPECT_EQ(\"bar\", kj::heapString(content.value.asChars()));\n      EXPECT_FALSE(content.isTruncated);\n    }\n    EXPECT_EQ(addr2->toString(), recv1->getSource().toString());\n    {\n      auto ancillary = recv1->getAncillary();\n      EXPECT_TRUE(ancillary.isTruncated);\n\n      // We might get a message, but it will be truncated.\n      if (ancillary.value.size() != 0) {\n        EXPECT_EQ(1, ancillary.value.size());\n\n        auto message = ancillary.value[0];\n        EXPECT_EQ(IPPROTO_IP, message.getLevel());\n        EXPECT_EQ(IP_PKTINFO, message.getType());\n\n        EXPECT_TRUE(message.as<struct in_pktinfo>() == nullptr);\n        EXPECT_LT(message.asArray<byte>().size(), sizeof(struct in_pktinfo));\n      }\n    }\n\n    // See what happens if there's not enough space even for the cmsghdr.\n    capacity.ancillary = CMSG_SPACE(0) - 8;\n    recv1 = port1->makeReceiver(capacity);\n\n    EXPECT_EQ(3, port2->send(\"baz\", 3, *addr1).wait(ioContext.waitScope));\n\n    recv1->receive().wait(ioContext.waitScope);\n    {\n      auto content = recv1->getContent();\n      EXPECT_EQ(\"baz\", kj::heapString(content.value.asChars()));\n      EXPECT_FALSE(content.isTruncated);\n    }\n    EXPECT_EQ(addr2->toString(), recv1->getSource().toString());\n    {\n      auto ancillary = recv1->getAncillary();\n      EXPECT_TRUE(ancillary.isTruncated);\n      EXPECT_EQ(0, ancillary.value.size());\n    }\n#endif\n  }\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io-test.c++",
    "lines": "210-221",
    "snippet": "TEST(AsyncIo, Timeouts) {\n  auto ioContext = setupAsyncIo();\n\n  Timer& timer = ioContext.provider->getTimer();\n\n  auto promise1 = timer.timeoutAfter(10 * MILLISECONDS, kj::Promise<void>(kj::NEVER_DONE));\n  auto promise2 = timer.timeoutAfter(100 * MILLISECONDS, kj::Promise<int>(123));\n\n  EXPECT_TRUE(promise1.then([]() { return false; }, [](kj::Exception&& e) { return true; })\n      .wait(ioContext.waitScope));\n  EXPECT_EQ(123, promise2.wait(ioContext.waitScope));\n}",
    "includes": [
      "#include <netdb.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "promise2.wait(ioContext.waitScope)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise2.wait",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "promise1.then([]() { return false; }, [](kj::Exception&& e) { return true; })\n      .wait(ioContext.waitScope)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise1.then",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise1.then",
          "args": [
            "[]() { return false; }",
            "[](kj::Exception&& e) { return true; }"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer.timeoutAfter",
          "args": [
            "100 * MILLISECONDS",
            "kj::Promise<int>(123)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::Promise<int>",
          "args": [
            "123"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "Promise",
          "container": "Promise",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "138-138",
          "snippet": "inline Promise(decltype(nullptr)) {}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\nPromise {\n  inline Promise(decltype(nullptr)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer.timeoutAfter",
          "args": [
            "10 * MILLISECONDS",
            "kj::Promise<void>(kj::NEVER_DONE)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getTimer",
          "args": [],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setupAsyncIo",
          "args": [],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "setupAsyncIo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1379-1385",
          "snippet": "AsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nTEST(AsyncIo, Timeouts) {\n  auto ioContext = setupAsyncIo();\n\n  Timer& timer = ioContext.provider->getTimer();\n\n  auto promise1 = timer.timeoutAfter(10 * MILLISECONDS, kj::Promise<void>(kj::NEVER_DONE));\n  auto promise2 = timer.timeoutAfter(100 * MILLISECONDS, kj::Promise<int>(123));\n\n  EXPECT_TRUE(promise1.then([]() { return false; }, [](kj::Exception&& e) { return true; })\n      .wait(ioContext.waitScope));\n  EXPECT_EQ(123, promise2.wait(ioContext.waitScope));\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io-test.c++",
    "lines": "187-208",
    "snippet": "TEST(AsyncIo, PipeThreadDisconnects) {\n  // Like above, but in this case we expect the main thread to detect the pipe thread disconnecting.\n\n  auto ioContext = setupAsyncIo();\n\n  auto pipeThread = ioContext.provider->newPipeThread(\n      [](AsyncIoProvider& ioProvider, AsyncIoStream& stream, WaitScope& waitScope) {\n    char buf[4];\n    stream.write(\"foo\", 3).wait(waitScope);\n    EXPECT_EQ(3u, stream.tryRead(buf, 3, 4).wait(waitScope));\n    EXPECT_EQ(\"bar\", heapString(buf, 3));\n  });\n\n  char buf[4];\n  EXPECT_EQ(3u, pipeThread.pipe->tryRead(buf, 3, 4).wait(ioContext.waitScope));\n  EXPECT_EQ(\"foo\", heapString(buf, 3));\n\n  pipeThread.pipe->write(\"bar\", 3).wait(ioContext.waitScope);\n\n  // Expect disconnect.\n  EXPECT_EQ(0, pipeThread.pipe->tryRead(buf, 1, 1).wait(ioContext.waitScope));\n}",
    "includes": [
      "#include <netdb.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "pipeThread.pipe->tryRead(buf, 1, 1).wait(ioContext.waitScope)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipeThread.pipe->tryRead",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipeThread.pipe->tryRead",
          "args": [
            "buf",
            "1",
            "1"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "TestInputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-test.c++",
          "lines": "156-162",
          "snippet": "size_t tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    KJ_ASSERT(maxBytes <= size_t(end - pos), \"Overran end of stream.\");\n    size_t amount = lazy ? minBytes : maxBytes;\n    memcpy(buffer, pos, amount);\n    pos += amount;\n    return amount;\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <string>",
            "#include <kj/miniposix.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string>\n#include <kj/miniposix.h>\n#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n\nTestInputStream {\n  size_t tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      KJ_ASSERT(maxBytes <= size_t(end - pos), \"Overran end of stream.\");\n      size_t amount = lazy ? minBytes : maxBytes;\n      memcpy(buffer, pos, amount);\n      pos += amount;\n      return amount;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipeThread.pipe->write",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "TestRunner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "422-424",
          "snippet": "void write(StringPtr text) {\n    FdOutputStream(STDOUT_FILENO).write(text.begin(), text.size());\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  void write(StringPtr text) {\n      FdOutputStream(STDOUT_FILENO).write(text.begin(), text.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipeThread.pipe->write",
          "args": [
            "\"bar\"",
            "3"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FragmentingOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async-test.c++",
          "lines": "42-50",
          "snippet": "void write(const void* buffer, size_t size) override {\n    while (size > 0) {\n      usleep(5000);\n      size_t n = rand() % size + 1;\n      inner.write(buffer, n);\n      buffer = reinterpret_cast<const byte*>(buffer) + n;\n      size -= n;\n    }\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"test-util.h\"",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <kj/thread.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"test-util.h\"\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"serialize-async.h\"\n\nFragmentingOutputStream {\n  void write(const void* buffer, size_t size) override {\n      while (size > 0) {\n        usleep(5000);\n        size_t n = rand() % size + 1;\n        inner.write(buffer, n);\n        buffer = reinterpret_cast<const byte*>(buffer) + n;\n        size -= n;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "heapString(buf, 3)"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heapString",
          "args": [
            "buf",
            "3"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "42-47",
          "snippet": "String heapString(const char* value, size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  memcpy(buffer, value, size);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(const char* value, size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  memcpy(buffer, value, size);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3u",
            "pipeThread.pipe->tryRead(buf, 3, 4).wait(ioContext.waitScope)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipeThread.pipe->tryRead",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->newPipeThread",
          "args": [
            "[](AsyncIoProvider& ioProvider, AsyncIoStream& stream, WaitScope& waitScope) {\n    char buf[4];\n    stream.write(\"foo\", 3).wait(waitScope);\n    EXPECT_EQ(3u, stream.tryRead(buf, 3, 4).wait(waitScope));\n    EXPECT_EQ(\"bar\", heapString(buf, 3));\n  }"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "heapString(buf, 3)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3u",
            "stream.tryRead(buf, 3, 4).wait(waitScope)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream.tryRead",
          "args": [
            "waitScope"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setupAsyncIo",
          "args": [],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "setupAsyncIo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1379-1385",
          "snippet": "AsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nTEST(AsyncIo, PipeThreadDisconnects) {\n  // Like above, but in this case we expect the main thread to detect the pipe thread disconnecting.\n\n  auto ioContext = setupAsyncIo();\n\n  auto pipeThread = ioContext.provider->newPipeThread(\n      [](AsyncIoProvider& ioProvider, AsyncIoStream& stream, WaitScope& waitScope) {\n    char buf[4];\n    stream.write(\"foo\", 3).wait(waitScope);\n    EXPECT_EQ(3u, stream.tryRead(buf, 3, 4).wait(waitScope));\n    EXPECT_EQ(\"bar\", heapString(buf, 3));\n  });\n\n  char buf[4];\n  EXPECT_EQ(3u, pipeThread.pipe->tryRead(buf, 3, 4).wait(ioContext.waitScope));\n  EXPECT_EQ(\"foo\", heapString(buf, 3));\n\n  pipeThread.pipe->write(\"bar\", 3).wait(ioContext.waitScope);\n\n  // Expect disconnect.\n  EXPECT_EQ(0, pipeThread.pipe->tryRead(buf, 1, 1).wait(ioContext.waitScope));\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io-test.c++",
    "lines": "167-185",
    "snippet": "TEST(AsyncIo, PipeThread) {\n  auto ioContext = setupAsyncIo();\n\n  auto pipeThread = ioContext.provider->newPipeThread(\n      [](AsyncIoProvider& ioProvider, AsyncIoStream& stream, WaitScope& waitScope) {\n    char buf[4];\n    stream.write(\"foo\", 3).wait(waitScope);\n    EXPECT_EQ(3u, stream.tryRead(buf, 3, 4).wait(waitScope));\n    EXPECT_EQ(\"bar\", heapString(buf, 3));\n\n    // Expect disconnect.\n    EXPECT_EQ(0, stream.tryRead(buf, 1, 1).wait(waitScope));\n  });\n\n  char buf[4];\n  pipeThread.pipe->write(\"bar\", 3).wait(ioContext.waitScope);\n  EXPECT_EQ(3u, pipeThread.pipe->tryRead(buf, 3, 4).wait(ioContext.waitScope));\n  EXPECT_EQ(\"foo\", heapString(buf, 3));\n}",
    "includes": [
      "#include <netdb.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "heapString(buf, 3)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heapString",
          "args": [
            "buf",
            "3"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "42-47",
          "snippet": "String heapString(const char* value, size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  memcpy(buffer, value, size);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(const char* value, size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  memcpy(buffer, value, size);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3u",
            "pipeThread.pipe->tryRead(buf, 3, 4).wait(ioContext.waitScope)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipeThread.pipe->tryRead",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipeThread.pipe->tryRead",
          "args": [
            "buf",
            "3",
            "4"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "TestInputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-test.c++",
          "lines": "156-162",
          "snippet": "size_t tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    KJ_ASSERT(maxBytes <= size_t(end - pos), \"Overran end of stream.\");\n    size_t amount = lazy ? minBytes : maxBytes;\n    memcpy(buffer, pos, amount);\n    pos += amount;\n    return amount;\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <string>",
            "#include <kj/miniposix.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string>\n#include <kj/miniposix.h>\n#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n\nTestInputStream {\n  size_t tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      KJ_ASSERT(maxBytes <= size_t(end - pos), \"Overran end of stream.\");\n      size_t amount = lazy ? minBytes : maxBytes;\n      memcpy(buffer, pos, amount);\n      pos += amount;\n      return amount;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipeThread.pipe->write",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "TestRunner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "422-424",
          "snippet": "void write(StringPtr text) {\n    FdOutputStream(STDOUT_FILENO).write(text.begin(), text.size());\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  void write(StringPtr text) {\n      FdOutputStream(STDOUT_FILENO).write(text.begin(), text.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipeThread.pipe->write",
          "args": [
            "\"bar\"",
            "3"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FragmentingOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async-test.c++",
          "lines": "42-50",
          "snippet": "void write(const void* buffer, size_t size) override {\n    while (size > 0) {\n      usleep(5000);\n      size_t n = rand() % size + 1;\n      inner.write(buffer, n);\n      buffer = reinterpret_cast<const byte*>(buffer) + n;\n      size -= n;\n    }\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"test-util.h\"",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <kj/thread.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"test-util.h\"\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"serialize-async.h\"\n\nFragmentingOutputStream {\n  void write(const void* buffer, size_t size) override {\n      while (size > 0) {\n        usleep(5000);\n        size_t n = rand() % size + 1;\n        inner.write(buffer, n);\n        buffer = reinterpret_cast<const byte*>(buffer) + n;\n        size -= n;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioContext.provider->newPipeThread",
          "args": [
            "[](AsyncIoProvider& ioProvider, AsyncIoStream& stream, WaitScope& waitScope) {\n    char buf[4];\n    stream.write(\"foo\", 3).wait(waitScope);\n    EXPECT_EQ(3u, stream.tryRead(buf, 3, 4).wait(waitScope));\n    EXPECT_EQ(\"bar\", heapString(buf, 3));\n\n    // Expect disconnect.\n    EXPECT_EQ(0, stream.tryRead(buf, 1, 1).wait(waitScope));\n  }"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "stream.tryRead(buf, 1, 1).wait(waitScope)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream.tryRead",
          "args": [
            "waitScope"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "heapString(buf, 3)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3u",
            "stream.tryRead(buf, 3, 4).wait(waitScope)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream.tryRead",
          "args": [
            "waitScope"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setupAsyncIo",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "setupAsyncIo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1379-1385",
          "snippet": "AsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nTEST(AsyncIo, PipeThread) {\n  auto ioContext = setupAsyncIo();\n\n  auto pipeThread = ioContext.provider->newPipeThread(\n      [](AsyncIoProvider& ioProvider, AsyncIoStream& stream, WaitScope& waitScope) {\n    char buf[4];\n    stream.write(\"foo\", 3).wait(waitScope);\n    EXPECT_EQ(3u, stream.tryRead(buf, 3, 4).wait(waitScope));\n    EXPECT_EQ(\"bar\", heapString(buf, 3));\n\n    // Expect disconnect.\n    EXPECT_EQ(0, stream.tryRead(buf, 1, 1).wait(waitScope));\n  });\n\n  char buf[4];\n  pipeThread.pipe->write(\"bar\", 3).wait(ioContext.waitScope);\n  EXPECT_EQ(3u, pipeThread.pipe->tryRead(buf, 3, 4).wait(ioContext.waitScope));\n  EXPECT_EQ(\"foo\", heapString(buf, 3));\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io-test.c++",
    "lines": "140-165",
    "snippet": "TEST(AsyncIo, TwoWayPipe) {\n  auto ioContext = setupAsyncIo();\n\n  auto pipe = ioContext.provider->newTwoWayPipe();\n  char receiveBuffer1[4];\n  char receiveBuffer2[4];\n\n  auto promise = pipe.ends[0]->write(\"foo\", 3).then([&]() {\n    return pipe.ends[0]->tryRead(receiveBuffer1, 3, 4);\n  }).then([&](size_t n) {\n    EXPECT_EQ(3u, n);\n    return heapString(receiveBuffer1, n);\n  });\n\n  kj::String result = pipe.ends[1]->write(\"bar\", 3).then([&]() {\n    return pipe.ends[1]->tryRead(receiveBuffer2, 3, 4);\n  }).then([&](size_t n) {\n    EXPECT_EQ(3u, n);\n    return heapString(receiveBuffer2, n);\n  }).wait(ioContext.waitScope);\n\n  kj::String result2 = promise.wait(ioContext.waitScope);\n\n  EXPECT_EQ(\"foo\", result);\n  EXPECT_EQ(\"bar\", result2);\n}",
    "includes": [
      "#include <netdb.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "result2"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "result"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe.ends[1]->write",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "TestRunner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "422-424",
          "snippet": "void write(StringPtr text) {\n    FdOutputStream(STDOUT_FILENO).write(text.begin(), text.size());\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  void write(StringPtr text) {\n      FdOutputStream(STDOUT_FILENO).write(text.begin(), text.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "heapString",
          "args": [
            "receiveBuffer2",
            "n"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "42-47",
          "snippet": "String heapString(const char* value, size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  memcpy(buffer, value, size);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(const char* value, size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  memcpy(buffer, value, size);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3u",
            "n"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe.ends[1]->tryRead",
          "args": [
            "receiveBuffer2",
            "3",
            "4"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "TestInputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-test.c++",
          "lines": "156-162",
          "snippet": "size_t tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    KJ_ASSERT(maxBytes <= size_t(end - pos), \"Overran end of stream.\");\n    size_t amount = lazy ? minBytes : maxBytes;\n    memcpy(buffer, pos, amount);\n    pos += amount;\n    return amount;\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <string>",
            "#include <kj/miniposix.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string>\n#include <kj/miniposix.h>\n#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n\nTestInputStream {\n  size_t tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      KJ_ASSERT(maxBytes <= size_t(end - pos), \"Overran end of stream.\");\n      size_t amount = lazy ? minBytes : maxBytes;\n      memcpy(buffer, pos, amount);\n      pos += amount;\n      return amount;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe.ends[1]->write",
          "args": [
            "\"bar\"",
            "3"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FragmentingOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async-test.c++",
          "lines": "42-50",
          "snippet": "void write(const void* buffer, size_t size) override {\n    while (size > 0) {\n      usleep(5000);\n      size_t n = rand() % size + 1;\n      inner.write(buffer, n);\n      buffer = reinterpret_cast<const byte*>(buffer) + n;\n      size -= n;\n    }\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"test-util.h\"",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <kj/thread.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"test-util.h\"\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"serialize-async.h\"\n\nFragmentingOutputStream {\n  void write(const void* buffer, size_t size) override {\n      while (size > 0) {\n        usleep(5000);\n        size_t n = rand() % size + 1;\n        inner.write(buffer, n);\n        buffer = reinterpret_cast<const byte*>(buffer) + n;\n        size -= n;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3u",
            "n"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->newTwoWayPipe",
          "args": [],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "newTwoWayPipe",
          "container": "AsyncIoProviderImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1289-1300",
          "snippet": "TwoWayPipe newTwoWayPipe() override {\n    int fds[2];\n    int type = SOCK_STREAM;\n#if __linux__ && !__BIONIC__\n    type |= SOCK_NONBLOCK | SOCK_CLOEXEC;\n#endif\n    KJ_SYSCALL(socketpair(AF_UNIX, type, 0, fds));\n    return TwoWayPipe { {\n      lowLevel.wrapSocketFd(fds[0], NEW_FD_FLAGS),\n      lowLevel.wrapSocketFd(fds[1], NEW_FD_FLAGS)\n    } };\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoProviderImpl {\n  TwoWayPipe newTwoWayPipe() override {\n      int fds[2];\n      int type = SOCK_STREAM;\n  #if __linux__ && !__BIONIC__\n      type |= SOCK_NONBLOCK | SOCK_CLOEXEC;\n  #endif\n      KJ_SYSCALL(socketpair(AF_UNIX, type, 0, fds));\n      return TwoWayPipe { {\n        lowLevel.wrapSocketFd(fds[0], NEW_FD_FLAGS),\n        lowLevel.wrapSocketFd(fds[1], NEW_FD_FLAGS)\n      } };\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setupAsyncIo",
          "args": [],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "setupAsyncIo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1379-1385",
          "snippet": "AsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nTEST(AsyncIo, TwoWayPipe) {\n  auto ioContext = setupAsyncIo();\n\n  auto pipe = ioContext.provider->newTwoWayPipe();\n  char receiveBuffer1[4];\n  char receiveBuffer2[4];\n\n  auto promise = pipe.ends[0]->write(\"foo\", 3).then([&]() {\n    return pipe.ends[0]->tryRead(receiveBuffer1, 3, 4);\n  }).then([&](size_t n) {\n    EXPECT_EQ(3u, n);\n    return heapString(receiveBuffer1, n);\n  });\n\n  kj::String result = pipe.ends[1]->write(\"bar\", 3).then([&]() {\n    return pipe.ends[1]->tryRead(receiveBuffer2, 3, 4);\n  }).then([&](size_t n) {\n    EXPECT_EQ(3u, n);\n    return heapString(receiveBuffer2, n);\n  }).wait(ioContext.waitScope);\n\n  kj::String result2 = promise.wait(ioContext.waitScope);\n\n  EXPECT_EQ(\"foo\", result);\n  EXPECT_EQ(\"bar\", result2);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io-test.c++",
    "lines": "122-138",
    "snippet": "TEST(AsyncIo, OneWayPipe) {\n  auto ioContext = setupAsyncIo();\n\n  auto pipe = ioContext.provider->newOneWayPipe();\n  char receiveBuffer[4];\n\n  pipe.out->write(\"foo\", 3).detach([](kj::Exception&& exception) {\n    KJ_FAIL_EXPECT(exception);\n  });\n\n  kj::String result = pipe.in->tryRead(receiveBuffer, 3, 4).then([&](size_t n) {\n    EXPECT_EQ(3u, n);\n    return heapString(receiveBuffer, n);\n  }).wait(ioContext.waitScope);\n\n  EXPECT_EQ(\"foo\", result);\n}",
    "includes": [
      "#include <netdb.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "result"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe.in->tryRead",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe.in->tryRead",
          "args": [
            "[&](size_t n) {\n    EXPECT_EQ(3u, n);\n    return heapString(receiveBuffer, n);\n  }"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heapString",
          "args": [
            "receiveBuffer",
            "n"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "42-47",
          "snippet": "String heapString(const char* value, size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  memcpy(buffer, value, size);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(const char* value, size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  memcpy(buffer, value, size);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3u",
            "n"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe.in->tryRead",
          "args": [
            "receiveBuffer",
            "3",
            "4"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "TestInputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-test.c++",
          "lines": "156-162",
          "snippet": "size_t tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    KJ_ASSERT(maxBytes <= size_t(end - pos), \"Overran end of stream.\");\n    size_t amount = lazy ? minBytes : maxBytes;\n    memcpy(buffer, pos, amount);\n    pos += amount;\n    return amount;\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <string>",
            "#include <kj/miniposix.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string>\n#include <kj/miniposix.h>\n#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n\nTestInputStream {\n  size_t tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      KJ_ASSERT(maxBytes <= size_t(end - pos), \"Overran end of stream.\");\n      size_t amount = lazy ? minBytes : maxBytes;\n      memcpy(buffer, pos, amount);\n      pos += amount;\n      return amount;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe.out->write",
          "args": [
            "[](kj::Exception&& exception) {\n    KJ_FAIL_EXPECT(exception);\n  }"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "TestRunner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "422-424",
          "snippet": "void write(StringPtr text) {\n    FdOutputStream(STDOUT_FILENO).write(text.begin(), text.size());\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  void write(StringPtr text) {\n      FdOutputStream(STDOUT_FILENO).write(text.begin(), text.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_EXPECT",
          "args": [
            "exception"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe.out->write",
          "args": [
            "\"foo\"",
            "3"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FragmentingOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async-test.c++",
          "lines": "42-50",
          "snippet": "void write(const void* buffer, size_t size) override {\n    while (size > 0) {\n      usleep(5000);\n      size_t n = rand() % size + 1;\n      inner.write(buffer, n);\n      buffer = reinterpret_cast<const byte*>(buffer) + n;\n      size -= n;\n    }\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"test-util.h\"",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <kj/thread.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"test-util.h\"\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"serialize-async.h\"\n\nFragmentingOutputStream {\n  void write(const void* buffer, size_t size) override {\n      while (size > 0) {\n        usleep(5000);\n        size_t n = rand() % size + 1;\n        inner.write(buffer, n);\n        buffer = reinterpret_cast<const byte*>(buffer) + n;\n        size -= n;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioContext.provider->newOneWayPipe",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "newOneWayPipe",
          "container": "AsyncIoProviderImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1276-1287",
          "snippet": "OneWayPipe newOneWayPipe() override {\n    int fds[2];\n#if __linux__ && !__BIONIC__\n    KJ_SYSCALL(pipe2(fds, O_NONBLOCK | O_CLOEXEC));\n#else\n    KJ_SYSCALL(pipe(fds));\n#endif\n    return OneWayPipe {\n      lowLevel.wrapInputFd(fds[0], NEW_FD_FLAGS),\n      lowLevel.wrapOutputFd(fds[1], NEW_FD_FLAGS)\n    };\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoProviderImpl {\n  OneWayPipe newOneWayPipe() override {\n      int fds[2];\n  #if __linux__ && !__BIONIC__\n      KJ_SYSCALL(pipe2(fds, O_NONBLOCK | O_CLOEXEC));\n  #else\n      KJ_SYSCALL(pipe(fds));\n  #endif\n      return OneWayPipe {\n        lowLevel.wrapInputFd(fds[0], NEW_FD_FLAGS),\n        lowLevel.wrapOutputFd(fds[1], NEW_FD_FLAGS)\n      };\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setupAsyncIo",
          "args": [],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "setupAsyncIo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1379-1385",
          "snippet": "AsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nTEST(AsyncIo, OneWayPipe) {\n  auto ioContext = setupAsyncIo();\n\n  auto pipe = ioContext.provider->newOneWayPipe();\n  char receiveBuffer[4];\n\n  pipe.out->write(\"foo\", 3).detach([](kj::Exception&& exception) {\n    KJ_FAIL_EXPECT(exception);\n  });\n\n  kj::String result = pipe.in->tryRead(receiveBuffer, 3, 4).then([&](size_t n) {\n    EXPECT_EQ(3u, n);\n    return heapString(receiveBuffer, n);\n  }).wait(ioContext.waitScope);\n\n  EXPECT_EQ(\"foo\", result);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io-test.c++",
    "lines": "88-120",
    "snippet": "TEST(AsyncIo, AddressParsing) {\n  auto ioContext = setupAsyncIo();\n  auto& w = ioContext.waitScope;\n  auto& network = ioContext.provider->getNetwork();\n\n  EXPECT_EQ(\"*:0\", tryParse(w, network, \"*\"));\n  EXPECT_EQ(\"*:123\", tryParse(w, network, \"*:123\"));\n  EXPECT_EQ(\"0.0.0.0:0\", tryParse(w, network, \"0.0.0.0\"));\n  EXPECT_EQ(\"1.2.3.4:5678\", tryParse(w, network, \"1.2.3.4\", 5678));\n\n  EXPECT_EQ(\"unix:foo/bar/baz\", tryParse(w, network, \"unix:foo/bar/baz\"));\n\n  // We can parse services by name...\n#if !__ANDROID__  // Service names not supported on Android for some reason?\n  EXPECT_EQ(\"1.2.3.4:80\", tryParse(w, network, \"1.2.3.4:http\", 5678));\n  EXPECT_EQ(\"*:80\", tryParse(w, network, \"*:http\", 5678));\n#endif\n\n  // IPv6 tests. Annoyingly, these don't work on machines that don't have IPv6 configured on any\n  // interfaces.\n  if (hasIpv6()) {\n    EXPECT_EQ(\"[::]:123\", tryParse(w, network, \"0::0\", 123));\n    EXPECT_EQ(\"[12ab:cd::34]:321\", tryParse(w, network, \"[12ab:cd:0::0:34]:321\", 432));\n#if !__ANDROID__  // Service names not supported on Android for some reason?\n    EXPECT_EQ(\"[::]:80\", tryParse(w, network, \"[::]:http\", 5678));\n    EXPECT_EQ(\"[12ab:cd::34]:80\", tryParse(w, network, \"[12ab:cd::34]:http\", 5678));\n#endif\n  }\n\n  // It would be nice to test DNS lookup here but the test would not be very hermetic.  Even\n  // localhost can map to different addresses depending on whether IPv6 is enabled.  We do\n  // connect to \"localhost\" in a different test, though.\n}",
    "includes": [
      "#include <netdb.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"[12ab:cd::34]:80\"",
            "tryParse(w, network, \"[12ab:cd::34]:http\", 5678)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryParse",
          "args": [
            "w",
            "network",
            "\"[12ab:cd::34]:http\"",
            "5678"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"[::]:80\"",
            "tryParse(w, network, \"[::]:http\", 5678)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryParse",
          "args": [
            "w",
            "network",
            "\"[::]:http\"",
            "5678"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"[12ab:cd::34]:321\"",
            "tryParse(w, network, \"[12ab:cd:0::0:34]:321\", 432)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryParse",
          "args": [
            "w",
            "network",
            "\"[12ab:cd:0::0:34]:321\"",
            "432"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"[::]:123\"",
            "tryParse(w, network, \"0::0\", 123)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryParse",
          "args": [
            "w",
            "network",
            "\"0::0\"",
            "123"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hasIpv6",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "hasIpv6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io-test.c++",
          "lines": "75-86",
          "snippet": "bool hasIpv6() {\n  // Can getaddrinfo() parse ipv6 addresses? This is only true if ipv6 is configured on at least\n  // one interface. (The loopback interface usually has it even if others don't... but not always.)\n  struct addrinfo* list;\n  int status = getaddrinfo(\"::\", nullptr, nullptr, &list);\n  if (status == 0) {\n    freeaddrinfo(list);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include <netdb.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nbool hasIpv6() {\n  // Can getaddrinfo() parse ipv6 addresses? This is only true if ipv6 is configured on at least\n  // one interface. (The loopback interface usually has it even if others don't... but not always.)\n  struct addrinfo* list;\n  int status = getaddrinfo(\"::\", nullptr, nullptr, &list);\n  if (status == 0) {\n    freeaddrinfo(list);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"*:80\"",
            "tryParse(w, network, \"*:http\", 5678)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryParse",
          "args": [
            "w",
            "network",
            "\"*:http\"",
            "5678"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"1.2.3.4:80\"",
            "tryParse(w, network, \"1.2.3.4:http\", 5678)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryParse",
          "args": [
            "w",
            "network",
            "\"1.2.3.4:http\"",
            "5678"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"unix:foo/bar/baz\"",
            "tryParse(w, network, \"unix:foo/bar/baz\")"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryParse",
          "args": [
            "w",
            "network",
            "\"unix:foo/bar/baz\""
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "tryParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io-test.c++",
          "lines": "71-73",
          "snippet": "String tryParse(WaitScope& waitScope, Network& network, StringPtr text, uint portHint = 0) {\n  return network.parseAddress(text, portHint).wait(waitScope)->toString();\n}",
          "includes": [
            "#include <netdb.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nString tryParse(WaitScope& waitScope, Network& network, StringPtr text, uint portHint = 0) {\n  return network.parseAddress(text, portHint).wait(waitScope)->toString();\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"1.2.3.4:5678\"",
            "tryParse(w, network, \"1.2.3.4\", 5678)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryParse",
          "args": [
            "w",
            "network",
            "\"1.2.3.4\"",
            "5678"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"0.0.0.0:0\"",
            "tryParse(w, network, \"0.0.0.0\")"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"*:123\"",
            "tryParse(w, network, \"*:123\")"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"*:0\"",
            "tryParse(w, network, \"*\")"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setupAsyncIo",
          "args": [],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "setupAsyncIo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1379-1385",
          "snippet": "AsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nTEST(AsyncIo, AddressParsing) {\n  auto ioContext = setupAsyncIo();\n  auto& w = ioContext.waitScope;\n  auto& network = ioContext.provider->getNetwork();\n\n  EXPECT_EQ(\"*:0\", tryParse(w, network, \"*\"));\n  EXPECT_EQ(\"*:123\", tryParse(w, network, \"*:123\"));\n  EXPECT_EQ(\"0.0.0.0:0\", tryParse(w, network, \"0.0.0.0\"));\n  EXPECT_EQ(\"1.2.3.4:5678\", tryParse(w, network, \"1.2.3.4\", 5678));\n\n  EXPECT_EQ(\"unix:foo/bar/baz\", tryParse(w, network, \"unix:foo/bar/baz\"));\n\n  // We can parse services by name...\n#if !__ANDROID__  // Service names not supported on Android for some reason?\n  EXPECT_EQ(\"1.2.3.4:80\", tryParse(w, network, \"1.2.3.4:http\", 5678));\n  EXPECT_EQ(\"*:80\", tryParse(w, network, \"*:http\", 5678));\n#endif\n\n  // IPv6 tests. Annoyingly, these don't work on machines that don't have IPv6 configured on any\n  // interfaces.\n  if (hasIpv6()) {\n    EXPECT_EQ(\"[::]:123\", tryParse(w, network, \"0::0\", 123));\n    EXPECT_EQ(\"[12ab:cd::34]:321\", tryParse(w, network, \"[12ab:cd:0::0:34]:321\", 432));\n#if !__ANDROID__  // Service names not supported on Android for some reason?\n    EXPECT_EQ(\"[::]:80\", tryParse(w, network, \"[::]:http\", 5678));\n    EXPECT_EQ(\"[12ab:cd::34]:80\", tryParse(w, network, \"[12ab:cd::34]:http\", 5678));\n#endif\n  }\n\n  // It would be nice to test DNS lookup here but the test would not be very hermetic.  Even\n  // localhost can map to different addresses depending on whether IPv6 is enabled.  We do\n  // connect to \"localhost\" in a different test, though.\n}"
  },
  {
    "function_name": "hasIpv6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io-test.c++",
    "lines": "75-86",
    "snippet": "bool hasIpv6() {\n  // Can getaddrinfo() parse ipv6 addresses? This is only true if ipv6 is configured on at least\n  // one interface. (The loopback interface usually has it even if others don't... but not always.)\n  struct addrinfo* list;\n  int status = getaddrinfo(\"::\", nullptr, nullptr, &list);\n  if (status == 0) {\n    freeaddrinfo(list);\n    return true;\n  } else {\n    return false;\n  }\n}",
    "includes": [
      "#include <netdb.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "list"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "\"::\"",
            "nullptr",
            "nullptr",
            "&list"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nbool hasIpv6() {\n  // Can getaddrinfo() parse ipv6 addresses? This is only true if ipv6 is configured on at least\n  // one interface. (The loopback interface usually has it even if others don't... but not always.)\n  struct addrinfo* list;\n  int status = getaddrinfo(\"::\", nullptr, nullptr, &list);\n  if (status == 0) {\n    freeaddrinfo(list);\n    return true;\n  } else {\n    return false;\n  }\n}"
  },
  {
    "function_name": "tryParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io-test.c++",
    "lines": "71-73",
    "snippet": "String tryParse(WaitScope& waitScope, Network& network, StringPtr text, uint portHint = 0) {\n  return network.parseAddress(text, portHint).wait(waitScope)->toString();\n}",
    "includes": [
      "#include <netdb.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "network.parseAddress",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "network.parseAddress",
          "args": [
            "waitScope"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "network.parseAddress",
          "args": [
            "text",
            "portHint"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nString tryParse(WaitScope& waitScope, Network& network, StringPtr text, uint portHint = 0) {\n  return network.parseAddress(text, portHint).wait(waitScope)->toString();\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io-test.c++",
    "lines": "33-69",
    "snippet": "TEST(AsyncIo, SimpleNetwork) {\n  auto ioContext = setupAsyncIo();\n  auto& network = ioContext.provider->getNetwork();\n\n  Own<ConnectionReceiver> listener;\n  Own<AsyncIoStream> server;\n  Own<AsyncIoStream> client;\n\n  char receiveBuffer[4];\n\n  auto port = newPromiseAndFulfiller<uint>();\n\n  port.promise.then([&](uint portnum) {\n    return network.parseAddress(\"localhost\", portnum);\n  }).then([&](Own<NetworkAddress>&& result) {\n    return result->connect();\n  }).then([&](Own<AsyncIoStream>&& result) {\n    client = kj::mv(result);\n    return client->write(\"foo\", 3);\n  }).detach([](kj::Exception&& exception) {\n    KJ_FAIL_EXPECT(exception);\n  });\n\n  kj::String result = network.parseAddress(\"*\").then([&](Own<NetworkAddress>&& result) {\n    listener = result->listen();\n    port.fulfiller->fulfill(listener->getPort());\n    return listener->accept();\n  }).then([&](Own<AsyncIoStream>&& result) {\n    server = kj::mv(result);\n    return server->tryRead(receiveBuffer, 3, 4);\n  }).then([&](size_t n) {\n    EXPECT_EQ(3u, n);\n    return heapString(receiveBuffer, n);\n  }).wait(ioContext.waitScope);\n\n  EXPECT_EQ(\"foo\", result);\n}",
    "includes": [
      "#include <netdb.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "result"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "network.parseAddress",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "network.parseAddress",
          "args": [
            "[&](size_t n) {\n    EXPECT_EQ(3u, n);\n    return heapString(receiveBuffer, n);\n  }"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heapString",
          "args": [
            "receiveBuffer",
            "n"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "42-47",
          "snippet": "String heapString(const char* value, size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  memcpy(buffer, value, size);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(const char* value, size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  memcpy(buffer, value, size);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3u",
            "n"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "network.parseAddress",
          "args": [
            "[&](Own<AsyncIoStream>&& result) {\n    server = kj::mv(result);\n    return server->tryRead(receiveBuffer, 3, 4);\n  }"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->tryRead",
          "args": [
            "receiveBuffer",
            "3",
            "4"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "TestInputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-test.c++",
          "lines": "156-162",
          "snippet": "size_t tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    KJ_ASSERT(maxBytes <= size_t(end - pos), \"Overran end of stream.\");\n    size_t amount = lazy ? minBytes : maxBytes;\n    memcpy(buffer, pos, amount);\n    pos += amount;\n    return amount;\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <string>",
            "#include <kj/miniposix.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string>\n#include <kj/miniposix.h>\n#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n\nTestInputStream {\n  size_t tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      KJ_ASSERT(maxBytes <= size_t(end - pos), \"Overran end of stream.\");\n      size_t amount = lazy ? minBytes : maxBytes;\n      memcpy(buffer, pos, amount);\n      pos += amount;\n      return amount;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "network.parseAddress",
          "args": [
            "[&](Own<NetworkAddress>&& result) {\n    listener = result->listen();\n    port.fulfiller->fulfill(listener->getPort());\n    return listener->accept();\n  }"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listener->accept",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "accept",
          "container": "FdConnectionReceiver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "784-828",
          "snippet": "Promise<Own<AsyncIoStream>> accept() override {\n    int newFd;\n\n  retry:\n#if __linux__ && !__BIONIC__\n    newFd = ::accept4(fd, nullptr, nullptr, SOCK_NONBLOCK | SOCK_CLOEXEC);\n#else\n    newFd = ::accept(fd, nullptr, nullptr);\n#endif\n\n    if (newFd >= 0) {\n      return Own<AsyncIoStream>(heap<AsyncStreamFd>(eventPort, newFd, NEW_FD_FLAGS));\n    } else {\n      int error = errno;\n\n      switch (error) {\n        case EAGAIN:\n#if EAGAIN != EWOULDBLOCK\n        case EWOULDBLOCK:\n#endif\n          // Not ready yet.\n          return observer.whenBecomesReadable().then([this]() {\n            return accept();\n          });\n\n        case EINTR:\n        case ENETDOWN:\n        case EPROTO:\n        case EHOSTDOWN:\n        case EHOSTUNREACH:\n        case ENETUNREACH:\n        case ECONNABORTED:\n        case ETIMEDOUT:\n          // According to the Linux man page, accept() may report an error if the accepted\n          // connection is already broken.  In this case, we really ought to just ignore it and\n          // keep waiting.  But it's hard to say exactly what errors are such network errors and\n          // which ones are permanent errors.  We've made a guess here.\n          goto retry;\n\n        default:\n          KJ_FAIL_SYSCALL(\"accept\", error);\n      }\n\n    }\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nFdConnectionReceiver {\n  Promise<Own<AsyncIoStream>> accept() override {\n      int newFd;\n  \n    retry:\n  #if __linux__ && !__BIONIC__\n      newFd = ::accept4(fd, nullptr, nullptr, SOCK_NONBLOCK | SOCK_CLOEXEC);\n  #else\n      newFd = ::accept(fd, nullptr, nullptr);\n  #endif\n  \n      if (newFd >= 0) {\n        return Own<AsyncIoStream>(heap<AsyncStreamFd>(eventPort, newFd, NEW_FD_FLAGS));\n      } else {\n        int error = errno;\n  \n        switch (error) {\n          case EAGAIN:\n  #if EAGAIN != EWOULDBLOCK\n          case EWOULDBLOCK:\n  #endif\n            // Not ready yet.\n            return observer.whenBecomesReadable().then([this]() {\n              return accept();\n            });\n  \n          case EINTR:\n          case ENETDOWN:\n          case EPROTO:\n          case EHOSTDOWN:\n          case EHOSTUNREACH:\n          case ENETUNREACH:\n          case ECONNABORTED:\n          case ETIMEDOUT:\n            // According to the Linux man page, accept() may report an error if the accepted\n            // connection is already broken.  In this case, we really ought to just ignore it and\n            // keep waiting.  But it's hard to say exactly what errors are such network errors and\n            // which ones are permanent errors.  We've made a guess here.\n            goto retry;\n  \n          default:\n            KJ_FAIL_SYSCALL(\"accept\", error);\n        }\n  \n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "port.fulfiller->fulfill",
          "args": [
            "listener->getPort()"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "fulfill",
          "container": "WeakFulfiller",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "847-851",
          "snippet": "void fulfill(FixVoid<T>&& value) override {\n    if (inner != nullptr) {\n      inner->fulfill(kj::mv(value));\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "WeakFulfiller {\n  void fulfill(FixVoid<T>&& value) override {\n      if (inner != nullptr) {\n        inner->fulfill(kj::mv(value));\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "listener->getPort",
          "args": [],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "getPort",
          "container": "DatagramPortImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "863-865",
          "snippet": "uint getPort() override {\n    return SocketAddress::getLocalAddress(fd).getPort();\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nDatagramPortImpl {\n  uint getPort() override {\n      return SocketAddress::getLocalAddress(fd).getPort();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result->listen",
          "args": [],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "listen",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "959-983",
          "snippet": "Own<ConnectionReceiver> listen() override {\n    if (addrs.size() > 1) {\n      KJ_LOG(WARNING, \"Bind address resolved to multiple addresses.  Only the first address will \"\n          \"be used.  If this is incorrect, specify the address numerically.  This may be fixed \"\n          \"in the future.\", addrs[0].toString());\n    }\n\n    int fd = addrs[0].socket(SOCK_STREAM);\n\n    {\n      KJ_ON_SCOPE_FAILURE(close(fd));\n\n      // We always enable SO_REUSEADDR because having to take your server down for five minutes\n      // before it can restart really sucks.\n      int optval = 1;\n      KJ_SYSCALL(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)));\n\n      addrs[0].bind(fd);\n\n      // TODO(someday):  Let queue size be specified explicitly in string addresses.\n      KJ_SYSCALL(::listen(fd, SOMAXCONN));\n    }\n\n    return lowLevel.wrapListenSocketFd(fd, NEW_FD_FLAGS);\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Own<ConnectionReceiver> listen() override {\n      if (addrs.size() > 1) {\n        KJ_LOG(WARNING, \"Bind address resolved to multiple addresses.  Only the first address will \"\n            \"be used.  If this is incorrect, specify the address numerically.  This may be fixed \"\n            \"in the future.\", addrs[0].toString());\n      }\n  \n      int fd = addrs[0].socket(SOCK_STREAM);\n  \n      {\n        KJ_ON_SCOPE_FAILURE(close(fd));\n  \n        // We always enable SO_REUSEADDR because having to take your server down for five minutes\n        // before it can restart really sucks.\n        int optval = 1;\n        KJ_SYSCALL(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)));\n  \n        addrs[0].bind(fd);\n  \n        // TODO(someday):  Let queue size be specified explicitly in string addresses.\n        KJ_SYSCALL(::listen(fd, SOMAXCONN));\n      }\n  \n      return lowLevel.wrapListenSocketFd(fd, NEW_FD_FLAGS);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "network.parseAddress",
          "args": [
            "\"*\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.promise.then",
          "args": [
            "[](kj::Exception&& exception) {\n    KJ_FAIL_EXPECT(exception);\n  }"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_EXPECT",
          "args": [
            "exception"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.promise.then",
          "args": [
            "[&](Own<AsyncIoStream>&& result) {\n    client = kj::mv(result);\n    return client->write(\"foo\", 3);\n  }"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client->write",
          "args": [
            "\"foo\"",
            "3"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FragmentingOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async-test.c++",
          "lines": "42-50",
          "snippet": "void write(const void* buffer, size_t size) override {\n    while (size > 0) {\n      usleep(5000);\n      size_t n = rand() % size + 1;\n      inner.write(buffer, n);\n      buffer = reinterpret_cast<const byte*>(buffer) + n;\n      size -= n;\n    }\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"test-util.h\"",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <kj/thread.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"test-util.h\"\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"serialize-async.h\"\n\nFragmentingOutputStream {\n  void write(const void* buffer, size_t size) override {\n      while (size > 0) {\n        usleep(5000);\n        size_t n = rand() % size + 1;\n        inner.write(buffer, n);\n        buffer = reinterpret_cast<const byte*>(buffer) + n;\n        size -= n;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.promise.then",
          "args": [
            "[&](Own<NetworkAddress>&& result) {\n    return result->connect();\n  }"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result->connect",
          "args": [],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "955-957",
          "snippet": "Promise<Own<AsyncIoStream>> connect() override {\n    return connectImpl(0);\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Promise<Own<AsyncIoStream>> connect() override {\n      return connectImpl(0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "port.promise.then",
          "args": [
            "[&](uint portnum) {\n    return network.parseAddress(\"localhost\", portnum);\n  }"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "network.parseAddress",
          "args": [
            "\"localhost\"",
            "portnum"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newPromiseAndFulfiller<uint>",
          "args": [],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getNetwork",
          "args": [],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setupAsyncIo",
          "args": [],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "setupAsyncIo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1379-1385",
          "snippet": "AsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nTEST(AsyncIo, SimpleNetwork) {\n  auto ioContext = setupAsyncIo();\n  auto& network = ioContext.provider->getNetwork();\n\n  Own<ConnectionReceiver> listener;\n  Own<AsyncIoStream> server;\n  Own<AsyncIoStream> client;\n\n  char receiveBuffer[4];\n\n  auto port = newPromiseAndFulfiller<uint>();\n\n  port.promise.then([&](uint portnum) {\n    return network.parseAddress(\"localhost\", portnum);\n  }).then([&](Own<NetworkAddress>&& result) {\n    return result->connect();\n  }).then([&](Own<AsyncIoStream>&& result) {\n    client = kj::mv(result);\n    return client->write(\"foo\", 3);\n  }).detach([](kj::Exception&& exception) {\n    KJ_FAIL_EXPECT(exception);\n  });\n\n  kj::String result = network.parseAddress(\"*\").then([&](Own<NetworkAddress>&& result) {\n    listener = result->listen();\n    port.fulfiller->fulfill(listener->getPort());\n    return listener->accept();\n  }).then([&](Own<AsyncIoStream>&& result) {\n    server = kj::mv(result);\n    return server->tryRead(receiveBuffer, 3, 4);\n  }).then([&](size_t n) {\n    EXPECT_EQ(3u, n);\n    return heapString(receiveBuffer, n);\n  }).wait(ioContext.waitScope);\n\n  EXPECT_EQ(\"foo\", result);\n}"
  }
]