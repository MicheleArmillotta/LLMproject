[
  {
    "function_name": "hadErrors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "1382-1384",
    "snippet": "bool hadErrors() override {\n    return hadErrors_;\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool hadErrors_ = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nbool hadErrors_ = false;\n\nbool hadErrors() override {\n    return hadErrors_;\n  }"
  },
  {
    "function_name": "resolveConstant",
    "container": "ValueResolverGlue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "1349-1352",
    "snippet": "kj::Maybe<DynamicValue::Reader> resolveConstant(Expression::Reader name) {\n      errorReporter.addErrorOn(name, kj::str(\"External constants not allowed in encode input.\"));\n      return nullptr;\n    }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CapnpParser parser(arena.getOrphanage(), errorReporter);",
      "ValueResolverGlue resolver(compiler->getLoader(), errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "errorReporter.addErrorOn",
          "args": [
            "name",
            "kj::str(\"External constants not allowed in encode input.\")"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "addErrorOn",
          "container": "ErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.h",
          "lines": "47-52",
          "snippet": "inline void addErrorOn(T&& decl, kj::StringPtr message) {\n    // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n    // of the Cap'n Proto types defined in `grammar.capnp` do.\n\n    addError(decl.getStartByte(), decl.getEndByte(), message);\n  }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/string.h>",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/string.h>\n#include \"../common.h\"\n\nErrorReporter {\n  inline void addErrorOn(T&& decl, kj::StringPtr message) {\n      // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n      // of the Cap'n Proto types defined in `grammar.capnp` do.\n  \n      addError(decl.getStartByte(), decl.getEndByte(), message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"External constants not allowed in encode input.\""
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "341-341",
          "snippet": "inline String str(String&& s) { return mv(s); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nCapnpParser parser(arena.getOrphanage(), errorReporter);\nValueResolverGlue resolver(compiler->getLoader(), errorReporter);\n\nValueResolverGlue {\n  kj::Maybe<DynamicValue::Reader> resolveConstant(Expression::Reader name) {\n        errorReporter.addErrorOn(name, kj::str(\"External constants not allowed in encode input.\"));\n        return nullptr;\n      }\n}"
  },
  {
    "function_name": "resolveType",
    "container": "ValueResolverGlue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "1344-1347",
    "snippet": "kj::Maybe<Schema> resolveType(uint64_t id) {\n      // Don't use tryGet() here because we shouldn't even be here if there were compile errors.\n      return loader.get(id);\n    }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ModuleLoader loader;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "loader.get",
          "args": [
            "id"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nModuleLoader loader;\n\nValueResolverGlue {\n  kj::Maybe<Schema> resolveType(uint64_t id) {\n        // Don't use tryGet() here because we shouldn't even be here if there were compile errors.\n        return loader.get(id);\n      }\n}"
  },
  {
    "function_name": "ValueResolverGlue",
    "container": "ValueResolverGlue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "1341-1342",
    "snippet": "ValueResolverGlue(const SchemaLoader& loader, ErrorReporter& errorReporter)\n        : loader(loader), errorReporter(errorReporter) {}",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CapnpParser parser(arena.getOrphanage(), errorReporter);",
      "ValueResolverGlue resolver(compiler->getLoader(), errorReporter);",
      "ModuleLoader loader;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nCapnpParser parser(arena.getOrphanage(), errorReporter);\nValueResolverGlue resolver(compiler->getLoader(), errorReporter);\nModuleLoader loader;\n\nValueResolverGlue {\n  ValueResolverGlue(const SchemaLoader& loader, ErrorReporter& errorReporter)\n          : loader(loader), errorReporter(errorReporter) {}\n}"
  },
  {
    "function_name": "hadErrors",
    "container": "EncoderErrorReporter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "1330-1332",
    "snippet": "bool hadErrors() override {\n      return globalReporter.hadErrors();\n    }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nEncoderErrorReporter {\n  bool hadErrors() override {\n        return globalReporter.hadErrors();\n      }\n}"
  },
  {
    "function_name": "addError",
    "container": "EncoderErrorReporter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "1325-1328",
    "snippet": "void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n      globalReporter.addError(\"<stdin>\", lineBreaks.toSourcePos(startByte),\n                              lineBreaks.toSourcePos(endByte), message);\n    }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "MallocMessageBuilder message;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "globalReporter.addError",
          "args": [
            "\"<stdin>\"",
            "lineBreaks.toSourcePos(startByte)",
            "lineBreaks.toSourcePos(endByte)",
            "message"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "addError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "113-133",
          "snippet": "void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n    auto& lines = lineBreaks.get(\n        [](kj::SpaceFor<kj::Vector<uint>>& space) {\n          KJ_FAIL_REQUIRE(\"Can't report errors until loadContent() is called.\");\n          return space.construct();\n        });\n\n    // TODO(someday):  This counts tabs as single characters.  Do we care?\n    uint startLine = findLargestElementBefore(lines, startByte);\n    uint startCol = startByte - lines[startLine];\n    uint endLine = findLargestElementBefore(lines, endByte);\n    uint endCol = endByte - lines[endLine];\n\n    file->reportError(\n        SchemaFile::SourcePos { startByte, startLine, startCol },\n        SchemaFile::SourcePos { endByte, endLine, endCol },\n        message);\n\n    // We intentionally only set hadErrors true if reportError() didn't throw.\n    parser.hadErrors = true;\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nvoid addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n    auto& lines = lineBreaks.get(\n        [](kj::SpaceFor<kj::Vector<uint>>& space) {\n          KJ_FAIL_REQUIRE(\"Can't report errors until loadContent() is called.\");\n          return space.construct();\n        });\n\n    // TODO(someday):  This counts tabs as single characters.  Do we care?\n    uint startLine = findLargestElementBefore(lines, startByte);\n    uint startCol = startByte - lines[startLine];\n    uint endLine = findLargestElementBefore(lines, endByte);\n    uint endCol = endByte - lines[endLine];\n\n    file->reportError(\n        SchemaFile::SourcePos { startByte, startLine, startCol },\n        SchemaFile::SourcePos { endByte, endLine, endCol },\n        message);\n\n    // We intentionally only set hadErrors true if reportError() didn't throw.\n    parser.hadErrors = true;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "lineBreaks.toSourcePos",
          "args": [
            "endByte"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lineBreaks.toSourcePos",
          "args": [
            "startByte"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nMallocMessageBuilder message;\n\nEncoderErrorReporter {\n  void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n        globalReporter.addError(\"<stdin>\", lineBreaks.toSourcePos(startByte),\n                                lineBreaks.toSourcePos(endByte), message);\n      }\n}"
  },
  {
    "function_name": "EncoderErrorReporter",
    "container": "EncoderErrorReporter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "1321-1323",
    "snippet": "EncoderErrorReporter(GlobalErrorReporter& globalReporter,\n                         kj::ArrayPtr<const char> content)\n      : globalReporter(globalReporter), lineBreaks(content) {}",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nEncoderErrorReporter {\n  EncoderErrorReporter(GlobalErrorReporter& globalReporter,\n                           kj::ArrayPtr<const char> content)\n        : globalReporter(globalReporter), lineBreaks(content) {}\n}"
  },
  {
    "function_name": "writeFlat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "1300-1317",
    "snippet": "void writeFlat(DynamicStruct::Reader value, kj::BufferedOutputStream& output) {\n    // Always copy the message to a flat array so that the output is predictable (one segment,\n    // in canonical order).\n    size_t size = value.totalSize().wordCount + 1;\n    kj::Array<word> space = kj::heapArray<word>(size);\n    memset(space.begin(), 0, size * sizeof(word));\n    FlatMessageBuilder flatMessage(space);\n    flatMessage.setRoot(value);\n    flatMessage.requireFilled();\n\n    if (flat) {\n      output.write(space.begin(), space.size() * sizeof(word));\n    } else if (packed) {\n      writePackedMessage(output, flatMessage);\n    } else {\n      writeMessage(output, flatMessage);\n    }\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "MallocMessageBuilder message;",
      "DynamicValue::Reader value;",
      "bool flat = false;",
      "bool packed = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeMessage",
          "args": [
            "output",
            "flatMessage"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "writeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.h",
          "lines": "58-60",
          "snippet": "inline kj::Promise<void> writeMessage(kj::AsyncOutputStream& output, MessageBuilder& builder) {\n  return writeMessage(output, builder.getSegmentsForOutput());\n}",
          "includes": [
            "#include \"message.h\"",
            "#include <kj/async-io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"message.h\"\n#include <kj/async-io.h>\n\ninline kj::Promise<void> writeMessage(kj::AsyncOutputStream& output, MessageBuilder& builder) {\n  return writeMessage(output, builder.getSegmentsForOutput());\n}"
        }
      },
      {
        "call_info": {
          "callee": "writePackedMessage",
          "args": [
            "output",
            "flatMessage"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "writePackedMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed.h",
          "lines": "116-118",
          "snippet": "inline void writePackedMessage(kj::OutputStream& output, MessageBuilder& builder) {\n  writePackedMessage(output, builder.getSegmentsForOutput());\n}",
          "includes": [
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"serialize.h\"\n\ninline void writePackedMessage(kj::OutputStream& output, MessageBuilder& builder) {\n  writePackedMessage(output, builder.getSegmentsForOutput());\n}"
        }
      },
      {
        "call_info": {
          "callee": "output.write",
          "args": [
            "space.begin()",
            "space.size() * sizeof(word)"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FragmentingOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async-test.c++",
          "lines": "42-50",
          "snippet": "void write(const void* buffer, size_t size) override {\n    while (size > 0) {\n      usleep(5000);\n      size_t n = rand() % size + 1;\n      inner.write(buffer, n);\n      buffer = reinterpret_cast<const byte*>(buffer) + n;\n      size -= n;\n    }\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"test-util.h\"",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <kj/thread.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"test-util.h\"\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"serialize-async.h\"\n\nFragmentingOutputStream {\n  void write(const void* buffer, size_t size) override {\n      while (size > 0) {\n        usleep(5000);\n        size_t n = rand() % size + 1;\n        inner.write(buffer, n);\n        buffer = reinterpret_cast<const byte*>(buffer) + n;\n        size -= n;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "space.size",
          "args": [],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "space.begin",
          "args": [],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "76-76",
          "snippet": "inline Iterator begin() const { return Iterator(0); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "flatMessage.requireFilled",
          "args": [],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flatMessage.setRoot",
          "args": [
            "value"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "space.begin()",
            "0",
            "size * sizeof(word)"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArray<word>",
          "args": [
            "size"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "696-698",
          "snippet": "inline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.totalSize",
          "args": [],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "totalSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/grammar.capnp.h",
          "lines": "3151-3151",
          "snippet": "inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nMallocMessageBuilder message;\nDynamicValue::Reader value;\nbool flat = false;\nbool packed = false;\n\nvoid writeFlat(DynamicStruct::Reader value, kj::BufferedOutputStream& output) {\n    // Always copy the message to a flat array so that the output is predictable (one segment,\n    // in canonical order).\n    size_t size = value.totalSize().wordCount + 1;\n    kj::Array<word> space = kj::heapArray<word>(size);\n    memset(space.begin(), 0, size * sizeof(word));\n    FlatMessageBuilder flatMessage(space);\n    flatMessage.setRoot(value);\n    flatMessage.requireFilled();\n\n    if (flat) {\n      output.write(space.begin(), space.size() * sizeof(word));\n    } else if (packed) {\n      writePackedMessage(output, flatMessage);\n    } else {\n      writeMessage(output, flatMessage);\n    }\n  }"
  },
  {
    "function_name": "evalConst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "1155-1181",
    "snippet": "kj::MainBuilder::Validity evalConst(kj::StringPtr name) {\n    KJ_ASSERT(sourceFiles.size() == 1);\n\n    auto parser = kj::parse::sequence(\n        kj::parse::many(\n            kj::parse::sequence(\n                kj::parse::identifier,\n                kj::parse::many(\n                    kj::parse::sequence(\n                        kj::parse::exactChar<'['>(),\n                        kj::parse::integer,\n                        kj::parse::exactChar<']'>())),\n                kj::parse::oneOf(\n                    kj::parse::endOfInput,\n                    kj::parse::sequence(\n                        kj::parse::exactChar<'.'>(),\n                        kj::parse::notLookingAt(kj::parse::endOfInput))))),\n        kj::parse::endOfInput);\n\n    kj::parse::IteratorInput<char, const char*> input(name.begin(), name.end());\n\n    kj::Array<kj::Tuple<kj::String, kj::Array<uint64_t>>> nameParts;\n    KJ_IF_MAYBE(p, parser(input)) {\n      nameParts = kj::mv(*p);\n    } else {\n      return \"invalid syntax\";\n    }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CapnpParser::ParserInput parserInput(tokens.begin(), tokens.end());",
      "kj::Vector<SourceFile> sourceFiles;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*p"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.end",
          "args": [],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "77-77",
          "snippet": "inline Iterator end() const { return Iterator(amount); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator end() const { return Iterator(amount); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "name.begin",
          "args": [],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "76-76",
          "snippet": "inline Iterator begin() const { return Iterator(0); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::parse::sequence",
          "args": [
            "kj::parse::many(\n            kj::parse::sequence(\n                kj::parse::identifier,\n                kj::parse::many(\n                    kj::parse::sequence(\n                        kj::parse::exactChar<'['>(),\n                        kj::parse::integer,\n                        kj::parse::exactChar<']'>())),\n                kj::parse::oneOf(\n                    kj::parse::endOfInput,\n                    kj::parse::sequence(\n                        kj::parse::exactChar<'.'>(),\n                        kj::parse::notLookingAt(kj::parse::endOfInput)))))",
            "kj::parse::endOfInput"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::parse::many",
          "args": [
            "kj::parse::sequence(\n                kj::parse::identifier,\n                kj::parse::many(\n                    kj::parse::sequence(\n                        kj::parse::exactChar<'['>(),\n                        kj::parse::integer,\n                        kj::parse::exactChar<']'>())),\n                kj::parse::oneOf(\n                    kj::parse::endOfInput,\n                    kj::parse::sequence(\n                        kj::parse::exactChar<'.'>(),\n                        kj::parse::notLookingAt(kj::parse::endOfInput))))"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "432-436",
          "snippet": "constexpr Many_<SubParser, false> many(SubParser&& subParser) {\n  // Constructs a parser that repeatedly executes the given parser until it fails, returning an\n  // Array of the results (or a uint count if `subParser` returns an empty tuple).\n  return Many_<SubParser, false>(kj::fwd<SubParser>(subParser));\n}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr Many_<SubParser, false> many(SubParser&& subParser) {\n  // Constructs a parser that repeatedly executes the given parser until it fails, returning an\n  // Array of the results (or a uint count if `subParser` returns an empty tuple).\n  return Many_<SubParser, false>(kj::fwd<SubParser>(subParser));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::parse::sequence",
          "args": [
            "kj::parse::identifier",
            "kj::parse::many(\n                    kj::parse::sequence(\n                        kj::parse::exactChar<'['>(),\n                        kj::parse::integer,\n                        kj::parse::exactChar<']'>()))",
            "kj::parse::oneOf(\n                    kj::parse::endOfInput,\n                    kj::parse::sequence(\n                        kj::parse::exactChar<'.'>(),\n                        kj::parse::notLookingAt(kj::parse::endOfInput)))"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::parse::oneOf",
          "args": [
            "kj::parse::endOfInput",
            "kj::parse::sequence(\n                        kj::parse::exactChar<'.'>(),\n                        kj::parse::notLookingAt(kj::parse::endOfInput))"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::parse::sequence",
          "args": [
            "kj::parse::exactChar<'.'>()",
            "kj::parse::notLookingAt(kj::parse::endOfInput)"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::parse::notLookingAt",
          "args": [
            "kj::parse::endOfInput"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "notLookingAt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "753-757",
          "snippet": "constexpr NotLookingAt_<SubParser> notLookingAt(SubParser&& subParser) {\n  // Constructs a parser which fails at any position where the given parser succeeds.  Otherwise,\n  // it succeeds without consuming any input and returns an empty tuple.\n  return NotLookingAt_<SubParser>(kj::fwd<SubParser>(subParser));\n}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr NotLookingAt_<SubParser> notLookingAt(SubParser&& subParser) {\n  // Constructs a parser which fails at any position where the given parser succeeds.  Otherwise,\n  // it succeeds without consuming any input and returns an empty tuple.\n  return NotLookingAt_<SubParser>(kj::fwd<SubParser>(subParser));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::parse::exactChar<'.'>",
          "args": [],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "exactChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/char.h",
          "lines": "68-72",
          "snippet": "constexpr ExactlyConst_<char, c> exactChar() {\n  // Returns a parser that matches exactly the character given by the template argument (returning\n  // no result).\n  return ExactlyConst_<char, c>();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include \"../string.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include \"../string.h\"\n#include \"common.h\"\n\nconstexpr ExactlyConst_<char, c> exactChar() {\n  // Returns a parser that matches exactly the character given by the template argument (returning\n  // no result).\n  return ExactlyConst_<char, c>();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::parse::sequence",
          "args": [
            "kj::parse::exactChar<'['>()",
            "kj::parse::integer",
            "kj::parse::exactChar<']'>()"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "sourceFiles.size() == 1"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sourceFiles.size",
          "args": [],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nCapnpParser::ParserInput parserInput(tokens.begin(), tokens.end());\nkj::Vector<SourceFile> sourceFiles;\n\nkj::MainBuilder::Validity evalConst(kj::StringPtr name) {\n    KJ_ASSERT(sourceFiles.size() == 1);\n\n    auto parser = kj::parse::sequence(\n        kj::parse::many(\n            kj::parse::sequence(\n                kj::parse::identifier,\n                kj::parse::many(\n                    kj::parse::sequence(\n                        kj::parse::exactChar<'['>(),\n                        kj::parse::integer,\n                        kj::parse::exactChar<']'>())),\n                kj::parse::oneOf(\n                    kj::parse::endOfInput,\n                    kj::parse::sequence(\n                        kj::parse::exactChar<'.'>(),\n                        kj::parse::notLookingAt(kj::parse::endOfInput))))),\n        kj::parse::endOfInput);\n\n    kj::parse::IteratorInput<char, const char*> input(name.begin(), name.end());\n\n    kj::Array<kj::Tuple<kj::String, kj::Array<uint64_t>>> nameParts;\n    KJ_IF_MAYBE(p, parser(input)) {\n      nameParts = kj::mv(*p);\n    } else {\n      return \"invalid syntax\";\n    }"
  },
  {
    "function_name": "checkPlausibility",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "910-1079",
    "snippet": "kj::MainBuilder::Validity checkPlausibility(kj::ArrayPtr<const byte> prefix) {\n    if (flat) {\n      switch (isPlausiblyFlat(prefix)) {\n        case PLAUSIBLE:\n          break;\n        case IMPOSSIBLE:\n          if (plausibleOrWrongType(isPlausiblyPacked(prefix))) {\n            return \"The input is not in --flat format.  It looks like it is in --packed format.  \"\n                   \"Try that instead.\";\n          } else if (plausibleOrWrongType(isPlausiblyBinary(prefix))) {\n            return \"The input is not in --flat format.  It looks like it is in regular binary \"\n                   \"format.  Try removing the --flat flag.\";\n          } else {\n            return \"The input is not a Cap'n Proto message.\";\n          }\n        case IMPLAUSIBLE:\n          if (plausibleOrWrongType(isPlausiblyPacked(prefix))) {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be in --flat format.  It looks like it may\\n\"\n                \"be in --packed format.  I'll try to parse it in --flat format as you\\n\"\n                \"requested, but if it doesn't work, try --packed instead.  Use --quiet to\\n\"\n                \"suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          } else if (plausibleOrWrongType(isPlausiblyBinary(prefix))) {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be in --flat format.  It looks like it may\\n\"\n                \"be in regular binary format.  I'll try to parse it in --flat format as you\\n\"\n                \"requested, but if it doesn't work, try removing --flat.  Use --quiet to\\n\"\n                \"suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          } else {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be a Cap'n Proto message in any known\\n\"\n                \"binary format.  I'll try to parse it anyway, but if it doesn't work, please\\n\"\n                \"check your input.  Use --quiet to suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          }\n          break;\n        case WRONG_TYPE:\n          if (plausibleOrWrongType(isPlausiblyBinary(prefix))) {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be the type that you specified.  I'll try\\n\"\n                \"to parse it anyway, but if it doesn't look right, please verify that you\\n\"\n                \"have the right type.  This could also be because the input is not in --flat\\n\"\n                \"format; indeed, it looks like this input may be in regular binary format,\\n\"\n                \"so you might want to try removing --flat.  Use --quiet to suppress this\\n\"\n                \"warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          } else {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be the type that you specified.  I'll try\\n\"\n                \"to parse it anyway, but if it doesn't look right, please verify that you\\n\"\n                \"have the right type.  Use --quiet to suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          }\n          break;\n      }\n    } else if (packed) {\n      switch (isPlausiblyPacked(prefix)) {\n        case PLAUSIBLE:\n          break;\n        case IMPOSSIBLE:\n          if (plausibleOrWrongType(isPlausiblyBinary(prefix))) {\n            return \"The input is not in --packed format.  It looks like it is in regular binary \"\n                   \"format.  Try removing the --packed flag.\";\n          } else if (plausibleOrWrongType(isPlausiblyFlat(prefix))) {\n            return \"The input is not in --packed format, nor does it look like it is in regular \"\n                   \"binary format.  It looks like it could be in --flat format, although that \"\n                   \"is unusual so I could be wrong.\";\n          } else {\n            return \"The input is not a Cap'n Proto message.\";\n          }\n        case IMPLAUSIBLE:\n          if (plausibleOrWrongType(isPlausiblyBinary(prefix))) {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be in --packed format.  It looks like it\\n\"\n                \"may be in regular binary format.  I'll try to parse it in --packed format as\\n\"\n                \"you requested, but if it doesn't work, try removing --packed.  Use --quiet to\\n\"\n                \"suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          } else if (plausibleOrWrongType(isPlausiblyFlat(prefix))) {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be in --packed format, nor does it look\\n\"\n                \"like it's in regular binary format.  It looks like it could be in --flat\\n\"\n                \"format, although that is unusual so I could be wrong.  I'll try to parse\\n\"\n                \"it in --flat format as you requested, but if it doesn't work, you might\\n\"\n                \"want to try --flat, or the data may not be Cap'n Proto at all.  Use\\n\"\n                \"--quiet to suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          } else {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be a Cap'n Proto message in any known\\n\"\n                \"binary format.  I'll try to parse it anyway, but if it doesn't work, please\\n\"\n                \"check your input.  Use --quiet to suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          }\n          break;\n        case WRONG_TYPE:\n          context.warning(\n              \"*** WARNING ***\\n\"\n              \"The input data does not appear to be the type that you specified.  I'll try\\n\"\n              \"to parse it anyway, but if it doesn't look right, please verify that you\\n\"\n              \"have the right type.  Use --quiet to suppress this warning.\\n\"\n              \"*** END WARNING ***\\n\");\n          break;\n      }\n    } else {\n      switch (isPlausiblyBinary(prefix)) {\n        case PLAUSIBLE:\n          break;\n        case IMPOSSIBLE:\n          if (plausibleOrWrongType(isPlausiblyPacked(prefix))) {\n            return \"The input is not in regular binary format.  It looks like it is in --packed \"\n                   \"format.  Try adding the --packed flag.\";\n          } else if (plausibleOrWrongType(isPlausiblyFlat(prefix))) {\n            return \"The input is not in regular binary format, nor does it look like it is in \"\n                   \"--packed format.  It looks like it could be in --flat format, although that \"\n                   \"is unusual so I could be wrong.\";\n          } else {\n            return \"The input is not a Cap'n Proto message.\";\n          }\n        case IMPLAUSIBLE:\n          if (plausibleOrWrongType(isPlausiblyPacked(prefix))) {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be in regular binary format.  It looks like\\n\"\n                \"it may be in --packed format.  I'll try to parse it in regular format as you\\n\"\n                \"requested, but if it doesn't work, try adding --packed.  Use --quiet to\\n\"\n                \"suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          } else if (plausibleOrWrongType(isPlausiblyFlat(prefix))) {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be in regular binary format, nor does it\\n\"\n                \"look like it's in --packed format.  It looks like it could be in --flat\\n\"\n                \"format, although that is unusual so I could be wrong.  I'll try to parse\\n\"\n                \"it in regular format as you requested, but if it doesn't work, you might\\n\"\n                \"want to try --flat, or the data may not be Cap'n Proto at all.  Use\\n\"\n                \"--quiet to suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          } else {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be a Cap'n Proto message in any known\\n\"\n                \"binary format.  I'll try to parse it anyway, but if it doesn't work, please\\n\"\n                \"check your input.  Use --quiet to suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          }\n          break;\n        case WRONG_TYPE:\n          context.warning(\n              \"*** WARNING ***\\n\"\n              \"The input data does not appear to be the type that you specified.  I'll try\\n\"\n              \"to parse it anyway, but if it doesn't look right, please verify that you\\n\"\n              \"have the right type.  Use --quiet to suppress this warning.\\n\"\n              \"*** END WARNING ***\\n\");\n          break;\n      }\n    }\n\n    return true;\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "MallocMessageBuilder message;",
      "bool binary = false;",
      "bool flat = false;",
      "bool packed = false;",
      "bool quiet = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"*** WARNING ***\\n\"\n              \"The input data does not appear to be the type that you specified.  I'll try\\n\"\n              \"to parse it anyway, but if it doesn't look right, please verify that you\\n\"\n              \"have the right type.  Use --quiet to suppress this warning.\\n\"\n              \"*** END WARNING ***\\n\""
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"*** WARNING ***\\n\"\n                \"The input data does not appear to be a Cap'n Proto message in any known\\n\"\n                \"binary format.  I'll try to parse it anyway, but if it doesn't work, please\\n\"\n                \"check your input.  Use --quiet to suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\""
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"*** WARNING ***\\n\"\n                \"The input data does not appear to be in regular binary format, nor does it\\n\"\n                \"look like it's in --packed format.  It looks like it could be in --flat\\n\"\n                \"format, although that is unusual so I could be wrong.  I'll try to parse\\n\"\n                \"it in regular format as you requested, but if it doesn't work, you might\\n\"\n                \"want to try --flat, or the data may not be Cap'n Proto at all.  Use\\n\"\n                \"--quiet to suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\""
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plausibleOrWrongType",
          "args": [
            "isPlausiblyFlat(prefix)"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "plausibleOrWrongType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
          "lines": "760-762",
          "snippet": "bool plausibleOrWrongType(Plausibility p) {\n    return p == PLAUSIBLE || p == WRONG_TYPE;\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <process.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/main.h>",
            "#include <iostream>",
            "#include \"../message.h\"",
            "#include <kj/debug.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/vector.h>",
            "#include <capnp/schema.capnp.h>",
            "#include <capnp/pretty-print.h>",
            "#include \"node-translator.h\"",
            "#include \"module-loader.h\"",
            "#include \"compiler.h\"",
            "#include \"parser.h\"",
            "#include \"lexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nbool plausibleOrWrongType(Plausibility p) {\n    return p == PLAUSIBLE || p == WRONG_TYPE;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "isPlausiblyFlat",
          "args": [
            "prefix"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "isPlausiblyFlat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
          "lines": "764-821",
          "snippet": "Plausibility isPlausiblyFlat(kj::ArrayPtr<const byte> prefix, uint segmentCount = 1) {\n    if (prefix.size() < 8) {\n      // Not enough prefix to say.\n      return PLAUSIBLE;\n    }\n\n    if ((prefix[0] & 3) == 2) {\n      // Far pointer.  Verify the segment ID.\n      uint32_t segmentId = prefix[4] | (prefix[5] << 8)\n                         | (prefix[6] << 16) | (prefix[7] << 24);\n      if (segmentId == 0 || segmentId >= segmentCount) {\n        return IMPOSSIBLE;\n      } else {\n        return PLAUSIBLE;\n      }\n    }\n\n    if ((prefix[0] & 3) != 0) {\n      // Not a struct pointer.\n      return IMPOSSIBLE;\n    }\n    if ((prefix[3] & 0x80) != 0) {\n      // Offset is negative (invalid).\n      return IMPOSSIBLE;\n    }\n    if ((prefix[3] & 0xe0) != 0) {\n      // Offset is over a gigabyte (implausible).\n      return IMPLAUSIBLE;\n    }\n\n    uint data = prefix[4] | (prefix[5] << 8);\n    uint pointers = prefix[6] | (prefix[7] << 8);\n\n    if (data + pointers > 2048) {\n      // Root struct is huge (over 16 KiB).\n      return IMPLAUSIBLE;\n    }\n\n    auto structSchema = rootType.getProto().getStruct();\n    if ((data < structSchema.getDataWordCount() && pointers > structSchema.getPointerCount()) ||\n        (data > structSchema.getDataWordCount() && pointers < structSchema.getPointerCount())) {\n      // Struct is neither older nor newer than the schema.\n      return WRONG_TYPE;\n    }\n\n    if (data > structSchema.getDataWordCount() &&\n        data - structSchema.getDataWordCount() > 128) {\n      // Data section appears to have grown by 1k (128 words).  This seems implausible.\n      return WRONG_TYPE;\n    }\n    if (pointers > structSchema.getPointerCount() &&\n        pointers - structSchema.getPointerCount() > 128) {\n      // Pointer section appears to have grown by 1k (128 words).  This seems implausible.\n      return WRONG_TYPE;\n    }\n\n    return PLAUSIBLE;\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <process.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/main.h>",
            "#include <iostream>",
            "#include \"../message.h\"",
            "#include <kj/debug.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/vector.h>",
            "#include <capnp/schema.capnp.h>",
            "#include <capnp/pretty-print.h>",
            "#include \"node-translator.h\"",
            "#include \"module-loader.h\"",
            "#include \"compiler.h\"",
            "#include \"parser.h\"",
            "#include \"lexer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Schema schema = compiler->getLoader().get(scopeId);",
            "StructSchema rootType;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nSchema schema = compiler->getLoader().get(scopeId);\nStructSchema rootType;\n\nPlausibility isPlausiblyFlat(kj::ArrayPtr<const byte> prefix, uint segmentCount = 1) {\n    if (prefix.size() < 8) {\n      // Not enough prefix to say.\n      return PLAUSIBLE;\n    }\n\n    if ((prefix[0] & 3) == 2) {\n      // Far pointer.  Verify the segment ID.\n      uint32_t segmentId = prefix[4] | (prefix[5] << 8)\n                         | (prefix[6] << 16) | (prefix[7] << 24);\n      if (segmentId == 0 || segmentId >= segmentCount) {\n        return IMPOSSIBLE;\n      } else {\n        return PLAUSIBLE;\n      }\n    }\n\n    if ((prefix[0] & 3) != 0) {\n      // Not a struct pointer.\n      return IMPOSSIBLE;\n    }\n    if ((prefix[3] & 0x80) != 0) {\n      // Offset is negative (invalid).\n      return IMPOSSIBLE;\n    }\n    if ((prefix[3] & 0xe0) != 0) {\n      // Offset is over a gigabyte (implausible).\n      return IMPLAUSIBLE;\n    }\n\n    uint data = prefix[4] | (prefix[5] << 8);\n    uint pointers = prefix[6] | (prefix[7] << 8);\n\n    if (data + pointers > 2048) {\n      // Root struct is huge (over 16 KiB).\n      return IMPLAUSIBLE;\n    }\n\n    auto structSchema = rootType.getProto().getStruct();\n    if ((data < structSchema.getDataWordCount() && pointers > structSchema.getPointerCount()) ||\n        (data > structSchema.getDataWordCount() && pointers < structSchema.getPointerCount())) {\n      // Struct is neither older nor newer than the schema.\n      return WRONG_TYPE;\n    }\n\n    if (data > structSchema.getDataWordCount() &&\n        data - structSchema.getDataWordCount() > 128) {\n      // Data section appears to have grown by 1k (128 words).  This seems implausible.\n      return WRONG_TYPE;\n    }\n    if (pointers > structSchema.getPointerCount() &&\n        pointers - structSchema.getPointerCount() > 128) {\n      // Pointer section appears to have grown by 1k (128 words).  This seems implausible.\n      return WRONG_TYPE;\n    }\n\n    return PLAUSIBLE;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"*** WARNING ***\\n\"\n                \"The input data does not appear to be in regular binary format.  It looks like\\n\"\n                \"it may be in --packed format.  I'll try to parse it in regular format as you\\n\"\n                \"requested, but if it doesn't work, try adding --packed.  Use --quiet to\\n\"\n                \"suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\""
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isPlausiblyPacked",
          "args": [
            "prefix"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "isPlausiblyPacked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
          "lines": "866-908",
          "snippet": "Plausibility isPlausiblyPacked(kj::ArrayPtr<const byte> prefix) {\n    kj::Vector<byte> unpacked;\n\n    // Try to unpack a prefix so that we can check it.\n    const byte* pos = prefix.begin();\n    const byte* end = prefix.end();\n    if (end - pos > 1024) {\n      // Don't bother unpacking more than 1k.\n      end = pos + 1024;\n    }\n    while (pos < end) {\n      byte tag = *pos++;\n      for (uint i = 0; i < 8 && pos < end; i++) {\n        if (tag & (1 << i)) {\n          byte b = *pos++;\n          if (b == 0) {\n            // A zero byte should have been deflated away.\n            return IMPOSSIBLE;\n          }\n          unpacked.add(b);\n        } else {\n          unpacked.add(0);\n        }\n      }\n\n      if (pos == end) {\n        break;\n      }\n\n      if (tag == 0) {\n        uint count = *pos++ * 8;\n        unpacked.addAll(kj::repeat(byte(0), count));\n      } else if (tag == 0xff) {\n        uint count = *pos++ * 8;\n        size_t available = end - pos;\n        uint n = kj::min(count, available);\n        unpacked.addAll(pos, pos + n);\n        pos += n;\n      }\n    }\n\n    return isPlausiblyBinary(unpacked);\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <process.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/main.h>",
            "#include <iostream>",
            "#include \"../message.h\"",
            "#include <kj/debug.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/vector.h>",
            "#include <capnp/schema.capnp.h>",
            "#include <capnp/pretty-print.h>",
            "#include \"node-translator.h\"",
            "#include \"module-loader.h\"",
            "#include \"compiler.h\"",
            "#include \"parser.h\"",
            "#include \"lexer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CapnpParser::ParserInput parserInput(tokens.begin(), tokens.end());",
            "auto pos = nameParts.begin();"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nCapnpParser::ParserInput parserInput(tokens.begin(), tokens.end());\nauto pos = nameParts.begin();\n\nPlausibility isPlausiblyPacked(kj::ArrayPtr<const byte> prefix) {\n    kj::Vector<byte> unpacked;\n\n    // Try to unpack a prefix so that we can check it.\n    const byte* pos = prefix.begin();\n    const byte* end = prefix.end();\n    if (end - pos > 1024) {\n      // Don't bother unpacking more than 1k.\n      end = pos + 1024;\n    }\n    while (pos < end) {\n      byte tag = *pos++;\n      for (uint i = 0; i < 8 && pos < end; i++) {\n        if (tag & (1 << i)) {\n          byte b = *pos++;\n          if (b == 0) {\n            // A zero byte should have been deflated away.\n            return IMPOSSIBLE;\n          }\n          unpacked.add(b);\n        } else {\n          unpacked.add(0);\n        }\n      }\n\n      if (pos == end) {\n        break;\n      }\n\n      if (tag == 0) {\n        uint count = *pos++ * 8;\n        unpacked.addAll(kj::repeat(byte(0), count));\n      } else if (tag == 0xff) {\n        uint count = *pos++ * 8;\n        size_t available = end - pos;\n        uint n = kj::min(count, available);\n        unpacked.addAll(pos, pos + n);\n        pos += n;\n      }\n    }\n\n    return isPlausiblyBinary(unpacked);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "isPlausiblyBinary",
          "args": [
            "prefix"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "isPlausiblyBinary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
          "lines": "823-864",
          "snippet": "Plausibility isPlausiblyBinary(kj::ArrayPtr<const byte> prefix) {\n    if (prefix.size() < 8) {\n      // Not enough prefix to say.\n      return PLAUSIBLE;\n    }\n\n    uint32_t segmentCount = prefix[0] | (prefix[1] << 8)\n                          | (prefix[2] << 16) | (prefix[3] << 24);\n\n    // Actually, the bytes store segmentCount - 1.\n    ++segmentCount;\n\n    if (segmentCount > 65536) {\n      // While technically possible, this is so implausible that we should mark it impossible.\n      // This helps to make sure we fail fast on packed input.\n      return IMPOSSIBLE;\n    } else if (segmentCount > 256) {\n      // Implausible segment count.\n      return IMPLAUSIBLE;\n    }\n\n    uint32_t segment0Size = prefix[4] | (prefix[5] << 8)\n                          | (prefix[6] << 16) | (prefix[7] << 24);\n\n    if (segment0Size > (1 << 27)) {\n      // Segment larger than 1G seems implausible.\n      return IMPLAUSIBLE;\n    }\n\n    uint32_t segment0Offset = 4 + segmentCount * 4;\n    if (segment0Offset % 8 != 0) {\n      segment0Offset += 4;\n    }\n    KJ_ASSERT(segment0Offset % 8 == 0);\n\n    if (prefix.size() < segment0Offset + 8) {\n      // Segment 0 is past our prefix, so we can't check it.\n      return PLAUSIBLE;\n    }\n\n    return isPlausiblyFlat(prefix.slice(segment0Offset, prefix.size()), segmentCount);\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <process.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/main.h>",
            "#include <iostream>",
            "#include \"../message.h\"",
            "#include <kj/debug.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/vector.h>",
            "#include <capnp/schema.capnp.h>",
            "#include <capnp/pretty-print.h>",
            "#include \"node-translator.h\"",
            "#include \"module-loader.h\"",
            "#include \"compiler.h\"",
            "#include \"parser.h\"",
            "#include \"lexer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool packed = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nbool packed = false;\n\nPlausibility isPlausiblyBinary(kj::ArrayPtr<const byte> prefix) {\n    if (prefix.size() < 8) {\n      // Not enough prefix to say.\n      return PLAUSIBLE;\n    }\n\n    uint32_t segmentCount = prefix[0] | (prefix[1] << 8)\n                          | (prefix[2] << 16) | (prefix[3] << 24);\n\n    // Actually, the bytes store segmentCount - 1.\n    ++segmentCount;\n\n    if (segmentCount > 65536) {\n      // While technically possible, this is so implausible that we should mark it impossible.\n      // This helps to make sure we fail fast on packed input.\n      return IMPOSSIBLE;\n    } else if (segmentCount > 256) {\n      // Implausible segment count.\n      return IMPLAUSIBLE;\n    }\n\n    uint32_t segment0Size = prefix[4] | (prefix[5] << 8)\n                          | (prefix[6] << 16) | (prefix[7] << 24);\n\n    if (segment0Size > (1 << 27)) {\n      // Segment larger than 1G seems implausible.\n      return IMPLAUSIBLE;\n    }\n\n    uint32_t segment0Offset = 4 + segmentCount * 4;\n    if (segment0Offset % 8 != 0) {\n      segment0Offset += 4;\n    }\n    KJ_ASSERT(segment0Offset % 8 == 0);\n\n    if (prefix.size() < segment0Offset + 8) {\n      // Segment 0 is past our prefix, so we can't check it.\n      return PLAUSIBLE;\n    }\n\n    return isPlausiblyFlat(prefix.slice(segment0Offset, prefix.size()), segmentCount);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"*** WARNING ***\\n\"\n              \"The input data does not appear to be the type that you specified.  I'll try\\n\"\n              \"to parse it anyway, but if it doesn't look right, please verify that you\\n\"\n              \"have the right type.  Use --quiet to suppress this warning.\\n\"\n              \"*** END WARNING ***\\n\""
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"*** WARNING ***\\n\"\n                \"The input data does not appear to be a Cap'n Proto message in any known\\n\"\n                \"binary format.  I'll try to parse it anyway, but if it doesn't work, please\\n\"\n                \"check your input.  Use --quiet to suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\""
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"*** WARNING ***\\n\"\n                \"The input data does not appear to be in --packed format, nor does it look\\n\"\n                \"like it's in regular binary format.  It looks like it could be in --flat\\n\"\n                \"format, although that is unusual so I could be wrong.  I'll try to parse\\n\"\n                \"it in --flat format as you requested, but if it doesn't work, you might\\n\"\n                \"want to try --flat, or the data may not be Cap'n Proto at all.  Use\\n\"\n                \"--quiet to suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\""
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"*** WARNING ***\\n\"\n                \"The input data does not appear to be in --packed format.  It looks like it\\n\"\n                \"may be in regular binary format.  I'll try to parse it in --packed format as\\n\"\n                \"you requested, but if it doesn't work, try removing --packed.  Use --quiet to\\n\"\n                \"suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\""
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"*** WARNING ***\\n\"\n                \"The input data does not appear to be the type that you specified.  I'll try\\n\"\n                \"to parse it anyway, but if it doesn't look right, please verify that you\\n\"\n                \"have the right type.  Use --quiet to suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\""
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"*** WARNING ***\\n\"\n                \"The input data does not appear to be the type that you specified.  I'll try\\n\"\n                \"to parse it anyway, but if it doesn't look right, please verify that you\\n\"\n                \"have the right type.  This could also be because the input is not in --flat\\n\"\n                \"format; indeed, it looks like this input may be in regular binary format,\\n\"\n                \"so you might want to try removing --flat.  Use --quiet to suppress this\\n\"\n                \"warning.\\n\"\n                \"*** END WARNING ***\\n\""
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"*** WARNING ***\\n\"\n                \"The input data does not appear to be a Cap'n Proto message in any known\\n\"\n                \"binary format.  I'll try to parse it anyway, but if it doesn't work, please\\n\"\n                \"check your input.  Use --quiet to suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\""
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"*** WARNING ***\\n\"\n                \"The input data does not appear to be in --flat format.  It looks like it may\\n\"\n                \"be in regular binary format.  I'll try to parse it in --flat format as you\\n\"\n                \"requested, but if it doesn't work, try removing --flat.  Use --quiet to\\n\"\n                \"suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\""
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "\"*** WARNING ***\\n\"\n                \"The input data does not appear to be in --flat format.  It looks like it may\\n\"\n                \"be in --packed format.  I'll try to parse it in --flat format as you\\n\"\n                \"requested, but if it doesn't work, try --packed instead.  Use --quiet to\\n\"\n                \"suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\""
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nMallocMessageBuilder message;\nbool binary = false;\nbool flat = false;\nbool packed = false;\nbool quiet = false;\n\nkj::MainBuilder::Validity checkPlausibility(kj::ArrayPtr<const byte> prefix) {\n    if (flat) {\n      switch (isPlausiblyFlat(prefix)) {\n        case PLAUSIBLE:\n          break;\n        case IMPOSSIBLE:\n          if (plausibleOrWrongType(isPlausiblyPacked(prefix))) {\n            return \"The input is not in --flat format.  It looks like it is in --packed format.  \"\n                   \"Try that instead.\";\n          } else if (plausibleOrWrongType(isPlausiblyBinary(prefix))) {\n            return \"The input is not in --flat format.  It looks like it is in regular binary \"\n                   \"format.  Try removing the --flat flag.\";\n          } else {\n            return \"The input is not a Cap'n Proto message.\";\n          }\n        case IMPLAUSIBLE:\n          if (plausibleOrWrongType(isPlausiblyPacked(prefix))) {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be in --flat format.  It looks like it may\\n\"\n                \"be in --packed format.  I'll try to parse it in --flat format as you\\n\"\n                \"requested, but if it doesn't work, try --packed instead.  Use --quiet to\\n\"\n                \"suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          } else if (plausibleOrWrongType(isPlausiblyBinary(prefix))) {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be in --flat format.  It looks like it may\\n\"\n                \"be in regular binary format.  I'll try to parse it in --flat format as you\\n\"\n                \"requested, but if it doesn't work, try removing --flat.  Use --quiet to\\n\"\n                \"suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          } else {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be a Cap'n Proto message in any known\\n\"\n                \"binary format.  I'll try to parse it anyway, but if it doesn't work, please\\n\"\n                \"check your input.  Use --quiet to suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          }\n          break;\n        case WRONG_TYPE:\n          if (plausibleOrWrongType(isPlausiblyBinary(prefix))) {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be the type that you specified.  I'll try\\n\"\n                \"to parse it anyway, but if it doesn't look right, please verify that you\\n\"\n                \"have the right type.  This could also be because the input is not in --flat\\n\"\n                \"format; indeed, it looks like this input may be in regular binary format,\\n\"\n                \"so you might want to try removing --flat.  Use --quiet to suppress this\\n\"\n                \"warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          } else {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be the type that you specified.  I'll try\\n\"\n                \"to parse it anyway, but if it doesn't look right, please verify that you\\n\"\n                \"have the right type.  Use --quiet to suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          }\n          break;\n      }\n    } else if (packed) {\n      switch (isPlausiblyPacked(prefix)) {\n        case PLAUSIBLE:\n          break;\n        case IMPOSSIBLE:\n          if (plausibleOrWrongType(isPlausiblyBinary(prefix))) {\n            return \"The input is not in --packed format.  It looks like it is in regular binary \"\n                   \"format.  Try removing the --packed flag.\";\n          } else if (plausibleOrWrongType(isPlausiblyFlat(prefix))) {\n            return \"The input is not in --packed format, nor does it look like it is in regular \"\n                   \"binary format.  It looks like it could be in --flat format, although that \"\n                   \"is unusual so I could be wrong.\";\n          } else {\n            return \"The input is not a Cap'n Proto message.\";\n          }\n        case IMPLAUSIBLE:\n          if (plausibleOrWrongType(isPlausiblyBinary(prefix))) {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be in --packed format.  It looks like it\\n\"\n                \"may be in regular binary format.  I'll try to parse it in --packed format as\\n\"\n                \"you requested, but if it doesn't work, try removing --packed.  Use --quiet to\\n\"\n                \"suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          } else if (plausibleOrWrongType(isPlausiblyFlat(prefix))) {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be in --packed format, nor does it look\\n\"\n                \"like it's in regular binary format.  It looks like it could be in --flat\\n\"\n                \"format, although that is unusual so I could be wrong.  I'll try to parse\\n\"\n                \"it in --flat format as you requested, but if it doesn't work, you might\\n\"\n                \"want to try --flat, or the data may not be Cap'n Proto at all.  Use\\n\"\n                \"--quiet to suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          } else {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be a Cap'n Proto message in any known\\n\"\n                \"binary format.  I'll try to parse it anyway, but if it doesn't work, please\\n\"\n                \"check your input.  Use --quiet to suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          }\n          break;\n        case WRONG_TYPE:\n          context.warning(\n              \"*** WARNING ***\\n\"\n              \"The input data does not appear to be the type that you specified.  I'll try\\n\"\n              \"to parse it anyway, but if it doesn't look right, please verify that you\\n\"\n              \"have the right type.  Use --quiet to suppress this warning.\\n\"\n              \"*** END WARNING ***\\n\");\n          break;\n      }\n    } else {\n      switch (isPlausiblyBinary(prefix)) {\n        case PLAUSIBLE:\n          break;\n        case IMPOSSIBLE:\n          if (plausibleOrWrongType(isPlausiblyPacked(prefix))) {\n            return \"The input is not in regular binary format.  It looks like it is in --packed \"\n                   \"format.  Try adding the --packed flag.\";\n          } else if (plausibleOrWrongType(isPlausiblyFlat(prefix))) {\n            return \"The input is not in regular binary format, nor does it look like it is in \"\n                   \"--packed format.  It looks like it could be in --flat format, although that \"\n                   \"is unusual so I could be wrong.\";\n          } else {\n            return \"The input is not a Cap'n Proto message.\";\n          }\n        case IMPLAUSIBLE:\n          if (plausibleOrWrongType(isPlausiblyPacked(prefix))) {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be in regular binary format.  It looks like\\n\"\n                \"it may be in --packed format.  I'll try to parse it in regular format as you\\n\"\n                \"requested, but if it doesn't work, try adding --packed.  Use --quiet to\\n\"\n                \"suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          } else if (plausibleOrWrongType(isPlausiblyFlat(prefix))) {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be in regular binary format, nor does it\\n\"\n                \"look like it's in --packed format.  It looks like it could be in --flat\\n\"\n                \"format, although that is unusual so I could be wrong.  I'll try to parse\\n\"\n                \"it in regular format as you requested, but if it doesn't work, you might\\n\"\n                \"want to try --flat, or the data may not be Cap'n Proto at all.  Use\\n\"\n                \"--quiet to suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          } else {\n            context.warning(\n                \"*** WARNING ***\\n\"\n                \"The input data does not appear to be a Cap'n Proto message in any known\\n\"\n                \"binary format.  I'll try to parse it anyway, but if it doesn't work, please\\n\"\n                \"check your input.  Use --quiet to suppress this warning.\\n\"\n                \"*** END WARNING ***\\n\");\n          }\n          break;\n        case WRONG_TYPE:\n          context.warning(\n              \"*** WARNING ***\\n\"\n              \"The input data does not appear to be the type that you specified.  I'll try\\n\"\n              \"to parse it anyway, but if it doesn't look right, please verify that you\\n\"\n              \"have the right type.  Use --quiet to suppress this warning.\\n\"\n              \"*** END WARNING ***\\n\");\n          break;\n      }\n    }\n\n    return true;\n  }"
  },
  {
    "function_name": "isPlausiblyPacked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "866-908",
    "snippet": "Plausibility isPlausiblyPacked(kj::ArrayPtr<const byte> prefix) {\n    kj::Vector<byte> unpacked;\n\n    // Try to unpack a prefix so that we can check it.\n    const byte* pos = prefix.begin();\n    const byte* end = prefix.end();\n    if (end - pos > 1024) {\n      // Don't bother unpacking more than 1k.\n      end = pos + 1024;\n    }\n    while (pos < end) {\n      byte tag = *pos++;\n      for (uint i = 0; i < 8 && pos < end; i++) {\n        if (tag & (1 << i)) {\n          byte b = *pos++;\n          if (b == 0) {\n            // A zero byte should have been deflated away.\n            return IMPOSSIBLE;\n          }\n          unpacked.add(b);\n        } else {\n          unpacked.add(0);\n        }\n      }\n\n      if (pos == end) {\n        break;\n      }\n\n      if (tag == 0) {\n        uint count = *pos++ * 8;\n        unpacked.addAll(kj::repeat(byte(0), count));\n      } else if (tag == 0xff) {\n        uint count = *pos++ * 8;\n        size_t available = end - pos;\n        uint n = kj::min(count, available);\n        unpacked.addAll(pos, pos + n);\n        pos += n;\n      }\n    }\n\n    return isPlausiblyBinary(unpacked);\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CapnpParser::ParserInput parserInput(tokens.begin(), tokens.end());",
      "auto pos = nameParts.begin();"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isPlausiblyBinary",
          "args": [
            "unpacked"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "isPlausiblyBinary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
          "lines": "823-864",
          "snippet": "Plausibility isPlausiblyBinary(kj::ArrayPtr<const byte> prefix) {\n    if (prefix.size() < 8) {\n      // Not enough prefix to say.\n      return PLAUSIBLE;\n    }\n\n    uint32_t segmentCount = prefix[0] | (prefix[1] << 8)\n                          | (prefix[2] << 16) | (prefix[3] << 24);\n\n    // Actually, the bytes store segmentCount - 1.\n    ++segmentCount;\n\n    if (segmentCount > 65536) {\n      // While technically possible, this is so implausible that we should mark it impossible.\n      // This helps to make sure we fail fast on packed input.\n      return IMPOSSIBLE;\n    } else if (segmentCount > 256) {\n      // Implausible segment count.\n      return IMPLAUSIBLE;\n    }\n\n    uint32_t segment0Size = prefix[4] | (prefix[5] << 8)\n                          | (prefix[6] << 16) | (prefix[7] << 24);\n\n    if (segment0Size > (1 << 27)) {\n      // Segment larger than 1G seems implausible.\n      return IMPLAUSIBLE;\n    }\n\n    uint32_t segment0Offset = 4 + segmentCount * 4;\n    if (segment0Offset % 8 != 0) {\n      segment0Offset += 4;\n    }\n    KJ_ASSERT(segment0Offset % 8 == 0);\n\n    if (prefix.size() < segment0Offset + 8) {\n      // Segment 0 is past our prefix, so we can't check it.\n      return PLAUSIBLE;\n    }\n\n    return isPlausiblyFlat(prefix.slice(segment0Offset, prefix.size()), segmentCount);\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <process.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/main.h>",
            "#include <iostream>",
            "#include \"../message.h\"",
            "#include <kj/debug.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/vector.h>",
            "#include <capnp/schema.capnp.h>",
            "#include <capnp/pretty-print.h>",
            "#include \"node-translator.h\"",
            "#include \"module-loader.h\"",
            "#include \"compiler.h\"",
            "#include \"parser.h\"",
            "#include \"lexer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool packed = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nbool packed = false;\n\nPlausibility isPlausiblyBinary(kj::ArrayPtr<const byte> prefix) {\n    if (prefix.size() < 8) {\n      // Not enough prefix to say.\n      return PLAUSIBLE;\n    }\n\n    uint32_t segmentCount = prefix[0] | (prefix[1] << 8)\n                          | (prefix[2] << 16) | (prefix[3] << 24);\n\n    // Actually, the bytes store segmentCount - 1.\n    ++segmentCount;\n\n    if (segmentCount > 65536) {\n      // While technically possible, this is so implausible that we should mark it impossible.\n      // This helps to make sure we fail fast on packed input.\n      return IMPOSSIBLE;\n    } else if (segmentCount > 256) {\n      // Implausible segment count.\n      return IMPLAUSIBLE;\n    }\n\n    uint32_t segment0Size = prefix[4] | (prefix[5] << 8)\n                          | (prefix[6] << 16) | (prefix[7] << 24);\n\n    if (segment0Size > (1 << 27)) {\n      // Segment larger than 1G seems implausible.\n      return IMPLAUSIBLE;\n    }\n\n    uint32_t segment0Offset = 4 + segmentCount * 4;\n    if (segment0Offset % 8 != 0) {\n      segment0Offset += 4;\n    }\n    KJ_ASSERT(segment0Offset % 8 == 0);\n\n    if (prefix.size() < segment0Offset + 8) {\n      // Segment 0 is past our prefix, so we can't check it.\n      return PLAUSIBLE;\n    }\n\n    return isPlausiblyFlat(prefix.slice(segment0Offset, prefix.size()), segmentCount);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "unpacked.addAll",
          "args": [
            "pos",
            "pos + n"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "addAll",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "81-85",
          "snippet": "inline void addAll(Iterator begin, Iterator end) {\n    size_t needed = builder.size() + (end - begin);\n    if (needed > builder.capacity()) grow(needed);\n    builder.addAll(begin, end);\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline void addAll(Iterator begin, Iterator end) {\n      size_t needed = builder.size() + (end - begin);\n      if (needed > builder.capacity()) grow(needed);\n      builder.addAll(begin, end);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::min",
          "args": [
            "count",
            "available"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "473-475",
          "snippet": "auto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unpacked.addAll",
          "args": [
            "kj::repeat(byte(0), count)"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "addAll",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "357-359",
          "snippet": "void addAll(Container&& container) {\n    addAll(container.begin(), container.end());\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  void addAll(Container&& container) {\n      addAll(container.begin(), container.end());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::repeat",
          "args": [
            "byte(0)",
            "count"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "repeat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "703-708",
          "snippet": "inline constexpr Repeat<Decay<T>> repeat(T&& value, size_t count) {\n  // Returns a fake iterable which contains `count` repeats of `value`.  Useful for e.g. creating\n  // a bunch of spaces:  `kj::repeat(' ', indent * 2)`\n\n  return Repeat<Decay<T>>(value, count);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Repeat<Decay<T>> repeat(T&& value, size_t count) {\n  // Returns a fake iterable which contains `count` repeats of `value`.  Useful for e.g. creating\n  // a bunch of spaces:  `kj::repeat(' ', indent * 2)`\n\n  return Repeat<Decay<T>>(value, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "byte",
          "args": [
            "0"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpacked.add",
          "args": [
            "0"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefix.end",
          "args": [],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "77-77",
          "snippet": "inline Iterator end() const { return Iterator(amount); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator end() const { return Iterator(amount); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefix.begin",
          "args": [],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "76-76",
          "snippet": "inline Iterator begin() const { return Iterator(0); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nCapnpParser::ParserInput parserInput(tokens.begin(), tokens.end());\nauto pos = nameParts.begin();\n\nPlausibility isPlausiblyPacked(kj::ArrayPtr<const byte> prefix) {\n    kj::Vector<byte> unpacked;\n\n    // Try to unpack a prefix so that we can check it.\n    const byte* pos = prefix.begin();\n    const byte* end = prefix.end();\n    if (end - pos > 1024) {\n      // Don't bother unpacking more than 1k.\n      end = pos + 1024;\n    }\n    while (pos < end) {\n      byte tag = *pos++;\n      for (uint i = 0; i < 8 && pos < end; i++) {\n        if (tag & (1 << i)) {\n          byte b = *pos++;\n          if (b == 0) {\n            // A zero byte should have been deflated away.\n            return IMPOSSIBLE;\n          }\n          unpacked.add(b);\n        } else {\n          unpacked.add(0);\n        }\n      }\n\n      if (pos == end) {\n        break;\n      }\n\n      if (tag == 0) {\n        uint count = *pos++ * 8;\n        unpacked.addAll(kj::repeat(byte(0), count));\n      } else if (tag == 0xff) {\n        uint count = *pos++ * 8;\n        size_t available = end - pos;\n        uint n = kj::min(count, available);\n        unpacked.addAll(pos, pos + n);\n        pos += n;\n      }\n    }\n\n    return isPlausiblyBinary(unpacked);\n  }"
  },
  {
    "function_name": "isPlausiblyBinary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "823-864",
    "snippet": "Plausibility isPlausiblyBinary(kj::ArrayPtr<const byte> prefix) {\n    if (prefix.size() < 8) {\n      // Not enough prefix to say.\n      return PLAUSIBLE;\n    }\n\n    uint32_t segmentCount = prefix[0] | (prefix[1] << 8)\n                          | (prefix[2] << 16) | (prefix[3] << 24);\n\n    // Actually, the bytes store segmentCount - 1.\n    ++segmentCount;\n\n    if (segmentCount > 65536) {\n      // While technically possible, this is so implausible that we should mark it impossible.\n      // This helps to make sure we fail fast on packed input.\n      return IMPOSSIBLE;\n    } else if (segmentCount > 256) {\n      // Implausible segment count.\n      return IMPLAUSIBLE;\n    }\n\n    uint32_t segment0Size = prefix[4] | (prefix[5] << 8)\n                          | (prefix[6] << 16) | (prefix[7] << 24);\n\n    if (segment0Size > (1 << 27)) {\n      // Segment larger than 1G seems implausible.\n      return IMPLAUSIBLE;\n    }\n\n    uint32_t segment0Offset = 4 + segmentCount * 4;\n    if (segment0Offset % 8 != 0) {\n      segment0Offset += 4;\n    }\n    KJ_ASSERT(segment0Offset % 8 == 0);\n\n    if (prefix.size() < segment0Offset + 8) {\n      // Segment 0 is past our prefix, so we can't check it.\n      return PLAUSIBLE;\n    }\n\n    return isPlausiblyFlat(prefix.slice(segment0Offset, prefix.size()), segmentCount);\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool packed = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isPlausiblyFlat",
          "args": [
            "prefix.slice(segment0Offset, prefix.size())",
            "segmentCount"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prefix.slice",
          "args": [
            "segment0Offset",
            "prefix.size()"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefix.size",
          "args": [],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "segment0Offset % 8 == 0"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nbool packed = false;\n\nPlausibility isPlausiblyBinary(kj::ArrayPtr<const byte> prefix) {\n    if (prefix.size() < 8) {\n      // Not enough prefix to say.\n      return PLAUSIBLE;\n    }\n\n    uint32_t segmentCount = prefix[0] | (prefix[1] << 8)\n                          | (prefix[2] << 16) | (prefix[3] << 24);\n\n    // Actually, the bytes store segmentCount - 1.\n    ++segmentCount;\n\n    if (segmentCount > 65536) {\n      // While technically possible, this is so implausible that we should mark it impossible.\n      // This helps to make sure we fail fast on packed input.\n      return IMPOSSIBLE;\n    } else if (segmentCount > 256) {\n      // Implausible segment count.\n      return IMPLAUSIBLE;\n    }\n\n    uint32_t segment0Size = prefix[4] | (prefix[5] << 8)\n                          | (prefix[6] << 16) | (prefix[7] << 24);\n\n    if (segment0Size > (1 << 27)) {\n      // Segment larger than 1G seems implausible.\n      return IMPLAUSIBLE;\n    }\n\n    uint32_t segment0Offset = 4 + segmentCount * 4;\n    if (segment0Offset % 8 != 0) {\n      segment0Offset += 4;\n    }\n    KJ_ASSERT(segment0Offset % 8 == 0);\n\n    if (prefix.size() < segment0Offset + 8) {\n      // Segment 0 is past our prefix, so we can't check it.\n      return PLAUSIBLE;\n    }\n\n    return isPlausiblyFlat(prefix.slice(segment0Offset, prefix.size()), segmentCount);\n  }"
  },
  {
    "function_name": "isPlausiblyFlat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "764-821",
    "snippet": "Plausibility isPlausiblyFlat(kj::ArrayPtr<const byte> prefix, uint segmentCount = 1) {\n    if (prefix.size() < 8) {\n      // Not enough prefix to say.\n      return PLAUSIBLE;\n    }\n\n    if ((prefix[0] & 3) == 2) {\n      // Far pointer.  Verify the segment ID.\n      uint32_t segmentId = prefix[4] | (prefix[5] << 8)\n                         | (prefix[6] << 16) | (prefix[7] << 24);\n      if (segmentId == 0 || segmentId >= segmentCount) {\n        return IMPOSSIBLE;\n      } else {\n        return PLAUSIBLE;\n      }\n    }\n\n    if ((prefix[0] & 3) != 0) {\n      // Not a struct pointer.\n      return IMPOSSIBLE;\n    }\n    if ((prefix[3] & 0x80) != 0) {\n      // Offset is negative (invalid).\n      return IMPOSSIBLE;\n    }\n    if ((prefix[3] & 0xe0) != 0) {\n      // Offset is over a gigabyte (implausible).\n      return IMPLAUSIBLE;\n    }\n\n    uint data = prefix[4] | (prefix[5] << 8);\n    uint pointers = prefix[6] | (prefix[7] << 8);\n\n    if (data + pointers > 2048) {\n      // Root struct is huge (over 16 KiB).\n      return IMPLAUSIBLE;\n    }\n\n    auto structSchema = rootType.getProto().getStruct();\n    if ((data < structSchema.getDataWordCount() && pointers > structSchema.getPointerCount()) ||\n        (data > structSchema.getDataWordCount() && pointers < structSchema.getPointerCount())) {\n      // Struct is neither older nor newer than the schema.\n      return WRONG_TYPE;\n    }\n\n    if (data > structSchema.getDataWordCount() &&\n        data - structSchema.getDataWordCount() > 128) {\n      // Data section appears to have grown by 1k (128 words).  This seems implausible.\n      return WRONG_TYPE;\n    }\n    if (pointers > structSchema.getPointerCount() &&\n        pointers - structSchema.getPointerCount() > 128) {\n      // Pointer section appears to have grown by 1k (128 words).  This seems implausible.\n      return WRONG_TYPE;\n    }\n\n    return PLAUSIBLE;\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Schema schema = compiler->getLoader().get(scopeId);",
      "StructSchema rootType;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "structSchema.getPointerCount",
          "args": [],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structSchema.getPointerCount",
          "args": [],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structSchema.getDataWordCount",
          "args": [],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structSchema.getDataWordCount",
          "args": [],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structSchema.getPointerCount",
          "args": [],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structSchema.getDataWordCount",
          "args": [],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structSchema.getPointerCount",
          "args": [],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structSchema.getDataWordCount",
          "args": [],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rootType.getProto",
          "args": [],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "prefix.size",
          "args": [],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nSchema schema = compiler->getLoader().get(scopeId);\nStructSchema rootType;\n\nPlausibility isPlausiblyFlat(kj::ArrayPtr<const byte> prefix, uint segmentCount = 1) {\n    if (prefix.size() < 8) {\n      // Not enough prefix to say.\n      return PLAUSIBLE;\n    }\n\n    if ((prefix[0] & 3) == 2) {\n      // Far pointer.  Verify the segment ID.\n      uint32_t segmentId = prefix[4] | (prefix[5] << 8)\n                         | (prefix[6] << 16) | (prefix[7] << 24);\n      if (segmentId == 0 || segmentId >= segmentCount) {\n        return IMPOSSIBLE;\n      } else {\n        return PLAUSIBLE;\n      }\n    }\n\n    if ((prefix[0] & 3) != 0) {\n      // Not a struct pointer.\n      return IMPOSSIBLE;\n    }\n    if ((prefix[3] & 0x80) != 0) {\n      // Offset is negative (invalid).\n      return IMPOSSIBLE;\n    }\n    if ((prefix[3] & 0xe0) != 0) {\n      // Offset is over a gigabyte (implausible).\n      return IMPLAUSIBLE;\n    }\n\n    uint data = prefix[4] | (prefix[5] << 8);\n    uint pointers = prefix[6] | (prefix[7] << 8);\n\n    if (data + pointers > 2048) {\n      // Root struct is huge (over 16 KiB).\n      return IMPLAUSIBLE;\n    }\n\n    auto structSchema = rootType.getProto().getStruct();\n    if ((data < structSchema.getDataWordCount() && pointers > structSchema.getPointerCount()) ||\n        (data > structSchema.getDataWordCount() && pointers < structSchema.getPointerCount())) {\n      // Struct is neither older nor newer than the schema.\n      return WRONG_TYPE;\n    }\n\n    if (data > structSchema.getDataWordCount() &&\n        data - structSchema.getDataWordCount() > 128) {\n      // Data section appears to have grown by 1k (128 words).  This seems implausible.\n      return WRONG_TYPE;\n    }\n    if (pointers > structSchema.getPointerCount() &&\n        pointers - structSchema.getPointerCount() > 128) {\n      // Pointer section appears to have grown by 1k (128 words).  This seems implausible.\n      return WRONG_TYPE;\n    }\n\n    return PLAUSIBLE;\n  }"
  },
  {
    "function_name": "plausibleOrWrongType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "760-762",
    "snippet": "bool plausibleOrWrongType(Plausibility p) {\n    return p == PLAUSIBLE || p == WRONG_TYPE;\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nbool plausibleOrWrongType(Plausibility p) {\n    return p == PLAUSIBLE || p == WRONG_TYPE;\n  }"
  },
  {
    "function_name": "decodeInner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "718-751",
    "snippet": "void decodeInner(Input&& input) {\n    // Since this is a debug tool, lift the usual security limits.  Worse case is the process\n    // crashes or has to be killed.\n    ReaderOptions options;\n    options.nestingLimit = kj::maxValue;\n    options.traversalLimitInWords = kj::maxValue;\n\n    MessageReaderType reader(input, options);\n    kj::String text;\n    kj::Maybe<kj::Exception> exception;\n\n    {\n      ParseErrorCatcher catcher;\n      auto root = reader.template getRoot<DynamicStruct>(rootType);\n      if (pretty) {\n        text = kj::str(prettyPrint(root), '\\n');\n      } else {\n        text = kj::str(root, '\\n');\n      }\n      exception = kj::mv(catcher.exception);\n    }\n\n    kj::FdOutputStream(STDOUT_FILENO).write(text.begin(), text.size());\n\n    KJ_IF_MAYBE(e, exception) {\n      context.error(kj::str(\n          \"*** ERROR DECODING PREVIOUS MESSAGE ***\\n\"\n          \"The following error occurred while decoding the message above.\\n\"\n          \"This probably means the input data is invalid/corrupted.\\n\",\n          \"Exception description: \", e->getDescription(), \"\\n\"\n          \"Code location: \", e->getFile(), \":\", e->getLine(), \"\\n\"\n          \"*** END ERROR ***\"));\n    }\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "MallocMessageBuilder message;",
      "kj::FdOutputStream rawOutput(STDOUT_FILENO);",
      "bool pretty = true;",
      "StructSchema rootType;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.error",
          "args": [
            "kj::str(\n          \"*** ERROR DECODING PREVIOUS MESSAGE ***\\n\"\n          \"The following error occurred while decoding the message above.\\n\"\n          \"This probably means the input data is invalid/corrupted.\\n\",\n          \"Exception description: \", e->getDescription(), \"\\n\"\n          \"Code location: \", e->getFile(), \":\", e->getLine(), \"\\n\"\n          \"*** END ERROR ***\")"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"*** ERROR DECODING PREVIOUS MESSAGE ***\\n\"\n          \"The following error occurred while decoding the message above.\\n\"\n          \"This probably means the input data is invalid/corrupted.\\n\"",
            "\"Exception description: \"",
            "e->getDescription()",
            "\"\\n\"\n          \"Code location: \"",
            "e->getFile()",
            "\":\"",
            "e->getLine()",
            "\"\\n\"\n          \"*** END ERROR ***\""
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e->getLine",
          "args": [],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "getLine",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "79-79",
          "snippet": "int getLine() const { return line; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  int getLine() const { return line; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "e->getFile",
          "args": [],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e->getDescription",
          "args": [],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "getDescription",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "81-81",
          "snippet": "StringPtr getDescription() const { return description; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  StringPtr getDescription() const { return description; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "text.begin()",
            "text.size()"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text.size",
          "args": [],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.begin",
          "args": [],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "76-76",
          "snippet": "inline Iterator begin() const { return Iterator(0); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "FdOutputStream",
          "container": "FdOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.h",
          "lines": "298-298",
          "snippet": "explicit FdOutputStream(AutoCloseFd fd): fd(fd), autoclose(mv(fd)) {}",
          "includes": [
            "#include \"exception.h\"",
            "#include \"array.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exception.h\"\n#include \"array.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nFdOutputStream {\n  explicit FdOutputStream(AutoCloseFd fd): fd(fd), autoclose(mv(fd)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "catcher.exception"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "root",
            "'\\n'"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "prettyPrint(root)",
            "'\\n'"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prettyPrint",
          "args": [
            "root"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "prettyPrint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/stringify.c++",
          "lines": "272-272",
          "snippet": "kj::StringTree prettyPrint(DynamicList::Builder value) { return prettyPrint(value.asReader()); }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"dynamic.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"dynamic.h\"\n\nkj::StringTree prettyPrint(DynamicList::Builder value) { return prettyPrint(value.asReader()); }"
        }
      },
      {
        "call_info": {
          "callee": "reader.template getRoot<DynamicStruct>",
          "args": [
            "rootType"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nMallocMessageBuilder message;\nkj::FdOutputStream rawOutput(STDOUT_FILENO);\nbool pretty = true;\nStructSchema rootType;\n\nvoid decodeInner(Input&& input) {\n    // Since this is a debug tool, lift the usual security limits.  Worse case is the process\n    // crashes or has to be killed.\n    ReaderOptions options;\n    options.nestingLimit = kj::maxValue;\n    options.traversalLimitInWords = kj::maxValue;\n\n    MessageReaderType reader(input, options);\n    kj::String text;\n    kj::Maybe<kj::Exception> exception;\n\n    {\n      ParseErrorCatcher catcher;\n      auto root = reader.template getRoot<DynamicStruct>(rootType);\n      if (pretty) {\n        text = kj::str(prettyPrint(root), '\\n');\n      } else {\n        text = kj::str(root, '\\n');\n      }\n      exception = kj::mv(catcher.exception);\n    }\n\n    kj::FdOutputStream(STDOUT_FILENO).write(text.begin(), text.size());\n\n    KJ_IF_MAYBE(e, exception) {\n      context.error(kj::str(\n          \"*** ERROR DECODING PREVIOUS MESSAGE ***\\n\"\n          \"The following error occurred while decoding the message above.\\n\"\n          \"This probably means the input data is invalid/corrupted.\\n\",\n          \"Exception description: \", e->getDescription(), \"\\n\"\n          \"Code location: \", e->getFile(), \":\", e->getLine(), \"\\n\"\n          \"*** END ERROR ***\"));\n    }\n  }"
  },
  {
    "function_name": "onRecoverableException",
    "container": "ParseErrorCatcher",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "706-712",
    "snippet": "void onRecoverableException(kj::Exception&& e) {\n      // Only capture the first exception, on the assumption that later exceptions are probably\n      // just cascading problems.\n      if (exception == nullptr) {\n        exception = kj::mv(e);\n      }\n    }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "e"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nParseErrorCatcher {\n  void onRecoverableException(kj::Exception&& e) {\n        // Only capture the first exception, on the assumption that later exceptions are probably\n        // just cascading problems.\n        if (exception == nullptr) {\n          exception = kj::mv(e);\n        }\n      }\n}"
  },
  {
    "function_name": "setRootType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "618-630",
    "snippet": "kj::MainBuilder::Validity setRootType(kj::StringPtr type) {\n    KJ_ASSERT(sourceFiles.size() == 1);\n\n    KJ_IF_MAYBE(schema, resolveName(sourceFiles[0].id, type)) {\n      if (schema->getProto().which() != schema::Node::STRUCT) {\n        return \"not a struct type\";\n      }\n      rootType = schema->asStruct();\n      return true;\n    } else {\n      return \"no such type\";\n    }\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Schema schema = compiler->getLoader().get(scopeId);",
      "StructSchema rootType;",
      "kj::Vector<SourceFile> sourceFiles;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schema->asStruct",
          "args": [],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema->getProto",
          "args": [],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "schema",
            "resolveName(sourceFiles[0].id, type)"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "resolveName",
          "args": [
            "sourceFiles[0].id",
            "type"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "sourceFiles.size() == 1"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sourceFiles.size",
          "args": [],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nSchema schema = compiler->getLoader().get(scopeId);\nStructSchema rootType;\nkj::Vector<SourceFile> sourceFiles;\n\nkj::MainBuilder::Validity setRootType(kj::StringPtr type) {\n    KJ_ASSERT(sourceFiles.size() == 1);\n\n    KJ_IF_MAYBE(schema, resolveName(sourceFiles[0].id, type)) {\n      if (schema->getProto().which() != schema::Node::STRUCT) {\n        return \"not a struct type\";\n      }\n      rootType = schema->asStruct();\n      return true;\n    } else {\n      return \"no such type\";\n    }\n  }"
  },
  {
    "function_name": "setSegmentSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "608-616",
    "snippet": "kj::MainBuilder::Validity setSegmentSize(kj::StringPtr size) {\n    if (flat) return \"cannot be used with --flat\";\n    char* end;\n    segmentSize = strtol(size.cStr(), &end, 0);\n    if (size.size() == 0 || *end != '\\0') {\n      return \"not an integer\";\n    }\n    return true;\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CapnpParser::ParserInput parserInput(tokens.begin(), tokens.end());",
      "bool flat = false;",
      "uint segmentSize = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "size.size",
          "args": [],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "size.cStr()",
            "&end",
            "0"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size.cStr",
          "args": [],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nCapnpParser::ParserInput parserInput(tokens.begin(), tokens.end());\nbool flat = false;\nuint segmentSize = 0;\n\nkj::MainBuilder::Validity setSegmentSize(kj::StringPtr size) {\n    if (flat) return \"cannot be used with --flat\";\n    char* end;\n    segmentSize = strtol(size.cStr(), &end, 0);\n    if (size.size() == 0 || *end != '\\0') {\n      return \"not an integer\";\n    }\n    return true;\n  }"
  },
  {
    "function_name": "setQuiet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "604-607",
    "snippet": "kj::MainBuilder::Validity setQuiet() {\n    quiet = true;\n    return true;\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool quiet = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nbool quiet = false;\n\nkj::MainBuilder::Validity setQuiet() {\n    quiet = true;\n    return true;\n  }"
  },
  {
    "function_name": "printShort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "600-603",
    "snippet": "kj::MainBuilder::Validity printShort() {\n    pretty = false;\n    return true;\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool pretty = true;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nbool pretty = true;\n\nkj::MainBuilder::Validity printShort() {\n    pretty = false;\n    return true;\n  }"
  },
  {
    "function_name": "codePacked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "594-599",
    "snippet": "kj::MainBuilder::Validity codePacked() {\n    if (binary) return \"cannot be used with --binary\";\n    if (flat) return \"cannot be used with --flat\";\n    packed = true;\n    return true;\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool binary = false;",
      "bool flat = false;",
      "bool packed = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nbool binary = false;\nbool flat = false;\nbool packed = false;\n\nkj::MainBuilder::Validity codePacked() {\n    if (binary) return \"cannot be used with --binary\";\n    if (flat) return \"cannot be used with --flat\";\n    packed = true;\n    return true;\n  }"
  },
  {
    "function_name": "codeFlat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "588-593",
    "snippet": "kj::MainBuilder::Validity codeFlat() {\n    if (binary) return \"cannot be used with --binary\";\n    if (packed) return \"cannot be used with --packed\";\n    flat = true;\n    return true;\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool binary = false;",
      "bool flat = false;",
      "bool packed = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nbool binary = false;\nbool flat = false;\nbool packed = false;\n\nkj::MainBuilder::Validity codeFlat() {\n    if (binary) return \"cannot be used with --binary\";\n    if (packed) return \"cannot be used with --packed\";\n    flat = true;\n    return true;\n  }"
  },
  {
    "function_name": "codeBinary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "582-587",
    "snippet": "kj::MainBuilder::Validity codeBinary() {\n    if (packed) return \"cannot be used with --packed\";\n    if (flat) return \"cannot be used with --flat\";\n    binary = true;\n    return true;\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool binary = false;",
      "bool flat = false;",
      "bool packed = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nbool binary = false;\nbool flat = false;\nbool packed = false;\n\nkj::MainBuilder::Validity codeBinary() {\n    if (packed) return \"cannot be used with --packed\";\n    if (flat) return \"cannot be used with --flat\";\n    binary = true;\n    return true;\n  }"
  },
  {
    "function_name": "addSourcePrefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "391-408",
    "snippet": "kj::MainBuilder::Validity addSourcePrefix(kj::StringPtr prefix) {\n    // Strip redundant \"./\" prefixes to make src-prefix matching more lenient.\n    while (prefix.startsWith(\"./\")) {\n      prefix = prefix.slice(2);\n    }\n\n    if (prefix == \"\" || prefix == \".\") {\n      // Irrelevant prefix.\n      return true;\n    }\n\n    if (prefix.endsWith(\"/\")) {\n      sourcePrefixes.add(kj::heapString(prefix));\n    } else {\n      sourcePrefixes.add(kj::str(prefix, '/'));\n    }\n    return true;\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Vector<kj::String> sourcePrefixes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sourcePrefixes.add",
          "args": [
            "kj::str(prefix, '/')"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "prefix",
            "'/'"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "prefix"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefix.endsWith",
          "args": [
            "\"/\""
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "endsWith",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "175-175",
          "snippet": "inline bool endsWith(const StringPtr& other) const { return StringPtr(*this).endsWith(other); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline bool endsWith(const StringPtr& other) const { return StringPtr(*this).endsWith(other); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefix.slice",
          "args": [
            "2"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "177-177",
          "snippet": "inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefix.startsWith",
          "args": [
            "\"./\""
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "startsWith",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "174-174",
          "snippet": "inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nkj::Vector<kj::String> sourcePrefixes;\n\nkj::MainBuilder::Validity addSourcePrefix(kj::StringPtr prefix) {\n    // Strip redundant \"./\" prefixes to make src-prefix matching more lenient.\n    while (prefix.startsWith(\"./\")) {\n      prefix = prefix.slice(2);\n    }\n\n    if (prefix == \"\" || prefix == \".\") {\n      // Irrelevant prefix.\n      return true;\n    }\n\n    if (prefix.endsWith(\"/\")) {\n      sourcePrefixes.add(kj::heapString(prefix));\n    } else {\n      sourcePrefixes.add(kj::str(prefix, '/'));\n    }\n    return true;\n  }"
  },
  {
    "function_name": "addOutput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "334-386",
    "snippet": "kj::MainBuilder::Validity addOutput(kj::StringPtr spec) {\n    KJ_IF_MAYBE(split, spec.findFirst(':')) {\n      kj::StringPtr dir = spec.slice(*split + 1);\n      auto plugin = spec.slice(0, *split);\n\n      KJ_IF_MAYBE(split2, dir.findFirst(':')) {\n        // Grr, there are two colons. Might this be a Windows path? Let's do some heuristics.\n        if (*split == 1 && (dir.startsWith(\"/\") || dir.startsWith(\"\\\\\"))) {\n          // So, the first ':' was the second char, and was followed by '/' or '\\', e.g.:\n          //     capnp compile -o c:/foo.exe:bar\n          //\n          // In this case we can conclude that the second colon is actually meant to be the\n          // plugin/location separator, and the first colon was simply signifying a drive letter.\n          //\n          // Proof by contradiction:\n          // - Say that none of the colons were meant to be plugin/location separators; i.e. the\n          //   whole argument is meant to be a plugin indicator and the location defaults to \".\".\n          //   -> In this case, the plugin path has two colons, which is not valid.\n          //   -> CONTRADICTION\n          // - Say that the first colon was meant to be the plugin/location separator.\n          //   -> In this case, the second colon must be the drive letter separator for the\n          //      output location.\n          //   -> However, the output location begins with '/' or '\\', which is not a drive letter.\n          //   -> CONTRADICTION\n          // - Say that there are more colons beyond the first two, and one of these is meant to\n          //   be the plugin/location separator.\n          //   -> In this case, the plugin path has two or more colons, which is not valid.\n          //   -> CONTRADICTION\n          //\n          // We therefore conclude that the *second* colon is in fact the plugin/location separator.\n          //\n          // Note that there is still an ambiguous case:\n          //     capnp compile -o c:/foo\n          //\n          // In this unfortunate case, we have no way to tell if the user meant \"use the 'c' plugin\n          // and output to /foo\" or \"use the plugin c:/foo and output to the default location\". We\n          // prefer the former interpretation, because the latter is Windows-specific and such\n          // users can always explicitly specify the output location like:\n          //     capnp compile -o c:/foo:.\n\n          dir = dir.slice(*split2 + 1);\n          plugin = spec.slice(0, *split2 + 2);\n        }\n      }\n\n      struct stat stats;\n      if (stat(dir.cStr(), &stats) < 0 || !S_ISDIR(stats.st_mode)) {\n        return \"output location is inaccessible or is not a directory\";\n      }\n      outputs.add(OutputDirective { plugin, dir });\n    } else {\n      outputs.add(OutputDirective { spec.asArray(), nullptr });\n    }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Vector<OutputDirective> outputs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outputs.add",
          "args": [
            "OutputDirective { spec.asArray(), nullptr }"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "spec.asArray",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "stats.st_mode"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dir.cStr()",
            "&stats"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir.cStr",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spec.slice",
          "args": [
            "0",
            "*split2 + 2"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir.slice",
          "args": [
            "*split2 + 1"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "177-177",
          "snippet": "inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir.startsWith",
          "args": [
            "\"\\\\\""
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "startsWith",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "174-174",
          "snippet": "inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "split2",
            "dir.findFirst(':')"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "dir.findFirst",
          "args": [
            "':'"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "findFirst",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "182-182",
          "snippet": "inline Maybe<size_t> findFirst(char c) const { return StringPtr(*this).findFirst(c); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline Maybe<size_t> findFirst(char c) const { return StringPtr(*this).findFirst(c); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nkj::Vector<OutputDirective> outputs;\n\nkj::MainBuilder::Validity addOutput(kj::StringPtr spec) {\n    KJ_IF_MAYBE(split, spec.findFirst(':')) {\n      kj::StringPtr dir = spec.slice(*split + 1);\n      auto plugin = spec.slice(0, *split);\n\n      KJ_IF_MAYBE(split2, dir.findFirst(':')) {\n        // Grr, there are two colons. Might this be a Windows path? Let's do some heuristics.\n        if (*split == 1 && (dir.startsWith(\"/\") || dir.startsWith(\"\\\\\"))) {\n          // So, the first ':' was the second char, and was followed by '/' or '\\', e.g.:\n          //     capnp compile -o c:/foo.exe:bar\n          //\n          // In this case we can conclude that the second colon is actually meant to be the\n          // plugin/location separator, and the first colon was simply signifying a drive letter.\n          //\n          // Proof by contradiction:\n          // - Say that none of the colons were meant to be plugin/location separators; i.e. the\n          //   whole argument is meant to be a plugin indicator and the location defaults to \".\".\n          //   -> In this case, the plugin path has two colons, which is not valid.\n          //   -> CONTRADICTION\n          // - Say that the first colon was meant to be the plugin/location separator.\n          //   -> In this case, the second colon must be the drive letter separator for the\n          //      output location.\n          //   -> However, the output location begins with '/' or '\\', which is not a drive letter.\n          //   -> CONTRADICTION\n          // - Say that there are more colons beyond the first two, and one of these is meant to\n          //   be the plugin/location separator.\n          //   -> In this case, the plugin path has two or more colons, which is not valid.\n          //   -> CONTRADICTION\n          //\n          // We therefore conclude that the *second* colon is in fact the plugin/location separator.\n          //\n          // Note that there is still an ambiguous case:\n          //     capnp compile -o c:/foo\n          //\n          // In this unfortunate case, we have no way to tell if the user meant \"use the 'c' plugin\n          // and output to /foo\" or \"use the plugin c:/foo and output to the default location\". We\n          // prefer the former interpretation, because the latter is Windows-specific and such\n          // users can always explicitly specify the output location like:\n          //     capnp compile -o c:/foo:.\n\n          dir = dir.slice(*split2 + 1);\n          plugin = spec.slice(0, *split2 + 2);\n        }\n      }\n\n      struct stat stats;\n      if (stat(dir.cStr(), &stats) < 0 || !S_ISDIR(stats.st_mode)) {\n        return \"output location is inaccessible or is not a directory\";\n      }\n      outputs.add(OutputDirective { plugin, dir });\n    } else {\n      outputs.add(OutputDirective { spec.asArray(), nullptr });\n    }"
  },
  {
    "function_name": "loadModule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
    "lines": "66-320",
    "snippet": "class CompilerMain final: public GlobalErrorReporter {\npublic:\n  explicit CompilerMain(kj::ProcessContext& context)\n      : context(context), loader(*this) {}\n\n  kj::MainFunc getMain() {\n    if (context.getProgramName().endsWith(\"capnpc\")) {\n      kj::MainBuilder builder(context, VERSION_STRING,\n            \"Compiles Cap'n Proto schema files and generates corresponding source code in one or \"\n            \"more languages.\");\n      addGlobalOptions(builder);\n      addCompileOptions(builder);\n      builder.addOption({'i', \"generate-id\"}, KJ_BIND_METHOD(*this, generateId),\n                        \"Generate a new 64-bit unique ID for use in a Cap'n Proto schema.\");\n      return builder.build();\n    } else {\n      kj::MainBuilder builder(context, VERSION_STRING,\n            \"Command-line tool for Cap'n Proto development and debugging.\");\n      builder.addSubCommand(\"compile\", KJ_BIND_METHOD(*this, getCompileMain),\n                            \"Generate source code from schema files.\")\n             .addSubCommand(\"id\", KJ_BIND_METHOD(*this, getGenIdMain),\n                            \"Generate a new unique ID.\")\n             .addSubCommand(\"decode\", KJ_BIND_METHOD(*this, getDecodeMain),\n                            \"Decode binary Cap'n Proto message to text.\")\n             .addSubCommand(\"encode\", KJ_BIND_METHOD(*this, getEncodeMain),\n                            \"Encode text Cap'n Proto message to binary.\")\n             .addSubCommand(\"eval\", KJ_BIND_METHOD(*this, getEvalMain),\n                            \"Evaluate a const from a schema file.\");\n      addGlobalOptions(builder);\n      return builder.build();\n    }\n  }\n\n  kj::MainFunc getCompileMain() {\n    kj::MainBuilder builder(context, VERSION_STRING,\n          \"Compiles Cap'n Proto schema files and generates corresponding source code in one or \"\n          \"more languages.\");\n    addGlobalOptions(builder);\n    addCompileOptions(builder);\n    return builder.build();\n  }\n\n  kj::MainFunc getGenIdMain() {\n    return kj::MainBuilder(context, VERSION_STRING,\n          \"Generates a new 64-bit unique ID for use in a Cap'n Proto schema.\")\n        .callAfterParsing(KJ_BIND_METHOD(*this, generateId))\n        .build();\n  }\n\n  kj::MainFunc getDecodeMain() {\n    // Only parse the schemas we actually need for decoding.\n    compileEagerness = Compiler::NODE;\n\n    // Drop annotations since we don't need them.  This avoids importing files like c++.capnp.\n    annotationFlag = Compiler::DROP_ANNOTATIONS;\n\n    kj::MainBuilder builder(context, VERSION_STRING,\n          \"Decodes one or more encoded Cap'n Proto messages as text.  The messages have root \"\n          \"type <type> defined in <schema-file>.  Messages are read from standard input and \"\n          \"by default are expected to be in standard Cap'n Proto serialization format.\");\n    addGlobalOptions(builder);\n    builder.addOption({\"flat\"}, KJ_BIND_METHOD(*this, codeFlat),\n                      \"Interpret the input as one large single-segment message rather than a \"\n                      \"stream in standard serialization format.  (Rarely used.)\")\n           .addOption({'p', \"packed\"}, KJ_BIND_METHOD(*this, codePacked),\n                      \"Expect the input to be packed using standard Cap'n Proto packing, which \"\n                      \"deflates zero-valued bytes.  (This reads messages written with \"\n                      \"capnp::writePackedMessage*() from <capnp/serialize-packed.h>.  Do not use \"\n                      \"this for messages written with capnp::writeMessage*() from \"\n                      \"<capnp/serialize.h>.)\")\n           .addOption({\"short\"}, KJ_BIND_METHOD(*this, printShort),\n                      \"Print in short (non-pretty) format.  Each message will be printed on one \"\n                      \"line, without using whitespace to improve readability.\")\n           .addOption({\"quiet\"}, KJ_BIND_METHOD(*this, setQuiet),\n                      \"Do not print warning messages about the input being in the wrong format.  \"\n                      \"Use this if you find the warnings are wrong (but also let us know so \"\n                      \"we can improve them).\")\n           .expectArg(\"<schema-file>\", KJ_BIND_METHOD(*this, addSource))\n           .expectArg(\"<type>\", KJ_BIND_METHOD(*this, setRootType))\n           .callAfterParsing(KJ_BIND_METHOD(*this, decode));\n    return builder.build();\n  }\n\n  kj::MainFunc getEncodeMain() {\n    // Only parse the schemas we actually need for decoding.\n    compileEagerness = Compiler::NODE;\n\n    // Drop annotations since we don't need them.  This avoids importing files like c++.capnp.\n    annotationFlag = Compiler::DROP_ANNOTATIONS;\n\n    kj::MainBuilder builder(context, VERSION_STRING,\n          \"Encodes one or more textual Cap'n Proto messages to binary.  The messages have root \"\n          \"type <type> defined in <schema-file>.  Messages are read from standard input.  Each \"\n          \"mesage is a parenthesized struct literal, like the format used to specify constants \"\n          \"and default values of struct type in the schema language.  For example:\\n\"\n          \"    (foo = 123, bar = \\\"hello\\\", baz = [true, false, true])\\n\"\n          \"The input may contain any number of such values; each will be encoded as a separate \"\n          \"message.\",\n\n          \"Note that the current implementation reads the entire input into memory before \"\n          \"beginning to encode.  A better implementation would read and encode one message at \"\n          \"a time.\");\n    addGlobalOptions(builder);\n    builder.addOption({\"flat\"}, KJ_BIND_METHOD(*this, codeFlat),\n                      \"Expect only one input value, serializing it as a single-segment message \"\n                      \"with no framing.\")\n           .addOption({'p', \"packed\"}, KJ_BIND_METHOD(*this, codePacked),\n                      \"Pack the output message with standard Cap'n Proto packing, which \"\n                      \"deflates zero-valued bytes.  (This writes messages using \"\n                      \"capnp::writePackedMessage() from <capnp/serialize-packed.h>.  Without \"\n                      \"this, capnp::writeMessage() from <capnp/serialize.h> is used.)\")\n           .addOptionWithArg({\"segment-size\"}, KJ_BIND_METHOD(*this, setSegmentSize), \"<n>\",\n                             \"Sets the preferred segment size on the MallocMessageBuilder to <n> \"\n                             \"words and turns off heuristic growth.  This flag is mainly useful \"\n                             \"for testing.  Without it, each message will be written as a single \"\n                             \"segment.\")\n           .expectArg(\"<schema-file>\", KJ_BIND_METHOD(*this, addSource))\n           .expectArg(\"<type>\", KJ_BIND_METHOD(*this, setRootType))\n           .callAfterParsing(KJ_BIND_METHOD(*this, encode));\n    return builder.build();\n  }\n\n  kj::MainFunc getEvalMain() {\n    // Only parse the schemas we actually need for decoding.\n    compileEagerness = Compiler::NODE;\n\n    // Drop annotations since we don't need them.  This avoids importing files like c++.capnp.\n    annotationFlag = Compiler::DROP_ANNOTATIONS;\n\n    kj::MainBuilder builder(context, VERSION_STRING,\n          \"Prints (or encodes) the value of <name>, which must be defined in <schema-file>.  \"\n          \"<name> must refer to a const declaration, a field of a struct type (prints the default \"\n          \"value), or a field or list element nested within some other value.  Examples:\\n\"\n          \"    capnp eval myschema.capnp MyType.someField\\n\"\n          \"    capnp eval myschema.capnp someConstant\\n\"\n          \"    capnp eval myschema.capnp someConstant.someField\\n\"\n          \"    capnp eval myschema.capnp someConstant.someList[4]\\n\"\n          \"    capnp eval myschema.capnp someConstant.someList[4].anotherField[1][2][3]\\n\"\n          \"Since consts can have complex struct types, and since you can define a const using \"\n          \"import and variable substitution, this can be a convenient way to write text-format \"\n          \"config files which are compiled to binary before deployment.\",\n\n          \"By default the value is written in text format and can have any type.  The -b, -p, \"\n          \"and --flat flags specify binary output, in which case the const must be of struct \"\n          \"type.\");\n    addGlobalOptions(builder);\n    builder.addOption({'b', \"binary\"}, KJ_BIND_METHOD(*this, codeBinary),\n                      \"Write the output as binary instead of text, using standard Cap'n Proto \"\n                      \"serialization.  (This writes the message using capnp::writeMessage() \"\n                      \"from <capnp/serialize.h>.)\")\n           .addOption({\"flat\"}, KJ_BIND_METHOD(*this, codeFlat),\n                      \"Write the output as a flat single-segment binary message, with no framing.\")\n           .addOption({'p', \"packed\"}, KJ_BIND_METHOD(*this, codePacked),\n                      \"Write the output as packed binary instead of text, using standard Cap'n \"\n                      \"Proto packing, which deflates zero-valued bytes.  (This writes the \"\n                      \"message using capnp::writePackedMessage() from \"\n                      \"<capnp/serialize-packed.h>.)\")\n           .addOption({\"short\"}, KJ_BIND_METHOD(*this, printShort),\n                      \"Print in short (non-pretty) text format.  The message will be printed on \"\n                      \"one line, without using whitespace to improve readability.\")\n           .expectArg(\"<schema-file>\", KJ_BIND_METHOD(*this, addSource))\n           .expectArg(\"<name>\", KJ_BIND_METHOD(*this, evalConst));\n    return builder.build();\n  }\n\n  void addGlobalOptions(kj::MainBuilder& builder) {\n    builder.addOptionWithArg({'I', \"import-path\"}, KJ_BIND_METHOD(*this, addImportPath), \"<dir>\",\n                             \"Add <dir> to the list of directories searched for non-relative \"\n                             \"imports (ones that start with a '/').\")\n           .addOption({\"no-standard-import\"}, KJ_BIND_METHOD(*this, noStandardImport),\n                      \"Do not add any default import paths; use only those specified by -I.  \"\n                      \"Otherwise, typically /usr/include and /usr/local/include are added by \"\n                      \"default.\");\n  }\n\n  void addCompileOptions(kj::MainBuilder& builder) {\n    builder.addOptionWithArg({'o', \"output\"}, KJ_BIND_METHOD(*this, addOutput), \"<lang>[:<dir>]\",\n                             \"Generate source code for language <lang> in directory <dir> \"\n                             \"(default: current directory).  <lang> actually specifies a plugin \"\n                             \"to use.  If <lang> is a simple word, the compiler for a plugin \"\n                             \"called 'capnpc-<lang>' in $PATH.  If <lang> is a file path \"\n                             \"containing slashes, it is interpreted as the exact plugin \"\n                             \"executable file name, and $PATH is not searched.\")\n           .addOptionWithArg({\"src-prefix\"}, KJ_BIND_METHOD(*this, addSourcePrefix), \"<prefix>\",\n                             \"If a file specified for compilation starts with <prefix>, remove \"\n                             \"the prefix for the purpose of deciding the names of output files.  \"\n                             \"For example, the following command:\\n\"\n                             \"    capnp compile --src-prefix=foo/bar -oc++:corge foo/bar/baz/qux.capnp\\n\"\n                             \"would generate the files corge/baz/qux.capnp.{h,c++}.\")\n           .expectOneOrMoreArgs(\"<source>\", KJ_BIND_METHOD(*this, addSource))\n           .callAfterParsing(KJ_BIND_METHOD(*this, generateOutput));\n  }\n\n  // =====================================================================================\n  // shared options\n\n  kj::MainBuilder::Validity addImportPath(kj::StringPtr path) {\n    loader.addImportPath(kj::heapString(path));\n    return true;\n  }\n\n  kj::MainBuilder::Validity noStandardImport() {\n    addStandardImportPaths = false;\n    return true;\n  }\n\n  kj::MainBuilder::Validity addSource(kj::StringPtr file) {\n    // Strip redundant \"./\" prefixes to make src-prefix matching more lenient.\n    while (file.startsWith(\"./\")) {\n      file = file.slice(2);\n\n      // Remove redundant slashes as well (e.g. \".////foo\" -> \"foo\").\n      while (file.startsWith(\"/\")) {\n        file = file.slice(1);\n      }\n    }\n\n    if (!compilerConstructed) {\n      compiler = compilerSpace.construct(annotationFlag);\n      compilerConstructed = true;\n    }\n\n    if (addStandardImportPaths) {\n      loader.addImportPath(kj::heapString(\"/usr/local/include\"));\n      loader.addImportPath(kj::heapString(\"/usr/include\"));\n#ifdef CAPNP_INCLUDE_DIR\n      loader.addImportPath(kj::heapString(CAPNP_INCLUDE_DIR));\n#endif\n      addStandardImportPaths = false;\n    }\n\n    KJ_IF_MAYBE(module, loadModule(file)) {\n      uint64_t id = compiler->add(*module);\n      compiler->eagerlyCompile(id, compileEagerness);\n      sourceFiles.add(SourceFile { id, module->getSourceName(), &*module });\n    } else {\n      return \"no such file\";\n    }\n\n    return true;\n  }\n\nprivate:\n  kj::Maybe<Module&> loadModule(kj::StringPtr file) {\n    size_t longestPrefix = 0;\n\n    for (auto& prefix: sourcePrefixes) {\n      if (file.startsWith(prefix)) {\n        longestPrefix = kj::max(longestPrefix, prefix.size());\n      }\n    }\n\n    kj::StringPtr canonicalName = file.slice(longestPrefix);\n    return loader.loadModule(file, canonicalName);\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <sys/wait.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <process.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <capnp/serialize-packed.h>",
      "#include <capnp/serialize.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <kj/parse/char.h>",
      "#include <kj/main.h>",
      "#include <iostream>",
      "#include \"../message.h\"",
      "#include <kj/debug.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/vector.h>",
      "#include <capnp/schema.capnp.h>",
      "#include <capnp/pretty-print.h>",
      "#include \"node-translator.h\"",
      "#include \"module-loader.h\"",
      "#include \"compiler.h\"",
      "#include \"parser.h\"",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "MallocMessageBuilder message;",
      "auto schemas = compiler->getLoader().getAllLoaded();",
      "Schema schema = compiler->getLoader().get(scopeId);",
      "DynamicValue::Reader value;",
      "ModuleLoader loader;",
      "kj::SpaceFor<Compiler> compilerSpace;",
      "bool compilerConstructed = false;",
      "kj::Own<Compiler> compiler;",
      "Compiler::AnnotationFlag annotationFlag = Compiler::COMPILE_ANNOTATIONS;",
      "uint compileEagerness = Compiler::NODE | Compiler::CHILDREN |\n                          Compiler::DEPENDENCIES | Compiler::DEPENDENCY_PARENTS;",
      "kj::Vector<kj::String> sourcePrefixes;",
      "bool addStandardImportPaths = true;",
      "bool binary = false;",
      "bool flat = false;",
      "bool packed = false;",
      "bool pretty = true;",
      "bool quiet = false;",
      "kj::Vector<SourceFile> sourceFiles;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "loader.loadModule",
          "args": [
            "file",
            "canonicalName"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.slice",
          "args": [
            "longestPrefix"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "177-177",
          "snippet": "inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::max",
          "args": [
            "longestPrefix",
            "prefix.size()"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "486-488",
          "snippet": "auto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefix.size",
          "args": [],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file.startsWith",
          "args": [
            "prefix"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "startsWith",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "174-174",
          "snippet": "inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sourceFiles.add",
          "args": [
            "SourceFile { id, module->getSourceName(), &*module }"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "module->getSourceName",
          "args": [],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "getSourceName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "232-232",
          "snippet": "kj::StringPtr getSourceName() { return parserModule.getSourceName(); }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nkj::StringPtr getSourceName() { return parserModule.getSourceName(); }"
        }
      },
      {
        "call_info": {
          "callee": "compiler->eagerlyCompile",
          "args": [
            "id",
            "compileEagerness"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loader.addImportPath",
          "args": [
            "kj::heapString(CAPNP_INCLUDE_DIR)"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "addImportPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
          "lines": "220-222",
          "snippet": "void addImportPath(kj::String path) {\n    searchPath.add(kj::heapString(kj::mv(path)));\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/mutex.h>",
            "#include <kj/vector.h>",
            "#include \"parser.h\"",
            "#include \"lexer.h\"",
            "#include \"module-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nvoid addImportPath(kj::String path) {\n    searchPath.add(kj::heapString(kj::mv(path)));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "CAPNP_INCLUDE_DIR"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compilerSpace.construct",
          "args": [
            "annotationFlag"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "558-560",
          "snippet": "static void construct(void* ptr) {\n    kj::ctor(*reinterpret_cast<T*>(ptr));\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nstatic void construct(void* ptr) {\n    kj::ctor(*reinterpret_cast<T*>(ptr));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "builder.addOptionWithArg",
          "args": [
            "KJ_BIND_METHOD(*this, generateOutput)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "generateOutput"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOptionWithArg",
          "args": [
            "\"<source>\"",
            "KJ_BIND_METHOD(*this, addSource)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "addSource"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOptionWithArg",
          "args": [
            "{\"src-prefix\"}",
            "KJ_BIND_METHOD(*this, addSourcePrefix)",
            "\"<prefix>\"",
            "\"If a file specified for compilation starts with <prefix>, remove \"\n                             \"the prefix for the purpose of deciding the names of output files.  \"\n                             \"For example, the following command:\\n\"\n                             \"    capnp compile --src-prefix=foo/bar -oc++:corge foo/bar/baz/qux.capnp\\n\"\n                             \"would generate the files corge/baz/qux.capnp.{h,c++}.\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "addSourcePrefix"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOptionWithArg",
          "args": [
            "{'o', \"output\"}",
            "KJ_BIND_METHOD(*this, addOutput)",
            "\"<lang>[:<dir>]\"",
            "\"Generate source code for language <lang> in directory <dir> \"\n                             \"(default: current directory).  <lang> actually specifies a plugin \"\n                             \"to use.  If <lang> is a simple word, the compiler for a plugin \"\n                             \"called 'capnpc-<lang>' in $PATH.  If <lang> is a file path \"\n                             \"containing slashes, it is interpreted as the exact plugin \"\n                             \"executable file name, and $PATH is not searched.\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "addOutput"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOptionWithArg",
          "args": [
            "{\"no-standard-import\"}",
            "KJ_BIND_METHOD(*this, noStandardImport)",
            "\"Do not add any default import paths; use only those specified by -I.  \"\n                      \"Otherwise, typically /usr/include and /usr/local/include are added by \"\n                      \"default.\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "noStandardImport"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOptionWithArg",
          "args": [
            "{'I', \"import-path\"}",
            "KJ_BIND_METHOD(*this, addImportPath)",
            "\"<dir>\"",
            "\"Add <dir> to the list of directories searched for non-relative \"\n                             \"imports (ones that start with a '/').\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "addImportPath"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.build",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "\"<name>\"",
            "KJ_BIND_METHOD(*this, evalConst)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "evalConst"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "\"<schema-file>\"",
            "KJ_BIND_METHOD(*this, addSource)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "addSource"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "{\"short\"}",
            "KJ_BIND_METHOD(*this, printShort)",
            "\"Print in short (non-pretty) text format.  The message will be printed on \"\n                      \"one line, without using whitespace to improve readability.\""
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "printShort"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "{'p', \"packed\"}",
            "KJ_BIND_METHOD(*this, codePacked)",
            "\"Write the output as packed binary instead of text, using standard Cap'n \"\n                      \"Proto packing, which deflates zero-valued bytes.  (This writes the \"\n                      \"message using capnp::writePackedMessage() from \"\n                      \"<capnp/serialize-packed.h>.)\""
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "codePacked"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "{\"flat\"}",
            "KJ_BIND_METHOD(*this, codeFlat)",
            "\"Write the output as a flat single-segment binary message, with no framing.\""
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "codeFlat"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "{'b', \"binary\"}",
            "KJ_BIND_METHOD(*this, codeBinary)",
            "\"Write the output as binary instead of text, using standard Cap'n Proto \"\n                      \"serialization.  (This writes the message using capnp::writeMessage() \"\n                      \"from <capnp/serialize.h>.)\""
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "codeBinary"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addGlobalOptions",
          "args": [
            "builder"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.build",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "KJ_BIND_METHOD(*this, encode)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "encode"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "\"<type>\"",
            "KJ_BIND_METHOD(*this, setRootType)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setRootType"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "\"<schema-file>\"",
            "KJ_BIND_METHOD(*this, addSource)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "addSource"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "{\"segment-size\"}",
            "KJ_BIND_METHOD(*this, setSegmentSize)",
            "\"<n>\"",
            "\"Sets the preferred segment size on the MallocMessageBuilder to <n> \"\n                             \"words and turns off heuristic growth.  This flag is mainly useful \"\n                             \"for testing.  Without it, each message will be written as a single \"\n                             \"segment.\""
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setSegmentSize"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "{'p', \"packed\"}",
            "KJ_BIND_METHOD(*this, codePacked)",
            "\"Pack the output message with standard Cap'n Proto packing, which \"\n                      \"deflates zero-valued bytes.  (This writes messages using \"\n                      \"capnp::writePackedMessage() from <capnp/serialize-packed.h>.  Without \"\n                      \"this, capnp::writeMessage() from <capnp/serialize.h> is used.)\""
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "codePacked"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "{\"flat\"}",
            "KJ_BIND_METHOD(*this, codeFlat)",
            "\"Expect only one input value, serializing it as a single-segment message \"\n                      \"with no framing.\""
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "codeFlat"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addGlobalOptions",
          "args": [
            "builder"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.build",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "KJ_BIND_METHOD(*this, decode)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "decode"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "\"<type>\"",
            "KJ_BIND_METHOD(*this, setRootType)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setRootType"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "\"<schema-file>\"",
            "KJ_BIND_METHOD(*this, addSource)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "addSource"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "{\"quiet\"}",
            "KJ_BIND_METHOD(*this, setQuiet)",
            "\"Do not print warning messages about the input being in the wrong format.  \"\n                      \"Use this if you find the warnings are wrong (but also let us know so \"\n                      \"we can improve them).\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setQuiet"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "{\"short\"}",
            "KJ_BIND_METHOD(*this, printShort)",
            "\"Print in short (non-pretty) format.  Each message will be printed on one \"\n                      \"line, without using whitespace to improve readability.\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "printShort"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "{'p', \"packed\"}",
            "KJ_BIND_METHOD(*this, codePacked)",
            "\"Expect the input to be packed using standard Cap'n Proto packing, which \"\n                      \"deflates zero-valued bytes.  (This reads messages written with \"\n                      \"capnp::writePackedMessage*() from <capnp/serialize-packed.h>.  Do not use \"\n                      \"this for messages written with capnp::writeMessage*() from \"\n                      \"<capnp/serialize.h>.)\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "codePacked"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "{\"flat\"}",
            "KJ_BIND_METHOD(*this, codeFlat)",
            "\"Interpret the input as one large single-segment message rather than a \"\n                      \"stream in standard serialization format.  (Rarely used.)\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "codeFlat"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addGlobalOptions",
          "args": [
            "builder"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "KJ_BIND_METHOD(*this, generateId)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "generateId"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "VERSION_STRING",
            "\"Generates a new 64-bit unique ID for use in a Cap'n Proto schema.\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.build",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addCompileOptions",
          "args": [
            "builder"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addGlobalOptions",
          "args": [
            "builder"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.build",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addGlobalOptions",
          "args": [
            "builder"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addSubCommand",
          "args": [
            "\"eval\"",
            "KJ_BIND_METHOD(*this, getEvalMain)",
            "\"Evaluate a const from a schema file.\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "getEvalMain"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addSubCommand",
          "args": [
            "\"encode\"",
            "KJ_BIND_METHOD(*this, getEncodeMain)",
            "\"Encode text Cap'n Proto message to binary.\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "getEncodeMain"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addSubCommand",
          "args": [
            "\"decode\"",
            "KJ_BIND_METHOD(*this, getDecodeMain)",
            "\"Decode binary Cap'n Proto message to text.\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "getDecodeMain"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addSubCommand",
          "args": [
            "\"id\"",
            "KJ_BIND_METHOD(*this, getGenIdMain)",
            "\"Generate a new unique ID.\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "getGenIdMain"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addSubCommand",
          "args": [
            "\"compile\"",
            "KJ_BIND_METHOD(*this, getCompileMain)",
            "\"Generate source code from schema files.\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "getCompileMain"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.build",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addOption",
          "args": [
            "{'i', \"generate-id\"}",
            "KJ_BIND_METHOD(*this, generateId)",
            "\"Generate a new 64-bit unique ID for use in a Cap'n Proto schema.\""
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "generateId"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addCompileOptions",
          "args": [
            "builder"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addGlobalOptions",
          "args": [
            "builder"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getProgramName",
          "args": [
            "\"capnpc\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getProgramName",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nMallocMessageBuilder message;\nauto schemas = compiler->getLoader().getAllLoaded();\nSchema schema = compiler->getLoader().get(scopeId);\nDynamicValue::Reader value;\nModuleLoader loader;\nkj::SpaceFor<Compiler> compilerSpace;\nbool compilerConstructed = false;\nkj::Own<Compiler> compiler;\nCompiler::AnnotationFlag annotationFlag = Compiler::COMPILE_ANNOTATIONS;\nuint compileEagerness = Compiler::NODE | Compiler::CHILDREN |\n                          Compiler::DEPENDENCIES | Compiler::DEPENDENCY_PARENTS;\nkj::Vector<kj::String> sourcePrefixes;\nbool addStandardImportPaths = true;\nbool binary = false;\nbool flat = false;\nbool packed = false;\nbool pretty = true;\nbool quiet = false;\nkj::Vector<SourceFile> sourceFiles;\n\nclass CompilerMain final: public GlobalErrorReporter {\npublic:\n  explicit CompilerMain(kj::ProcessContext& context)\n      : context(context), loader(*this) {}\n\n  kj::MainFunc getMain() {\n    if (context.getProgramName().endsWith(\"capnpc\")) {\n      kj::MainBuilder builder(context, VERSION_STRING,\n            \"Compiles Cap'n Proto schema files and generates corresponding source code in one or \"\n            \"more languages.\");\n      addGlobalOptions(builder);\n      addCompileOptions(builder);\n      builder.addOption({'i', \"generate-id\"}, KJ_BIND_METHOD(*this, generateId),\n                        \"Generate a new 64-bit unique ID for use in a Cap'n Proto schema.\");\n      return builder.build();\n    } else {\n      kj::MainBuilder builder(context, VERSION_STRING,\n            \"Command-line tool for Cap'n Proto development and debugging.\");\n      builder.addSubCommand(\"compile\", KJ_BIND_METHOD(*this, getCompileMain),\n                            \"Generate source code from schema files.\")\n             .addSubCommand(\"id\", KJ_BIND_METHOD(*this, getGenIdMain),\n                            \"Generate a new unique ID.\")\n             .addSubCommand(\"decode\", KJ_BIND_METHOD(*this, getDecodeMain),\n                            \"Decode binary Cap'n Proto message to text.\")\n             .addSubCommand(\"encode\", KJ_BIND_METHOD(*this, getEncodeMain),\n                            \"Encode text Cap'n Proto message to binary.\")\n             .addSubCommand(\"eval\", KJ_BIND_METHOD(*this, getEvalMain),\n                            \"Evaluate a const from a schema file.\");\n      addGlobalOptions(builder);\n      return builder.build();\n    }\n  }\n\n  kj::MainFunc getCompileMain() {\n    kj::MainBuilder builder(context, VERSION_STRING,\n          \"Compiles Cap'n Proto schema files and generates corresponding source code in one or \"\n          \"more languages.\");\n    addGlobalOptions(builder);\n    addCompileOptions(builder);\n    return builder.build();\n  }\n\n  kj::MainFunc getGenIdMain() {\n    return kj::MainBuilder(context, VERSION_STRING,\n          \"Generates a new 64-bit unique ID for use in a Cap'n Proto schema.\")\n        .callAfterParsing(KJ_BIND_METHOD(*this, generateId))\n        .build();\n  }\n\n  kj::MainFunc getDecodeMain() {\n    // Only parse the schemas we actually need for decoding.\n    compileEagerness = Compiler::NODE;\n\n    // Drop annotations since we don't need them.  This avoids importing files like c++.capnp.\n    annotationFlag = Compiler::DROP_ANNOTATIONS;\n\n    kj::MainBuilder builder(context, VERSION_STRING,\n          \"Decodes one or more encoded Cap'n Proto messages as text.  The messages have root \"\n          \"type <type> defined in <schema-file>.  Messages are read from standard input and \"\n          \"by default are expected to be in standard Cap'n Proto serialization format.\");\n    addGlobalOptions(builder);\n    builder.addOption({\"flat\"}, KJ_BIND_METHOD(*this, codeFlat),\n                      \"Interpret the input as one large single-segment message rather than a \"\n                      \"stream in standard serialization format.  (Rarely used.)\")\n           .addOption({'p', \"packed\"}, KJ_BIND_METHOD(*this, codePacked),\n                      \"Expect the input to be packed using standard Cap'n Proto packing, which \"\n                      \"deflates zero-valued bytes.  (This reads messages written with \"\n                      \"capnp::writePackedMessage*() from <capnp/serialize-packed.h>.  Do not use \"\n                      \"this for messages written with capnp::writeMessage*() from \"\n                      \"<capnp/serialize.h>.)\")\n           .addOption({\"short\"}, KJ_BIND_METHOD(*this, printShort),\n                      \"Print in short (non-pretty) format.  Each message will be printed on one \"\n                      \"line, without using whitespace to improve readability.\")\n           .addOption({\"quiet\"}, KJ_BIND_METHOD(*this, setQuiet),\n                      \"Do not print warning messages about the input being in the wrong format.  \"\n                      \"Use this if you find the warnings are wrong (but also let us know so \"\n                      \"we can improve them).\")\n           .expectArg(\"<schema-file>\", KJ_BIND_METHOD(*this, addSource))\n           .expectArg(\"<type>\", KJ_BIND_METHOD(*this, setRootType))\n           .callAfterParsing(KJ_BIND_METHOD(*this, decode));\n    return builder.build();\n  }\n\n  kj::MainFunc getEncodeMain() {\n    // Only parse the schemas we actually need for decoding.\n    compileEagerness = Compiler::NODE;\n\n    // Drop annotations since we don't need them.  This avoids importing files like c++.capnp.\n    annotationFlag = Compiler::DROP_ANNOTATIONS;\n\n    kj::MainBuilder builder(context, VERSION_STRING,\n          \"Encodes one or more textual Cap'n Proto messages to binary.  The messages have root \"\n          \"type <type> defined in <schema-file>.  Messages are read from standard input.  Each \"\n          \"mesage is a parenthesized struct literal, like the format used to specify constants \"\n          \"and default values of struct type in the schema language.  For example:\\n\"\n          \"    (foo = 123, bar = \\\"hello\\\", baz = [true, false, true])\\n\"\n          \"The input may contain any number of such values; each will be encoded as a separate \"\n          \"message.\",\n\n          \"Note that the current implementation reads the entire input into memory before \"\n          \"beginning to encode.  A better implementation would read and encode one message at \"\n          \"a time.\");\n    addGlobalOptions(builder);\n    builder.addOption({\"flat\"}, KJ_BIND_METHOD(*this, codeFlat),\n                      \"Expect only one input value, serializing it as a single-segment message \"\n                      \"with no framing.\")\n           .addOption({'p', \"packed\"}, KJ_BIND_METHOD(*this, codePacked),\n                      \"Pack the output message with standard Cap'n Proto packing, which \"\n                      \"deflates zero-valued bytes.  (This writes messages using \"\n                      \"capnp::writePackedMessage() from <capnp/serialize-packed.h>.  Without \"\n                      \"this, capnp::writeMessage() from <capnp/serialize.h> is used.)\")\n           .addOptionWithArg({\"segment-size\"}, KJ_BIND_METHOD(*this, setSegmentSize), \"<n>\",\n                             \"Sets the preferred segment size on the MallocMessageBuilder to <n> \"\n                             \"words and turns off heuristic growth.  This flag is mainly useful \"\n                             \"for testing.  Without it, each message will be written as a single \"\n                             \"segment.\")\n           .expectArg(\"<schema-file>\", KJ_BIND_METHOD(*this, addSource))\n           .expectArg(\"<type>\", KJ_BIND_METHOD(*this, setRootType))\n           .callAfterParsing(KJ_BIND_METHOD(*this, encode));\n    return builder.build();\n  }\n\n  kj::MainFunc getEvalMain() {\n    // Only parse the schemas we actually need for decoding.\n    compileEagerness = Compiler::NODE;\n\n    // Drop annotations since we don't need them.  This avoids importing files like c++.capnp.\n    annotationFlag = Compiler::DROP_ANNOTATIONS;\n\n    kj::MainBuilder builder(context, VERSION_STRING,\n          \"Prints (or encodes) the value of <name>, which must be defined in <schema-file>.  \"\n          \"<name> must refer to a const declaration, a field of a struct type (prints the default \"\n          \"value), or a field or list element nested within some other value.  Examples:\\n\"\n          \"    capnp eval myschema.capnp MyType.someField\\n\"\n          \"    capnp eval myschema.capnp someConstant\\n\"\n          \"    capnp eval myschema.capnp someConstant.someField\\n\"\n          \"    capnp eval myschema.capnp someConstant.someList[4]\\n\"\n          \"    capnp eval myschema.capnp someConstant.someList[4].anotherField[1][2][3]\\n\"\n          \"Since consts can have complex struct types, and since you can define a const using \"\n          \"import and variable substitution, this can be a convenient way to write text-format \"\n          \"config files which are compiled to binary before deployment.\",\n\n          \"By default the value is written in text format and can have any type.  The -b, -p, \"\n          \"and --flat flags specify binary output, in which case the const must be of struct \"\n          \"type.\");\n    addGlobalOptions(builder);\n    builder.addOption({'b', \"binary\"}, KJ_BIND_METHOD(*this, codeBinary),\n                      \"Write the output as binary instead of text, using standard Cap'n Proto \"\n                      \"serialization.  (This writes the message using capnp::writeMessage() \"\n                      \"from <capnp/serialize.h>.)\")\n           .addOption({\"flat\"}, KJ_BIND_METHOD(*this, codeFlat),\n                      \"Write the output as a flat single-segment binary message, with no framing.\")\n           .addOption({'p', \"packed\"}, KJ_BIND_METHOD(*this, codePacked),\n                      \"Write the output as packed binary instead of text, using standard Cap'n \"\n                      \"Proto packing, which deflates zero-valued bytes.  (This writes the \"\n                      \"message using capnp::writePackedMessage() from \"\n                      \"<capnp/serialize-packed.h>.)\")\n           .addOption({\"short\"}, KJ_BIND_METHOD(*this, printShort),\n                      \"Print in short (non-pretty) text format.  The message will be printed on \"\n                      \"one line, without using whitespace to improve readability.\")\n           .expectArg(\"<schema-file>\", KJ_BIND_METHOD(*this, addSource))\n           .expectArg(\"<name>\", KJ_BIND_METHOD(*this, evalConst));\n    return builder.build();\n  }\n\n  void addGlobalOptions(kj::MainBuilder& builder) {\n    builder.addOptionWithArg({'I', \"import-path\"}, KJ_BIND_METHOD(*this, addImportPath), \"<dir>\",\n                             \"Add <dir> to the list of directories searched for non-relative \"\n                             \"imports (ones that start with a '/').\")\n           .addOption({\"no-standard-import\"}, KJ_BIND_METHOD(*this, noStandardImport),\n                      \"Do not add any default import paths; use only those specified by -I.  \"\n                      \"Otherwise, typically /usr/include and /usr/local/include are added by \"\n                      \"default.\");\n  }\n\n  void addCompileOptions(kj::MainBuilder& builder) {\n    builder.addOptionWithArg({'o', \"output\"}, KJ_BIND_METHOD(*this, addOutput), \"<lang>[:<dir>]\",\n                             \"Generate source code for language <lang> in directory <dir> \"\n                             \"(default: current directory).  <lang> actually specifies a plugin \"\n                             \"to use.  If <lang> is a simple word, the compiler for a plugin \"\n                             \"called 'capnpc-<lang>' in $PATH.  If <lang> is a file path \"\n                             \"containing slashes, it is interpreted as the exact plugin \"\n                             \"executable file name, and $PATH is not searched.\")\n           .addOptionWithArg({\"src-prefix\"}, KJ_BIND_METHOD(*this, addSourcePrefix), \"<prefix>\",\n                             \"If a file specified for compilation starts with <prefix>, remove \"\n                             \"the prefix for the purpose of deciding the names of output files.  \"\n                             \"For example, the following command:\\n\"\n                             \"    capnp compile --src-prefix=foo/bar -oc++:corge foo/bar/baz/qux.capnp\\n\"\n                             \"would generate the files corge/baz/qux.capnp.{h,c++}.\")\n           .expectOneOrMoreArgs(\"<source>\", KJ_BIND_METHOD(*this, addSource))\n           .callAfterParsing(KJ_BIND_METHOD(*this, generateOutput));\n  }\n\n  // =====================================================================================\n  // shared options\n\n  kj::MainBuilder::Validity addImportPath(kj::StringPtr path) {\n    loader.addImportPath(kj::heapString(path));\n    return true;\n  }\n\n  kj::MainBuilder::Validity noStandardImport() {\n    addStandardImportPaths = false;\n    return true;\n  }\n\n  kj::MainBuilder::Validity addSource(kj::StringPtr file) {\n    // Strip redundant \"./\" prefixes to make src-prefix matching more lenient.\n    while (file.startsWith(\"./\")) {\n      file = file.slice(2);\n\n      // Remove redundant slashes as well (e.g. \".////foo\" -> \"foo\").\n      while (file.startsWith(\"/\")) {\n        file = file.slice(1);\n      }\n    }\n\n    if (!compilerConstructed) {\n      compiler = compilerSpace.construct(annotationFlag);\n      compilerConstructed = true;\n    }\n\n    if (addStandardImportPaths) {\n      loader.addImportPath(kj::heapString(\"/usr/local/include\"));\n      loader.addImportPath(kj::heapString(\"/usr/include\"));\n#ifdef CAPNP_INCLUDE_DIR\n      loader.addImportPath(kj::heapString(CAPNP_INCLUDE_DIR));\n#endif\n      addStandardImportPaths = false;\n    }\n\n    KJ_IF_MAYBE(module, loadModule(file)) {\n      uint64_t id = compiler->add(*module);\n      compiler->eagerlyCompile(id, compileEagerness);\n      sourceFiles.add(SourceFile { id, module->getSourceName(), &*module });\n    } else {\n      return \"no such file\";\n    }\n\n    return true;\n  }\n\nprivate:\n  kj::Maybe<Module&> loadModule(kj::StringPtr file) {\n    size_t longestPrefix = 0;\n\n    for (auto& prefix: sourcePrefixes) {\n      if (file.startsWith(prefix)) {\n        longestPrefix = kj::max(longestPrefix, prefix.size());\n      }\n    }\n\n    kj::StringPtr canonicalName = file.slice(longestPrefix);\n    return loader.loadModule(file, canonicalName);\n  }"
  }
]