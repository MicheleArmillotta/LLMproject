[
  {
    "function_name": "SchemaFile::newDiskFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "476-482",
    "snippet": "kj::Own<SchemaFile> SchemaFile::newDiskFile(\n    kj::StringPtr displayName, kj::StringPtr diskPath,\n    kj::ArrayPtr<const kj::StringPtr> importPath,\n    const FileReader& fileReader) {\n  return kj::heap<DiskSchemaFile>(fileReader, canonicalizePath(displayName),\n                                  canonicalizePath(diskPath), importPath);\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<DiskSchemaFile>",
          "args": [
            "fileReader",
            "canonicalizePath(displayName)",
            "canonicalizePath(diskPath)",
            "importPath"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "canonicalizePath",
          "args": [
            "diskPath"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "canonicalizePath",
          "args": [
            "displayName"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::Own<SchemaFile> SchemaFile::newDiskFile(\n    kj::StringPtr displayName, kj::StringPtr diskPath,\n    kj::ArrayPtr<const kj::StringPtr> importPath,\n    const FileReader& fileReader) {\n  return kj::heap<DiskSchemaFile>(fileReader, canonicalizePath(displayName),\n                                  canonicalizePath(diskPath), importPath);\n}"
  },
  {
    "function_name": "reportError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "463-467",
    "snippet": "void reportError(SourcePos start, SourcePos end, kj::StringPtr message) const override {\n    kj::getExceptionCallback().onRecoverableException(kj::Exception(\n        kj::Exception::Type::FAILED, kj::heapString(diskPath), start.line,\n        kj::heapString(message)));\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::getExceptionCallback",
          "args": [
            "kj::Exception(\n        kj::Exception::Type::FAILED, kj::heapString(diskPath), start.line,\n        kj::heapString(message))"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::Exception",
          "args": [
            "kj::Exception::Type::FAILED",
            "kj::heapString(diskPath)",
            "start.line",
            "kj::heapString(message)"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "message"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::getExceptionCallback",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nvoid reportError(SourcePos start, SourcePos end, kj::StringPtr message) const override {\n    kj::getExceptionCallback().onRecoverableException(kj::Exception(\n        kj::Exception::Type::FAILED, kj::heapString(diskPath), start.line,\n        kj::heapString(message)));\n  }"
  },
  {
    "function_name": "hashCode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "453-461",
    "snippet": "size_t hashCode() const override {\n    // djb hash with xor\n    // TODO(someday):  Add hashing library to KJ.\n    size_t result = 5381;\n    for (char c: diskPath) {\n      result = (result * 33) ^ c;\n    }\n    return result;\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nsize_t hashCode() const override {\n    // djb hash with xor\n    // TODO(someday):  Add hashing library to KJ.\n    size_t result = 5381;\n    for (char c: diskPath) {\n      result = (result * 33) ^ c;\n    }\n    return result;\n  }"
  },
  {
    "function_name": "import",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "424-445",
    "snippet": "kj::Maybe<kj::Own<SchemaFile>> import(kj::StringPtr path) const override {\n    if (path.startsWith(\"/\")) {\n      for (auto candidate: importPath) {\n        kj::String newDiskPath = canonicalizePath(joinPath(candidate, path.slice(1)));\n        if (fileReader.exists(newDiskPath)) {\n          return kj::implicitCast<kj::Own<SchemaFile>>(kj::heap<DiskSchemaFile>(\n              fileReader, canonicalizePath(path.slice(1)),\n              kj::mv(newDiskPath), importPath));\n        }\n      }\n      return nullptr;\n    } else {\n      kj::String newDiskPath = canonicalizePath(relativePath(diskPath, path));\n      if (fileReader.exists(newDiskPath)) {\n        return kj::implicitCast<kj::Own<SchemaFile>>(kj::heap<DiskSchemaFile>(\n            fileReader, canonicalizePath(relativePath(displayName, path)),\n            kj::mv(newDiskPath), importPath));\n      } else {\n        return nullptr;\n      }\n    }\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::implicitCast<kj::Own<SchemaFile>>",
          "args": [
            "kj::heap<DiskSchemaFile>(\n            fileReader, canonicalizePath(relativePath(displayName, path)),\n            kj::mv(newDiskPath), importPath)"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<DiskSchemaFile>",
          "args": [
            "fileReader",
            "canonicalizePath(relativePath(displayName, path))",
            "kj::mv(newDiskPath)",
            "importPath"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "newDiskPath"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "canonicalizePath",
          "args": [
            "relativePath(displayName, path)"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relativePath",
          "args": [
            "displayName",
            "path"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "relativePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "327-338",
          "snippet": "kj::String relativePath(kj::StringPtr base, kj::StringPtr add) {\n  if (add.size() > 0 && add[0] == '/') {\n    return kj::heapString(add);\n  }\n\n  const char* pos = base.end();\n  while (pos > base.begin() && pos[-1] != '/') {\n    --pos;\n  }\n\n  return kj::str(base.slice(0, pos - base.begin()), add);\n}",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::String relativePath(kj::StringPtr base, kj::StringPtr add) {\n  if (add.size() > 0 && add[0] == '/') {\n    return kj::heapString(add);\n  }\n\n  const char* pos = base.end();\n  while (pos > base.begin() && pos[-1] != '/') {\n    --pos;\n  }\n\n  return kj::str(base.slice(0, pos - base.begin()), add);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileReader.exists",
          "args": [
            "newDiskPath"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "exists",
          "container": "FakeFileReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser-test.c++",
          "lines": "37-39",
          "snippet": "bool exists(kj::StringPtr path) const override {\n    return files.count(path) > 0;\n  }",
          "includes": [
            "#include <map>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\"",
            "#include <kj/compat/gtest.h>",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include <kj/compat/gtest.h>\n#include \"schema-parser.h\"\n\nFakeFileReader {\n  bool exists(kj::StringPtr path) const override {\n      return files.count(path) > 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "canonicalizePath",
          "args": [
            "relativePath(diskPath, path)"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::implicitCast<kj::Own<SchemaFile>>",
          "args": [
            "kj::heap<DiskSchemaFile>(\n              fileReader, canonicalizePath(path.slice(1)),\n              kj::mv(newDiskPath), importPath)"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<DiskSchemaFile>",
          "args": [
            "fileReader",
            "canonicalizePath(path.slice(1))",
            "kj::mv(newDiskPath)",
            "importPath"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "newDiskPath"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "canonicalizePath",
          "args": [
            "path.slice(1)"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.slice",
          "args": [
            "1"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "177-177",
          "snippet": "inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "canonicalizePath",
          "args": [
            "joinPath(candidate, path.slice(1))"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "joinPath",
          "args": [
            "candidate",
            "path.slice(1)"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "joinPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "340-344",
          "snippet": "kj::String joinPath(kj::StringPtr base, kj::StringPtr add) {\n  KJ_REQUIRE(!add.startsWith(\"/\"));\n\n  return kj::str(base, '/', add);\n}",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::String joinPath(kj::StringPtr base, kj::StringPtr add) {\n  KJ_REQUIRE(!add.startsWith(\"/\"));\n\n  return kj::str(base, '/', add);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path.startsWith",
          "args": [
            "\"/\""
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "startsWith",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "174-174",
          "snippet": "inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::Maybe<kj::Own<SchemaFile>> import(kj::StringPtr path) const override {\n    if (path.startsWith(\"/\")) {\n      for (auto candidate: importPath) {\n        kj::String newDiskPath = canonicalizePath(joinPath(candidate, path.slice(1)));\n        if (fileReader.exists(newDiskPath)) {\n          return kj::implicitCast<kj::Own<SchemaFile>>(kj::heap<DiskSchemaFile>(\n              fileReader, canonicalizePath(path.slice(1)),\n              kj::mv(newDiskPath), importPath));\n        }\n      }\n      return nullptr;\n    } else {\n      kj::String newDiskPath = canonicalizePath(relativePath(diskPath, path));\n      if (fileReader.exists(newDiskPath)) {\n        return kj::implicitCast<kj::Own<SchemaFile>>(kj::heap<DiskSchemaFile>(\n            fileReader, canonicalizePath(relativePath(displayName, path)),\n            kj::mv(newDiskPath), importPath));\n      } else {\n        return nullptr;\n      }\n    }\n  }"
  },
  {
    "function_name": "readContent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "420-422",
    "snippet": "kj::Array<const char> readContent() const override {\n    return fileReader.read(diskPath);\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fileReader.read",
          "args": [
            "diskPath"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FakeFileReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser-test.c++",
          "lines": "41-47",
          "snippet": "kj::Array<const char> read(kj::StringPtr path) const override {\n    auto iter = files.find(path);\n    KJ_ASSERT(iter != files.end(), \"FakeFileReader has no such file.\", path);\n    auto result = kj::heapArray<char>(iter->second.size());\n    memcpy(result.begin(), iter->second.begin(), iter->second.size());\n    return kj::mv(result);\n  }",
          "includes": [
            "#include <map>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\"",
            "#include <kj/compat/gtest.h>",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include <kj/compat/gtest.h>\n#include \"schema-parser.h\"\n\nFakeFileReader {\n  kj::Array<const char> read(kj::StringPtr path) const override {\n      auto iter = files.find(path);\n      KJ_ASSERT(iter != files.end(), \"FakeFileReader has no such file.\", path);\n      auto result = kj::heapArray<char>(iter->second.size());\n      memcpy(result.begin(), iter->second.begin(), iter->second.size());\n      return kj::mv(result);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::Array<const char> readContent() const override {\n    return fileReader.read(diskPath);\n  }"
  },
  {
    "function_name": "getDisplayName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "416-418",
    "snippet": "kj::StringPtr getDisplayName() const override {\n    return displayName;\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::StringPtr getDisplayName() const override {\n    return displayName;\n  }"
  },
  {
    "function_name": "DiskSchemaFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "409-414",
    "snippet": "DiskSchemaFile(const FileReader& fileReader, kj::String displayName,\n                 kj::String diskPath, kj::ArrayPtr<const kj::StringPtr> importPath)\n      : fileReader(fileReader),\n        displayName(kj::mv(displayName)),\n        diskPath(kj::mv(diskPath)),\n        importPath(importPath) {}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "diskPath"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "displayName"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nDiskSchemaFile(const FileReader& fileReader, kj::String displayName,\n                 kj::String diskPath, kj::ArrayPtr<const kj::StringPtr> importPath)\n      : fileReader(fileReader),\n        displayName(kj::mv(displayName)),\n        diskPath(kj::mv(diskPath)),\n        importPath(importPath) {}"
  },
  {
    "function_name": "SchemaFile::DiskFileReader::read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "355-403",
    "snippet": "kj::Array<const char> SchemaFile::DiskFileReader::read(kj::StringPtr path) const {\n  int fd;\n  // We already established that the file exists, so this should not fail.\n  KJ_SYSCALL(fd = open(path.cStr(), O_RDONLY), path);\n  kj::AutoCloseFd closer(fd);\n\n  struct stat stats;\n  KJ_SYSCALL(fstat(fd, &stats));\n\n  if (S_ISREG(stats.st_mode)) {\n    if (stats.st_size == 0) {\n      // mmap()ing zero bytes will fail.\n      return nullptr;\n    }\n\n    // Regular file.  Just mmap() it.\n#if _WIN32\n    HANDLE handle = reinterpret_cast<HANDLE>(_get_osfhandle(fd));\n    KJ_ASSERT(handle != INVALID_HANDLE_VALUE);\n    HANDLE mappingHandle = CreateFileMapping(\n        handle, NULL, PAGE_READONLY, 0, stats.st_size, NULL);\n    KJ_ASSERT(mappingHandle != INVALID_HANDLE_VALUE);\n    KJ_DEFER(KJ_ASSERT(CloseHandle(mappingHandle)));\n    const void* mapping = MapViewOfFile(mappingHandle, FILE_MAP_READ, 0, 0, stats.st_size);\n#else  // _WIN32\n    const void* mapping = mmap(NULL, stats.st_size, PROT_READ, MAP_SHARED, fd, 0);\n    if (mapping == MAP_FAILED) {\n      KJ_FAIL_SYSCALL(\"mmap\", errno, path);\n    }\n#endif  // !_WIN32\n\n    return kj::Array<const char>(\n        reinterpret_cast<const char*>(mapping), stats.st_size, mmapDisposer);\n  } else {\n    // This could be a stream of some sort, like a pipe.  Fall back to read().\n    // TODO(cleanup):  This does a lot of copies.  Not sure I care.\n    kj::Vector<char> data(8192);\n\n    char buffer[4096];\n    for (;;) {\n      ssize_t n;\n      KJ_SYSCALL(n = ::read(fd, buffer, sizeof(buffer)));\n      if (n == 0) break;\n      data.addAll(buffer, buffer + n);\n    }\n\n    return data.releaseAsArray();\n  }\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data.releaseAsArray",
          "args": [],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "releaseAsArray",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "66-72",
          "snippet": "inline Array<T> releaseAsArray() {\n    // TODO(perf):  Avoid a copy/move by allowing Array<T> to point to incomplete space?\n    if (!builder.isFull()) {\n      setCapacity(size());\n    }\n    return builder.finish();\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline Array<T> releaseAsArray() {\n      // TODO(perf):  Avoid a copy/move by allowing Array<T> to point to incomplete space?\n      if (!builder.isFull()) {\n        setCapacity(size());\n      }\n      return builder.finish();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.addAll",
          "args": [
            "buffer",
            "buffer + n"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "addAll",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "81-85",
          "snippet": "inline void addAll(Iterator begin, Iterator end) {\n    size_t needed = builder.size() + (end - begin);\n    if (needed > builder.capacity()) grow(needed);\n    builder.addAll(begin, end);\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline void addAll(Iterator begin, Iterator end) {\n      size_t needed = builder.size() + (end - begin);\n      if (needed > builder.capacity()) grow(needed);\n      builder.addAll(begin, end);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "n = ::read(fd, buffer, sizeof(buffer))"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::read",
          "args": [
            "fd",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "AsyncMessageReader::read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
          "lines": "66-81",
          "snippet": "kj::Promise<bool> AsyncMessageReader::read(kj::AsyncInputStream& inputStream,\n                                           kj::ArrayPtr<word> scratchSpace) {\n  return inputStream.tryRead(firstWord, sizeof(firstWord), sizeof(firstWord))\n      .then([this,&inputStream,scratchSpace](size_t n) mutable -> kj::Promise<bool> {\n    if (n == 0) {\n      return false;\n    } else if (n < sizeof(firstWord)) {\n      // EOF in first word.\n      KJ_FAIL_REQUIRE(\"Premature EOF.\") {\n        return false;\n      }\n    }\n\n    return readAfterFirstWord(inputStream, scratchSpace).then([]() { return true; });\n  });\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nkj::Promise<bool> AsyncMessageReader::read(kj::AsyncInputStream& inputStream,\n                                           kj::ArrayPtr<word> scratchSpace) {\n  return inputStream.tryRead(firstWord, sizeof(firstWord), sizeof(firstWord))\n      .then([this,&inputStream,scratchSpace](size_t n) mutable -> kj::Promise<bool> {\n    if (n == 0) {\n      return false;\n    } else if (n < sizeof(firstWord)) {\n      // EOF in first word.\n      KJ_FAIL_REQUIRE(\"Premature EOF.\") {\n        return false;\n      }\n    }\n\n    return readAfterFirstWord(inputStream, scratchSpace).then([]() { return true; });\n  });\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::Array<const char>",
          "args": [
            "reinterpret_cast<const char*>(mapping)",
            "stats.st_size",
            "mmapDisposer"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "Array",
          "container": "Array",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "146-147",
          "snippet": "inline Array(T* firstElement, size_t size, const ArrayDisposer& disposer)\n      : ptr(firstElement), size_(size), disposer(&disposer) {}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArray {\n  inline Array(T* firstElement, size_t size, const ArrayDisposer& disposer)\n        : ptr(firstElement), size_(size), disposer(&disposer) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const char*>",
          "args": [
            "mapping"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"mmap\"",
            "errno",
            "path"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap",
          "args": [
            "NULL",
            "stats.st_size",
            "PROT_READ",
            "MAP_SHARED",
            "fd",
            "0"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MapViewOfFile",
          "args": [
            "mappingHandle",
            "FILE_MAP_READ",
            "0",
            "0",
            "stats.st_size"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "KJ_ASSERT(CloseHandle(mappingHandle))"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "CloseHandle(mappingHandle)"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CloseHandle",
          "args": [
            "mappingHandle"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "mappingHandle != INVALID_HANDLE_VALUE"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateFileMapping",
          "args": [
            "handle",
            "NULL",
            "PAGE_READONLY",
            "0",
            "stats.st_size",
            "NULL"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "handle != INVALID_HANDLE_VALUE"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<HANDLE>",
          "args": [
            "_get_osfhandle(fd)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_get_osfhandle",
          "args": [
            "fd"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "stats.st_mode"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fstat(fd, &stats)"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&stats"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fd = open(path.cStr(), O_RDONLY)",
            "path"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path.cStr()",
            "O_RDONLY"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::Array<const char> SchemaFile::DiskFileReader::read(kj::StringPtr path) const {\n  int fd;\n  // We already established that the file exists, so this should not fail.\n  KJ_SYSCALL(fd = open(path.cStr(), O_RDONLY), path);\n  kj::AutoCloseFd closer(fd);\n\n  struct stat stats;\n  KJ_SYSCALL(fstat(fd, &stats));\n\n  if (S_ISREG(stats.st_mode)) {\n    if (stats.st_size == 0) {\n      // mmap()ing zero bytes will fail.\n      return nullptr;\n    }\n\n    // Regular file.  Just mmap() it.\n#if _WIN32\n    HANDLE handle = reinterpret_cast<HANDLE>(_get_osfhandle(fd));\n    KJ_ASSERT(handle != INVALID_HANDLE_VALUE);\n    HANDLE mappingHandle = CreateFileMapping(\n        handle, NULL, PAGE_READONLY, 0, stats.st_size, NULL);\n    KJ_ASSERT(mappingHandle != INVALID_HANDLE_VALUE);\n    KJ_DEFER(KJ_ASSERT(CloseHandle(mappingHandle)));\n    const void* mapping = MapViewOfFile(mappingHandle, FILE_MAP_READ, 0, 0, stats.st_size);\n#else  // _WIN32\n    const void* mapping = mmap(NULL, stats.st_size, PROT_READ, MAP_SHARED, fd, 0);\n    if (mapping == MAP_FAILED) {\n      KJ_FAIL_SYSCALL(\"mmap\", errno, path);\n    }\n#endif  // !_WIN32\n\n    return kj::Array<const char>(\n        reinterpret_cast<const char*>(mapping), stats.st_size, mmapDisposer);\n  } else {\n    // This could be a stream of some sort, like a pipe.  Fall back to read().\n    // TODO(cleanup):  This does a lot of copies.  Not sure I care.\n    kj::Vector<char> data(8192);\n\n    char buffer[4096];\n    for (;;) {\n      ssize_t n;\n      KJ_SYSCALL(n = ::read(fd, buffer, sizeof(buffer)));\n      if (n == 0) break;\n      data.addAll(buffer, buffer + n);\n    }\n\n    return data.releaseAsArray();\n  }\n}"
  },
  {
    "function_name": "SchemaFile::DiskFileReader::exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "351-353",
    "snippet": "bool SchemaFile::DiskFileReader::exists(kj::StringPtr path) const {\n  return access(path.cStr(), F_OK) == 0;\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "access",
          "args": [
            "path.cStr()",
            "F_OK"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nbool SchemaFile::DiskFileReader::exists(kj::StringPtr path) const {\n  return access(path.cStr(), F_OK) == 0;\n}"
  },
  {
    "function_name": "joinPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "340-344",
    "snippet": "kj::String joinPath(kj::StringPtr base, kj::StringPtr add) {\n  KJ_REQUIRE(!add.startsWith(\"/\"));\n\n  return kj::str(base, '/', add);\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "base",
            "'/'",
            "add"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "!add.startsWith(\"/\")"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add.startsWith",
          "args": [
            "\"/\""
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "startsWith",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "174-174",
          "snippet": "inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::String joinPath(kj::StringPtr base, kj::StringPtr add) {\n  KJ_REQUIRE(!add.startsWith(\"/\"));\n\n  return kj::str(base, '/', add);\n}"
  },
  {
    "function_name": "relativePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "327-338",
    "snippet": "kj::String relativePath(kj::StringPtr base, kj::StringPtr add) {\n  if (add.size() > 0 && add[0] == '/') {\n    return kj::heapString(add);\n  }\n\n  const char* pos = base.end();\n  while (pos > base.begin() && pos[-1] != '/') {\n    --pos;\n  }\n\n  return kj::str(base.slice(0, pos - base.begin()), add);\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "base.slice(0, pos - base.begin())",
            "add"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base.slice",
          "args": [
            "0",
            "pos - base.begin()"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "base.begin",
          "args": [],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "base.end",
          "args": [],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "add"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add.size",
          "args": [],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::String relativePath(kj::StringPtr base, kj::StringPtr add) {\n  if (add.size() > 0 && add[0] == '/') {\n    return kj::heapString(add);\n  }\n\n  const char* pos = base.end();\n  while (pos > base.begin() && pos[-1] != '/') {\n    --pos;\n  }\n\n  return kj::str(base.slice(0, pos - base.begin()), add);\n}"
  },
  {
    "function_name": "canonicalizePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "318-325",
    "snippet": "kj::String canonicalizePath(kj::StringPtr path) {\n  KJ_STACK_ARRAY(char, result, path.size() + 1, 128, 512);\n  strcpy(result.begin(), path.begin());\n\n  char* start = path.startsWith(\"/\") ? result.begin() + 1 : result.begin();\n  char* end = canonicalizePath(start);\n  return kj::heapString(result.slice(0, end - result.begin()));\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "result.slice(0, end - result.begin())"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.slice",
          "args": [
            "0",
            "end - result.begin()"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.begin",
          "args": [],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "canonicalizePath",
          "args": [
            "start"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.startsWith",
          "args": [
            "\"/\""
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "startsWith",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "174-174",
          "snippet": "inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "result.begin()",
            "path.begin()"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::String canonicalizePath(kj::StringPtr path) {\n  KJ_STACK_ARRAY(char, result, path.size() + 1, 128, 512);\n  strcpy(result.begin(), path.begin());\n\n  char* start = path.startsWith(\"/\") ? result.begin() + 1 : result.begin();\n  char* end = canonicalizePath(start);\n  return kj::heapString(result.slice(0, end - result.begin()));\n}"
  },
  {
    "function_name": "disposeImpl",
    "container": "MmapDisposer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "227-234",
    "snippet": "void disposeImpl(void* firstElement, size_t elementSize, size_t elementCount,\n                   size_t capacity, void (*destroyElement)(void*)) const {\n#if _WIN32\n    KJ_ASSERT(UnmapViewOfFile(firstElement));\n#else\n    munmap(firstElement, elementSize * elementCount);\n#endif\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "munmap",
          "args": [
            "firstElement",
            "elementSize * elementCount"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "UnmapViewOfFile(firstElement)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnmapViewOfFile",
          "args": [
            "firstElement"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nMmapDisposer {\n  void disposeImpl(void* firstElement, size_t elementSize, size_t elementCount,\n                     size_t capacity, void (*destroyElement)(void*)) const {\n  #if _WIN32\n      KJ_ASSERT(UnmapViewOfFile(firstElement));\n  #else\n      munmap(firstElement, elementSize * elementCount);\n  #endif\n    }\n}"
  },
  {
    "function_name": "ParsedSchema::getNested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "213-218",
    "snippet": "ParsedSchema ParsedSchema::getNested(kj::StringPtr nestedName) const {\n  KJ_IF_MAYBE(nested, findNested(nestedName)) {\n    return *nested;\n  } else {\n    KJ_FAIL_REQUIRE(\"no such nested declaration\", getProto().getDisplayName(), nestedName);\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"no such nested declaration\"",
            "getProto().getDisplayName()",
            "nestedName"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nParsedSchema ParsedSchema::getNested(kj::StringPtr nestedName) const {\n  KJ_IF_MAYBE(nested, findNested(nestedName)) {\n    return *nested;\n  } else {\n    KJ_FAIL_REQUIRE(\"no such nested declaration\", getProto().getDisplayName(), nestedName);\n  }"
  },
  {
    "function_name": "ParsedSchema::findNested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "206-211",
    "snippet": "kj::Maybe<ParsedSchema> ParsedSchema::findNested(kj::StringPtr name) const {\n  return parser->impl->compiler.lookup(getProto().getId(), name).map(\n      [this](uint64_t childId) {\n        return ParsedSchema(parser->impl->compiler.getLoader().get(childId), *parser);\n      });\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parser->impl->compiler.lookup",
          "args": [
            "[this](uint64_t childId) {\n        return ParsedSchema(parser->impl->compiler.getLoader().get(childId), *parser);\n      }"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ParsedSchema",
          "args": [
            "parser->impl->compiler.getLoader().get(childId)",
            "*parser"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "ParsedSchema",
          "container": "ParsedSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.h",
          "lines": "114-114",
          "snippet": "inline ParsedSchema(Schema inner, const SchemaParser& parser): Schema(inner), parser(&parser) {}",
          "includes": [
            "#include <kj/string.h>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include \"schema-loader.h\"\n\nParsedSchema {\n  inline ParsedSchema(Schema inner, const SchemaParser& parser): Schema(inner), parser(&parser) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser->impl->compiler.getLoader",
          "args": [
            "childId"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->impl->compiler.getLoader",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser->impl->compiler.lookup",
          "args": [
            "getProto().getId()",
            "name"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::Maybe<ParsedSchema> ParsedSchema::findNested(kj::StringPtr name) const {\n  return parser->impl->compiler.lookup(getProto().getId(), name).map(\n      [this](uint64_t childId) {\n        return ParsedSchema(parser->impl->compiler.getLoader().get(childId), *parser);\n      });\n}"
  },
  {
    "function_name": "SchemaParser::parseFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "182-189",
    "snippet": "ParsedSchema SchemaParser::parseFile(kj::Own<SchemaFile>&& file) const {\n  KJ_DEFER(impl->compiler.clearWorkspace());\n  uint64_t id = impl->compiler.add(getModuleImpl(kj::mv(file)));\n  impl->compiler.eagerlyCompile(id,\n      compiler::Compiler::NODE | compiler::Compiler::CHILDREN |\n      compiler::Compiler::DEPENDENCIES | compiler::Compiler::DEPENDENCY_DEPENDENCIES);\n  return ParsedSchema(impl->compiler.getLoader().get(id), *this);\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ParsedSchema",
          "args": [
            "impl->compiler.getLoader().get(id)",
            "*this"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "ParsedSchema",
          "container": "ParsedSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.h",
          "lines": "114-114",
          "snippet": "inline ParsedSchema(Schema inner, const SchemaParser& parser): Schema(inner), parser(&parser) {}",
          "includes": [
            "#include <kj/string.h>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include \"schema-loader.h\"\n\nParsedSchema {\n  inline ParsedSchema(Schema inner, const SchemaParser& parser): Schema(inner), parser(&parser) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "impl->compiler.getLoader",
          "args": [
            "id"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "impl->compiler.getLoader",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "impl->compiler.eagerlyCompile",
          "args": [
            "id",
            "compiler::Compiler::NODE | compiler::Compiler::CHILDREN |\n      compiler::Compiler::DEPENDENCIES | compiler::Compiler::DEPENDENCY_DEPENDENCIES"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "impl->compiler.add",
          "args": [
            "getModuleImpl(kj::mv(file))"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getModuleImpl",
          "args": [
            "kj::mv(file)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "file"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "impl->compiler.clearWorkspace()"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "impl->compiler.clearWorkspace",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nParsedSchema SchemaParser::parseFile(kj::Own<SchemaFile>&& file) const {\n  KJ_DEFER(impl->compiler.clearWorkspace());\n  uint64_t id = impl->compiler.add(getModuleImpl(kj::mv(file)));\n  impl->compiler.eagerlyCompile(id,\n      compiler::Compiler::NODE | compiler::Compiler::CHILDREN |\n      compiler::Compiler::DEPENDENCIES | compiler::Compiler::DEPENDENCY_DEPENDENCIES);\n  return ParsedSchema(impl->compiler.getLoader().get(id), *this);\n}"
  },
  {
    "function_name": "SchemaParser::parseDiskFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "176-180",
    "snippet": "ParsedSchema SchemaParser::parseDiskFile(\n    kj::StringPtr displayName, kj::StringPtr diskPath,\n    kj::ArrayPtr<const kj::StringPtr> importPath) const {\n  return parseFile(SchemaFile::newDiskFile(displayName, diskPath, importPath));\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parseFile",
          "args": [
            "SchemaFile::newDiskFile(displayName, diskPath, importPath)"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "SchemaParser::parseFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "182-189",
          "snippet": "ParsedSchema SchemaParser::parseFile(kj::Own<SchemaFile>&& file) const {\n  KJ_DEFER(impl->compiler.clearWorkspace());\n  uint64_t id = impl->compiler.add(getModuleImpl(kj::mv(file)));\n  impl->compiler.eagerlyCompile(id,\n      compiler::Compiler::NODE | compiler::Compiler::CHILDREN |\n      compiler::Compiler::DEPENDENCIES | compiler::Compiler::DEPENDENCY_DEPENDENCIES);\n  return ParsedSchema(impl->compiler.getLoader().get(id), *this);\n}",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nParsedSchema SchemaParser::parseFile(kj::Own<SchemaFile>&& file) const {\n  KJ_DEFER(impl->compiler.clearWorkspace());\n  uint64_t id = impl->compiler.add(getModuleImpl(kj::mv(file)));\n  impl->compiler.eagerlyCompile(id,\n      compiler::Compiler::NODE | compiler::Compiler::CHILDREN |\n      compiler::Compiler::DEPENDENCIES | compiler::Compiler::DEPENDENCY_DEPENDENCIES);\n  return ParsedSchema(impl->compiler.getLoader().get(id), *this);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SchemaFile::newDiskFile",
          "args": [
            "displayName",
            "diskPath",
            "importPath"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nParsedSchema SchemaParser::parseDiskFile(\n    kj::StringPtr displayName, kj::StringPtr diskPath,\n    kj::ArrayPtr<const kj::StringPtr> importPath) const {\n  return parseFile(SchemaFile::newDiskFile(displayName, diskPath, importPath));\n}"
  },
  {
    "function_name": "SchemaParser::~SchemaParser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "174-174",
    "snippet": "SchemaParser::~SchemaParser() noexcept(false) {}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nSchemaParser::~SchemaParser() noexcept(false) {}"
  },
  {
    "function_name": "SchemaParser::SchemaParser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "173-173",
    "snippet": "SchemaParser::SchemaParser(): impl(kj::heap<Impl>()) {}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<Impl>",
          "args": [],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "321-328",
          "snippet": "Own<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nSchemaParser::SchemaParser(): impl(kj::heap<Impl>()) {}"
  },
  {
    "function_name": "hadErrors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "135-137",
    "snippet": "bool hadErrors() override {\n    return parser.hadErrors;\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nbool hadErrors() override {\n    return parser.hadErrors;\n  }"
  },
  {
    "function_name": "addError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "113-133",
    "snippet": "void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n    auto& lines = lineBreaks.get(\n        [](kj::SpaceFor<kj::Vector<uint>>& space) {\n          KJ_FAIL_REQUIRE(\"Can't report errors until loadContent() is called.\");\n          return space.construct();\n        });\n\n    // TODO(someday):  This counts tabs as single characters.  Do we care?\n    uint startLine = findLargestElementBefore(lines, startByte);\n    uint startCol = startByte - lines[startLine];\n    uint endLine = findLargestElementBefore(lines, endByte);\n    uint endCol = endByte - lines[endLine];\n\n    file->reportError(\n        SchemaFile::SourcePos { startByte, startLine, startCol },\n        SchemaFile::SourcePos { endByte, endLine, endCol },\n        message);\n\n    // We intentionally only set hadErrors true if reportError() didn't throw.\n    parser.hadErrors = true;\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file->reportError",
          "args": [
            "SchemaFile::SourcePos { startByte, startLine, startCol }",
            "SchemaFile::SourcePos { endByte, endLine, endCol }",
            "message"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "reportError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "463-467",
          "snippet": "void reportError(SourcePos start, SourcePos end, kj::StringPtr message) const override {\n    kj::getExceptionCallback().onRecoverableException(kj::Exception(\n        kj::Exception::Type::FAILED, kj::heapString(diskPath), start.line,\n        kj::heapString(message)));\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nvoid reportError(SourcePos start, SourcePos end, kj::StringPtr message) const override {\n    kj::getExceptionCallback().onRecoverableException(kj::Exception(\n        kj::Exception::Type::FAILED, kj::heapString(diskPath), start.line,\n        kj::heapString(message)));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "findLargestElementBefore",
          "args": [
            "lines",
            "endByte"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "findLargestElementBefore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "51-67",
          "snippet": "size_t findLargestElementBefore(const kj::Vector<T>& vec, const T& key) {\n  KJ_REQUIRE(vec.size() > 0 && vec[0] <= key);\n\n  size_t lower = 0;\n  size_t upper = vec.size();\n\n  while (upper - lower > 1) {\n    size_t mid = (lower + upper) / 2;\n    if (vec[mid] > key) {\n      upper = mid;\n    } else {\n      lower = mid;\n    }\n  }\n\n  return lower;\n}",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nsize_t findLargestElementBefore(const kj::Vector<T>& vec, const T& key) {\n  KJ_REQUIRE(vec.size() > 0 && vec[0] <= key);\n\n  size_t lower = 0;\n  size_t upper = vec.size();\n\n  while (upper - lower > 1) {\n    size_t mid = (lower + upper) / 2;\n    if (vec[mid] > key) {\n      upper = mid;\n    } else {\n      lower = mid;\n    }\n  }\n\n  return lower;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lineBreaks.get",
          "args": [
            "[](kj::SpaceFor<kj::Vector<uint>>& space) {\n          KJ_FAIL_REQUIRE(\"Can't report errors until loadContent() is called.\");\n          return space.construct();\n        }"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "space.construct",
          "args": [],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "construct",
          "container": "SpaceFor",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "355-358",
          "snippet": "Own<T> construct(Params&&... params) {\n    ctor(value, kj::fwd<Params>(params)...);\n    return Own<T>(&value, DestructorOnlyDisposer<T>::instance);\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nSpaceFor {\n  Own<T> construct(Params&&... params) {\n      ctor(value, kj::fwd<Params>(params)...);\n      return Own<T>(&value, DestructorOnlyDisposer<T>::instance);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Can't report errors until loadContent() is called.\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nvoid addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n    auto& lines = lineBreaks.get(\n        [](kj::SpaceFor<kj::Vector<uint>>& space) {\n          KJ_FAIL_REQUIRE(\"Can't report errors until loadContent() is called.\");\n          return space.construct();\n        });\n\n    // TODO(someday):  This counts tabs as single characters.  Do we care?\n    uint startLine = findLargestElementBefore(lines, startByte);\n    uint startCol = startByte - lines[startLine];\n    uint endLine = findLargestElementBefore(lines, endByte);\n    uint endCol = endByte - lines[endLine];\n\n    file->reportError(\n        SchemaFile::SourcePos { startByte, startLine, startCol },\n        SchemaFile::SourcePos { endByte, endLine, endCol },\n        message);\n\n    // We intentionally only set hadErrors true if reportError() didn't throw.\n    parser.hadErrors = true;\n  }"
  },
  {
    "function_name": "importRelative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "105-111",
    "snippet": "kj::Maybe<Module&> importRelative(kj::StringPtr importPath) override {\n    KJ_IF_MAYBE(importedFile, file->import(importPath)) {\n      return parser.getModuleImpl(kj::mv(*importedFile));\n    } else {\n      return nullptr;\n    }\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parser.getModuleImpl",
          "args": [
            "kj::mv(*importedFile)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*importedFile"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "importedFile",
            "file->import(importPath)"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "file->import",
          "args": [
            "importPath"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "import",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "424-445",
          "snippet": "kj::Maybe<kj::Own<SchemaFile>> import(kj::StringPtr path) const override {\n    if (path.startsWith(\"/\")) {\n      for (auto candidate: importPath) {\n        kj::String newDiskPath = canonicalizePath(joinPath(candidate, path.slice(1)));\n        if (fileReader.exists(newDiskPath)) {\n          return kj::implicitCast<kj::Own<SchemaFile>>(kj::heap<DiskSchemaFile>(\n              fileReader, canonicalizePath(path.slice(1)),\n              kj::mv(newDiskPath), importPath));\n        }\n      }\n      return nullptr;\n    } else {\n      kj::String newDiskPath = canonicalizePath(relativePath(diskPath, path));\n      if (fileReader.exists(newDiskPath)) {\n        return kj::implicitCast<kj::Own<SchemaFile>>(kj::heap<DiskSchemaFile>(\n            fileReader, canonicalizePath(relativePath(displayName, path)),\n            kj::mv(newDiskPath), importPath));\n      } else {\n        return nullptr;\n      }\n    }\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::Maybe<kj::Own<SchemaFile>> import(kj::StringPtr path) const override {\n    if (path.startsWith(\"/\")) {\n      for (auto candidate: importPath) {\n        kj::String newDiskPath = canonicalizePath(joinPath(candidate, path.slice(1)));\n        if (fileReader.exists(newDiskPath)) {\n          return kj::implicitCast<kj::Own<SchemaFile>>(kj::heap<DiskSchemaFile>(\n              fileReader, canonicalizePath(path.slice(1)),\n              kj::mv(newDiskPath), importPath));\n        }\n      }\n      return nullptr;\n    } else {\n      kj::String newDiskPath = canonicalizePath(relativePath(diskPath, path));\n      if (fileReader.exists(newDiskPath)) {\n        return kj::implicitCast<kj::Own<SchemaFile>>(kj::heap<DiskSchemaFile>(\n            fileReader, canonicalizePath(relativePath(displayName, path)),\n            kj::mv(newDiskPath), importPath));\n      } else {\n        return nullptr;\n      }\n    }\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::Maybe<Module&> importRelative(kj::StringPtr importPath) override {\n    KJ_IF_MAYBE(importedFile, file->import(importPath)) {\n      return parser.getModuleImpl(kj::mv(*importedFile));\n    } else {\n      return nullptr;\n    }\n  }"
  },
  {
    "function_name": "loadContent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "82-103",
    "snippet": "Orphan<compiler::ParsedFile> loadContent(Orphanage orphanage) override {\n    kj::Array<const char> content = file->readContent();\n\n    lineBreaks.get([&](kj::SpaceFor<kj::Vector<uint>>& space) {\n      auto vec = space.construct(content.size() / 40);\n      vec->add(0);\n      for (const char* pos = content.begin(); pos < content.end(); ++pos) {\n        if (*pos == '\\n') {\n          vec->add(pos + 1 - content.begin());\n        }\n      }\n      return vec;\n    });\n\n    MallocMessageBuilder lexedBuilder;\n    auto statements = lexedBuilder.initRoot<compiler::LexedStatements>();\n    compiler::lex(content, statements, *this);\n\n    auto parsed = orphanage.newOrphan<compiler::ParsedFile>();\n    compiler::parseFile(statements.getStatements(), parsed.get(), *this);\n    return parsed;\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compiler::parseFile",
          "args": [
            "statements.getStatements()",
            "parsed.get()",
            "*this"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsed.get",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "statements.getStatements",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<compiler::ParsedFile>",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compiler::lex",
          "args": [
            "content",
            "statements",
            "*this"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lexedBuilder.initRoot<compiler::LexedStatements>",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lineBreaks.get",
          "args": [
            "[&](kj::SpaceFor<kj::Vector<uint>>& space) {\n      auto vec = space.construct(content.size() / 40);\n      vec->add(0);\n      for (const char* pos = content.begin(); pos < content.end(); ++pos) {\n        if (*pos == '\\n') {\n          vec->add(pos + 1 - content.begin());\n        }\n      }\n      return vec;\n    }"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "vec->add",
          "args": [
            "pos + 1 - content.begin()"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "content.begin",
          "args": [],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "content.end",
          "args": [],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      },
      {
        "call_info": {
          "callee": "space.construct",
          "args": [
            "content.size() / 40"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "558-560",
          "snippet": "static void construct(void* ptr) {\n    kj::ctor(*reinterpret_cast<T*>(ptr));\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nstatic void construct(void* ptr) {\n    kj::ctor(*reinterpret_cast<T*>(ptr));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "content.size",
          "args": [],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "file->readContent",
          "args": [],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "readContent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "420-422",
          "snippet": "kj::Array<const char> readContent() const override {\n    return fileReader.read(diskPath);\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::Array<const char> readContent() const override {\n    return fileReader.read(diskPath);\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nOrphan<compiler::ParsedFile> loadContent(Orphanage orphanage) override {\n    kj::Array<const char> content = file->readContent();\n\n    lineBreaks.get([&](kj::SpaceFor<kj::Vector<uint>>& space) {\n      auto vec = space.construct(content.size() / 40);\n      vec->add(0);\n      for (const char* pos = content.begin(); pos < content.end(); ++pos) {\n        if (*pos == '\\n') {\n          vec->add(pos + 1 - content.begin());\n        }\n      }\n      return vec;\n    });\n\n    MallocMessageBuilder lexedBuilder;\n    auto statements = lexedBuilder.initRoot<compiler::LexedStatements>();\n    compiler::lex(content, statements, *this);\n\n    auto parsed = orphanage.newOrphan<compiler::ParsedFile>();\n    compiler::parseFile(statements.getStatements(), parsed.get(), *this);\n    return parsed;\n  }"
  },
  {
    "function_name": "getSourceName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "78-80",
    "snippet": "kj::StringPtr getSourceName() override {\n    return file->getDisplayName();\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file->getDisplayName",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "getDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "416-418",
          "snippet": "kj::StringPtr getDisplayName() const override {\n    return displayName;\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::StringPtr getDisplayName() const override {\n    return displayName;\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::StringPtr getSourceName() override {\n    return file->getDisplayName();\n  }"
  },
  {
    "function_name": "ModuleImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "75-76",
    "snippet": "ModuleImpl(const SchemaParser& parser, kj::Own<const SchemaFile>&& file)\n      : parser(parser), file(kj::mv(file)) {}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "file"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nModuleImpl(const SchemaParser& parser, kj::Own<const SchemaFile>&& file)\n      : parser(parser), file(kj::mv(file)) {}"
  },
  {
    "function_name": "findLargestElementBefore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
    "lines": "51-67",
    "snippet": "size_t findLargestElementBefore(const kj::Vector<T>& vec, const T& key) {\n  KJ_REQUIRE(vec.size() > 0 && vec[0] <= key);\n\n  size_t lower = 0;\n  size_t upper = vec.size();\n\n  while (upper - lower > 1) {\n    size_t mid = (lower + upper) / 2;\n    if (vec[mid] > key) {\n      upper = mid;\n    } else {\n      lower = mid;\n    }\n  }\n\n  return lower;\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/vector.h>",
      "#include <kj/mutex.h>",
      "#include <unordered_map>",
      "#include <capnp/compiler/parser.h>",
      "#include <capnp/compiler/grammar.capnp.h>",
      "#include <capnp/compiler/lexer.h>",
      "#include <capnp/compiler/lexer.capnp.h>",
      "#include <capnp/compiler/compiler.h>",
      "#include \"message.h\"",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vec.size",
          "args": [],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "vec.size() > 0 && vec[0] <= key"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nsize_t findLargestElementBefore(const kj::Vector<T>& vec, const T& key) {\n  KJ_REQUIRE(vec.size() > 0 && vec[0] <= key);\n\n  size_t lower = 0;\n  size_t upper = vec.size();\n\n  while (upper - lower > 1) {\n    size_t mid = (lower + upper) / 2;\n    if (vec[mid] > key) {\n      upper = mid;\n    } else {\n      lower = mid;\n    }\n  }\n\n  return lower;\n}"
  }
]