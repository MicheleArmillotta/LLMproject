[
  {
    "function_name": "UnwindDetector::catchExceptionsIfUnwinding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
    "lines": "275-282",
    "snippet": "void UnwindDetector::catchExceptionsIfUnwinding(Func&& func) const {\n  if (isUnwinding()) {\n    _::RunnableImpl<Decay<Func>> runnable(kj::fwd<Func>(func));\n    catchExceptionsAsSecondaryFaults(runnable);\n  } else {\n    func();\n  }\n}",
    "includes": [
      "#include \"string.h\"",
      "#include \"array.h\"",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "func",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "catchExceptionsAsSecondaryFaults",
          "args": [
            "runnable"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "UnwindDetector::catchExceptionsAsSecondaryFaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "430-435",
          "snippet": "void UnwindDetector::catchExceptionsAsSecondaryFaults(_::Runnable& runnable) const {\n  // TODO(someday):  Attach the secondary exception to whatever primary exception is causing\n  //   the unwind.  For now we just drop it on the floor as this is probably fine most of the\n  //   time.\n  runCatchingExceptions(runnable);\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid UnwindDetector::catchExceptionsAsSecondaryFaults(_::Runnable& runnable) const {\n  // TODO(someday):  Attach the secondary exception to whatever primary exception is causing\n  //   the unwind.  For now we just drop it on the floor as this is probably fine most of the\n  //   time.\n  runCatchingExceptions(runnable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isUnwinding",
          "args": [],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "UnwindDetector::isUnwinding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "426-428",
          "snippet": "bool UnwindDetector::isUnwinding() const {\n  return _::uncaughtExceptionCount() > uncaughtCount;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nbool UnwindDetector::isUnwinding() const {\n  return _::uncaughtExceptionCount() > uncaughtCount;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nvoid UnwindDetector::catchExceptionsIfUnwinding(Func&& func) const {\n  if (isUnwinding()) {\n    _::RunnableImpl<Decay<Func>> runnable(kj::fwd<Func>(func));\n    catchExceptionsAsSecondaryFaults(runnable);\n  } else {\n    func();\n  }\n}"
  },
  {
    "function_name": "runCatchingExceptions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
    "lines": "269-272",
    "snippet": "Maybe<Exception> runCatchingExceptions(Func&& func) noexcept {\n  _::RunnableImpl<Decay<Func>> runnable(kj::fwd<Func>(func));\n  return _::runCatchingExceptions(runnable);\n}",
    "includes": [
      "#include \"string.h\"",
      "#include \"array.h\"",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_::runCatchingExceptions",
          "args": [
            "runnable"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nMaybe<Exception> runCatchingExceptions(Func&& func) noexcept {\n  _::RunnableImpl<Decay<Func>> runnable(kj::fwd<Func>(func));\n  return _::runCatchingExceptions(runnable);\n}"
  },
  {
    "function_name": "run",
    "container": "RunnableImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
    "lines": "257-259",
    "snippet": "void run() override {\n    func();\n  }",
    "includes": [
      "#include \"string.h\"",
      "#include \"array.h\"",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "func",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nRunnableImpl {\n  void run() override {\n      func();\n    }\n}"
  },
  {
    "function_name": "RunnableImpl",
    "container": "RunnableImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
    "lines": "256-256",
    "snippet": "RunnableImpl(Func&& func): func(kj::mv(func)) {}",
    "includes": [
      "#include \"string.h\"",
      "#include \"array.h\"",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "func"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nRunnableImpl {\n  RunnableImpl(Func&& func): func(kj::mv(func)) {}\n}"
  },
  {
    "function_name": "getContext",
    "container": "Exception",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
    "lines": "97-103",
    "snippet": "inline Maybe<const Context&> getContext() const {\n    KJ_IF_MAYBE(c, context) {\n      return **c;\n    } else {\n      return nullptr;\n    }\n  }",
    "includes": [
      "#include \"string.h\"",
      "#include \"array.h\"",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  inline Maybe<const Context&> getContext() const {\n      KJ_IF_MAYBE(c, context) {\n        return **c;\n      } else {\n        return nullptr;\n      }\n    }\n}"
  },
  {
    "function_name": "Context",
    "container": "Exception::Context",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
    "lines": "92-93",
    "snippet": "Context(const char* file, int line, String&& description, Maybe<Own<Context>>&& next)\n        : file(file), line(line), description(mv(description)), next(mv(next)) {}",
    "includes": [
      "#include \"string.h\"",
      "#include \"array.h\"",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "next"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "description"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  Context {\n    Context(const char* file, int line, String&& description, Maybe<Own<Context>>&& next)\n            : file(file), line(line), description(mv(description)), next(mv(next)) {}\n  }\n}"
  },
  {
    "function_name": "getStackTrace",
    "container": "Exception",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
    "lines": "82-82",
    "snippet": "ArrayPtr<void* const> getStackTrace() const { return arrayPtr(trace, traceCount); }",
    "includes": [
      "#include \"string.h\"",
      "#include \"array.h\"",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arrayPtr",
          "args": [
            "trace",
            "traceCount"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  ArrayPtr<void* const> getStackTrace() const { return arrayPtr(trace, traceCount); }\n}"
  },
  {
    "function_name": "getDescription",
    "container": "Exception",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
    "lines": "81-81",
    "snippet": "StringPtr getDescription() const { return description; }",
    "includes": [
      "#include \"string.h\"",
      "#include \"array.h\"",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  StringPtr getDescription() const { return description; }\n}"
  },
  {
    "function_name": "getType",
    "container": "Exception",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
    "lines": "80-80",
    "snippet": "Type getType() const { return type; }",
    "includes": [
      "#include \"string.h\"",
      "#include \"array.h\"",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  Type getType() const { return type; }\n}"
  },
  {
    "function_name": "getLine",
    "container": "Exception",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
    "lines": "79-79",
    "snippet": "int getLine() const { return line; }",
    "includes": [
      "#include \"string.h\"",
      "#include \"array.h\"",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  int getLine() const { return line; }\n}"
  }
]