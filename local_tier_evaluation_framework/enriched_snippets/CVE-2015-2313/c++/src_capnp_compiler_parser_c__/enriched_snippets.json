[
  {
    "function_name": "CapnpParser::parseStatement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "1054-1098",
    "snippet": "kj::Maybe<Orphan<Declaration>> CapnpParser::parseStatement(\n    Statement::Reader statement, const DeclParser& parser) {\n  auto fullParser = p::sequence(parser, p::endOfInput);\n\n  auto tokens = statement.getTokens();\n  ParserInput parserInput(tokens.begin(), tokens.end());\n\n  KJ_IF_MAYBE(output, fullParser(parserInput)) {\n    auto builder = output->decl.get();\n\n    if (statement.hasDocComment()) {\n      builder.setDocComment(statement.getDocComment());\n    }\n\n    builder.setStartByte(statement.getStartByte());\n    builder.setEndByte(statement.getEndByte());\n\n    switch (statement.which()) {\n      case Statement::LINE:\n        if (output->memberParser != nullptr) {\n          errorReporter.addError(statement.getStartByte(), statement.getEndByte(),\n              \"This statement should end with a block, not a semicolon.\");\n        }\n        break;\n\n      case Statement::BLOCK:\n        KJ_IF_MAYBE(memberParser, output->memberParser) {\n          auto memberStatements = statement.getBlock();\n          kj::Vector<Orphan<Declaration>> members(memberStatements.size());\n          for (auto memberStatement: memberStatements) {\n            KJ_IF_MAYBE(member, parseStatement(memberStatement, *memberParser)) {\n              members.add(kj::mv(*member));\n            }\n          }\n          builder.adoptNestedDecls(arrayToList(orphanage, members.releaseAsArray()));\n        } else {\n          errorReporter.addError(statement.getStartByte(), statement.getEndByte(),\n              \"This statement should end with a semicolon, not a block.\");\n        }\n        break;\n    }\n\n    return kj::mv(output->decl);\n\n  }",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "output->decl"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errorReporter.addError",
          "args": [
            "statement.getStartByte()",
            "statement.getEndByte()",
            "\"This statement should end with a semicolon, not a block.\""
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "addError",
          "container": "TestFailingErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer-test.c++",
          "lines": "32-34",
          "snippet": "void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n    KJ_FAIL_EXPECT(\"Parse failed.\", startByte, endByte, message);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"../message.h\"",
            "#include \"lexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"../message.h\"\n#include \"lexer.h\"\n\nTestFailingErrorReporter {\n  void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n      KJ_FAIL_EXPECT(\"Parse failed.\", startByte, endByte, message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "statement.getEndByte",
          "args": [],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statement.getStartByte",
          "args": [],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.adoptNestedDecls",
          "args": [
            "arrayToList(orphanage, members.releaseAsArray())"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arrayToList",
          "args": [
            "orphanage",
            "members.releaseAsArray()"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "arrayToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "353-360",
          "snippet": "Orphan<List<T>> arrayToList(Orphanage& orphanage, kj::Array<Orphan<T>>&& elements) {\n  auto result = orphanage.newOrphan<List<T>>(elements.size());\n  auto builder = result.get();\n  for (size_t i = 0; i < elements.size(); i++) {\n    builder.adoptWithCaveats(i, kj::mv(elements[i]));\n  }\n  return kj::mv(result);\n}",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nOrphan<List<T>> arrayToList(Orphanage& orphanage, kj::Array<Orphan<T>>&& elements) {\n  auto result = orphanage.newOrphan<List<T>>(elements.size());\n  auto builder = result.get();\n  for (size_t i = 0; i < elements.size(); i++) {\n    builder.adoptWithCaveats(i, kj::mv(elements[i]));\n  }\n  return kj::mv(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "members.releaseAsArray",
          "args": [],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "releaseAsArray",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "66-72",
          "snippet": "inline Array<T> releaseAsArray() {\n    // TODO(perf):  Avoid a copy/move by allowing Array<T> to point to incomplete space?\n    if (!builder.isFull()) {\n      setCapacity(size());\n    }\n    return builder.finish();\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline Array<T> releaseAsArray() {\n      // TODO(perf):  Avoid a copy/move by allowing Array<T> to point to incomplete space?\n      if (!builder.isFull()) {\n        setCapacity(size());\n      }\n      return builder.finish();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "members.add",
          "args": [
            "kj::mv(*member)"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*member"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "member",
            "parseStatement(memberStatement, *memberParser)"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "parseStatement",
          "args": [
            "memberStatement",
            "*memberParser"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memberStatements.size",
          "args": [],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "statement.getBlock",
          "args": [],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statement.getEndByte",
          "args": [],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statement.getStartByte",
          "args": [],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statement.which",
          "args": [],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setEndByte",
          "args": [
            "statement.getEndByte()"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statement.getEndByte",
          "args": [],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setStartByte",
          "args": [
            "statement.getStartByte()"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statement.getStartByte",
          "args": [],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setDocComment",
          "args": [
            "statement.getDocComment()"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statement.getDocComment",
          "args": [],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statement.hasDocComment",
          "args": [],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output->decl.get",
          "args": [],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tokens.end",
          "args": [],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "77-77",
          "snippet": "inline Iterator end() const { return Iterator(amount); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator end() const { return Iterator(amount); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tokens.begin",
          "args": [],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "76-76",
          "snippet": "inline Iterator begin() const { return Iterator(0); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "statement.getTokens",
          "args": [],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "parser",
            "p::endOfInput"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nkj::Maybe<Orphan<Declaration>> CapnpParser::parseStatement(\n    Statement::Reader statement, const DeclParser& parser) {\n  auto fullParser = p::sequence(parser, p::endOfInput);\n\n  auto tokens = statement.getTokens();\n  ParserInput parserInput(tokens.begin(), tokens.end());\n\n  KJ_IF_MAYBE(output, fullParser(parserInput)) {\n    auto builder = output->decl.get();\n\n    if (statement.hasDocComment()) {\n      builder.setDocComment(statement.getDocComment());\n    }\n\n    builder.setStartByte(statement.getStartByte());\n    builder.setEndByte(statement.getEndByte());\n\n    switch (statement.which()) {\n      case Statement::LINE:\n        if (output->memberParser != nullptr) {\n          errorReporter.addError(statement.getStartByte(), statement.getEndByte(),\n              \"This statement should end with a block, not a semicolon.\");\n        }\n        break;\n\n      case Statement::BLOCK:\n        KJ_IF_MAYBE(memberParser, output->memberParser) {\n          auto memberStatements = statement.getBlock();\n          kj::Vector<Orphan<Declaration>> members(memberStatements.size());\n          for (auto memberStatement: memberStatements) {\n            KJ_IF_MAYBE(member, parseStatement(memberStatement, *memberParser)) {\n              members.add(kj::mv(*member));\n            }\n          }\n          builder.adoptNestedDecls(arrayToList(orphanage, members.releaseAsArray()));\n        } else {\n          errorReporter.addError(statement.getStartByte(), statement.getEndByte(),\n              \"This statement should end with a semicolon, not a block.\");\n        }\n        break;\n    }\n\n    return kj::mv(output->decl);\n\n  }"
  },
  {
    "function_name": "CapnpParser::~CapnpParser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "1052-1052",
    "snippet": "CapnpParser::~CapnpParser() noexcept(false) {}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nCapnpParser::~CapnpParser() noexcept(false) {}"
  },
  {
    "function_name": "KJ_IF_MAYBE",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "982-1016",
    "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "errorReporter.addError",
          "args": [
            "target->startByte",
            "target->endByte",
            "\"Not a valid annotation target.\""
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "addError",
          "container": "TestFailingErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer-test.c++",
          "lines": "32-34",
          "snippet": "void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n    KJ_FAIL_EXPECT(\"Parse failed.\", startByte, endByte, message);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"../message.h\"",
            "#include \"lexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"../message.h\"\n#include \"lexer.h\"\n\nTestFailingErrorReporter {\n  void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n      KJ_FAIL_EXPECT(\"Parse failed.\", startByte, endByte, message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dynamicBuilder.set",
          "args": [
            "*field",
            "true"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "872-874",
          "snippet": "static inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "dynamicBuilder.get",
          "args": [],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dynamicBuilder.get",
          "args": [
            "*field"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "dynamicBuilder.getSchema",
          "args": [
            "buffer"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dynamicBuilder.getSchema",
          "args": [],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "getSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "505-505",
          "snippet": "inline InterfaceSchema getSchema() const { return schema; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline InterfaceSchema getSchema() const { return schema; }"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"targets\""
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "buffer",
            "target->value.cStr()"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target->value.cStr",
          "args": [],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buffer",
            "\"targets\""
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target->value.size",
          "args": [],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "field.getProto",
          "args": [
            "\"targets\""
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getProto",
          "args": [],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
  },
  {
    "function_name": "KJ_IF_MAYBE",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "946-948",
    "snippet": "KJ_IF_MAYBE(r, results) {\n          builder.getResults().adoptExplicit(kj::mv(*r));\n        }",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.getResults",
          "args": [
            "kj::mv(*r)"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "154-161",
          "snippet": "AnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<Response<AnyPointer>> response;",
            "AnyPointer::Builder responseBuilder = nullptr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<Response<AnyPointer>> response;\nAnyPointer::Builder responseBuilder = nullptr;\n\nAnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*r"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getResults",
          "args": [],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1644-1646",
          "snippet": "AnyPointer::Reader getResults() override {\n      return message.getRoot<AnyPointer>();\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  AnyPointer::Reader getResults() override {\n        return message.getRoot<AnyPointer>();\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(r, results) {\n          builder.getResults().adoptExplicit(kj::mv(*r));\n        }"
  },
  {
    "function_name": "KJ_IF_MAYBE",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "889-891",
    "snippet": "KJ_IF_MAYBE(val, defaultValue) {\n          builder.getDefaultValue().adoptValue(kj::mv(*val));\n        }",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.getDefaultValue",
          "args": [
            "kj::mv(*val)"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*val"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getDefaultValue",
          "args": [],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(val, defaultValue) {\n          builder.getDefaultValue().adoptValue(kj::mv(*val));\n        }"
  },
  {
    "function_name": "KJ_IF_MAYBE",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "861-868",
    "snippet": "KJ_IF_MAYBE(s, superclasses) {\n          auto superclassesBuilder = builder.initSuperclasses(s->value.size());\n          for (uint i: kj::indices(s->value)) {\n            KJ_IF_MAYBE(superclass, s->value[i]) {\n              superclassesBuilder.adoptWithCaveats(i, kj::mv(*superclass));\n            }\n          }\n        }",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "superclassesBuilder.adoptWithCaveats",
          "args": [
            "i",
            "kj::mv(*superclass)"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "adoptWithCaveats",
          "container": "Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/list.h",
          "lines": "251-268",
          "snippet": "inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n      // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n      // the fact that structs in a struct list are allocated inline rather than by pointer:\n      // * This actually performs a shallow copy, effectively adopting each of the orphan's\n      //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n      //   possibly wasting space in the message object.\n      // * If the orphan is larger than the target struct -- say, because the orphan was built\n      //   using a newer version of the schema that has additional fields -- it will be truncated,\n      //   losing data.\n\n      KJ_IREQUIRE(index < size());\n\n      // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n      // expanded under any circumstances.  We're just going to throw it away anyway, and\n      // transferContentFrom() already carefully compares the struct sizes before transferring.\n      builder.getStructElement(index * ELEMENTS).transferContentFrom(\n          orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n    }",
          "includes": [
            "#include <iterator>",
            "#include <initializer_list>",
            "#include \"orphan.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <initializer_list>\n#include \"orphan.h\"\n#include \"layout.h\"\n\nBuilder {\n  inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n        // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n        // the fact that structs in a struct list are allocated inline rather than by pointer:\n        // * This actually performs a shallow copy, effectively adopting each of the orphan's\n        //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n        //   possibly wasting space in the message object.\n        // * If the orphan is larger than the target struct -- say, because the orphan was built\n        //   using a newer version of the schema that has additional fields -- it will be truncated,\n        //   losing data.\n  \n        KJ_IREQUIRE(index < size());\n  \n        // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n        // expanded under any circumstances.  We're just going to throw it away anyway, and\n        // transferContentFrom() already carefully compares the struct sizes before transferring.\n        builder.getStructElement(index * ELEMENTS).transferContentFrom(\n            orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*superclass"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "s->value"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.initSuperclasses",
          "args": [
            "s->value.size()"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s->value.size",
          "args": [],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(s, superclasses) {\n          auto superclassesBuilder = builder.initSuperclasses(s->value.size());\n          for (uint i: kj::indices(s->value)) {\n            KJ_IF_MAYBE(superclass, s->value[i]) {\n              superclassesBuilder.adoptWithCaveats(i, kj::mv(*superclass));\n            }\n          }\n        }"
  },
  {
    "function_name": "KJ_IF_MAYBE",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "816-818",
    "snippet": "KJ_IF_MAYBE(ord, ordinal) {\n          builder.getId().adoptOrdinal(kj::mv(*ord));\n        }",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.getId",
          "args": [
            "kj::mv(*ord)"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*ord"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getId",
          "args": [],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(ord, ordinal) {\n          builder.getId().adoptOrdinal(kj::mv(*ord));\n        }"
  },
  {
    "function_name": "KJ_IF_MAYBE",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "754-756",
    "snippet": "KJ_IF_MAYBE(val, defaultValue) {\n          builder.getDefaultValue().adoptValue(kj::mv(*val));\n        }",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.getDefaultValue",
          "args": [
            "kj::mv(*val)"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*val"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getDefaultValue",
          "args": [],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(val, defaultValue) {\n          builder.getDefaultValue().adoptValue(kj::mv(*val));\n        }"
  },
  {
    "function_name": "CapnpParser::CapnpParser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "421-685",
    "snippet": "CapnpParser::CapnpParser(Orphanage orphanageParam, ErrorReporter& errorReporterParam)\n    : orphanage(orphanageParam), errorReporter(errorReporterParam) {\n  auto& tupleElement = arena.copy(p::transform(\n      p::sequence(p::optional(p::sequence(identifier, op(\"=\"))), parsers.expression),\n      [this](kj::Maybe<Located<Text::Reader>>&& fieldName, Orphan<Expression>&& fieldValue)\n             -> Orphan<Expression::Param> {\n        auto result = orphanage.newOrphan<Expression::Param>();\n        auto builder = result.get();\n        KJ_IF_MAYBE(fn, fieldName) {\n          fn->copyTo(builder.initNamed());\n        } else {\n          builder.setUnnamed();\n        }\n        builder.adoptValue(kj::mv(fieldValue));\n        return kj::mv(result);\n      }));\n\n  auto& tuple = arena.copy<Parser<Located<Orphan<List<Expression::Param>>>>>(\n      arena.copy(p::transform(\n        parenthesizedList(tupleElement, errorReporter),\n        [this](Located<kj::Array<kj::Maybe<Orphan<Expression::Param>>>>&& elements)\n               -> Located<Orphan<List<Expression::Param>>> {\n          auto result = orphanage.newOrphan<List<Expression::Param>>(elements.value.size());\n          auto builder = result.get();\n          for (uint i: kj::indices(elements.value)) {\n            KJ_IF_MAYBE(e, elements.value[i]) {\n              builder.adoptWithCaveats(i, kj::mv(*e));\n            } else {\n              builder[i].initValue().setUnknown();\n            }\n          }\n          return elements.rewrap(kj::mv(result));\n        })));\n\n  parsers.expression = arena.copy(p::transform(\n      p::sequence(\n          // Base expression.\n          p::oneOf(\n              p::transform(integerLiteral,\n                  [this](Located<uint64_t>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setPositiveInt(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(p::sequence(op(\"-\"), integerLiteral),\n                  [this](Located<uint64_t>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setNegativeInt(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(floatLiteral,\n                  [this](Located<double>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setFloat(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(p::sequence(op(\"-\"), floatLiteral),\n                  [this](Located<double>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setFloat(-value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transformWithLocation(p::sequence(op(\"-\"), keyword(\"inf\")),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location)\n                      -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setFloat(-kj::inf());\n                    initLocation(location, builder);\n                    return result;\n                  }),\n              p::transform(stringLiteral,\n                  [this](Located<Text::Reader>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setString(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(binaryLiteral,\n                  [this](Located<Data::Reader>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setBinary(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(bracketedList(parsers.expression, errorReporter),\n                  [this](Located<kj::Array<kj::Maybe<Orphan<Expression>>>>&& value)\n                      -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    auto listBuilder = builder.initList(value.value.size());\n                    for (uint i = 0; i < value.value.size(); i++) {\n                      KJ_IF_MAYBE(element, value.value[i]) {\n                        listBuilder.adoptWithCaveats(i, kj::mv(*element));\n                      }\n                    }\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(tuple,\n                  [this](Located<Orphan<List<Expression::Param>>>&& value)\n                      -> Orphan<Expression> {\n                    auto elements = value.value.get();\n\n                    if (elements.size() == 1 && elements[0].isUnnamed()) {\n                      // Single-value tuple is just a value.\n                      return elements[0].disownValue();\n                    } else {\n                      auto result = orphanage.newOrphan<Expression>();\n                      auto builder = result.get();\n                      builder.adoptTuple(kj::mv(value.value));\n                      value.copyLocationTo(builder);\n                      return result;\n                    }\n                  }),\n              p::transformWithLocation(p::sequence(keyword(\"import\"), stringLiteral),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location,\n                         Located<Text::Reader>&& filename) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    initLocation(location, builder);\n                    filename.copyTo(builder.initImport());\n                    return result;\n                  }),\n              p::transformWithLocation(p::sequence(op(\".\"), identifier),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location,\n                         Located<Text::Reader>&& name) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    initLocation(location, builder);\n                    name.copyTo(builder.initAbsoluteName());\n                    return result;\n                  }),\n              p::transform(identifier,\n                  [this](Located<Text::Reader>&& name) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    name.copyTo(builder.initRelativeName());\n                    name.copyLocationTo(builder);\n                    return result;\n                  })),\n          // Suffixes, e.g. \".member\" or \"(param1, param2)\".\n          p::many(p::oneOf(\n              p::transformWithLocation(p::sequence(op(\".\"), identifier),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location,\n                         Located<Text::Reader>&& name) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    initLocation(location, builder);\n                    name.copyTo(builder.initMember().initName());\n                    return result;\n                  }),\n              p::transform(tuple,\n                  [this](Located<Orphan<List<Expression::Param>>>&& params) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    params.copyLocationTo(builder);\n                    builder.initApplication().adoptParams(kj::mv(params.value));\n                    return result;\n                  })))),\n      [this](Orphan<Expression>&& base, kj::Array<Orphan<Expression>>&& suffixes)\n          -> Orphan<Expression> {\n        // Apply all the suffixes to the base expression.\n        uint startByte = base.getReader().getStartByte();\n        for (auto& suffix: suffixes) {\n          auto builder = suffix.get();\n          if (builder.isApplication()) {\n            builder.getApplication().adoptFunction(kj::mv(base));\n          } else if (builder.isMember()) {\n            builder.getMember().adoptParent(kj::mv(base));\n          } else {\n            KJ_FAIL_ASSERT(\"Unknown suffix?\", (uint)builder.which());\n          }\n          builder.setStartByte(startByte);\n          base = kj::mv(suffix);\n        }\n        return kj::mv(base);\n      }));\n\n  parsers.annotation = arena.copy(p::transform(\n      p::sequence(op(\"$\"), parsers.expression),\n      [this](Orphan<Expression>&& expression)\n          -> Orphan<Declaration::AnnotationApplication> {\n        auto result = orphanage.newOrphan<Declaration::AnnotationApplication>();\n        auto builder = result.get();\n\n        auto exp = expression.get();\n        if (exp.isApplication()) {\n          // Oops, this annotation specifies the value, but we parsed it as an application on\n          // the preceding expression. Pull it back apart.\n          auto app = exp.getApplication();\n          builder.adoptName(app.disownFunction());\n          auto params = app.getParams();\n          if (params.size() == 1 && params[0].isUnnamed()) {\n            // Params has a single unnamed element, so reduce it to a simple value rather than\n            // a tuple.\n            builder.getValue().adoptExpression(params[0].disownValue());\n          } else {\n            // Params is not a single unnamed element, so it's a tuple.\n            builder.getValue().initExpression().adoptTuple(app.disownParams());\n          }\n        } else {\n          // The annotation has no value.\n          builder.adoptName(kj::mv(expression));\n          builder.getValue().setNone();\n        }\n\n        return result;\n      }));\n\n  parsers.uid = arena.copy(p::transform(\n      p::sequence(op(\"@\"), integerLiteral),\n      [this](Located<uint64_t>&& value) {\n        if (value.value < (1ull << 63)) {\n          errorReporter.addError(value.startByte, value.endByte,\n              \"Invalid ID.  Please generate a new one with 'capnpc -i'.\");\n        }\n        return value.asProto<LocatedInteger>(orphanage);\n      }));\n\n  parsers.ordinal = arena.copy(p::transform(\n      p::sequence(op(\"@\"), integerLiteral),\n      [this](Located<uint64_t>&& value) {\n        if (value.value >= 65536) {\n          errorReporter.addError(value.startByte, value.endByte,\n              \"Ordinals cannot be greater than 65535.\");\n        }\n        return value.asProto<LocatedInteger>(orphanage);\n      }));\n\n  // -----------------------------------------------------------------\n\n  parsers.usingDecl = arena.copy(p::transform(\n      p::sequence(keyword(\"using\"), p::optional(p::sequence(identifier, op(\"=\"))),\n                  parsers.expression),\n      [this](kj::Maybe<Located<Text::Reader>>&& name, Orphan<Expression>&& target)\n          -> DeclParserResult {\n        auto decl = orphanage.newOrphan<Declaration>();\n        auto builder = decl.get();\n        KJ_IF_MAYBE(n, name) {\n          n->copyTo(builder.initName());\n        } else {\n          auto targetReader = target.getReader();\n          if (targetReader.isMember()) {\n            builder.setName(targetReader.getMember().getName());\n          } else {\n            errorReporter.addErrorOn(targetReader,\n                \"'using' declaration without '=' must specify a named declaration from a \"\n                \"different scope.\");\n          }\n        }\n        // no id, no annotations for using decl\n        builder.initUsing().adoptTarget(kj::mv(target));\n        return DeclParserResult(kj::mv(decl));\n      }",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arena.copy",
          "args": [
            "p::transform(\n      p::sequence(keyword(\"using\"), p::optional(p::sequence(identifier, op(\"=\"))),\n                  parsers.expression),\n      [this](kj::Maybe<Located<Text::Reader>>&& name, Orphan<Expression>&& target)\n          -> DeclParserResult {\n        auto decl = orphanage.newOrphan<Declaration>();\n        auto builder = decl.get();\n        KJ_IF_MAYBE(n, name) {\n          n->copyTo(builder.initName());\n        } else {\n          auto targetReader = target.getReader();\n          if (targetReader.isMember()) {\n            builder.setName(targetReader.getMember().getName());\n          } else {\n            errorReporter.addErrorOn(targetReader,\n                \"'using' declaration without '=' must specify a named declaration from a \"\n                \"different scope.\");\n          }\n        }\n        // no id, no annotations for using decl\n        builder.initUsing().adoptTarget(kj::mv(target));\n        return DeclParserResult(kj::mv(decl)"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::transform",
          "args": [
            "p::sequence(keyword(\"using\"), p::optional(p::sequence(identifier, op(\"=\"))),\n                  parsers.expression)",
            "[this](kj::Maybe<Located<Text::Reader>>&& name, Orphan<Expression>&& target)\n          -> DeclParserResult {\n        auto decl = orphanage.newOrphan<Declaration>();\n        auto builder = decl.get();\n        KJ_IF_MAYBE(n, name) {\n          n->copyTo(builder.initName());\n        } else {\n          auto targetReader = target.getReader();\n          if (targetReader.isMember()) {\n            builder.setName(targetReader.getMember().getName());\n          } else {\n            errorReporter.addErrorOn(targetReader,\n                \"'using' declaration without '=' must specify a named declaration from a \"\n                \"different scope.\");\n          }\n        }\n        // no id, no annotations for using decl\n        builder.initUsing().adoptTarget(kj::mv(target));\n        return DeclParserResult(kj::mv(decl"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "699-706",
          "snippet": "constexpr Transform_<SubParser, TransformFunc> transform(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Constructs a parser which executes some other parser and then transforms the result by invoking\n  // `functor` on it.  Typically `functor` is a lambda.  It is invoked using `kj::apply`,\n  // meaning tuples will be unpacked as arguments.\n  return Transform_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr Transform_<SubParser, TransformFunc> transform(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Constructs a parser which executes some other parser and then transforms the result by invoking\n  // `functor` on it.  Typically `functor` is a lambda.  It is invoked using `kj::apply`,\n  // meaning tuples will be unpacked as arguments.\n  return Transform_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}"
        }
      },
      {
        "call_info": {
          "callee": "[this]",
          "args": [
            "kj::mv(target)"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "target"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "[this]",
          "args": [],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errorReporter.addErrorOn",
          "args": [
            "targetReader",
            "\"'using' declaration without '=' must specify a named declaration from a \"\n                \"different scope.\""
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "addErrorOn",
          "container": "ErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.h",
          "lines": "47-52",
          "snippet": "inline void addErrorOn(T&& decl, kj::StringPtr message) {\n    // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n    // of the Cap'n Proto types defined in `grammar.capnp` do.\n\n    addError(decl.getStartByte(), decl.getEndByte(), message);\n  }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/string.h>",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/string.h>\n#include \"../common.h\"\n\nErrorReporter {\n  inline void addErrorOn(T&& decl, kj::StringPtr message) {\n      // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n      // of the Cap'n Proto types defined in `grammar.capnp` do.\n  \n      addError(decl.getStartByte(), decl.getEndByte(), message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.setName",
          "args": [
            "targetReader.getMember().getName()"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "targetReader.getMember",
          "args": [],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "targetReader.getMember",
          "args": [],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "targetReader.isMember",
          "args": [],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.getReader",
          "args": [],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n->copyTo",
          "args": [
            "builder.initName()"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "copyTo",
          "container": "Located",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "209-212",
          "snippet": "void copyTo(Builder builder) {\n    builder.setValue(value);\n    copyLocationTo(builder);\n  }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nLocated {\n  void copyTo(Builder builder) {\n      builder.setValue(value);\n      copyLocationTo(builder);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.initName",
          "args": [],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.get",
          "args": [],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Declaration>",
          "args": [],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "keyword(\"using\")",
            "p::optional(p::sequence(identifier, op(\"=\")))",
            "parsers.expression"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::optional",
          "args": [
            "p::sequence(identifier, op(\"=\"))"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "optional",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "548-552",
          "snippet": "constexpr Optional_<SubParser> optional(SubParser&& subParser) {\n  // Constructs a parser that accepts zero or one of the given sub-parser, returning a Maybe\n  // of the sub-parser's result.\n  return Optional_<SubParser>(kj::fwd<SubParser>(subParser));\n}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr Optional_<SubParser> optional(SubParser&& subParser) {\n  // Constructs a parser that accepts zero or one of the given sub-parser, returning a Maybe\n  // of the sub-parser's result.\n  return Optional_<SubParser>(kj::fwd<SubParser>(subParser));\n}"
        }
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "identifier",
            "op(\"=\")"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op",
          "args": [
            "\"=\""
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "281-284",
          "snippet": "constexpr auto op(const char* expected)\n    -> decltype(p::transformOrReject(operatorToken, ExactString(expected))) {\n  return p::transformOrReject(operatorToken, ExactString(expected));\n}",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nconstexpr auto op(const char* expected)\n    -> decltype(p::transformOrReject(operatorToken, ExactString(expected))) {\n  return p::transformOrReject(operatorToken, ExactString(expected));\n}"
        }
      },
      {
        "call_info": {
          "callee": "keyword",
          "args": [
            "\"using\""
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "keyword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "276-279",
          "snippet": "constexpr auto keyword(const char* expected)\n    -> decltype(p::transformOrReject(identifier, ExactString(expected))) {\n  return p::transformOrReject(identifier, ExactString(expected));\n}",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nconstexpr auto keyword(const char* expected)\n    -> decltype(p::transformOrReject(identifier, ExactString(expected))) {\n  return p::transformOrReject(identifier, ExactString(expected));\n}"
        }
      },
      {
        "call_info": {
          "callee": "arena.copy",
          "args": [
            "p::transform(\n      p::sequence(op(\"@\"), integerLiteral),\n      [this](Located<uint64_t>&& value) {\n        if (value.value >= 65536) {\n          errorReporter.addError(value.startByte, value.endByte,\n              \"Ordinals cannot be greater than 65535.\");\n        }\n        return value.asProto<LocatedInteger>(orphanage);\n      })"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.asProto<LocatedInteger>",
          "args": [
            "orphanage"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "asProto",
          "container": "Located",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "214-218",
          "snippet": "Orphan<Result> asProto(Orphanage orphanage) {\n    auto result = orphanage.newOrphan<Result>();\n    copyTo(result.get());\n    return result;\n  }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nLocated {\n  Orphan<Result> asProto(Orphanage orphanage) {\n      auto result = orphanage.newOrphan<Result>();\n      copyTo(result.get());\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "errorReporter.addError",
          "args": [
            "value.startByte",
            "value.endByte",
            "\"Ordinals cannot be greater than 65535.\""
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "addError",
          "container": "TestFailingErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer-test.c++",
          "lines": "32-34",
          "snippet": "void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n    KJ_FAIL_EXPECT(\"Parse failed.\", startByte, endByte, message);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"../message.h\"",
            "#include \"lexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"../message.h\"\n#include \"lexer.h\"\n\nTestFailingErrorReporter {\n  void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n      KJ_FAIL_EXPECT(\"Parse failed.\", startByte, endByte, message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "op(\"@\")",
            "integerLiteral"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.copy",
          "args": [
            "p::transform(\n      p::sequence(op(\"@\"), integerLiteral),\n      [this](Located<uint64_t>&& value) {\n        if (value.value < (1ull << 63)) {\n          errorReporter.addError(value.startByte, value.endByte,\n              \"Invalid ID.  Please generate a new one with 'capnpc -i'.\");\n        }\n        return value.asProto<LocatedInteger>(orphanage);\n      })"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "op(\"@\")",
            "integerLiteral"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.copy",
          "args": [
            "p::transform(\n      p::sequence(op(\"$\"), parsers.expression),\n      [this](Orphan<Expression>&& expression)\n          -> Orphan<Declaration::AnnotationApplication> {\n        auto result = orphanage.newOrphan<Declaration::AnnotationApplication>();\n        auto builder = result.get();\n\n        auto exp = expression.get();\n        if (exp.isApplication()) {\n          // Oops, this annotation specifies the value, but we parsed it as an application on\n          // the preceding expression. Pull it back apart.\n          auto app = exp.getApplication();\n          builder.adoptName(app.disownFunction());\n          auto params = app.getParams();\n          if (params.size() == 1 && params[0].isUnnamed()) {\n            // Params has a single unnamed element, so reduce it to a simple value rather than\n            // a tuple.\n            builder.getValue().adoptExpression(params[0].disownValue());\n          } else {\n            // Params is not a single unnamed element, so it's a tuple.\n            builder.getValue().initExpression().adoptTuple(app.disownParams());\n          }\n        } else {\n          // The annotation has no value.\n          builder.adoptName(kj::mv(expression));\n          builder.getValue().setNone();\n        }\n\n        return result;\n      })"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getValue",
          "args": [],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getValue",
          "args": [],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.adoptName",
          "args": [
            "kj::mv(expression)"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "expression"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getValue",
          "args": [
            "app.disownParams()"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "app.disownParams",
          "args": [],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getValue",
          "args": [],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getValue",
          "args": [],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getValue",
          "args": [
            "params[0].disownValue()"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[0].disownValue",
          "args": [],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getValue",
          "args": [],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[0].isUnnamed",
          "args": [],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "app.getParams",
          "args": [],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.adoptName",
          "args": [
            "app.disownFunction()"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "app.disownFunction",
          "args": [],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getApplication",
          "args": [],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.isApplication",
          "args": [],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Declaration::AnnotationApplication>",
          "args": [],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "op(\"$\")",
            "parsers.expression"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.copy",
          "args": [
            "p::transform(\n      p::sequence(\n          // Base expression.\n          p::oneOf(\n              p::transform(integerLiteral,\n                  [this](Located<uint64_t>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setPositiveInt(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(p::sequence(op(\"-\"), integerLiteral),\n                  [this](Located<uint64_t>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setNegativeInt(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(floatLiteral,\n                  [this](Located<double>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setFloat(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(p::sequence(op(\"-\"), floatLiteral),\n                  [this](Located<double>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setFloat(-value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transformWithLocation(p::sequence(op(\"-\"), keyword(\"inf\")),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location)\n                      -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setFloat(-kj::inf());\n                    initLocation(location, builder);\n                    return result;\n                  }),\n              p::transform(stringLiteral,\n                  [this](Located<Text::Reader>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setString(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(binaryLiteral,\n                  [this](Located<Data::Reader>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setBinary(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(bracketedList(parsers.expression, errorReporter),\n                  [this](Located<kj::Array<kj::Maybe<Orphan<Expression>>>>&& value)\n                      -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    auto listBuilder = builder.initList(value.value.size());\n                    for (uint i = 0; i < value.value.size(); i++) {\n                      KJ_IF_MAYBE(element, value.value[i]) {\n                        listBuilder.adoptWithCaveats(i, kj::mv(*element));\n                      }\n                    }\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(tuple,\n                  [this](Located<Orphan<List<Expression::Param>>>&& value)\n                      -> Orphan<Expression> {\n                    auto elements = value.value.get();\n\n                    if (elements.size() == 1 && elements[0].isUnnamed()) {\n                      // Single-value tuple is just a value.\n                      return elements[0].disownValue();\n                    } else {\n                      auto result = orphanage.newOrphan<Expression>();\n                      auto builder = result.get();\n                      builder.adoptTuple(kj::mv(value.value));\n                      value.copyLocationTo(builder);\n                      return result;\n                    }\n                  }),\n              p::transformWithLocation(p::sequence(keyword(\"import\"), stringLiteral),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location,\n                         Located<Text::Reader>&& filename) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    initLocation(location, builder);\n                    filename.copyTo(builder.initImport());\n                    return result;\n                  }),\n              p::transformWithLocation(p::sequence(op(\".\"), identifier),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location,\n                         Located<Text::Reader>&& name) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    initLocation(location, builder);\n                    name.copyTo(builder.initAbsoluteName());\n                    return result;\n                  }),\n              p::transform(identifier,\n                  [this](Located<Text::Reader>&& name) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    name.copyTo(builder.initRelativeName());\n                    name.copyLocationTo(builder);\n                    return result;\n                  })),\n          // Suffixes, e.g. \".member\" or \"(param1, param2)\".\n          p::many(p::oneOf(\n              p::transformWithLocation(p::sequence(op(\".\"), identifier),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location,\n                         Located<Text::Reader>&& name) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    initLocation(location, builder);\n                    name.copyTo(builder.initMember().initName());\n                    return result;\n                  }),\n              p::transform(tuple,\n                  [this](Located<Orphan<List<Expression::Param>>>&& params) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    params.copyLocationTo(builder);\n                    builder.initApplication().adoptParams(kj::mv(params.value));\n                    return result;\n                  })))),\n      [this](Orphan<Expression>&& base, kj::Array<Orphan<Expression>>&& suffixes)\n          -> Orphan<Expression> {\n        // Apply all the suffixes to the base expression.\n        uint startByte = base.getReader().getStartByte();\n        for (auto& suffix: suffixes) {\n          auto builder = suffix.get();\n          if (builder.isApplication()) {\n            builder.getApplication().adoptFunction(kj::mv(base));\n          } else if (builder.isMember()) {\n            builder.getMember().adoptParent(kj::mv(base));\n          } else {\n            KJ_FAIL_ASSERT(\"Unknown suffix?\", (uint)builder.which());\n          }\n          builder.setStartByte(startByte);\n          base = kj::mv(suffix);\n        }\n        return kj::mv(base);\n      })"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "base"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "suffix"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setStartByte",
          "args": [
            "startByte"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Unknown suffix?\"",
            "(uint)builder.which()"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.which",
          "args": [],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getMember",
          "args": [
            "kj::mv(base)"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "base"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getMember",
          "args": [],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.isMember",
          "args": [],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getApplication",
          "args": [
            "kj::mv(base)"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "base"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getApplication",
          "args": [],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.isApplication",
          "args": [],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base.getReader",
          "args": [],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base.getReader",
          "args": [],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "// Base expression.p::oneOf(\n              p::transform(integerLiteral,\n                  [this](Located<uint64_t>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setPositiveInt(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(p::sequence(op(\"-\"), integerLiteral),\n                  [this](Located<uint64_t>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setNegativeInt(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(floatLiteral,\n                  [this](Located<double>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setFloat(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(p::sequence(op(\"-\"), floatLiteral),\n                  [this](Located<double>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setFloat(-value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transformWithLocation(p::sequence(op(\"-\"), keyword(\"inf\")),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location)\n                      -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setFloat(-kj::inf());\n                    initLocation(location, builder);\n                    return result;\n                  }),\n              p::transform(stringLiteral,\n                  [this](Located<Text::Reader>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setString(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(binaryLiteral,\n                  [this](Located<Data::Reader>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setBinary(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(bracketedList(parsers.expression, errorReporter),\n                  [this](Located<kj::Array<kj::Maybe<Orphan<Expression>>>>&& value)\n                      -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    auto listBuilder = builder.initList(value.value.size());\n                    for (uint i = 0; i < value.value.size(); i++) {\n                      KJ_IF_MAYBE(element, value.value[i]) {\n                        listBuilder.adoptWithCaveats(i, kj::mv(*element));\n                      }\n                    }\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(tuple,\n                  [this](Located<Orphan<List<Expression::Param>>>&& value)\n                      -> Orphan<Expression> {\n                    auto elements = value.value.get();\n\n                    if (elements.size() == 1 && elements[0].isUnnamed()) {\n                      // Single-value tuple is just a value.\n                      return elements[0].disownValue();\n                    } else {\n                      auto result = orphanage.newOrphan<Expression>();\n                      auto builder = result.get();\n                      builder.adoptTuple(kj::mv(value.value));\n                      value.copyLocationTo(builder);\n                      return result;\n                    }\n                  }),\n              p::transformWithLocation(p::sequence(keyword(\"import\"), stringLiteral),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location,\n                         Located<Text::Reader>&& filename) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    initLocation(location, builder);\n                    filename.copyTo(builder.initImport());\n                    return result;\n                  }),\n              p::transformWithLocation(p::sequence(op(\".\"), identifier),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location,\n                         Located<Text::Reader>&& name) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    initLocation(location, builder);\n                    name.copyTo(builder.initAbsoluteName());\n                    return result;\n                  }),\n              p::transform(identifier,\n                  [this](Located<Text::Reader>&& name) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    name.copyTo(builder.initRelativeName());\n                    name.copyLocationTo(builder);\n                    return result;\n                  }))",
            "// Suffixes, e.g. \".member\" or \"(param1, param2)\".p::many(p::oneOf(\n              p::transformWithLocation(p::sequence(op(\".\"), identifier),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location,\n                         Located<Text::Reader>&& name) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    initLocation(location, builder);\n                    name.copyTo(builder.initMember().initName());\n                    return result;\n                  }),\n              p::transform(tuple,\n                  [this](Located<Orphan<List<Expression::Param>>>&& params) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    params.copyLocationTo(builder);\n                    builder.initApplication().adoptParams(kj::mv(params.value));\n                    return result;\n                  })))"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::many",
          "args": [
            "p::oneOf(\n              p::transformWithLocation(p::sequence(op(\".\"), identifier),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location,\n                         Located<Text::Reader>&& name) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    initLocation(location, builder);\n                    name.copyTo(builder.initMember().initName());\n                    return result;\n                  }),\n              p::transform(tuple,\n                  [this](Located<Orphan<List<Expression::Param>>>&& params) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    params.copyLocationTo(builder);\n                    builder.initApplication().adoptParams(kj::mv(params.value));\n                    return result;\n                  }))"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "432-436",
          "snippet": "constexpr Many_<SubParser, false> many(SubParser&& subParser) {\n  // Constructs a parser that repeatedly executes the given parser until it fails, returning an\n  // Array of the results (or a uint count if `subParser` returns an empty tuple).\n  return Many_<SubParser, false>(kj::fwd<SubParser>(subParser));\n}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr Many_<SubParser, false> many(SubParser&& subParser) {\n  // Constructs a parser that repeatedly executes the given parser until it fails, returning an\n  // Array of the results (or a uint count if `subParser` returns an empty tuple).\n  return Many_<SubParser, false>(kj::fwd<SubParser>(subParser));\n}"
        }
      },
      {
        "call_info": {
          "callee": "p::oneOf",
          "args": [
            "p::transformWithLocation(p::sequence(op(\".\"), identifier),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location,\n                         Located<Text::Reader>&& name) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    initLocation(location, builder);\n                    name.copyTo(builder.initMember().initName());\n                    return result;\n                  })",
            "p::transform(tuple,\n                  [this](Located<Orphan<List<Expression::Param>>>&& params) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    params.copyLocationTo(builder);\n                    builder.initApplication().adoptParams(kj::mv(params.value));\n                    return result;\n                  })"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initApplication",
          "args": [
            "kj::mv(params.value)"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "params.value"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initApplication",
          "args": [],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.copyLocationTo",
          "args": [
            "builder"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "copyLocationTo",
          "container": "Located",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "204-207",
          "snippet": "void copyLocationTo(Builder builder) {\n    builder.setStartByte(startByte);\n    builder.setEndByte(endByte);\n  }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nLocated {\n  void copyLocationTo(Builder builder) {\n      builder.setStartByte(startByte);\n      builder.setEndByte(endByte);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Expression>",
          "args": [],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::transformWithLocation",
          "args": [
            "p::sequence(op(\".\"), identifier)",
            "[this](kj::parse::Span<List<Token>::Reader::Iterator> location,\n                         Located<Text::Reader>&& name) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    initLocation(location, builder);\n                    name.copyTo(builder.initMember().initName());\n                    return result;\n                  }"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "transformWithLocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "718-725",
          "snippet": "constexpr TransformWithLocation_<SubParser, TransformFunc> transformWithLocation(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Like `transform` except that `functor` also takes a `Span` as its first parameter specifying\n  // the location of the parsed content.  The span's position type is whatever the parser input's\n  // getPosition() returns.\n  return TransformWithLocation_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr TransformWithLocation_<SubParser, TransformFunc> transformWithLocation(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Like `transform` except that `functor` also takes a `Span` as its first parameter specifying\n  // the location of the parsed content.  The span's position type is whatever the parser input's\n  // getPosition() returns.\n  return TransformWithLocation_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.initMember",
          "args": [],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initMember",
          "args": [],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initLocation",
          "args": [
            "location",
            "builder"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "initLocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "409-415",
          "snippet": "void initLocation(kj::parse::Span<List<Token>::Reader::Iterator> location,\n                  BuilderType builder) {\n  if (location.begin() < location.end()) {\n    builder.setStartByte(location.begin()->getStartByte());\n    builder.setEndByte((location.end() - 1)->getEndByte());\n  }\n}",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nvoid initLocation(kj::parse::Span<List<Token>::Reader::Iterator> location,\n                  BuilderType builder) {\n  if (location.begin() < location.end()) {\n    builder.setStartByte(location.begin()->getStartByte());\n    builder.setEndByte((location.end() - 1)->getEndByte());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Expression>",
          "args": [],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "op(\".\")",
            "identifier"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::oneOf",
          "args": [
            "p::transform(integerLiteral,\n                  [this](Located<uint64_t>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setPositiveInt(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  })",
            "p::transform(p::sequence(op(\"-\"), integerLiteral),\n                  [this](Located<uint64_t>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setNegativeInt(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  })",
            "p::transform(floatLiteral,\n                  [this](Located<double>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setFloat(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  })",
            "p::transform(p::sequence(op(\"-\"), floatLiteral),\n                  [this](Located<double>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setFloat(-value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  })",
            "p::transformWithLocation(p::sequence(op(\"-\"), keyword(\"inf\")),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location)\n                      -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setFloat(-kj::inf());\n                    initLocation(location, builder);\n                    return result;\n                  })",
            "p::transform(stringLiteral,\n                  [this](Located<Text::Reader>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setString(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  })",
            "p::transform(binaryLiteral,\n                  [this](Located<Data::Reader>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setBinary(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  })",
            "p::transform(bracketedList(parsers.expression, errorReporter),\n                  [this](Located<kj::Array<kj::Maybe<Orphan<Expression>>>>&& value)\n                      -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    auto listBuilder = builder.initList(value.value.size());\n                    for (uint i = 0; i < value.value.size(); i++) {\n                      KJ_IF_MAYBE(element, value.value[i]) {\n                        listBuilder.adoptWithCaveats(i, kj::mv(*element));\n                      }\n                    }\n                    value.copyLocationTo(builder);\n                    return result;\n                  })",
            "p::transform(tuple,\n                  [this](Located<Orphan<List<Expression::Param>>>&& value)\n                      -> Orphan<Expression> {\n                    auto elements = value.value.get();\n\n                    if (elements.size() == 1 && elements[0].isUnnamed()) {\n                      // Single-value tuple is just a value.\n                      return elements[0].disownValue();\n                    } else {\n                      auto result = orphanage.newOrphan<Expression>();\n                      auto builder = result.get();\n                      builder.adoptTuple(kj::mv(value.value));\n                      value.copyLocationTo(builder);\n                      return result;\n                    }\n                  })",
            "p::transformWithLocation(p::sequence(keyword(\"import\"), stringLiteral),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location,\n                         Located<Text::Reader>&& filename) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    initLocation(location, builder);\n                    filename.copyTo(builder.initImport());\n                    return result;\n                  })",
            "p::transformWithLocation(p::sequence(op(\".\"), identifier),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location,\n                         Located<Text::Reader>&& name) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    initLocation(location, builder);\n                    name.copyTo(builder.initAbsoluteName());\n                    return result;\n                  })",
            "p::transform(identifier,\n                  [this](Located<Text::Reader>&& name) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    name.copyTo(builder.initRelativeName());\n                    name.copyLocationTo(builder);\n                    return result;\n                  })"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initRelativeName",
          "args": [],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Expression>",
          "args": [],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initAbsoluteName",
          "args": [],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Expression>",
          "args": [],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "op(\".\")",
            "identifier"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initImport",
          "args": [],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Expression>",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "keyword(\"import\")",
            "stringLiteral"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.adoptTuple",
          "args": [
            "kj::mv(value.value)"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "value.value"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Expression>",
          "args": [],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elements[0].disownValue",
          "args": [],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elements[0].isUnnamed",
          "args": [],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listBuilder.adoptWithCaveats",
          "args": [
            "i",
            "kj::mv(*element)"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "adoptWithCaveats",
          "container": "Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/list.h",
          "lines": "251-268",
          "snippet": "inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n      // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n      // the fact that structs in a struct list are allocated inline rather than by pointer:\n      // * This actually performs a shallow copy, effectively adopting each of the orphan's\n      //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n      //   possibly wasting space in the message object.\n      // * If the orphan is larger than the target struct -- say, because the orphan was built\n      //   using a newer version of the schema that has additional fields -- it will be truncated,\n      //   losing data.\n\n      KJ_IREQUIRE(index < size());\n\n      // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n      // expanded under any circumstances.  We're just going to throw it away anyway, and\n      // transferContentFrom() already carefully compares the struct sizes before transferring.\n      builder.getStructElement(index * ELEMENTS).transferContentFrom(\n          orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n    }",
          "includes": [
            "#include <iterator>",
            "#include <initializer_list>",
            "#include \"orphan.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <initializer_list>\n#include \"orphan.h\"\n#include \"layout.h\"\n\nBuilder {\n  inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n        // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n        // the fact that structs in a struct list are allocated inline rather than by pointer:\n        // * This actually performs a shallow copy, effectively adopting each of the orphan's\n        //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n        //   possibly wasting space in the message object.\n        // * If the orphan is larger than the target struct -- say, because the orphan was built\n        //   using a newer version of the schema that has additional fields -- it will be truncated,\n        //   losing data.\n  \n        KJ_IREQUIRE(index < size());\n  \n        // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n        // expanded under any circumstances.  We're just going to throw it away anyway, and\n        // transferContentFrom() already carefully compares the struct sizes before transferring.\n        builder.getStructElement(index * ELEMENTS).transferContentFrom(\n            orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*element"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "element",
            "value.value[i]"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "builder.initList",
          "args": [
            "value.value.size()"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Expression>",
          "args": [],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bracketedList",
          "args": [
            "parsers.expression",
            "errorReporter"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "bracketedList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "343-348",
          "snippet": "constexpr auto bracketedList(ItemParser&& itemParser, ErrorReporter& errorReporter) -> decltype(\n         transform(rawBracketedList, ParseListItems<ItemParser>(\n             kj::fwd<ItemParser>(itemParser), errorReporter))) {\n  return transform(rawBracketedList, ParseListItems<ItemParser>(\n             kj::fwd<ItemParser>(itemParser), errorReporter));\n}",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nconstexpr auto bracketedList(ItemParser&& itemParser, ErrorReporter& errorReporter) -> decltype(\n         transform(rawBracketedList, ParseListItems<ItemParser>(\n             kj::fwd<ItemParser>(itemParser), errorReporter))) {\n  return transform(rawBracketedList, ParseListItems<ItemParser>(\n             kj::fwd<ItemParser>(itemParser), errorReporter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.setBinary",
          "args": [
            "value.value"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Expression>",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setString",
          "args": [
            "value.value"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Expression>",
          "args": [],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setFloat",
          "args": [
            "-kj::inf()"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::inf",
          "args": [],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "inf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "580-580",
          "snippet": "inline constexpr float inf() { return (float)(1e300 * 1e300); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr float inf() { return (float)(1e300 * 1e300); }"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Expression>",
          "args": [],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "op(\"-\")",
            "keyword(\"inf\")"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setFloat",
          "args": [
            "-value.value"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Expression>",
          "args": [],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "op(\"-\")",
            "floatLiteral"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setFloat",
          "args": [
            "value.value"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Expression>",
          "args": [],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setNegativeInt",
          "args": [
            "value.value"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Expression>",
          "args": [],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "op(\"-\")",
            "integerLiteral"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setPositiveInt",
          "args": [
            "value.value"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Expression>",
          "args": [],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.copy",
          "args": [
            "p::transform(\n        parenthesizedList(tupleElement, errorReporter),\n        [this](Located<kj::Array<kj::Maybe<Orphan<Expression::Param>>>>&& elements)\n               -> Located<Orphan<List<Expression::Param>>> {\n          auto result = orphanage.newOrphan<List<Expression::Param>>(elements.value.size());\n          auto builder = result.get();\n          for (uint i: kj::indices(elements.value)) {\n            KJ_IF_MAYBE(e, elements.value[i]) {\n              builder.adoptWithCaveats(i, kj::mv(*e));\n            } else {\n              builder[i].initValue().setUnknown();\n            }\n          }\n          return elements.rewrap(kj::mv(result));\n        })"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "[this]",
          "args": [
            "kj::mv(result)"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder[i].initValue",
          "args": [],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder[i].initValue",
          "args": [],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*e"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "elements.value"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<List<Expression::Param>>",
          "args": [
            "elements.value.size()"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parenthesizedList",
          "args": [
            "tupleElement",
            "errorReporter"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "parenthesizedList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "335-340",
          "snippet": "constexpr auto parenthesizedList(ItemParser&& itemParser, ErrorReporter& errorReporter) -> decltype(\n         transform(rawParenthesizedList, ParseListItems<ItemParser>(\n             kj::fwd<ItemParser>(itemParser), errorReporter))) {\n  return transform(rawParenthesizedList, ParseListItems<ItemParser>(\n             kj::fwd<ItemParser>(itemParser), errorReporter));\n}",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nconstexpr auto parenthesizedList(ItemParser&& itemParser, ErrorReporter& errorReporter) -> decltype(\n         transform(rawParenthesizedList, ParseListItems<ItemParser>(\n             kj::fwd<ItemParser>(itemParser), errorReporter))) {\n  return transform(rawParenthesizedList, ParseListItems<ItemParser>(\n             kj::fwd<ItemParser>(itemParser), errorReporter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "arena.copy",
          "args": [
            "p::transform(\n      p::sequence(p::optional(p::sequence(identifier, op(\"=\"))), parsers.expression),\n      [this](kj::Maybe<Located<Text::Reader>>&& fieldName, Orphan<Expression>&& fieldValue)\n             -> Orphan<Expression::Param> {\n        auto result = orphanage.newOrphan<Expression::Param>();\n        auto builder = result.get();\n        KJ_IF_MAYBE(fn, fieldName) {\n          fn->copyTo(builder.initNamed());\n        } else {\n          builder.setUnnamed();\n        }\n        builder.adoptValue(kj::mv(fieldValue));\n        return kj::mv(result);\n      })"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "else {\n          builder.setUnnamed",
          "args": [
            "kj::mv(fieldValue)"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "fieldValue"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setUnnamed",
          "args": [],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initNamed",
          "args": [],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Expression::Param>",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "p::optional(p::sequence(identifier, op(\"=\")))",
            "parsers.expression"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "identifier",
            "op(\"=\")"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nCapnpParser::CapnpParser(Orphanage orphanageParam, ErrorReporter& errorReporterParam)\n    : orphanage(orphanageParam), errorReporter(errorReporterParam) {\n  auto& tupleElement = arena.copy(p::transform(\n      p::sequence(p::optional(p::sequence(identifier, op(\"=\"))), parsers.expression),\n      [this](kj::Maybe<Located<Text::Reader>>&& fieldName, Orphan<Expression>&& fieldValue)\n             -> Orphan<Expression::Param> {\n        auto result = orphanage.newOrphan<Expression::Param>();\n        auto builder = result.get();\n        KJ_IF_MAYBE(fn, fieldName) {\n          fn->copyTo(builder.initNamed());\n        } else {\n          builder.setUnnamed();\n        }\n        builder.adoptValue(kj::mv(fieldValue));\n        return kj::mv(result);\n      }));\n\n  auto& tuple = arena.copy<Parser<Located<Orphan<List<Expression::Param>>>>>(\n      arena.copy(p::transform(\n        parenthesizedList(tupleElement, errorReporter),\n        [this](Located<kj::Array<kj::Maybe<Orphan<Expression::Param>>>>&& elements)\n               -> Located<Orphan<List<Expression::Param>>> {\n          auto result = orphanage.newOrphan<List<Expression::Param>>(elements.value.size());\n          auto builder = result.get();\n          for (uint i: kj::indices(elements.value)) {\n            KJ_IF_MAYBE(e, elements.value[i]) {\n              builder.adoptWithCaveats(i, kj::mv(*e));\n            } else {\n              builder[i].initValue().setUnknown();\n            }\n          }\n          return elements.rewrap(kj::mv(result));\n        })));\n\n  parsers.expression = arena.copy(p::transform(\n      p::sequence(\n          // Base expression.\n          p::oneOf(\n              p::transform(integerLiteral,\n                  [this](Located<uint64_t>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setPositiveInt(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(p::sequence(op(\"-\"), integerLiteral),\n                  [this](Located<uint64_t>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setNegativeInt(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(floatLiteral,\n                  [this](Located<double>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setFloat(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(p::sequence(op(\"-\"), floatLiteral),\n                  [this](Located<double>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setFloat(-value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transformWithLocation(p::sequence(op(\"-\"), keyword(\"inf\")),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location)\n                      -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setFloat(-kj::inf());\n                    initLocation(location, builder);\n                    return result;\n                  }),\n              p::transform(stringLiteral,\n                  [this](Located<Text::Reader>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setString(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(binaryLiteral,\n                  [this](Located<Data::Reader>&& value) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    builder.setBinary(value.value);\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(bracketedList(parsers.expression, errorReporter),\n                  [this](Located<kj::Array<kj::Maybe<Orphan<Expression>>>>&& value)\n                      -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    auto listBuilder = builder.initList(value.value.size());\n                    for (uint i = 0; i < value.value.size(); i++) {\n                      KJ_IF_MAYBE(element, value.value[i]) {\n                        listBuilder.adoptWithCaveats(i, kj::mv(*element));\n                      }\n                    }\n                    value.copyLocationTo(builder);\n                    return result;\n                  }),\n              p::transform(tuple,\n                  [this](Located<Orphan<List<Expression::Param>>>&& value)\n                      -> Orphan<Expression> {\n                    auto elements = value.value.get();\n\n                    if (elements.size() == 1 && elements[0].isUnnamed()) {\n                      // Single-value tuple is just a value.\n                      return elements[0].disownValue();\n                    } else {\n                      auto result = orphanage.newOrphan<Expression>();\n                      auto builder = result.get();\n                      builder.adoptTuple(kj::mv(value.value));\n                      value.copyLocationTo(builder);\n                      return result;\n                    }\n                  }),\n              p::transformWithLocation(p::sequence(keyword(\"import\"), stringLiteral),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location,\n                         Located<Text::Reader>&& filename) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    initLocation(location, builder);\n                    filename.copyTo(builder.initImport());\n                    return result;\n                  }),\n              p::transformWithLocation(p::sequence(op(\".\"), identifier),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location,\n                         Located<Text::Reader>&& name) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    initLocation(location, builder);\n                    name.copyTo(builder.initAbsoluteName());\n                    return result;\n                  }),\n              p::transform(identifier,\n                  [this](Located<Text::Reader>&& name) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    name.copyTo(builder.initRelativeName());\n                    name.copyLocationTo(builder);\n                    return result;\n                  })),\n          // Suffixes, e.g. \".member\" or \"(param1, param2)\".\n          p::many(p::oneOf(\n              p::transformWithLocation(p::sequence(op(\".\"), identifier),\n                  [this](kj::parse::Span<List<Token>::Reader::Iterator> location,\n                         Located<Text::Reader>&& name) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    initLocation(location, builder);\n                    name.copyTo(builder.initMember().initName());\n                    return result;\n                  }),\n              p::transform(tuple,\n                  [this](Located<Orphan<List<Expression::Param>>>&& params) -> Orphan<Expression> {\n                    auto result = orphanage.newOrphan<Expression>();\n                    auto builder = result.get();\n                    params.copyLocationTo(builder);\n                    builder.initApplication().adoptParams(kj::mv(params.value));\n                    return result;\n                  })))),\n      [this](Orphan<Expression>&& base, kj::Array<Orphan<Expression>>&& suffixes)\n          -> Orphan<Expression> {\n        // Apply all the suffixes to the base expression.\n        uint startByte = base.getReader().getStartByte();\n        for (auto& suffix: suffixes) {\n          auto builder = suffix.get();\n          if (builder.isApplication()) {\n            builder.getApplication().adoptFunction(kj::mv(base));\n          } else if (builder.isMember()) {\n            builder.getMember().adoptParent(kj::mv(base));\n          } else {\n            KJ_FAIL_ASSERT(\"Unknown suffix?\", (uint)builder.which());\n          }\n          builder.setStartByte(startByte);\n          base = kj::mv(suffix);\n        }\n        return kj::mv(base);\n      }));\n\n  parsers.annotation = arena.copy(p::transform(\n      p::sequence(op(\"$\"), parsers.expression),\n      [this](Orphan<Expression>&& expression)\n          -> Orphan<Declaration::AnnotationApplication> {\n        auto result = orphanage.newOrphan<Declaration::AnnotationApplication>();\n        auto builder = result.get();\n\n        auto exp = expression.get();\n        if (exp.isApplication()) {\n          // Oops, this annotation specifies the value, but we parsed it as an application on\n          // the preceding expression. Pull it back apart.\n          auto app = exp.getApplication();\n          builder.adoptName(app.disownFunction());\n          auto params = app.getParams();\n          if (params.size() == 1 && params[0].isUnnamed()) {\n            // Params has a single unnamed element, so reduce it to a simple value rather than\n            // a tuple.\n            builder.getValue().adoptExpression(params[0].disownValue());\n          } else {\n            // Params is not a single unnamed element, so it's a tuple.\n            builder.getValue().initExpression().adoptTuple(app.disownParams());\n          }\n        } else {\n          // The annotation has no value.\n          builder.adoptName(kj::mv(expression));\n          builder.getValue().setNone();\n        }\n\n        return result;\n      }));\n\n  parsers.uid = arena.copy(p::transform(\n      p::sequence(op(\"@\"), integerLiteral),\n      [this](Located<uint64_t>&& value) {\n        if (value.value < (1ull << 63)) {\n          errorReporter.addError(value.startByte, value.endByte,\n              \"Invalid ID.  Please generate a new one with 'capnpc -i'.\");\n        }\n        return value.asProto<LocatedInteger>(orphanage);\n      }));\n\n  parsers.ordinal = arena.copy(p::transform(\n      p::sequence(op(\"@\"), integerLiteral),\n      [this](Located<uint64_t>&& value) {\n        if (value.value >= 65536) {\n          errorReporter.addError(value.startByte, value.endByte,\n              \"Ordinals cannot be greater than 65535.\");\n        }\n        return value.asProto<LocatedInteger>(orphanage);\n      }));\n\n  // -----------------------------------------------------------------\n\n  parsers.usingDecl = arena.copy(p::transform(\n      p::sequence(keyword(\"using\"), p::optional(p::sequence(identifier, op(\"=\"))),\n                  parsers.expression),\n      [this](kj::Maybe<Located<Text::Reader>>&& name, Orphan<Expression>&& target)\n          -> DeclParserResult {\n        auto decl = orphanage.newOrphan<Declaration>();\n        auto builder = decl.get();\n        KJ_IF_MAYBE(n, name) {\n          n->copyTo(builder.initName());\n        } else {\n          auto targetReader = target.getReader();\n          if (targetReader.isMember()) {\n            builder.setName(targetReader.getMember().getName());\n          } else {\n            errorReporter.addErrorOn(targetReader,\n                \"'using' declaration without '=' must specify a named declaration from a \"\n                \"different scope.\");\n          }\n        }\n        // no id, no annotations for using decl\n        builder.initUsing().adoptTarget(kj::mv(target));\n        return DeclParserResult(kj::mv(decl));\n      }"
  },
  {
    "function_name": "initLocation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "409-415",
    "snippet": "void initLocation(kj::parse::Span<List<Token>::Reader::Iterator> location,\n                  BuilderType builder) {\n  if (location.begin() < location.end()) {\n    builder.setStartByte(location.begin()->getStartByte());\n    builder.setEndByte((location.end() - 1)->getEndByte());\n  }\n}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.setEndByte",
          "args": [
            "(location.end() - 1)->getEndByte()"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "location.end",
          "args": [],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "77-77",
          "snippet": "inline Iterator end() const { return Iterator(amount); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator end() const { return Iterator(amount); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.setStartByte",
          "args": [
            "location.begin()->getStartByte()"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "location.begin",
          "args": [],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "76-76",
          "snippet": "inline Iterator begin() const { return Iterator(0); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nvoid initLocation(kj::parse::Span<List<Token>::Reader::Iterator> location,\n                  BuilderType builder) {\n  if (location.begin() < location.end()) {\n    builder.setStartByte(location.begin()->getStartByte());\n    builder.setEndByte((location.end() - 1)->getEndByte());\n  }\n}"
  },
  {
    "function_name": "initMemberDecl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "395-406",
    "snippet": "static Declaration::Builder initMemberDecl(\n    Declaration::Builder builder, Located<Text::Reader>&& name,\n    Orphan<LocatedInteger>&& ordinal,\n    kj::Array<Orphan<Declaration::AnnotationApplication>>&& annotations) {\n  name.copyTo(builder.initName());\n  builder.getId().adoptOrdinal(kj::mv(ordinal));\n  auto list = builder.initAnnotations(annotations.size());\n  for (uint i = 0; i < annotations.size(); i++) {\n    list.adoptWithCaveats(i, kj::mv(annotations[i]));\n  }\n  return builder;\n}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list.adoptWithCaveats",
          "args": [
            "i",
            "kj::mv(annotations[i])"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "adoptWithCaveats",
          "container": "Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/list.h",
          "lines": "251-268",
          "snippet": "inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n      // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n      // the fact that structs in a struct list are allocated inline rather than by pointer:\n      // * This actually performs a shallow copy, effectively adopting each of the orphan's\n      //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n      //   possibly wasting space in the message object.\n      // * If the orphan is larger than the target struct -- say, because the orphan was built\n      //   using a newer version of the schema that has additional fields -- it will be truncated,\n      //   losing data.\n\n      KJ_IREQUIRE(index < size());\n\n      // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n      // expanded under any circumstances.  We're just going to throw it away anyway, and\n      // transferContentFrom() already carefully compares the struct sizes before transferring.\n      builder.getStructElement(index * ELEMENTS).transferContentFrom(\n          orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n    }",
          "includes": [
            "#include <iterator>",
            "#include <initializer_list>",
            "#include \"orphan.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <initializer_list>\n#include \"orphan.h\"\n#include \"layout.h\"\n\nBuilder {\n  inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n        // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n        // the fact that structs in a struct list are allocated inline rather than by pointer:\n        // * This actually performs a shallow copy, effectively adopting each of the orphan's\n        //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n        //   possibly wasting space in the message object.\n        // * If the orphan is larger than the target struct -- say, because the orphan was built\n        //   using a newer version of the schema that has additional fields -- it will be truncated,\n        //   losing data.\n  \n        KJ_IREQUIRE(index < size());\n  \n        // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n        // expanded under any circumstances.  We're just going to throw it away anyway, and\n        // transferContentFrom() already carefully compares the struct sizes before transferring.\n        builder.getStructElement(index * ELEMENTS).transferContentFrom(\n            orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "annotations[i]"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotations.size",
          "args": [],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.initAnnotations",
          "args": [
            "annotations.size()"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getId",
          "args": [
            "kj::mv(ordinal)"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "ordinal"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getId",
          "args": [],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "name.copyTo",
          "args": [
            "builder.initName()"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "copyTo",
          "container": "Located",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "209-212",
          "snippet": "void copyTo(Builder builder) {\n    builder.setValue(value);\n    copyLocationTo(builder);\n  }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nLocated {\n  void copyTo(Builder builder) {\n      builder.setValue(value);\n      copyLocationTo(builder);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.initName",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nstatic Declaration::Builder initMemberDecl(\n    Declaration::Builder builder, Located<Text::Reader>&& name,\n    Orphan<LocatedInteger>&& ordinal,\n    kj::Array<Orphan<Declaration::AnnotationApplication>>&& annotations) {\n  name.copyTo(builder.initName());\n  builder.getId().adoptOrdinal(kj::mv(ordinal));\n  auto list = builder.initAnnotations(annotations.size());\n  for (uint i = 0; i < annotations.size(); i++) {\n    list.adoptWithCaveats(i, kj::mv(annotations[i]));\n  }\n  return builder;\n}"
  },
  {
    "function_name": "initDecl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "376-393",
    "snippet": "static Declaration::Builder initDecl(\n    Declaration::Builder builder, Located<Text::Reader>&& name,\n    kj::Maybe<Orphan<LocatedInteger>>&& id,\n    kj::Maybe<Located<kj::Array<kj::Maybe<Located<Text::Reader>>>>>&& genericParameters,\n    kj::Array<Orphan<Declaration::AnnotationApplication>>&& annotations) {\n  name.copyTo(builder.initName());\n  KJ_IF_MAYBE(i, id) {\n    builder.getId().adoptUid(kj::mv(*i));\n  }\n\n  initGenericParams(builder, kj::mv(genericParameters));\n\n  auto list = builder.initAnnotations(annotations.size());\n  for (uint i = 0; i < annotations.size(); i++) {\n    list.adoptWithCaveats(i, kj::mv(annotations[i]));\n  }\n  return builder;\n}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list.adoptWithCaveats",
          "args": [
            "i",
            "kj::mv(annotations[i])"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "adoptWithCaveats",
          "container": "Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/list.h",
          "lines": "251-268",
          "snippet": "inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n      // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n      // the fact that structs in a struct list are allocated inline rather than by pointer:\n      // * This actually performs a shallow copy, effectively adopting each of the orphan's\n      //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n      //   possibly wasting space in the message object.\n      // * If the orphan is larger than the target struct -- say, because the orphan was built\n      //   using a newer version of the schema that has additional fields -- it will be truncated,\n      //   losing data.\n\n      KJ_IREQUIRE(index < size());\n\n      // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n      // expanded under any circumstances.  We're just going to throw it away anyway, and\n      // transferContentFrom() already carefully compares the struct sizes before transferring.\n      builder.getStructElement(index * ELEMENTS).transferContentFrom(\n          orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n    }",
          "includes": [
            "#include <iterator>",
            "#include <initializer_list>",
            "#include \"orphan.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <initializer_list>\n#include \"orphan.h\"\n#include \"layout.h\"\n\nBuilder {\n  inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n        // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n        // the fact that structs in a struct list are allocated inline rather than by pointer:\n        // * This actually performs a shallow copy, effectively adopting each of the orphan's\n        //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n        //   possibly wasting space in the message object.\n        // * If the orphan is larger than the target struct -- say, because the orphan was built\n        //   using a newer version of the schema that has additional fields -- it will be truncated,\n        //   losing data.\n  \n        KJ_IREQUIRE(index < size());\n  \n        // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n        // expanded under any circumstances.  We're just going to throw it away anyway, and\n        // transferContentFrom() already carefully compares the struct sizes before transferring.\n        builder.getStructElement(index * ELEMENTS).transferContentFrom(\n            orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "annotations[i]"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotations.size",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.initAnnotations",
          "args": [
            "annotations.size()"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initGenericParams",
          "args": [
            "builder",
            "kj::mv(genericParameters)"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "genericParameters"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getId",
          "args": [
            "kj::mv(*i)"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*i"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getId",
          "args": [],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "name.copyTo",
          "args": [
            "builder.initName()"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "copyTo",
          "container": "Located",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "209-212",
          "snippet": "void copyTo(Builder builder) {\n    builder.setValue(value);\n    copyLocationTo(builder);\n  }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nLocated {\n  void copyTo(Builder builder) {\n      builder.setValue(value);\n      copyLocationTo(builder);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.initName",
          "args": [],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nstatic Declaration::Builder initDecl(\n    Declaration::Builder builder, Located<Text::Reader>&& name,\n    kj::Maybe<Orphan<LocatedInteger>>&& id,\n    kj::Maybe<Located<kj::Array<kj::Maybe<Located<Text::Reader>>>>>&& genericParameters,\n    kj::Array<Orphan<Declaration::AnnotationApplication>>&& annotations) {\n  name.copyTo(builder.initName());\n  KJ_IF_MAYBE(i, id) {\n    builder.getId().adoptUid(kj::mv(*i));\n  }\n\n  initGenericParams(builder, kj::mv(genericParameters));\n\n  auto list = builder.initAnnotations(annotations.size());\n  for (uint i = 0; i < annotations.size(); i++) {\n    list.adoptWithCaveats(i, kj::mv(annotations[i]));\n  }\n  return builder;\n}"
  },
  {
    "function_name": "initGenericParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "362-374",
    "snippet": "static void initGenericParams(Declaration::Builder builder,\n    kj::Maybe<Located<kj::Array<kj::Maybe<Located<Text::Reader>>>>>&& genericParameters) {\n  KJ_IF_MAYBE(p, genericParameters) {\n    auto params = builder.initParameters(p->value.size());\n    for (uint i: kj::indices(p->value)) {\n      KJ_IF_MAYBE(name, p->value[i]) {\n        auto param = params[i];\n        param.setName(name->value);\n        name->copyLocationTo(param);\n      }\n    }\n  }\n}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "name->copyLocationTo",
          "args": [
            "param"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "copyLocationTo",
          "container": "Located",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "204-207",
          "snippet": "void copyLocationTo(Builder builder) {\n    builder.setStartByte(startByte);\n    builder.setEndByte(endByte);\n  }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nLocated {\n  void copyLocationTo(Builder builder) {\n      builder.setStartByte(startByte);\n      builder.setEndByte(endByte);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "param.setName",
          "args": [
            "name->value"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "name",
            "p->value[i]"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "p->value"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.initParameters",
          "args": [
            "p->value.size()"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->value.size",
          "args": [],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "695-695",
          "snippet": "inline size_t size() const { return count; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline size_t size() const { return count; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nstatic void initGenericParams(Declaration::Builder builder,\n    kj::Maybe<Located<kj::Array<kj::Maybe<Located<Text::Reader>>>>>&& genericParameters) {\n  KJ_IF_MAYBE(p, genericParameters) {\n    auto params = builder.initParameters(p->value.size());\n    for (uint i: kj::indices(p->value)) {\n      KJ_IF_MAYBE(name, p->value[i]) {\n        auto param = params[i];\n        param.setName(name->value);\n        name->copyLocationTo(param);\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "arrayToList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "353-360",
    "snippet": "Orphan<List<T>> arrayToList(Orphanage& orphanage, kj::Array<Orphan<T>>&& elements) {\n  auto result = orphanage.newOrphan<List<T>>(elements.size());\n  auto builder = result.get();\n  for (size_t i = 0; i < elements.size(); i++) {\n    builder.adoptWithCaveats(i, kj::mv(elements[i]));\n  }\n  return kj::mv(result);\n}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.adoptWithCaveats",
          "args": [
            "i",
            "kj::mv(elements[i])"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "adoptWithCaveats",
          "container": "Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/list.h",
          "lines": "251-268",
          "snippet": "inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n      // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n      // the fact that structs in a struct list are allocated inline rather than by pointer:\n      // * This actually performs a shallow copy, effectively adopting each of the orphan's\n      //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n      //   possibly wasting space in the message object.\n      // * If the orphan is larger than the target struct -- say, because the orphan was built\n      //   using a newer version of the schema that has additional fields -- it will be truncated,\n      //   losing data.\n\n      KJ_IREQUIRE(index < size());\n\n      // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n      // expanded under any circumstances.  We're just going to throw it away anyway, and\n      // transferContentFrom() already carefully compares the struct sizes before transferring.\n      builder.getStructElement(index * ELEMENTS).transferContentFrom(\n          orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n    }",
          "includes": [
            "#include <iterator>",
            "#include <initializer_list>",
            "#include \"orphan.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <initializer_list>\n#include \"orphan.h\"\n#include \"layout.h\"\n\nBuilder {\n  inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n        // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n        // the fact that structs in a struct list are allocated inline rather than by pointer:\n        // * This actually performs a shallow copy, effectively adopting each of the orphan's\n        //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n        //   possibly wasting space in the message object.\n        // * If the orphan is larger than the target struct -- say, because the orphan was built\n        //   using a newer version of the schema that has additional fields -- it will be truncated,\n        //   losing data.\n  \n        KJ_IREQUIRE(index < size());\n  \n        // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n        // expanded under any circumstances.  We're just going to throw it away anyway, and\n        // transferContentFrom() already carefully compares the struct sizes before transferring.\n        builder.getStructElement(index * ELEMENTS).transferContentFrom(\n            orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "elements[i]"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elements.size",
          "args": [],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.get",
          "args": [],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<List<T>>",
          "args": [
            "elements.size()"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nOrphan<List<T>> arrayToList(Orphanage& orphanage, kj::Array<Orphan<T>>&& elements) {\n  auto result = orphanage.newOrphan<List<T>>(elements.size());\n  auto builder = result.get();\n  for (size_t i = 0; i < elements.size(); i++) {\n    builder.adoptWithCaveats(i, kj::mv(elements[i]));\n  }\n  return kj::mv(result);\n}"
  },
  {
    "function_name": "bracketedList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "343-348",
    "snippet": "constexpr auto bracketedList(ItemParser&& itemParser, ErrorReporter& errorReporter) -> decltype(\n         transform(rawBracketedList, ParseListItems<ItemParser>(\n             kj::fwd<ItemParser>(itemParser), errorReporter))) {\n  return transform(rawBracketedList, ParseListItems<ItemParser>(\n             kj::fwd<ItemParser>(itemParser), errorReporter));\n}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "transform",
          "args": [
            "rawBracketedList",
            "ParseListItems<ItemParser>(\n             kj::fwd<ItemParser>(itemParser), errorReporter)"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "699-706",
          "snippet": "constexpr Transform_<SubParser, TransformFunc> transform(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Constructs a parser which executes some other parser and then transforms the result by invoking\n  // `functor` on it.  Typically `functor` is a lambda.  It is invoked using `kj::apply`,\n  // meaning tuples will be unpacked as arguments.\n  return Transform_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr Transform_<SubParser, TransformFunc> transform(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Constructs a parser which executes some other parser and then transforms the result by invoking\n  // `functor` on it.  Typically `functor` is a lambda.  It is invoked using `kj::apply`,\n  // meaning tuples will be unpacked as arguments.\n  return Transform_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseListItems<ItemParser>",
          "args": [
            "kj::fwd<ItemParser>(itemParser)",
            "errorReporter"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "ParseListItems",
          "container": "ParseListItems",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "293-295",
          "snippet": "constexpr ParseListItems(ItemParser&& itemParser, ErrorReporter& errorReporter)\n      : itemParser(p::sequence(kj::fwd<ItemParser>(itemParser), p::endOfInput)),\n        errorReporter(errorReporter) {}",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nParseListItems {\n  constexpr ParseListItems(ItemParser&& itemParser, ErrorReporter& errorReporter)\n        : itemParser(p::sequence(kj::fwd<ItemParser>(itemParser), p::endOfInput)),\n          errorReporter(errorReporter) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<ItemParser>",
          "args": [
            "itemParser"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<ItemParser>",
          "args": [
            "itemParser"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nconstexpr auto bracketedList(ItemParser&& itemParser, ErrorReporter& errorReporter) -> decltype(\n         transform(rawBracketedList, ParseListItems<ItemParser>(\n             kj::fwd<ItemParser>(itemParser), errorReporter))) {\n  return transform(rawBracketedList, ParseListItems<ItemParser>(\n             kj::fwd<ItemParser>(itemParser), errorReporter));\n}"
  },
  {
    "function_name": "parenthesizedList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "335-340",
    "snippet": "constexpr auto parenthesizedList(ItemParser&& itemParser, ErrorReporter& errorReporter) -> decltype(\n         transform(rawParenthesizedList, ParseListItems<ItemParser>(\n             kj::fwd<ItemParser>(itemParser), errorReporter))) {\n  return transform(rawParenthesizedList, ParseListItems<ItemParser>(\n             kj::fwd<ItemParser>(itemParser), errorReporter));\n}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "transform",
          "args": [
            "rawParenthesizedList",
            "ParseListItems<ItemParser>(\n             kj::fwd<ItemParser>(itemParser), errorReporter)"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "699-706",
          "snippet": "constexpr Transform_<SubParser, TransformFunc> transform(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Constructs a parser which executes some other parser and then transforms the result by invoking\n  // `functor` on it.  Typically `functor` is a lambda.  It is invoked using `kj::apply`,\n  // meaning tuples will be unpacked as arguments.\n  return Transform_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr Transform_<SubParser, TransformFunc> transform(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Constructs a parser which executes some other parser and then transforms the result by invoking\n  // `functor` on it.  Typically `functor` is a lambda.  It is invoked using `kj::apply`,\n  // meaning tuples will be unpacked as arguments.\n  return Transform_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseListItems<ItemParser>",
          "args": [
            "kj::fwd<ItemParser>(itemParser)",
            "errorReporter"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "ParseListItems",
          "container": "ParseListItems",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "293-295",
          "snippet": "constexpr ParseListItems(ItemParser&& itemParser, ErrorReporter& errorReporter)\n      : itemParser(p::sequence(kj::fwd<ItemParser>(itemParser), p::endOfInput)),\n        errorReporter(errorReporter) {}",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nParseListItems {\n  constexpr ParseListItems(ItemParser&& itemParser, ErrorReporter& errorReporter)\n        : itemParser(p::sequence(kj::fwd<ItemParser>(itemParser), p::endOfInput)),\n          errorReporter(errorReporter) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<ItemParser>",
          "args": [
            "itemParser"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<ItemParser>",
          "args": [
            "itemParser"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nconstexpr auto parenthesizedList(ItemParser&& itemParser, ErrorReporter& errorReporter) -> decltype(\n         transform(rawParenthesizedList, ParseListItems<ItemParser>(\n             kj::fwd<ItemParser>(itemParser), errorReporter))) {\n  return transform(rawParenthesizedList, ParseListItems<ItemParser>(\n             kj::fwd<ItemParser>(itemParser), errorReporter));\n}"
  },
  {
    "function_name": "ParseListItems",
    "container": "ParseListItems",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "293-295",
    "snippet": "constexpr ParseListItems(ItemParser&& itemParser, ErrorReporter& errorReporter)\n      : itemParser(p::sequence(kj::fwd<ItemParser>(itemParser), p::endOfInput)),\n        errorReporter(errorReporter) {}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "kj::fwd<ItemParser>(itemParser)",
            "p::endOfInput"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<ItemParser>",
          "args": [
            "itemParser"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nParseListItems {\n  constexpr ParseListItems(ItemParser&& itemParser, ErrorReporter& errorReporter)\n        : itemParser(p::sequence(kj::fwd<ItemParser>(itemParser), p::endOfInput)),\n          errorReporter(errorReporter) {}\n}"
  },
  {
    "function_name": "op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "281-284",
    "snippet": "constexpr auto op(const char* expected)\n    -> decltype(p::transformOrReject(operatorToken, ExactString(expected))) {\n  return p::transformOrReject(operatorToken, ExactString(expected));\n}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p::transformOrReject",
          "args": [
            "operatorToken",
            "ExactString(expected)"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "transformOrReject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "709-715",
          "snippet": "constexpr TransformOrReject_<SubParser, TransformFunc> transformOrReject(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Like `transform()` except that `functor` returns a `Maybe`.  If it returns null, parsing fails,\n  // otherwise the parser's result is the content of the `Maybe`.\n  return TransformOrReject_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr TransformOrReject_<SubParser, TransformFunc> transformOrReject(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Like `transform()` except that `functor` returns a `Maybe`.  If it returns null, parsing fails,\n  // otherwise the parser's result is the content of the `Maybe`.\n  return TransformOrReject_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExactString",
          "args": [
            "expected"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "ExactString",
          "container": "ExactString",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "262-262",
          "snippet": "constexpr ExactString(const char* expected): expected(expected) {}",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nExactString {\n  constexpr ExactString(const char* expected): expected(expected) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nconstexpr auto op(const char* expected)\n    -> decltype(p::transformOrReject(operatorToken, ExactString(expected))) {\n  return p::transformOrReject(operatorToken, ExactString(expected));\n}"
  },
  {
    "function_name": "keyword",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "276-279",
    "snippet": "constexpr auto keyword(const char* expected)\n    -> decltype(p::transformOrReject(identifier, ExactString(expected))) {\n  return p::transformOrReject(identifier, ExactString(expected));\n}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p::transformOrReject",
          "args": [
            "identifier",
            "ExactString(expected)"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "transformOrReject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "709-715",
          "snippet": "constexpr TransformOrReject_<SubParser, TransformFunc> transformOrReject(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Like `transform()` except that `functor` returns a `Maybe`.  If it returns null, parsing fails,\n  // otherwise the parser's result is the content of the `Maybe`.\n  return TransformOrReject_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr TransformOrReject_<SubParser, TransformFunc> transformOrReject(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Like `transform()` except that `functor` returns a `Maybe`.  If it returns null, parsing fails,\n  // otherwise the parser's result is the content of the `Maybe`.\n  return TransformOrReject_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExactString",
          "args": [
            "expected"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "ExactString",
          "container": "ExactString",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "262-262",
          "snippet": "constexpr ExactString(const char* expected): expected(expected) {}",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nExactString {\n  constexpr ExactString(const char* expected): expected(expected) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nconstexpr auto keyword(const char* expected)\n    -> decltype(p::transformOrReject(identifier, ExactString(expected))) {\n  return p::transformOrReject(identifier, ExactString(expected));\n}"
  },
  {
    "function_name": "ExactString",
    "container": "ExactString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "262-262",
    "snippet": "constexpr ExactString(const char* expected): expected(expected) {}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nExactString {\n  constexpr ExactString(const char* expected): expected(expected) {}\n}"
  },
  {
    "function_name": "Located",
    "container": "Located",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "226-227",
    "snippet": "Located(T&& value, uint32_t startByte, uint32_t endByte)\n      : value(kj::mv(value)), startByte(startByte), endByte(endByte) {}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "value"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nLocated {\n  Located(T&& value, uint32_t startByte, uint32_t endByte)\n        : value(kj::mv(value)), startByte(startByte), endByte(endByte) {}\n}"
  },
  {
    "function_name": "Located",
    "container": "Located",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "224-225",
    "snippet": "Located(const T& value, uint32_t startByte, uint32_t endByte)\n      : value(value), startByte(startByte), endByte(endByte) {}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nLocated {\n  Located(const T& value, uint32_t startByte, uint32_t endByte)\n        : value(value), startByte(startByte), endByte(endByte) {}\n}"
  },
  {
    "function_name": "rewrap",
    "container": "Located",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "220-222",
    "snippet": "Located<kj::Decay<Other>> rewrap(Other&& other) {\n    return Located<Other>(kj::fwd<Other>(other), startByte, endByte);\n  }",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Located<Other>",
          "args": [
            "kj::fwd<Other>(other)",
            "startByte",
            "endByte"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "Located",
          "container": "Located",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "226-227",
          "snippet": "Located(T&& value, uint32_t startByte, uint32_t endByte)\n      : value(kj::mv(value)), startByte(startByte), endByte(endByte) {}",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nLocated {\n  Located(T&& value, uint32_t startByte, uint32_t endByte)\n        : value(kj::mv(value)), startByte(startByte), endByte(endByte) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<Other>",
          "args": [
            "other"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nLocated {\n  Located<kj::Decay<Other>> rewrap(Other&& other) {\n      return Located<Other>(kj::fwd<Other>(other), startByte, endByte);\n    }\n}"
  },
  {
    "function_name": "asProto",
    "container": "Located",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "214-218",
    "snippet": "Orphan<Result> asProto(Orphanage orphanage) {\n    auto result = orphanage.newOrphan<Result>();\n    copyTo(result.get());\n    return result;\n  }",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copyTo",
          "args": [
            "result.get()"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "copyTo",
          "container": "Located",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "209-212",
          "snippet": "void copyTo(Builder builder) {\n    builder.setValue(value);\n    copyLocationTo(builder);\n  }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nLocated {\n  void copyTo(Builder builder) {\n      builder.setValue(value);\n      copyLocationTo(builder);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.get",
          "args": [],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Result>",
          "args": [],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nLocated {\n  Orphan<Result> asProto(Orphanage orphanage) {\n      auto result = orphanage.newOrphan<Result>();\n      copyTo(result.get());\n      return result;\n    }\n}"
  },
  {
    "function_name": "copyTo",
    "container": "Located",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "209-212",
    "snippet": "void copyTo(Builder builder) {\n    builder.setValue(value);\n    copyLocationTo(builder);\n  }",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copyLocationTo",
          "args": [
            "builder"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "copyLocationTo",
          "container": "Located",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "204-207",
          "snippet": "void copyLocationTo(Builder builder) {\n    builder.setStartByte(startByte);\n    builder.setEndByte(endByte);\n  }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nLocated {\n  void copyLocationTo(Builder builder) {\n      builder.setStartByte(startByte);\n      builder.setEndByte(endByte);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.setValue",
          "args": [
            "value"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nLocated {\n  void copyTo(Builder builder) {\n      builder.setValue(value);\n      copyLocationTo(builder);\n    }\n}"
  },
  {
    "function_name": "copyLocationTo",
    "container": "Located",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "204-207",
    "snippet": "void copyLocationTo(Builder builder) {\n    builder.setStartByte(startByte);\n    builder.setEndByte(endByte);\n  }",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.setEndByte",
          "args": [
            "endByte"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setStartByte",
          "args": [
            "startByte"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nLocated {\n  void copyLocationTo(Builder builder) {\n      builder.setStartByte(startByte);\n      builder.setEndByte(endByte);\n    }\n}"
  },
  {
    "function_name": "parseFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "137-189",
    "snippet": "void parseFile(List<Statement>::Reader statements, ParsedFile::Builder result,\n               ErrorReporter& errorReporter) {\n  CapnpParser parser(Orphanage::getForMessageContaining(result), errorReporter);\n\n  kj::Vector<Orphan<Declaration>> decls(statements.size());\n  kj::Vector<Orphan<Declaration::AnnotationApplication>> annotations;\n\n  auto fileDecl = result.getRoot();\n  fileDecl.setFile(VOID);\n\n  for (auto statement: statements) {\n    KJ_IF_MAYBE(decl, parser.parseStatement(statement, parser.getParsers().fileLevelDecl)) {\n      Declaration::Builder builder = decl->get();\n      switch (builder.which()) {\n        case Declaration::NAKED_ID:\n          if (fileDecl.getId().isUid()) {\n            errorReporter.addError(builder.getStartByte(), builder.getEndByte(),\n                                   \"File can only have one ID.\");\n          } else {\n            fileDecl.getId().adoptUid(builder.disownNakedId());\n            if (builder.hasDocComment()) {\n              fileDecl.adoptDocComment(builder.disownDocComment());\n            }\n          }\n          break;\n        case Declaration::NAKED_ANNOTATION:\n          annotations.add(builder.disownNakedAnnotation());\n          break;\n        default:\n          decls.add(kj::mv(*decl));\n          break;\n      }\n    }\n  }\n\n  if (fileDecl.getId().which() != Declaration::Id::UID) {\n    uint64_t id = generateRandomId();\n    fileDecl.getId().initUid().setValue(id);\n    errorReporter.addError(0, 0,\n        kj::str(\"File does not declare an ID.  I've generated one for you.  Add this line to your \"\n                \"file: @0x\", kj::hex(id), \";\"));\n  }\n\n  auto declsBuilder = fileDecl.initNestedDecls(decls.size());\n  for (size_t i = 0; i < decls.size(); i++) {\n    declsBuilder.adoptWithCaveats(i, kj::mv(decls[i]));\n  }\n\n  auto annotationsBuilder = fileDecl.initAnnotations(annotations.size());\n  for (size_t i = 0; i < annotations.size(); i++) {\n    annotationsBuilder.adoptWithCaveats(i, kj::mv(annotations[i]));\n  }\n}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "annotationsBuilder.adoptWithCaveats",
          "args": [
            "i",
            "kj::mv(annotations[i])"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "adoptWithCaveats",
          "container": "Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/list.h",
          "lines": "251-268",
          "snippet": "inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n      // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n      // the fact that structs in a struct list are allocated inline rather than by pointer:\n      // * This actually performs a shallow copy, effectively adopting each of the orphan's\n      //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n      //   possibly wasting space in the message object.\n      // * If the orphan is larger than the target struct -- say, because the orphan was built\n      //   using a newer version of the schema that has additional fields -- it will be truncated,\n      //   losing data.\n\n      KJ_IREQUIRE(index < size());\n\n      // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n      // expanded under any circumstances.  We're just going to throw it away anyway, and\n      // transferContentFrom() already carefully compares the struct sizes before transferring.\n      builder.getStructElement(index * ELEMENTS).transferContentFrom(\n          orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n    }",
          "includes": [
            "#include <iterator>",
            "#include <initializer_list>",
            "#include \"orphan.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <initializer_list>\n#include \"orphan.h\"\n#include \"layout.h\"\n\nBuilder {\n  inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n        // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n        // the fact that structs in a struct list are allocated inline rather than by pointer:\n        // * This actually performs a shallow copy, effectively adopting each of the orphan's\n        //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n        //   possibly wasting space in the message object.\n        // * If the orphan is larger than the target struct -- say, because the orphan was built\n        //   using a newer version of the schema that has additional fields -- it will be truncated,\n        //   losing data.\n  \n        KJ_IREQUIRE(index < size());\n  \n        // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n        // expanded under any circumstances.  We're just going to throw it away anyway, and\n        // transferContentFrom() already carefully compares the struct sizes before transferring.\n        builder.getStructElement(index * ELEMENTS).transferContentFrom(\n            orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "annotations[i]"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotations.size",
          "args": [],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileDecl.initAnnotations",
          "args": [
            "annotations.size()"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "decls[i]"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileDecl.initNestedDecls",
          "args": [
            "decls.size()"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errorReporter.addError",
          "args": [
            "0",
            "0",
            "kj::str(\"File does not declare an ID.  I've generated one for you.  Add this line to your \"\n                \"file: @0x\", kj::hex(id), \";\")"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "addError",
          "container": "TestFailingErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer-test.c++",
          "lines": "32-34",
          "snippet": "void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n    KJ_FAIL_EXPECT(\"Parse failed.\", startByte, endByte, message);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"../message.h\"",
            "#include \"lexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"../message.h\"\n#include \"lexer.h\"\n\nTestFailingErrorReporter {\n  void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n      KJ_FAIL_EXPECT(\"Parse failed.\", startByte, endByte, message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"File does not declare an ID.  I've generated one for you.  Add this line to your \"\n                \"file: @0x\"",
            "kj::hex(id)",
            "\";\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::hex",
          "args": [
            "id"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileDecl.getId",
          "args": [
            "id"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileDecl.getId",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "generateRandomId",
          "args": [],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "generateRandomId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "39-60",
          "snippet": "uint64_t generateRandomId() {\n  uint64_t result;\n\n#if _WIN32\n  HCRYPTPROV handle;\n  KJ_ASSERT(CryptAcquireContextW(&handle, nullptr, nullptr,\n                                 PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT));\n  KJ_DEFER(KJ_ASSERT(CryptReleaseContext(handle, 0)) {break;});\n\n  KJ_ASSERT(CryptGenRandom(handle, sizeof(result), reinterpret_cast<BYTE*>(&result)));\n\n#else\n  int fd;\n  KJ_SYSCALL(fd = open(\"/dev/urandom\", O_RDONLY));\n\n  ssize_t n;\n  KJ_SYSCALL(n = read(fd, &result, sizeof(result)), \"/dev/urandom\");\n  KJ_ASSERT(n == sizeof(result), \"Incomplete read from /dev/urandom.\", n);\n#endif\n\n  return result | (1ull << 63);\n}",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nuint64_t generateRandomId() {\n  uint64_t result;\n\n#if _WIN32\n  HCRYPTPROV handle;\n  KJ_ASSERT(CryptAcquireContextW(&handle, nullptr, nullptr,\n                                 PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT));\n  KJ_DEFER(KJ_ASSERT(CryptReleaseContext(handle, 0)) {break;});\n\n  KJ_ASSERT(CryptGenRandom(handle, sizeof(result), reinterpret_cast<BYTE*>(&result)));\n\n#else\n  int fd;\n  KJ_SYSCALL(fd = open(\"/dev/urandom\", O_RDONLY));\n\n  ssize_t n;\n  KJ_SYSCALL(n = read(fd, &result, sizeof(result)), \"/dev/urandom\");\n  KJ_ASSERT(n == sizeof(result), \"Incomplete read from /dev/urandom.\", n);\n#endif\n\n  return result | (1ull << 63);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decls.add",
          "args": [
            "kj::mv(*decl)"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*decl"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.disownNakedAnnotation",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileDecl.adoptDocComment",
          "args": [
            "builder.disownDocComment()"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.disownDocComment",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.hasDocComment",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileDecl.getId",
          "args": [
            "builder.disownNakedId()"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.disownNakedId",
          "args": [],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getEndByte",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getStartByte",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.which",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl->get",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "decl",
            "parser.parseStatement(statement, parser.getParsers().fileLevelDecl)"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "parser.parseStatement",
          "args": [
            "statement",
            "parser.getParsers().fileLevelDecl"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser.getParsers",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileDecl.setFile",
          "args": [
            "VOID"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.getRoot",
          "args": [],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nvoid parseFile(List<Statement>::Reader statements, ParsedFile::Builder result,\n               ErrorReporter& errorReporter) {\n  CapnpParser parser(Orphanage::getForMessageContaining(result), errorReporter);\n\n  kj::Vector<Orphan<Declaration>> decls(statements.size());\n  kj::Vector<Orphan<Declaration::AnnotationApplication>> annotations;\n\n  auto fileDecl = result.getRoot();\n  fileDecl.setFile(VOID);\n\n  for (auto statement: statements) {\n    KJ_IF_MAYBE(decl, parser.parseStatement(statement, parser.getParsers().fileLevelDecl)) {\n      Declaration::Builder builder = decl->get();\n      switch (builder.which()) {\n        case Declaration::NAKED_ID:\n          if (fileDecl.getId().isUid()) {\n            errorReporter.addError(builder.getStartByte(), builder.getEndByte(),\n                                   \"File can only have one ID.\");\n          } else {\n            fileDecl.getId().adoptUid(builder.disownNakedId());\n            if (builder.hasDocComment()) {\n              fileDecl.adoptDocComment(builder.disownDocComment());\n            }\n          }\n          break;\n        case Declaration::NAKED_ANNOTATION:\n          annotations.add(builder.disownNakedAnnotation());\n          break;\n        default:\n          decls.add(kj::mv(*decl));\n          break;\n      }\n    }\n  }\n\n  if (fileDecl.getId().which() != Declaration::Id::UID) {\n    uint64_t id = generateRandomId();\n    fileDecl.getId().initUid().setValue(id);\n    errorReporter.addError(0, 0,\n        kj::str(\"File does not declare an ID.  I've generated one for you.  Add this line to your \"\n                \"file: @0x\", kj::hex(id), \";\"));\n  }\n\n  auto declsBuilder = fileDecl.initNestedDecls(decls.size());\n  for (size_t i = 0; i < decls.size(); i++) {\n    declsBuilder.adoptWithCaveats(i, kj::mv(decls[i]));\n  }\n\n  auto annotationsBuilder = fileDecl.initAnnotations(annotations.size());\n  for (size_t i = 0; i < annotations.size(); i++) {\n    annotationsBuilder.adoptWithCaveats(i, kj::mv(annotations[i]));\n  }\n}"
  },
  {
    "function_name": "generateMethodParamsId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "110-135",
    "snippet": "uint64_t generateMethodParamsId(uint64_t parentId, uint16_t methodOrdinal, bool isResults) {\n  // Compute ID by MD5 hashing the concatenation of the parent ID, the method ordinal, and a\n  // boolean indicating whether this is the params or the results, and then taking the first 8\n  // bytes.\n\n  kj::byte bytes[sizeof(uint64_t) + sizeof(uint16_t) + 1];\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    bytes[i] = (parentId >> (i * 8)) & 0xff;\n  }\n  for (uint i = 0; i < sizeof(uint16_t); i++) {\n    bytes[sizeof(uint64_t) + i] = (methodOrdinal >> (i * 8)) & 0xff;\n  }\n  bytes[sizeof(bytes) - 1] = isResults;\n\n  Md5 md5;\n  md5.update(bytes);\n\n  kj::ArrayPtr<const kj::byte> resultBytes = md5.finish();\n\n  uint64_t result = 0;\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    result = (result << 8) | resultBytes[i];\n  }\n\n  return result | (1ull << 63);\n}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "md5.finish",
          "args": [],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "md5.update",
          "args": [
            "bytes"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "update",
          "container": "Md5",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/md5.h",
          "lines": "52-54",
          "snippet": "inline void update(const char* data) {\n    return update(kj::StringPtr(data));\n  }",
          "includes": [
            "#include <kj/array.h>",
            "#include <kj/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/array.h>\n#include <kj/string.h>\n\nMd5 {\n  inline void update(const char* data) {\n      return update(kj::StringPtr(data));\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nuint64_t generateMethodParamsId(uint64_t parentId, uint16_t methodOrdinal, bool isResults) {\n  // Compute ID by MD5 hashing the concatenation of the parent ID, the method ordinal, and a\n  // boolean indicating whether this is the params or the results, and then taking the first 8\n  // bytes.\n\n  kj::byte bytes[sizeof(uint64_t) + sizeof(uint16_t) + 1];\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    bytes[i] = (parentId >> (i * 8)) & 0xff;\n  }\n  for (uint i = 0; i < sizeof(uint16_t); i++) {\n    bytes[sizeof(uint64_t) + i] = (methodOrdinal >> (i * 8)) & 0xff;\n  }\n  bytes[sizeof(bytes) - 1] = isResults;\n\n  Md5 md5;\n  md5.update(bytes);\n\n  kj::ArrayPtr<const kj::byte> resultBytes = md5.finish();\n\n  uint64_t result = 0;\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    result = (result << 8) | resultBytes[i];\n  }\n\n  return result | (1ull << 63);\n}"
  },
  {
    "function_name": "generateGroupId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "85-108",
    "snippet": "uint64_t generateGroupId(uint64_t parentId, uint16_t groupIndex) {\n  // Compute ID by MD5 hashing the concatenation of the parent ID and the group index, and\n  // then taking the first 8 bytes.\n\n  kj::byte bytes[sizeof(uint64_t) + sizeof(uint16_t)];\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    bytes[i] = (parentId >> (i * 8)) & 0xff;\n  }\n  for (uint i = 0; i < sizeof(uint16_t); i++) {\n    bytes[sizeof(uint64_t) + i] = (groupIndex >> (i * 8)) & 0xff;\n  }\n\n  Md5 md5;\n  md5.update(bytes);\n\n  kj::ArrayPtr<const kj::byte> resultBytes = md5.finish();\n\n  uint64_t result = 0;\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    result = (result << 8) | resultBytes[i];\n  }\n\n  return result | (1ull << 63);\n}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "md5.finish",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "md5.update",
          "args": [
            "bytes"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "update",
          "container": "Md5",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/md5.h",
          "lines": "52-54",
          "snippet": "inline void update(const char* data) {\n    return update(kj::StringPtr(data));\n  }",
          "includes": [
            "#include <kj/array.h>",
            "#include <kj/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/array.h>\n#include <kj/string.h>\n\nMd5 {\n  inline void update(const char* data) {\n      return update(kj::StringPtr(data));\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nuint64_t generateGroupId(uint64_t parentId, uint16_t groupIndex) {\n  // Compute ID by MD5 hashing the concatenation of the parent ID and the group index, and\n  // then taking the first 8 bytes.\n\n  kj::byte bytes[sizeof(uint64_t) + sizeof(uint16_t)];\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    bytes[i] = (parentId >> (i * 8)) & 0xff;\n  }\n  for (uint i = 0; i < sizeof(uint16_t); i++) {\n    bytes[sizeof(uint64_t) + i] = (groupIndex >> (i * 8)) & 0xff;\n  }\n\n  Md5 md5;\n  md5.update(bytes);\n\n  kj::ArrayPtr<const kj::byte> resultBytes = md5.finish();\n\n  uint64_t result = 0;\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    result = (result << 8) | resultBytes[i];\n  }\n\n  return result | (1ull << 63);\n}"
  },
  {
    "function_name": "generateChildId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "62-83",
    "snippet": "uint64_t generateChildId(uint64_t parentId, kj::StringPtr childName) {\n  // Compute ID by MD5 hashing the concatenation of the parent ID and the declaration name, and\n  // then taking the first 8 bytes.\n\n  kj::byte parentIdBytes[sizeof(uint64_t)];\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    parentIdBytes[i] = (parentId >> (i * 8)) & 0xff;\n  }\n\n  Md5 md5;\n  md5.update(kj::arrayPtr(parentIdBytes, kj::size(parentIdBytes)));\n  md5.update(childName);\n\n  kj::ArrayPtr<const kj::byte> resultBytes = md5.finish();\n\n  uint64_t result = 0;\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    result = (result << 8) | resultBytes[i];\n  }\n\n  return result | (1ull << 63);\n}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "md5.finish",
          "args": [],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "md5.update",
          "args": [
            "childName"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "update",
          "container": "Md5",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/md5.h",
          "lines": "52-54",
          "snippet": "inline void update(const char* data) {\n    return update(kj::StringPtr(data));\n  }",
          "includes": [
            "#include <kj/array.h>",
            "#include <kj/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/array.h>\n#include <kj/string.h>\n\nMd5 {\n  inline void update(const char* data) {\n      return update(kj::StringPtr(data));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "parentIdBytes",
            "kj::size(parentIdBytes)"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::size",
          "args": [
            "parentIdBytes"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "493-493",
          "snippet": "inline constexpr size_t size(T&& arr) { return arr.size(); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr size_t size(T&& arr) { return arr.size(); }"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nuint64_t generateChildId(uint64_t parentId, kj::StringPtr childName) {\n  // Compute ID by MD5 hashing the concatenation of the parent ID and the declaration name, and\n  // then taking the first 8 bytes.\n\n  kj::byte parentIdBytes[sizeof(uint64_t)];\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    parentIdBytes[i] = (parentId >> (i * 8)) & 0xff;\n  }\n\n  Md5 md5;\n  md5.update(kj::arrayPtr(parentIdBytes, kj::size(parentIdBytes)));\n  md5.update(childName);\n\n  kj::ArrayPtr<const kj::byte> resultBytes = md5.finish();\n\n  uint64_t result = 0;\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    result = (result << 8) | resultBytes[i];\n  }\n\n  return result | (1ull << 63);\n}"
  },
  {
    "function_name": "generateRandomId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
    "lines": "39-60",
    "snippet": "uint64_t generateRandomId() {\n  uint64_t result;\n\n#if _WIN32\n  HCRYPTPROV handle;\n  KJ_ASSERT(CryptAcquireContextW(&handle, nullptr, nullptr,\n                                 PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT));\n  KJ_DEFER(KJ_ASSERT(CryptReleaseContext(handle, 0)) {break;});\n\n  KJ_ASSERT(CryptGenRandom(handle, sizeof(result), reinterpret_cast<BYTE*>(&result)));\n\n#else\n  int fd;\n  KJ_SYSCALL(fd = open(\"/dev/urandom\", O_RDONLY));\n\n  ssize_t n;\n  KJ_SYSCALL(n = read(fd, &result, sizeof(result)), \"/dev/urandom\");\n  KJ_ASSERT(n == sizeof(result), \"Incomplete read from /dev/urandom.\", n);\n#endif\n\n  return result | (1ull << 63);\n}",
    "includes": [
      "#include <windows.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <kj/debug.h>",
      "#include <capnp/dynamic.h>",
      "#include \"md5.h\"",
      "#include \"parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "n == sizeof(result)",
            "\"Incomplete read from /dev/urandom.\"",
            "n"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "n = read(fd, &result, sizeof(result))",
            "\"/dev/urandom\""
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "&result",
            "sizeof(result)"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "AsyncMessageReader::read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
          "lines": "66-81",
          "snippet": "kj::Promise<bool> AsyncMessageReader::read(kj::AsyncInputStream& inputStream,\n                                           kj::ArrayPtr<word> scratchSpace) {\n  return inputStream.tryRead(firstWord, sizeof(firstWord), sizeof(firstWord))\n      .then([this,&inputStream,scratchSpace](size_t n) mutable -> kj::Promise<bool> {\n    if (n == 0) {\n      return false;\n    } else if (n < sizeof(firstWord)) {\n      // EOF in first word.\n      KJ_FAIL_REQUIRE(\"Premature EOF.\") {\n        return false;\n      }\n    }\n\n    return readAfterFirstWord(inputStream, scratchSpace).then([]() { return true; });\n  });\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nkj::Promise<bool> AsyncMessageReader::read(kj::AsyncInputStream& inputStream,\n                                           kj::ArrayPtr<word> scratchSpace) {\n  return inputStream.tryRead(firstWord, sizeof(firstWord), sizeof(firstWord))\n      .then([this,&inputStream,scratchSpace](size_t n) mutable -> kj::Promise<bool> {\n    if (n == 0) {\n      return false;\n    } else if (n < sizeof(firstWord)) {\n      // EOF in first word.\n      KJ_FAIL_REQUIRE(\"Premature EOF.\") {\n        return false;\n      }\n    }\n\n    return readAfterFirstWord(inputStream, scratchSpace).then([]() { return true; });\n  });\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fd = open(\"/dev/urandom\", O_RDONLY)"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/urandom\"",
            "O_RDONLY"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "CryptGenRandom(handle, sizeof(result), reinterpret_cast<BYTE*>(&result))"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CryptGenRandom",
          "args": [
            "handle",
            "sizeof(result)",
            "reinterpret_cast<BYTE*>(&result)"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<BYTE*>",
          "args": [
            "&result"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "KJ_ASSERT(CryptReleaseContext(handle, 0)){break;}"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "CryptReleaseContext(handle, 0)"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CryptReleaseContext",
          "args": [
            "handle",
            "0"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "CryptAcquireContextW(&handle, nullptr, nullptr,\n                                 PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT)"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CryptAcquireContextW",
          "args": [
            "&handle",
            "nullptr",
            "nullptr",
            "PROV_RSA_FULL",
            "CRYPT_VERIFYCONTEXT | CRYPT_SILENT"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nuint64_t generateRandomId() {\n  uint64_t result;\n\n#if _WIN32\n  HCRYPTPROV handle;\n  KJ_ASSERT(CryptAcquireContextW(&handle, nullptr, nullptr,\n                                 PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT));\n  KJ_DEFER(KJ_ASSERT(CryptReleaseContext(handle, 0)) {break;});\n\n  KJ_ASSERT(CryptGenRandom(handle, sizeof(result), reinterpret_cast<BYTE*>(&result)));\n\n#else\n  int fd;\n  KJ_SYSCALL(fd = open(\"/dev/urandom\", O_RDONLY));\n\n  ssize_t n;\n  KJ_SYSCALL(n = read(fd, &result, sizeof(result)), \"/dev/urandom\");\n  KJ_ASSERT(n == sizeof(result), \"Incomplete read from /dev/urandom.\", n);\n#endif\n\n  return result | (1ull << 63);\n}"
  }
]