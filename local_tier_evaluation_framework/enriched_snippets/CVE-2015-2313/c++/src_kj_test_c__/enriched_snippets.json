[
  {
    "function_name": "write",
    "container": "TestRunner",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "426-439",
    "snippet": "void write(Color color, StringPtr prefix, StringPtr message) {\n    StringPtr startColor, endColor;\n    if (useColor) {\n      switch (color) {\n        case RED:   startColor = \"\\033[0;1;31m\"; break;\n        case GREEN: startColor = \"\\033[0;1;32m\"; break;\n        case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n      }\n      endColor = \"\\033[0m\";\n    }\n\n    String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n    write(text);\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "startColor",
            "prefix",
            "endColor",
            "' '",
            "message",
            "'\\n'"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  void write(Color color, StringPtr prefix, StringPtr message) {\n      StringPtr startColor, endColor;\n      if (useColor) {\n        switch (color) {\n          case RED:   startColor = \"\\033[0;1;31m\"; break;\n          case GREEN: startColor = \"\\033[0;1;32m\"; break;\n          case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n        }\n        endColor = \"\\033[0m\";\n      }\n  \n      String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n      write(text);\n    }\n}"
  },
  {
    "function_name": "write",
    "container": "TestRunner",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "422-424",
    "snippet": "void write(StringPtr text) {\n    FdOutputStream(STDOUT_FILENO).write(text.begin(), text.size());\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FdOutputStream",
          "args": [
            "text.begin()",
            "text.size()"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text.size",
          "args": [],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.begin",
          "args": [],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FdOutputStream",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "FdOutputStream",
          "container": "FdOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.h",
          "lines": "298-298",
          "snippet": "explicit FdOutputStream(AutoCloseFd fd): fd(fd), autoclose(mv(fd)) {}",
          "includes": [
            "#include \"exception.h\"",
            "#include \"array.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exception.h\"\n#include \"array.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nFdOutputStream {\n  explicit FdOutputStream(AutoCloseFd fd): fd(fd), autoclose(mv(fd)) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  void write(StringPtr text) {\n      FdOutputStream(STDOUT_FILENO).write(text.begin(), text.size());\n    }\n}"
  },
  {
    "function_name": "run",
    "container": "TestRunner",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "353-408",
    "snippet": "MainBuilder::Validity run() {\n    if (testCasesHead == nullptr) {\n      return \"no tests were declared\";\n    }\n\n    // Find the common path prefix of all filenames, so we can strip it off.\n    ArrayPtr<const char> commonPrefix = StringPtr(testCasesHead->file);\n    for (TestCase* testCase = testCasesHead; testCase != nullptr; testCase = testCase->next) {\n      for (size_t i: kj::indices(commonPrefix)) {\n        if (testCase->file[i] != commonPrefix[i]) {\n          commonPrefix = commonPrefix.slice(0, i);\n          break;\n        }\n      }\n    }\n\n    // Back off the prefix to the last '/'.\n    while (commonPrefix.size() > 0 && commonPrefix.back() != '/' && commonPrefix.back() != '\\\\') {\n      commonPrefix = commonPrefix.slice(0, commonPrefix.size() - 1);\n    }\n\n    // Run the testts.\n    uint passCount = 0;\n    uint failCount = 0;\n    for (TestCase* testCase = testCasesHead; testCase != nullptr; testCase = testCase->next) {\n      if (!hasFilter || testCase->matchedFilter) {\n        auto name = kj::str(testCase->file + commonPrefix.size(), ':', testCase->line,\n                            \": \", testCase->description);\n\n        write(BLUE, \"[ TEST ]\", name);\n\n        if (!listOnly) {\n          bool currentFailed = true;\n          KJ_IF_MAYBE(exception, runCatchingExceptions([&]() {\n            TestExceptionCallback exceptionCallback(context);\n            testCase->run();\n            currentFailed = exceptionCallback.failed();\n          })) {\n            context.error(kj::str(*exception));\n          }\n\n          if (currentFailed) {\n            write(RED, \"[ FAIL ]\", name);\n            ++failCount;\n          } else {\n            write(GREEN, \"[ PASS ]\", name);\n            ++passCount;\n          }\n        }\n      }\n    }\n\n    if (passCount > 0) write(GREEN, kj::str(passCount, \" test(s) passed\"), \"\");\n    if (failCount > 0) write(RED, kj::str(failCount, \" test(s) failed\"), \"\");\n    context.exit();\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.exit",
          "args": [],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "RED",
            "kj::str(failCount, \" test(s) failed\")",
            "\"\""
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "TestRunner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "426-439",
          "snippet": "void write(Color color, StringPtr prefix, StringPtr message) {\n    StringPtr startColor, endColor;\n    if (useColor) {\n      switch (color) {\n        case RED:   startColor = \"\\033[0;1;31m\"; break;\n        case GREEN: startColor = \"\\033[0;1;32m\"; break;\n        case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n      }\n      endColor = \"\\033[0m\";\n    }\n\n    String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n    write(text);\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  void write(Color color, StringPtr prefix, StringPtr message) {\n      StringPtr startColor, endColor;\n      if (useColor) {\n        switch (color) {\n          case RED:   startColor = \"\\033[0;1;31m\"; break;\n          case GREEN: startColor = \"\\033[0;1;32m\"; break;\n          case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n        }\n        endColor = \"\\033[0m\";\n      }\n  \n      String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n      write(text);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "failCount",
            "\" test(s) failed\""
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "passCount",
            "\" test(s) passed\""
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.error",
          "args": [
            "kj::str(*exception)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "*exception"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "341-341",
          "snippet": "inline String str(String&& s) { return mv(s); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exception",
            "runCatchingExceptions([&]() {\n            TestExceptionCallback exceptionCallback(context);\n            testCase->run();\n            currentFailed = exceptionCallback.failed();\n          })"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "runCatchingExceptions",
          "args": [
            "[&]() {\n            TestExceptionCallback exceptionCallback(context);\n            testCase->run();\n            currentFailed = exceptionCallback.failed();\n          }"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exceptionCallback.failed",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "failed",
          "container": "TestExceptionCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "250-250",
          "snippet": "bool failed() { return sawError; }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestExceptionCallback {\n  bool failed() { return sawError; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "testCase->run",
          "args": [],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": "RunnableImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "257-259",
          "snippet": "void run() override {\n    func();\n  }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nRunnableImpl {\n  void run() override {\n      func();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "testCase->file + commonPrefix.size()",
            "':'",
            "testCase->line",
            "\": \"",
            "testCase->description"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commonPrefix.size",
          "args": [],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "commonPrefix.slice",
          "args": [
            "0",
            "commonPrefix.size() - 1"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "commonPrefix.back",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commonPrefix.back",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "commonPrefix"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "StringPtr",
          "args": [
            "testCasesHead->file"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "StringPtr",
          "container": "StringPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "116-116",
          "snippet": "inline StringPtr(ArrayPtr<const char> content): content(content) {}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(ArrayPtr<const char> content): content(content) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  MainBuilder::Validity run() {\n      if (testCasesHead == nullptr) {\n        return \"no tests were declared\";\n      }\n  \n      // Find the common path prefix of all filenames, so we can strip it off.\n      ArrayPtr<const char> commonPrefix = StringPtr(testCasesHead->file);\n      for (TestCase* testCase = testCasesHead; testCase != nullptr; testCase = testCase->next) {\n        for (size_t i: kj::indices(commonPrefix)) {\n          if (testCase->file[i] != commonPrefix[i]) {\n            commonPrefix = commonPrefix.slice(0, i);\n            break;\n          }\n        }\n      }\n  \n      // Back off the prefix to the last '/'.\n      while (commonPrefix.size() > 0 && commonPrefix.back() != '/' && commonPrefix.back() != '\\\\') {\n        commonPrefix = commonPrefix.slice(0, commonPrefix.size() - 1);\n      }\n  \n      // Run the testts.\n      uint passCount = 0;\n      uint failCount = 0;\n      for (TestCase* testCase = testCasesHead; testCase != nullptr; testCase = testCase->next) {\n        if (!hasFilter || testCase->matchedFilter) {\n          auto name = kj::str(testCase->file + commonPrefix.size(), ':', testCase->line,\n                              \": \", testCase->description);\n  \n          write(BLUE, \"[ TEST ]\", name);\n  \n          if (!listOnly) {\n            bool currentFailed = true;\n            KJ_IF_MAYBE(exception, runCatchingExceptions([&]() {\n              TestExceptionCallback exceptionCallback(context);\n              testCase->run();\n              currentFailed = exceptionCallback.failed();\n            })) {\n              context.error(kj::str(*exception));\n            }\n  \n            if (currentFailed) {\n              write(RED, \"[ FAIL ]\", name);\n              ++failCount;\n            } else {\n              write(GREEN, \"[ PASS ]\", name);\n              ++passCount;\n            }\n          }\n        }\n      }\n  \n      if (passCount > 0) write(GREEN, kj::str(passCount, \" test(s) passed\"), \"\");\n      if (failCount > 0) write(RED, kj::str(failCount, \" test(s) failed\"), \"\");\n      context.exit();\n    }\n}"
  },
  {
    "function_name": "setList",
    "container": "TestRunner",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "348-351",
    "snippet": "MainBuilder::Validity setList() {\n    listOnly = true;\n    return true;\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  MainBuilder::Validity setList() {\n      listOnly = true;\n      return true;\n    }\n}"
  },
  {
    "function_name": "setFilter",
    "container": "TestRunner",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "300-346",
    "snippet": "MainBuilder::Validity setFilter(StringPtr pattern) {\n    hasFilter = true;\n    ArrayPtr<const char> filePattern = pattern;\n    uint minLine = kj::minValue;\n    uint maxLine = kj::maxValue;\n\n    KJ_IF_MAYBE(colonPos, pattern.findLast(':')) {\n      char* end;\n      StringPtr lineStr = pattern.slice(*colonPos + 1);\n\n      bool parsedRange = false;\n      minLine = strtoul(lineStr.cStr(), &end, 0);\n      if (end != lineStr.begin()) {\n        if (*end == '-') {\n          // A range.\n          const char* part2 = end + 1;\n          maxLine = strtoul(part2, &end, 0);\n          if (end > part2 && *end == '\\0') {\n            parsedRange = true;\n          }\n        } else if (*end == '\\0') {\n          parsedRange = true;\n        }\n      }\n\n      if (parsedRange) {\n        // We have an exact line number.\n        filePattern = pattern.slice(0, *colonPos);\n      } else {\n        // Can't parse as a number. Maybe the colon is part of a Windows path name or something.\n        // Let's just keep it as part of the file pattern.\n        minLine = kj::minValue;\n        maxLine = kj::maxValue;\n      }\n    }\n\n    _::GlobFilter filter(filePattern);\n\n    for (TestCase* testCase = testCasesHead; testCase != nullptr; testCase = testCase->next) {\n      if (!testCase->matchedFilter && filter.matches(testCase->file) &&\n          testCase->line >= minLine && testCase->line <= maxLine) {\n        testCase->matchedFilter = true;\n      }\n    }\n\n    return true;\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filter.matches",
          "args": [
            "testCase->file"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pattern.slice",
          "args": [
            "0",
            "*colonPos"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "part2",
            "&end",
            "0"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lineStr.begin",
          "args": [],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "lineStr.cStr()",
            "&end",
            "0"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lineStr.cStr",
          "args": [],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pattern.slice",
          "args": [
            "*colonPos + 1"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "177-177",
          "snippet": "inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "colonPos",
            "pattern.findLast(':')"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "pattern.findLast",
          "args": [
            "':'"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "findLast",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "183-183",
          "snippet": "inline Maybe<size_t> findLast(char c) const { return StringPtr(*this).findLast(c); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline Maybe<size_t> findLast(char c) const { return StringPtr(*this).findLast(c); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  MainBuilder::Validity setFilter(StringPtr pattern) {\n      hasFilter = true;\n      ArrayPtr<const char> filePattern = pattern;\n      uint minLine = kj::minValue;\n      uint maxLine = kj::maxValue;\n  \n      KJ_IF_MAYBE(colonPos, pattern.findLast(':')) {\n        char* end;\n        StringPtr lineStr = pattern.slice(*colonPos + 1);\n  \n        bool parsedRange = false;\n        minLine = strtoul(lineStr.cStr(), &end, 0);\n        if (end != lineStr.begin()) {\n          if (*end == '-') {\n            // A range.\n            const char* part2 = end + 1;\n            maxLine = strtoul(part2, &end, 0);\n            if (end > part2 && *end == '\\0') {\n              parsedRange = true;\n            }\n          } else if (*end == '\\0') {\n            parsedRange = true;\n          }\n        }\n  \n        if (parsedRange) {\n          // We have an exact line number.\n          filePattern = pattern.slice(0, *colonPos);\n        } else {\n          // Can't parse as a number. Maybe the colon is part of a Windows path name or something.\n          // Let's just keep it as part of the file pattern.\n          minLine = kj::minValue;\n          maxLine = kj::maxValue;\n        }\n      }\n  \n      _::GlobFilter filter(filePattern);\n  \n      for (TestCase* testCase = testCasesHead; testCase != nullptr; testCase = testCase->next) {\n        if (!testCase->matchedFilter && filter.matches(testCase->file) &&\n            testCase->line >= minLine && testCase->line <= maxLine) {\n          testCase->matchedFilter = true;\n        }\n      }\n  \n      return true;\n    }\n}"
  },
  {
    "function_name": "getMain",
    "container": "TestRunner",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "285-298",
    "snippet": "MainFunc getMain() {\n    return MainBuilder(context, \"KJ Test Runner (version not applicable)\",\n        \"Run all tests that have been linked into the binary with this test runner.\")\n        .addOptionWithArg({'f', \"filter\"}, KJ_BIND_METHOD(*this, setFilter), \"<file>[:<line>]\",\n            \"Run only the specified test case(s). You may use a '*' wildcard in <file>. You may \"\n            \"also omit any prefix of <file>'s path; test from all matching files will run. \"\n            \"You may specify multiple filters; any test matching at least one filter will run. \"\n            \"<line> may be a range, e.g. \\\"100-500\\\".\")\n        .addOption({'l', \"list\"}, KJ_BIND_METHOD(*this, setList),\n            \"List all test cases that would run, but don't run them. If --filter is specified \"\n            \"then only the match tests will be listed.\")\n        .callAfterParsing(KJ_BIND_METHOD(*this, run))\n        .build();\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MainBuilder",
          "args": [],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "releaseError",
          "container": "MainBuilder::Validity",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.h",
          "lines": "279-279",
          "snippet": "inline Maybe<String> releaseError() { return kj::mv(errorMessage); }",
          "includes": [
            "#include \"function.h\"",
            "#include \"vector.h\"",
            "#include \"string.h\"",
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"function.h\"\n#include \"vector.h\"\n#include \"string.h\"\n#include \"array.h\"\n\nMainBuilder {\n  Validity {\n    inline Maybe<String> releaseError() { return kj::mv(errorMessage); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MainBuilder",
          "args": [
            "KJ_BIND_METHOD(*this, run)"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "Validity",
          "container": "MainBuilder::Validity",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.h",
          "lines": "275-276",
          "snippet": "inline Validity(String&& errorMessage)\n        : errorMessage(kj::mv(errorMessage)) {}",
          "includes": [
            "#include \"function.h\"",
            "#include \"vector.h\"",
            "#include \"string.h\"",
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"function.h\"\n#include \"vector.h\"\n#include \"string.h\"\n#include \"array.h\"\n\nMainBuilder {\n  Validity {\n    inline Validity(String&& errorMessage)\n            : errorMessage(kj::mv(errorMessage)) {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "run"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MainBuilder",
          "args": [
            "{'l', \"list\"}",
            "KJ_BIND_METHOD(*this, setList)",
            "\"List all test cases that would run, but don't run them. If --filter is specified \"\n            \"then only the match tests will be listed.\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setList"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MainBuilder",
          "args": [
            "{'f', \"filter\"}",
            "KJ_BIND_METHOD(*this, setFilter)",
            "\"<file>[:<line>]\"",
            "\"Run only the specified test case(s). You may use a '*' wildcard in <file>. You may \"\n            \"also omit any prefix of <file>'s path; test from all matching files will run. \"\n            \"You may specify multiple filters; any test matching at least one filter will run. \"\n            \"<line> may be a range, e.g. \\\"100-500\\\".\""
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "MainBuilder::MainBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/main.c++",
          "lines": "326-333",
          "snippet": "MainBuilder::MainBuilder(ProcessContext& context, StringPtr version,\n                         StringPtr briefDescription, StringPtr extendedDescription)\n    : impl(heap<Impl>(context, version, briefDescription, extendedDescription)) {\n  addOption({\"verbose\"}, KJ_BIND_METHOD(*impl, increaseVerbosity),\n            \"Log informational messages to stderr; useful for debugging.\");\n  addOption({\"version\"}, KJ_BIND_METHOD(*impl, printVersion),\n            \"Print version information and exit.\");\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <windows.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <set>",
            "#include <map>",
            "#include \"arena.h\"",
            "#include \"debug.h\"",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <fcntl.h>\n#include <io.h>\n#include <windows.h>\n#include <limits.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <set>\n#include <map>\n#include \"arena.h\"\n#include \"debug.h\"\n#include \"main.h\"\n\nMainBuilder::MainBuilder(ProcessContext& context, StringPtr version,\n                         StringPtr briefDescription, StringPtr extendedDescription)\n    : impl(heap<Impl>(context, version, briefDescription, extendedDescription)) {\n  addOption({\"verbose\"}, KJ_BIND_METHOD(*impl, increaseVerbosity),\n            \"Log informational messages to stderr; useful for debugging.\");\n  addOption({\"version\"}, KJ_BIND_METHOD(*impl, printVersion),\n            \"Print version information and exit.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setFilter"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MainBuilder",
          "args": [
            "context",
            "\"KJ Test Runner (version not applicable)\"",
            "\"Run all tests that have been linked into the binary with this test runner.\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  MainFunc getMain() {\n      return MainBuilder(context, \"KJ Test Runner (version not applicable)\",\n          \"Run all tests that have been linked into the binary with this test runner.\")\n          .addOptionWithArg({'f', \"filter\"}, KJ_BIND_METHOD(*this, setFilter), \"<file>[:<line>]\",\n              \"Run only the specified test case(s). You may use a '*' wildcard in <file>. You may \"\n              \"also omit any prefix of <file>'s path; test from all matching files will run. \"\n              \"You may specify multiple filters; any test matching at least one filter will run. \"\n              \"<line> may be a range, e.g. \\\"100-500\\\".\")\n          .addOption({'l', \"list\"}, KJ_BIND_METHOD(*this, setList),\n              \"List all test cases that would run, but don't run them. If --filter is specified \"\n              \"then only the match tests will be listed.\")\n          .callAfterParsing(KJ_BIND_METHOD(*this, run))\n          .build();\n    }\n}"
  },
  {
    "function_name": "TestRunner",
    "container": "TestRunner",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "280-283",
    "snippet": "explicit TestRunner(ProcessContext& context)\n      : context(context), useColor(isatty(STDOUT_FILENO)) {\n    registerCrashHandler();\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "registerCrashHandler",
          "args": [],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "registerCrashHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "201-238",
          "snippet": "void registerCrashHandler() {\n  // Set up alternate signal stack so that stack overflows can be handled.\n  stack_t stack;\n  memset(&stack, 0, sizeof(stack));\n\n#ifndef MAP_ANONYMOUS\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n#ifndef MAP_GROWSDOWN\n#define MAP_GROWSDOWN 0\n#endif\n\n  stack.ss_size = 65536;\n  // Note: ss_sp is char* on FreeBSD, void* on Linux and OSX.\n  stack.ss_sp = reinterpret_cast<char*>(mmap(\n      nullptr, stack.ss_size, PROT_READ | PROT_WRITE,\n      MAP_ANONYMOUS | MAP_PRIVATE | MAP_GROWSDOWN, -1, 0));\n  KJ_SYSCALL(sigaltstack(&stack, nullptr));\n\n  // Catch all relevant signals.\n  struct sigaction action;\n  memset(&action, 0, sizeof(action));\n\n  action.sa_flags = SA_SIGINFO | SA_ONSTACK | SA_NODEFER | SA_RESETHAND;\n  action.sa_sigaction = &crashHandler;\n\n  // Dump stack on common \"crash\" signals.\n  KJ_SYSCALL(sigaction(SIGSEGV, &action, nullptr));\n  KJ_SYSCALL(sigaction(SIGBUS, &action, nullptr));\n  KJ_SYSCALL(sigaction(SIGFPE, &action, nullptr));\n  KJ_SYSCALL(sigaction(SIGABRT, &action, nullptr));\n\n  // Dump stack on unimplemented syscalls -- useful in seccomp sandboxes.\n  KJ_SYSCALL(sigaction(SIGSYS, &action, nullptr));\n\n  // Dump stack on keyboard interrupt -- useful for infinite loops.\n  KJ_SYSCALL(sigaction(SIGINT, &action, nullptr));\n}",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [
            "#define MAP_GROWSDOWN 0",
            "#define MAP_ANONYMOUS MAP_ANON"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\n#define MAP_GROWSDOWN 0\n#define MAP_ANONYMOUS MAP_ANON\n\nvoid registerCrashHandler() {\n  // Set up alternate signal stack so that stack overflows can be handled.\n  stack_t stack;\n  memset(&stack, 0, sizeof(stack));\n\n#ifndef MAP_ANONYMOUS\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n#ifndef MAP_GROWSDOWN\n#define MAP_GROWSDOWN 0\n#endif\n\n  stack.ss_size = 65536;\n  // Note: ss_sp is char* on FreeBSD, void* on Linux and OSX.\n  stack.ss_sp = reinterpret_cast<char*>(mmap(\n      nullptr, stack.ss_size, PROT_READ | PROT_WRITE,\n      MAP_ANONYMOUS | MAP_PRIVATE | MAP_GROWSDOWN, -1, 0));\n  KJ_SYSCALL(sigaltstack(&stack, nullptr));\n\n  // Catch all relevant signals.\n  struct sigaction action;\n  memset(&action, 0, sizeof(action));\n\n  action.sa_flags = SA_SIGINFO | SA_ONSTACK | SA_NODEFER | SA_RESETHAND;\n  action.sa_sigaction = &crashHandler;\n\n  // Dump stack on common \"crash\" signals.\n  KJ_SYSCALL(sigaction(SIGSEGV, &action, nullptr));\n  KJ_SYSCALL(sigaction(SIGBUS, &action, nullptr));\n  KJ_SYSCALL(sigaction(SIGFPE, &action, nullptr));\n  KJ_SYSCALL(sigaction(SIGABRT, &action, nullptr));\n\n  // Dump stack on unimplemented syscalls -- useful in seccomp sandboxes.\n  KJ_SYSCALL(sigaction(SIGSYS, &action, nullptr));\n\n  // Dump stack on keyboard interrupt -- useful for infinite loops.\n  KJ_SYSCALL(sigaction(SIGINT, &action, nullptr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  explicit TestRunner(ProcessContext& context)\n        : context(context), useColor(isatty(STDOUT_FILENO)) {\n      registerCrashHandler();\n    }\n}"
  },
  {
    "function_name": "logMessage",
    "container": "TestExceptionCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "252-269",
    "snippet": "void logMessage(LogSeverity severity, const char* file, int line, int contextDepth,\n                  String&& text) override {\n    void* traceSpace[32];\n    auto trace = getStackTrace(traceSpace);\n\n    if (text.size() == 0) {\n      text = kj::heapString(\"expectation failed\");\n    }\n\n    text = kj::str(kj::repeat('_', contextDepth), file, ':', line, \": \", kj::mv(text));\n\n    if (severity == LogSeverity::ERROR || severity == LogSeverity::FATAL) {\n      sawError = true;\n      context.error(kj::str(text, \"\\nstack: \", strArray(trace, \" \"), stringifyStackTrace(trace)));\n    } else {\n      context.warning(text);\n    }\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.warning",
          "args": [
            "text"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.error",
          "args": [
            "kj::str(text, \"\\nstack: \", strArray(trace, \" \"), stringifyStackTrace(trace))"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "text",
            "\"\\nstack: \"",
            "strArray(trace, \" \")",
            "stringifyStackTrace(trace)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringifyStackTrace",
          "args": [
            "trace"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "stringifyStackTrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "63-140",
          "snippet": "String stringifyStackTrace(ArrayPtr<void* const> trace) {\n#if (__linux__ || __APPLE__) && !__ANDROID__ && defined(KJ_DEBUG)\n  // We want to generate a human-readable stack trace.\n\n  // TODO(someday):  It would be really great if we could avoid farming out to another process\n  //   and do this all in-process, but that may involve onerous requirements like large library\n  //   dependencies or using -rdynamic.\n\n  // The environment manipulation is not thread-safe, so lock a mutex.  This could still be\n  // problematic if another thread is manipulating the environment in unrelated code, but there's\n  // not much we can do about that.  This is debug-only anyway and only an issue when LD_PRELOAD\n  // is in use.\n  static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n  pthread_mutex_lock(&mutex);\n  KJ_DEFER(pthread_mutex_unlock(&mutex));\n\n  // Don't heapcheck / intercept syscalls.\n  const char* preload = getenv(\"LD_PRELOAD\");\n  String oldPreload;\n  if (preload != nullptr) {\n    oldPreload = heapString(preload);\n    unsetenv(\"LD_PRELOAD\");\n  }\n  KJ_DEFER(if (oldPreload != nullptr) { setenv(\"LD_PRELOAD\", oldPreload.cStr(), true); });\n\n  String lines[8];\n  FILE* p = nullptr;\n\n#if __linux__\n  // Get executable name from /proc/self/exe, then pass it and the stack trace to addr2line to\n  // get file/line pairs.\n  char exe[512];\n  ssize_t n = readlink(\"/proc/self/exe\", exe, sizeof(exe));\n  if (n < 0 || n >= static_cast<ssize_t>(sizeof(exe))) {\n    return nullptr;\n  }\n  exe[n] = '\\0';\n\n  p = popen(str(\"addr2line -e \", exe, ' ', strArray(trace, \" \")).cStr(), \"r\");\n#elif __APPLE__\n  // The Mac OS X equivalent of addr2line is atos.\n  // (Internally, it uses the private CoreSymbolication.framework library.)\n  p = popen(str(\"xcrun atos -p \", getpid(), ' ', strArray(trace, \" \")).cStr(), \"r\");\n#endif\n\n  if (p == nullptr) {\n    return nullptr;\n  }\n\n  char line[512];\n  size_t i = 0;\n  while (i < kj::size(lines) && fgets(line, sizeof(line), p) != nullptr) {\n    // Don't include exception-handling infrastructure in stack trace.\n    // addr2line output matches file names; atos output matches symbol names.\n    if (i == 0 &&\n        (strstr(line, \"kj/common.c++\") != nullptr ||\n         strstr(line, \"kj/exception.\") != nullptr ||\n         strstr(line, \"kj/debug.\") != nullptr ||\n         strstr(line, \"kj::Exception\") != nullptr ||\n         strstr(line, \"kj::_::Debug\") != nullptr)) {\n      continue;\n    }\n\n    size_t len = strlen(line);\n    if (len > 0 && line[len-1] == '\\n') line[len-1] = '\\0';\n    lines[i++] = str(\"\\n\", line, \": called here\");\n  }\n\n  // Skip remaining input.\n  while (fgets(line, sizeof(line), p) != nullptr) {}\n\n  pclose(p);\n\n  return strArray(arrayPtr(lines, i), \"\");\n#else\n  return nullptr;\n#endif\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nString stringifyStackTrace(ArrayPtr<void* const> trace) {\n#if (__linux__ || __APPLE__) && !__ANDROID__ && defined(KJ_DEBUG)\n  // We want to generate a human-readable stack trace.\n\n  // TODO(someday):  It would be really great if we could avoid farming out to another process\n  //   and do this all in-process, but that may involve onerous requirements like large library\n  //   dependencies or using -rdynamic.\n\n  // The environment manipulation is not thread-safe, so lock a mutex.  This could still be\n  // problematic if another thread is manipulating the environment in unrelated code, but there's\n  // not much we can do about that.  This is debug-only anyway and only an issue when LD_PRELOAD\n  // is in use.\n  static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n  pthread_mutex_lock(&mutex);\n  KJ_DEFER(pthread_mutex_unlock(&mutex));\n\n  // Don't heapcheck / intercept syscalls.\n  const char* preload = getenv(\"LD_PRELOAD\");\n  String oldPreload;\n  if (preload != nullptr) {\n    oldPreload = heapString(preload);\n    unsetenv(\"LD_PRELOAD\");\n  }\n  KJ_DEFER(if (oldPreload != nullptr) { setenv(\"LD_PRELOAD\", oldPreload.cStr(), true); });\n\n  String lines[8];\n  FILE* p = nullptr;\n\n#if __linux__\n  // Get executable name from /proc/self/exe, then pass it and the stack trace to addr2line to\n  // get file/line pairs.\n  char exe[512];\n  ssize_t n = readlink(\"/proc/self/exe\", exe, sizeof(exe));\n  if (n < 0 || n >= static_cast<ssize_t>(sizeof(exe))) {\n    return nullptr;\n  }\n  exe[n] = '\\0';\n\n  p = popen(str(\"addr2line -e \", exe, ' ', strArray(trace, \" \")).cStr(), \"r\");\n#elif __APPLE__\n  // The Mac OS X equivalent of addr2line is atos.\n  // (Internally, it uses the private CoreSymbolication.framework library.)\n  p = popen(str(\"xcrun atos -p \", getpid(), ' ', strArray(trace, \" \")).cStr(), \"r\");\n#endif\n\n  if (p == nullptr) {\n    return nullptr;\n  }\n\n  char line[512];\n  size_t i = 0;\n  while (i < kj::size(lines) && fgets(line, sizeof(line), p) != nullptr) {\n    // Don't include exception-handling infrastructure in stack trace.\n    // addr2line output matches file names; atos output matches symbol names.\n    if (i == 0 &&\n        (strstr(line, \"kj/common.c++\") != nullptr ||\n         strstr(line, \"kj/exception.\") != nullptr ||\n         strstr(line, \"kj/debug.\") != nullptr ||\n         strstr(line, \"kj::Exception\") != nullptr ||\n         strstr(line, \"kj::_::Debug\") != nullptr)) {\n      continue;\n    }\n\n    size_t len = strlen(line);\n    if (len > 0 && line[len-1] == '\\n') line[len-1] = '\\0';\n    lines[i++] = str(\"\\n\", line, \": called here\");\n  }\n\n  // Skip remaining input.\n  while (fgets(line, sizeof(line), p) != nullptr) {}\n\n  pclose(p);\n\n  return strArray(arrayPtr(lines, i), \"\");\n#else\n  return nullptr;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strArray",
          "args": [
            "trace",
            "\" \""
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "kj::repeat('_', contextDepth)",
            "file",
            "':'",
            "line",
            "\": \"",
            "kj::mv(text)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "text"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::repeat",
          "args": [
            "'_'",
            "contextDepth"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "repeat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "703-708",
          "snippet": "inline constexpr Repeat<Decay<T>> repeat(T&& value, size_t count) {\n  // Returns a fake iterable which contains `count` repeats of `value`.  Useful for e.g. creating\n  // a bunch of spaces:  `kj::repeat(' ', indent * 2)`\n\n  return Repeat<Decay<T>>(value, count);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Repeat<Decay<T>> repeat(T&& value, size_t count) {\n  // Returns a fake iterable which contains `count` repeats of `value`.  Useful for e.g. creating\n  // a bunch of spaces:  `kj::repeat(' ', indent * 2)`\n\n  return Repeat<Decay<T>>(value, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "\"expectation failed\""
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.size",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getStackTrace",
          "args": [
            "traceSpace"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "getStackTrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "55-61",
          "snippet": "ArrayPtr<void* const> getStackTrace(ArrayPtr<void*> space) {\n#ifndef KJ_HAS_BACKTRACE\n  return nullptr;\n#else\n  return space.slice(0, backtrace(space.begin(), space.size()));\n#endif\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [
            "#define KJ_HAS_BACKTRACE 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\n#define KJ_HAS_BACKTRACE 1\n\nArrayPtr<void* const> getStackTrace(ArrayPtr<void*> space) {\n#ifndef KJ_HAS_BACKTRACE\n  return nullptr;\n#else\n  return space.slice(0, backtrace(space.begin(), space.size()));\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestExceptionCallback {\n  void logMessage(LogSeverity severity, const char* file, int line, int contextDepth,\n                    String&& text) override {\n      void* traceSpace[32];\n      auto trace = getStackTrace(traceSpace);\n  \n      if (text.size() == 0) {\n        text = kj::heapString(\"expectation failed\");\n      }\n  \n      text = kj::str(kj::repeat('_', contextDepth), file, ':', line, \": \", kj::mv(text));\n  \n      if (severity == LogSeverity::ERROR || severity == LogSeverity::FATAL) {\n        sawError = true;\n        context.error(kj::str(text, \"\\nstack: \", strArray(trace, \" \"), stringifyStackTrace(trace)));\n      } else {\n        context.warning(text);\n      }\n    }\n}"
  },
  {
    "function_name": "failed",
    "container": "TestExceptionCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "250-250",
    "snippet": "bool failed() { return sawError; }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestExceptionCallback {\n  bool failed() { return sawError; }\n}"
  },
  {
    "function_name": "TestExceptionCallback",
    "container": "TestExceptionCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "248-248",
    "snippet": "TestExceptionCallback(ProcessContext& context): context(context) {}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestExceptionCallback {\n  TestExceptionCallback(ProcessContext& context): context(context) {}\n}"
  },
  {
    "function_name": "registerCrashHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "201-238",
    "snippet": "void registerCrashHandler() {\n  // Set up alternate signal stack so that stack overflows can be handled.\n  stack_t stack;\n  memset(&stack, 0, sizeof(stack));\n\n#ifndef MAP_ANONYMOUS\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n#ifndef MAP_GROWSDOWN\n#define MAP_GROWSDOWN 0\n#endif\n\n  stack.ss_size = 65536;\n  // Note: ss_sp is char* on FreeBSD, void* on Linux and OSX.\n  stack.ss_sp = reinterpret_cast<char*>(mmap(\n      nullptr, stack.ss_size, PROT_READ | PROT_WRITE,\n      MAP_ANONYMOUS | MAP_PRIVATE | MAP_GROWSDOWN, -1, 0));\n  KJ_SYSCALL(sigaltstack(&stack, nullptr));\n\n  // Catch all relevant signals.\n  struct sigaction action;\n  memset(&action, 0, sizeof(action));\n\n  action.sa_flags = SA_SIGINFO | SA_ONSTACK | SA_NODEFER | SA_RESETHAND;\n  action.sa_sigaction = &crashHandler;\n\n  // Dump stack on common \"crash\" signals.\n  KJ_SYSCALL(sigaction(SIGSEGV, &action, nullptr));\n  KJ_SYSCALL(sigaction(SIGBUS, &action, nullptr));\n  KJ_SYSCALL(sigaction(SIGFPE, &action, nullptr));\n  KJ_SYSCALL(sigaction(SIGABRT, &action, nullptr));\n\n  // Dump stack on unimplemented syscalls -- useful in seccomp sandboxes.\n  KJ_SYSCALL(sigaction(SIGSYS, &action, nullptr));\n\n  // Dump stack on keyboard interrupt -- useful for infinite loops.\n  KJ_SYSCALL(sigaction(SIGINT, &action, nullptr));\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [
      "#define MAP_GROWSDOWN 0",
      "#define MAP_ANONYMOUS MAP_ANON"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigaction(SIGINT, &action, nullptr)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGINT",
            "&action",
            "nullptr"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigaction(SIGSYS, &action, nullptr)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGSYS",
            "&action",
            "nullptr"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigaction(SIGABRT, &action, nullptr)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGABRT",
            "&action",
            "nullptr"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigaction(SIGFPE, &action, nullptr)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGFPE",
            "&action",
            "nullptr"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigaction(SIGBUS, &action, nullptr)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGBUS",
            "&action",
            "nullptr"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigaction(SIGSEGV, &action, nullptr)"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGSEGV",
            "&action",
            "nullptr"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&action",
            "0",
            "sizeof(action)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigaltstack(&stack, nullptr)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaltstack",
          "args": [
            "&stack",
            "nullptr"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<char*>",
          "args": [
            "mmap(\n      nullptr, stack.ss_size, PROT_READ | PROT_WRITE,\n      MAP_ANONYMOUS | MAP_PRIVATE | MAP_GROWSDOWN, -1, 0)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap",
          "args": [
            "nullptr",
            "stack.ss_size",
            "PROT_READ | PROT_WRITE",
            "MAP_ANONYMOUS | MAP_PRIVATE | MAP_GROWSDOWN",
            "-1",
            "0"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&stack",
            "0",
            "sizeof(stack)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\n#define MAP_GROWSDOWN 0\n#define MAP_ANONYMOUS MAP_ANON\n\nvoid registerCrashHandler() {\n  // Set up alternate signal stack so that stack overflows can be handled.\n  stack_t stack;\n  memset(&stack, 0, sizeof(stack));\n\n#ifndef MAP_ANONYMOUS\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n#ifndef MAP_GROWSDOWN\n#define MAP_GROWSDOWN 0\n#endif\n\n  stack.ss_size = 65536;\n  // Note: ss_sp is char* on FreeBSD, void* on Linux and OSX.\n  stack.ss_sp = reinterpret_cast<char*>(mmap(\n      nullptr, stack.ss_size, PROT_READ | PROT_WRITE,\n      MAP_ANONYMOUS | MAP_PRIVATE | MAP_GROWSDOWN, -1, 0));\n  KJ_SYSCALL(sigaltstack(&stack, nullptr));\n\n  // Catch all relevant signals.\n  struct sigaction action;\n  memset(&action, 0, sizeof(action));\n\n  action.sa_flags = SA_SIGINFO | SA_ONSTACK | SA_NODEFER | SA_RESETHAND;\n  action.sa_sigaction = &crashHandler;\n\n  // Dump stack on common \"crash\" signals.\n  KJ_SYSCALL(sigaction(SIGSEGV, &action, nullptr));\n  KJ_SYSCALL(sigaction(SIGBUS, &action, nullptr));\n  KJ_SYSCALL(sigaction(SIGFPE, &action, nullptr));\n  KJ_SYSCALL(sigaction(SIGABRT, &action, nullptr));\n\n  // Dump stack on unimplemented syscalls -- useful in seccomp sandboxes.\n  KJ_SYSCALL(sigaction(SIGSYS, &action, nullptr));\n\n  // Dump stack on keyboard interrupt -- useful for infinite loops.\n  KJ_SYSCALL(sigaction(SIGINT, &action, nullptr));\n}"
  },
  {
    "function_name": "crashHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "184-199",
    "snippet": "void crashHandler(int signo, siginfo_t* info, void* context) {\n  void* traceSpace[32];\n  auto trace = getStackTrace(traceSpace);\n\n  if (trace.size() >= 3) {\n    // Remove getStackTrace(), crashHandler() and signal trampoline from trace.\n    trace = trace.slice(3, trace.size());\n  }\n\n  auto message = kj::str(\"*** Received signal #\", signo, \": \", strsignal(signo),\n                         \"\\nstack: \", strArray(trace, \" \"),\n                         stringifyStackTrace(trace), '\\n');\n\n  FdOutputStream(STDERR_FILENO).write(message.begin(), message.size());\n  _exit(1);\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FdOutputStream",
          "args": [
            "message.begin()",
            "message.size()"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.size",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "message.begin",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FdOutputStream",
          "args": [
            "STDERR_FILENO"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "FdOutputStream",
          "container": "FdOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.h",
          "lines": "298-298",
          "snippet": "explicit FdOutputStream(AutoCloseFd fd): fd(fd), autoclose(mv(fd)) {}",
          "includes": [
            "#include \"exception.h\"",
            "#include \"array.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exception.h\"\n#include \"array.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nFdOutputStream {\n  explicit FdOutputStream(AutoCloseFd fd): fd(fd), autoclose(mv(fd)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"*** Received signal #\"",
            "signo",
            "\": \"",
            "strsignal(signo)",
            "\"\\nstack: \"",
            "strArray(trace, \" \")",
            "stringifyStackTrace(trace)",
            "'\\n'"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringifyStackTrace",
          "args": [
            "trace"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "stringifyStackTrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "63-140",
          "snippet": "String stringifyStackTrace(ArrayPtr<void* const> trace) {\n#if (__linux__ || __APPLE__) && !__ANDROID__ && defined(KJ_DEBUG)\n  // We want to generate a human-readable stack trace.\n\n  // TODO(someday):  It would be really great if we could avoid farming out to another process\n  //   and do this all in-process, but that may involve onerous requirements like large library\n  //   dependencies or using -rdynamic.\n\n  // The environment manipulation is not thread-safe, so lock a mutex.  This could still be\n  // problematic if another thread is manipulating the environment in unrelated code, but there's\n  // not much we can do about that.  This is debug-only anyway and only an issue when LD_PRELOAD\n  // is in use.\n  static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n  pthread_mutex_lock(&mutex);\n  KJ_DEFER(pthread_mutex_unlock(&mutex));\n\n  // Don't heapcheck / intercept syscalls.\n  const char* preload = getenv(\"LD_PRELOAD\");\n  String oldPreload;\n  if (preload != nullptr) {\n    oldPreload = heapString(preload);\n    unsetenv(\"LD_PRELOAD\");\n  }\n  KJ_DEFER(if (oldPreload != nullptr) { setenv(\"LD_PRELOAD\", oldPreload.cStr(), true); });\n\n  String lines[8];\n  FILE* p = nullptr;\n\n#if __linux__\n  // Get executable name from /proc/self/exe, then pass it and the stack trace to addr2line to\n  // get file/line pairs.\n  char exe[512];\n  ssize_t n = readlink(\"/proc/self/exe\", exe, sizeof(exe));\n  if (n < 0 || n >= static_cast<ssize_t>(sizeof(exe))) {\n    return nullptr;\n  }\n  exe[n] = '\\0';\n\n  p = popen(str(\"addr2line -e \", exe, ' ', strArray(trace, \" \")).cStr(), \"r\");\n#elif __APPLE__\n  // The Mac OS X equivalent of addr2line is atos.\n  // (Internally, it uses the private CoreSymbolication.framework library.)\n  p = popen(str(\"xcrun atos -p \", getpid(), ' ', strArray(trace, \" \")).cStr(), \"r\");\n#endif\n\n  if (p == nullptr) {\n    return nullptr;\n  }\n\n  char line[512];\n  size_t i = 0;\n  while (i < kj::size(lines) && fgets(line, sizeof(line), p) != nullptr) {\n    // Don't include exception-handling infrastructure in stack trace.\n    // addr2line output matches file names; atos output matches symbol names.\n    if (i == 0 &&\n        (strstr(line, \"kj/common.c++\") != nullptr ||\n         strstr(line, \"kj/exception.\") != nullptr ||\n         strstr(line, \"kj/debug.\") != nullptr ||\n         strstr(line, \"kj::Exception\") != nullptr ||\n         strstr(line, \"kj::_::Debug\") != nullptr)) {\n      continue;\n    }\n\n    size_t len = strlen(line);\n    if (len > 0 && line[len-1] == '\\n') line[len-1] = '\\0';\n    lines[i++] = str(\"\\n\", line, \": called here\");\n  }\n\n  // Skip remaining input.\n  while (fgets(line, sizeof(line), p) != nullptr) {}\n\n  pclose(p);\n\n  return strArray(arrayPtr(lines, i), \"\");\n#else\n  return nullptr;\n#endif\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nString stringifyStackTrace(ArrayPtr<void* const> trace) {\n#if (__linux__ || __APPLE__) && !__ANDROID__ && defined(KJ_DEBUG)\n  // We want to generate a human-readable stack trace.\n\n  // TODO(someday):  It would be really great if we could avoid farming out to another process\n  //   and do this all in-process, but that may involve onerous requirements like large library\n  //   dependencies or using -rdynamic.\n\n  // The environment manipulation is not thread-safe, so lock a mutex.  This could still be\n  // problematic if another thread is manipulating the environment in unrelated code, but there's\n  // not much we can do about that.  This is debug-only anyway and only an issue when LD_PRELOAD\n  // is in use.\n  static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n  pthread_mutex_lock(&mutex);\n  KJ_DEFER(pthread_mutex_unlock(&mutex));\n\n  // Don't heapcheck / intercept syscalls.\n  const char* preload = getenv(\"LD_PRELOAD\");\n  String oldPreload;\n  if (preload != nullptr) {\n    oldPreload = heapString(preload);\n    unsetenv(\"LD_PRELOAD\");\n  }\n  KJ_DEFER(if (oldPreload != nullptr) { setenv(\"LD_PRELOAD\", oldPreload.cStr(), true); });\n\n  String lines[8];\n  FILE* p = nullptr;\n\n#if __linux__\n  // Get executable name from /proc/self/exe, then pass it and the stack trace to addr2line to\n  // get file/line pairs.\n  char exe[512];\n  ssize_t n = readlink(\"/proc/self/exe\", exe, sizeof(exe));\n  if (n < 0 || n >= static_cast<ssize_t>(sizeof(exe))) {\n    return nullptr;\n  }\n  exe[n] = '\\0';\n\n  p = popen(str(\"addr2line -e \", exe, ' ', strArray(trace, \" \")).cStr(), \"r\");\n#elif __APPLE__\n  // The Mac OS X equivalent of addr2line is atos.\n  // (Internally, it uses the private CoreSymbolication.framework library.)\n  p = popen(str(\"xcrun atos -p \", getpid(), ' ', strArray(trace, \" \")).cStr(), \"r\");\n#endif\n\n  if (p == nullptr) {\n    return nullptr;\n  }\n\n  char line[512];\n  size_t i = 0;\n  while (i < kj::size(lines) && fgets(line, sizeof(line), p) != nullptr) {\n    // Don't include exception-handling infrastructure in stack trace.\n    // addr2line output matches file names; atos output matches symbol names.\n    if (i == 0 &&\n        (strstr(line, \"kj/common.c++\") != nullptr ||\n         strstr(line, \"kj/exception.\") != nullptr ||\n         strstr(line, \"kj/debug.\") != nullptr ||\n         strstr(line, \"kj::Exception\") != nullptr ||\n         strstr(line, \"kj::_::Debug\") != nullptr)) {\n      continue;\n    }\n\n    size_t len = strlen(line);\n    if (len > 0 && line[len-1] == '\\n') line[len-1] = '\\0';\n    lines[i++] = str(\"\\n\", line, \": called here\");\n  }\n\n  // Skip remaining input.\n  while (fgets(line, sizeof(line), p) != nullptr) {}\n\n  pclose(p);\n\n  return strArray(arrayPtr(lines, i), \"\");\n#else\n  return nullptr;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strArray",
          "args": [
            "trace",
            "\" \""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsignal",
          "args": [
            "signo"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace.slice",
          "args": [
            "3",
            "trace.size()"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getStackTrace",
          "args": [
            "traceSpace"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "getStackTrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "55-61",
          "snippet": "ArrayPtr<void* const> getStackTrace(ArrayPtr<void*> space) {\n#ifndef KJ_HAS_BACKTRACE\n  return nullptr;\n#else\n  return space.slice(0, backtrace(space.begin(), space.size()));\n#endif\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [
            "#define KJ_HAS_BACKTRACE 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\n#define KJ_HAS_BACKTRACE 1\n\nArrayPtr<void* const> getStackTrace(ArrayPtr<void*> space) {\n#ifndef KJ_HAS_BACKTRACE\n  return nullptr;\n#else\n  return space.slice(0, backtrace(space.begin(), space.size()));\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nvoid crashHandler(int signo, siginfo_t* info, void* context) {\n  void* traceSpace[32];\n  auto trace = getStackTrace(traceSpace);\n\n  if (trace.size() >= 3) {\n    // Remove getStackTrace(), crashHandler() and signal trampoline from trace.\n    trace = trace.slice(3, trace.size());\n  }\n\n  auto message = kj::str(\"*** Received signal #\", signo, \": \", strsignal(signo),\n                         \"\\nstack: \", strArray(trace, \" \"),\n                         stringifyStackTrace(trace), '\\n');\n\n  FdOutputStream(STDERR_FILENO).write(message.begin(), message.size());\n  _exit(1);\n}"
  },
  {
    "function_name": "GlobFilter::applyState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "150-176",
    "snippet": "void GlobFilter::applyState(char c, int state) {\n  if (state < pattern.size()) {\n    switch (pattern[state]) {\n      case '*':\n        // At a '*', we both re-add the current state and attempt to match the *next* state.\n        if (c != '/' && c != '\\\\') {  // '*' doesn't match '/'.\n          states.add(state);\n        }\n        applyState(c, state + 1);\n        break;\n\n      case '?':\n        // A '?' matches one character (never a '/').\n        if (c != '/' && c != '\\\\') {\n          states.add(state + 1);\n        }\n        break;\n\n      default:\n        // Any other character matches only itself.\n        if (c == pattern[state]) {\n          states.add(state + 1);\n        }\n        break;\n    }\n  }\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "states.add",
          "args": [
            "state + 1"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pattern.size",
          "args": [],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nvoid GlobFilter::applyState(char c, int state) {\n  if (state < pattern.size()) {\n    switch (pattern[state]) {\n      case '*':\n        // At a '*', we both re-add the current state and attempt to match the *next* state.\n        if (c != '/' && c != '\\\\') {  // '*' doesn't match '/'.\n          states.add(state);\n        }\n        applyState(c, state + 1);\n        break;\n\n      case '?':\n        // A '?' matches one character (never a '/').\n        if (c != '/' && c != '\\\\') {\n          states.add(state + 1);\n        }\n        break;\n\n      default:\n        // Any other character matches only itself.\n        if (c == pattern[state]) {\n          states.add(state + 1);\n        }\n        break;\n    }\n  }\n}"
  },
  {
    "function_name": "GlobFilter::matches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "98-148",
    "snippet": "bool GlobFilter::matches(StringPtr name) {\n  // Get out your computer science books. We're implementing a non-deterministic finite automaton.\n  //\n  // Our NDFA has one \"state\" corresponding to each character in the pattern.\n  //\n  // As you may recall, an NDFA can be transformed into a DFA where every state in the DFA\n  // represents some combination of states in the NDFA. Therefore, we actually have to store a\n  // list of states here. (Actually, what we really want is a set of states, but because our\n  // patterns are mostly non-cyclic a list of states should work fine and be a bit more efficient.)\n\n  // Our state list starts out pointing only at the start of the pattern.\n  states.resize(0);\n  states.add(0);\n\n  Vector<uint> scratch;\n\n  // Iterate through each character in the name.\n  for (char c: name) {\n    // Pull the current set of states off to the side, so that we can populate `states` with the\n    // new set of states.\n    Vector<uint> oldStates = kj::mv(states);\n    states = kj::mv(scratch);\n    states.resize(0);\n\n    // The pattern can omit a leading path. So if we're at a '/' then enter the state machine at\n    // the beginning on the next char.\n    if (c == '/' || c == '\\\\') {\n      states.add(0);\n    }\n\n    // Process each state.\n    for (uint state: oldStates) {\n      applyState(c, state);\n    }\n\n    // Store the previous state vector for reuse.\n    scratch = kj::mv(oldStates);\n  }\n\n  // If any one state is at the end of the pattern (or at a wildcard just before the end of the\n  // pattern), we have a match.\n  for (uint state: states) {\n    while (state < pattern.size() && pattern[state] == '*') {\n      ++state;\n    }\n    if (state == pattern.size()) {\n      return true;\n    }\n  }\n  return false;\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pattern.size",
          "args": [],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "oldStates"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "applyState",
          "args": [
            "c",
            "state"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "GlobFilter::applyState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "150-176",
          "snippet": "void GlobFilter::applyState(char c, int state) {\n  if (state < pattern.size()) {\n    switch (pattern[state]) {\n      case '*':\n        // At a '*', we both re-add the current state and attempt to match the *next* state.\n        if (c != '/' && c != '\\\\') {  // '*' doesn't match '/'.\n          states.add(state);\n        }\n        applyState(c, state + 1);\n        break;\n\n      case '?':\n        // A '?' matches one character (never a '/').\n        if (c != '/' && c != '\\\\') {\n          states.add(state + 1);\n        }\n        break;\n\n      default:\n        // Any other character matches only itself.\n        if (c == pattern[state]) {\n          states.add(state + 1);\n        }\n        break;\n    }\n  }\n}",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nvoid GlobFilter::applyState(char c, int state) {\n  if (state < pattern.size()) {\n    switch (pattern[state]) {\n      case '*':\n        // At a '*', we both re-add the current state and attempt to match the *next* state.\n        if (c != '/' && c != '\\\\') {  // '*' doesn't match '/'.\n          states.add(state);\n        }\n        applyState(c, state + 1);\n        break;\n\n      case '?':\n        // A '?' matches one character (never a '/').\n        if (c != '/' && c != '\\\\') {\n          states.add(state + 1);\n        }\n        break;\n\n      default:\n        // Any other character matches only itself.\n        if (c == pattern[state]) {\n          states.add(state + 1);\n        }\n        break;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "states.add",
          "args": [
            "0"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "states.resize",
          "args": [
            "0"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "96-104",
          "snippet": "inline void resize(size_t size) {\n    if (size > builder.capacity()) grow(size);\n    while (builder.size() < size) {\n      builder.add(T());\n    }\n    while (builder.size() > size) {\n      builder.removeLast();\n    }\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline void resize(size_t size) {\n      if (size > builder.capacity()) grow(size);\n      while (builder.size() < size) {\n        builder.add(T());\n      }\n      while (builder.size() > size) {\n        builder.removeLast();\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "scratch"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "states"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nbool GlobFilter::matches(StringPtr name) {\n  // Get out your computer science books. We're implementing a non-deterministic finite automaton.\n  //\n  // Our NDFA has one \"state\" corresponding to each character in the pattern.\n  //\n  // As you may recall, an NDFA can be transformed into a DFA where every state in the DFA\n  // represents some combination of states in the NDFA. Therefore, we actually have to store a\n  // list of states here. (Actually, what we really want is a set of states, but because our\n  // patterns are mostly non-cyclic a list of states should work fine and be a bit more efficient.)\n\n  // Our state list starts out pointing only at the start of the pattern.\n  states.resize(0);\n  states.add(0);\n\n  Vector<uint> scratch;\n\n  // Iterate through each character in the name.\n  for (char c: name) {\n    // Pull the current set of states off to the side, so that we can populate `states` with the\n    // new set of states.\n    Vector<uint> oldStates = kj::mv(states);\n    states = kj::mv(scratch);\n    states.resize(0);\n\n    // The pattern can omit a leading path. So if we're at a '/' then enter the state machine at\n    // the beginning on the next char.\n    if (c == '/' || c == '\\\\') {\n      states.add(0);\n    }\n\n    // Process each state.\n    for (uint state: oldStates) {\n      applyState(c, state);\n    }\n\n    // Store the previous state vector for reuse.\n    scratch = kj::mv(oldStates);\n  }\n\n  // If any one state is at the end of the pattern (or at a wildcard just before the end of the\n  // pattern), we have a match.\n  for (uint state: states) {\n    while (state < pattern.size() && pattern[state] == '*') {\n      ++state;\n    }\n    if (state == pattern.size()) {\n      return true;\n    }\n  }\n  return false;\n}"
  },
  {
    "function_name": "GlobFilter::GlobFilter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "96-96",
    "snippet": "GlobFilter::GlobFilter(ArrayPtr<const char> pattern): pattern(heapString(pattern)) {}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heapString",
          "args": [
            "pattern"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nGlobFilter::GlobFilter(ArrayPtr<const char> pattern): pattern(heapString(pattern)) {}"
  },
  {
    "function_name": "GlobFilter::GlobFilter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "95-95",
    "snippet": "GlobFilter::GlobFilter(const char* pattern): pattern(heapString(pattern)) {}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heapString",
          "args": [
            "pattern"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nGlobFilter::GlobFilter(const char* pattern): pattern(heapString(pattern)) {}"
  },
  {
    "function_name": "LogExpectation::logMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "78-91",
    "snippet": "void LogExpectation::logMessage(\n    LogSeverity severity, const char* file, int line, int contextDepth,\n    String&& text) {\n  if (!seen && severity == this->severity) {\n    if (hasSubstring(text, substring)) {\n      // Match. Ignore it.\n      seen = true;\n      return;\n    }\n  }\n\n  // Pass up the chain.\n  ExceptionCallback::logMessage(severity, file, line, contextDepth, kj::mv(text));\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ExceptionCallback::logMessage",
          "args": [
            "severity",
            "file",
            "line",
            "contextDepth",
            "kj::mv(text)"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "logMessage",
          "container": "TestExceptionCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "252-269",
          "snippet": "void logMessage(LogSeverity severity, const char* file, int line, int contextDepth,\n                  String&& text) override {\n    void* traceSpace[32];\n    auto trace = getStackTrace(traceSpace);\n\n    if (text.size() == 0) {\n      text = kj::heapString(\"expectation failed\");\n    }\n\n    text = kj::str(kj::repeat('_', contextDepth), file, ':', line, \": \", kj::mv(text));\n\n    if (severity == LogSeverity::ERROR || severity == LogSeverity::FATAL) {\n      sawError = true;\n      context.error(kj::str(text, \"\\nstack: \", strArray(trace, \" \"), stringifyStackTrace(trace)));\n    } else {\n      context.warning(text);\n    }\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestExceptionCallback {\n  void logMessage(LogSeverity severity, const char* file, int line, int contextDepth,\n                    String&& text) override {\n      void* traceSpace[32];\n      auto trace = getStackTrace(traceSpace);\n  \n      if (text.size() == 0) {\n        text = kj::heapString(\"expectation failed\");\n      }\n  \n      text = kj::str(kj::repeat('_', contextDepth), file, ':', line, \": \", kj::mv(text));\n  \n      if (severity == LogSeverity::ERROR || severity == LogSeverity::FATAL) {\n        sawError = true;\n        context.error(kj::str(text, \"\\nstack: \", strArray(trace, \" \"), stringifyStackTrace(trace)));\n      } else {\n        context.warning(text);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "text"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hasSubstring",
          "args": [
            "text",
            "substring"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "hasSubstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "60-68",
          "snippet": "bool hasSubstring(kj::StringPtr haystack, kj::StringPtr needle) {\n  // TODO(perf): This is not the best algorithm for substring matching.\n  for (size_t i = 0; i <= haystack.size() - needle.size(); i++) {\n    if (haystack.slice(i).startsWith(needle)) {\n      return true;\n    }\n  }\n  return false;\n}",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nbool hasSubstring(kj::StringPtr haystack, kj::StringPtr needle) {\n  // TODO(perf): This is not the best algorithm for substring matching.\n  for (size_t i = 0; i <= haystack.size() - needle.size(); i++) {\n    if (haystack.slice(i).startsWith(needle)) {\n      return true;\n    }\n  }\n  return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nvoid LogExpectation::logMessage(\n    LogSeverity severity, const char* file, int line, int contextDepth,\n    String&& text) {\n  if (!seen && severity == this->severity) {\n    if (hasSubstring(text, substring)) {\n      // Match. Ignore it.\n      seen = true;\n      return;\n    }\n  }\n\n  // Pass up the chain.\n  ExceptionCallback::logMessage(severity, file, line, contextDepth, kj::mv(text));\n}"
  },
  {
    "function_name": "LogExpectation::~LogExpectation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "72-76",
    "snippet": "LogExpectation::~LogExpectation() {\n  if (!unwindDetector.isUnwinding()) {\n    KJ_ASSERT(seen, \"expected log message not seen\", severity, substring);\n  }\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "seen",
            "\"expected log message not seen\"",
            "severity",
            "substring"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unwindDetector.isUnwinding",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nLogExpectation::~LogExpectation() {\n  if (!unwindDetector.isUnwinding()) {\n    KJ_ASSERT(seen, \"expected log message not seen\", severity, substring);\n  }\n}"
  },
  {
    "function_name": "LogExpectation::LogExpectation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "70-71",
    "snippet": "LogExpectation::LogExpectation(LogSeverity severity, StringPtr substring)\n    : severity(severity), substring(substring), seen(false) {}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nLogExpectation::LogExpectation(LogSeverity severity, StringPtr substring)\n    : severity(severity), substring(substring), seen(false) {}"
  },
  {
    "function_name": "hasSubstring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "60-68",
    "snippet": "bool hasSubstring(kj::StringPtr haystack, kj::StringPtr needle) {\n  // TODO(perf): This is not the best algorithm for substring matching.\n  for (size_t i = 0; i <= haystack.size() - needle.size(); i++) {\n    if (haystack.slice(i).startsWith(needle)) {\n      return true;\n    }\n  }\n  return false;\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "haystack.slice",
          "args": [
            "needle"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "177-177",
          "snippet": "inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "needle.size",
          "args": [],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nbool hasSubstring(kj::StringPtr haystack, kj::StringPtr needle) {\n  // TODO(perf): This is not the best algorithm for substring matching.\n  for (size_t i = 0; i <= haystack.size() - needle.size(); i++) {\n    if (haystack.slice(i).startsWith(needle)) {\n      return true;\n    }\n  }\n  return false;\n}"
  },
  {
    "function_name": "TestCase::~TestCase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "47-54",
    "snippet": "TestCase::~TestCase() {\n  *prev = next;\n  if (next == nullptr) {\n    testCasesTail = prev;\n  } else {\n    next->prev = prev;\n  }\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestCase::~TestCase() {\n  *prev = next;\n  if (next == nullptr) {\n    testCasesTail = prev;\n  } else {\n    next->prev = prev;\n  }\n}"
  },
  {
    "function_name": "TestCase::TestCase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
    "lines": "40-45",
    "snippet": "TestCase::TestCase(const char* file, uint line, const char* description)\n    : file(file), line(line), description(description), next(nullptr), prev(testCasesTail),\n      matchedFilter(false) {\n  *prev = this;\n  testCasesTail = &next;\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <string.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"io.h\"",
      "#include \"main.h\"",
      "#include \"test.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestCase::TestCase(const char* file, uint line, const char* description)\n    : file(file), line(line), description(description), next(nullptr), prev(testCasesTail),\n      matchedFilter(false) {\n  *prev = this;\n  testCasesTail = &next;\n}"
  }
]