[
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "674-714",
    "snippet": "TEST(Async, SetRunnable) {\n  DummyEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  EXPECT_FALSE(port.runnable);\n  EXPECT_EQ(0, port.callCount);\n\n  {\n    auto promise = evalLater([]() {}).eagerlyEvaluate(nullptr);\n\n    EXPECT_TRUE(port.runnable);\n    loop.run(1);\n    EXPECT_FALSE(port.runnable);\n    EXPECT_EQ(2, port.callCount);\n\n    promise.wait(waitScope);\n    EXPECT_FALSE(port.runnable);\n    EXPECT_EQ(4, port.callCount);\n  }\n\n  {\n    auto paf = newPromiseAndFulfiller<void>();\n    auto promise = paf.promise.then([]() {}).eagerlyEvaluate(nullptr);\n    EXPECT_FALSE(port.runnable);\n\n    auto promise2 = evalLater([]() {}).eagerlyEvaluate(nullptr);\n    paf.fulfiller->fulfill();\n\n    EXPECT_TRUE(port.runnable);\n    loop.run(1);\n    EXPECT_TRUE(port.runnable);\n    loop.run(10);\n    EXPECT_FALSE(port.runnable);\n\n    promise.wait(waitScope);\n    EXPECT_FALSE(port.runnable);\n\n    EXPECT_EQ(8, port.callCount);\n  }\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "8",
            "port.callCount"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "port.runnable"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "port.runnable"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loop.run",
          "args": [
            "10"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": "TestRunner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "353-408",
          "snippet": "MainBuilder::Validity run() {\n    if (testCasesHead == nullptr) {\n      return \"no tests were declared\";\n    }\n\n    // Find the common path prefix of all filenames, so we can strip it off.\n    ArrayPtr<const char> commonPrefix = StringPtr(testCasesHead->file);\n    for (TestCase* testCase = testCasesHead; testCase != nullptr; testCase = testCase->next) {\n      for (size_t i: kj::indices(commonPrefix)) {\n        if (testCase->file[i] != commonPrefix[i]) {\n          commonPrefix = commonPrefix.slice(0, i);\n          break;\n        }\n      }\n    }\n\n    // Back off the prefix to the last '/'.\n    while (commonPrefix.size() > 0 && commonPrefix.back() != '/' && commonPrefix.back() != '\\\\') {\n      commonPrefix = commonPrefix.slice(0, commonPrefix.size() - 1);\n    }\n\n    // Run the testts.\n    uint passCount = 0;\n    uint failCount = 0;\n    for (TestCase* testCase = testCasesHead; testCase != nullptr; testCase = testCase->next) {\n      if (!hasFilter || testCase->matchedFilter) {\n        auto name = kj::str(testCase->file + commonPrefix.size(), ':', testCase->line,\n                            \": \", testCase->description);\n\n        write(BLUE, \"[ TEST ]\", name);\n\n        if (!listOnly) {\n          bool currentFailed = true;\n          KJ_IF_MAYBE(exception, runCatchingExceptions([&]() {\n            TestExceptionCallback exceptionCallback(context);\n            testCase->run();\n            currentFailed = exceptionCallback.failed();\n          })) {\n            context.error(kj::str(*exception));\n          }\n\n          if (currentFailed) {\n            write(RED, \"[ FAIL ]\", name);\n            ++failCount;\n          } else {\n            write(GREEN, \"[ PASS ]\", name);\n            ++passCount;\n          }\n        }\n      }\n    }\n\n    if (passCount > 0) write(GREEN, kj::str(passCount, \" test(s) passed\"), \"\");\n    if (failCount > 0) write(RED, kj::str(failCount, \" test(s) failed\"), \"\");\n    context.exit();\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  MainBuilder::Validity run() {\n      if (testCasesHead == nullptr) {\n        return \"no tests were declared\";\n      }\n  \n      // Find the common path prefix of all filenames, so we can strip it off.\n      ArrayPtr<const char> commonPrefix = StringPtr(testCasesHead->file);\n      for (TestCase* testCase = testCasesHead; testCase != nullptr; testCase = testCase->next) {\n        for (size_t i: kj::indices(commonPrefix)) {\n          if (testCase->file[i] != commonPrefix[i]) {\n            commonPrefix = commonPrefix.slice(0, i);\n            break;\n          }\n        }\n      }\n  \n      // Back off the prefix to the last '/'.\n      while (commonPrefix.size() > 0 && commonPrefix.back() != '/' && commonPrefix.back() != '\\\\') {\n        commonPrefix = commonPrefix.slice(0, commonPrefix.size() - 1);\n      }\n  \n      // Run the testts.\n      uint passCount = 0;\n      uint failCount = 0;\n      for (TestCase* testCase = testCasesHead; testCase != nullptr; testCase = testCase->next) {\n        if (!hasFilter || testCase->matchedFilter) {\n          auto name = kj::str(testCase->file + commonPrefix.size(), ':', testCase->line,\n                              \": \", testCase->description);\n  \n          write(BLUE, \"[ TEST ]\", name);\n  \n          if (!listOnly) {\n            bool currentFailed = true;\n            KJ_IF_MAYBE(exception, runCatchingExceptions([&]() {\n              TestExceptionCallback exceptionCallback(context);\n              testCase->run();\n              currentFailed = exceptionCallback.failed();\n            })) {\n              context.error(kj::str(*exception));\n            }\n  \n            if (currentFailed) {\n              write(RED, \"[ FAIL ]\", name);\n              ++failCount;\n            } else {\n              write(GREEN, \"[ PASS ]\", name);\n              ++passCount;\n            }\n          }\n        }\n      }\n  \n      if (passCount > 0) write(GREEN, kj::str(passCount, \" test(s) passed\"), \"\");\n      if (failCount > 0) write(RED, kj::str(failCount, \" test(s) failed\"), \"\");\n      context.exit();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "port.runnable"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "port.runnable"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.fulfiller->fulfill",
          "args": [],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "fulfill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "68-72",
          "snippet": "void fulfill() {\n    fulfiller.fulfill();\n    port.timers->timers.erase(pos);\n    pos = port.timers->timers.end();\n  }",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid fulfill() {\n    fulfiller.fulfill();\n    port.timers->timers.erase(pos);\n    pos = port.timers->timers.end();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "nullptr"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "port.runnable"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "nullptr"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "[]() {}"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newPromiseAndFulfiller<void>",
          "args": [],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "4",
            "port.callCount"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "port.runnable"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "port.callCount"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "port.runnable"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "port.runnable"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "port.callCount"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "port.runnable"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, SetRunnable) {\n  DummyEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  EXPECT_FALSE(port.runnable);\n  EXPECT_EQ(0, port.callCount);\n\n  {\n    auto promise = evalLater([]() {}).eagerlyEvaluate(nullptr);\n\n    EXPECT_TRUE(port.runnable);\n    loop.run(1);\n    EXPECT_FALSE(port.runnable);\n    EXPECT_EQ(2, port.callCount);\n\n    promise.wait(waitScope);\n    EXPECT_FALSE(port.runnable);\n    EXPECT_EQ(4, port.callCount);\n  }\n\n  {\n    auto paf = newPromiseAndFulfiller<void>();\n    auto promise = paf.promise.then([]() {}).eagerlyEvaluate(nullptr);\n    EXPECT_FALSE(port.runnable);\n\n    auto promise2 = evalLater([]() {}).eagerlyEvaluate(nullptr);\n    paf.fulfiller->fulfill();\n\n    EXPECT_TRUE(port.runnable);\n    loop.run(1);\n    EXPECT_TRUE(port.runnable);\n    loop.run(10);\n    EXPECT_FALSE(port.runnable);\n\n    promise.wait(waitScope);\n    EXPECT_FALSE(port.runnable);\n\n    EXPECT_EQ(8, port.callCount);\n  }\n}"
  },
  {
    "function_name": "setRunnable",
    "container": "DummyEventPort",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "668-671",
    "snippet": "void setRunnable(bool runnable) override {\n    this->runnable = runnable;\n    ++callCount;\n  }",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  void setRunnable(bool runnable) override {\n      this->runnable = runnable;\n      ++callCount;\n    }\n}"
  },
  {
    "function_name": "poll",
    "container": "DummyEventPort",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "667-667",
    "snippet": "bool poll() override { return false; }",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  bool poll() override { return false; }\n}"
  },
  {
    "function_name": "wait",
    "container": "DummyEventPort",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "666-666",
    "snippet": "bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Nothing to wait for.\""
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "638-659",
    "snippet": "TEST(Async, Detach) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  bool ran1 = false;\n  bool ran2 = false;\n  bool ran3 = false;\n\n  evalLater([&]() { ran1 = true; });\n  evalLater([&]() { ran2 = true; }).detach([](kj::Exception&&) { ADD_FAILURE(); });\n  evalLater([]() { KJ_FAIL_ASSERT(\"foo\"){break;} }).detach([&](kj::Exception&& e) { ran3 = true; });\n\n  EXPECT_FALSE(ran1);\n  EXPECT_FALSE(ran2);\n  EXPECT_FALSE(ran3);\n\n  evalLater([]() {}).wait(waitScope);\n\n  EXPECT_FALSE(ran1);\n  EXPECT_TRUE(ran2);\n  EXPECT_TRUE(ran3);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "ran3"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "ran2"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "ran1"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "waitScope"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "ran3"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "ran2"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "ran1"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"foo\""
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADD_FAILURE",
          "args": [],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, Detach) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  bool ran1 = false;\n  bool ran2 = false;\n  bool ran3 = false;\n\n  evalLater([&]() { ran1 = true; });\n  evalLater([&]() { ran2 = true; }).detach([](kj::Exception&&) { ADD_FAILURE(); });\n  evalLater([]() { KJ_FAIL_ASSERT(\"foo\"){break;} }).detach([&](kj::Exception&& e) { ran3 = true; });\n\n  EXPECT_FALSE(ran1);\n  EXPECT_FALSE(ran2);\n  EXPECT_FALSE(ran3);\n\n  evalLater([]() {}).wait(waitScope);\n\n  EXPECT_FALSE(ran1);\n  EXPECT_TRUE(ran2);\n  EXPECT_TRUE(ran3);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "618-636",
    "snippet": "TEST(Async, EagerlyEvaluate) {\n  bool called = false;\n\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<void> promise = Promise<void>(READY_NOW).then([&]() {\n    called = true;\n  });\n  evalLater([]() {}).wait(waitScope);\n\n  EXPECT_FALSE(called);\n\n  promise = promise.eagerlyEvaluate(nullptr);\n\n  evalLater([]() {}).wait(waitScope);\n\n  EXPECT_TRUE(called);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "called"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "waitScope"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "promise.eagerlyEvaluate",
          "args": [
            "nullptr"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "called"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Promise<void>",
          "args": [
            "[&]() {\n    called = true;\n  }"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "Promise<T>::Promise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "671-672",
          "snippet": "Promise<T>::Promise(kj::Exception&& exception)\n    : PromiseBase(heap<_::ImmediateBrokenPromiseNode>(kj::mv(exception))) {}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "Promise<T>::Promise(kj::Exception&& exception)\n    : PromiseBase(heap<_::ImmediateBrokenPromiseNode>(kj::mv(exception))) {}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, EagerlyEvaluate) {\n  bool called = false;\n\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<void> promise = Promise<void>(READY_NOW).then([&]() {\n    called = true;\n  });\n  evalLater([]() {}).wait(waitScope);\n\n  EXPECT_FALSE(called);\n\n  promise = promise.eagerlyEvaluate(nullptr);\n\n  evalLater([]() {}).wait(waitScope);\n\n  EXPECT_TRUE(called);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "597-616",
    "snippet": "TEST(Async, Attach) {\n  bool destroyed = false;\n\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<int> promise = evalLater([&]() {\n    EXPECT_FALSE(destroyed);\n    return 123;\n  }).attach(kj::heap<DestructorDetector>(destroyed));\n\n  promise = promise.then([&](int i) {\n    EXPECT_TRUE(destroyed);\n    return i + 321;\n  });\n\n  EXPECT_FALSE(destroyed);\n  EXPECT_EQ(444, promise.wait(waitScope));\n  EXPECT_TRUE(destroyed);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "destroyed"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "444",
            "promise.wait(waitScope)"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "destroyed"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "[&](int i) {\n    EXPECT_TRUE(destroyed);\n    return i + 321;\n  }"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "destroyed"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "kj::heap<DestructorDetector>(destroyed)"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<DestructorDetector>",
          "args": [
            "destroyed"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "destroyed"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, Attach) {\n  bool destroyed = false;\n\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<int> promise = evalLater([&]() {\n    EXPECT_FALSE(destroyed);\n    return 123;\n  }).attach(kj::heap<DestructorDetector>(destroyed));\n\n  promise = promise.then([&](int i) {\n    EXPECT_TRUE(destroyed);\n    return i + 321;\n  });\n\n  EXPECT_FALSE(destroyed);\n  EXPECT_EQ(444, promise.wait(waitScope));\n  EXPECT_TRUE(destroyed);\n}"
  },
  {
    "function_name": "DestructorDetector",
    "container": "DestructorDetector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "590-590",
    "snippet": "DestructorDetector(bool& setTrue): setTrue(setTrue) {}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDestructorDetector {\n  DestructorDetector(bool& setTrue): setTrue(setTrue) {}\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "557-586",
    "snippet": "TEST(Async, TaskSet) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n  ErrorHandlerImpl errorHandler;\n  TaskSet tasks(errorHandler);\n\n  int counter = 0;\n\n  tasks.add(evalLater([&]() {\n    EXPECT_EQ(0, counter++);\n  }));\n  tasks.add(evalLater([&]() {\n    EXPECT_EQ(1, counter++);\n    KJ_FAIL_ASSERT(\"example TaskSet failure\") { break; }\n  }));\n  tasks.add(evalLater([&]() {\n    EXPECT_EQ(2, counter++);\n  }));\n\n  (void)evalLater([&]() {\n    KJ_FAIL_EXPECT(\"Promise without waiter shouldn't execute.\");\n  });\n\n  evalLater([&]() {\n    EXPECT_EQ(3, counter++);\n  }).wait(waitScope);\n\n  EXPECT_EQ(4, counter);\n  EXPECT_EQ(1u, errorHandler.exceptionCount);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1u",
            "errorHandler.exceptionCount"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "4",
            "counter"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "waitScope"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "counter++"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_EXPECT",
          "args": [
            "\"Promise without waiter shouldn't execute.\""
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "evalLater([&]() {\n    EXPECT_EQ(2, counter++);\n  })"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "counter++"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"example TaskSet failure\""
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "counter++"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "counter++"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, TaskSet) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n  ErrorHandlerImpl errorHandler;\n  TaskSet tasks(errorHandler);\n\n  int counter = 0;\n\n  tasks.add(evalLater([&]() {\n    EXPECT_EQ(0, counter++);\n  }));\n  tasks.add(evalLater([&]() {\n    EXPECT_EQ(1, counter++);\n    KJ_FAIL_ASSERT(\"example TaskSet failure\") { break; }\n  }));\n  tasks.add(evalLater([&]() {\n    EXPECT_EQ(2, counter++);\n  }));\n\n  (void)evalLater([&]() {\n    KJ_FAIL_EXPECT(\"Promise without waiter shouldn't execute.\");\n  });\n\n  evalLater([&]() {\n    EXPECT_EQ(3, counter++);\n  }).wait(waitScope);\n\n  EXPECT_EQ(4, counter);\n  EXPECT_EQ(1u, errorHandler.exceptionCount);\n}"
  },
  {
    "function_name": "taskFailed",
    "container": "ErrorHandlerImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "551-554",
    "snippet": "void taskFailed(kj::Exception&& exception) override {\n    EXPECT_TRUE(exception.getDescription().endsWith(\"example TaskSet failure\"));\n    ++exceptionCount;\n  }",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "exception.getDescription().endsWith(\"example TaskSet failure\")"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception.getDescription",
          "args": [
            "\"example TaskSet failure\""
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception.getDescription",
          "args": [],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "getDescription",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "81-81",
          "snippet": "StringPtr getDescription() const { return description; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  StringPtr getDescription() const { return description; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nErrorHandlerImpl {\n  void taskFailed(kj::Exception&& exception) override {\n      EXPECT_TRUE(exception.getDescription().endsWith(\"example TaskSet failure\"));\n      ++exceptionCount;\n    }\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "534-546",
    "snippet": "TEST(Async, ArrayJoinVoid) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  auto builder = heapArrayBuilder<Promise<void>>(3);\n  builder.add(READY_NOW);\n  builder.add(READY_NOW);\n  builder.add(READY_NOW);\n\n  Promise<void> promise = joinPromises(builder.finish());\n\n  promise.wait(waitScope);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "joinPromises",
          "args": [
            "builder.finish()"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "joinPromises",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "814-818",
          "snippet": "Promise<Array<T>> joinPromises(Array<Promise<T>>&& promises) {\n  return Promise<Array<T>>(false, kj::heap<_::ArrayJoinPromiseNode<T>>(\n      KJ_MAP(p, promises) { return kj::mv(p.node); },\n      heapArray<_::ExceptionOr<T>>(promises.size())));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "Promise<Array<T>> joinPromises(Array<Promise<T>>&& promises) {\n  return Promise<Array<T>>(false, kj::heap<_::ArrayJoinPromiseNode<T>>(\n      KJ_MAP(p, promises) { return kj::mv(p.node); },\n      heapArray<_::ExceptionOr<T>>(promises.size())));\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.finish",
          "args": [],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.add",
          "args": [
            "READY_NOW"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "heapArrayBuilder<Promise<void>>",
          "args": [
            "3"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, ArrayJoinVoid) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  auto builder = heapArrayBuilder<Promise<void>>(3);\n  builder.add(READY_NOW);\n  builder.add(READY_NOW);\n  builder.add(READY_NOW);\n\n  Promise<void> promise = joinPromises(builder.finish());\n\n  promise.wait(waitScope);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "515-532",
    "snippet": "TEST(Async, ArrayJoin) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  auto builder = heapArrayBuilder<Promise<int>>(3);\n  builder.add(123);\n  builder.add(456);\n  builder.add(789);\n\n  Promise<Array<int>> promise = joinPromises(builder.finish());\n\n  auto result = promise.wait(waitScope);\n\n  ASSERT_EQ(3u, result.size());\n  EXPECT_EQ(123, result[0]);\n  EXPECT_EQ(456, result[1]);\n  EXPECT_EQ(789, result[2]);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "789",
            "result[2]"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "456",
            "result[1]"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "result[0]"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "3u",
            "result.size()"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.size",
          "args": [],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "joinPromises",
          "args": [
            "builder.finish()"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "joinPromises",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "814-818",
          "snippet": "Promise<Array<T>> joinPromises(Array<Promise<T>>&& promises) {\n  return Promise<Array<T>>(false, kj::heap<_::ArrayJoinPromiseNode<T>>(\n      KJ_MAP(p, promises) { return kj::mv(p.node); },\n      heapArray<_::ExceptionOr<T>>(promises.size())));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "Promise<Array<T>> joinPromises(Array<Promise<T>>&& promises) {\n  return Promise<Array<T>>(false, kj::heap<_::ArrayJoinPromiseNode<T>>(\n      KJ_MAP(p, promises) { return kj::mv(p.node); },\n      heapArray<_::ExceptionOr<T>>(promises.size())));\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.finish",
          "args": [],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.add",
          "args": [
            "789"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "heapArrayBuilder<Promise<int>>",
          "args": [
            "3"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, ArrayJoin) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  auto builder = heapArrayBuilder<Promise<int>>(3);\n  builder.add(123);\n  builder.add(456);\n  builder.add(789);\n\n  Promise<Array<int>> promise = joinPromises(builder.finish());\n\n  auto result = promise.wait(waitScope);\n\n  ASSERT_EQ(3u, result.size());\n  EXPECT_EQ(123, result[0]);\n  EXPECT_EQ(456, result[1]);\n  EXPECT_EQ(789, result[2]);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "473-513",
    "snippet": "TEST(Async, ExclusiveJoin) {\n  {\n    EventLoop loop;\n    WaitScope waitScope(loop);\n\n    auto left = evalLater([&]() { return 123; });\n    auto right = newPromiseAndFulfiller<int>();  // never fulfilled\n\n    EXPECT_EQ(123, left.exclusiveJoin(kj::mv(right.promise)).wait(waitScope));\n  }\n\n  {\n    EventLoop loop;\n    WaitScope waitScope(loop);\n\n    auto left = newPromiseAndFulfiller<int>();  // never fulfilled\n    auto right = evalLater([&]() { return 123; });\n\n    EXPECT_EQ(123, left.promise.exclusiveJoin(kj::mv(right)).wait(waitScope));\n  }\n\n  {\n    EventLoop loop;\n    WaitScope waitScope(loop);\n\n    auto left = evalLater([&]() { return 123; });\n    auto right = evalLater([&]() { return 456; });\n\n    EXPECT_EQ(123, left.exclusiveJoin(kj::mv(right)).wait(waitScope));\n  }\n\n  {\n    EventLoop loop;\n    WaitScope waitScope(loop);\n\n    auto left = evalLater([&]() { return 123; });\n    auto right = evalLater([&]() { return 456; }).eagerlyEvaluate(nullptr);\n\n    EXPECT_EQ(456, left.exclusiveJoin(kj::mv(right)).wait(waitScope));\n  }\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "456",
            "left.exclusiveJoin(kj::mv(right)).wait(waitScope)"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "left.exclusiveJoin",
          "args": [
            "waitScope"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "left.exclusiveJoin",
          "args": [
            "kj::mv(right)"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "right"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "nullptr"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "left.exclusiveJoin(kj::mv(right)).wait(waitScope)"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "left.exclusiveJoin",
          "args": [
            "waitScope"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "left.exclusiveJoin",
          "args": [
            "kj::mv(right)"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "right"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "left.promise.exclusiveJoin(kj::mv(right)).wait(waitScope)"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "left.promise.exclusiveJoin",
          "args": [
            "waitScope"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "left.promise.exclusiveJoin",
          "args": [
            "kj::mv(right)"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "right"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newPromiseAndFulfiller<int>",
          "args": [],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "left.exclusiveJoin(kj::mv(right.promise)).wait(waitScope)"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "left.exclusiveJoin",
          "args": [
            "waitScope"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "left.exclusiveJoin",
          "args": [
            "kj::mv(right.promise)"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "right.promise"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, ExclusiveJoin) {\n  {\n    EventLoop loop;\n    WaitScope waitScope(loop);\n\n    auto left = evalLater([&]() { return 123; });\n    auto right = newPromiseAndFulfiller<int>();  // never fulfilled\n\n    EXPECT_EQ(123, left.exclusiveJoin(kj::mv(right.promise)).wait(waitScope));\n  }\n\n  {\n    EventLoop loop;\n    WaitScope waitScope(loop);\n\n    auto left = newPromiseAndFulfiller<int>();  // never fulfilled\n    auto right = evalLater([&]() { return 123; });\n\n    EXPECT_EQ(123, left.promise.exclusiveJoin(kj::mv(right)).wait(waitScope));\n  }\n\n  {\n    EventLoop loop;\n    WaitScope waitScope(loop);\n\n    auto left = evalLater([&]() { return 123; });\n    auto right = evalLater([&]() { return 456; });\n\n    EXPECT_EQ(123, left.exclusiveJoin(kj::mv(right)).wait(waitScope));\n  }\n\n  {\n    EventLoop loop;\n    WaitScope waitScope(loop);\n\n    auto left = evalLater([&]() { return 123; });\n    auto right = evalLater([&]() { return 456; }).eagerlyEvaluate(nullptr);\n\n    EXPECT_EQ(456, left.exclusiveJoin(kj::mv(right)).wait(waitScope));\n  }\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "446-471",
    "snippet": "TEST(Async, ForkRef) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<Own<RefcountedInt>> promise = evalLater([&]() {\n    return refcounted<RefcountedInt>(123);\n  });\n\n  auto fork = promise.fork();\n\n  auto branch1 = fork.addBranch().then([](Own<RefcountedInt>&& i) {\n    EXPECT_EQ(123, i->i);\n    return 456;\n  });\n  auto branch2 = fork.addBranch().then([](Own<RefcountedInt>&& i) {\n    EXPECT_EQ(123, i->i);\n    return 789;\n  });\n\n  {\n    auto releaseFork = kj::mv(fork);\n  }\n\n  EXPECT_EQ(456, branch1.wait(waitScope));\n  EXPECT_EQ(789, branch2.wait(waitScope));\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "789",
            "branch2.wait(waitScope)"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "branch2.wait",
          "args": [
            "waitScope"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "456",
            "branch1.wait(waitScope)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "branch1.wait",
          "args": [
            "waitScope"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "fork"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork.addBranch",
          "args": [
            "[](Own<RefcountedInt>&& i) {\n    EXPECT_EQ(123, i->i);\n    return 789;\n  }"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "i->i"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork.addBranch",
          "args": [],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "addBranch",
          "container": "ForkHub",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "396-398",
          "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork.addBranch",
          "args": [
            "[](Own<RefcountedInt>&& i) {\n    EXPECT_EQ(123, i->i);\n    return 456;\n  }"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "i->i"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.fork",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "[&]() {\n    return refcounted<RefcountedInt>(123);\n  }"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcounted<RefcountedInt>",
          "args": [
            "123"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, ForkRef) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<Own<RefcountedInt>> promise = evalLater([&]() {\n    return refcounted<RefcountedInt>(123);\n  });\n\n  auto fork = promise.fork();\n\n  auto branch1 = fork.addBranch().then([](Own<RefcountedInt>&& i) {\n    EXPECT_EQ(123, i->i);\n    return 456;\n  });\n  auto branch2 = fork.addBranch().then([](Own<RefcountedInt>&& i) {\n    EXPECT_EQ(123, i->i);\n    return 789;\n  });\n\n  {\n    auto releaseFork = kj::mv(fork);\n  }\n\n  EXPECT_EQ(456, branch1.wait(waitScope));\n  EXPECT_EQ(789, branch2.wait(waitScope));\n}"
  },
  {
    "function_name": "addRef",
    "container": "RefcountedInt",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "443-443",
    "snippet": "Own<RefcountedInt> addRef() { return kj::addRef(*this); }",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nRefcountedInt {\n  Own<RefcountedInt> addRef() { return kj::addRef(*this); }\n}"
  },
  {
    "function_name": "RefcountedInt",
    "container": "RefcountedInt",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "441-441",
    "snippet": "RefcountedInt(int i): i(i) {}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nRefcountedInt {\n  RefcountedInt(int i): i(i) {}\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "415-438",
    "snippet": "TEST(Async, Fork) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<int> promise = evalLater([&]() { return 123; });\n\n  auto fork = promise.fork();\n\n  auto branch1 = fork.addBranch().then([](int i) {\n    EXPECT_EQ(123, i);\n    return 456;\n  });\n  auto branch2 = fork.addBranch().then([](int i) {\n    EXPECT_EQ(123, i);\n    return 789;\n  });\n\n  {\n    auto releaseFork = kj::mv(fork);\n  }\n\n  EXPECT_EQ(456, branch1.wait(waitScope));\n  EXPECT_EQ(789, branch2.wait(waitScope));\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "789",
            "branch2.wait(waitScope)"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "branch2.wait",
          "args": [
            "waitScope"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "456",
            "branch1.wait(waitScope)"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "branch1.wait",
          "args": [
            "waitScope"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "fork"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork.addBranch",
          "args": [
            "[](int i) {\n    EXPECT_EQ(123, i);\n    return 789;\n  }"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "i"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork.addBranch",
          "args": [],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "addBranch",
          "container": "ForkHub",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "396-398",
          "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork.addBranch",
          "args": [
            "[](int i) {\n    EXPECT_EQ(123, i);\n    return 456;\n  }"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "i"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.fork",
          "args": [],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "[&]() { return 123; }"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, Fork) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<int> promise = evalLater([&]() { return 123; });\n\n  auto fork = promise.fork();\n\n  auto branch1 = fork.addBranch().then([](int i) {\n    EXPECT_EQ(123, i);\n    return 456;\n  });\n  auto branch2 = fork.addBranch().then([](int i) {\n    EXPECT_EQ(123, i);\n    return 789;\n  });\n\n  {\n    auto releaseFork = kj::mv(fork);\n  }\n\n  EXPECT_EQ(456, branch1.wait(waitScope));\n  EXPECT_EQ(789, branch2.wait(waitScope));\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "358-413",
    "snippet": "TEST(Async, Ordering) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  int counter = 0;\n  Promise<void> promises[6] = {nullptr, nullptr, nullptr, nullptr, nullptr, nullptr};\n\n  promises[1] = evalLater([&]() {\n    EXPECT_EQ(0, counter++);\n\n    {\n      // Use a promise and fulfiller so that we can fulfill the promise after waiting on it in\n      // order to induce depth-first scheduling.\n      auto paf = kj::newPromiseAndFulfiller<void>();\n      promises[2] = paf.promise.then([&]() {\n        EXPECT_EQ(1, counter++);\n      }).eagerlyEvaluate(nullptr);\n      paf.fulfiller->fulfill();\n    }\n\n    // .then() is scheduled breadth-first if the promise has already resolved, but depth-first\n    // if the promise resolves later.\n    promises[3] = Promise<void>(READY_NOW).then([&]() {\n      EXPECT_EQ(4, counter++);\n    }).then([&]() {\n      EXPECT_EQ(5, counter++);\n    }).eagerlyEvaluate(nullptr);\n\n    {\n      auto paf = kj::newPromiseAndFulfiller<void>();\n      promises[4] = paf.promise.then([&]() {\n        EXPECT_EQ(2, counter++);\n      }).eagerlyEvaluate(nullptr);\n      paf.fulfiller->fulfill();\n    }\n\n    // evalLater() is like READY_NOW.then().\n    promises[5] = evalLater([&]() {\n      EXPECT_EQ(6, counter++);\n    }).eagerlyEvaluate(nullptr);\n  }).eagerlyEvaluate(nullptr);\n\n  promises[0] = evalLater([&]() {\n    EXPECT_EQ(3, counter++);\n\n    // Making this a chain should NOT cause it to preempt promises[1].  (This was a problem at one\n    // point.)\n    return Promise<void>(READY_NOW);\n  }).eagerlyEvaluate(nullptr);\n\n  for (auto i: indices(promises)) {\n    kj::mv(promises[i]).wait(waitScope);\n  }\n\n  EXPECT_EQ(7, counter);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "7",
            "counter"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "waitScope"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promises[i]"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indices",
          "args": [
            "promises"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "nullptr"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "Promise<void>",
          "args": [
            "READY_NOW"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "Promise<T>::Promise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "671-672",
          "snippet": "Promise<T>::Promise(kj::Exception&& exception)\n    : PromiseBase(heap<_::ImmediateBrokenPromiseNode>(kj::mv(exception))) {}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "Promise<T>::Promise(kj::Exception&& exception)\n    : PromiseBase(heap<_::ImmediateBrokenPromiseNode>(kj::mv(exception))) {}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "counter++"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "6",
            "counter++"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.fulfiller->fulfill",
          "args": [],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "fulfill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "68-72",
          "snippet": "void fulfill() {\n    fulfiller.fulfill();\n    port.timers->timers.erase(pos);\n    pos = port.timers->timers.end();\n  }",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid fulfill() {\n    fulfiller.fulfill();\n    port.timers->timers.erase(pos);\n    pos = port.timers->timers.end();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "nullptr"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "[&]() {\n        EXPECT_EQ(2, counter++);\n      }"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "counter++"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<void>",
          "args": [],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "5",
            "counter++"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "4",
            "counter++"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "nullptr"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "[&]() {\n        EXPECT_EQ(1, counter++);\n      }"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "counter++"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "counter++"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, Ordering) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  int counter = 0;\n  Promise<void> promises[6] = {nullptr, nullptr, nullptr, nullptr, nullptr, nullptr};\n\n  promises[1] = evalLater([&]() {\n    EXPECT_EQ(0, counter++);\n\n    {\n      // Use a promise and fulfiller so that we can fulfill the promise after waiting on it in\n      // order to induce depth-first scheduling.\n      auto paf = kj::newPromiseAndFulfiller<void>();\n      promises[2] = paf.promise.then([&]() {\n        EXPECT_EQ(1, counter++);\n      }).eagerlyEvaluate(nullptr);\n      paf.fulfiller->fulfill();\n    }\n\n    // .then() is scheduled breadth-first if the promise has already resolved, but depth-first\n    // if the promise resolves later.\n    promises[3] = Promise<void>(READY_NOW).then([&]() {\n      EXPECT_EQ(4, counter++);\n    }).then([&]() {\n      EXPECT_EQ(5, counter++);\n    }).eagerlyEvaluate(nullptr);\n\n    {\n      auto paf = kj::newPromiseAndFulfiller<void>();\n      promises[4] = paf.promise.then([&]() {\n        EXPECT_EQ(2, counter++);\n      }).eagerlyEvaluate(nullptr);\n      paf.fulfiller->fulfill();\n    }\n\n    // evalLater() is like READY_NOW.then().\n    promises[5] = evalLater([&]() {\n      EXPECT_EQ(6, counter++);\n    }).eagerlyEvaluate(nullptr);\n  }).eagerlyEvaluate(nullptr);\n\n  promises[0] = evalLater([&]() {\n    EXPECT_EQ(3, counter++);\n\n    // Making this a chain should NOT cause it to preempt promises[1].  (This was a problem at one\n    // point.)\n    return Promise<void>(READY_NOW);\n  }).eagerlyEvaluate(nullptr);\n\n  for (auto i: indices(promises)) {\n    kj::mv(promises[i]).wait(waitScope);\n  }\n\n  EXPECT_EQ(7, counter);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "353-356",
    "snippet": "TEST(Async, SeparateFulfillerMemoryLeak) {\n  auto paf = kj::newPromiseAndFulfiller<void>();\n  paf.fulfiller->fulfill();\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "paf.fulfiller->fulfill",
          "args": [],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "fulfill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "68-72",
          "snippet": "void fulfill() {\n    fulfiller.fulfill();\n    port.timers->timers.erase(pos);\n    pos = port.timers->timers.end();\n  }",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid fulfill() {\n    fulfiller.fulfill();\n    port.timers->timers.erase(pos);\n    pos = port.timers->timers.end();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<void>",
          "args": [],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, SeparateFulfillerMemoryLeak) {\n  auto paf = kj::newPromiseAndFulfiller<void>();\n  paf.fulfiller->fulfill();\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "343-351",
    "snippet": "TEST(Async, SeparateFulfillerDiscarded) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  auto pair = newPromiseAndFulfiller<int>();\n  pair.fulfiller = nullptr;\n\n  EXPECT_ANY_THROW(pair.promise.wait(waitScope));\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_ANY_THROW",
          "args": [
            "pair.promise.wait(waitScope)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pair.promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newPromiseAndFulfiller<int>",
          "args": [],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, SeparateFulfillerDiscarded) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  auto pair = newPromiseAndFulfiller<int>();\n  pair.fulfiller = nullptr;\n\n  EXPECT_ANY_THROW(pair.promise.wait(waitScope));\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "322-336",
    "snippet": "TEST(Async, SeparateFulfillerChained) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  auto pair = newPromiseAndFulfiller<Promise<int>>();\n  auto inner = newPromiseAndFulfiller<int>();\n\n  EXPECT_TRUE(pair.fulfiller->isWaiting());\n  pair.fulfiller->fulfill(kj::mv(inner.promise));\n  EXPECT_FALSE(pair.fulfiller->isWaiting());\n\n  inner.fulfiller->fulfill(123);\n\n  EXPECT_EQ(123, pair.promise.wait(waitScope));\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "pair.promise.wait(waitScope)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pair.promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inner.fulfiller->fulfill",
          "args": [
            "123"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "fulfill",
          "container": "WeakFulfiller",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "847-851",
          "snippet": "void fulfill(FixVoid<T>&& value) override {\n    if (inner != nullptr) {\n      inner->fulfill(kj::mv(value));\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "WeakFulfiller {\n  void fulfill(FixVoid<T>&& value) override {\n      if (inner != nullptr) {\n        inner->fulfill(kj::mv(value));\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "pair.fulfiller->isWaiting()"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pair.fulfiller->isWaiting",
          "args": [],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "isWaiting",
          "container": "WeakFulfiller",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "859-861",
          "snippet": "bool isWaiting() override {\n    return inner != nullptr && inner->isWaiting();\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "WeakFulfiller {\n  bool isWaiting() override {\n      return inner != nullptr && inner->isWaiting();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "inner.promise"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "pair.fulfiller->isWaiting()"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newPromiseAndFulfiller<int>",
          "args": [],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      },
      {
        "call_info": {
          "callee": "newPromiseAndFulfiller<Promise<int>>",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, SeparateFulfillerChained) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  auto pair = newPromiseAndFulfiller<Promise<int>>();\n  auto inner = newPromiseAndFulfiller<int>();\n\n  EXPECT_TRUE(pair.fulfiller->isWaiting());\n  pair.fulfiller->fulfill(kj::mv(inner.promise));\n  EXPECT_FALSE(pair.fulfiller->isWaiting());\n\n  inner.fulfiller->fulfill(123);\n\n  EXPECT_EQ(123, pair.promise.wait(waitScope));\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "314-320",
    "snippet": "TEST(Async, SeparateFulfillerCanceled) {\n  auto pair = newPromiseAndFulfiller<void>();\n\n  EXPECT_TRUE(pair.fulfiller->isWaiting());\n  pair.promise = nullptr;\n  EXPECT_FALSE(pair.fulfiller->isWaiting());\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "pair.fulfiller->isWaiting()"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pair.fulfiller->isWaiting",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "isWaiting",
          "container": "WeakFulfiller",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "859-861",
          "snippet": "bool isWaiting() override {\n    return inner != nullptr && inner->isWaiting();\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "WeakFulfiller {\n  bool isWaiting() override {\n      return inner != nullptr && inner->isWaiting();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "pair.fulfiller->isWaiting()"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newPromiseAndFulfiller<void>",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, SeparateFulfillerCanceled) {\n  auto pair = newPromiseAndFulfiller<void>();\n\n  EXPECT_TRUE(pair.fulfiller->isWaiting());\n  pair.promise = nullptr;\n  EXPECT_FALSE(pair.fulfiller->isWaiting());\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "301-312",
    "snippet": "TEST(Async, SeparateFulfillerVoid) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  auto pair = newPromiseAndFulfiller<void>();\n\n  EXPECT_TRUE(pair.fulfiller->isWaiting());\n  pair.fulfiller->fulfill();\n  EXPECT_FALSE(pair.fulfiller->isWaiting());\n\n  pair.promise.wait(waitScope);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pair.promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "pair.fulfiller->isWaiting()"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pair.fulfiller->isWaiting",
          "args": [],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "isWaiting",
          "container": "WeakFulfiller",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "859-861",
          "snippet": "bool isWaiting() override {\n    return inner != nullptr && inner->isWaiting();\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "WeakFulfiller {\n  bool isWaiting() override {\n      return inner != nullptr && inner->isWaiting();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pair.fulfiller->fulfill",
          "args": [],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "fulfill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "68-72",
          "snippet": "void fulfill() {\n    fulfiller.fulfill();\n    port.timers->timers.erase(pos);\n    pos = port.timers->timers.end();\n  }",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid fulfill() {\n    fulfiller.fulfill();\n    port.timers->timers.erase(pos);\n    pos = port.timers->timers.end();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "pair.fulfiller->isWaiting()"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newPromiseAndFulfiller<void>",
          "args": [],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, SeparateFulfillerVoid) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  auto pair = newPromiseAndFulfiller<void>();\n\n  EXPECT_TRUE(pair.fulfiller->isWaiting());\n  pair.fulfiller->fulfill();\n  EXPECT_FALSE(pair.fulfiller->isWaiting());\n\n  pair.promise.wait(waitScope);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "288-299",
    "snippet": "TEST(Async, SeparateFulfiller) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  auto pair = newPromiseAndFulfiller<int>();\n\n  EXPECT_TRUE(pair.fulfiller->isWaiting());\n  pair.fulfiller->fulfill(123);\n  EXPECT_FALSE(pair.fulfiller->isWaiting());\n\n  EXPECT_EQ(123, pair.promise.wait(waitScope));\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "pair.promise.wait(waitScope)"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pair.promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "pair.fulfiller->isWaiting()"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pair.fulfiller->isWaiting",
          "args": [],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "isWaiting",
          "container": "WeakFulfiller",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "859-861",
          "snippet": "bool isWaiting() override {\n    return inner != nullptr && inner->isWaiting();\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "WeakFulfiller {\n  bool isWaiting() override {\n      return inner != nullptr && inner->isWaiting();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pair.fulfiller->fulfill",
          "args": [
            "123"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "fulfill",
          "container": "WeakFulfiller",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "847-851",
          "snippet": "void fulfill(FixVoid<T>&& value) override {\n    if (inner != nullptr) {\n      inner->fulfill(kj::mv(value));\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "WeakFulfiller {\n  void fulfill(FixVoid<T>&& value) override {\n      if (inner != nullptr) {\n        inner->fulfill(kj::mv(value));\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "pair.fulfiller->isWaiting()"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newPromiseAndFulfiller<int>",
          "args": [],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, SeparateFulfiller) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  auto pair = newPromiseAndFulfiller<int>();\n\n  EXPECT_TRUE(pair.fulfiller->isWaiting());\n  pair.fulfiller->fulfill(123);\n  EXPECT_FALSE(pair.fulfiller->isWaiting());\n\n  EXPECT_EQ(123, pair.promise.wait(waitScope));\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "266-286",
    "snippet": "TEST(Async, DeepChain4) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<void> promise = nullptr;\n  promise = evalLater([&]() {\n    auto trace = promise.trace();\n    uint lines = 0;\n    for (char c: trace) {\n      lines += c == '\\n';\n    }\n\n    // Chain nodes should have been collapsed such that instead of a chain of 1000 nodes, we have\n    // 2-ish nodes.  We'll give a little room for implementation freedom.\n    EXPECT_LT(lines, 5);\n  });\n\n  promise = makeChain2(1000, kj::mv(promise));\n\n  promise.wait(waitScope);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeChain2",
          "args": [
            "1000",
            "kj::mv(promise)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promise"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "[&]() {\n    auto trace = promise.trace();\n    uint lines = 0;\n    for (char c: trace) {\n      lines += c == '\\n';\n    }\n\n    // Chain nodes should have been collapsed such that instead of a chain of 1000 nodes, we have\n    // 2-ish nodes.  We'll give a little room for implementation freedom.\n    EXPECT_LT(lines, 5);\n  }"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_LT",
          "args": [
            "lines",
            "5"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.trace",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "trace",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "155-161",
          "snippet": "kj::String trace() {\n    kj::Vector<kj::String> traces;\n    for (auto& entry: tasks) {\n      traces.add(entry.second->trace());\n    }\n    return kj::strArray(traces, \"\\n============================================\\n\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  kj::String trace() {\n      kj::Vector<kj::String> traces;\n      for (auto& entry: tasks) {\n        traces.add(entry.second->trace());\n      }\n      return kj::strArray(traces, \"\\n============================================\\n\");\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, DeepChain4) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<void> promise = nullptr;\n  promise = evalLater([&]() {\n    auto trace = promise.trace();\n    uint lines = 0;\n    for (char c: trace) {\n      lines += c == '\\n';\n    }\n\n    // Chain nodes should have been collapsed such that instead of a chain of 1000 nodes, we have\n    // 2-ish nodes.  We'll give a little room for implementation freedom.\n    EXPECT_LT(lines, 5);\n  });\n\n  promise = makeChain2(1000, kj::mv(promise));\n\n  promise.wait(waitScope);\n}"
  },
  {
    "function_name": "makeChain2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "256-264",
    "snippet": "Promise<void> makeChain2(uint i, Promise<void> promise) {\n  if (i > 0) {\n    return evalLater(mvCapture(promise, [i](Promise<void>&& promise) -> Promise<void> {\n      return makeChain2(i - 1, kj::mv(promise));\n    }));\n  } else {\n    return kj::mv(promise);\n  }\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promise"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "mvCapture(promise, [i](Promise<void>&& promise) -> Promise<void> {\n      return makeChain2(i - 1, kj::mv(promise));\n    })"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "mvCapture",
          "args": [
            "promise",
            "[i](Promise<void>&& promise) -> Promise<void> {\n      return makeChain2(i - 1, kj::mv(promise));\n    }"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeChain2",
          "args": [
            "i - 1",
            "kj::mv(promise)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promise"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nPromise<void> makeChain2(uint i, Promise<void> promise) {\n  if (i > 0) {\n    return evalLater(mvCapture(promise, [i](Promise<void>&& promise) -> Promise<void> {\n      return makeChain2(i - 1, kj::mv(promise));\n    }));\n  } else {\n    return kj::mv(promise);\n  }\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "237-254",
    "snippet": "TEST(Async, DeepChain3) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<void> promise = makeChain(1000);\n\n  loop.run();\n\n  auto trace = promise.trace();\n  uint lines = 0;\n  for (char c: trace) {\n    lines += c == '\\n';\n  }\n\n  // Chain nodes should have been collapsed such that instead of a chain of 1000 nodes, we have\n  // 2-ish nodes.  We'll give a little room for implementation freedom.\n  EXPECT_LT(lines, 5);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_LT",
          "args": [
            "lines",
            "5"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.trace",
          "args": [],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "trace",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "155-161",
          "snippet": "kj::String trace() {\n    kj::Vector<kj::String> traces;\n    for (auto& entry: tasks) {\n      traces.add(entry.second->trace());\n    }\n    return kj::strArray(traces, \"\\n============================================\\n\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  kj::String trace() {\n      kj::Vector<kj::String> traces;\n      for (auto& entry: tasks) {\n        traces.add(entry.second->trace());\n      }\n      return kj::strArray(traces, \"\\n============================================\\n\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "loop.run",
          "args": [],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": "RunnableImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "257-259",
          "snippet": "void run() override {\n    func();\n  }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nRunnableImpl {\n  void run() override {\n      func();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeChain",
          "args": [
            "1000"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "makeChain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "227-235",
          "snippet": "Promise<void> makeChain(uint i) {\n  if (i > 0) {\n    return evalLater([i]() -> Promise<void> {\n      return makeChain(i - 1);\n    });\n  } else {\n    return NEVER_DONE;\n  }\n}",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nPromise<void> makeChain(uint i) {\n  if (i > 0) {\n    return evalLater([i]() -> Promise<void> {\n      return makeChain(i - 1);\n    });\n  } else {\n    return NEVER_DONE;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, DeepChain3) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<void> promise = makeChain(1000);\n\n  loop.run();\n\n  auto trace = promise.trace();\n  uint lines = 0;\n  for (char c: trace) {\n    lines += c == '\\n';\n  }\n\n  // Chain nodes should have been collapsed such that instead of a chain of 1000 nodes, we have\n  // 2-ish nodes.  We'll give a little room for implementation freedom.\n  EXPECT_LT(lines, 5);\n}"
  },
  {
    "function_name": "makeChain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "227-235",
    "snippet": "Promise<void> makeChain(uint i) {\n  if (i > 0) {\n    return evalLater([i]() -> Promise<void> {\n      return makeChain(i - 1);\n    });\n  } else {\n    return NEVER_DONE;\n  }\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "[i]() -> Promise<void> {\n      return makeChain(i - 1);\n    }"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nPromise<void> makeChain(uint i) {\n  if (i > 0) {\n    return evalLater([i]() -> Promise<void> {\n      return makeChain(i - 1);\n    });\n  } else {\n    return NEVER_DONE;\n  }\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "200-225",
    "snippet": "TEST(Async, DeepChain2) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<void> promise = nullptr;\n  promise = evalLater([&]() {\n    auto trace = promise.trace();\n    uint lines = 0;\n    for (char c: trace) {\n      lines += c == '\\n';\n    }\n\n    // Chain nodes should have been collapsed such that instead of a chain of 1000 nodes, we have\n    // 2-ish nodes.  We'll give a little room for implementation freedom.\n    EXPECT_LT(lines, 5);\n  });\n\n  // Create a ridiculous chain of promises.\n  for (uint i = 0; i < 1000; i++) {\n    promise = evalLater(mvCapture(promise, [](Promise<void> promise) {\n      return kj::mv(promise);\n    }));\n  }\n\n  promise.wait(waitScope);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "mvCapture(promise, [](Promise<void> promise) {\n      return kj::mv(promise);\n    })"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "mvCapture",
          "args": [
            "promise",
            "[](Promise<void> promise) {\n      return kj::mv(promise);\n    }"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promise"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_LT",
          "args": [
            "lines",
            "5"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.trace",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "trace",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "155-161",
          "snippet": "kj::String trace() {\n    kj::Vector<kj::String> traces;\n    for (auto& entry: tasks) {\n      traces.add(entry.second->trace());\n    }\n    return kj::strArray(traces, \"\\n============================================\\n\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  kj::String trace() {\n      kj::Vector<kj::String> traces;\n      for (auto& entry: tasks) {\n        traces.add(entry.second->trace());\n      }\n      return kj::strArray(traces, \"\\n============================================\\n\");\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, DeepChain2) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<void> promise = nullptr;\n  promise = evalLater([&]() {\n    auto trace = promise.trace();\n    uint lines = 0;\n    for (char c: trace) {\n      lines += c == '\\n';\n    }\n\n    // Chain nodes should have been collapsed such that instead of a chain of 1000 nodes, we have\n    // 2-ish nodes.  We'll give a little room for implementation freedom.\n    EXPECT_LT(lines, 5);\n  });\n\n  // Create a ridiculous chain of promises.\n  for (uint i = 0; i < 1000; i++) {\n    promise = evalLater(mvCapture(promise, [](Promise<void> promise) {\n      return kj::mv(promise);\n    }));\n  }\n\n  promise.wait(waitScope);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "174-198",
    "snippet": "TEST(Async, DeepChain) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<void> promise = NEVER_DONE;\n\n  // Create a ridiculous chain of promises.\n  for (uint i = 0; i < 1000; i++) {\n    promise = evalLater(mvCapture(promise, [](Promise<void> promise) {\n      return kj::mv(promise);\n    }));\n  }\n\n  loop.run();\n\n  auto trace = promise.trace();\n  uint lines = 0;\n  for (char c: trace) {\n    lines += c == '\\n';\n  }\n\n  // Chain nodes should have been collapsed such that instead of a chain of 1000 nodes, we have\n  // 2-ish nodes.  We'll give a little room for implementation freedom.\n  EXPECT_LT(lines, 5);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_LT",
          "args": [
            "lines",
            "5"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.trace",
          "args": [],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "trace",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "155-161",
          "snippet": "kj::String trace() {\n    kj::Vector<kj::String> traces;\n    for (auto& entry: tasks) {\n      traces.add(entry.second->trace());\n    }\n    return kj::strArray(traces, \"\\n============================================\\n\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  kj::String trace() {\n      kj::Vector<kj::String> traces;\n      for (auto& entry: tasks) {\n        traces.add(entry.second->trace());\n      }\n      return kj::strArray(traces, \"\\n============================================\\n\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "loop.run",
          "args": [],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": "RunnableImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "257-259",
          "snippet": "void run() override {\n    func();\n  }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nRunnableImpl {\n  void run() override {\n      func();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "mvCapture(promise, [](Promise<void> promise) {\n      return kj::mv(promise);\n    })"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "mvCapture",
          "args": [
            "promise",
            "[](Promise<void> promise) {\n      return kj::mv(promise);\n    }"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promise"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, DeepChain) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<void> promise = NEVER_DONE;\n\n  // Create a ridiculous chain of promises.\n  for (uint i = 0; i < 1000; i++) {\n    promise = evalLater(mvCapture(promise, [](Promise<void> promise) {\n      return kj::mv(promise);\n    }));\n  }\n\n  loop.run();\n\n  auto trace = promise.trace();\n  uint lines = 0;\n  for (char c: trace) {\n    lines += c == '\\n';\n  }\n\n  // Chain nodes should have been collapsed such that instead of a chain of 1000 nodes, we have\n  // 2-ish nodes.  We'll give a little room for implementation freedom.\n  EXPECT_LT(lines, 5);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "158-172",
    "snippet": "TEST(Async, Chain) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<int> promise = evalLater([&]() -> int { return 123; });\n  Promise<int> promise2 = evalLater([&]() -> int { return 321; });\n\n  auto promise3 = promise.then([&](int i) {\n    return promise2.then([&loop,i](int j) {\n      return i + j;\n    });\n  });\n\n  EXPECT_EQ(444, promise3.wait(waitScope));\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "444",
            "promise3.wait(waitScope)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise3.wait",
          "args": [
            "waitScope"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "[&](int i) {\n    return promise2.then([&loop,i](int j) {\n      return i + j;\n    });\n  }"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise2.then",
          "args": [
            "[&loop,i](int j) {\n      return i + j;\n    }"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "[&]() -> int { return 321; }"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, Chain) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<int> promise = evalLater([&]() -> int { return 123; });\n  Promise<int> promise2 = evalLater([&]() -> int { return 321; });\n\n  auto promise3 = promise.then([&](int i) {\n    return promise2.then([&loop,i](int j) {\n      return i + j;\n    });\n  });\n\n  EXPECT_EQ(444, promise3.wait(waitScope));\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "140-156",
    "snippet": "TEST(Async, Then) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  bool done = false;\n\n  Promise<int> promise = Promise<int>(123).then([&](int i) {\n    done = true;\n    return i + 321;\n  });\n\n  EXPECT_FALSE(done);\n\n  EXPECT_EQ(444, promise.wait(waitScope));\n\n  EXPECT_TRUE(done);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "done"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "444",
            "promise.wait(waitScope)"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "done"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Promise<int>",
          "args": [
            "[&](int i) {\n    done = true;\n    return i + 321;\n  }"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "Promise<T>::Promise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "671-672",
          "snippet": "Promise<T>::Promise(kj::Exception&& exception)\n    : PromiseBase(heap<_::ImmediateBrokenPromiseNode>(kj::mv(exception))) {}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "Promise<T>::Promise(kj::Exception&& exception)\n    : PromiseBase(heap<_::ImmediateBrokenPromiseNode>(kj::mv(exception))) {}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, Then) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  bool done = false;\n\n  Promise<int> promise = Promise<int>(123).then([&](int i) {\n    done = true;\n    return i + 321;\n  });\n\n  EXPECT_FALSE(done);\n\n  EXPECT_EQ(444, promise.wait(waitScope));\n\n  EXPECT_TRUE(done);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "123-138",
    "snippet": "TEST(Async, PropagateExceptionTypeChange) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<int> promise = evalLater(\n      [&]() -> int { KJ_FAIL_ASSERT(\"foo\") { return 123; } });\n  int line = __LINE__ - 1;\n\n  Promise<StringPtr> promise2 = promise.then([](int i) -> StringPtr { return \"foo\"; });\n\n  promise2 = promise2.then(\n      [](StringPtr s) -> StringPtr { return \"bar\"; },\n      [&](Exception&& e) -> StringPtr { EXPECT_EQ(line, e.getLine()); return \"baz\"; });\n\n  EXPECT_EQ(\"baz\", promise2.wait(waitScope));\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"baz\"",
            "promise2.wait(waitScope)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise2.wait",
          "args": [
            "waitScope"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise2.then",
          "args": [
            "[](StringPtr s) -> StringPtr { return \"bar\"; }",
            "[&](Exception&& e) -> StringPtr { EXPECT_EQ(line, e.getLine()); return \"baz\"; }"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "line",
            "e.getLine()"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getLine",
          "args": [],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "getLine",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "79-79",
          "snippet": "int getLine() const { return line; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  int getLine() const { return line; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "[](int i) -> StringPtr { return \"foo\"; }"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "[&]() -> int { KJ_FAIL_ASSERT(\"foo\") { return 123; } }"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"foo\""
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, PropagateExceptionTypeChange) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<int> promise = evalLater(\n      [&]() -> int { KJ_FAIL_ASSERT(\"foo\") { return 123; } });\n  int line = __LINE__ - 1;\n\n  Promise<StringPtr> promise2 = promise.then([](int i) -> StringPtr { return \"foo\"; });\n\n  promise2 = promise2.then(\n      [](StringPtr s) -> StringPtr { return \"bar\"; },\n      [&](Exception&& e) -> StringPtr { EXPECT_EQ(line, e.getLine()); return \"baz\"; });\n\n  EXPECT_EQ(\"baz\", promise2.wait(waitScope));\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "106-121",
    "snippet": "TEST(Async, PropagateException) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<int> promise = evalLater(\n      [&]() -> int { KJ_FAIL_ASSERT(\"foo\") { return 123; } });\n  int line = __LINE__ - 1;\n\n  promise = promise.then([](int i) { return i + 1; });\n\n  promise = promise.then(\n      [](int i) { return i + 2; },\n      [&](Exception&& e) { EXPECT_EQ(line, e.getLine()); return 345; });\n\n  EXPECT_EQ(345, promise.wait(waitScope));\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "345",
            "promise.wait(waitScope)"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "[](int i) { return i + 2; }",
            "[&](Exception&& e) { EXPECT_EQ(line, e.getLine()); return 345; }"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "line",
            "e.getLine()"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getLine",
          "args": [],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "getLine",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "79-79",
          "snippet": "int getLine() const { return line; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  int getLine() const { return line; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "[](int i) { return i + 1; }"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "[&]() -> int { KJ_FAIL_ASSERT(\"foo\") { return 123; } }"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"foo\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, PropagateException) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<int> promise = evalLater(\n      [&]() -> int { KJ_FAIL_ASSERT(\"foo\") { return 123; } });\n  int line = __LINE__ - 1;\n\n  promise = promise.then([](int i) { return i + 1; });\n\n  promise = promise.then(\n      [](int i) { return i + 2; },\n      [&](Exception&& e) { EXPECT_EQ(line, e.getLine()); return 345; });\n\n  EXPECT_EQ(345, promise.wait(waitScope));\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "91-104",
    "snippet": "TEST(Async, HandleException) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<int> promise = evalLater(\n      [&]() -> int { KJ_FAIL_ASSERT(\"foo\") { return 123; } });\n  int line = __LINE__ - 1;\n\n  promise = promise.then(\n      [](int i) { return i + 1; },\n      [&](Exception&& e) { EXPECT_EQ(line, e.getLine()); return 345; });\n\n  EXPECT_EQ(345, promise.wait(waitScope));\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "345",
            "promise.wait(waitScope)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "[](int i) { return i + 1; }",
            "[&](Exception&& e) { EXPECT_EQ(line, e.getLine()); return 345; }"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "line",
            "e.getLine()"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getLine",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "getLine",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "79-79",
          "snippet": "int getLine() const { return line; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  int getLine() const { return line; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "[&]() -> int { KJ_FAIL_ASSERT(\"foo\") { return 123; } }"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"foo\""
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, HandleException) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<int> promise = evalLater(\n      [&]() -> int { KJ_FAIL_ASSERT(\"foo\") { return 123; } });\n  int line = __LINE__ - 1;\n\n  promise = promise.then(\n      [](int i) { return i + 1; },\n      [&](Exception&& e) { EXPECT_EQ(line, e.getLine()); return 345; });\n\n  EXPECT_EQ(345, promise.wait(waitScope));\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "79-89",
    "snippet": "TEST(Async, Exception) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<int> promise = evalLater(\n      [&]() -> int { KJ_FAIL_ASSERT(\"foo\") { return 123; } });\n  EXPECT_TRUE(kj::runCatchingExceptions([&]() {\n    // wait() only returns when compiling with -fno-exceptions.\n    EXPECT_EQ(123, promise.wait(waitScope));\n  }) != nullptr);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "kj::runCatchingExceptions([&]() {\n    // wait() only returns when compiling with -fno-exceptions.\n    EXPECT_EQ(123, promise.wait(waitScope));\n  }) != nullptr"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() {\n    // wait() only returns when compiling with -fno-exceptions.\n    EXPECT_EQ(123, promise.wait(waitScope));\n  }"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "promise.wait(waitScope)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "[&]() -> int { KJ_FAIL_ASSERT(\"foo\") { return 123; } }"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"foo\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, Exception) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<int> promise = evalLater(\n      [&]() -> int { KJ_FAIL_ASSERT(\"foo\") { return 123; } });\n  EXPECT_TRUE(kj::runCatchingExceptions([&]() {\n    // wait() only returns when compiling with -fno-exceptions.\n    EXPECT_EQ(123, promise.wait(waitScope));\n  }) != nullptr);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "66-77",
    "snippet": "TEST(Async, ThereVoid) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<int> a = 123;\n  int value = 0;\n\n  Promise<void> promise = a.then([&](int ai) { value = ai; });\n  EXPECT_EQ(0, value);\n  promise.wait(waitScope);\n  EXPECT_EQ(123, value);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "value"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "value"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a.then",
          "args": [
            "[&](int ai) { value = ai; }"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, ThereVoid) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<int> a = 123;\n  int value = 0;\n\n  Promise<void> promise = a.then([&](int ai) { value = ai; });\n  EXPECT_EQ(0, value);\n  promise.wait(waitScope);\n  EXPECT_EQ(123, value);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "53-64",
    "snippet": "TEST(Async, There) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<int> a = 123;\n  bool done = false;\n\n  Promise<int> promise = a.then([&](int ai) { done = true; return ai + 321; });\n  EXPECT_FALSE(done);\n  EXPECT_EQ(444, promise.wait(waitScope));\n  EXPECT_TRUE(done);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "done"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "444",
            "promise.wait(waitScope)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "done"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a.then",
          "args": [
            "[&](int ai) { done = true; return ai + 321; }"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, There) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  Promise<int> a = 123;\n  bool done = false;\n\n  Promise<int> promise = a.then([&](int ai) { done = true; return ai + 321; });\n  EXPECT_FALSE(done);\n  EXPECT_EQ(444, promise.wait(waitScope));\n  EXPECT_TRUE(done);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "41-51",
    "snippet": "TEST(Async, EvalInt) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  bool done = false;\n\n  Promise<int> promise = evalLater([&]() { done = true; return 123; });\n  EXPECT_FALSE(done);\n  EXPECT_EQ(123, promise.wait(waitScope));\n  EXPECT_TRUE(done);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "done"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "promise.wait(waitScope)"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "done"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "[&]() { done = true; return 123; }"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, EvalInt) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  bool done = false;\n\n  Promise<int> promise = evalLater([&]() { done = true; return 123; });\n  EXPECT_FALSE(done);\n  EXPECT_EQ(123, promise.wait(waitScope));\n  EXPECT_TRUE(done);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
    "lines": "29-39",
    "snippet": "TEST(Async, EvalVoid) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  bool done = false;\n\n  Promise<void> promise = evalLater([&]() { done = true; });\n  EXPECT_FALSE(done);\n  promise.wait(waitScope);\n  EXPECT_TRUE(done);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "done"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "done"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "[&]() { done = true; }"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nTEST(Async, EvalVoid) {\n  EventLoop loop;\n  WaitScope waitScope(loop);\n\n  bool done = false;\n\n  Promise<void> promise = evalLater([&]() { done = true; });\n  EXPECT_FALSE(done);\n  promise.wait(waitScope);\n  EXPECT_TRUE(done);\n}"
  }
]