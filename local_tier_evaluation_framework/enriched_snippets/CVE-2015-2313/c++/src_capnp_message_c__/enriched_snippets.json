[
  {
    "function_name": "FlatMessageBuilder::allocateSegment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "241-245",
    "snippet": "kj::ArrayPtr<word> FlatMessageBuilder::allocateSegment(uint minimumSize) {\n  KJ_REQUIRE(!allocated, \"FlatMessageBuilder's buffer was not large enough.\");\n  allocated = true;\n  return array;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "!allocated",
            "\"FlatMessageBuilder's buffer was not large enough.\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nkj::ArrayPtr<word> FlatMessageBuilder::allocateSegment(uint minimumSize) {\n  KJ_REQUIRE(!allocated, \"FlatMessageBuilder's buffer was not large enough.\");\n  allocated = true;\n  return array;\n}"
  },
  {
    "function_name": "FlatMessageBuilder::requireFilled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "236-239",
    "snippet": "void FlatMessageBuilder::requireFilled() {\n  KJ_REQUIRE(getSegmentsForOutput()[0].end() == array.end(),\n          \"FlatMessageBuilder's buffer was too large.\");\n}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "getSegmentsForOutput()[0].end() == array.end()",
            "\"FlatMessageBuilder's buffer was too large.\""
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array.end",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      },
      {
        "call_info": {
          "callee": "getSegmentsForOutput",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "MessageBuilder::getSegmentsForOutput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
          "lines": "103-109",
          "snippet": "kj::ArrayPtr<const kj::ArrayPtr<const word>> MessageBuilder::getSegmentsForOutput() {\n  if (allocatedArena) {\n    return arena()->getSegmentsForOutput();\n  } else {\n    return nullptr;\n  }\n}",
          "includes": [
            "#include <errno.h>",
            "#include <vector>",
            "#include <string>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"orphan.h\"",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"message.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nkj::ArrayPtr<const kj::ArrayPtr<const word>> MessageBuilder::getSegmentsForOutput() {\n  if (allocatedArena) {\n    return arena()->getSegmentsForOutput();\n  } else {\n    return nullptr;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nvoid FlatMessageBuilder::requireFilled() {\n  KJ_REQUIRE(getSegmentsForOutput()[0].end() == array.end(),\n          \"FlatMessageBuilder's buffer was too large.\");\n}"
  },
  {
    "function_name": "FlatMessageBuilder::~FlatMessageBuilder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "234-234",
    "snippet": "FlatMessageBuilder::~FlatMessageBuilder() noexcept(false) {}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nFlatMessageBuilder::~FlatMessageBuilder() noexcept(false) {}"
  },
  {
    "function_name": "FlatMessageBuilder::FlatMessageBuilder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "233-233",
    "snippet": "FlatMessageBuilder::FlatMessageBuilder(kj::ArrayPtr<word> array): array(array), allocated(false) {}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nFlatMessageBuilder::FlatMessageBuilder(kj::ArrayPtr<word> array): array(array), allocated(false) {}"
  },
  {
    "function_name": "MallocMessageBuilder::allocateSegment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "189-226",
    "snippet": "kj::ArrayPtr<word> MallocMessageBuilder::allocateSegment(uint minimumSize) {\n  if (!returnedFirstSegment && !ownFirstSegment) {\n    kj::ArrayPtr<word> result = kj::arrayPtr(reinterpret_cast<word*>(firstSegment), nextSize);\n    if (result.size() >= minimumSize) {\n      returnedFirstSegment = true;\n      return result;\n    }\n    // If the provided first segment wasn't big enough, we discard it and proceed to allocate\n    // our own.  This never happens in practice since minimumSize is always 1 for the first\n    // segment.\n    ownFirstSegment = true;\n  }\n\n  uint size = kj::max(minimumSize, nextSize);\n\n  void* result = calloc(size, sizeof(word));\n  if (result == nullptr) {\n    KJ_FAIL_SYSCALL(\"calloc(size, sizeof(word))\", ENOMEM, size);\n  }\n\n  if (!returnedFirstSegment) {\n    firstSegment = result;\n    returnedFirstSegment = true;\n\n    // After the first segment, we want nextSize to equal the total size allocated so far.\n    if (allocationStrategy == AllocationStrategy::GROW_HEURISTICALLY) nextSize = size;\n  } else {\n    MoreSegments* segments;\n    KJ_IF_MAYBE(s, moreSegments) {\n      segments = *s;\n    } else {\n      auto newSegments = kj::heap<MoreSegments>();\n      segments = newSegments;\n      moreSegments = mv(newSegments);\n    }\n    segments->segments.push_back(result);\n    if (allocationStrategy == AllocationStrategy::GROW_HEURISTICALLY) nextSize += size;\n  }",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "segments->segments.push_back",
          "args": [
            "result"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "newSegments"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<MoreSegments>",
          "args": [],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "321-328",
          "snippet": "Own<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"calloc(size, sizeof(word))\"",
            "ENOMEM",
            "size"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "size",
            "sizeof(word)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::max",
          "args": [
            "minimumSize",
            "nextSize"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "486-488",
          "snippet": "auto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.size",
          "args": [],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "reinterpret_cast<word*>(firstSegment)",
            "nextSize"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<word*>",
          "args": [
            "firstSegment"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nkj::ArrayPtr<word> MallocMessageBuilder::allocateSegment(uint minimumSize) {\n  if (!returnedFirstSegment && !ownFirstSegment) {\n    kj::ArrayPtr<word> result = kj::arrayPtr(reinterpret_cast<word*>(firstSegment), nextSize);\n    if (result.size() >= minimumSize) {\n      returnedFirstSegment = true;\n      return result;\n    }\n    // If the provided first segment wasn't big enough, we discard it and proceed to allocate\n    // our own.  This never happens in practice since minimumSize is always 1 for the first\n    // segment.\n    ownFirstSegment = true;\n  }\n\n  uint size = kj::max(minimumSize, nextSize);\n\n  void* result = calloc(size, sizeof(word));\n  if (result == nullptr) {\n    KJ_FAIL_SYSCALL(\"calloc(size, sizeof(word))\", ENOMEM, size);\n  }\n\n  if (!returnedFirstSegment) {\n    firstSegment = result;\n    returnedFirstSegment = true;\n\n    // After the first segment, we want nextSize to equal the total size allocated so far.\n    if (allocationStrategy == AllocationStrategy::GROW_HEURISTICALLY) nextSize = size;\n  } else {\n    MoreSegments* segments;\n    KJ_IF_MAYBE(s, moreSegments) {\n      segments = *s;\n    } else {\n      auto newSegments = kj::heap<MoreSegments>();\n      segments = newSegments;\n      moreSegments = mv(newSegments);\n    }\n    segments->segments.push_back(result);\n    if (allocationStrategy == AllocationStrategy::GROW_HEURISTICALLY) nextSize += size;\n  }"
  },
  {
    "function_name": "MallocMessageBuilder::~MallocMessageBuilder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "167-187",
    "snippet": "MallocMessageBuilder::~MallocMessageBuilder() noexcept(false) {\n  if (returnedFirstSegment) {\n    if (ownFirstSegment) {\n      free(firstSegment);\n    } else {\n      // Must zero first segment.\n      kj::ArrayPtr<const kj::ArrayPtr<const word>> segments = getSegmentsForOutput();\n      if (segments.size() > 0) {\n        KJ_ASSERT(segments[0].begin() == firstSegment,\n            \"First segment in getSegmentsForOutput() is not the first segment allocated?\");\n        memset(firstSegment, 0, segments[0].size() * sizeof(word));\n      }\n    }\n\n    KJ_IF_MAYBE(s, moreSegments) {\n      for (void* ptr: s->get()->segments) {\n        free(ptr);\n      }\n    }\n  }\n}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ptr"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s->get",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "firstSegment",
            "0",
            "segments[0].size() * sizeof(word)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segments[0].size",
          "args": [],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "segments[0].begin() == firstSegment",
            "\"First segment in getSegmentsForOutput() is not the first segment allocated?\""
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segments[0].begin",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "getSegmentsForOutput",
          "args": [],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "MessageBuilder::getSegmentsForOutput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
          "lines": "103-109",
          "snippet": "kj::ArrayPtr<const kj::ArrayPtr<const word>> MessageBuilder::getSegmentsForOutput() {\n  if (allocatedArena) {\n    return arena()->getSegmentsForOutput();\n  } else {\n    return nullptr;\n  }\n}",
          "includes": [
            "#include <errno.h>",
            "#include <vector>",
            "#include <string>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"orphan.h\"",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"message.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nkj::ArrayPtr<const kj::ArrayPtr<const word>> MessageBuilder::getSegmentsForOutput() {\n  if (allocatedArena) {\n    return arena()->getSegmentsForOutput();\n  } else {\n    return nullptr;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "firstSegment"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nMallocMessageBuilder::~MallocMessageBuilder() noexcept(false) {\n  if (returnedFirstSegment) {\n    if (ownFirstSegment) {\n      free(firstSegment);\n    } else {\n      // Must zero first segment.\n      kj::ArrayPtr<const kj::ArrayPtr<const word>> segments = getSegmentsForOutput();\n      if (segments.size() > 0) {\n        KJ_ASSERT(segments[0].begin() == firstSegment,\n            \"First segment in getSegmentsForOutput() is not the first segment allocated?\");\n        memset(firstSegment, 0, segments[0].size() * sizeof(word));\n      }\n    }\n\n    KJ_IF_MAYBE(s, moreSegments) {\n      for (void* ptr: s->get()->segments) {\n        free(ptr);\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "MallocMessageBuilder::MallocMessageBuilder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "156-165",
    "snippet": "MallocMessageBuilder::MallocMessageBuilder(\n    kj::ArrayPtr<word> firstSegment, AllocationStrategy allocationStrategy)\n    : nextSize(firstSegment.size()), allocationStrategy(allocationStrategy),\n      ownFirstSegment(false), returnedFirstSegment(false), firstSegment(firstSegment.begin()) {\n  KJ_REQUIRE(firstSegment.size() > 0, \"First segment size must be non-zero.\");\n\n  // Checking just the first word should catch most cases of failing to zero the segment.\n  KJ_REQUIRE(*reinterpret_cast<uint64_t*>(firstSegment.begin()) == 0,\n          \"First segment must be zeroed.\");\n}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "*reinterpret_cast<uint64_t*>(firstSegment.begin()) == 0",
            "\"First segment must be zeroed.\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<uint64_t*>",
          "args": [
            "firstSegment.begin()"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "firstSegment.begin",
          "args": [],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "firstSegment.size() > 0",
            "\"First segment size must be non-zero.\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "firstSegment.size",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nMallocMessageBuilder::MallocMessageBuilder(\n    kj::ArrayPtr<word> firstSegment, AllocationStrategy allocationStrategy)\n    : nextSize(firstSegment.size()), allocationStrategy(allocationStrategy),\n      ownFirstSegment(false), returnedFirstSegment(false), firstSegment(firstSegment.begin()) {\n  KJ_REQUIRE(firstSegment.size() > 0, \"First segment size must be non-zero.\");\n\n  // Checking just the first word should catch most cases of failing to zero the segment.\n  KJ_REQUIRE(*reinterpret_cast<uint64_t*>(firstSegment.begin()) == 0,\n          \"First segment must be zeroed.\");\n}"
  },
  {
    "function_name": "MallocMessageBuilder::MallocMessageBuilder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "151-154",
    "snippet": "MallocMessageBuilder::MallocMessageBuilder(\n    uint firstSegmentWords, AllocationStrategy allocationStrategy)\n    : nextSize(firstSegmentWords), allocationStrategy(allocationStrategy),\n      ownFirstSegment(true), returnedFirstSegment(false), firstSegment(nullptr) {}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nMallocMessageBuilder::MallocMessageBuilder(\n    uint firstSegmentWords, AllocationStrategy allocationStrategy)\n    : nextSize(firstSegmentWords), allocationStrategy(allocationStrategy),\n      ownFirstSegment(true), returnedFirstSegment(false), firstSegment(nullptr) {}"
  },
  {
    "function_name": "SegmentArrayMessageReader::getSegment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "137-143",
    "snippet": "kj::ArrayPtr<const word> SegmentArrayMessageReader::getSegment(uint id) {\n  if (id < segments.size()) {\n    return segments[id];\n  } else {\n    return nullptr;\n  }\n}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "segments.size",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nkj::ArrayPtr<const word> SegmentArrayMessageReader::getSegment(uint id) {\n  if (id < segments.size()) {\n    return segments[id];\n  } else {\n    return nullptr;\n  }\n}"
  },
  {
    "function_name": "SegmentArrayMessageReader::~SegmentArrayMessageReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "135-135",
    "snippet": "SegmentArrayMessageReader::~SegmentArrayMessageReader() noexcept(false) {}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nSegmentArrayMessageReader::~SegmentArrayMessageReader() noexcept(false) {}"
  },
  {
    "function_name": "SegmentArrayMessageReader::SegmentArrayMessageReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "131-133",
    "snippet": "SegmentArrayMessageReader::SegmentArrayMessageReader(\n    kj::ArrayPtr<const kj::ArrayPtr<const word>> segments, ReaderOptions options)\n    : MessageReader(options), segments(segments) {}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nSegmentArrayMessageReader::SegmentArrayMessageReader(\n    kj::ArrayPtr<const kj::ArrayPtr<const word>> segments, ReaderOptions options)\n    : MessageReader(options), segments(segments) {}"
  },
  {
    "function_name": "MessageBuilder::getOrphanage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "121-127",
    "snippet": "Orphanage MessageBuilder::getOrphanage() {\n  // We must ensure that the arena and root pointer have been allocated before the Orphanage\n  // can be used.\n  if (!allocatedArena) getRootSegment();\n\n  return Orphanage(arena());\n}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Orphanage",
          "args": [
            "arena()"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "Orphanage",
          "container": "Orphanage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/orphan.h",
          "lines": "160-160",
          "snippet": "inline explicit Orphanage(_::BuilderArena* arena): arena(arena) {}",
          "includes": [
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n\nOrphanage {\n  inline explicit Orphanage(_::BuilderArena* arena): arena(arena) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "arena",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getRootSegment",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nOrphanage MessageBuilder::getOrphanage() {\n  // We must ensure that the arena and root pointer have been allocated before the Orphanage\n  // can be used.\n  if (!allocatedArena) getRootSegment();\n\n  return Orphanage(arena());\n}"
  },
  {
    "function_name": "MessageBuilder::getCapTable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "112-118",
    "snippet": "kj::ArrayPtr<kj::Maybe<kj::Own<ClientHook>>> MessageBuilder::getCapTable() {\n  if (allocatedArena) {\n    return arena()->getCapTable();\n  } else {\n    return nullptr;\n  }\n}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arena",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nkj::ArrayPtr<kj::Maybe<kj::Own<ClientHook>>> MessageBuilder::getCapTable() {\n  if (allocatedArena) {\n    return arena()->getCapTable();\n  } else {\n    return nullptr;\n  }\n}"
  },
  {
    "function_name": "MessageBuilder::getSegmentsForOutput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "103-109",
    "snippet": "kj::ArrayPtr<const kj::ArrayPtr<const word>> MessageBuilder::getSegmentsForOutput() {\n  if (allocatedArena) {\n    return arena()->getSegmentsForOutput();\n  } else {\n    return nullptr;\n  }\n}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arena",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nkj::ArrayPtr<const kj::ArrayPtr<const word>> MessageBuilder::getSegmentsForOutput() {\n  if (allocatedArena) {\n    return arena()->getSegmentsForOutput();\n  } else {\n    return nullptr;\n  }\n}"
  },
  {
    "function_name": "MessageBuilder::getRootInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "97-101",
    "snippet": "AnyPointer::Builder MessageBuilder::getRootInternal() {\n  _::SegmentBuilder* rootSegment = getRootSegment();\n  return AnyPointer::Builder(_::PointerBuilder::getRoot(\n      rootSegment, rootSegment->getPtrUnchecked(0 * WORDS)));\n}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AnyPointer::Builder",
          "args": [
            "_::PointerBuilder::getRoot(\n      rootSegment, rootSegment->getPtrUnchecked(0 * WORDS))"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_::PointerBuilder::getRoot",
          "args": [
            "rootSegment",
            "rootSegment->getPtrUnchecked(0 * WORDS)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rootSegment->getPtrUnchecked",
          "args": [
            "0 * WORDS"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getRootSegment",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nAnyPointer::Builder MessageBuilder::getRootInternal() {\n  _::SegmentBuilder* rootSegment = getRootSegment();\n  return AnyPointer::Builder(_::PointerBuilder::getRoot(\n      rootSegment, rootSegment->getPtrUnchecked(0 * WORDS)));\n}"
  },
  {
    "function_name": "MessageBuilder::MessageBuilder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "72-76",
    "snippet": "MessageBuilder::MessageBuilder(kj::ArrayPtr<SegmentInit> segments)\n    : allocatedArena(false) {\n  kj::ctor(*arena(), this, segments);\n  allocatedArena = true;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::ctor",
          "args": [
            "*arena()",
            "this",
            "segments"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nMessageBuilder::MessageBuilder(kj::ArrayPtr<SegmentInit> segments)\n    : allocatedArena(false) {\n  kj::ctor(*arena(), this, segments);\n  allocatedArena = true;\n}"
  },
  {
    "function_name": "MessageBuilder::~MessageBuilder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "66-70",
    "snippet": "MessageBuilder::~MessageBuilder() noexcept(false) {\n  if (allocatedArena) {\n    kj::dtor(*arena());\n  }\n}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::dtor",
          "args": [
            "*arena()"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "dtor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "738-740",
          "snippet": "inline void dtor(T& location) {\n  location.~T();\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline void dtor(T& location) {\n  location.~T();\n}"
        }
      },
      {
        "call_info": {
          "callee": "arena",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nMessageBuilder::~MessageBuilder() noexcept(false) {\n  if (allocatedArena) {\n    kj::dtor(*arena());\n  }\n}"
  },
  {
    "function_name": "MessageBuilder::MessageBuilder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "64-64",
    "snippet": "MessageBuilder::MessageBuilder(): allocatedArena(false) {}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nMessageBuilder::MessageBuilder(): allocatedArena(false) {}"
  },
  {
    "function_name": "MessageReader::getRootInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "42-60",
    "snippet": "AnyPointer::Reader MessageReader::getRootInternal() {\n  if (!allocatedArena) {\n    static_assert(sizeof(_::ReaderArena) <= sizeof(arenaSpace),\n        \"arenaSpace is too small to hold a ReaderArena.  Please increase it.  This will break \"\n        \"ABI compatibility.\");\n    new(arena()) _::ReaderArena(this);\n    allocatedArena = true;\n  }\n\n  _::SegmentReader* segment = arena()->tryGetSegment(_::SegmentId(0));\n  KJ_REQUIRE(segment != nullptr &&\n             segment->containsInterval(segment->getStartPtr(), segment->getStartPtr() + 1),\n             \"Message did not contain a root pointer.\") {\n    return AnyPointer::Reader();\n  }\n\n  return AnyPointer::Reader(_::PointerReader::getRoot(\n      segment, segment->getStartPtr(), options.nestingLimit));\n}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AnyPointer::Reader",
          "args": [
            "_::PointerReader::getRoot(\n      segment, segment->getStartPtr(), options.nestingLimit)"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "Reader",
          "container": "AnyPointer::Reader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "88-88",
          "snippet": "inline Reader(_::PointerReader reader): reader(reader) {}",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Reader {\n    inline Reader(_::PointerReader reader): reader(reader) {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_::PointerReader::getRoot",
          "args": [
            "segment",
            "segment->getStartPtr()",
            "options.nestingLimit"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getStartPtr",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AnyPointer::Reader",
          "args": [],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "AnyPointer::Reader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "97-99",
          "snippet": "inline bool isList() {\n      return reader.isList();\n    }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Reader {\n    inline bool isList() {\n          return reader.isList();\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "segment != nullptr &&\n             segment->containsInterval(segment->getStartPtr(), segment->getStartPtr() + 1)",
            "\"Message did not contain a root pointer.\""
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->containsInterval",
          "args": [
            "segment->getStartPtr()",
            "segment->getStartPtr() + 1"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getStartPtr",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getStartPtr",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena",
          "args": [
            "_::SegmentId(0)"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::SegmentId",
          "args": [
            "0"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena",
          "args": [],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena",
          "args": [],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nAnyPointer::Reader MessageReader::getRootInternal() {\n  if (!allocatedArena) {\n    static_assert(sizeof(_::ReaderArena) <= sizeof(arenaSpace),\n        \"arenaSpace is too small to hold a ReaderArena.  Please increase it.  This will break \"\n        \"ABI compatibility.\");\n    new(arena()) _::ReaderArena(this);\n    allocatedArena = true;\n  }\n\n  _::SegmentReader* segment = arena()->tryGetSegment(_::SegmentId(0));\n  KJ_REQUIRE(segment != nullptr &&\n             segment->containsInterval(segment->getStartPtr(), segment->getStartPtr() + 1),\n             \"Message did not contain a root pointer.\") {\n    return AnyPointer::Reader();\n  }\n\n  return AnyPointer::Reader(_::PointerReader::getRoot(\n      segment, segment->getStartPtr(), options.nestingLimit));\n}"
  },
  {
    "function_name": "MessageReader::~MessageReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "36-40",
    "snippet": "MessageReader::~MessageReader() noexcept(false) {\n  if (allocatedArena) {\n    arena()->~ReaderArena();\n  }\n}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arena",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nMessageReader::~MessageReader() noexcept(false) {\n  if (allocatedArena) {\n    arena()->~ReaderArena();\n  }\n}"
  },
  {
    "function_name": "MessageReader::MessageReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.c++",
    "lines": "35-35",
    "snippet": "MessageReader::MessageReader(ReaderOptions options): options(options), allocatedArena(false) {}",
    "includes": [
      "#include <errno.h>",
      "#include <vector>",
      "#include <string>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"orphan.h\"",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"message.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <vector>\n#include <string>\n#include <exception>\n#include <stdlib.h>\n#include \"orphan.h\"\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"message.h\"\n\nMessageReader::MessageReader(ReaderOptions options): options(options), allocatedArena(false) {}"
  }
]