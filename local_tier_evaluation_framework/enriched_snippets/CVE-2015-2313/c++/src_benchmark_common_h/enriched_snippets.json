[
  {
    "function_name": "benchmarkMain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
    "lines": "281-292",
    "snippet": "int benchmarkMain(int argc, char* argv[]) {\n  if (argc != 5) {\n    fprintf(stderr, \"USAGE:  %s MODE REUSE COMPRESSION ITERATION_COUNT\\n\", argv[0]);\n    return 1;\n  }\n\n  uint64_t iters = strtoull(argv[4], nullptr, 0);\n  uint64_t throughput = doBenchmark3<BenchmarkTypes, TestCase>(argv[1], argv[2], argv[3], iters);\n  fprintf(stdout, \"%llu\\n\", (long long unsigned int)throughput);\n\n  return 0;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdexcept>",
      "#include <algorithm>",
      "#include <semaphore.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <limits>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%llu\\n\"",
            "(long long unsigned int)throughput"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "doBenchmark3<BenchmarkTypes, TestCase>",
          "args": [
            "argv[1]",
            "argv[2]",
            "argv[3]",
            "iters"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "doBenchmark3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "261-278",
          "snippet": "uint64_t doBenchmark3(const std::string& mode, const std::string& reuse,\n                      const std::string& compression, uint64_t iters) {\n  if (compression == \"none\") {\n    return doBenchmark2<BenchmarkTypes, TestCase, typename BenchmarkTypes::Uncompressed>(\n        mode, reuse, iters);\n  } else if (compression == \"packed\") {\n    return doBenchmark2<BenchmarkTypes, TestCase, typename BenchmarkTypes::Packed>(\n        mode, reuse, iters);\n#if HAVE_SNAPPY\n  } else if (compression == \"snappy\") {\n    return doBenchmark2<BenchmarkTypes, TestCase, typename BenchmarkTypes::SnappyCompressed>(\n        mode, reuse, iters);\n#endif  // HAVE_SNAPPY\n  } else {\n    fprintf(stderr, \"Unknown compression mode: %s\\n\", compression.c_str());\n    exit(1);\n  }\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nuint64_t doBenchmark3(const std::string& mode, const std::string& reuse,\n                      const std::string& compression, uint64_t iters) {\n  if (compression == \"none\") {\n    return doBenchmark2<BenchmarkTypes, TestCase, typename BenchmarkTypes::Uncompressed>(\n        mode, reuse, iters);\n  } else if (compression == \"packed\") {\n    return doBenchmark2<BenchmarkTypes, TestCase, typename BenchmarkTypes::Packed>(\n        mode, reuse, iters);\n#if HAVE_SNAPPY\n  } else if (compression == \"snappy\") {\n    return doBenchmark2<BenchmarkTypes, TestCase, typename BenchmarkTypes::SnappyCompressed>(\n        mode, reuse, iters);\n#endif  // HAVE_SNAPPY\n  } else {\n    fprintf(stderr, \"Unknown compression mode: %s\\n\", compression.c_str());\n    exit(1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoull",
          "args": [
            "argv[4]",
            "nullptr",
            "0"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"USAGE:  %s MODE REUSE COMPRESSION ITERATION_COUNT\\n\"",
            "argv[0]"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nint benchmarkMain(int argc, char* argv[]) {\n  if (argc != 5) {\n    fprintf(stderr, \"USAGE:  %s MODE REUSE COMPRESSION ITERATION_COUNT\\n\", argv[0]);\n    return 1;\n  }\n\n  uint64_t iters = strtoull(argv[4], nullptr, 0);\n  uint64_t throughput = doBenchmark3<BenchmarkTypes, TestCase>(argv[1], argv[2], argv[3], iters);\n  fprintf(stdout, \"%llu\\n\", (long long unsigned int)throughput);\n\n  return 0;\n}"
  },
  {
    "function_name": "doBenchmark3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
    "lines": "261-278",
    "snippet": "uint64_t doBenchmark3(const std::string& mode, const std::string& reuse,\n                      const std::string& compression, uint64_t iters) {\n  if (compression == \"none\") {\n    return doBenchmark2<BenchmarkTypes, TestCase, typename BenchmarkTypes::Uncompressed>(\n        mode, reuse, iters);\n  } else if (compression == \"packed\") {\n    return doBenchmark2<BenchmarkTypes, TestCase, typename BenchmarkTypes::Packed>(\n        mode, reuse, iters);\n#if HAVE_SNAPPY\n  } else if (compression == \"snappy\") {\n    return doBenchmark2<BenchmarkTypes, TestCase, typename BenchmarkTypes::SnappyCompressed>(\n        mode, reuse, iters);\n#endif  // HAVE_SNAPPY\n  } else {\n    fprintf(stderr, \"Unknown compression mode: %s\\n\", compression.c_str());\n    exit(1);\n  }\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdexcept>",
      "#include <algorithm>",
      "#include <semaphore.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <limits>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Unknown compression mode: %s\\n\"",
            "compression.c_str()"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compression.c_str",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "doBenchmark2<BenchmarkTypes, TestCase, typename BenchmarkTypes::SnappyCompressed>",
          "args": [
            "mode",
            "reuse",
            "iters"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "doBenchmark2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "245-258",
          "snippet": "uint64_t doBenchmark2(const std::string& mode, const std::string& reuse, uint64_t iters) {\n  if (reuse == \"reuse\") {\n    return doBenchmark<\n        BenchmarkTypes, TestCase, typename BenchmarkTypes::ReusableResources, Compression>(\n            mode, iters);\n  } else if (reuse == \"no-reuse\") {\n    return doBenchmark<\n        BenchmarkTypes, TestCase, typename BenchmarkTypes::SingleUseResources, Compression>(\n            mode, iters);\n  } else {\n    fprintf(stderr, \"Unknown reuse mode: %s\\n\", reuse.c_str());\n    exit(1);\n  }\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nuint64_t doBenchmark2(const std::string& mode, const std::string& reuse, uint64_t iters) {\n  if (reuse == \"reuse\") {\n    return doBenchmark<\n        BenchmarkTypes, TestCase, typename BenchmarkTypes::ReusableResources, Compression>(\n            mode, iters);\n  } else if (reuse == \"no-reuse\") {\n    return doBenchmark<\n        BenchmarkTypes, TestCase, typename BenchmarkTypes::SingleUseResources, Compression>(\n            mode, iters);\n  } else {\n    fprintf(stderr, \"Unknown reuse mode: %s\\n\", reuse.c_str());\n    exit(1);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nuint64_t doBenchmark3(const std::string& mode, const std::string& reuse,\n                      const std::string& compression, uint64_t iters) {\n  if (compression == \"none\") {\n    return doBenchmark2<BenchmarkTypes, TestCase, typename BenchmarkTypes::Uncompressed>(\n        mode, reuse, iters);\n  } else if (compression == \"packed\") {\n    return doBenchmark2<BenchmarkTypes, TestCase, typename BenchmarkTypes::Packed>(\n        mode, reuse, iters);\n#if HAVE_SNAPPY\n  } else if (compression == \"snappy\") {\n    return doBenchmark2<BenchmarkTypes, TestCase, typename BenchmarkTypes::SnappyCompressed>(\n        mode, reuse, iters);\n#endif  // HAVE_SNAPPY\n  } else {\n    fprintf(stderr, \"Unknown compression mode: %s\\n\", compression.c_str());\n    exit(1);\n  }\n}"
  },
  {
    "function_name": "doBenchmark2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
    "lines": "245-258",
    "snippet": "uint64_t doBenchmark2(const std::string& mode, const std::string& reuse, uint64_t iters) {\n  if (reuse == \"reuse\") {\n    return doBenchmark<\n        BenchmarkTypes, TestCase, typename BenchmarkTypes::ReusableResources, Compression>(\n            mode, iters);\n  } else if (reuse == \"no-reuse\") {\n    return doBenchmark<\n        BenchmarkTypes, TestCase, typename BenchmarkTypes::SingleUseResources, Compression>(\n            mode, iters);\n  } else {\n    fprintf(stderr, \"Unknown reuse mode: %s\\n\", reuse.c_str());\n    exit(1);\n  }\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdexcept>",
      "#include <algorithm>",
      "#include <semaphore.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <limits>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Unknown reuse mode: %s\\n\"",
            "reuse.c_str()"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reuse.c_str",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "doBenchmark<\n        BenchmarkTypes, TestCase, typename BenchmarkTypes::SingleUseResources, Compression>",
          "args": [
            "mode",
            "iters"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "doBenchmark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "221-242",
          "snippet": "uint64_t doBenchmark(const std::string& mode, uint64_t iters) {\n  typedef typename BenchmarkTypes::template BenchmarkMethods<TestCase, Reuse, Compression>\n      BenchmarkMethods;\n  if (mode == \"client\") {\n    return BenchmarkMethods::syncClient(STDIN_FILENO, STDOUT_FILENO, iters);\n  } else if (mode == \"server\") {\n    return BenchmarkMethods::server(STDIN_FILENO, STDOUT_FILENO, iters);\n  } else if (mode == \"object\") {\n    return BenchmarkMethods::passByObject(iters, false);\n  } else if (mode == \"object-size\") {\n    return BenchmarkMethods::passByObject(iters, true);\n  } else if (mode == \"bytes\") {\n    return BenchmarkMethods::passByBytes(iters);\n  } else if (mode == \"pipe\") {\n    return passByPipe<BenchmarkMethods>(BenchmarkMethods::syncClient, iters);\n  } else if (mode == \"pipe-async\") {\n    return passByPipe<BenchmarkMethods>(BenchmarkMethods::asyncClient, iters);\n  } else {\n    fprintf(stderr, \"Unknown mode: %s\\n\", mode.c_str());\n    exit(1);\n  }\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nuint64_t doBenchmark(const std::string& mode, uint64_t iters) {\n  typedef typename BenchmarkTypes::template BenchmarkMethods<TestCase, Reuse, Compression>\n      BenchmarkMethods;\n  if (mode == \"client\") {\n    return BenchmarkMethods::syncClient(STDIN_FILENO, STDOUT_FILENO, iters);\n  } else if (mode == \"server\") {\n    return BenchmarkMethods::server(STDIN_FILENO, STDOUT_FILENO, iters);\n  } else if (mode == \"object\") {\n    return BenchmarkMethods::passByObject(iters, false);\n  } else if (mode == \"object-size\") {\n    return BenchmarkMethods::passByObject(iters, true);\n  } else if (mode == \"bytes\") {\n    return BenchmarkMethods::passByBytes(iters);\n  } else if (mode == \"pipe\") {\n    return passByPipe<BenchmarkMethods>(BenchmarkMethods::syncClient, iters);\n  } else if (mode == \"pipe-async\") {\n    return passByPipe<BenchmarkMethods>(BenchmarkMethods::asyncClient, iters);\n  } else {\n    fprintf(stderr, \"Unknown mode: %s\\n\", mode.c_str());\n    exit(1);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nuint64_t doBenchmark2(const std::string& mode, const std::string& reuse, uint64_t iters) {\n  if (reuse == \"reuse\") {\n    return doBenchmark<\n        BenchmarkTypes, TestCase, typename BenchmarkTypes::ReusableResources, Compression>(\n            mode, iters);\n  } else if (reuse == \"no-reuse\") {\n    return doBenchmark<\n        BenchmarkTypes, TestCase, typename BenchmarkTypes::SingleUseResources, Compression>(\n            mode, iters);\n  } else {\n    fprintf(stderr, \"Unknown reuse mode: %s\\n\", reuse.c_str());\n    exit(1);\n  }\n}"
  },
  {
    "function_name": "doBenchmark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
    "lines": "221-242",
    "snippet": "uint64_t doBenchmark(const std::string& mode, uint64_t iters) {\n  typedef typename BenchmarkTypes::template BenchmarkMethods<TestCase, Reuse, Compression>\n      BenchmarkMethods;\n  if (mode == \"client\") {\n    return BenchmarkMethods::syncClient(STDIN_FILENO, STDOUT_FILENO, iters);\n  } else if (mode == \"server\") {\n    return BenchmarkMethods::server(STDIN_FILENO, STDOUT_FILENO, iters);\n  } else if (mode == \"object\") {\n    return BenchmarkMethods::passByObject(iters, false);\n  } else if (mode == \"object-size\") {\n    return BenchmarkMethods::passByObject(iters, true);\n  } else if (mode == \"bytes\") {\n    return BenchmarkMethods::passByBytes(iters);\n  } else if (mode == \"pipe\") {\n    return passByPipe<BenchmarkMethods>(BenchmarkMethods::syncClient, iters);\n  } else if (mode == \"pipe-async\") {\n    return passByPipe<BenchmarkMethods>(BenchmarkMethods::asyncClient, iters);\n  } else {\n    fprintf(stderr, \"Unknown mode: %s\\n\", mode.c_str());\n    exit(1);\n  }\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdexcept>",
      "#include <algorithm>",
      "#include <semaphore.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <limits>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Unknown mode: %s\\n\"",
            "mode.c_str()"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mode.c_str",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "passByPipe<BenchmarkMethods>",
          "args": [
            "BenchmarkMethods::asyncClient",
            "iters"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "passByPipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "181-218",
          "snippet": "uint64_t passByPipe(Func&& clientFunc, uint64_t iters) {\n  int clientToServer[2];\n  int serverToClient[2];\n  if (pipe(clientToServer) < 0) throw OsException(errno);\n  if (pipe(serverToClient) < 0) throw OsException(errno);\n\n  pid_t child = fork();\n  if (child == 0) {\n    // Client.\n    close(clientToServer[0]);\n    close(serverToClient[1]);\n\n    uint64_t throughput = clientFunc(serverToClient[0], clientToServer[1], iters);\n    writeAll(clientToServer[1], &throughput, sizeof(throughput));\n\n    exit(0);\n  } else {\n    // Server.\n    close(clientToServer[1]);\n    close(serverToClient[0]);\n\n    uint64_t throughput = BenchmarkMethods::server(clientToServer[0], serverToClient[1], iters);\n\n    uint64_t clientThroughput = 0;\n    readAll(clientToServer[0], &clientThroughput, sizeof(clientThroughput));\n    throughput += clientThroughput;\n\n    int status;\n    if (waitpid(child, &status, 0) != child) {\n      throw OsException(errno);\n    }\n    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {\n      throw std::logic_error(\"Child exited abnormally.\");\n    }\n\n    return throughput;\n  }\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nuint64_t passByPipe(Func&& clientFunc, uint64_t iters) {\n  int clientToServer[2];\n  int serverToClient[2];\n  if (pipe(clientToServer) < 0) throw OsException(errno);\n  if (pipe(serverToClient) < 0) throw OsException(errno);\n\n  pid_t child = fork();\n  if (child == 0) {\n    // Client.\n    close(clientToServer[0]);\n    close(serverToClient[1]);\n\n    uint64_t throughput = clientFunc(serverToClient[0], clientToServer[1], iters);\n    writeAll(clientToServer[1], &throughput, sizeof(throughput));\n\n    exit(0);\n  } else {\n    // Server.\n    close(clientToServer[1]);\n    close(serverToClient[0]);\n\n    uint64_t throughput = BenchmarkMethods::server(clientToServer[0], serverToClient[1], iters);\n\n    uint64_t clientThroughput = 0;\n    readAll(clientToServer[0], &clientThroughput, sizeof(clientThroughput));\n    throughput += clientThroughput;\n\n    int status;\n    if (waitpid(child, &status, 0) != child) {\n      throw OsException(errno);\n    }\n    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {\n      throw std::logic_error(\"Child exited abnormally.\");\n    }\n\n    return throughput;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BenchmarkMethods::passByBytes",
          "args": [
            "iters"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "passByBytes",
          "container": "BenchmarkMethods",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "152-155",
          "snippet": "static uint64_t passByBytes(uint64_t iters) {\n    fprintf(stderr, \"Null benchmark doesn't do I/O.\\n\");\n    exit(1);\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nBenchmarkMethods {\n  static uint64_t passByBytes(uint64_t iters) {\n      fprintf(stderr, \"Null benchmark doesn't do I/O.\\n\");\n      exit(1);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BenchmarkMethods::passByObject",
          "args": [
            "iters",
            "true"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "passByObject",
          "container": "BenchmarkMethods",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "272-297",
          "snippet": "static uint64_t passByObject(uint64_t iters, bool countObjectSize) {\n    uint64_t throughput = 0;\n\n    REUSABLE(Request) reusableRequest;\n    REUSABLE(Response) reusableResponse;\n\n    for (; iters > 0; --iters) {\n      SINGLE_USE(Request) request(reusableRequest);\n      typename TestCase::Expectation expected = TestCase::setupRequest(&request);\n\n      SINGLE_USE(Response) response(reusableResponse);\n      TestCase::handleRequest(request, &response);\n      ReuseStrategy::doneWith(request);\n      if (!TestCase::checkResponse(response, expected)) {\n        throw std::logic_error(\"Incorrect response.\");\n      }\n      ReuseStrategy::doneWith(response);\n\n      if (countObjectSize) {\n        throughput += request.SpaceUsed();\n        throughput += response.SpaceUsed();\n      }\n    }\n\n    return throughput;\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nBenchmarkMethods {\n  static uint64_t passByObject(uint64_t iters, bool countObjectSize) {\n      uint64_t throughput = 0;\n  \n      REUSABLE(Request) reusableRequest;\n      REUSABLE(Response) reusableResponse;\n  \n      for (; iters > 0; --iters) {\n        SINGLE_USE(Request) request(reusableRequest);\n        typename TestCase::Expectation expected = TestCase::setupRequest(&request);\n  \n        SINGLE_USE(Response) response(reusableResponse);\n        TestCase::handleRequest(request, &response);\n        ReuseStrategy::doneWith(request);\n        if (!TestCase::checkResponse(response, expected)) {\n          throw std::logic_error(\"Incorrect response.\");\n        }\n        ReuseStrategy::doneWith(response);\n  \n        if (countObjectSize) {\n          throughput += request.SpaceUsed();\n          throughput += response.SpaceUsed();\n        }\n      }\n  \n      return throughput;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BenchmarkMethods::server",
          "args": [
            "STDIN_FILENO",
            "STDOUT_FILENO",
            "iters"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "server",
          "container": "BenchmarkMethods",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "126-129",
          "snippet": "static uint64_t server(int inputFd, int outputFd, uint64_t iters) {\n    fprintf(stderr, \"Null benchmark doesn't do I/O.\\n\");\n    exit(1);\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nBenchmarkMethods {\n  static uint64_t server(int inputFd, int outputFd, uint64_t iters) {\n      fprintf(stderr, \"Null benchmark doesn't do I/O.\\n\");\n      exit(1);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BenchmarkMethods::syncClient",
          "args": [
            "STDIN_FILENO",
            "STDOUT_FILENO",
            "iters"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "syncClient",
          "container": "BenchmarkMethods",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "102-105",
          "snippet": "static uint64_t syncClient(int inputFd, int outputFd, uint64_t iters) {\n    fprintf(stderr, \"Null benchmark doesn't do I/O.\\n\");\n    exit(1);\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nBenchmarkMethods {\n  static uint64_t syncClient(int inputFd, int outputFd, uint64_t iters) {\n      fprintf(stderr, \"Null benchmark doesn't do I/O.\\n\");\n      exit(1);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nuint64_t doBenchmark(const std::string& mode, uint64_t iters) {\n  typedef typename BenchmarkTypes::template BenchmarkMethods<TestCase, Reuse, Compression>\n      BenchmarkMethods;\n  if (mode == \"client\") {\n    return BenchmarkMethods::syncClient(STDIN_FILENO, STDOUT_FILENO, iters);\n  } else if (mode == \"server\") {\n    return BenchmarkMethods::server(STDIN_FILENO, STDOUT_FILENO, iters);\n  } else if (mode == \"object\") {\n    return BenchmarkMethods::passByObject(iters, false);\n  } else if (mode == \"object-size\") {\n    return BenchmarkMethods::passByObject(iters, true);\n  } else if (mode == \"bytes\") {\n    return BenchmarkMethods::passByBytes(iters);\n  } else if (mode == \"pipe\") {\n    return passByPipe<BenchmarkMethods>(BenchmarkMethods::syncClient, iters);\n  } else if (mode == \"pipe-async\") {\n    return passByPipe<BenchmarkMethods>(BenchmarkMethods::asyncClient, iters);\n  } else {\n    fprintf(stderr, \"Unknown mode: %s\\n\", mode.c_str());\n    exit(1);\n  }\n}"
  },
  {
    "function_name": "passByPipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
    "lines": "181-218",
    "snippet": "uint64_t passByPipe(Func&& clientFunc, uint64_t iters) {\n  int clientToServer[2];\n  int serverToClient[2];\n  if (pipe(clientToServer) < 0) throw OsException(errno);\n  if (pipe(serverToClient) < 0) throw OsException(errno);\n\n  pid_t child = fork();\n  if (child == 0) {\n    // Client.\n    close(clientToServer[0]);\n    close(serverToClient[1]);\n\n    uint64_t throughput = clientFunc(serverToClient[0], clientToServer[1], iters);\n    writeAll(clientToServer[1], &throughput, sizeof(throughput));\n\n    exit(0);\n  } else {\n    // Server.\n    close(clientToServer[1]);\n    close(serverToClient[0]);\n\n    uint64_t throughput = BenchmarkMethods::server(clientToServer[0], serverToClient[1], iters);\n\n    uint64_t clientThroughput = 0;\n    readAll(clientToServer[0], &clientThroughput, sizeof(clientThroughput));\n    throughput += clientThroughput;\n\n    int status;\n    if (waitpid(child, &status, 0) != child) {\n      throw OsException(errno);\n    }\n    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {\n      throw std::logic_error(\"Child exited abnormally.\");\n    }\n\n    return throughput;\n  }\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdexcept>",
      "#include <algorithm>",
      "#include <semaphore.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <limits>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::logic_error",
          "args": [
            "\"Child exited abnormally.\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OsException",
          "args": [
            "errno"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "OsException",
          "container": "OsException",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "145-145",
          "snippet": "OsException(int error): error(error) {}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nOsException {\n  OsException(int error): error(error) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "&status",
            "0"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readAll",
          "args": [
            "clientToServer[0]",
            "&clientThroughput",
            "sizeof(clientThroughput)"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "readAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "168-178",
          "snippet": "static void readAll(int fd, void* buffer, size_t size) {\n  char* pos = reinterpret_cast<char*>(buffer);\n  while (size > 0) {\n    ssize_t n = read(fd, pos, size);\n    if (n <= 0) {\n      throw OsException(errno);\n    }\n    pos += n;\n    size -= n;\n  }\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nstatic void readAll(int fd, void* buffer, size_t size) {\n  char* pos = reinterpret_cast<char*>(buffer);\n  while (size > 0) {\n    ssize_t n = read(fd, pos, size);\n    if (n <= 0) {\n      throw OsException(errno);\n    }\n    pos += n;\n    size -= n;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BenchmarkMethods::server",
          "args": [
            "clientToServer[0]",
            "serverToClient[1]",
            "iters"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "server",
          "container": "BenchmarkMethods",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "126-129",
          "snippet": "static uint64_t server(int inputFd, int outputFd, uint64_t iters) {\n    fprintf(stderr, \"Null benchmark doesn't do I/O.\\n\");\n    exit(1);\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nBenchmarkMethods {\n  static uint64_t server(int inputFd, int outputFd, uint64_t iters) {\n      fprintf(stderr, \"Null benchmark doesn't do I/O.\\n\");\n      exit(1);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "serverToClient[0]"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "57-59",
          "snippet": "inline int close(int fd) {\n  return ::_close(fd);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int close(int fd) {\n  return ::_close(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeAll",
          "args": [
            "clientToServer[1]",
            "&throughput",
            "sizeof(throughput)"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "writeAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "156-166",
          "snippet": "static void writeAll(int fd, const void* buffer, size_t size) {\n  const char* pos = reinterpret_cast<const char*>(buffer);\n  while (size > 0) {\n    ssize_t n = write(fd, pos, size);\n    if (n <= 0) {\n      throw OsException(errno);\n    }\n    pos += n;\n    size -= n;\n  }\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nstatic void writeAll(int fd, const void* buffer, size_t size) {\n  const char* pos = reinterpret_cast<const char*>(buffer);\n  while (size > 0) {\n    ssize_t n = write(fd, pos, size);\n    if (n <= 0) {\n      throw OsException(errno);\n    }\n    pos += n;\n    size -= n;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "clientFunc",
          "args": [
            "serverToClient[0]",
            "clientToServer[1]",
            "iters"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "Promise<T>::fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "745-747",
          "snippet": "ForkedPromise<T> Promise<T>::fork() {\n  return ForkedPromise<T>(false, refcounted<_::ForkHub<_::FixVoid<T>>>(kj::mv(node)));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkedPromise<T> Promise<T>::fork() {\n  return ForkedPromise<T>(false, refcounted<_::ForkHub<_::FixVoid<T>>>(kj::mv(node)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "serverToClient"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "84-86",
          "snippet": "inline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nuint64_t passByPipe(Func&& clientFunc, uint64_t iters) {\n  int clientToServer[2];\n  int serverToClient[2];\n  if (pipe(clientToServer) < 0) throw OsException(errno);\n  if (pipe(serverToClient) < 0) throw OsException(errno);\n\n  pid_t child = fork();\n  if (child == 0) {\n    // Client.\n    close(clientToServer[0]);\n    close(serverToClient[1]);\n\n    uint64_t throughput = clientFunc(serverToClient[0], clientToServer[1], iters);\n    writeAll(clientToServer[1], &throughput, sizeof(throughput));\n\n    exit(0);\n  } else {\n    // Server.\n    close(clientToServer[1]);\n    close(serverToClient[0]);\n\n    uint64_t throughput = BenchmarkMethods::server(clientToServer[0], serverToClient[1], iters);\n\n    uint64_t clientThroughput = 0;\n    readAll(clientToServer[0], &clientThroughput, sizeof(clientThroughput));\n    throughput += clientThroughput;\n\n    int status;\n    if (waitpid(child, &status, 0) != child) {\n      throw OsException(errno);\n    }\n    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {\n      throw std::logic_error(\"Child exited abnormally.\");\n    }\n\n    return throughput;\n  }\n}"
  },
  {
    "function_name": "readAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
    "lines": "168-178",
    "snippet": "static void readAll(int fd, void* buffer, size_t size) {\n  char* pos = reinterpret_cast<char*>(buffer);\n  while (size > 0) {\n    ssize_t n = read(fd, pos, size);\n    if (n <= 0) {\n      throw OsException(errno);\n    }\n    pos += n;\n    size -= n;\n  }\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdexcept>",
      "#include <algorithm>",
      "#include <semaphore.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <limits>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OsException",
          "args": [
            "errno"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "OsException",
          "container": "OsException",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "145-145",
          "snippet": "OsException(int error): error(error) {}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nOsException {\n  OsException(int error): error(error) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "pos",
            "size"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "Uncompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "101-113",
          "snippet": "static void read(google::protobuf::io::ZeroCopyInputStream* rawInput,\n                   google::protobuf::MessageLite* message) {\n    google::protobuf::io::CodedInputStream input(rawInput);\n    uint32_t size;\n    GOOGLE_CHECK(input.ReadVarint32(&size));\n\n    auto limit = input.PushLimit(size);\n\n    GOOGLE_CHECK(message->MergePartialFromCodedStream(&input) &&\n                 input.ConsumedEntireMessage());\n\n    input.PopLimit(limit);\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nUncompressed {\n  static void read(google::protobuf::io::ZeroCopyInputStream* rawInput,\n                     google::protobuf::MessageLite* message) {\n      google::protobuf::io::CodedInputStream input(rawInput);\n      uint32_t size;\n      GOOGLE_CHECK(input.ReadVarint32(&size));\n  \n      auto limit = input.PushLimit(size);\n  \n      GOOGLE_CHECK(message->MergePartialFromCodedStream(&input) &&\n                   input.ConsumedEntireMessage());\n  \n      input.PopLimit(limit);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<char*>",
          "args": [
            "buffer"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nstatic void readAll(int fd, void* buffer, size_t size) {\n  char* pos = reinterpret_cast<char*>(buffer);\n  while (size > 0) {\n    ssize_t n = read(fd, pos, size);\n    if (n <= 0) {\n      throw OsException(errno);\n    }\n    pos += n;\n    size -= n;\n  }\n}"
  },
  {
    "function_name": "writeAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
    "lines": "156-166",
    "snippet": "static void writeAll(int fd, const void* buffer, size_t size) {\n  const char* pos = reinterpret_cast<const char*>(buffer);\n  while (size > 0) {\n    ssize_t n = write(fd, pos, size);\n    if (n <= 0) {\n      throw OsException(errno);\n    }\n    pos += n;\n    size -= n;\n  }\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdexcept>",
      "#include <algorithm>",
      "#include <semaphore.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <limits>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OsException",
          "args": [
            "errno"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "OsException",
          "container": "OsException",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "145-145",
          "snippet": "OsException(int error): error(error) {}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nOsException {\n  OsException(int error): error(error) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "pos",
            "size"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "Uncompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "83-99",
          "snippet": "static uint64_t write(const google::protobuf::MessageLite& message,\n                        google::protobuf::io::FileOutputStream* rawOutput) {\n    google::protobuf::io::CodedOutputStream output(rawOutput);\n    const int size = message.ByteSize();\n    output.WriteVarint32(size);\n    uint8_t* buffer = output.GetDirectBufferForNBytesAndAdvance(size);\n    if (buffer != NULL) {\n      message.SerializeWithCachedSizesToArray(buffer);\n    } else {\n      message.SerializeWithCachedSizes(&output);\n      if (output.HadError()) {\n        throw OsException(rawOutput->GetErrno());\n      }\n    }\n\n    return size;\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nUncompressed {\n  static uint64_t write(const google::protobuf::MessageLite& message,\n                          google::protobuf::io::FileOutputStream* rawOutput) {\n      google::protobuf::io::CodedOutputStream output(rawOutput);\n      const int size = message.ByteSize();\n      output.WriteVarint32(size);\n      uint8_t* buffer = output.GetDirectBufferForNBytesAndAdvance(size);\n      if (buffer != NULL) {\n        message.SerializeWithCachedSizesToArray(buffer);\n      } else {\n        message.SerializeWithCachedSizes(&output);\n        if (output.HadError()) {\n          throw OsException(rawOutput->GetErrno());\n        }\n      }\n  \n      return size;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const char*>",
          "args": [
            "buffer"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nstatic void writeAll(int fd, const void* buffer, size_t size) {\n  const char* pos = reinterpret_cast<const char*>(buffer);\n  while (size > 0) {\n    ssize_t n = write(fd, pos, size);\n    if (n <= 0) {\n      throw OsException(errno);\n    }\n    pos += n;\n    size -= n;\n  }\n}"
  },
  {
    "function_name": "OsException",
    "container": "OsException",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
    "lines": "145-145",
    "snippet": "OsException(int error): error(error) {}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdexcept>",
      "#include <algorithm>",
      "#include <semaphore.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <limits>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nOsException {\n  OsException(int error): error(error) {}\n}"
  },
  {
    "function_name": "Node",
    "container": "ProducerConsumerQueue::Node",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
    "lines": "134-134",
    "snippet": "Node(T value): value(value), next(nullptr) {}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdexcept>",
      "#include <algorithm>",
      "#include <semaphore.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <limits>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nProducerConsumerQueue {\n  Node {\n    Node(T value): value(value), next(nullptr) {}\n  }\n}"
  },
  {
    "function_name": "Node",
    "container": "ProducerConsumerQueue::Node",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
    "lines": "133-133",
    "snippet": "Node(): next(nullptr) {}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdexcept>",
      "#include <algorithm>",
      "#include <semaphore.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <limits>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nProducerConsumerQueue {\n  Node {\n    Node(): next(nullptr) {}\n  }\n}"
  },
  {
    "function_name": "next",
    "container": "ProducerConsumerQueue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
    "lines": "120-126",
    "snippet": "T next() {\n    sem_wait(&semaphore);\n    Node* oldFront = front;\n    front = front->next;\n    delete oldFront;\n    return front->value;\n  }",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdexcept>",
      "#include <algorithm>",
      "#include <semaphore.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <limits>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sem_wait",
          "args": [
            "&semaphore"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nProducerConsumerQueue {\n  T next() {\n      sem_wait(&semaphore);\n      Node* oldFront = front;\n      front = front->next;\n      delete oldFront;\n      return front->value;\n    }\n}"
  },
  {
    "function_name": "post",
    "container": "ProducerConsumerQueue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
    "lines": "114-118",
    "snippet": "void post(T t) {\n    back->next = new Node(t);\n    back = back->next;\n    sem_post(&semaphore);\n  }",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdexcept>",
      "#include <algorithm>",
      "#include <semaphore.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <limits>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sem_post",
          "args": [
            "&semaphore"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nProducerConsumerQueue {\n  void post(T t) {\n      back->next = new Node(t);\n      back = back->next;\n      sem_post(&semaphore);\n    }\n}"
  },
  {
    "function_name": "ProducerConsumerQueue",
    "container": "ProducerConsumerQueue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
    "lines": "99-103",
    "snippet": "ProducerConsumerQueue() {\n    front = new Node;\n    back = front;\n    sem_init(&semaphore, 0, 0);\n  }",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdexcept>",
      "#include <algorithm>",
      "#include <semaphore.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <limits>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sem_init",
          "args": [
            "&semaphore",
            "0",
            "0"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nProducerConsumerQueue {\n  ProducerConsumerQueue() {\n      front = new Node;\n      back = front;\n      sem_init(&semaphore, 0, 0);\n    }\n}"
  },
  {
    "function_name": "mod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
    "lines": "81-88",
    "snippet": "inline int32_t mod(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN % -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a % b;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdexcept>",
      "#include <algorithm>",
      "#include <semaphore.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <limits>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::numeric_limits<int32_t>::max",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::numeric_limits<int32_t>::min",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::numeric_limits<int32_t>::max",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\ninline int32_t mod(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN % -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a % b;\n}"
  },
  {
    "function_name": "div",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
    "lines": "72-79",
    "snippet": "inline int32_t div(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN / -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a / b;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdexcept>",
      "#include <algorithm>",
      "#include <semaphore.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <limits>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::numeric_limits<int32_t>::max",
          "args": [],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::numeric_limits<int32_t>::min",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::numeric_limits<int32_t>::max",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\ninline int32_t div(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN / -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a / b;\n}"
  },
  {
    "function_name": "fastRandDouble",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
    "lines": "68-70",
    "snippet": "static inline double fastRandDouble(double range) {\n  return nextFastRand() * range / std::numeric_limits<uint32_t>::max();\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdexcept>",
      "#include <algorithm>",
      "#include <semaphore.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <limits>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::numeric_limits<uint32_t>::max",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nextFastRand",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "nextFastRand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "49-62",
          "snippet": "static inline uint32_t nextFastRand() {\n  // These values are arbitrary. Any seed other than all zeroes is OK.\n  static uint32_t x = 0x1d2acd47;\n  static uint32_t y = 0x58ca3e14;\n  static uint32_t z = 0xf563f232;\n  static uint32_t w = 0x0bc76199;\n\n  uint32_t tmp = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  w = w ^ (w >> 19) ^ tmp ^ (tmp >> 8);\n  return w;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nstatic inline uint32_t nextFastRand() {\n  // These values are arbitrary. Any seed other than all zeroes is OK.\n  static uint32_t x = 0x1d2acd47;\n  static uint32_t y = 0x58ca3e14;\n  static uint32_t z = 0xf563f232;\n  static uint32_t w = 0x0bc76199;\n\n  uint32_t tmp = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  w = w ^ (w >> 19) ^ tmp ^ (tmp >> 8);\n  return w;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nstatic inline double fastRandDouble(double range) {\n  return nextFastRand() * range / std::numeric_limits<uint32_t>::max();\n}"
  },
  {
    "function_name": "fastRand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
    "lines": "64-66",
    "snippet": "static inline uint32_t fastRand(uint32_t range) {\n  return nextFastRand() % range;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdexcept>",
      "#include <algorithm>",
      "#include <semaphore.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <limits>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nextFastRand",
          "args": [],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "nextFastRand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "49-62",
          "snippet": "static inline uint32_t nextFastRand() {\n  // These values are arbitrary. Any seed other than all zeroes is OK.\n  static uint32_t x = 0x1d2acd47;\n  static uint32_t y = 0x58ca3e14;\n  static uint32_t z = 0xf563f232;\n  static uint32_t w = 0x0bc76199;\n\n  uint32_t tmp = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  w = w ^ (w >> 19) ^ tmp ^ (tmp >> 8);\n  return w;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nstatic inline uint32_t nextFastRand() {\n  // These values are arbitrary. Any seed other than all zeroes is OK.\n  static uint32_t x = 0x1d2acd47;\n  static uint32_t y = 0x58ca3e14;\n  static uint32_t z = 0xf563f232;\n  static uint32_t w = 0x0bc76199;\n\n  uint32_t tmp = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  w = w ^ (w >> 19) ^ tmp ^ (tmp >> 8);\n  return w;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nstatic inline uint32_t fastRand(uint32_t range) {\n  return nextFastRand() % range;\n}"
  },
  {
    "function_name": "nextFastRand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
    "lines": "49-62",
    "snippet": "static inline uint32_t nextFastRand() {\n  // These values are arbitrary. Any seed other than all zeroes is OK.\n  static uint32_t x = 0x1d2acd47;\n  static uint32_t y = 0x58ca3e14;\n  static uint32_t z = 0xf563f232;\n  static uint32_t w = 0x0bc76199;\n\n  uint32_t tmp = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  w = w ^ (w >> 19) ^ tmp ^ (tmp >> 8);\n  return w;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdexcept>",
      "#include <algorithm>",
      "#include <semaphore.h>",
      "#include <stdlib.h>",
      "#include <sys/wait.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include <limits>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nstatic inline uint32_t nextFastRand() {\n  // These values are arbitrary. Any seed other than all zeroes is OK.\n  static uint32_t x = 0x1d2acd47;\n  static uint32_t y = 0x58ca3e14;\n  static uint32_t z = 0xf563f232;\n  static uint32_t w = 0x0bc76199;\n\n  uint32_t tmp = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  w = w ^ (w >> 19) ^ tmp ^ (tmp >> 8);\n  return w;\n}"
  }
]