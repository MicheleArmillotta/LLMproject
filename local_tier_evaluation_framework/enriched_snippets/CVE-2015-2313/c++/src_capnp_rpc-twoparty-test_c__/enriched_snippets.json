[
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty-test.c++",
    "lines": "280-309",
    "snippet": "TEST(TwoPartyNetwork, Abort) {\n  // Verify that aborts are received.\n\n  auto ioContext = kj::setupAsyncIo();\n  int callCount = 0;\n  int handleCount = 0;\n\n  auto serverThread = runServer(*ioContext.provider, callCount, handleCount);\n  TwoPartyVatNetwork network(*serverThread.pipe, rpc::twoparty::Side::CLIENT);\n\n  MallocMessageBuilder refMessage(128);\n  auto hostId = refMessage.initRoot<rpc::twoparty::VatId>();\n  hostId.setSide(rpc::twoparty::Side::SERVER);\n\n  auto conn = KJ_ASSERT_NONNULL(network.connect(hostId));\n\n  {\n    // Send an invalid message (Return to non-existent question).\n    auto msg = conn->newOutgoingMessage(128);\n    auto body = msg->getBody().initAs<rpc::Message>().initReturn();\n    body.setAnswerId(1234);\n    body.setCanceled();\n    msg->send();\n  }\n\n  auto reply = KJ_ASSERT_NONNULL(conn->receiveIncomingMessage().wait(ioContext.waitScope));\n  EXPECT_EQ(rpc::Message::ABORT, reply->getBody().getAs<rpc::Message>().which());\n\n  EXPECT_TRUE(conn->receiveIncomingMessage().wait(ioContext.waitScope) == nullptr);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/thread.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-unix.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"test-util.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "conn->receiveIncomingMessage().wait(ioContext.waitScope) == nullptr"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conn->receiveIncomingMessage",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conn->receiveIncomingMessage",
          "args": [],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "rpc::Message::ABORT",
            "reply->getBody().getAs<rpc::Message>().which()"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reply->getBody",
          "args": [],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "getBody",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "106-108",
          "snippet": "AnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nAnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "conn->receiveIncomingMessage().wait(ioContext.waitScope)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conn->receiveIncomingMessage",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conn->receiveIncomingMessage",
          "args": [],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msg->send",
          "args": [],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "body.setCanceled",
          "args": [],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.setAnswerId",
          "args": [
            "1234"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conn->newOutgoingMessage",
          "args": [
            "128"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "newOutgoingMessage",
          "container": "TestNetworkAdapter::ConnectionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "305-307",
          "snippet": "kj::Own<OutgoingRpcMessage> newOutgoingMessage(uint firstSegmentWordSize) override {\n      return kj::heap<OutgoingRpcMessageImpl>(*this, firstSegmentWordSize);\n    }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    kj::Own<OutgoingRpcMessage> newOutgoingMessage(uint firstSegmentWordSize) override {\n          return kj::heap<OutgoingRpcMessageImpl>(*this, firstSegmentWordSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "network.connect(hostId)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "network.connect",
          "args": [
            "hostId"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "TestContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "468-476",
          "snippet": "Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n    MallocMessageBuilder refMessage(128);\n    auto ref = refMessage.initRoot<test::TestSturdyRef>();\n    auto hostId = ref.initHostId();\n    hostId.setHost(\"server\");\n    ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n\n    return rpcClient.restore(hostId, ref.getObjectId());\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n      MallocMessageBuilder refMessage(128);\n      auto ref = refMessage.initRoot<test::TestSturdyRef>();\n      auto hostId = ref.initHostId();\n      hostId.setHost(\"server\");\n      ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n  \n      return rpcClient.restore(hostId, ref.getObjectId());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hostId.setSide",
          "args": [
            "rpc::twoparty::Side::SERVER"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refMessage.initRoot<rpc::twoparty::VatId>",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runServer",
          "args": [
            "*ioContext.provider",
            "callCount",
            "handleCount"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::setupAsyncIo",
          "args": [],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "setupAsyncIo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1379-1385",
          "snippet": "AsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <capnp/rpc.capnp.h>\n#include \"test-util.h\"\n#include \"rpc-twoparty.h\"\n\nTEST(TwoPartyNetwork, Abort) {\n  // Verify that aborts are received.\n\n  auto ioContext = kj::setupAsyncIo();\n  int callCount = 0;\n  int handleCount = 0;\n\n  auto serverThread = runServer(*ioContext.provider, callCount, handleCount);\n  TwoPartyVatNetwork network(*serverThread.pipe, rpc::twoparty::Side::CLIENT);\n\n  MallocMessageBuilder refMessage(128);\n  auto hostId = refMessage.initRoot<rpc::twoparty::VatId>();\n  hostId.setSide(rpc::twoparty::Side::SERVER);\n\n  auto conn = KJ_ASSERT_NONNULL(network.connect(hostId));\n\n  {\n    // Send an invalid message (Return to non-existent question).\n    auto msg = conn->newOutgoingMessage(128);\n    auto body = msg->getBody().initAs<rpc::Message>().initReturn();\n    body.setAnswerId(1234);\n    body.setCanceled();\n    msg->send();\n  }\n\n  auto reply = KJ_ASSERT_NONNULL(conn->receiveIncomingMessage().wait(ioContext.waitScope));\n  EXPECT_EQ(rpc::Message::ABORT, reply->getBody().getAs<rpc::Message>().which());\n\n  EXPECT_TRUE(conn->receiveIncomingMessage().wait(ioContext.waitScope) == nullptr);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty-test.c++",
    "lines": "227-278",
    "snippet": "TEST(TwoPartyNetwork, Release) {\n  auto ioContext = kj::setupAsyncIo();\n  int callCount = 0;\n  int handleCount = 0;\n\n  auto serverThread = runServer(*ioContext.provider, callCount, handleCount);\n  TwoPartyVatNetwork network(*serverThread.pipe, rpc::twoparty::Side::CLIENT);\n  auto rpcClient = makeRpcClient(network);\n\n  // Request the particular capability from the server.\n  auto client = getPersistentCap(rpcClient, rpc::twoparty::Side::SERVER,\n      test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF).castAs<test::TestMoreStuff>();\n\n  auto handle1 = client.getHandleRequest().send().wait(ioContext.waitScope).getHandle();\n  auto promise = client.getHandleRequest().send();\n  auto handle2 = promise.wait(ioContext.waitScope).getHandle();\n\n  EXPECT_EQ(2, handleCount);\n\n  handle1 = nullptr;\n\n  // There once was a bug where the last outgoing message (and any capabilities attached) would\n  // not get cleaned up (until a new message was sent). This appeared to be a bug in Release,\n  // becaues if a client received a message and then released a capability from it but then did\n  // not make any further calls, then the capability would not be released because the message\n  // introducing it remained the last server -> client message (because a \"Release\" message has\n  // no reply). Here we are explicitly trying to catch this bug. This proves tricky, because when\n  // we drop a reference on the client side, there's no particular way to wait for the release\n  // message to reach the server except to make a subsequent call and wait for the return -- but\n  // that would mask the bug. So, we wait spin waiting for handleCount to change.\n\n  uint maxSpins = 1000;\n\n  while (handleCount > 1) {\n    ioContext.provider->getTimer().afterDelay(10 * kj::MILLISECONDS).wait(ioContext.waitScope);\n    KJ_ASSERT(--maxSpins > 0);\n  }\n  EXPECT_EQ(1, handleCount);\n\n  handle2 = nullptr;\n\n  ioContext.provider->getTimer().afterDelay(10 * kj::MILLISECONDS).wait(ioContext.waitScope);\n  EXPECT_EQ(1, handleCount);\n\n  promise = nullptr;\n\n  while (handleCount > 0) {\n    ioContext.provider->getTimer().afterDelay(10 * kj::MILLISECONDS).wait(ioContext.waitScope);\n    KJ_ASSERT(--maxSpins > 0);\n  }\n  EXPECT_EQ(0, handleCount);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/thread.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-unix.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"test-util.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "handleCount"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "--maxSpins > 0"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getTimer",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getTimer",
          "args": [
            "10 * kj::MILLISECONDS"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getTimer",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "handleCount"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getTimer",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getTimer",
          "args": [
            "10 * kj::MILLISECONDS"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getTimer",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "handleCount"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "--maxSpins > 0"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getTimer",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getTimer",
          "args": [
            "10 * kj::MILLISECONDS"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioContext.provider->getTimer",
          "args": [],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "handleCount"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "wait",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "666-666",
          "snippet": "bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getHandleRequest",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getHandleRequest",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getHandleRequest",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getHandleRequest",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getHandleRequest",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getHandleRequest",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getPersistentCap",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getPersistentCap",
          "args": [
            "rpcClient",
            "rpc::twoparty::Side::SERVER",
            "test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "getPersistentCap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty-test.c++",
          "lines": "83-97",
          "snippet": "Capability::Client getPersistentCap(RpcSystem<rpc::twoparty::VatId>& client,\n                                    rpc::twoparty::Side side,\n                                    test::TestSturdyRefObjectId::Tag tag) {\n  // Create the VatId.\n  MallocMessageBuilder hostIdMessage(8);\n  auto hostId = hostIdMessage.initRoot<rpc::twoparty::VatId>();\n  hostId.setSide(side);\n\n  // Create the SturdyRefObjectId.\n  MallocMessageBuilder objectIdMessage(8);\n  objectIdMessage.initRoot<test::TestSturdyRefObjectId>().setTag(tag);\n\n  // Connect to the remote capability.\n  return client.restore(hostId, objectIdMessage.getRoot<AnyPointer>());\n}",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/thread.h>",
            "#include <kj/debug.h>",
            "#include <kj/async-unix.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include \"test-util.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <capnp/rpc.capnp.h>\n#include \"test-util.h\"\n#include \"rpc-twoparty.h\"\n\nCapability::Client getPersistentCap(RpcSystem<rpc::twoparty::VatId>& client,\n                                    rpc::twoparty::Side side,\n                                    test::TestSturdyRefObjectId::Tag tag) {\n  // Create the VatId.\n  MallocMessageBuilder hostIdMessage(8);\n  auto hostId = hostIdMessage.initRoot<rpc::twoparty::VatId>();\n  hostId.setSide(side);\n\n  // Create the SturdyRefObjectId.\n  MallocMessageBuilder objectIdMessage(8);\n  objectIdMessage.initRoot<test::TestSturdyRefObjectId>().setTag(tag);\n\n  // Connect to the remote capability.\n  return client.restore(hostId, objectIdMessage.getRoot<AnyPointer>());\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeRpcClient",
          "args": [
            "network"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "makeRpcClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.h",
          "lines": "399-402",
          "snippet": "RpcSystem<VatId> makeRpcClient(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network) {\n  return RpcSystem<VatId>(network, nullptr);\n}",
          "includes": [
            "#include \"rpc-prelude.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc-prelude.h\"\n#include \"capability.h\"\n\nRpcSystem<VatId> makeRpcClient(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network) {\n  return RpcSystem<VatId>(network, nullptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "runServer",
          "args": [
            "*ioContext.provider",
            "callCount",
            "handleCount"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::setupAsyncIo",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "setupAsyncIo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1379-1385",
          "snippet": "AsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <capnp/rpc.capnp.h>\n#include \"test-util.h\"\n#include \"rpc-twoparty.h\"\n\nTEST(TwoPartyNetwork, Release) {\n  auto ioContext = kj::setupAsyncIo();\n  int callCount = 0;\n  int handleCount = 0;\n\n  auto serverThread = runServer(*ioContext.provider, callCount, handleCount);\n  TwoPartyVatNetwork network(*serverThread.pipe, rpc::twoparty::Side::CLIENT);\n  auto rpcClient = makeRpcClient(network);\n\n  // Request the particular capability from the server.\n  auto client = getPersistentCap(rpcClient, rpc::twoparty::Side::SERVER,\n      test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF).castAs<test::TestMoreStuff>();\n\n  auto handle1 = client.getHandleRequest().send().wait(ioContext.waitScope).getHandle();\n  auto promise = client.getHandleRequest().send();\n  auto handle2 = promise.wait(ioContext.waitScope).getHandle();\n\n  EXPECT_EQ(2, handleCount);\n\n  handle1 = nullptr;\n\n  // There once was a bug where the last outgoing message (and any capabilities attached) would\n  // not get cleaned up (until a new message was sent). This appeared to be a bug in Release,\n  // becaues if a client received a message and then released a capability from it but then did\n  // not make any further calls, then the capability would not be released because the message\n  // introducing it remained the last server -> client message (because a \"Release\" message has\n  // no reply). Here we are explicitly trying to catch this bug. This proves tricky, because when\n  // we drop a reference on the client side, there's no particular way to wait for the release\n  // message to reach the server except to make a subsequent call and wait for the return -- but\n  // that would mask the bug. So, we wait spin waiting for handleCount to change.\n\n  uint maxSpins = 1000;\n\n  while (handleCount > 1) {\n    ioContext.provider->getTimer().afterDelay(10 * kj::MILLISECONDS).wait(ioContext.waitScope);\n    KJ_ASSERT(--maxSpins > 0);\n  }\n  EXPECT_EQ(1, handleCount);\n\n  handle2 = nullptr;\n\n  ioContext.provider->getTimer().afterDelay(10 * kj::MILLISECONDS).wait(ioContext.waitScope);\n  EXPECT_EQ(1, handleCount);\n\n  promise = nullptr;\n\n  while (handleCount > 0) {\n    ioContext.provider->getTimer().afterDelay(10 * kj::MILLISECONDS).wait(ioContext.waitScope);\n    KJ_ASSERT(--maxSpins > 0);\n  }\n  EXPECT_EQ(0, handleCount);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty-test.c++",
    "lines": "145-225",
    "snippet": "TEST(TwoPartyNetwork, Pipelining) {\n  auto ioContext = kj::setupAsyncIo();\n  int callCount = 0;\n  int handleCount = 0;\n  int reverseCallCount = 0;  // Calls back from server to client.\n\n  auto serverThread = runServer(*ioContext.provider, callCount, handleCount);\n  TwoPartyVatNetwork network(*serverThread.pipe, rpc::twoparty::Side::CLIENT);\n  auto rpcClient = makeRpcClient(network);\n\n  bool disconnected = false;\n  kj::Promise<void> disconnectPromise = network.onDisconnect().then([&]() { disconnected = true; });\n\n  {\n    // Request the particular capability from the server.\n    auto client = getPersistentCap(rpcClient, rpc::twoparty::Side::SERVER,\n        test::TestSturdyRefObjectId::Tag::TEST_PIPELINE).castAs<test::TestPipeline>();\n\n    {\n      // Use the capability.\n      auto request = client.getCapRequest();\n      request.setN(234);\n      request.setInCap(kj::heap<TestInterfaceImpl>(reverseCallCount));\n\n      auto promise = request.send();\n\n      auto pipelineRequest = promise.getOutBox().getCap().fooRequest();\n      pipelineRequest.setI(321);\n      auto pipelinePromise = pipelineRequest.send();\n\n      auto pipelineRequest2 = promise.getOutBox().getCap()\n          .castAs<test::TestExtends>().graultRequest();\n      auto pipelinePromise2 = pipelineRequest2.send();\n\n      promise = nullptr;  // Just to be annoying, drop the original promise.\n\n      EXPECT_EQ(0, callCount);\n      EXPECT_EQ(0, reverseCallCount);\n\n      auto response = pipelinePromise.wait(ioContext.waitScope);\n      EXPECT_EQ(\"bar\", response.getX());\n\n      auto response2 = pipelinePromise2.wait(ioContext.waitScope);\n      checkTestMessage(response2);\n\n      EXPECT_EQ(3, callCount);\n      EXPECT_EQ(1, reverseCallCount);\n    }\n\n    EXPECT_FALSE(disconnected);\n\n    // What if we disconnect?\n    serverThread.pipe->shutdownWrite();\n\n    // The other side should also disconnect.\n    disconnectPromise.wait(ioContext.waitScope);\n\n    {\n      // Use the now-broken capability.\n      auto request = client.getCapRequest();\n      request.setN(234);\n      request.setInCap(kj::heap<TestInterfaceImpl>(reverseCallCount));\n\n      auto promise = request.send();\n\n      auto pipelineRequest = promise.getOutBox().getCap().fooRequest();\n      pipelineRequest.setI(321);\n      auto pipelinePromise = pipelineRequest.send();\n\n      auto pipelineRequest2 = promise.getOutBox().getCap()\n          .castAs<test::TestExtends>().graultRequest();\n      auto pipelinePromise2 = pipelineRequest2.send();\n\n      EXPECT_ANY_THROW(pipelinePromise.wait(ioContext.waitScope));\n      EXPECT_ANY_THROW(pipelinePromise2.wait(ioContext.waitScope));\n\n      EXPECT_EQ(3, callCount);\n      EXPECT_EQ(1, reverseCallCount);\n    }\n  }\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/thread.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-unix.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"test-util.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "reverseCallCount"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "callCount"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_ANY_THROW",
          "args": [
            "pipelinePromise2.wait(ioContext.waitScope)"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipelinePromise2.wait",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_ANY_THROW",
          "args": [
            "pipelinePromise.wait(ioContext.waitScope)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipelinePromise.wait",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipelineRequest2.send",
          "args": [],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipelineRequest.setI",
          "args": [
            "321"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setInCap",
          "args": [
            "kj::heap<TestInterfaceImpl>(reverseCallCount)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestInterfaceImpl>",
          "args": [
            "reverseCallCount"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.setN",
          "args": [
            "234"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCapRequest",
          "args": [],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disconnectPromise.wait",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "serverThread.pipe->shutdownWrite",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "disconnected"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "reverseCallCount"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "callCount"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkTestMessage",
          "args": [
            "response2"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "checkTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "844-844",
          "snippet": "void checkTestMessage(TestListDefaults::Reader reader) { genericCheckListDefaults(reader); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid checkTestMessage(TestListDefaults::Reader reader) { genericCheckListDefaults(reader); }"
        }
      },
      {
        "call_info": {
          "callee": "pipelinePromise2.wait",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "response.getX()"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getX",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipelinePromise.wait",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "reverseCallCount"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "callCount"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipelineRequest.setI",
          "args": [
            "321"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setInCap",
          "args": [
            "kj::heap<TestInterfaceImpl>(reverseCallCount)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setN",
          "args": [
            "234"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCapRequest",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getPersistentCap",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getPersistentCap",
          "args": [
            "rpcClient",
            "rpc::twoparty::Side::SERVER",
            "test::TestSturdyRefObjectId::Tag::TEST_PIPELINE"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "getPersistentCap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty-test.c++",
          "lines": "83-97",
          "snippet": "Capability::Client getPersistentCap(RpcSystem<rpc::twoparty::VatId>& client,\n                                    rpc::twoparty::Side side,\n                                    test::TestSturdyRefObjectId::Tag tag) {\n  // Create the VatId.\n  MallocMessageBuilder hostIdMessage(8);\n  auto hostId = hostIdMessage.initRoot<rpc::twoparty::VatId>();\n  hostId.setSide(side);\n\n  // Create the SturdyRefObjectId.\n  MallocMessageBuilder objectIdMessage(8);\n  objectIdMessage.initRoot<test::TestSturdyRefObjectId>().setTag(tag);\n\n  // Connect to the remote capability.\n  return client.restore(hostId, objectIdMessage.getRoot<AnyPointer>());\n}",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/thread.h>",
            "#include <kj/debug.h>",
            "#include <kj/async-unix.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include \"test-util.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <capnp/rpc.capnp.h>\n#include \"test-util.h\"\n#include \"rpc-twoparty.h\"\n\nCapability::Client getPersistentCap(RpcSystem<rpc::twoparty::VatId>& client,\n                                    rpc::twoparty::Side side,\n                                    test::TestSturdyRefObjectId::Tag tag) {\n  // Create the VatId.\n  MallocMessageBuilder hostIdMessage(8);\n  auto hostId = hostIdMessage.initRoot<rpc::twoparty::VatId>();\n  hostId.setSide(side);\n\n  // Create the SturdyRefObjectId.\n  MallocMessageBuilder objectIdMessage(8);\n  objectIdMessage.initRoot<test::TestSturdyRefObjectId>().setTag(tag);\n\n  // Connect to the remote capability.\n  return client.restore(hostId, objectIdMessage.getRoot<AnyPointer>());\n}"
        }
      },
      {
        "call_info": {
          "callee": "network.onDisconnect",
          "args": [
            "[&]() { disconnected = true; }"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "network.onDisconnect",
          "args": [],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "onDisconnect",
          "container": "TwoPartyVatNetwork",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.h",
          "lines": "58-58",
          "snippet": "kj::Promise<void> onDisconnect() { return disconnectPromise.addBranch(); }",
          "includes": [
            "#include <capnp/rpc-twoparty.capnp.h>",
            "#include <kj/async-io.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc-twoparty.capnp.h>\n#include <kj/async-io.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nTwoPartyVatNetwork {\n  kj::Promise<void> onDisconnect() { return disconnectPromise.addBranch(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeRpcClient",
          "args": [
            "network"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "makeRpcClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.h",
          "lines": "399-402",
          "snippet": "RpcSystem<VatId> makeRpcClient(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network) {\n  return RpcSystem<VatId>(network, nullptr);\n}",
          "includes": [
            "#include \"rpc-prelude.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc-prelude.h\"\n#include \"capability.h\"\n\nRpcSystem<VatId> makeRpcClient(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network) {\n  return RpcSystem<VatId>(network, nullptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "runServer",
          "args": [
            "*ioContext.provider",
            "callCount",
            "handleCount"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::setupAsyncIo",
          "args": [],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "setupAsyncIo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1379-1385",
          "snippet": "AsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <capnp/rpc.capnp.h>\n#include \"test-util.h\"\n#include \"rpc-twoparty.h\"\n\nTEST(TwoPartyNetwork, Pipelining) {\n  auto ioContext = kj::setupAsyncIo();\n  int callCount = 0;\n  int handleCount = 0;\n  int reverseCallCount = 0;  // Calls back from server to client.\n\n  auto serverThread = runServer(*ioContext.provider, callCount, handleCount);\n  TwoPartyVatNetwork network(*serverThread.pipe, rpc::twoparty::Side::CLIENT);\n  auto rpcClient = makeRpcClient(network);\n\n  bool disconnected = false;\n  kj::Promise<void> disconnectPromise = network.onDisconnect().then([&]() { disconnected = true; });\n\n  {\n    // Request the particular capability from the server.\n    auto client = getPersistentCap(rpcClient, rpc::twoparty::Side::SERVER,\n        test::TestSturdyRefObjectId::Tag::TEST_PIPELINE).castAs<test::TestPipeline>();\n\n    {\n      // Use the capability.\n      auto request = client.getCapRequest();\n      request.setN(234);\n      request.setInCap(kj::heap<TestInterfaceImpl>(reverseCallCount));\n\n      auto promise = request.send();\n\n      auto pipelineRequest = promise.getOutBox().getCap().fooRequest();\n      pipelineRequest.setI(321);\n      auto pipelinePromise = pipelineRequest.send();\n\n      auto pipelineRequest2 = promise.getOutBox().getCap()\n          .castAs<test::TestExtends>().graultRequest();\n      auto pipelinePromise2 = pipelineRequest2.send();\n\n      promise = nullptr;  // Just to be annoying, drop the original promise.\n\n      EXPECT_EQ(0, callCount);\n      EXPECT_EQ(0, reverseCallCount);\n\n      auto response = pipelinePromise.wait(ioContext.waitScope);\n      EXPECT_EQ(\"bar\", response.getX());\n\n      auto response2 = pipelinePromise2.wait(ioContext.waitScope);\n      checkTestMessage(response2);\n\n      EXPECT_EQ(3, callCount);\n      EXPECT_EQ(1, reverseCallCount);\n    }\n\n    EXPECT_FALSE(disconnected);\n\n    // What if we disconnect?\n    serverThread.pipe->shutdownWrite();\n\n    // The other side should also disconnect.\n    disconnectPromise.wait(ioContext.waitScope);\n\n    {\n      // Use the now-broken capability.\n      auto request = client.getCapRequest();\n      request.setN(234);\n      request.setInCap(kj::heap<TestInterfaceImpl>(reverseCallCount));\n\n      auto promise = request.send();\n\n      auto pipelineRequest = promise.getOutBox().getCap().fooRequest();\n      pipelineRequest.setI(321);\n      auto pipelinePromise = pipelineRequest.send();\n\n      auto pipelineRequest2 = promise.getOutBox().getCap()\n          .castAs<test::TestExtends>().graultRequest();\n      auto pipelinePromise2 = pipelineRequest2.send();\n\n      EXPECT_ANY_THROW(pipelinePromise.wait(ioContext.waitScope));\n      EXPECT_ANY_THROW(pipelinePromise2.wait(ioContext.waitScope));\n\n      EXPECT_EQ(3, callCount);\n      EXPECT_EQ(1, reverseCallCount);\n    }\n  }\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty-test.c++",
    "lines": "99-143",
    "snippet": "TEST(TwoPartyNetwork, Basic) {\n  auto ioContext = kj::setupAsyncIo();\n  int callCount = 0;\n  int handleCount = 0;\n\n  auto serverThread = runServer(*ioContext.provider, callCount, handleCount);\n  TwoPartyVatNetwork network(*serverThread.pipe, rpc::twoparty::Side::CLIENT);\n  auto rpcClient = makeRpcClient(network);\n\n  // Request the particular capability from the server.\n  auto client = getPersistentCap(rpcClient, rpc::twoparty::Side::SERVER,\n      test::TestSturdyRefObjectId::Tag::TEST_INTERFACE).castAs<test::TestInterface>();\n\n  // Use the capability.\n  auto request1 = client.fooRequest();\n  request1.setI(123);\n  request1.setJ(true);\n  auto promise1 = request1.send();\n\n  auto request2 = client.bazRequest();\n  initTestMessage(request2.initS());\n  auto promise2 = request2.send();\n\n  bool barFailed = false;\n  auto request3 = client.barRequest();\n  auto promise3 = request3.send().then(\n      [](Response<test::TestInterface::BarResults>&& response) {\n        ADD_FAILURE() << \"Expected bar() call to fail.\";\n      }, [&](kj::Exception&& e) {\n        barFailed = true;\n      });\n\n  EXPECT_EQ(0, callCount);\n\n  auto response1 = promise1.wait(ioContext.waitScope);\n\n  EXPECT_EQ(\"foo\", response1.getX());\n\n  auto response2 = promise2.wait(ioContext.waitScope);\n\n  promise3.wait(ioContext.waitScope);\n\n  EXPECT_EQ(2, callCount);\n  EXPECT_TRUE(barFailed);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/thread.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-unix.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"test-util.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "barFailed"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "callCount"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise3.wait",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise2.wait",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "response1.getX()"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response1.getX",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise1.wait",
          "args": [
            "ioContext.waitScope"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "callCount"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request3.send",
          "args": [
            "[](Response<test::TestInterface::BarResults>&& response) {\n        ADD_FAILURE() << \"Expected bar() call to fail.\";\n      }",
            "[&](kj::Exception&& e) {\n        barFailed = true;\n      }"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "LocalRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "207-241",
          "snippet": "RemotePromise<AnyPointer> send() override {\n    KJ_REQUIRE(message.get() != nullptr, \"Already called send() on this request.\");\n\n    // For the lambda capture.\n    uint64_t interfaceId = this->interfaceId;\n    uint16_t methodId = this->methodId;\n\n    auto cancelPaf = kj::newPromiseAndFulfiller<void>();\n\n    auto context = kj::refcounted<LocalCallContext>(\n        kj::mv(message), client->addRef(), kj::mv(cancelPaf.fulfiller));\n    auto promiseAndPipeline = client->call(interfaceId, methodId, kj::addRef(*context));\n\n    // We have to make sure the call is not canceled unless permitted.  We need to fork the promise\n    // so that if the client drops their copy, the promise isn't necessarily canceled.\n    auto forked = promiseAndPipeline.promise.fork();\n\n    // We daemonize one branch, but only after joining it with the promise that fires if\n    // cancellation is allowed.\n    forked.addBranch()\n        .attach(kj::addRef(*context))\n        .exclusiveJoin(kj::mv(cancelPaf.promise))\n        .detach([](kj::Exception&&) {});  // ignore exceptions\n\n    // Now the other branch returns the response from the context.\n    auto promise = forked.addBranch().then(kj::mvCapture(context,\n        [](kj::Own<LocalCallContext>&& context) {\n      context->getResults(MessageSize { 0, 0 });  // force response allocation\n      return kj::mv(KJ_ASSERT_NONNULL(context->response));\n    }));\n\n    // We return the other branch.\n    return RemotePromise<AnyPointer>(\n        kj::mv(promise), AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline)));\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<MallocMessageBuilder>> request;",
            "kj::Maybe<Response<AnyPointer>> response;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<kj::Own<MallocMessageBuilder>> request;\nkj::Maybe<Response<AnyPointer>> response;\n\nLocalRequest {\n  RemotePromise<AnyPointer> send() override {\n      KJ_REQUIRE(message.get() != nullptr, \"Already called send() on this request.\");\n  \n      // For the lambda capture.\n      uint64_t interfaceId = this->interfaceId;\n      uint16_t methodId = this->methodId;\n  \n      auto cancelPaf = kj::newPromiseAndFulfiller<void>();\n  \n      auto context = kj::refcounted<LocalCallContext>(\n          kj::mv(message), client->addRef(), kj::mv(cancelPaf.fulfiller));\n      auto promiseAndPipeline = client->call(interfaceId, methodId, kj::addRef(*context));\n  \n      // We have to make sure the call is not canceled unless permitted.  We need to fork the promise\n      // so that if the client drops their copy, the promise isn't necessarily canceled.\n      auto forked = promiseAndPipeline.promise.fork();\n  \n      // We daemonize one branch, but only after joining it with the promise that fires if\n      // cancellation is allowed.\n      forked.addBranch()\n          .attach(kj::addRef(*context))\n          .exclusiveJoin(kj::mv(cancelPaf.promise))\n          .detach([](kj::Exception&&) {});  // ignore exceptions\n  \n      // Now the other branch returns the response from the context.\n      auto promise = forked.addBranch().then(kj::mvCapture(context,\n          [](kj::Own<LocalCallContext>&& context) {\n        context->getResults(MessageSize { 0, 0 });  // force response allocation\n        return kj::mv(KJ_ASSERT_NONNULL(context->response));\n      }));\n  \n      // We return the other branch.\n      return RemotePromise<AnyPointer>(\n          kj::mv(promise), AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADD_FAILURE",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request3.send",
          "args": [],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "client.barRequest",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initTestMessage",
          "args": [
            "request2.initS()"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "initTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "836-836",
          "snippet": "void initTestMessage(TestListDefaults::Builder builder) { genericInitListDefaults(builder); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid initTestMessage(TestListDefaults::Builder builder) { genericInitListDefaults(builder); }"
        }
      },
      {
        "call_info": {
          "callee": "request2.initS",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.bazRequest",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request1.setJ",
          "args": [
            "true"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request1.setI",
          "args": [
            "123"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.fooRequest",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getPersistentCap",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getPersistentCap",
          "args": [
            "rpcClient",
            "rpc::twoparty::Side::SERVER",
            "test::TestSturdyRefObjectId::Tag::TEST_INTERFACE"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "getPersistentCap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty-test.c++",
          "lines": "83-97",
          "snippet": "Capability::Client getPersistentCap(RpcSystem<rpc::twoparty::VatId>& client,\n                                    rpc::twoparty::Side side,\n                                    test::TestSturdyRefObjectId::Tag tag) {\n  // Create the VatId.\n  MallocMessageBuilder hostIdMessage(8);\n  auto hostId = hostIdMessage.initRoot<rpc::twoparty::VatId>();\n  hostId.setSide(side);\n\n  // Create the SturdyRefObjectId.\n  MallocMessageBuilder objectIdMessage(8);\n  objectIdMessage.initRoot<test::TestSturdyRefObjectId>().setTag(tag);\n\n  // Connect to the remote capability.\n  return client.restore(hostId, objectIdMessage.getRoot<AnyPointer>());\n}",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/thread.h>",
            "#include <kj/debug.h>",
            "#include <kj/async-unix.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include \"test-util.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <capnp/rpc.capnp.h>\n#include \"test-util.h\"\n#include \"rpc-twoparty.h\"\n\nCapability::Client getPersistentCap(RpcSystem<rpc::twoparty::VatId>& client,\n                                    rpc::twoparty::Side side,\n                                    test::TestSturdyRefObjectId::Tag tag) {\n  // Create the VatId.\n  MallocMessageBuilder hostIdMessage(8);\n  auto hostId = hostIdMessage.initRoot<rpc::twoparty::VatId>();\n  hostId.setSide(side);\n\n  // Create the SturdyRefObjectId.\n  MallocMessageBuilder objectIdMessage(8);\n  objectIdMessage.initRoot<test::TestSturdyRefObjectId>().setTag(tag);\n\n  // Connect to the remote capability.\n  return client.restore(hostId, objectIdMessage.getRoot<AnyPointer>());\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeRpcClient",
          "args": [
            "network"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "makeRpcClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.h",
          "lines": "399-402",
          "snippet": "RpcSystem<VatId> makeRpcClient(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network) {\n  return RpcSystem<VatId>(network, nullptr);\n}",
          "includes": [
            "#include \"rpc-prelude.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc-prelude.h\"\n#include \"capability.h\"\n\nRpcSystem<VatId> makeRpcClient(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network) {\n  return RpcSystem<VatId>(network, nullptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "runServer",
          "args": [
            "*ioContext.provider",
            "callCount",
            "handleCount"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::setupAsyncIo",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "setupAsyncIo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1379-1385",
          "snippet": "AsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <capnp/rpc.capnp.h>\n#include \"test-util.h\"\n#include \"rpc-twoparty.h\"\n\nTEST(TwoPartyNetwork, Basic) {\n  auto ioContext = kj::setupAsyncIo();\n  int callCount = 0;\n  int handleCount = 0;\n\n  auto serverThread = runServer(*ioContext.provider, callCount, handleCount);\n  TwoPartyVatNetwork network(*serverThread.pipe, rpc::twoparty::Side::CLIENT);\n  auto rpcClient = makeRpcClient(network);\n\n  // Request the particular capability from the server.\n  auto client = getPersistentCap(rpcClient, rpc::twoparty::Side::SERVER,\n      test::TestSturdyRefObjectId::Tag::TEST_INTERFACE).castAs<test::TestInterface>();\n\n  // Use the capability.\n  auto request1 = client.fooRequest();\n  request1.setI(123);\n  request1.setJ(true);\n  auto promise1 = request1.send();\n\n  auto request2 = client.bazRequest();\n  initTestMessage(request2.initS());\n  auto promise2 = request2.send();\n\n  bool barFailed = false;\n  auto request3 = client.barRequest();\n  auto promise3 = request3.send().then(\n      [](Response<test::TestInterface::BarResults>&& response) {\n        ADD_FAILURE() << \"Expected bar() call to fail.\";\n      }, [&](kj::Exception&& e) {\n        barFailed = true;\n      });\n\n  EXPECT_EQ(0, callCount);\n\n  auto response1 = promise1.wait(ioContext.waitScope);\n\n  EXPECT_EQ(\"foo\", response1.getX());\n\n  auto response2 = promise2.wait(ioContext.waitScope);\n\n  promise3.wait(ioContext.waitScope);\n\n  EXPECT_EQ(2, callCount);\n  EXPECT_TRUE(barFailed);\n}"
  },
  {
    "function_name": "getPersistentCap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty-test.c++",
    "lines": "83-97",
    "snippet": "Capability::Client getPersistentCap(RpcSystem<rpc::twoparty::VatId>& client,\n                                    rpc::twoparty::Side side,\n                                    test::TestSturdyRefObjectId::Tag tag) {\n  // Create the VatId.\n  MallocMessageBuilder hostIdMessage(8);\n  auto hostId = hostIdMessage.initRoot<rpc::twoparty::VatId>();\n  hostId.setSide(side);\n\n  // Create the SturdyRefObjectId.\n  MallocMessageBuilder objectIdMessage(8);\n  objectIdMessage.initRoot<test::TestSturdyRefObjectId>().setTag(tag);\n\n  // Connect to the remote capability.\n  return client.restore(hostId, objectIdMessage.getRoot<AnyPointer>());\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/thread.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-unix.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"test-util.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "client.restore",
          "args": [
            "hostId",
            "objectIdMessage.getRoot<AnyPointer>()"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "restore",
          "container": "ClientContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
          "lines": "101-116",
          "snippet": "Capability::Client restore(kj::StringPtr name) {\n      word scratch[64];\n      memset(scratch, 0, sizeof(scratch));\n      MallocMessageBuilder message(scratch);\n\n      auto hostIdOrphan = message.getOrphanage().newOrphan<rpc::twoparty::VatId>();\n      auto hostId = hostIdOrphan.get();\n      hostId.setSide(rpc::twoparty::Side::SERVER);\n\n      auto objectId = message.getRoot<AnyPointer>();\n      objectId.setAs<Text>(name);\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n      return rpcSystem.restore(hostId, objectId);\n#pragma GCC diagnostic pop\n    }",
          "includes": [
            "#include <map>",
            "#include <kj/threadlocal.h>",
            "#include <kj/debug.h>",
            "#include <kj/async-io.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include \"rpc-twoparty.h\"",
            "#include \"ez-rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nClientContext {\n  Capability::Client restore(kj::StringPtr name) {\n        word scratch[64];\n        memset(scratch, 0, sizeof(scratch));\n        MallocMessageBuilder message(scratch);\n  \n        auto hostIdOrphan = message.getOrphanage().newOrphan<rpc::twoparty::VatId>();\n        auto hostId = hostIdOrphan.get();\n        hostId.setSide(rpc::twoparty::Side::SERVER);\n  \n        auto objectId = message.getRoot<AnyPointer>();\n        objectId.setAs<Text>(name);\n  #pragma GCC diagnostic push\n  #pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n        return rpcSystem.restore(hostId, objectId);\n  #pragma GCC diagnostic pop\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "objectIdMessage.getRoot<AnyPointer>",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "objectIdMessage.initRoot<test::TestSturdyRefObjectId>",
          "args": [
            "tag"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "objectIdMessage.initRoot<test::TestSturdyRefObjectId>",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostId.setSide",
          "args": [
            "side"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostIdMessage.initRoot<rpc::twoparty::VatId>",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <capnp/rpc.capnp.h>\n#include \"test-util.h\"\n#include \"rpc-twoparty.h\"\n\nCapability::Client getPersistentCap(RpcSystem<rpc::twoparty::VatId>& client,\n                                    rpc::twoparty::Side side,\n                                    test::TestSturdyRefObjectId::Tag tag) {\n  // Create the VatId.\n  MallocMessageBuilder hostIdMessage(8);\n  auto hostId = hostIdMessage.initRoot<rpc::twoparty::VatId>();\n  hostId.setSide(side);\n\n  // Create the SturdyRefObjectId.\n  MallocMessageBuilder objectIdMessage(8);\n  objectIdMessage.initRoot<test::TestSturdyRefObjectId>().setTag(tag);\n\n  // Connect to the remote capability.\n  return client.restore(hostId, objectIdMessage.getRoot<AnyPointer>());\n}"
  },
  {
    "function_name": "runServer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty-test.c++",
    "lines": "71-81",
    "snippet": "kj::AsyncIoProvider::PipeThread runServer(kj::AsyncIoProvider& ioProvider,\n                                          int& callCount, int& handleCount) {\n  return ioProvider.newPipeThread(\n      [&callCount, &handleCount](\n       kj::AsyncIoProvider& ioProvider, kj::AsyncIoStream& stream, kj::WaitScope& waitScope) {\n    TwoPartyVatNetwork network(stream, rpc::twoparty::Side::SERVER);\n    TestRestorer restorer(callCount, handleCount);\n    auto server = makeRpcServer(network, restorer);\n    network.onDisconnect().wait(waitScope);\n  });\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/thread.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-unix.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"test-util.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioProvider.newPipeThread",
          "args": [
            "[&callCount, &handleCount](\n       kj::AsyncIoProvider& ioProvider, kj::AsyncIoStream& stream, kj::WaitScope& waitScope) {\n    TwoPartyVatNetwork network(stream, rpc::twoparty::Side::SERVER);\n    TestRestorer restorer(callCount, handleCount);\n    auto server = makeRpcServer(network, restorer);\n    network.onDisconnect().wait(waitScope);\n  }"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "network.onDisconnect",
          "args": [
            "waitScope"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "network.onDisconnect",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "onDisconnect",
          "container": "TwoPartyVatNetwork",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.h",
          "lines": "58-58",
          "snippet": "kj::Promise<void> onDisconnect() { return disconnectPromise.addBranch(); }",
          "includes": [
            "#include <capnp/rpc-twoparty.capnp.h>",
            "#include <kj/async-io.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc-twoparty.capnp.h>\n#include <kj/async-io.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nTwoPartyVatNetwork {\n  kj::Promise<void> onDisconnect() { return disconnectPromise.addBranch(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeRpcServer",
          "args": [
            "network",
            "restorer"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "makeRpcServer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.h",
          "lines": "391-395",
          "snippet": "RpcSystem<VatId> makeRpcServer(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network,\n    SturdyRefRestorer<LocalSturdyRefObjectId>& restorer) {\n  return RpcSystem<VatId>(network, restorer);\n}",
          "includes": [
            "#include \"rpc-prelude.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc-prelude.h\"\n#include \"capability.h\"\n\nRpcSystem<VatId> makeRpcServer(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network,\n    SturdyRefRestorer<LocalSturdyRefObjectId>& restorer) {\n  return RpcSystem<VatId>(network, restorer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <capnp/rpc.capnp.h>\n#include \"test-util.h\"\n#include \"rpc-twoparty.h\"\n\nkj::AsyncIoProvider::PipeThread runServer(kj::AsyncIoProvider& ioProvider,\n                                          int& callCount, int& handleCount) {\n  return ioProvider.newPipeThread(\n      [&callCount, &handleCount](\n       kj::AsyncIoProvider& ioProvider, kj::AsyncIoStream& stream, kj::WaitScope& waitScope) {\n    TwoPartyVatNetwork network(stream, rpc::twoparty::Side::SERVER);\n    TestRestorer restorer(callCount, handleCount);\n    auto server = makeRpcServer(network, restorer);\n    network.onDisconnect().wait(waitScope);\n  });\n}"
  },
  {
    "function_name": "restore",
    "container": "TestRestorer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty-test.c++",
    "lines": "48-64",
    "snippet": "Capability::Client restore(test::TestSturdyRefObjectId::Reader objectId) override {\n    switch (objectId.getTag()) {\n      case test::TestSturdyRefObjectId::Tag::TEST_INTERFACE:\n        return kj::heap<TestInterfaceImpl>(callCount);\n      case test::TestSturdyRefObjectId::Tag::TEST_EXTENDS:\n        return Capability::Client(newBrokenCap(\"No TestExtends implemented.\"));\n      case test::TestSturdyRefObjectId::Tag::TEST_PIPELINE:\n        return kj::heap<TestPipelineImpl>(callCount);\n      case test::TestSturdyRefObjectId::Tag::TEST_TAIL_CALLEE:\n        return kj::heap<TestTailCalleeImpl>(callCount);\n      case test::TestSturdyRefObjectId::Tag::TEST_TAIL_CALLER:\n        return kj::heap<TestTailCallerImpl>(callCount);\n      case test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF:\n        return kj::heap<TestMoreStuffImpl>(callCount, handleCount);\n    }\n    KJ_UNREACHABLE;\n  }",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/thread.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-unix.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"test-util.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<TestMoreStuffImpl>",
          "args": [
            "callCount",
            "handleCount"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestTailCallerImpl>",
          "args": [
            "callCount"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Capability::Client",
          "args": [
            "newBrokenCap(\"No TestExtends implemented.\")"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newBrokenCap",
          "args": [
            "\"No TestExtends implemented.\""
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "newBrokenCap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "620-622",
          "snippet": "kj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}"
        }
      },
      {
        "call_info": {
          "callee": "objectId.getTag",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <capnp/rpc.capnp.h>\n#include \"test-util.h\"\n#include \"rpc-twoparty.h\"\n\nTestRestorer {\n  Capability::Client restore(test::TestSturdyRefObjectId::Reader objectId) override {\n      switch (objectId.getTag()) {\n        case test::TestSturdyRefObjectId::Tag::TEST_INTERFACE:\n          return kj::heap<TestInterfaceImpl>(callCount);\n        case test::TestSturdyRefObjectId::Tag::TEST_EXTENDS:\n          return Capability::Client(newBrokenCap(\"No TestExtends implemented.\"));\n        case test::TestSturdyRefObjectId::Tag::TEST_PIPELINE:\n          return kj::heap<TestPipelineImpl>(callCount);\n        case test::TestSturdyRefObjectId::Tag::TEST_TAIL_CALLEE:\n          return kj::heap<TestTailCalleeImpl>(callCount);\n        case test::TestSturdyRefObjectId::Tag::TEST_TAIL_CALLER:\n          return kj::heap<TestTailCallerImpl>(callCount);\n        case test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF:\n          return kj::heap<TestMoreStuffImpl>(callCount, handleCount);\n      }\n      KJ_UNREACHABLE;\n    }\n}"
  },
  {
    "function_name": "TestRestorer",
    "container": "TestRestorer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty-test.c++",
    "lines": "45-46",
    "snippet": "TestRestorer(int& callCount, int& handleCount)\n      : callCount(callCount), handleCount(handleCount) {}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/thread.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-unix.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"test-util.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <capnp/rpc.capnp.h>\n#include \"test-util.h\"\n#include \"rpc-twoparty.h\"\n\nTestRestorer {\n  TestRestorer(int& callCount, int& handleCount)\n        : callCount(callCount), handleCount(handleCount) {}\n}"
  },
  {
    "function_name": "KJ_STRINGIFY",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty-test.c++",
    "lines": "33-35",
    "snippet": "inline kj::String KJ_STRINGIFY(Message::Which which) {\n  return kj::str(static_cast<uint16_t>(which));\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/thread.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-unix.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"test-util.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "static_cast<uint16_t>(which)"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "341-341",
          "snippet": "inline String str(String&& s) { return mv(s); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<uint16_t>",
          "args": [
            "which"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include <kj/async-unix.h>\n#include <capnp/rpc.capnp.h>\n#include \"test-util.h\"\n#include \"rpc-twoparty.h\"\n\ninline kj::String KJ_STRINGIFY(Message::Which which) {\n  return kj::str(static_cast<uint16_t>(which));\n}"
  }
]