[
  {
    "function_name": "IdentityFunc<Promise<void>>::operator()",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "946-946",
    "snippet": "Promise<void> IdentityFunc<Promise<void>>::operator()() const { return READY_NOW; }",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nPromise<void> IdentityFunc<Promise<void>>::operator()() const { return READY_NOW; }"
  },
  {
    "function_name": "AdapterPromiseNodeBase::onReady",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "940-942",
    "snippet": "void AdapterPromiseNodeBase::onReady(Event& event) noexcept {\n  onReadyEvent.init(event);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onReadyEvent.init",
          "args": [
            "event"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/pointer-helpers.h",
          "lines": "51-53",
          "snippet": "static inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"layout.h\"\n\nstatic inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid AdapterPromiseNodeBase::onReady(Event& event) noexcept {\n  onReadyEvent.init(event);\n}"
  },
  {
    "function_name": "EagerPromiseNodeBase::fire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "926-936",
    "snippet": "Maybe<Own<Event>> EagerPromiseNodeBase::fire() {\n  dependency->get(resultRef);\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([this]() {\n    dependency = nullptr;\n  })) {\n    resultRef.addException(kj::mv(*exception));\n  }\n\n  onReadyEvent.arm();\n  return nullptr;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onReadyEvent.arm",
          "args": [],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resultRef.addException",
          "args": [
            "kj::mv(*exception)"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "addException",
          "container": "ExceptionOrValue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "49-53",
          "snippet": "void addException(Exception&& exception) {\n    if (this->exception == nullptr) {\n      this->exception = kj::mv(exception);\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ExceptionOrValue {\n  void addException(Exception&& exception) {\n      if (this->exception == nullptr) {\n        this->exception = kj::mv(exception);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*exception"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exception",
            "kj::runCatchingExceptions([this]() {\n    dependency = nullptr;\n  })"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[this]() {\n    dependency = nullptr;\n  }"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dependency->get",
          "args": [
            "resultRef"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "82-84",
          "snippet": "void get(_::ExceptionOrValue& output) noexcept override {\n    KJ_FAIL_REQUIRE(\"Not ready.\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void get(_::ExceptionOrValue& output) noexcept override {\n      KJ_FAIL_REQUIRE(\"Not ready.\");\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nMaybe<Own<Event>> EagerPromiseNodeBase::fire() {\n  dependency->get(resultRef);\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([this]() {\n    dependency = nullptr;\n  })) {\n    resultRef.addException(kj::mv(*exception));\n  }\n\n  onReadyEvent.arm();\n  return nullptr;\n}"
  },
  {
    "function_name": "EagerPromiseNodeBase::onReady",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "918-920",
    "snippet": "void EagerPromiseNodeBase::onReady(Event& event) noexcept {\n  onReadyEvent.init(event);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onReadyEvent.init",
          "args": [
            "event"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/pointer-helpers.h",
          "lines": "51-53",
          "snippet": "static inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"layout.h\"\n\nstatic inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid EagerPromiseNodeBase::onReady(Event& event) noexcept {\n  onReadyEvent.init(event);\n}"
  },
  {
    "function_name": "EagerPromiseNodeBase::EagerPromiseNodeBase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "911-916",
    "snippet": "EagerPromiseNodeBase::EagerPromiseNodeBase(\n    Own<PromiseNode>&& dependencyParam, ExceptionOrValue& resultRef)\n    : dependency(kj::mv(dependencyParam)), resultRef(resultRef) {\n  dependency->setSelfPointer(&dependency);\n  dependency->onReady(*this);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dependency->onReady",
          "args": [
            "*this"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "onReady",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "79-81",
          "snippet": "void onReady(_::Event& event) noexcept override {\n    // ignore\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void onReady(_::Event& event) noexcept override {\n      // ignore\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dependency->setSelfPointer",
          "args": [
            "&dependency"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "dependencyParam"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nEagerPromiseNodeBase::EagerPromiseNodeBase(\n    Own<PromiseNode>&& dependencyParam, ExceptionOrValue& resultRef)\n    : dependency(kj::mv(dependencyParam)), resultRef(resultRef) {\n  dependency->setSelfPointer(&dependency);\n  dependency->onReady(*this);\n}"
  },
  {
    "function_name": "joinPromises",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "901-905",
    "snippet": "Promise<void> joinPromises(Array<Promise<void>>&& promises) {\n  return Promise<void>(false, kj::heap<_::ArrayJoinPromiseNode<void>>(\n      KJ_MAP(p, promises) { return kj::mv(p.node); },\n      heapArray<_::ExceptionOr<_::Void>>(promises.size())));\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Promise<void>",
          "args": [
            "false",
            "kj::heap<_::ArrayJoinPromiseNode<void>>(\n      KJ_MAP(p, promises) { return kj::mv(p.node); },\n      heapArray<_::ExceptionOr<_::Void>>(promises.size()))"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "ForkedPromise",
          "container": "ForkedPromise",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "319-319",
          "snippet": "inline ForkedPromise(bool, Own<_::ForkHub<_::FixVoid<T>>>&& hub): hub(kj::mv(hub)) {}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\nForkedPromise {\n  inline ForkedPromise(bool, Own<_::ForkHub<_::FixVoid<T>>>&& hub): hub(kj::mv(hub)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<_::ArrayJoinPromiseNode<void>>",
          "args": [
            "KJ_MAP(p, promises){ return kj::mv(p.node); }",
            "heapArray<_::ExceptionOr<_::Void>>(promises.size())"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heapArray<_::ExceptionOr<_::Void>>",
          "args": [
            "promises.size()"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promises.size",
          "args": [],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "p.node"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "p",
            "promises"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nPromise<void> joinPromises(Array<Promise<void>>&& promises) {\n  return Promise<void>(false, kj::heap<_::ArrayJoinPromiseNode<void>>(\n      KJ_MAP(p, promises) { return kj::mv(p.node); },\n      heapArray<_::ExceptionOr<_::Void>>(promises.size())));\n}"
  },
  {
    "function_name": "ArrayJoinPromiseNode<void>::getNoError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "895-897",
    "snippet": "void ArrayJoinPromiseNode<void>::getNoError(ExceptionOrValue& output) noexcept {\n  output.as<_::Void>() = _::Void();\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_::Void",
          "args": [],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.as<_::Void>",
          "args": [],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "as",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "601-604",
          "snippet": "BuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nBuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid ArrayJoinPromiseNode<void>::getNoError(ExceptionOrValue& output) noexcept {\n  output.as<_::Void>() = _::Void();\n}"
  },
  {
    "function_name": "ArrayJoinPromiseNode<void>::~ArrayJoinPromiseNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "893-893",
    "snippet": "ArrayJoinPromiseNode<void>::~ArrayJoinPromiseNode() {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nArrayJoinPromiseNode<void>::~ArrayJoinPromiseNode() {}"
  },
  {
    "function_name": "ArrayJoinPromiseNode<void>::ArrayJoinPromiseNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "888-891",
    "snippet": "ArrayJoinPromiseNode<void>::ArrayJoinPromiseNode(\n    Array<Own<PromiseNode>> promises, Array<ExceptionOr<_::Void>> resultParts)\n    : ArrayJoinPromiseNodeBase(kj::mv(promises), resultParts.begin(), sizeof(ExceptionOr<_::Void>)),\n      resultParts(kj::mv(resultParts)) {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "resultParts"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resultParts.begin",
          "args": [],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promises"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nArrayJoinPromiseNode<void>::ArrayJoinPromiseNode(\n    Array<Own<PromiseNode>> promises, Array<ExceptionOr<_::Void>> resultParts)\n    : ArrayJoinPromiseNodeBase(kj::mv(promises), resultParts.begin(), sizeof(ExceptionOr<_::Void>)),\n      resultParts(kj::mv(resultParts)) {}"
  },
  {
    "function_name": "ArrayJoinPromiseNodeBase::Branch::getPart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "883-886",
    "snippet": "Maybe<Exception> ArrayJoinPromiseNodeBase::Branch::getPart() {\n  dependency->get(output);\n  return kj::mv(output.exception);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "output.exception"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dependency->get",
          "args": [
            "output"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "82-84",
          "snippet": "void get(_::ExceptionOrValue& output) noexcept override {\n    KJ_FAIL_REQUIRE(\"Not ready.\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void get(_::ExceptionOrValue& output) noexcept override {\n      KJ_FAIL_REQUIRE(\"Not ready.\");\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nMaybe<Exception> ArrayJoinPromiseNodeBase::Branch::getPart() {\n  dependency->get(output);\n  return kj::mv(output.exception);\n}"
  },
  {
    "function_name": "ArrayJoinPromiseNodeBase::Branch::fire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "872-877",
    "snippet": "Maybe<Own<Event>> ArrayJoinPromiseNodeBase::Branch::fire() {\n  if (--joinNode.countLeft == 0) {\n    joinNode.onReadyEvent.arm();\n  }\n  return nullptr;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "joinNode.onReadyEvent.arm",
          "args": [],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nMaybe<Own<Event>> ArrayJoinPromiseNodeBase::Branch::fire() {\n  if (--joinNode.countLeft == 0) {\n    joinNode.onReadyEvent.arm();\n  }\n  return nullptr;\n}"
  },
  {
    "function_name": "ArrayJoinPromiseNodeBase::Branch::~Branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "870-870",
    "snippet": "ArrayJoinPromiseNodeBase::Branch::~Branch() noexcept(false) {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nArrayJoinPromiseNodeBase::Branch::~Branch() noexcept(false) {}"
  },
  {
    "function_name": "ArrayJoinPromiseNodeBase::Branch::Branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "863-868",
    "snippet": "ArrayJoinPromiseNodeBase::Branch::Branch(\n    ArrayJoinPromiseNodeBase& joinNode, Own<PromiseNode> dependencyParam, ExceptionOrValue& output)\n    : joinNode(joinNode), dependency(kj::mv(dependencyParam)), output(output) {\n  dependency->setSelfPointer(&dependency);\n  dependency->onReady(*this);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dependency->onReady",
          "args": [
            "*this"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "onReady",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "79-81",
          "snippet": "void onReady(_::Event& event) noexcept override {\n    // ignore\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void onReady(_::Event& event) noexcept override {\n      // ignore\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dependency->setSelfPointer",
          "args": [
            "&dependency"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "dependencyParam"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nArrayJoinPromiseNodeBase::Branch::Branch(\n    ArrayJoinPromiseNodeBase& joinNode, Own<PromiseNode> dependencyParam, ExceptionOrValue& output)\n    : joinNode(joinNode), dependency(kj::mv(dependencyParam)), output(output) {\n  dependency->setSelfPointer(&dependency);\n  dependency->onReady(*this);\n}"
  },
  {
    "function_name": "ArrayJoinPromiseNodeBase::get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "845-857",
    "snippet": "void ArrayJoinPromiseNodeBase::get(ExceptionOrValue& output) noexcept {\n  // If any of the elements threw exceptions, propagate them.\n  for (auto& branch: branches) {\n    KJ_IF_MAYBE(exception, branch.getPart()) {\n      output.addException(kj::mv(*exception));\n    }\n  }\n\n  if (output.exception == nullptr) {\n    // No errors.  The template subclass will need to fill in the result.\n    getNoError(output);\n  }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getNoError",
          "args": [
            "output"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayJoinPromiseNode<void>::getNoError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "895-897",
          "snippet": "void ArrayJoinPromiseNode<void>::getNoError(ExceptionOrValue& output) noexcept {\n  output.as<_::Void>() = _::Void();\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid ArrayJoinPromiseNode<void>::getNoError(ExceptionOrValue& output) noexcept {\n  output.as<_::Void>() = _::Void();\n}"
        }
      },
      {
        "call_info": {
          "callee": "output.addException",
          "args": [
            "kj::mv(*exception)"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "addException",
          "container": "ExceptionOrValue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "49-53",
          "snippet": "void addException(Exception&& exception) {\n    if (this->exception == nullptr) {\n      this->exception = kj::mv(exception);\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ExceptionOrValue {\n  void addException(Exception&& exception) {\n      if (this->exception == nullptr) {\n        this->exception = kj::mv(exception);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*exception"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exception",
            "branch.getPart()"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "branch.getPart",
          "args": [],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid ArrayJoinPromiseNodeBase::get(ExceptionOrValue& output) noexcept {\n  // If any of the elements threw exceptions, propagate them.\n  for (auto& branch: branches) {\n    KJ_IF_MAYBE(exception, branch.getPart()) {\n      output.addException(kj::mv(*exception));\n    }\n  }\n\n  if (output.exception == nullptr) {\n    // No errors.  The template subclass will need to fill in the result.\n    getNoError(output);\n  }\n}"
  },
  {
    "function_name": "ArrayJoinPromiseNodeBase::onReady",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "841-843",
    "snippet": "void ArrayJoinPromiseNodeBase::onReady(Event& event) noexcept {\n  onReadyEvent.init(event);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onReadyEvent.init",
          "args": [
            "event"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/pointer-helpers.h",
          "lines": "51-53",
          "snippet": "static inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"layout.h\"\n\nstatic inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid ArrayJoinPromiseNodeBase::onReady(Event& event) noexcept {\n  onReadyEvent.init(event);\n}"
  },
  {
    "function_name": "ArrayJoinPromiseNodeBase::~ArrayJoinPromiseNodeBase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "839-839",
    "snippet": "ArrayJoinPromiseNodeBase::~ArrayJoinPromiseNodeBase() noexcept(false) {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nArrayJoinPromiseNodeBase::~ArrayJoinPromiseNodeBase() noexcept(false) {}"
  },
  {
    "function_name": "ArrayJoinPromiseNodeBase::ArrayJoinPromiseNodeBase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "823-838",
    "snippet": "ArrayJoinPromiseNodeBase::ArrayJoinPromiseNodeBase(\n    Array<Own<PromiseNode>> promises, ExceptionOrValue* resultParts, size_t partSize)\n    : countLeft(promises.size()) {\n  // Make the branches.\n  auto builder = heapArrayBuilder<Branch>(promises.size());\n  for (uint i: indices(promises)) {\n    ExceptionOrValue& output = *reinterpret_cast<ExceptionOrValue*>(\n        reinterpret_cast<byte*>(resultParts) + i * partSize);\n    builder.add(*this, kj::mv(promises[i]), output);\n  }\n  branches = builder.finish();\n\n  if (branches.size() == 0) {\n    onReadyEvent.arm();\n  }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onReadyEvent.arm",
          "args": [],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "branches.size",
          "args": [],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.finish",
          "args": [],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.add",
          "args": [
            "*this",
            "kj::mv(promises[i])",
            "output"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promises[i]"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<ExceptionOrValue*>",
          "args": [
            "reinterpret_cast<byte*>(resultParts) + i * partSize"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "resultParts"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indices",
          "args": [
            "promises"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "heapArrayBuilder<Branch>",
          "args": [
            "promises.size()"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "heapArrayBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "410-416",
          "snippet": "inline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nArrayJoinPromiseNodeBase::ArrayJoinPromiseNodeBase(\n    Array<Own<PromiseNode>> promises, ExceptionOrValue* resultParts, size_t partSize)\n    : countLeft(promises.size()) {\n  // Make the branches.\n  auto builder = heapArrayBuilder<Branch>(promises.size());\n  for (uint i: indices(promises)) {\n    ExceptionOrValue& output = *reinterpret_cast<ExceptionOrValue*>(\n        reinterpret_cast<byte*>(resultParts) + i * partSize);\n    builder.add(*this, kj::mv(promises[i]), output);\n  }\n  branches = builder.finish();\n\n  if (branches.size() == 0) {\n    onReadyEvent.arm();\n  }\n}"
  },
  {
    "function_name": "ExclusiveJoinPromiseNode::Branch::fire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "805-815",
    "snippet": "Maybe<Own<Event>> ExclusiveJoinPromiseNode::Branch::fire() {\n  // Cancel the branch that didn't return first.  Ignore exceptions caused by cancellation.\n  if (this == &joinNode.left) {\n    kj::runCatchingExceptions([&]() { joinNode.right.dependency = nullptr; });\n  } else {\n    kj::runCatchingExceptions([&]() { joinNode.left.dependency = nullptr; });\n  }\n\n  joinNode.onReadyEvent.arm();\n  return nullptr;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "joinNode.onReadyEvent.arm",
          "args": [],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() { joinNode.left.dependency = nullptr; }"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() { joinNode.right.dependency = nullptr; }"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nMaybe<Own<Event>> ExclusiveJoinPromiseNode::Branch::fire() {\n  // Cancel the branch that didn't return first.  Ignore exceptions caused by cancellation.\n  if (this == &joinNode.left) {\n    kj::runCatchingExceptions([&]() { joinNode.right.dependency = nullptr; });\n  } else {\n    kj::runCatchingExceptions([&]() { joinNode.left.dependency = nullptr; });\n  }\n\n  joinNode.onReadyEvent.arm();\n  return nullptr;\n}"
  },
  {
    "function_name": "ExclusiveJoinPromiseNode::Branch::get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "796-803",
    "snippet": "bool ExclusiveJoinPromiseNode::Branch::get(ExceptionOrValue& output) {\n  if (dependency) {\n    dependency->get(output);\n    return true;\n  } else {\n    return false;\n  }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dependency->get",
          "args": [
            "output"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "82-84",
          "snippet": "void get(_::ExceptionOrValue& output) noexcept override {\n    KJ_FAIL_REQUIRE(\"Not ready.\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void get(_::ExceptionOrValue& output) noexcept override {\n      KJ_FAIL_REQUIRE(\"Not ready.\");\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nbool ExclusiveJoinPromiseNode::Branch::get(ExceptionOrValue& output) {\n  if (dependency) {\n    dependency->get(output);\n    return true;\n  } else {\n    return false;\n  }\n}"
  },
  {
    "function_name": "ExclusiveJoinPromiseNode::Branch::~Branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "794-794",
    "snippet": "ExclusiveJoinPromiseNode::Branch::~Branch() noexcept(false) {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nExclusiveJoinPromiseNode::Branch::~Branch() noexcept(false) {}"
  },
  {
    "function_name": "ExclusiveJoinPromiseNode::Branch::Branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "787-792",
    "snippet": "ExclusiveJoinPromiseNode::Branch::Branch(\n    ExclusiveJoinPromiseNode& joinNode, Own<PromiseNode> dependencyParam)\n    : joinNode(joinNode), dependency(kj::mv(dependencyParam)) {\n  dependency->setSelfPointer(&dependency);\n  dependency->onReady(*this);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dependency->onReady",
          "args": [
            "*this"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "onReady",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "79-81",
          "snippet": "void onReady(_::Event& event) noexcept override {\n    // ignore\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void onReady(_::Event& event) noexcept override {\n      // ignore\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dependency->setSelfPointer",
          "args": [
            "&dependency"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "dependencyParam"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nExclusiveJoinPromiseNode::Branch::Branch(\n    ExclusiveJoinPromiseNode& joinNode, Own<PromiseNode> dependencyParam)\n    : joinNode(joinNode), dependency(kj::mv(dependencyParam)) {\n  dependency->setSelfPointer(&dependency);\n  dependency->onReady(*this);\n}"
  },
  {
    "function_name": "ExclusiveJoinPromiseNode::get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "775-777",
    "snippet": "void ExclusiveJoinPromiseNode::get(ExceptionOrValue& output) noexcept {\n  KJ_REQUIRE(left.get(output) || right.get(output), \"get() called before ready.\");\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "left.get(output) || right.get(output)",
            "\"get() called before ready.\""
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "right.get",
          "args": [
            "output"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "82-84",
          "snippet": "void get(_::ExceptionOrValue& output) noexcept override {\n    KJ_FAIL_REQUIRE(\"Not ready.\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void get(_::ExceptionOrValue& output) noexcept override {\n      KJ_FAIL_REQUIRE(\"Not ready.\");\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid ExclusiveJoinPromiseNode::get(ExceptionOrValue& output) noexcept {\n  KJ_REQUIRE(left.get(output) || right.get(output), \"get() called before ready.\");\n}"
  },
  {
    "function_name": "ExclusiveJoinPromiseNode::onReady",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "771-773",
    "snippet": "void ExclusiveJoinPromiseNode::onReady(Event& event) noexcept {\n  onReadyEvent.init(event);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onReadyEvent.init",
          "args": [
            "event"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/pointer-helpers.h",
          "lines": "51-53",
          "snippet": "static inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"layout.h\"\n\nstatic inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid ExclusiveJoinPromiseNode::onReady(Event& event) noexcept {\n  onReadyEvent.init(event);\n}"
  },
  {
    "function_name": "ExclusiveJoinPromiseNode::~ExclusiveJoinPromiseNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "769-769",
    "snippet": "ExclusiveJoinPromiseNode::~ExclusiveJoinPromiseNode() noexcept(false) {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nExclusiveJoinPromiseNode::~ExclusiveJoinPromiseNode() noexcept(false) {}"
  },
  {
    "function_name": "ExclusiveJoinPromiseNode::ExclusiveJoinPromiseNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "766-767",
    "snippet": "ExclusiveJoinPromiseNode::ExclusiveJoinPromiseNode(Own<PromiseNode> left, Own<PromiseNode> right)\n    : left(*this, kj::mv(left)), right(*this, kj::mv(right)) {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "right"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "left"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nExclusiveJoinPromiseNode::ExclusiveJoinPromiseNode(Own<PromiseNode> left, Own<PromiseNode> right)\n    : left(*this, kj::mv(left)), right(*this, kj::mv(right)) {}"
  },
  {
    "function_name": "ChainPromiseNode::fire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "712-740",
    "snippet": "Maybe<Own<Event>> ChainPromiseNode::fire() {\n  KJ_REQUIRE(state != STEP2);\n\n  static_assert(sizeof(Promise<int>) == sizeof(PromiseBase),\n      \"This code assumes Promise<T> does not add any new members to PromiseBase.\");\n\n  ExceptionOr<PromiseBase> intermediate;\n  inner->get(intermediate);\n\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([this]() {\n    inner = nullptr;\n  })) {\n    intermediate.addException(kj::mv(*exception));\n  }\n\n  KJ_IF_MAYBE(exception, intermediate.exception) {\n    // There is an exception.  If there is also a value, delete it.\n    kj::runCatchingExceptions([&,this]() { intermediate.value = nullptr; });\n    // Now set step2 to a rejected promise.\n    inner = heap<ImmediateBrokenPromiseNode>(kj::mv(*exception));\n  } else KJ_IF_MAYBE(value, intermediate.value) {\n    // There is a value and no exception.  The value is itself a promise.  Adopt it as our\n    // step2.\n    inner = kj::mv(value->node);\n  } else {\n    // We can only get here if inner->get() returned neither an exception nor a\n    // value, which never actually happens.\n    KJ_FAIL_ASSERT(\"Inner node returned empty value.\");\n  }",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Inner node returned empty value.\""
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "value->node"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap<ImmediateBrokenPromiseNode>",
          "args": [
            "kj::mv(*exception)"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*exception"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&,this]() { intermediate.value = nullptr; }"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exception",
            "intermediate.exception"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "intermediate.addException",
          "args": [
            "kj::mv(*exception)"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "addException",
          "container": "ExceptionOrValue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "49-53",
          "snippet": "void addException(Exception&& exception) {\n    if (this->exception == nullptr) {\n      this->exception = kj::mv(exception);\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ExceptionOrValue {\n  void addException(Exception&& exception) {\n      if (this->exception == nullptr) {\n        this->exception = kj::mv(exception);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*exception"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[this]() {\n    inner = nullptr;\n  }"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inner->get",
          "args": [
            "intermediate"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "82-84",
          "snippet": "void get(_::ExceptionOrValue& output) noexcept override {\n    KJ_FAIL_REQUIRE(\"Not ready.\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void get(_::ExceptionOrValue& output) noexcept override {\n      KJ_FAIL_REQUIRE(\"Not ready.\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "state != STEP2"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nMaybe<Own<Event>> ChainPromiseNode::fire() {\n  KJ_REQUIRE(state != STEP2);\n\n  static_assert(sizeof(Promise<int>) == sizeof(PromiseBase),\n      \"This code assumes Promise<T> does not add any new members to PromiseBase.\");\n\n  ExceptionOr<PromiseBase> intermediate;\n  inner->get(intermediate);\n\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([this]() {\n    inner = nullptr;\n  })) {\n    intermediate.addException(kj::mv(*exception));\n  }\n\n  KJ_IF_MAYBE(exception, intermediate.exception) {\n    // There is an exception.  If there is also a value, delete it.\n    kj::runCatchingExceptions([&,this]() { intermediate.value = nullptr; });\n    // Now set step2 to a rejected promise.\n    inner = heap<ImmediateBrokenPromiseNode>(kj::mv(*exception));\n  } else KJ_IF_MAYBE(value, intermediate.value) {\n    // There is a value and no exception.  The value is itself a promise.  Adopt it as our\n    // step2.\n    inner = kj::mv(value->node);\n  } else {\n    // We can only get here if inner->get() returned neither an exception nor a\n    // value, which never actually happens.\n    KJ_FAIL_ASSERT(\"Inner node returned empty value.\");\n  }"
  },
  {
    "function_name": "ChainPromiseNode::get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "703-706",
    "snippet": "void ChainPromiseNode::get(ExceptionOrValue& output) noexcept {\n  KJ_REQUIRE(state == STEP2);\n  return inner->get(output);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inner->get",
          "args": [
            "output"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "82-84",
          "snippet": "void get(_::ExceptionOrValue& output) noexcept override {\n    KJ_FAIL_REQUIRE(\"Not ready.\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void get(_::ExceptionOrValue& output) noexcept override {\n      KJ_FAIL_REQUIRE(\"Not ready.\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "state == STEP2"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid ChainPromiseNode::get(ExceptionOrValue& output) noexcept {\n  KJ_REQUIRE(state == STEP2);\n  return inner->get(output);\n}"
  },
  {
    "function_name": "ChainPromiseNode::setSelfPointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "694-701",
    "snippet": "void ChainPromiseNode::setSelfPointer(Own<PromiseNode>* selfPtr) noexcept {\n  if (state == STEP2) {\n    *selfPtr = kj::mv(inner);  // deletes this!\n    selfPtr->get()->setSelfPointer(selfPtr);\n  } else {\n    this->selfPtr = selfPtr;\n  }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "selfPtr->get",
          "args": [
            "selfPtr"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "82-84",
          "snippet": "void get(_::ExceptionOrValue& output) noexcept override {\n    KJ_FAIL_REQUIRE(\"Not ready.\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void get(_::ExceptionOrValue& output) noexcept override {\n      KJ_FAIL_REQUIRE(\"Not ready.\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "selfPtr->get",
          "args": [],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "AutoCloseFd",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.h",
          "lines": "258-258",
          "snippet": "inline int get() const { return fd; }",
          "includes": [
            "#include \"exception.h\"",
            "#include \"array.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exception.h\"\n#include \"array.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nAutoCloseFd {\n  inline int get() const { return fd; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "inner"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid ChainPromiseNode::setSelfPointer(Own<PromiseNode>* selfPtr) noexcept {\n  if (state == STEP2) {\n    *selfPtr = kj::mv(inner);  // deletes this!\n    selfPtr->get()->setSelfPointer(selfPtr);\n  } else {\n    this->selfPtr = selfPtr;\n  }\n}"
  },
  {
    "function_name": "ChainPromiseNode::onReady",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "681-692",
    "snippet": "void ChainPromiseNode::onReady(Event& event) noexcept {\n  switch (state) {\n    case STEP1:\n      KJ_REQUIRE(onReadyEvent == nullptr, \"onReady() can only be called once.\");\n      onReadyEvent = &event;\n      return;\n    case STEP2:\n      inner->onReady(event);\n      return;\n  }\n  KJ_UNREACHABLE;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inner->onReady",
          "args": [
            "event"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "onReady",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "79-81",
          "snippet": "void onReady(_::Event& event) noexcept override {\n    // ignore\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void onReady(_::Event& event) noexcept override {\n      // ignore\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "onReadyEvent == nullptr",
            "\"onReady() can only be called once.\""
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid ChainPromiseNode::onReady(Event& event) noexcept {\n  switch (state) {\n    case STEP1:\n      KJ_REQUIRE(onReadyEvent == nullptr, \"onReady() can only be called once.\");\n      onReadyEvent = &event;\n      return;\n    case STEP2:\n      inner->onReady(event);\n      return;\n  }\n  KJ_UNREACHABLE;\n}"
  },
  {
    "function_name": "ChainPromiseNode::~ChainPromiseNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "679-679",
    "snippet": "ChainPromiseNode::~ChainPromiseNode() noexcept(false) {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nChainPromiseNode::~ChainPromiseNode() noexcept(false) {}"
  },
  {
    "function_name": "ChainPromiseNode::ChainPromiseNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "673-677",
    "snippet": "ChainPromiseNode::ChainPromiseNode(Own<PromiseNode> innerParam)\n    : state(STEP1), inner(kj::mv(innerParam)) {\n  inner->setSelfPointer(&inner);\n  inner->onReady(*this);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inner->onReady",
          "args": [
            "*this"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "onReady",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "79-81",
          "snippet": "void onReady(_::Event& event) noexcept override {\n    // ignore\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void onReady(_::Event& event) noexcept override {\n      // ignore\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "inner->setSelfPointer",
          "args": [
            "&inner"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "innerParam"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nChainPromiseNode::ChainPromiseNode(Own<PromiseNode> innerParam)\n    : state(STEP1), inner(kj::mv(innerParam)) {\n  inner->setSelfPointer(&inner);\n  inner->onReady(*this);\n}"
  },
  {
    "function_name": "ForkHubBase::fire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "645-665",
    "snippet": "Maybe<Own<Event>> ForkHubBase::fire() {\n  // Dependency is ready.  Fetch its result and then delete the node.\n  inner->get(resultRef);\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([this]() {\n    inner = nullptr;\n  })) {\n    resultRef.addException(kj::mv(*exception));\n  }\n\n  for (auto branch = headBranch; branch != nullptr; branch = branch->next) {\n    branch->hubReady();\n    *branch->prevPtr = nullptr;\n    branch->prevPtr = nullptr;\n  }\n  *tailBranch = nullptr;\n\n  // Indicate that the list is no longer active.\n  tailBranch = nullptr;\n\n  return nullptr;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "branch->hubReady",
          "args": [],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resultRef.addException",
          "args": [
            "kj::mv(*exception)"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "addException",
          "container": "ExceptionOrValue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "49-53",
          "snippet": "void addException(Exception&& exception) {\n    if (this->exception == nullptr) {\n      this->exception = kj::mv(exception);\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ExceptionOrValue {\n  void addException(Exception&& exception) {\n      if (this->exception == nullptr) {\n        this->exception = kj::mv(exception);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*exception"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exception",
            "kj::runCatchingExceptions([this]() {\n    inner = nullptr;\n  })"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[this]() {\n    inner = nullptr;\n  }"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inner->get",
          "args": [
            "resultRef"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "82-84",
          "snippet": "void get(_::ExceptionOrValue& output) noexcept override {\n    KJ_FAIL_REQUIRE(\"Not ready.\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void get(_::ExceptionOrValue& output) noexcept override {\n      KJ_FAIL_REQUIRE(\"Not ready.\");\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nMaybe<Own<Event>> ForkHubBase::fire() {\n  // Dependency is ready.  Fetch its result and then delete the node.\n  inner->get(resultRef);\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([this]() {\n    inner = nullptr;\n  })) {\n    resultRef.addException(kj::mv(*exception));\n  }\n\n  for (auto branch = headBranch; branch != nullptr; branch = branch->next) {\n    branch->hubReady();\n    *branch->prevPtr = nullptr;\n    branch->prevPtr = nullptr;\n  }\n  *tailBranch = nullptr;\n\n  // Indicate that the list is no longer active.\n  tailBranch = nullptr;\n\n  return nullptr;\n}"
  },
  {
    "function_name": "ForkHubBase::ForkHubBase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "639-643",
    "snippet": "ForkHubBase::ForkHubBase(Own<PromiseNode>&& innerParam, ExceptionOrValue& resultRef)\n    : inner(kj::mv(innerParam)), resultRef(resultRef) {\n  inner->setSelfPointer(&inner);\n  inner->onReady(*this);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inner->onReady",
          "args": [
            "*this"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "onReady",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "79-81",
          "snippet": "void onReady(_::Event& event) noexcept override {\n    // ignore\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void onReady(_::Event& event) noexcept override {\n      // ignore\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "inner->setSelfPointer",
          "args": [
            "&inner"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "innerParam"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nForkHubBase::ForkHubBase(Own<PromiseNode>&& innerParam, ExceptionOrValue& resultRef)\n    : inner(kj::mv(innerParam)), resultRef(resultRef) {\n  inner->setSelfPointer(&inner);\n  inner->onReady(*this);\n}"
  },
  {
    "function_name": "ForkBranchBase::onReady",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "629-631",
    "snippet": "void ForkBranchBase::onReady(Event& event) noexcept {\n  onReadyEvent.init(event);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onReadyEvent.init",
          "args": [
            "event"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/pointer-helpers.h",
          "lines": "51-53",
          "snippet": "static inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"layout.h\"\n\nstatic inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid ForkBranchBase::onReady(Event& event) noexcept {\n  onReadyEvent.init(event);\n}"
  },
  {
    "function_name": "ForkBranchBase::releaseHub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "621-627",
    "snippet": "void ForkBranchBase::releaseHub(ExceptionOrValue& output) {\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([this]() {\n    hub = nullptr;\n  })) {\n    output.addException(kj::mv(*exception));\n  }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "output.addException",
          "args": [
            "kj::mv(*exception)"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "addException",
          "container": "ExceptionOrValue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "49-53",
          "snippet": "void addException(Exception&& exception) {\n    if (this->exception == nullptr) {\n      this->exception = kj::mv(exception);\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ExceptionOrValue {\n  void addException(Exception&& exception) {\n      if (this->exception == nullptr) {\n        this->exception = kj::mv(exception);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*exception"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exception",
            "kj::runCatchingExceptions([this]() {\n    hub = nullptr;\n  })"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[this]() {\n    hub = nullptr;\n  }"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid ForkBranchBase::releaseHub(ExceptionOrValue& output) {\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([this]() {\n    hub = nullptr;\n  })) {\n    output.addException(kj::mv(*exception));\n  }\n}"
  },
  {
    "function_name": "ForkBranchBase::hubReady",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "617-619",
    "snippet": "void ForkBranchBase::hubReady() noexcept {\n  onReadyEvent.arm();\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onReadyEvent.arm",
          "args": [],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid ForkBranchBase::hubReady() noexcept {\n  onReadyEvent.arm();\n}"
  },
  {
    "function_name": "ForkBranchBase::~ForkBranchBase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "609-615",
    "snippet": "ForkBranchBase::~ForkBranchBase() noexcept(false) {\n  if (prevPtr != nullptr) {\n    // Remove from hub's linked list of branches.\n    *prevPtr = next;\n    (next == nullptr ? hub->tailBranch : next->prevPtr) = prevPtr;\n  }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nForkBranchBase::~ForkBranchBase() noexcept(false) {\n  if (prevPtr != nullptr) {\n    // Remove from hub's linked list of branches.\n    *prevPtr = next;\n    (next == nullptr ? hub->tailBranch : next->prevPtr) = prevPtr;\n  }\n}"
  },
  {
    "function_name": "ForkBranchBase::ForkBranchBase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "597-607",
    "snippet": "ForkBranchBase::ForkBranchBase(Own<ForkHubBase>&& hubParam): hub(kj::mv(hubParam)) {\n  if (hub->tailBranch == nullptr) {\n    onReadyEvent.arm();\n  } else {\n    // Insert into hub's linked list of branches.\n    prevPtr = hub->tailBranch;\n    *prevPtr = this;\n    next = nullptr;\n    hub->tailBranch = &next;\n  }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onReadyEvent.arm",
          "args": [],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "hubParam"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nForkBranchBase::ForkBranchBase(Own<ForkHubBase>&& hubParam): hub(kj::mv(hubParam)) {\n  if (hub->tailBranch == nullptr) {\n    onReadyEvent.arm();\n  } else {\n    // Insert into hub's linked list of branches.\n    prevPtr = hub->tailBranch;\n    *prevPtr = this;\n    next = nullptr;\n    hub->tailBranch = &next;\n  }\n}"
  },
  {
    "function_name": "TransformPromiseNodeBase::getDepResult",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "586-593",
    "snippet": "void TransformPromiseNodeBase::getDepResult(ExceptionOrValue& output) {\n  dependency->get(output);\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n    dependency = nullptr;\n  })) {\n    output.addException(kj::mv(*exception));\n  }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "output.addException",
          "args": [
            "kj::mv(*exception)"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "addException",
          "container": "ExceptionOrValue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "49-53",
          "snippet": "void addException(Exception&& exception) {\n    if (this->exception == nullptr) {\n      this->exception = kj::mv(exception);\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ExceptionOrValue {\n  void addException(Exception&& exception) {\n      if (this->exception == nullptr) {\n        this->exception = kj::mv(exception);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*exception"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exception",
            "kj::runCatchingExceptions([&]() {\n    dependency = nullptr;\n  })"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() {\n    dependency = nullptr;\n  }"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dependency->get",
          "args": [
            "output"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "82-84",
          "snippet": "void get(_::ExceptionOrValue& output) noexcept override {\n    KJ_FAIL_REQUIRE(\"Not ready.\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void get(_::ExceptionOrValue& output) noexcept override {\n      KJ_FAIL_REQUIRE(\"Not ready.\");\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid TransformPromiseNodeBase::getDepResult(ExceptionOrValue& output) {\n  dependency->get(output);\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n    dependency = nullptr;\n  })) {\n    output.addException(kj::mv(*exception));\n  }\n}"
  },
  {
    "function_name": "TransformPromiseNodeBase::dropDependency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "582-584",
    "snippet": "void TransformPromiseNodeBase::dropDependency() {\n  dependency = nullptr;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid TransformPromiseNodeBase::dropDependency() {\n  dependency = nullptr;\n}"
  },
  {
    "function_name": "TransformPromiseNodeBase::get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "569-576",
    "snippet": "void TransformPromiseNodeBase::get(ExceptionOrValue& output) noexcept {\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n    getImpl(output);\n    dropDependency();\n  })) {\n    output.addException(kj::mv(*exception));\n  }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "output.addException",
          "args": [
            "kj::mv(*exception)"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "addException",
          "container": "ExceptionOrValue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "49-53",
          "snippet": "void addException(Exception&& exception) {\n    if (this->exception == nullptr) {\n      this->exception = kj::mv(exception);\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ExceptionOrValue {\n  void addException(Exception&& exception) {\n      if (this->exception == nullptr) {\n        this->exception = kj::mv(exception);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*exception"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exception",
            "kj::runCatchingExceptions([&]() {\n    getImpl(output);\n    dropDependency();\n  })"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() {\n    getImpl(output);\n    dropDependency();\n  }"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dropDependency",
          "args": [],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "TransformPromiseNodeBase::dropDependency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "582-584",
          "snippet": "void TransformPromiseNodeBase::dropDependency() {\n  dependency = nullptr;\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid TransformPromiseNodeBase::dropDependency() {\n  dependency = nullptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getImpl",
          "args": [
            "output"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "getImpl",
          "container": "TransformPromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "290-300",
          "snippet": "void getImpl(ExceptionOrValue& output) override {\n    ExceptionOr<DepT> depResult;\n    getDepResult(depResult);\n    KJ_IF_MAYBE(depException, depResult.exception) {\n      output.as<T>() = handle(\n          MaybeVoidCaller<Exception, FixVoid<ReturnType<ErrorFunc, Exception>>>::apply(\n              errorHandler, kj::mv(*depException)));\n    } else KJ_IF_MAYBE(depValue, depResult.value) {\n      output.as<T>() = handle(MaybeVoidCaller<DepT, T>::apply(func, kj::mv(*depValue)));\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "TransformPromiseNode {\n  void getImpl(ExceptionOrValue& output) override {\n      ExceptionOr<DepT> depResult;\n      getDepResult(depResult);\n      KJ_IF_MAYBE(depException, depResult.exception) {\n        output.as<T>() = handle(\n            MaybeVoidCaller<Exception, FixVoid<ReturnType<ErrorFunc, Exception>>>::apply(\n                errorHandler, kj::mv(*depException)));\n      } else KJ_IF_MAYBE(depValue, depResult.value) {\n        output.as<T>() = handle(MaybeVoidCaller<DepT, T>::apply(func, kj::mv(*depValue)));\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid TransformPromiseNodeBase::get(ExceptionOrValue& output) noexcept {\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n    getImpl(output);\n    dropDependency();\n  })) {\n    output.addException(kj::mv(*exception));\n  }\n}"
  },
  {
    "function_name": "TransformPromiseNodeBase::onReady",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "565-567",
    "snippet": "void TransformPromiseNodeBase::onReady(Event& event) noexcept {\n  dependency->onReady(event);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dependency->onReady",
          "args": [
            "event"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "onReady",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "79-81",
          "snippet": "void onReady(_::Event& event) noexcept override {\n    // ignore\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void onReady(_::Event& event) noexcept override {\n      // ignore\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid TransformPromiseNodeBase::onReady(Event& event) noexcept {\n  dependency->onReady(event);\n}"
  },
  {
    "function_name": "TransformPromiseNodeBase::TransformPromiseNodeBase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "560-563",
    "snippet": "TransformPromiseNodeBase::TransformPromiseNodeBase(Own<PromiseNode>&& dependencyParam)\n    : dependency(kj::mv(dependencyParam)) {\n  dependency->setSelfPointer(&dependency);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dependency->setSelfPointer",
          "args": [
            "&dependency"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "dependencyParam"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTransformPromiseNodeBase::TransformPromiseNodeBase(Own<PromiseNode>&& dependencyParam)\n    : dependency(kj::mv(dependencyParam)) {\n  dependency->setSelfPointer(&dependency);\n}"
  },
  {
    "function_name": "AttachmentPromiseNodeBase::dropDependency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "554-556",
    "snippet": "void AttachmentPromiseNodeBase::dropDependency() {\n  dependency = nullptr;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid AttachmentPromiseNodeBase::dropDependency() {\n  dependency = nullptr;\n}"
  },
  {
    "function_name": "AttachmentPromiseNodeBase::get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "546-548",
    "snippet": "void AttachmentPromiseNodeBase::get(ExceptionOrValue& output) noexcept {\n  dependency->get(output);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dependency->get",
          "args": [
            "output"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "82-84",
          "snippet": "void get(_::ExceptionOrValue& output) noexcept override {\n    KJ_FAIL_REQUIRE(\"Not ready.\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void get(_::ExceptionOrValue& output) noexcept override {\n      KJ_FAIL_REQUIRE(\"Not ready.\");\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid AttachmentPromiseNodeBase::get(ExceptionOrValue& output) noexcept {\n  dependency->get(output);\n}"
  },
  {
    "function_name": "AttachmentPromiseNodeBase::onReady",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "542-544",
    "snippet": "void AttachmentPromiseNodeBase::onReady(Event& event) noexcept {\n  dependency->onReady(event);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dependency->onReady",
          "args": [
            "event"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "onReady",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "79-81",
          "snippet": "void onReady(_::Event& event) noexcept override {\n    // ignore\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void onReady(_::Event& event) noexcept override {\n      // ignore\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid AttachmentPromiseNodeBase::onReady(Event& event) noexcept {\n  dependency->onReady(event);\n}"
  },
  {
    "function_name": "AttachmentPromiseNodeBase::AttachmentPromiseNodeBase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "537-540",
    "snippet": "AttachmentPromiseNodeBase::AttachmentPromiseNodeBase(Own<PromiseNode>&& dependencyParam)\n    : dependency(kj::mv(dependencyParam)) {\n  dependency->setSelfPointer(&dependency);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dependency->setSelfPointer",
          "args": [
            "&dependency"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "dependencyParam"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nAttachmentPromiseNodeBase::AttachmentPromiseNodeBase(Own<PromiseNode>&& dependencyParam)\n    : dependency(kj::mv(dependencyParam)) {\n  dependency->setSelfPointer(&dependency);\n}"
  },
  {
    "function_name": "ImmediateBrokenPromiseNode::get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "531-533",
    "snippet": "void ImmediateBrokenPromiseNode::get(ExceptionOrValue& output) noexcept {\n  output.exception = kj::mv(exception);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid ImmediateBrokenPromiseNode::get(ExceptionOrValue& output) noexcept {\n  output.exception = kj::mv(exception);\n}"
  },
  {
    "function_name": "ImmediateBrokenPromiseNode::ImmediateBrokenPromiseNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "528-529",
    "snippet": "ImmediateBrokenPromiseNode::ImmediateBrokenPromiseNode(Exception&& exception)\n    : exception(kj::mv(exception)) {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nImmediateBrokenPromiseNode::ImmediateBrokenPromiseNode(Exception&& exception)\n    : exception(kj::mv(exception)) {}"
  },
  {
    "function_name": "ImmediatePromiseNodeBase::onReady",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "524-526",
    "snippet": "void ImmediatePromiseNodeBase::onReady(Event& event) noexcept {\n  event.armBreadthFirst();\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event.armBreadthFirst",
          "args": [],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid ImmediatePromiseNodeBase::onReady(Event& event) noexcept {\n  event.armBreadthFirst();\n}"
  },
  {
    "function_name": "ImmediatePromiseNodeBase::~ImmediatePromiseNodeBase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "522-522",
    "snippet": "ImmediatePromiseNodeBase::~ImmediatePromiseNodeBase() noexcept(false) {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nImmediatePromiseNodeBase::~ImmediatePromiseNodeBase() noexcept(false) {}"
  },
  {
    "function_name": "ImmediatePromiseNodeBase::ImmediatePromiseNodeBase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "521-521",
    "snippet": "ImmediatePromiseNodeBase::ImmediatePromiseNodeBase() {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nImmediatePromiseNodeBase::ImmediatePromiseNodeBase() {}"
  },
  {
    "function_name": "PromiseNode::OnReadyEvent::arm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "508-517",
    "snippet": "void PromiseNode::OnReadyEvent::arm() {\n  if (event == nullptr) {\n    event = _kJ_ALREADY_READY;\n  } else {\n    // A promise resolved and an event is already waiting on it.  In this case, arm in depth-first\n    // order so that the event runs immediately after the current one.  This way, chained promises\n    // execute together for better cache locality and lower latency.\n    event->armDepthFirst();\n  }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [
      "#define _kJ_ALREADY_READY reinterpret_cast< ::kj::_::Event*>(1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event->armDepthFirst",
          "args": [],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\n#define _kJ_ALREADY_READY reinterpret_cast< ::kj::_::Event*>(1)\n\nvoid PromiseNode::OnReadyEvent::arm() {\n  if (event == nullptr) {\n    event = _kJ_ALREADY_READY;\n  } else {\n    // A promise resolved and an event is already waiting on it.  In this case, arm in depth-first\n    // order so that the event runs immediately after the current one.  This way, chained promises\n    // execute together for better cache locality and lower latency.\n    event->armDepthFirst();\n  }\n}"
  },
  {
    "function_name": "PromiseNode::OnReadyEvent::init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "497-506",
    "snippet": "void PromiseNode::OnReadyEvent::init(Event& newEvent) {\n  if (event == _kJ_ALREADY_READY) {\n    // A new continuation was added to a promise that was already ready.  In this case, we schedule\n    // breadth-first, to make it difficult for applications to accidentally starve the event loop\n    // by repeatedly waiting on immediate promises.\n    newEvent.armBreadthFirst();\n  } else {\n    event = &newEvent;\n  }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [
      "#define _kJ_ALREADY_READY reinterpret_cast< ::kj::_::Event*>(1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "newEvent.armBreadthFirst",
          "args": [],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\n#define _kJ_ALREADY_READY reinterpret_cast< ::kj::_::Event*>(1)\n\nvoid PromiseNode::OnReadyEvent::init(Event& newEvent) {\n  if (event == _kJ_ALREADY_READY) {\n    // A new continuation was added to a promise that was already ready.  In this case, we schedule\n    // breadth-first, to make it difficult for applications to accidentally starve the event loop\n    // by repeatedly waiting on immediate promises.\n    newEvent.armBreadthFirst();\n  } else {\n    event = &newEvent;\n  }\n}"
  },
  {
    "function_name": "PromiseNode::setSelfPointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "493-493",
    "snippet": "void PromiseNode::setSelfPointer(Own<PromiseNode>* selfPtr) noexcept {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid PromiseNode::setSelfPointer(Own<PromiseNode>* selfPtr) noexcept {}"
  },
  {
    "function_name": "PromiseBase::trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "489-491",
    "snippet": "kj::String PromiseBase::trace() {\n  return traceImpl(nullptr, node);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "traceImpl",
          "args": [
            "nullptr",
            "node"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "traceImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "447-464",
          "snippet": "static kj::String traceImpl(Event* event, _::PromiseNode* node) {\n#if KJ_NO_RTTI\n  return heapString(\"Trace not available because RTTI is disabled.\");\n#else\n  kj::Vector<kj::String> trace;\n\n  if (event != nullptr) {\n    trace.add(demangleTypeName(typeid(*event).name()));\n  }\n\n  while (node != nullptr) {\n    trace.add(demangleTypeName(typeid(*node).name()));\n    node = node->getInnerForTrace();\n  }\n\n  return strArray(trace, \"\\n\");\n#endif\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nstatic kj::String traceImpl(Event* event, _::PromiseNode* node) {\n#if KJ_NO_RTTI\n  return heapString(\"Trace not available because RTTI is disabled.\");\n#else\n  kj::Vector<kj::String> trace;\n\n  if (event != nullptr) {\n    trace.add(demangleTypeName(typeid(*event).name()));\n  }\n\n  while (node != nullptr) {\n    trace.add(demangleTypeName(typeid(*node).name()));\n    node = node->getInnerForTrace();\n  }\n\n  return strArray(trace, \"\\n\");\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nkj::String PromiseBase::trace() {\n  return traceImpl(nullptr, node);\n}"
  },
  {
    "function_name": "TaskSet::trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "483-485",
    "snippet": "kj::String TaskSet::trace() {\n  return impl->trace();\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "impl->trace",
          "args": [],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "trace",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "155-161",
          "snippet": "kj::String trace() {\n    kj::Vector<kj::String> traces;\n    for (auto& entry: tasks) {\n      traces.add(entry.second->trace());\n    }\n    return kj::strArray(traces, \"\\n============================================\\n\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  kj::String trace() {\n      kj::Vector<kj::String> traces;\n      for (auto& entry: tasks) {\n        traces.add(entry.second->trace());\n      }\n      return kj::strArray(traces, \"\\n============================================\\n\");\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nkj::String TaskSet::trace() {\n  return impl->trace();\n}"
  },
  {
    "function_name": "TaskSet::add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "479-481",
    "snippet": "void TaskSet::add(Promise<void>&& promise) {\n  impl->add(kj::mv(promise));\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "impl->add",
          "args": [
            "kj::mv(promise)"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promise"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid TaskSet::add(Promise<void>&& promise) {\n  impl->add(kj::mv(promise));\n}"
  },
  {
    "function_name": "TaskSet::~TaskSet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "477-477",
    "snippet": "TaskSet::~TaskSet() noexcept(false) {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSet::~TaskSet() noexcept(false) {}"
  },
  {
    "function_name": "TaskSet::TaskSet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "474-475",
    "snippet": "TaskSet::TaskSet(ErrorHandler& errorHandler)\n    : impl(heap<_::TaskSetImpl>(errorHandler)) {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap<_::TaskSetImpl>",
          "args": [
            "errorHandler"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSet::TaskSet(ErrorHandler& errorHandler)\n    : impl(heap<_::TaskSetImpl>(errorHandler)) {}"
  },
  {
    "function_name": "Event::trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "466-468",
    "snippet": "kj::String Event::trace() {\n  return traceImpl(this, getInnerForTrace());\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "traceImpl",
          "args": [
            "this",
            "getInnerForTrace()"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "traceImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "447-464",
          "snippet": "static kj::String traceImpl(Event* event, _::PromiseNode* node) {\n#if KJ_NO_RTTI\n  return heapString(\"Trace not available because RTTI is disabled.\");\n#else\n  kj::Vector<kj::String> trace;\n\n  if (event != nullptr) {\n    trace.add(demangleTypeName(typeid(*event).name()));\n  }\n\n  while (node != nullptr) {\n    trace.add(demangleTypeName(typeid(*node).name()));\n    node = node->getInnerForTrace();\n  }\n\n  return strArray(trace, \"\\n\");\n#endif\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nstatic kj::String traceImpl(Event* event, _::PromiseNode* node) {\n#if KJ_NO_RTTI\n  return heapString(\"Trace not available because RTTI is disabled.\");\n#else\n  kj::Vector<kj::String> trace;\n\n  if (event != nullptr) {\n    trace.add(demangleTypeName(typeid(*event).name()));\n  }\n\n  while (node != nullptr) {\n    trace.add(demangleTypeName(typeid(*node).name()));\n    node = node->getInnerForTrace();\n  }\n\n  return strArray(trace, \"\\n\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "getInnerForTrace",
          "args": [],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nkj::String Event::trace() {\n  return traceImpl(this, getInnerForTrace());\n}"
  },
  {
    "function_name": "traceImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "447-464",
    "snippet": "static kj::String traceImpl(Event* event, _::PromiseNode* node) {\n#if KJ_NO_RTTI\n  return heapString(\"Trace not available because RTTI is disabled.\");\n#else\n  kj::Vector<kj::String> trace;\n\n  if (event != nullptr) {\n    trace.add(demangleTypeName(typeid(*event).name()));\n  }\n\n  while (node != nullptr) {\n    trace.add(demangleTypeName(typeid(*node).name()));\n    node = node->getInnerForTrace();\n  }\n\n  return strArray(trace, \"\\n\");\n#endif\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strArray",
          "args": [
            "trace",
            "\"\\n\""
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->getInnerForTrace",
          "args": [],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace.add",
          "args": [
            "demangleTypeName(typeid(*node).name())"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "demangleTypeName",
          "args": [
            "typeid(*node).name()"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "demangleTypeName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "441-443",
          "snippet": "static kj::String demangleTypeName(const char* name) {\n  return kj::heapString(name);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nstatic kj::String demangleTypeName(const char* name) {\n  return kj::heapString(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "typeid",
          "args": [],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeid",
          "args": [
            "*node"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeid",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeid",
          "args": [
            "*event"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heapString",
          "args": [
            "\"Trace not available because RTTI is disabled.\""
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nstatic kj::String traceImpl(Event* event, _::PromiseNode* node) {\n#if KJ_NO_RTTI\n  return heapString(\"Trace not available because RTTI is disabled.\");\n#else\n  kj::Vector<kj::String> trace;\n\n  if (event != nullptr) {\n    trace.add(demangleTypeName(typeid(*event).name()));\n  }\n\n  while (node != nullptr) {\n    trace.add(demangleTypeName(typeid(*node).name()));\n    node = node->getInnerForTrace();\n  }\n\n  return strArray(trace, \"\\n\");\n#endif\n}"
  },
  {
    "function_name": "demangleTypeName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "441-443",
    "snippet": "static kj::String demangleTypeName(const char* name) {\n  return kj::heapString(name);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "name"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nstatic kj::String demangleTypeName(const char* name) {\n  return kj::heapString(name);\n}"
  },
  {
    "function_name": "demangleTypeName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "433-439",
    "snippet": "static kj::String demangleTypeName(const char* name) {\n  int status;\n  char* buf = abi::__cxa_demangle(name, nullptr, nullptr, &status);\n  kj::String result = kj::heapString(buf == nullptr ? name : buf);\n  free(buf);\n  return kj::mv(result);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buf"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "buf == nullptr ? name : buf"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "abi::__cxa_demangle",
          "args": [
            "name",
            "nullptr",
            "nullptr",
            "&status"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nstatic kj::String demangleTypeName(const char* name) {\n  int status;\n  char* buf = abi::__cxa_demangle(name, nullptr, nullptr, &status);\n  kj::String result = kj::heapString(buf == nullptr ? name : buf);\n  free(buf);\n  return kj::mv(result);\n}"
  },
  {
    "function_name": "Event::armBreadthFirst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "408-425",
    "snippet": "void Event::armBreadthFirst() {\n  KJ_REQUIRE(threadLocalEventLoop == &loop || threadLocalEventLoop == nullptr,\n             \"Event armed from different thread than it was created in.  You must use \"\n             \"the thread-safe work queue to queue events cross-thread.\");\n\n  if (prev == nullptr) {\n    next = *loop.tail;\n    prev = loop.tail;\n    *prev = this;\n    if (next != nullptr) {\n      next->prev = &next;\n    }\n\n    loop.tail = &next;\n\n    loop.setRunnable(true);\n  }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "loop.setRunnable",
          "args": [
            "true"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "setRunnable",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "668-671",
          "snippet": "void setRunnable(bool runnable) override {\n    this->runnable = runnable;\n    ++callCount;\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  void setRunnable(bool runnable) override {\n      this->runnable = runnable;\n      ++callCount;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "threadLocalEventLoop == &loop || threadLocalEventLoop == nullptr",
            "\"Event armed from different thread than it was created in.  You must use \"\n             \"the thread-safe work queue to queue events cross-thread.\""
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid Event::armBreadthFirst() {\n  KJ_REQUIRE(threadLocalEventLoop == &loop || threadLocalEventLoop == nullptr,\n             \"Event armed from different thread than it was created in.  You must use \"\n             \"the thread-safe work queue to queue events cross-thread.\");\n\n  if (prev == nullptr) {\n    next = *loop.tail;\n    prev = loop.tail;\n    *prev = this;\n    if (next != nullptr) {\n      next->prev = &next;\n    }\n\n    loop.tail = &next;\n\n    loop.setRunnable(true);\n  }\n}"
  },
  {
    "function_name": "Event::armDepthFirst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "385-406",
    "snippet": "void Event::armDepthFirst() {\n  KJ_REQUIRE(threadLocalEventLoop == &loop || threadLocalEventLoop == nullptr,\n             \"Event armed from different thread than it was created in.  You must use \"\n             \"the thread-safe work queue to queue events cross-thread.\");\n\n  if (prev == nullptr) {\n    next = *loop.depthFirstInsertPoint;\n    prev = loop.depthFirstInsertPoint;\n    *prev = this;\n    if (next != nullptr) {\n      next->prev = &next;\n    }\n\n    loop.depthFirstInsertPoint = &next;\n\n    if (loop.tail == prev) {\n      loop.tail = &next;\n    }\n\n    loop.setRunnable(true);\n  }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "loop.setRunnable",
          "args": [
            "true"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "setRunnable",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "668-671",
          "snippet": "void setRunnable(bool runnable) override {\n    this->runnable = runnable;\n    ++callCount;\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  void setRunnable(bool runnable) override {\n      this->runnable = runnable;\n      ++callCount;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "threadLocalEventLoop == &loop || threadLocalEventLoop == nullptr",
            "\"Event armed from different thread than it was created in.  You must use \"\n             \"the thread-safe work queue to queue events cross-thread.\""
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid Event::armDepthFirst() {\n  KJ_REQUIRE(threadLocalEventLoop == &loop || threadLocalEventLoop == nullptr,\n             \"Event armed from different thread than it was created in.  You must use \"\n             \"the thread-safe work queue to queue events cross-thread.\");\n\n  if (prev == nullptr) {\n    next = *loop.depthFirstInsertPoint;\n    prev = loop.depthFirstInsertPoint;\n    *prev = this;\n    if (next != nullptr) {\n      next->prev = &next;\n    }\n\n    loop.depthFirstInsertPoint = &next;\n\n    if (loop.tail == prev) {\n      loop.tail = &next;\n    }\n\n    loop.setRunnable(true);\n  }\n}"
  },
  {
    "function_name": "Event::~Event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "365-383",
    "snippet": "Event::~Event() noexcept(false) {\n  if (prev != nullptr) {\n    if (loop.tail == &next) {\n      loop.tail = prev;\n    }\n    if (loop.depthFirstInsertPoint == &next) {\n      loop.depthFirstInsertPoint = prev;\n    }\n\n    *prev = next;\n    if (next != nullptr) {\n      next->prev = prev;\n    }\n  }\n\n  KJ_REQUIRE(!firing, \"Promise callback destroyed itself.\");\n  KJ_REQUIRE(threadLocalEventLoop == &loop || threadLocalEventLoop == nullptr,\n             \"Promise destroyed from a different thread than it was created in.\");\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "threadLocalEventLoop == &loop || threadLocalEventLoop == nullptr",
            "\"Promise destroyed from a different thread than it was created in.\""
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "!firing",
            "\"Promise callback destroyed itself.\""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nEvent::~Event() noexcept(false) {\n  if (prev != nullptr) {\n    if (loop.tail == &next) {\n      loop.tail = prev;\n    }\n    if (loop.depthFirstInsertPoint == &next) {\n      loop.depthFirstInsertPoint = prev;\n    }\n\n    *prev = next;\n    if (next != nullptr) {\n      next->prev = prev;\n    }\n  }\n\n  KJ_REQUIRE(!firing, \"Promise callback destroyed itself.\");\n  KJ_REQUIRE(threadLocalEventLoop == &loop || threadLocalEventLoop == nullptr,\n             \"Promise destroyed from a different thread than it was created in.\");\n}"
  },
  {
    "function_name": "Event::Event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "362-363",
    "snippet": "Event::Event()\n    : loop(currentEventLoop()), next(nullptr), prev(nullptr) {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "currentEventLoop",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nEvent::Event()\n    : loop(currentEventLoop()), next(nullptr), prev(nullptr) {}"
  },
  {
    "function_name": "detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "356-360",
    "snippet": "void detach(kj::Promise<void>&& promise) {\n  EventLoop& loop = currentEventLoop();\n  KJ_REQUIRE(loop.daemons.get() != nullptr, \"EventLoop is shutting down.\") { return; }\n  loop.daemons->add(kj::mv(promise));\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "loop.daemons->add",
          "args": [
            "kj::mv(promise)"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promise"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "loop.daemons.get() != nullptr",
            "\"EventLoop is shutting down.\""
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loop.daemons.get",
          "args": [],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "AutoCloseFd",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.h",
          "lines": "258-258",
          "snippet": "inline int get() const { return fd; }",
          "includes": [
            "#include \"exception.h\"",
            "#include \"array.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exception.h\"\n#include \"array.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nAutoCloseFd {\n  inline int get() const { return fd; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "currentEventLoop",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid detach(kj::Promise<void>&& promise) {\n  EventLoop& loop = currentEventLoop();\n  KJ_REQUIRE(loop.daemons.get() != nullptr, \"EventLoop is shutting down.\") { return; }\n  loop.daemons->add(kj::mv(promise));\n}"
  },
  {
    "function_name": "NeverDone::wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "350-354",
    "snippet": "void NeverDone::wait(WaitScope& waitScope) const {\n  ExceptionOr<Void> dummy;\n  waitImpl(neverDone(), dummy, waitScope);\n  KJ_UNREACHABLE;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "waitImpl",
          "args": [
            "neverDone()",
            "dummy",
            "waitScope"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "waitImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "313-340",
          "snippet": "void waitImpl(Own<_::PromiseNode>&& node, _::ExceptionOrValue& result, WaitScope& waitScope) {\n  EventLoop& loop = waitScope.loop;\n  KJ_REQUIRE(&loop == threadLocalEventLoop, \"WaitScope not valid for this thread.\");\n  KJ_REQUIRE(!loop.running, \"wait() is not allowed from within event callbacks.\");\n\n  BoolEvent doneEvent;\n  node->setSelfPointer(&node);\n  node->onReady(doneEvent);\n\n  loop.running = true;\n  KJ_DEFER(loop.running = false);\n\n  while (!doneEvent.fired) {\n    if (!loop.turn()) {\n      // No events in the queue.  Wait for callback.\n      loop.port.wait();\n    }\n  }\n\n  loop.setRunnable(loop.head != nullptr);\n\n  node->get(result);\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n    node = nullptr;\n  })) {\n    result.addException(kj::mv(*exception));\n  }\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid waitImpl(Own<_::PromiseNode>&& node, _::ExceptionOrValue& result, WaitScope& waitScope) {\n  EventLoop& loop = waitScope.loop;\n  KJ_REQUIRE(&loop == threadLocalEventLoop, \"WaitScope not valid for this thread.\");\n  KJ_REQUIRE(!loop.running, \"wait() is not allowed from within event callbacks.\");\n\n  BoolEvent doneEvent;\n  node->setSelfPointer(&node);\n  node->onReady(doneEvent);\n\n  loop.running = true;\n  KJ_DEFER(loop.running = false);\n\n  while (!doneEvent.fired) {\n    if (!loop.turn()) {\n      // No events in the queue.  Wait for callback.\n      loop.port.wait();\n    }\n  }\n\n  loop.setRunnable(loop.head != nullptr);\n\n  node->get(result);\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n    node = nullptr;\n  })) {\n    result.addException(kj::mv(*exception));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "neverDone",
          "args": [],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "neverDone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "346-348",
          "snippet": "Own<PromiseNode> neverDone() {\n  return kj::heap<NeverDonePromiseNode>();\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nOwn<PromiseNode> neverDone() {\n  return kj::heap<NeverDonePromiseNode>();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid NeverDone::wait(WaitScope& waitScope) const {\n  ExceptionOr<Void> dummy;\n  waitImpl(neverDone(), dummy, waitScope);\n  KJ_UNREACHABLE;\n}"
  },
  {
    "function_name": "neverDone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "346-348",
    "snippet": "Own<PromiseNode> neverDone() {\n  return kj::heap<NeverDonePromiseNode>();\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<NeverDonePromiseNode>",
          "args": [],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "321-328",
          "snippet": "Own<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nOwn<PromiseNode> neverDone() {\n  return kj::heap<NeverDonePromiseNode>();\n}"
  },
  {
    "function_name": "yield",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "342-344",
    "snippet": "Promise<void> yield() {\n  return Promise<void>(false, kj::heap<YieldPromiseNode>());\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Promise<void>",
          "args": [
            "false",
            "kj::heap<YieldPromiseNode>()"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "ForkedPromise",
          "container": "ForkedPromise",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "319-319",
          "snippet": "inline ForkedPromise(bool, Own<_::ForkHub<_::FixVoid<T>>>&& hub): hub(kj::mv(hub)) {}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\nForkedPromise {\n  inline ForkedPromise(bool, Own<_::ForkHub<_::FixVoid<T>>>&& hub): hub(kj::mv(hub)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<YieldPromiseNode>",
          "args": [],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "321-328",
          "snippet": "Own<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nPromise<void> yield() {\n  return Promise<void>(false, kj::heap<YieldPromiseNode>());\n}"
  },
  {
    "function_name": "waitImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "313-340",
    "snippet": "void waitImpl(Own<_::PromiseNode>&& node, _::ExceptionOrValue& result, WaitScope& waitScope) {\n  EventLoop& loop = waitScope.loop;\n  KJ_REQUIRE(&loop == threadLocalEventLoop, \"WaitScope not valid for this thread.\");\n  KJ_REQUIRE(!loop.running, \"wait() is not allowed from within event callbacks.\");\n\n  BoolEvent doneEvent;\n  node->setSelfPointer(&node);\n  node->onReady(doneEvent);\n\n  loop.running = true;\n  KJ_DEFER(loop.running = false);\n\n  while (!doneEvent.fired) {\n    if (!loop.turn()) {\n      // No events in the queue.  Wait for callback.\n      loop.port.wait();\n    }\n  }\n\n  loop.setRunnable(loop.head != nullptr);\n\n  node->get(result);\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n    node = nullptr;\n  })) {\n    result.addException(kj::mv(*exception));\n  }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.addException",
          "args": [
            "kj::mv(*exception)"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "addException",
          "container": "ExceptionOrValue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "49-53",
          "snippet": "void addException(Exception&& exception) {\n    if (this->exception == nullptr) {\n      this->exception = kj::mv(exception);\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ExceptionOrValue {\n  void addException(Exception&& exception) {\n      if (this->exception == nullptr) {\n        this->exception = kj::mv(exception);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*exception"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exception",
            "kj::runCatchingExceptions([&]() {\n    node = nullptr;\n  })"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() {\n    node = nullptr;\n  }"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->get",
          "args": [
            "result"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "82-84",
          "snippet": "void get(_::ExceptionOrValue& output) noexcept override {\n    KJ_FAIL_REQUIRE(\"Not ready.\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void get(_::ExceptionOrValue& output) noexcept override {\n      KJ_FAIL_REQUIRE(\"Not ready.\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "loop.setRunnable",
          "args": [
            "loop.head != nullptr"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "setRunnable",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "668-671",
          "snippet": "void setRunnable(bool runnable) override {\n    this->runnable = runnable;\n    ++callCount;\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  void setRunnable(bool runnable) override {\n      this->runnable = runnable;\n      ++callCount;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "loop.port.wait",
          "args": [],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "wait",
          "container": "NullEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "183-185",
          "snippet": "bool wait() override {\n    KJ_FAIL_REQUIRE(\"Nothing to wait for; this thread would hang forever.\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNullEventPort {\n  bool wait() override {\n      KJ_FAIL_REQUIRE(\"Nothing to wait for; this thread would hang forever.\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "loop.turn",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "loop.running = false"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->onReady",
          "args": [
            "doneEvent"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "onReady",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "79-81",
          "snippet": "void onReady(_::Event& event) noexcept override {\n    // ignore\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void onReady(_::Event& event) noexcept override {\n      // ignore\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "node->setSelfPointer",
          "args": [
            "&node"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "!loop.running",
            "\"wait() is not allowed from within event callbacks.\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "&loop == threadLocalEventLoop",
            "\"WaitScope not valid for this thread.\""
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid waitImpl(Own<_::PromiseNode>&& node, _::ExceptionOrValue& result, WaitScope& waitScope) {\n  EventLoop& loop = waitScope.loop;\n  KJ_REQUIRE(&loop == threadLocalEventLoop, \"WaitScope not valid for this thread.\");\n  KJ_REQUIRE(!loop.running, \"wait() is not allowed from within event callbacks.\");\n\n  BoolEvent doneEvent;\n  node->setSelfPointer(&node);\n  node->onReady(doneEvent);\n\n  loop.running = true;\n  KJ_DEFER(loop.running = false);\n\n  while (!doneEvent.fired) {\n    if (!loop.turn()) {\n      // No events in the queue.  Wait for callback.\n      loop.port.wait();\n    }\n  }\n\n  loop.setRunnable(loop.head != nullptr);\n\n  node->get(result);\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n    node = nullptr;\n  })) {\n    result.addException(kj::mv(*exception));\n  }\n}"
  },
  {
    "function_name": "EventLoop::leaveScope",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "303-309",
    "snippet": "void EventLoop::leaveScope() {\n  KJ_REQUIRE(threadLocalEventLoop == this,\n             \"WaitScope destroyed in a different thread than it was created in.\") {\n    break;\n  }\n  threadLocalEventLoop = nullptr;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "threadLocalEventLoop == this",
            "\"WaitScope destroyed in a different thread than it was created in.\""
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid EventLoop::leaveScope() {\n  KJ_REQUIRE(threadLocalEventLoop == this,\n             \"WaitScope destroyed in a different thread than it was created in.\") {\n    break;\n  }\n  threadLocalEventLoop = nullptr;\n}"
  },
  {
    "function_name": "EventLoop::enterScope",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "298-301",
    "snippet": "void EventLoop::enterScope() {\n  KJ_REQUIRE(threadLocalEventLoop == nullptr, \"This thread already has an EventLoop.\");\n  threadLocalEventLoop = this;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "threadLocalEventLoop == nullptr",
            "\"This thread already has an EventLoop.\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid EventLoop::enterScope() {\n  KJ_REQUIRE(threadLocalEventLoop == nullptr, \"This thread already has an EventLoop.\");\n  threadLocalEventLoop = this;\n}"
  },
  {
    "function_name": "EventLoop::setRunnable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "291-296",
    "snippet": "void EventLoop::setRunnable(bool runnable) {\n  if (runnable != lastRunnableState) {\n    port.setRunnable(runnable);\n    lastRunnableState = runnable;\n  }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "port.setRunnable",
          "args": [
            "runnable"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "setRunnable",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "668-671",
          "snippet": "void setRunnable(bool runnable) override {\n    this->runnable = runnable;\n    ++callCount;\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  void setRunnable(bool runnable) override {\n      this->runnable = runnable;\n      ++callCount;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid EventLoop::setRunnable(bool runnable) {\n  if (runnable != lastRunnableState) {\n    port.setRunnable(runnable);\n    lastRunnableState = runnable;\n  }\n}"
  },
  {
    "function_name": "EventLoop::turn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "259-289",
    "snippet": "bool EventLoop::turn() {\n  _::Event* event = head;\n\n  if (event == nullptr) {\n    // No events in the queue.\n    return false;\n  } else {\n    head = event->next;\n    if (head != nullptr) {\n      head->prev = &head;\n    }\n\n    depthFirstInsertPoint = &head;\n    if (tail == &event->next) {\n      tail = &head;\n    }\n\n    event->next = nullptr;\n    event->prev = nullptr;\n\n    Maybe<Own<_::Event>> eventToDestroy;\n    {\n      event->firing = true;\n      KJ_DEFER(event->firing = false);\n      eventToDestroy = event->fire();\n    }\n\n    depthFirstInsertPoint = &head;\n    return true;\n  }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event->fire",
          "args": [],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "fire",
          "container": "TaskSetImpl::Task",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "115-138",
          "snippet": "Maybe<Own<Event>> fire() override {\n      // Get the result.\n      _::ExceptionOr<_::Void> result;\n      node->get(result);\n\n      // Delete the node, catching any exceptions.\n      KJ_IF_MAYBE(exception, kj::runCatchingExceptions([this]() {\n        node = nullptr;\n      })) {\n        result.addException(kj::mv(*exception));\n      }\n\n      // Call the error handler if there was an exception.\n      KJ_IF_MAYBE(e, result.exception) {\n        taskSet.errorHandler.taskFailed(kj::mv(*e));\n      }\n\n      // Remove from the task map.\n      auto iter = taskSet.tasks.find(this);\n      KJ_ASSERT(iter != taskSet.tasks.end());\n      Own<Event> self = kj::mv(iter->second);\n      taskSet.tasks.erase(iter);\n      return mv(self);\n    }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  Task {\n    Maybe<Own<Event>> fire() override {\n          // Get the result.\n          _::ExceptionOr<_::Void> result;\n          node->get(result);\n    \n          // Delete the node, catching any exceptions.\n          KJ_IF_MAYBE(exception, kj::runCatchingExceptions([this]() {\n            node = nullptr;\n          })) {\n            result.addException(kj::mv(*exception));\n          }\n    \n          // Call the error handler if there was an exception.\n          KJ_IF_MAYBE(e, result.exception) {\n            taskSet.errorHandler.taskFailed(kj::mv(*e));\n          }\n    \n          // Remove from the task map.\n          auto iter = taskSet.tasks.find(this);\n          KJ_ASSERT(iter != taskSet.tasks.end());\n          Own<Event> self = kj::mv(iter->second);\n          taskSet.tasks.erase(iter);\n          return mv(self);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "event->firing = false"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nbool EventLoop::turn() {\n  _::Event* event = head;\n\n  if (event == nullptr) {\n    // No events in the queue.\n    return false;\n  } else {\n    head = event->next;\n    if (head != nullptr) {\n      head->prev = &head;\n    }\n\n    depthFirstInsertPoint = &head;\n    if (tail == &event->next) {\n      tail = &head;\n    }\n\n    event->next = nullptr;\n    event->prev = nullptr;\n\n    Maybe<Own<_::Event>> eventToDestroy;\n    {\n      event->firing = true;\n      KJ_DEFER(event->firing = false);\n      eventToDestroy = event->fire();\n    }\n\n    depthFirstInsertPoint = &head;\n    return true;\n  }\n}"
  },
  {
    "function_name": "EventLoop::run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "246-257",
    "snippet": "void EventLoop::run(uint maxTurnCount) {\n  running = true;\n  KJ_DEFER(running = false);\n\n  for (uint i = 0; i < maxTurnCount; i++) {\n    if (!turn()) {\n      break;\n    }\n  }\n\n  setRunnable(head != nullptr);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setRunnable",
          "args": [
            "head != nullptr"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "EventLoop::setRunnable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "291-296",
          "snippet": "void EventLoop::setRunnable(bool runnable) {\n  if (runnable != lastRunnableState) {\n    port.setRunnable(runnable);\n    lastRunnableState = runnable;\n  }\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid EventLoop::setRunnable(bool runnable) {\n  if (runnable != lastRunnableState) {\n    port.setRunnable(runnable);\n    lastRunnableState = runnable;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "turn",
          "args": [],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "EventLoop::turn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "259-289",
          "snippet": "bool EventLoop::turn() {\n  _::Event* event = head;\n\n  if (event == nullptr) {\n    // No events in the queue.\n    return false;\n  } else {\n    head = event->next;\n    if (head != nullptr) {\n      head->prev = &head;\n    }\n\n    depthFirstInsertPoint = &head;\n    if (tail == &event->next) {\n      tail = &head;\n    }\n\n    event->next = nullptr;\n    event->prev = nullptr;\n\n    Maybe<Own<_::Event>> eventToDestroy;\n    {\n      event->firing = true;\n      KJ_DEFER(event->firing = false);\n      eventToDestroy = event->fire();\n    }\n\n    depthFirstInsertPoint = &head;\n    return true;\n  }\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nbool EventLoop::turn() {\n  _::Event* event = head;\n\n  if (event == nullptr) {\n    // No events in the queue.\n    return false;\n  } else {\n    head = event->next;\n    if (head != nullptr) {\n      head->prev = &head;\n    }\n\n    depthFirstInsertPoint = &head;\n    if (tail == &event->next) {\n      tail = &head;\n    }\n\n    event->next = nullptr;\n    event->prev = nullptr;\n\n    Maybe<Own<_::Event>> eventToDestroy;\n    {\n      event->firing = true;\n      KJ_DEFER(event->firing = false);\n      eventToDestroy = event->fire();\n    }\n\n    depthFirstInsertPoint = &head;\n    return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "running = false"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid EventLoop::run(uint maxTurnCount) {\n  running = true;\n  KJ_DEFER(running = false);\n\n  for (uint i = 0; i < maxTurnCount; i++) {\n    if (!turn()) {\n      break;\n    }\n  }\n\n  setRunnable(head != nullptr);\n}"
  },
  {
    "function_name": "EventLoop::~EventLoop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "219-244",
    "snippet": "EventLoop::~EventLoop() noexcept(false) {\n  // Destroy all \"daemon\" tasks, noting that their destructors might try to access the EventLoop\n  // some more.\n  daemons = nullptr;\n\n  // The application _should_ destroy everything using the EventLoop before destroying the\n  // EventLoop itself, so if there are events on the loop, this indicates a memory leak.\n  KJ_REQUIRE(head == nullptr, \"EventLoop destroyed with events still in the queue.  Memory leak?\",\n             head->trace()) {\n    // Unlink all the events and hope that no one ever fires them...\n    _::Event* event = head;\n    while (event != nullptr) {\n      _::Event* next = event->next;\n      event->next = nullptr;\n      event->prev = nullptr;\n      event = next;\n    }\n    break;\n  }\n\n  KJ_REQUIRE(threadLocalEventLoop != this,\n             \"EventLoop destroyed while still current for the thread.\") {\n    threadLocalEventLoop = nullptr;\n    break;\n  }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "threadLocalEventLoop != this",
            "\"EventLoop destroyed while still current for the thread.\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "head == nullptr",
            "\"EventLoop destroyed with events still in the queue.  Memory leak?\"",
            "head->trace()"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "head->trace",
          "args": [],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "trace",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "155-161",
          "snippet": "kj::String trace() {\n    kj::Vector<kj::String> traces;\n    for (auto& entry: tasks) {\n      traces.add(entry.second->trace());\n    }\n    return kj::strArray(traces, \"\\n============================================\\n\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  kj::String trace() {\n      kj::Vector<kj::String> traces;\n      for (auto& entry: tasks) {\n        traces.add(entry.second->trace());\n      }\n      return kj::strArray(traces, \"\\n============================================\\n\");\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nEventLoop::~EventLoop() noexcept(false) {\n  // Destroy all \"daemon\" tasks, noting that their destructors might try to access the EventLoop\n  // some more.\n  daemons = nullptr;\n\n  // The application _should_ destroy everything using the EventLoop before destroying the\n  // EventLoop itself, so if there are events on the loop, this indicates a memory leak.\n  KJ_REQUIRE(head == nullptr, \"EventLoop destroyed with events still in the queue.  Memory leak?\",\n             head->trace()) {\n    // Unlink all the events and hope that no one ever fires them...\n    _::Event* event = head;\n    while (event != nullptr) {\n      _::Event* next = event->next;\n      event->next = nullptr;\n      event->prev = nullptr;\n      event = next;\n    }\n    break;\n  }\n\n  KJ_REQUIRE(threadLocalEventLoop != this,\n             \"EventLoop destroyed while still current for the thread.\") {\n    threadLocalEventLoop = nullptr;\n    break;\n  }\n}"
  },
  {
    "function_name": "EventLoop::EventLoop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "215-217",
    "snippet": "EventLoop::EventLoop(EventPort& port)\n    : port(port),\n      daemons(kj::heap<_::TaskSetImpl>(_::LoggingErrorHandler::instance)) {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<_::TaskSetImpl>",
          "args": [
            "_::LoggingErrorHandler::instance"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nEventLoop::EventLoop(EventPort& port)\n    : port(port),\n      daemons(kj::heap<_::TaskSetImpl>(_::LoggingErrorHandler::instance)) {}"
  },
  {
    "function_name": "EventLoop::EventLoop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "211-213",
    "snippet": "EventLoop::EventLoop()\n    : port(_::NullEventPort::instance),\n      daemons(kj::heap<_::TaskSetImpl>(_::LoggingErrorHandler::instance)) {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<_::TaskSetImpl>",
          "args": [
            "_::LoggingErrorHandler::instance"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nEventLoop::EventLoop()\n    : port(_::NullEventPort::instance),\n      daemons(kj::heap<_::TaskSetImpl>(_::LoggingErrorHandler::instance)) {}"
  },
  {
    "function_name": "EventPort::wake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "206-209",
    "snippet": "void EventPort::wake() const {\n  kj::throwRecoverableException(KJ_EXCEPTION(UNIMPLEMENTED,\n      \"cross-thread wake() not implemented by this EventPort implementation\"));\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::throwRecoverableException",
          "args": [
            "KJ_EXCEPTION(UNIMPLEMENTED,\n      \"cross-thread wake() not implemented by this EventPort implementation\")"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "throwRecoverableException",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "353-355",
          "snippet": "void throwRecoverableException(kj::Exception&& exception) {\n  getExceptionCallback().onRecoverableException(kj::mv(exception));\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid throwRecoverableException(kj::Exception&& exception) {\n  getExceptionCallback().onRecoverableException(kj::mv(exception));\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_EXCEPTION",
          "args": [
            "UNIMPLEMENTED",
            "\"cross-thread wake() not implemented by this EventPort implementation\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid EventPort::wake() const {\n  kj::throwRecoverableException(KJ_EXCEPTION(UNIMPLEMENTED,\n      \"cross-thread wake() not implemented by this EventPort implementation\"));\n}"
  },
  {
    "function_name": "EventPort::setRunnable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "204-204",
    "snippet": "void EventPort::setRunnable(bool runnable) {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid EventPort::setRunnable(bool runnable) {}"
  },
  {
    "function_name": "wake",
    "container": "NullEventPort",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "189-193",
    "snippet": "void wake() const override {\n    // TODO(someday): Implement using condvar.\n    kj::throwRecoverableException(KJ_EXCEPTION(UNIMPLEMENTED,\n        \"Cross-thread events are not yet implemented for EventLoops with no EventPort.\"));\n  }",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::throwRecoverableException",
          "args": [
            "KJ_EXCEPTION(UNIMPLEMENTED,\n        \"Cross-thread events are not yet implemented for EventLoops with no EventPort.\")"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "throwRecoverableException",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "353-355",
          "snippet": "void throwRecoverableException(kj::Exception&& exception) {\n  getExceptionCallback().onRecoverableException(kj::mv(exception));\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid throwRecoverableException(kj::Exception&& exception) {\n  getExceptionCallback().onRecoverableException(kj::mv(exception));\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_EXCEPTION",
          "args": [
            "UNIMPLEMENTED",
            "\"Cross-thread events are not yet implemented for EventLoops with no EventPort.\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNullEventPort {\n  void wake() const override {\n      // TODO(someday): Implement using condvar.\n      kj::throwRecoverableException(KJ_EXCEPTION(UNIMPLEMENTED,\n          \"Cross-thread events are not yet implemented for EventLoops with no EventPort.\"));\n    }\n}"
  },
  {
    "function_name": "poll",
    "container": "NullEventPort",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "187-187",
    "snippet": "bool poll() override { return false; }",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNullEventPort {\n  bool poll() override { return false; }\n}"
  },
  {
    "function_name": "wait",
    "container": "NullEventPort",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "183-185",
    "snippet": "bool wait() override {\n    KJ_FAIL_REQUIRE(\"Nothing to wait for; this thread would hang forever.\");\n  }",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Nothing to wait for; this thread would hang forever.\""
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNullEventPort {\n  bool wait() override {\n      KJ_FAIL_REQUIRE(\"Nothing to wait for; this thread would hang forever.\");\n    }\n}"
  },
  {
    "function_name": "taskFailed",
    "container": "LoggingErrorHandler",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "174-176",
    "snippet": "void taskFailed(kj::Exception&& exception) override {\n    KJ_LOG(ERROR, \"Uncaught exception in daemonized task.\", exception);\n  }",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "\"Uncaught exception in daemonized task.\"",
            "exception"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nLoggingErrorHandler {\n  void taskFailed(kj::Exception&& exception) override {\n      KJ_LOG(ERROR, \"Uncaught exception in daemonized task.\", exception);\n    }\n}"
  },
  {
    "function_name": "trace",
    "container": "TaskSetImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "155-161",
    "snippet": "kj::String trace() {\n    kj::Vector<kj::String> traces;\n    for (auto& entry: tasks) {\n      traces.add(entry.second->trace());\n    }\n    return kj::strArray(traces, \"\\n============================================\\n\");\n  }",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::strArray",
          "args": [
            "traces",
            "\"\\n============================================\\n\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "traces.add",
          "args": [
            "entry.second->trace()"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  kj::String trace() {\n      kj::Vector<kj::String> traces;\n      for (auto& entry: tasks) {\n        traces.add(entry.second->trace());\n      }\n      return kj::strArray(traces, \"\\n============================================\\n\");\n    }\n}"
  },
  {
    "function_name": "add",
    "container": "TaskSetImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "149-153",
    "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasks.insert",
          "args": [
            "std::make_pair(ptr, kj::mv(task))"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "ptr",
            "kj::mv(task)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "task"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap<Task>",
          "args": [
            "*this",
            "kj::mv(promise.node)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promise.node"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
  },
  {
    "function_name": "fire",
    "container": "TaskSetImpl::Task",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "115-138",
    "snippet": "Maybe<Own<Event>> fire() override {\n      // Get the result.\n      _::ExceptionOr<_::Void> result;\n      node->get(result);\n\n      // Delete the node, catching any exceptions.\n      KJ_IF_MAYBE(exception, kj::runCatchingExceptions([this]() {\n        node = nullptr;\n      })) {\n        result.addException(kj::mv(*exception));\n      }\n\n      // Call the error handler if there was an exception.\n      KJ_IF_MAYBE(e, result.exception) {\n        taskSet.errorHandler.taskFailed(kj::mv(*e));\n      }\n\n      // Remove from the task map.\n      auto iter = taskSet.tasks.find(this);\n      KJ_ASSERT(iter != taskSet.tasks.end());\n      Own<Event> self = kj::mv(iter->second);\n      taskSet.tasks.erase(iter);\n      return mv(self);\n    }",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "self"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "taskSet.tasks.erase",
          "args": [
            "iter"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "204-216",
          "snippet": "T erase(Id id) {\n    // Remove an entry from the table and return it.  We return it so that the caller can be\n    // careful to release it (possibly invoking arbitrary destructors) at a time that makes sense.\n    if (id < kj::size(low)) {\n      T toRelease = kj::mv(low[id]);\n      low[id] = T();\n      return toRelease;\n    } else {\n      T toRelease = kj::mv(high[id]);\n      high.erase(id);\n      return toRelease;\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  T erase(Id id) {\n      // Remove an entry from the table and return it.  We return it so that the caller can be\n      // careful to release it (possibly invoking arbitrary destructors) at a time that makes sense.\n      if (id < kj::size(low)) {\n        T toRelease = kj::mv(low[id]);\n        low[id] = T();\n        return toRelease;\n      } else {\n        T toRelease = kj::mv(high[id]);\n        high.erase(id);\n        return toRelease;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "iter->second"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "iter != taskSet.tasks.end()"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "taskSet.tasks.end",
          "args": [],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "693-693",
          "snippet": "inline Iterator end() const { return Iterator(value, count); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator end() const { return Iterator(value, count); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "taskSet.tasks.find",
          "args": [
            "this"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "191-202",
          "snippet": "kj::Maybe<T&> find(Id id) {\n    if (id < kj::size(low)) {\n      return low[id];\n    } else {\n      auto iter = high.find(id);\n      if (iter == high.end()) {\n        return nullptr;\n      } else {\n        return iter->second;\n      }\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  kj::Maybe<T&> find(Id id) {\n      if (id < kj::size(low)) {\n        return low[id];\n      } else {\n        auto iter = high.find(id);\n        if (iter == high.end()) {\n          return nullptr;\n        } else {\n          return iter->second;\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "taskSet.errorHandler.taskFailed",
          "args": [
            "kj::mv(*e)"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "taskFailed",
          "container": "LoggingErrorHandler",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "174-176",
          "snippet": "void taskFailed(kj::Exception&& exception) override {\n    KJ_LOG(ERROR, \"Uncaught exception in daemonized task.\", exception);\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nLoggingErrorHandler {\n  void taskFailed(kj::Exception&& exception) override {\n      KJ_LOG(ERROR, \"Uncaught exception in daemonized task.\", exception);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*e"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "e",
            "result.exception"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "result.addException",
          "args": [
            "kj::mv(*exception)"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "addException",
          "container": "ExceptionOrValue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "49-53",
          "snippet": "void addException(Exception&& exception) {\n    if (this->exception == nullptr) {\n      this->exception = kj::mv(exception);\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ExceptionOrValue {\n  void addException(Exception&& exception) {\n      if (this->exception == nullptr) {\n        this->exception = kj::mv(exception);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*exception"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[this]() {\n        node = nullptr;\n      }"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->get",
          "args": [
            "result"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "82-84",
          "snippet": "void get(_::ExceptionOrValue& output) noexcept override {\n    KJ_FAIL_REQUIRE(\"Not ready.\");\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void get(_::ExceptionOrValue& output) noexcept override {\n      KJ_FAIL_REQUIRE(\"Not ready.\");\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  Task {\n    Maybe<Own<Event>> fire() override {\n          // Get the result.\n          _::ExceptionOr<_::Void> result;\n          node->get(result);\n    \n          // Delete the node, catching any exceptions.\n          KJ_IF_MAYBE(exception, kj::runCatchingExceptions([this]() {\n            node = nullptr;\n          })) {\n            result.addException(kj::mv(*exception));\n          }\n    \n          // Call the error handler if there was an exception.\n          KJ_IF_MAYBE(e, result.exception) {\n            taskSet.errorHandler.taskFailed(kj::mv(*e));\n          }\n    \n          // Remove from the task map.\n          auto iter = taskSet.tasks.find(this);\n          KJ_ASSERT(iter != taskSet.tasks.end());\n          Own<Event> self = kj::mv(iter->second);\n          taskSet.tasks.erase(iter);\n          return mv(self);\n        }\n  }\n}"
  },
  {
    "function_name": "Task",
    "container": "TaskSetImpl::Task",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "108-112",
    "snippet": "Task(TaskSetImpl& taskSet, Own<_::PromiseNode>&& nodeParam)\n        : taskSet(taskSet), node(kj::mv(nodeParam)) {\n      node->setSelfPointer(&node);\n      node->onReady(*this);\n    }",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node->onReady",
          "args": [
            "*this"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "onReady",
          "container": "NeverDonePromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "79-81",
          "snippet": "void onReady(_::Event& event) noexcept override {\n    // ignore\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void onReady(_::Event& event) noexcept override {\n      // ignore\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "node->setSelfPointer",
          "args": [
            "&node"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "nodeParam"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  Task {\n    Task(TaskSetImpl& taskSet, Own<_::PromiseNode>&& nodeParam)\n            : taskSet(taskSet), node(kj::mv(nodeParam)) {\n          node->setSelfPointer(&node);\n          node->onReady(*this);\n        }\n  }\n}"
  },
  {
    "function_name": "TaskSetImpl",
    "container": "TaskSetImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "93-94",
    "snippet": "inline TaskSetImpl(TaskSet::ErrorHandler& errorHandler)\n    : errorHandler(errorHandler) {}",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  inline TaskSetImpl(TaskSet::ErrorHandler& errorHandler)\n      : errorHandler(errorHandler) {}\n}"
  },
  {
    "function_name": "get",
    "container": "NeverDonePromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "82-84",
    "snippet": "void get(_::ExceptionOrValue& output) noexcept override {\n    KJ_FAIL_REQUIRE(\"Not ready.\");\n  }",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Not ready.\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void get(_::ExceptionOrValue& output) noexcept override {\n      KJ_FAIL_REQUIRE(\"Not ready.\");\n    }\n}"
  },
  {
    "function_name": "onReady",
    "container": "NeverDonePromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "79-81",
    "snippet": "void onReady(_::Event& event) noexcept override {\n    // ignore\n  }",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNeverDonePromiseNode {\n  void onReady(_::Event& event) noexcept override {\n      // ignore\n    }\n}"
  },
  {
    "function_name": "get",
    "container": "YieldPromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "72-74",
    "snippet": "void get(_::ExceptionOrValue& output) noexcept override {\n    output.as<_::Void>() = _::Void();\n  }",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_::Void",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.as<_::Void>",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "as",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "601-604",
          "snippet": "BuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nBuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nYieldPromiseNode {\n  void get(_::ExceptionOrValue& output) noexcept override {\n      output.as<_::Void>() = _::Void();\n    }\n}"
  },
  {
    "function_name": "onReady",
    "container": "YieldPromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "69-71",
    "snippet": "void onReady(_::Event& event) noexcept override {\n    event.armBreadthFirst();\n  }",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event.armBreadthFirst",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nYieldPromiseNode {\n  void onReady(_::Event& event) noexcept override {\n      event.armBreadthFirst();\n    }\n}"
  },
  {
    "function_name": "fire",
    "container": "BoolEvent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
    "lines": "61-64",
    "snippet": "Maybe<Own<_::Event>> fire() override {\n    fired = true;\n    return nullptr;\n  }",
    "includes": [
      "#include <stdlib.h>",
      "#include <cxxabi.h>",
      "#include <typeinfo>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <exception>",
      "#include \"threadlocal.h\"",
      "#include \"vector.h\"",
      "#include \"debug.h\"",
      "#include \"async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nBoolEvent {\n  Maybe<Own<_::Event>> fire() override {\n      fired = true;\n      return nullptr;\n    }\n}"
  }
]