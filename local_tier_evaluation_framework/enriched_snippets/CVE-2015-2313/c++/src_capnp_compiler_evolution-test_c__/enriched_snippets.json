[
  {
    "function_name": "run",
    "container": "EvolutionTestMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "866-880",
    "snippet": "kj::MainBuilder::Validity run() {\n    srand(seed);\n\n    {\n      kj::String text = kj::str(\n          \"Randomly testing backwards-compatibility scenarios with seed: \", seed, \"\\n\");\n      kj::FdOutputStream(STDOUT_FILENO).write(text.begin(), text.size());\n    }\n\n    KJ_CONTEXT(seed, \"PLEASE REPORT THIS FAILURE AND INCLUDE THE SEED\");\n\n    doTest();\n\n    return true;\n  }",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "doTest",
          "args": [],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "doTest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "749-839",
          "snippet": "void doTest() {\n  auto builder = kj::heap<MallocMessageBuilder>();\n\n  {\n    // Set up the basic file decl.\n    auto parsedFile = builder->initRoot<ParsedFile>();\n    auto file = parsedFile.initRoot();\n    file.setFile();\n    file.initId().initUid().setValue(0x8123456789abcdefllu);\n    auto decls = file.initNestedDecls(3 + kj::size(TYPE_OPTIONS));\n\n    {\n      auto decl = decls[0];\n      decl.initName().setValue(\"EvolvingStruct\");\n      decl.initId().initUid().setValue(0x823456789abcdef1llu);\n      decl.setStruct();\n    }\n    {\n      auto decl = decls[1];\n      decl.initName().setValue(\"StructType\");\n      decl.setStruct();\n\n      auto fieldDecl = decl.initNestedDecls(1)[0];\n      fieldDecl.initName().setValue(\"i\");\n      fieldDecl.getId().initOrdinal().setValue(0);\n      auto field = fieldDecl.initField();\n      setDeclName(field.initType(), \"UInt32\");\n    }\n    {\n      auto decl = decls[2];\n      decl.initName().setValue(\"EnumType\");\n      decl.setEnum();\n\n      auto enumerants = decl.initNestedDecls(4);\n\n      for (uint i = 0; i < kj::size(RFC3092); i++) {\n        auto enumerantDecl = enumerants[i];\n        enumerantDecl.initName().setValue(RFC3092[i]);\n        enumerantDecl.getId().initOrdinal().setValue(i);\n        enumerantDecl.setEnumerant();\n      }\n    }\n\n    // For each of TYPE_OPTIONS, declare a struct type that contains that type as its @0 field.\n    for (uint i = 0; i < kj::size(TYPE_OPTIONS); i++) {\n      auto decl = decls[3 + i];\n      auto& option = TYPE_OPTIONS[i];\n\n      decl.initName().setValue(kj::str(option.name, \"Struct\"));\n      decl.setStruct();\n\n      auto fieldDecl = decl.initNestedDecls(1)[0];\n      fieldDecl.initName().setValue(\"f0\");\n      fieldDecl.getId().initOrdinal().setValue(0);\n      auto field = fieldDecl.initField();\n      setDeclName(field.initType(), option.name);\n\n      uint ordinal = 1;\n      for (auto j: kj::range(0, rand() % 4)) {\n        (void)j;\n        structAddField(decl, ordinal, false);\n      }\n    }\n  }\n\n  uint nextOrdinal = 0;\n\n  for (uint i = 0; i < 96; i++) {\n    uint oldOrdinalCount = nextOrdinal;\n\n    auto newBuilder = kj::heap<MallocMessageBuilder>();\n    newBuilder->setRoot(builder->getRoot<ParsedFile>().asReader());\n\n    auto parsedFile = newBuilder->getRoot<ParsedFile>();\n    Declaration::Builder decl = parsedFile.getRoot().getNestedDecls()[0];\n\n    // Apply a random modification.\n    ChangeInfo changeInfo;\n    while (changeInfo.kind == NO_CHANGE) {\n      auto& mod = chooseFrom(STRUCT_MODS);\n      changeInfo = mod(decl, nextOrdinal, false);\n    }\n\n    KJ_CONTEXT(changeInfo.description);\n\n    if (checkChange(builder->getRoot<ParsedFile>(), parsedFile, changeInfo.kind, oldOrdinalCount) &&\n        checkChange(parsedFile, builder->getRoot<ParsedFile>(), changeInfo.kind, oldOrdinalCount)) {\n      builder = kj::mv(newBuilder);\n    }\n  }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nvoid doTest() {\n  auto builder = kj::heap<MallocMessageBuilder>();\n\n  {\n    // Set up the basic file decl.\n    auto parsedFile = builder->initRoot<ParsedFile>();\n    auto file = parsedFile.initRoot();\n    file.setFile();\n    file.initId().initUid().setValue(0x8123456789abcdefllu);\n    auto decls = file.initNestedDecls(3 + kj::size(TYPE_OPTIONS));\n\n    {\n      auto decl = decls[0];\n      decl.initName().setValue(\"EvolvingStruct\");\n      decl.initId().initUid().setValue(0x823456789abcdef1llu);\n      decl.setStruct();\n    }\n    {\n      auto decl = decls[1];\n      decl.initName().setValue(\"StructType\");\n      decl.setStruct();\n\n      auto fieldDecl = decl.initNestedDecls(1)[0];\n      fieldDecl.initName().setValue(\"i\");\n      fieldDecl.getId().initOrdinal().setValue(0);\n      auto field = fieldDecl.initField();\n      setDeclName(field.initType(), \"UInt32\");\n    }\n    {\n      auto decl = decls[2];\n      decl.initName().setValue(\"EnumType\");\n      decl.setEnum();\n\n      auto enumerants = decl.initNestedDecls(4);\n\n      for (uint i = 0; i < kj::size(RFC3092); i++) {\n        auto enumerantDecl = enumerants[i];\n        enumerantDecl.initName().setValue(RFC3092[i]);\n        enumerantDecl.getId().initOrdinal().setValue(i);\n        enumerantDecl.setEnumerant();\n      }\n    }\n\n    // For each of TYPE_OPTIONS, declare a struct type that contains that type as its @0 field.\n    for (uint i = 0; i < kj::size(TYPE_OPTIONS); i++) {\n      auto decl = decls[3 + i];\n      auto& option = TYPE_OPTIONS[i];\n\n      decl.initName().setValue(kj::str(option.name, \"Struct\"));\n      decl.setStruct();\n\n      auto fieldDecl = decl.initNestedDecls(1)[0];\n      fieldDecl.initName().setValue(\"f0\");\n      fieldDecl.getId().initOrdinal().setValue(0);\n      auto field = fieldDecl.initField();\n      setDeclName(field.initType(), option.name);\n\n      uint ordinal = 1;\n      for (auto j: kj::range(0, rand() % 4)) {\n        (void)j;\n        structAddField(decl, ordinal, false);\n      }\n    }\n  }\n\n  uint nextOrdinal = 0;\n\n  for (uint i = 0; i < 96; i++) {\n    uint oldOrdinalCount = nextOrdinal;\n\n    auto newBuilder = kj::heap<MallocMessageBuilder>();\n    newBuilder->setRoot(builder->getRoot<ParsedFile>().asReader());\n\n    auto parsedFile = newBuilder->getRoot<ParsedFile>();\n    Declaration::Builder decl = parsedFile.getRoot().getNestedDecls()[0];\n\n    // Apply a random modification.\n    ChangeInfo changeInfo;\n    while (changeInfo.kind == NO_CHANGE) {\n      auto& mod = chooseFrom(STRUCT_MODS);\n      changeInfo = mod(decl, nextOrdinal, false);\n    }\n\n    KJ_CONTEXT(changeInfo.description);\n\n    if (checkChange(builder->getRoot<ParsedFile>(), parsedFile, changeInfo.kind, oldOrdinalCount) &&\n        checkChange(parsedFile, builder->getRoot<ParsedFile>(), changeInfo.kind, oldOrdinalCount)) {\n      builder = kj::mv(newBuilder);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_CONTEXT",
          "args": [
            "seed",
            "\"PLEASE REPORT THIS FAILURE AND INCLUDE THE SEED\""
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "text.begin()",
            "text.size()"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text.size",
          "args": [],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.begin",
          "args": [],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "76-76",
          "snippet": "inline Iterator begin() const { return Iterator(0); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::FdOutputStream",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "FdOutputStream",
          "container": "FdOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.h",
          "lines": "298-298",
          "snippet": "explicit FdOutputStream(AutoCloseFd fd): fd(fd), autoclose(mv(fd)) {}",
          "includes": [
            "#include \"exception.h\"",
            "#include \"array.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exception.h\"\n#include \"array.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nFdOutputStream {\n  explicit FdOutputStream(AutoCloseFd fd): fd(fd), autoclose(mv(fd)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Randomly testing backwards-compatibility scenarios with seed: \"",
            "seed",
            "\"\\n\""
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srand",
          "args": [
            "seed"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nEvolutionTestMain {\n  kj::MainBuilder::Validity run() {\n      srand(seed);\n  \n      {\n        kj::String text = kj::str(\n            \"Randomly testing backwards-compatibility scenarios with seed: \", seed, \"\\n\");\n        kj::FdOutputStream(STDOUT_FILENO).write(text.begin(), text.size());\n      }\n  \n      KJ_CONTEXT(seed, \"PLEASE REPORT THIS FAILURE AND INCLUDE THE SEED\");\n  \n      doTest();\n  \n      return true;\n    }\n}"
  },
  {
    "function_name": "setSeed",
    "container": "EvolutionTestMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "856-864",
    "snippet": "kj::MainBuilder::Validity setSeed(kj::StringPtr value) {\n    char* end;\n    seed = strtol(value.cStr(), &end, 0);\n    if (value.size() == 0 || *end != '\\0') {\n      return \"not an integer\";\n    } else {\n      return true;\n    }\n  }",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "value.size",
          "args": [],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "value.cStr()",
            "&end",
            "0"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.cStr",
          "args": [],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nEvolutionTestMain {\n  kj::MainBuilder::Validity setSeed(kj::StringPtr value) {\n      char* end;\n      seed = strtol(value.cStr(), &end, 0);\n      if (value.size() == 0 || *end != '\\0') {\n        return \"not an integer\";\n      } else {\n        return true;\n      }\n    }\n}"
  },
  {
    "function_name": "getMain",
    "container": "EvolutionTestMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "846-854",
    "snippet": "kj::MainFunc getMain() {\n    return kj::MainBuilder(context, \"(unknown version)\",\n        \"Integration test / fuzzer which randomly modifies schemas is backwards-compatible ways \"\n        \"and verifies that they do actually remain compatible.\")\n        .addOptionWithArg({\"seed\"}, KJ_BIND_METHOD(*this, setSeed), \"<num>\",\n            \"Set random number seed to <num>.  By default, time() is used.\")\n        .callAfterParsing(KJ_BIND_METHOD(*this, run))\n        .build();\n  }",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "KJ_BIND_METHOD(*this, run)"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "run"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "{\"seed\"}",
            "KJ_BIND_METHOD(*this, setSeed)",
            "\"<num>\"",
            "\"Set random number seed to <num>.  By default, time() is used.\""
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "setSeed"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"(unknown version)\"",
            "\"Integration test / fuzzer which randomly modifies schemas is backwards-compatible ways \"\n        \"and verifies that they do actually remain compatible.\""
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nEvolutionTestMain {\n  kj::MainFunc getMain() {\n      return kj::MainBuilder(context, \"(unknown version)\",\n          \"Integration test / fuzzer which randomly modifies schemas is backwards-compatible ways \"\n          \"and verifies that they do actually remain compatible.\")\n          .addOptionWithArg({\"seed\"}, KJ_BIND_METHOD(*this, setSeed), \"<num>\",\n              \"Set random number seed to <num>.  By default, time() is used.\")\n          .callAfterParsing(KJ_BIND_METHOD(*this, run))\n          .build();\n    }\n}"
  },
  {
    "function_name": "EvolutionTestMain",
    "container": "EvolutionTestMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "843-844",
    "snippet": "explicit EvolutionTestMain(kj::ProcessContext& context)\n      : context(context) {}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nEvolutionTestMain {\n  explicit EvolutionTestMain(kj::ProcessContext& context)\n        : context(context) {}\n}"
  },
  {
    "function_name": "doTest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "749-839",
    "snippet": "void doTest() {\n  auto builder = kj::heap<MallocMessageBuilder>();\n\n  {\n    // Set up the basic file decl.\n    auto parsedFile = builder->initRoot<ParsedFile>();\n    auto file = parsedFile.initRoot();\n    file.setFile();\n    file.initId().initUid().setValue(0x8123456789abcdefllu);\n    auto decls = file.initNestedDecls(3 + kj::size(TYPE_OPTIONS));\n\n    {\n      auto decl = decls[0];\n      decl.initName().setValue(\"EvolvingStruct\");\n      decl.initId().initUid().setValue(0x823456789abcdef1llu);\n      decl.setStruct();\n    }\n    {\n      auto decl = decls[1];\n      decl.initName().setValue(\"StructType\");\n      decl.setStruct();\n\n      auto fieldDecl = decl.initNestedDecls(1)[0];\n      fieldDecl.initName().setValue(\"i\");\n      fieldDecl.getId().initOrdinal().setValue(0);\n      auto field = fieldDecl.initField();\n      setDeclName(field.initType(), \"UInt32\");\n    }\n    {\n      auto decl = decls[2];\n      decl.initName().setValue(\"EnumType\");\n      decl.setEnum();\n\n      auto enumerants = decl.initNestedDecls(4);\n\n      for (uint i = 0; i < kj::size(RFC3092); i++) {\n        auto enumerantDecl = enumerants[i];\n        enumerantDecl.initName().setValue(RFC3092[i]);\n        enumerantDecl.getId().initOrdinal().setValue(i);\n        enumerantDecl.setEnumerant();\n      }\n    }\n\n    // For each of TYPE_OPTIONS, declare a struct type that contains that type as its @0 field.\n    for (uint i = 0; i < kj::size(TYPE_OPTIONS); i++) {\n      auto decl = decls[3 + i];\n      auto& option = TYPE_OPTIONS[i];\n\n      decl.initName().setValue(kj::str(option.name, \"Struct\"));\n      decl.setStruct();\n\n      auto fieldDecl = decl.initNestedDecls(1)[0];\n      fieldDecl.initName().setValue(\"f0\");\n      fieldDecl.getId().initOrdinal().setValue(0);\n      auto field = fieldDecl.initField();\n      setDeclName(field.initType(), option.name);\n\n      uint ordinal = 1;\n      for (auto j: kj::range(0, rand() % 4)) {\n        (void)j;\n        structAddField(decl, ordinal, false);\n      }\n    }\n  }\n\n  uint nextOrdinal = 0;\n\n  for (uint i = 0; i < 96; i++) {\n    uint oldOrdinalCount = nextOrdinal;\n\n    auto newBuilder = kj::heap<MallocMessageBuilder>();\n    newBuilder->setRoot(builder->getRoot<ParsedFile>().asReader());\n\n    auto parsedFile = newBuilder->getRoot<ParsedFile>();\n    Declaration::Builder decl = parsedFile.getRoot().getNestedDecls()[0];\n\n    // Apply a random modification.\n    ChangeInfo changeInfo;\n    while (changeInfo.kind == NO_CHANGE) {\n      auto& mod = chooseFrom(STRUCT_MODS);\n      changeInfo = mod(decl, nextOrdinal, false);\n    }\n\n    KJ_CONTEXT(changeInfo.description);\n\n    if (checkChange(builder->getRoot<ParsedFile>(), parsedFile, changeInfo.kind, oldOrdinalCount) &&\n        checkChange(parsedFile, builder->getRoot<ParsedFile>(), changeInfo.kind, oldOrdinalCount)) {\n      builder = kj::mv(newBuilder);\n    }\n  }\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "newBuilder"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkChange",
          "args": [
            "parsedFile",
            "builder->getRoot<ParsedFile>()",
            "changeInfo.kind",
            "oldOrdinalCount"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder->getRoot<ParsedFile>",
          "args": [],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkChange",
          "args": [
            "builder->getRoot<ParsedFile>()",
            "parsedFile",
            "changeInfo.kind",
            "oldOrdinalCount"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_CONTEXT",
          "args": [
            "changeInfo.description"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod",
          "args": [
            "decl",
            "nextOrdinal",
            "false"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chooseFrom",
          "args": [
            "STRUCT_MODS"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "chooseFrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "53-55",
          "snippet": "auto chooseFrom(T arr) -> decltype(arr[0]) {\n  return arr[rand() % arr.size()];\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nauto chooseFrom(T arr) -> decltype(arr[0]) {\n  return arr[rand() % arr.size()];\n}"
        }
      },
      {
        "call_info": {
          "callee": "newBuilder->setRoot",
          "args": [
            "builder->getRoot<ParsedFile>().asReader()"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<MallocMessageBuilder>",
          "args": [],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "321-328",
          "snippet": "Own<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "structAddField",
          "args": [
            "decl",
            "ordinal",
            "false"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "structAddField",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "176-193",
          "snippet": "static ChangeInfo structAddField(Declaration::Builder decl, uint& nextOrdinal, bool scopeHasUnion) {\n  auto fieldDecl = addNested(decl);\n\n  uint ordinal = nextOrdinal++;\n\n  fieldDecl.initName().setValue(kj::str(\"f\", ordinal));\n  fieldDecl.getId().initOrdinal().setValue(ordinal);\n\n  auto field = fieldDecl.initField();\n\n  auto makeValue = randomizeType(field.initType());\n  if (rand() % 4 == 0) {\n    makeValue(field.getDefaultValue().initValue());\n  } else {\n    field.getDefaultValue().setNone();\n  }\n  return { COMPATIBLE, \"Add field.\" };\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nstatic ChangeInfo structAddField(Declaration::Builder decl, uint& nextOrdinal, bool scopeHasUnion) {\n  auto fieldDecl = addNested(decl);\n\n  uint ordinal = nextOrdinal++;\n\n  fieldDecl.initName().setValue(kj::str(\"f\", ordinal));\n  fieldDecl.getId().initOrdinal().setValue(ordinal);\n\n  auto field = fieldDecl.initField();\n\n  auto makeValue = randomizeType(field.initType());\n  if (rand() % 4 == 0) {\n    makeValue(field.getDefaultValue().initValue());\n  } else {\n    field.getDefaultValue().setNone();\n  }\n  return { COMPATIBLE, \"Add field.\" };\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::range",
          "args": [
            "0",
            "rand() % 4"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "642-642",
          "snippet": "inline constexpr Range<Decay<T>> range(T begin, T end) { return Range<Decay<T>>(begin, end); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<Decay<T>> range(T begin, T end) { return Range<Decay<T>>(begin, end); }"
        }
      },
      {
        "call_info": {
          "callee": "rand",
          "args": [],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "Annotation::Builder::disownBrand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.capnp.h",
          "lines": "7365-7368",
          "snippet": "inline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {\n  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(\n      _builder.getPointerField(1 * ::capnp::POINTERS));\n}",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {\n  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(\n      _builder.getPointerField(1 * ::capnp::POINTERS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "setDeclName",
          "args": [
            "field.initType()",
            "option.name"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "setDeclName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "116-118",
          "snippet": "void setDeclName(Expression::Builder decl, kj::StringPtr name) {\n  decl.initRelativeName().setValue(name);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nvoid setDeclName(Expression::Builder decl, kj::StringPtr name) {\n  decl.initRelativeName().setValue(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "field.initType",
          "args": [],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fieldDecl.initField",
          "args": [],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fieldDecl.getId",
          "args": [
            "0"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fieldDecl.getId",
          "args": [],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "fieldDecl.initName",
          "args": [
            "\"f0\""
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fieldDecl.initName",
          "args": [],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.initNestedDecls",
          "args": [
            "1"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.setStruct",
          "args": [],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.initName",
          "args": [
            "kj::str(option.name, \"Struct\")"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "option.name",
            "\"Struct\""
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.initName",
          "args": [],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::size",
          "args": [
            "TYPE_OPTIONS"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "493-493",
          "snippet": "inline constexpr size_t size(T&& arr) { return arr.size(); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr size_t size(T&& arr) { return arr.size(); }"
        }
      },
      {
        "call_info": {
          "callee": "enumerantDecl.setEnumerant",
          "args": [],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerantDecl.getId",
          "args": [
            "i"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerantDecl.initName",
          "args": [
            "RFC3092[i]"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerantDecl.initName",
          "args": [],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.initNestedDecls",
          "args": [
            "4"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.setEnum",
          "args": [],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.initName",
          "args": [
            "\"EnumType\""
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.initName",
          "args": [],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.initType",
          "args": [],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fieldDecl.initField",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fieldDecl.getId",
          "args": [
            "0"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fieldDecl.initName",
          "args": [
            "\"i\""
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fieldDecl.initName",
          "args": [],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.initNestedDecls",
          "args": [
            "1"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.setStruct",
          "args": [],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.initName",
          "args": [
            "\"StructType\""
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.initName",
          "args": [],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.setStruct",
          "args": [],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.initId",
          "args": [
            "0x823456789abcdef1llu"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.initId",
          "args": [],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.initId",
          "args": [],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.initName",
          "args": [
            "\"EvolvingStruct\""
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.initName",
          "args": [],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.initNestedDecls",
          "args": [
            "3 + kj::size(TYPE_OPTIONS)"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.initId",
          "args": [
            "0x8123456789abcdefllu"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.initId",
          "args": [],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.initId",
          "args": [],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.setFile",
          "args": [],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsedFile.initRoot",
          "args": [],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder->initRoot<ParsedFile>",
          "args": [],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nvoid doTest() {\n  auto builder = kj::heap<MallocMessageBuilder>();\n\n  {\n    // Set up the basic file decl.\n    auto parsedFile = builder->initRoot<ParsedFile>();\n    auto file = parsedFile.initRoot();\n    file.setFile();\n    file.initId().initUid().setValue(0x8123456789abcdefllu);\n    auto decls = file.initNestedDecls(3 + kj::size(TYPE_OPTIONS));\n\n    {\n      auto decl = decls[0];\n      decl.initName().setValue(\"EvolvingStruct\");\n      decl.initId().initUid().setValue(0x823456789abcdef1llu);\n      decl.setStruct();\n    }\n    {\n      auto decl = decls[1];\n      decl.initName().setValue(\"StructType\");\n      decl.setStruct();\n\n      auto fieldDecl = decl.initNestedDecls(1)[0];\n      fieldDecl.initName().setValue(\"i\");\n      fieldDecl.getId().initOrdinal().setValue(0);\n      auto field = fieldDecl.initField();\n      setDeclName(field.initType(), \"UInt32\");\n    }\n    {\n      auto decl = decls[2];\n      decl.initName().setValue(\"EnumType\");\n      decl.setEnum();\n\n      auto enumerants = decl.initNestedDecls(4);\n\n      for (uint i = 0; i < kj::size(RFC3092); i++) {\n        auto enumerantDecl = enumerants[i];\n        enumerantDecl.initName().setValue(RFC3092[i]);\n        enumerantDecl.getId().initOrdinal().setValue(i);\n        enumerantDecl.setEnumerant();\n      }\n    }\n\n    // For each of TYPE_OPTIONS, declare a struct type that contains that type as its @0 field.\n    for (uint i = 0; i < kj::size(TYPE_OPTIONS); i++) {\n      auto decl = decls[3 + i];\n      auto& option = TYPE_OPTIONS[i];\n\n      decl.initName().setValue(kj::str(option.name, \"Struct\"));\n      decl.setStruct();\n\n      auto fieldDecl = decl.initNestedDecls(1)[0];\n      fieldDecl.initName().setValue(\"f0\");\n      fieldDecl.getId().initOrdinal().setValue(0);\n      auto field = fieldDecl.initField();\n      setDeclName(field.initType(), option.name);\n\n      uint ordinal = 1;\n      for (auto j: kj::range(0, rand() % 4)) {\n        (void)j;\n        structAddField(decl, ordinal, false);\n      }\n    }\n  }\n\n  uint nextOrdinal = 0;\n\n  for (uint i = 0; i < 96; i++) {\n    uint oldOrdinalCount = nextOrdinal;\n\n    auto newBuilder = kj::heap<MallocMessageBuilder>();\n    newBuilder->setRoot(builder->getRoot<ParsedFile>().asReader());\n\n    auto parsedFile = newBuilder->getRoot<ParsedFile>();\n    Declaration::Builder decl = parsedFile.getRoot().getNestedDecls()[0];\n\n    // Apply a random modification.\n    ChangeInfo changeInfo;\n    while (changeInfo.kind == NO_CHANGE) {\n      auto& mod = chooseFrom(STRUCT_MODS);\n      changeInfo = mod(decl, nextOrdinal, false);\n    }\n\n    KJ_CONTEXT(changeInfo.description);\n\n    if (checkChange(builder->getRoot<ParsedFile>(), parsedFile, changeInfo.kind, oldOrdinalCount) &&\n        checkChange(parsedFile, builder->getRoot<ParsedFile>(), changeInfo.kind, oldOrdinalCount)) {\n      builder = kj::mv(newBuilder);\n    }\n  }\n}"
  },
  {
    "function_name": "checkChange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "713-747",
    "snippet": "bool checkChange(ParsedFile::Reader file1, ParsedFile::Reader file2, ChangeKind changeKind,\n                 uint sharedOrdinalCount) {\n  // Try loading file1 followed by file2 into the same SchemaLoader, expecting it to behave\n  // according to changeKind.  Returns true if the files are both expected to be compatible and\n  // actually are -- the main loop uses this to decide which version to keep\n\n  kj::Maybe<kj::Own<MallocMessageBuilder>> exampleBuilder;\n\n  if (changeKind != INCOMPATIBLE) {\n    // For COMPATIBLE and SUBTLY_COMPATIBLE changes, build an example message with one schema\n    // and check it with the other.\n    exampleBuilder = kj::heap<MallocMessageBuilder>();\n  }\n\n  SchemaLoader loader;\n  loadFile(file1, loader, true, exampleBuilder, sharedOrdinalCount);\n  auto exception = loadFile(file2, loader, false, exampleBuilder, sharedOrdinalCount);\n\n  if (changeKind == COMPATIBLE) {\n    KJ_IF_MAYBE(e, exception) {\n      kj::getExceptionCallback().onFatalException(kj::mv(*e));\n      return false;\n    } else {\n      return true;\n    }\n  } else if (changeKind == INCOMPATIBLE) {\n    KJ_ASSERT(exception != nullptr, file1, file2);\n    return false;\n  } else {\n    KJ_ASSERT(changeKind == SUBTLY_COMPATIBLE);\n\n    // SchemaLoader is allowed to throw an exception in this case, but we ignore it.\n    return true;\n  }\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "changeKind == SUBTLY_COMPATIBLE"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "exception != nullptr",
            "file1",
            "file2"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::getExceptionCallback",
          "args": [
            "kj::mv(*e)"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*e"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::getExceptionCallback",
          "args": [],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadFile",
          "args": [
            "file2",
            "loader",
            "false",
            "exampleBuilder",
            "sharedOrdinalCount"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadFile",
          "args": [
            "file1",
            "loader",
            "true",
            "exampleBuilder",
            "sharedOrdinalCount"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<MallocMessageBuilder>",
          "args": [],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "321-328",
          "snippet": "Own<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nbool checkChange(ParsedFile::Reader file1, ParsedFile::Reader file2, ChangeKind changeKind,\n                 uint sharedOrdinalCount) {\n  // Try loading file1 followed by file2 into the same SchemaLoader, expecting it to behave\n  // according to changeKind.  Returns true if the files are both expected to be compatible and\n  // actually are -- the main loop uses this to decide which version to keep\n\n  kj::Maybe<kj::Own<MallocMessageBuilder>> exampleBuilder;\n\n  if (changeKind != INCOMPATIBLE) {\n    // For COMPATIBLE and SUBTLY_COMPATIBLE changes, build an example message with one schema\n    // and check it with the other.\n    exampleBuilder = kj::heap<MallocMessageBuilder>();\n  }\n\n  SchemaLoader loader;\n  loadFile(file1, loader, true, exampleBuilder, sharedOrdinalCount);\n  auto exception = loadFile(file2, loader, false, exampleBuilder, sharedOrdinalCount);\n\n  if (changeKind == COMPATIBLE) {\n    KJ_IF_MAYBE(e, exception) {\n      kj::getExceptionCallback().onFatalException(kj::mv(*e));\n      return false;\n    } else {\n      return true;\n    }\n  } else if (changeKind == INCOMPATIBLE) {\n    KJ_ASSERT(exception != nullptr, file1, file2);\n    return false;\n  } else {\n    KJ_ASSERT(changeKind == SUBTLY_COMPATIBLE);\n\n    // SchemaLoader is allowed to throw an exception in this case, but we ignore it.\n    return true;\n  }\n}"
  },
  {
    "function_name": "loadFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "671-711",
    "snippet": "static kj::Maybe<kj::Exception> loadFile(\n    ParsedFile::Reader file, SchemaLoader& loader, bool allNodes,\n    kj::Maybe<kj::Own<MallocMessageBuilder>>& messageBuilder,\n    uint sharedOrdinalCount) {\n  Compiler compiler;\n  ModuleImpl module(file);\n  KJ_ASSERT(compiler.add(module) == 0x8123456789abcdefllu);\n\n  if (allNodes) {\n    // Eagerly compile and load the whole thing.\n    compiler.eagerlyCompile(0x8123456789abcdefllu, Compiler::ALL_RELATED_NODES);\n\n    KJ_IF_MAYBE(m, messageBuilder) {\n      // Build an example struct using the compiled schema.\n      m->get()->adoptRoot(makeExampleStruct(\n          m->get()->getOrphanage(), compiler.getLoader().get(0x823456789abcdef1llu).asStruct(),\n          sharedOrdinalCount));\n    }\n\n    for (auto schema: compiler.getLoader().getAllLoaded()) {\n      loader.load(schema.getProto());\n    }\n    return nullptr;\n  } else {\n    // Compile the file root so that the children are findable, then load the specific child\n    // we want.\n    compiler.eagerlyCompile(0x8123456789abcdefllu, Compiler::NODE);\n\n    KJ_IF_MAYBE(m, messageBuilder) {\n      // Check that the example struct matches the compiled schema.\n      auto root = m->get()->getRoot<DynamicStruct>(\n          compiler.getLoader().get(0x823456789abcdef1llu).asStruct()).asReader();\n      KJ_CONTEXT(root);\n      checkExampleStruct(root, sharedOrdinalCount);\n    }\n\n    return kj::runCatchingExceptions([&]() {\n      loadStructAndGroups(compiler.getLoader(), loader, 0x823456789abcdef1llu);\n    });\n  }\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() {\n      loadStructAndGroups(compiler.getLoader(), loader, 0x823456789abcdef1llu);\n    }"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadStructAndGroups",
          "args": [
            "compiler.getLoader()",
            "loader",
            "0x823456789abcdef1llu"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "loadStructAndGroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "660-669",
          "snippet": "static void loadStructAndGroups(const SchemaLoader& src, SchemaLoader& dst, uint64_t id) {\n  auto proto = src.get(id).getProto();\n  dst.load(proto);\n\n  for (auto field: proto.getStruct().getFields()) {\n    if (field.isGroup()) {\n      loadStructAndGroups(src, dst, field.getGroup().getTypeId());\n    }\n  }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nstatic void loadStructAndGroups(const SchemaLoader& src, SchemaLoader& dst, uint64_t id) {\n  auto proto = src.get(id).getProto();\n  dst.load(proto);\n\n  for (auto field: proto.getStruct().getFields()) {\n    if (field.isGroup()) {\n      loadStructAndGroups(src, dst, field.getGroup().getTypeId());\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compiler.getLoader",
          "args": [],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkExampleStruct",
          "args": [
            "root",
            "sharedOrdinalCount"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "checkExampleStruct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "614-633",
          "snippet": "void checkExampleStruct(DynamicStruct::Reader reader, uint sharedOrdinalCount) {\n  auto schema = reader.getSchema();\n\n  for (auto field: schema.getNonUnionFields()) {\n    checkExampleField(reader, field, sharedOrdinalCount);\n  }\n\n  auto unionFields = schema.getUnionFields();\n\n  // Pretend the union doesn't have any fields that aren't in the shared ordinal range.\n  uint range = unionFields.size();\n  while (range > 0 && getOrdinal(unionFields[range - 1]) >= sharedOrdinalCount) {\n    --range;\n  }\n\n  if (range > 0) {\n    auto field = unionFields[getOrdinal(unionFields[0]) % range];\n    checkExampleField(reader, field, sharedOrdinalCount);\n  }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nvoid checkExampleStruct(DynamicStruct::Reader reader, uint sharedOrdinalCount) {\n  auto schema = reader.getSchema();\n\n  for (auto field: schema.getNonUnionFields()) {\n    checkExampleField(reader, field, sharedOrdinalCount);\n  }\n\n  auto unionFields = schema.getUnionFields();\n\n  // Pretend the union doesn't have any fields that aren't in the shared ordinal range.\n  uint range = unionFields.size();\n  while (range > 0 && getOrdinal(unionFields[range - 1]) >= sharedOrdinalCount) {\n    --range;\n  }\n\n  if (range > 0) {\n    auto field = unionFields[getOrdinal(unionFields[0]) % range];\n    checkExampleField(reader, field, sharedOrdinalCount);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_CONTEXT",
          "args": [
            "root"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->get",
          "args": [],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "getRaw",
          "container": "DynamicEnum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "149-149",
          "snippet": "inline uint16_t getRaw() const { return value; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\nDynamicEnum {\n  inline uint16_t getRaw() const { return value; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m->get",
          "args": [
            "compiler.getLoader().get(0x823456789abcdef1llu).asStruct()"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "AdapterPromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "631-634",
          "snippet": "void get(ExceptionOrValue& output) noexcept override {\n    KJ_IREQUIRE(!isWaiting());\n    output.as<T>() = kj::mv(result);\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "AdapterPromiseNode {\n  void get(ExceptionOrValue& output) noexcept override {\n      KJ_IREQUIRE(!isWaiting());\n      output.as<T>() = kj::mv(result);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compiler.getLoader",
          "args": [],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compiler.getLoader",
          "args": [
            "0x823456789abcdef1llu"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compiler.getLoader",
          "args": [],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compiler.eagerlyCompile",
          "args": [
            "0x8123456789abcdefllu",
            "Compiler::NODE"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loader.load",
          "args": [
            "schema.getProto()"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.getProto",
          "args": [],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "compiler.getLoader",
          "args": [],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compiler.getLoader",
          "args": [],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeExampleStruct",
          "args": [
            "m->get()->getOrphanage()",
            "compiler.getLoader().get(0x823456789abcdef1llu).asStruct()",
            "sharedOrdinalCount"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "makeExampleStruct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "584-612",
          "snippet": "Orphan<DynamicStruct> makeExampleStruct(\n    Orphanage orphanage, StructSchema schema, uint sharedOrdinalCount) {\n  // Initialize all fields of the struct via reflection, such that they can be verified using\n  // a different version of the struct.  sharedOrdinalCount is the number of ordinals shared by\n  // the two versions.  This is used mainly to avoid setting union members that the other version\n  // doesn't have.\n\n  Orphan<DynamicStruct> result = orphanage.newOrphan(schema);\n  auto builder = result.get();\n\n  for (auto field: schema.getNonUnionFields()) {\n    setExampleField(builder, field, sharedOrdinalCount);\n  }\n\n  auto unionFields = schema.getUnionFields();\n\n  // Pretend the union doesn't have any fields that aren't in the shared ordinal range.\n  uint range = unionFields.size();\n  while (range > 0 && getOrdinal(unionFields[range - 1]) >= sharedOrdinalCount) {\n    --range;\n  }\n\n  if (range > 0) {\n    auto field = unionFields[getOrdinal(unionFields[0]) % range];\n    setExampleField(builder, field, sharedOrdinalCount);\n  }\n\n  return kj::mv(result);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nOrphan<DynamicStruct> makeExampleStruct(\n    Orphanage orphanage, StructSchema schema, uint sharedOrdinalCount) {\n  // Initialize all fields of the struct via reflection, such that they can be verified using\n  // a different version of the struct.  sharedOrdinalCount is the number of ordinals shared by\n  // the two versions.  This is used mainly to avoid setting union members that the other version\n  // doesn't have.\n\n  Orphan<DynamicStruct> result = orphanage.newOrphan(schema);\n  auto builder = result.get();\n\n  for (auto field: schema.getNonUnionFields()) {\n    setExampleField(builder, field, sharedOrdinalCount);\n  }\n\n  auto unionFields = schema.getUnionFields();\n\n  // Pretend the union doesn't have any fields that aren't in the shared ordinal range.\n  uint range = unionFields.size();\n  while (range > 0 && getOrdinal(unionFields[range - 1]) >= sharedOrdinalCount) {\n    --range;\n  }\n\n  if (range > 0) {\n    auto field = unionFields[getOrdinal(unionFields[0]) % range];\n    setExampleField(builder, field, sharedOrdinalCount);\n  }\n\n  return kj::mv(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compiler.getLoader",
          "args": [],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compiler.getLoader",
          "args": [
            "0x823456789abcdef1llu"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compiler.getLoader",
          "args": [],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compiler.eagerlyCompile",
          "args": [
            "0x8123456789abcdefllu",
            "Compiler::ALL_RELATED_NODES"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "compiler.add(module) == 0x8123456789abcdefllu"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compiler.add",
          "args": [
            "module"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nstatic kj::Maybe<kj::Exception> loadFile(\n    ParsedFile::Reader file, SchemaLoader& loader, bool allNodes,\n    kj::Maybe<kj::Own<MallocMessageBuilder>>& messageBuilder,\n    uint sharedOrdinalCount) {\n  Compiler compiler;\n  ModuleImpl module(file);\n  KJ_ASSERT(compiler.add(module) == 0x8123456789abcdefllu);\n\n  if (allNodes) {\n    // Eagerly compile and load the whole thing.\n    compiler.eagerlyCompile(0x8123456789abcdefllu, Compiler::ALL_RELATED_NODES);\n\n    KJ_IF_MAYBE(m, messageBuilder) {\n      // Build an example struct using the compiled schema.\n      m->get()->adoptRoot(makeExampleStruct(\n          m->get()->getOrphanage(), compiler.getLoader().get(0x823456789abcdef1llu).asStruct(),\n          sharedOrdinalCount));\n    }\n\n    for (auto schema: compiler.getLoader().getAllLoaded()) {\n      loader.load(schema.getProto());\n    }\n    return nullptr;\n  } else {\n    // Compile the file root so that the children are findable, then load the specific child\n    // we want.\n    compiler.eagerlyCompile(0x8123456789abcdefllu, Compiler::NODE);\n\n    KJ_IF_MAYBE(m, messageBuilder) {\n      // Check that the example struct matches the compiled schema.\n      auto root = m->get()->getRoot<DynamicStruct>(\n          compiler.getLoader().get(0x823456789abcdef1llu).asStruct()).asReader();\n      KJ_CONTEXT(root);\n      checkExampleStruct(root, sharedOrdinalCount);\n    }\n\n    return kj::runCatchingExceptions([&]() {\n      loadStructAndGroups(compiler.getLoader(), loader, 0x823456789abcdef1llu);\n    });\n  }\n}"
  },
  {
    "function_name": "loadStructAndGroups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "660-669",
    "snippet": "static void loadStructAndGroups(const SchemaLoader& src, SchemaLoader& dst, uint64_t id) {\n  auto proto = src.get(id).getProto();\n  dst.load(proto);\n\n  for (auto field: proto.getStruct().getFields()) {\n    if (field.isGroup()) {\n      loadStructAndGroups(src, dst, field.getGroup().getTypeId());\n    }\n  }\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "field.getGroup",
          "args": [],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getGroup",
          "args": [],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.isGroup",
          "args": [],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getStruct",
          "args": [],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getStruct",
          "args": [],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst.load",
          "args": [
            "proto"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src.get",
          "args": [],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "src.get",
          "args": [
            "id"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nstatic void loadStructAndGroups(const SchemaLoader& src, SchemaLoader& dst, uint64_t id) {\n  auto proto = src.get(id).getProto();\n  dst.load(proto);\n\n  for (auto field: proto.getStruct().getFields()) {\n    if (field.isGroup()) {\n      loadStructAndGroups(src, dst, field.getGroup().getTypeId());\n    }\n  }\n}"
  },
  {
    "function_name": "hadErrors",
    "container": "ModuleImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "652-654",
    "snippet": "bool hadErrors() override {\n    return false;\n  }",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nModuleImpl {\n  bool hadErrors() override {\n      return false;\n    }\n}"
  },
  {
    "function_name": "addError",
    "container": "ModuleImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "649-651",
    "snippet": "void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n    KJ_FAIL_ASSERT(\"Unexpected parse error.\", startByte, endByte, message);\n  }",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Unexpected parse error.\"",
            "startByte",
            "endByte",
            "message"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nModuleImpl {\n  void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n      KJ_FAIL_ASSERT(\"Unexpected parse error.\", startByte, endByte, message);\n    }\n}"
  },
  {
    "function_name": "importRelative",
    "container": "ModuleImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "645-647",
    "snippet": "kj::Maybe<Module&> importRelative(kj::StringPtr importPath) override {\n    return nullptr;\n  }",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nModuleImpl {\n  kj::Maybe<Module&> importRelative(kj::StringPtr importPath) override {\n      return nullptr;\n    }\n}"
  },
  {
    "function_name": "loadContent",
    "container": "ModuleImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "642-644",
    "snippet": "Orphan<ParsedFile> loadContent(Orphanage orphanage) override {\n    return orphanage.newOrphanCopy(content);\n  }",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "orphanage.newOrphanCopy",
          "args": [
            "content"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nModuleImpl {\n  Orphan<ParsedFile> loadContent(Orphanage orphanage) override {\n      return orphanage.newOrphanCopy(content);\n    }\n}"
  },
  {
    "function_name": "getSourceName",
    "container": "ModuleImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "641-641",
    "snippet": "kj::StringPtr getSourceName() override { return \"evolving-schema.capnp\"; }",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nModuleImpl {\n  kj::StringPtr getSourceName() override { return \"evolving-schema.capnp\"; }\n}"
  },
  {
    "function_name": "ModuleImpl",
    "container": "ModuleImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "639-639",
    "snippet": "explicit ModuleImpl(ParsedFile::Reader content): content(content) {}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nModuleImpl {\n  explicit ModuleImpl(ParsedFile::Reader content): content(content) {}\n}"
  },
  {
    "function_name": "checkExampleStruct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "614-633",
    "snippet": "void checkExampleStruct(DynamicStruct::Reader reader, uint sharedOrdinalCount) {\n  auto schema = reader.getSchema();\n\n  for (auto field: schema.getNonUnionFields()) {\n    checkExampleField(reader, field, sharedOrdinalCount);\n  }\n\n  auto unionFields = schema.getUnionFields();\n\n  // Pretend the union doesn't have any fields that aren't in the shared ordinal range.\n  uint range = unionFields.size();\n  while (range > 0 && getOrdinal(unionFields[range - 1]) >= sharedOrdinalCount) {\n    --range;\n  }\n\n  if (range > 0) {\n    auto field = unionFields[getOrdinal(unionFields[0]) % range];\n    checkExampleField(reader, field, sharedOrdinalCount);\n  }\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "checkExampleField",
          "args": [
            "reader",
            "field",
            "sharedOrdinalCount"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "checkExampleField",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "566-582",
          "snippet": "void checkExampleField(DynamicStruct::Reader reader, StructSchema::Field field,\n                       uint sharedOrdinalCount) {\n  auto fieldProto = field.getProto();\n  switch (fieldProto.which()) {\n    case schema::Field::SLOT: {\n      uint ordinal = getOrdinal(field);\n      if (ordinal < sharedOrdinalCount) {\n        checkExampleValue(reader.get(field), ordinal,\n                          fieldProto.getSlot().getType(), sharedOrdinalCount);\n      }\n      break;\n    }\n    case schema::Field::GROUP:\n      checkExampleStruct(reader.get(field).as<DynamicStruct>(), sharedOrdinalCount);\n      break;\n  }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nvoid checkExampleField(DynamicStruct::Reader reader, StructSchema::Field field,\n                       uint sharedOrdinalCount) {\n  auto fieldProto = field.getProto();\n  switch (fieldProto.which()) {\n    case schema::Field::SLOT: {\n      uint ordinal = getOrdinal(field);\n      if (ordinal < sharedOrdinalCount) {\n        checkExampleValue(reader.get(field), ordinal,\n                          fieldProto.getSlot().getType(), sharedOrdinalCount);\n      }\n      break;\n    }\n    case schema::Field::GROUP:\n      checkExampleStruct(reader.get(field).as<DynamicStruct>(), sharedOrdinalCount);\n      break;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getOrdinal",
          "args": [
            "unionFields[0]"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "getOrdinal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "451-461",
          "snippet": "uint getOrdinal(StructSchema::Field field) {\n  auto proto = field.getProto();\n  if (proto.getOrdinal().isExplicit()) {\n    return proto.getOrdinal().getExplicit();\n  }\n\n  KJ_ASSERT(proto.isGroup());\n\n  auto group = field.getType().asStruct();\n  return getOrdinal(group.getFields()[0]);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nuint getOrdinal(StructSchema::Field field) {\n  auto proto = field.getProto();\n  if (proto.getOrdinal().isExplicit()) {\n    return proto.getOrdinal().getExplicit();\n  }\n\n  KJ_ASSERT(proto.isGroup());\n\n  auto group = field.getType().asStruct();\n  return getOrdinal(group.getFields()[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unionFields.size",
          "args": [],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "schema.getUnionFields",
          "args": [],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.getNonUnionFields",
          "args": [],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.getSchema",
          "args": [],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "getSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "505-505",
          "snippet": "inline InterfaceSchema getSchema() const { return schema; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline InterfaceSchema getSchema() const { return schema; }"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nvoid checkExampleStruct(DynamicStruct::Reader reader, uint sharedOrdinalCount) {\n  auto schema = reader.getSchema();\n\n  for (auto field: schema.getNonUnionFields()) {\n    checkExampleField(reader, field, sharedOrdinalCount);\n  }\n\n  auto unionFields = schema.getUnionFields();\n\n  // Pretend the union doesn't have any fields that aren't in the shared ordinal range.\n  uint range = unionFields.size();\n  while (range > 0 && getOrdinal(unionFields[range - 1]) >= sharedOrdinalCount) {\n    --range;\n  }\n\n  if (range > 0) {\n    auto field = unionFields[getOrdinal(unionFields[0]) % range];\n    checkExampleField(reader, field, sharedOrdinalCount);\n  }\n}"
  },
  {
    "function_name": "makeExampleStruct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "584-612",
    "snippet": "Orphan<DynamicStruct> makeExampleStruct(\n    Orphanage orphanage, StructSchema schema, uint sharedOrdinalCount) {\n  // Initialize all fields of the struct via reflection, such that they can be verified using\n  // a different version of the struct.  sharedOrdinalCount is the number of ordinals shared by\n  // the two versions.  This is used mainly to avoid setting union members that the other version\n  // doesn't have.\n\n  Orphan<DynamicStruct> result = orphanage.newOrphan(schema);\n  auto builder = result.get();\n\n  for (auto field: schema.getNonUnionFields()) {\n    setExampleField(builder, field, sharedOrdinalCount);\n  }\n\n  auto unionFields = schema.getUnionFields();\n\n  // Pretend the union doesn't have any fields that aren't in the shared ordinal range.\n  uint range = unionFields.size();\n  while (range > 0 && getOrdinal(unionFields[range - 1]) >= sharedOrdinalCount) {\n    --range;\n  }\n\n  if (range > 0) {\n    auto field = unionFields[getOrdinal(unionFields[0]) % range];\n    setExampleField(builder, field, sharedOrdinalCount);\n  }\n\n  return kj::mv(result);\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setExampleField",
          "args": [
            "builder",
            "field",
            "sharedOrdinalCount"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "setExampleField",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "549-564",
          "snippet": "void setExampleField(DynamicStruct::Builder builder, StructSchema::Field field,\n                     uint sharedOrdinalCount) {\n  auto fieldProto = field.getProto();\n  switch (fieldProto.which()) {\n    case schema::Field::SLOT:\n      builder.adopt(field, makeExampleValue(\n          Orphanage::getForMessageContaining(builder),\n          getOrdinal(field), field.getType(), sharedOrdinalCount));\n      break;\n    case schema::Field::GROUP:\n      builder.adopt(field, makeExampleStruct(\n          Orphanage::getForMessageContaining(builder),\n          field.getType().asStruct(), sharedOrdinalCount));\n      break;\n  }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nvoid setExampleField(DynamicStruct::Builder builder, StructSchema::Field field,\n                     uint sharedOrdinalCount) {\n  auto fieldProto = field.getProto();\n  switch (fieldProto.which()) {\n    case schema::Field::SLOT:\n      builder.adopt(field, makeExampleValue(\n          Orphanage::getForMessageContaining(builder),\n          getOrdinal(field), field.getType(), sharedOrdinalCount));\n      break;\n    case schema::Field::GROUP:\n      builder.adopt(field, makeExampleStruct(\n          Orphanage::getForMessageContaining(builder),\n          field.getType().asStruct(), sharedOrdinalCount));\n      break;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getOrdinal",
          "args": [
            "unionFields[0]"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "getOrdinal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "451-461",
          "snippet": "uint getOrdinal(StructSchema::Field field) {\n  auto proto = field.getProto();\n  if (proto.getOrdinal().isExplicit()) {\n    return proto.getOrdinal().getExplicit();\n  }\n\n  KJ_ASSERT(proto.isGroup());\n\n  auto group = field.getType().asStruct();\n  return getOrdinal(group.getFields()[0]);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nuint getOrdinal(StructSchema::Field field) {\n  auto proto = field.getProto();\n  if (proto.getOrdinal().isExplicit()) {\n    return proto.getOrdinal().getExplicit();\n  }\n\n  KJ_ASSERT(proto.isGroup());\n\n  auto group = field.getType().asStruct();\n  return getOrdinal(group.getFields()[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unionFields.size",
          "args": [],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "schema.getUnionFields",
          "args": [],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.getNonUnionFields",
          "args": [],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.get",
          "args": [],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan",
          "args": [
            "schema"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nOrphan<DynamicStruct> makeExampleStruct(\n    Orphanage orphanage, StructSchema schema, uint sharedOrdinalCount) {\n  // Initialize all fields of the struct via reflection, such that they can be verified using\n  // a different version of the struct.  sharedOrdinalCount is the number of ordinals shared by\n  // the two versions.  This is used mainly to avoid setting union members that the other version\n  // doesn't have.\n\n  Orphan<DynamicStruct> result = orphanage.newOrphan(schema);\n  auto builder = result.get();\n\n  for (auto field: schema.getNonUnionFields()) {\n    setExampleField(builder, field, sharedOrdinalCount);\n  }\n\n  auto unionFields = schema.getUnionFields();\n\n  // Pretend the union doesn't have any fields that aren't in the shared ordinal range.\n  uint range = unionFields.size();\n  while (range > 0 && getOrdinal(unionFields[range - 1]) >= sharedOrdinalCount) {\n    --range;\n  }\n\n  if (range > 0) {\n    auto field = unionFields[getOrdinal(unionFields[0]) % range];\n    setExampleField(builder, field, sharedOrdinalCount);\n  }\n\n  return kj::mv(result);\n}"
  },
  {
    "function_name": "checkExampleField",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "566-582",
    "snippet": "void checkExampleField(DynamicStruct::Reader reader, StructSchema::Field field,\n                       uint sharedOrdinalCount) {\n  auto fieldProto = field.getProto();\n  switch (fieldProto.which()) {\n    case schema::Field::SLOT: {\n      uint ordinal = getOrdinal(field);\n      if (ordinal < sharedOrdinalCount) {\n        checkExampleValue(reader.get(field), ordinal,\n                          fieldProto.getSlot().getType(), sharedOrdinalCount);\n      }\n      break;\n    }\n    case schema::Field::GROUP:\n      checkExampleStruct(reader.get(field).as<DynamicStruct>(), sharedOrdinalCount);\n      break;\n  }\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "checkExampleStruct",
          "args": [
            "reader.get(field).as<DynamicStruct>()",
            "sharedOrdinalCount"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "checkExampleStruct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "614-633",
          "snippet": "void checkExampleStruct(DynamicStruct::Reader reader, uint sharedOrdinalCount) {\n  auto schema = reader.getSchema();\n\n  for (auto field: schema.getNonUnionFields()) {\n    checkExampleField(reader, field, sharedOrdinalCount);\n  }\n\n  auto unionFields = schema.getUnionFields();\n\n  // Pretend the union doesn't have any fields that aren't in the shared ordinal range.\n  uint range = unionFields.size();\n  while (range > 0 && getOrdinal(unionFields[range - 1]) >= sharedOrdinalCount) {\n    --range;\n  }\n\n  if (range > 0) {\n    auto field = unionFields[getOrdinal(unionFields[0]) % range];\n    checkExampleField(reader, field, sharedOrdinalCount);\n  }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nvoid checkExampleStruct(DynamicStruct::Reader reader, uint sharedOrdinalCount) {\n  auto schema = reader.getSchema();\n\n  for (auto field: schema.getNonUnionFields()) {\n    checkExampleField(reader, field, sharedOrdinalCount);\n  }\n\n  auto unionFields = schema.getUnionFields();\n\n  // Pretend the union doesn't have any fields that aren't in the shared ordinal range.\n  uint range = unionFields.size();\n  while (range > 0 && getOrdinal(unionFields[range - 1]) >= sharedOrdinalCount) {\n    --range;\n  }\n\n  if (range > 0) {\n    auto field = unionFields[getOrdinal(unionFields[0]) % range];\n    checkExampleField(reader, field, sharedOrdinalCount);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reader.get",
          "args": [],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reader.get",
          "args": [
            "field"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "checkExampleValue",
          "args": [
            "reader.get(field)",
            "ordinal",
            "fieldProto.getSlot().getType()",
            "sharedOrdinalCount"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "checkExampleValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "510-546",
          "snippet": "void checkExampleValue(DynamicValue::Reader value, uint ordinal, schema::Type::Reader type,\n                       uint sharedOrdinalCount) {\n  switch (type.which()) {\n    case schema::Type::INT32: KJ_ASSERT(value.as<int32_t>() == ordinal * 47327); break;\n    case schema::Type::FLOAT64: KJ_ASSERT(value.as<double>() == ordinal * 313.25); break;\n    case schema::Type::INT8: KJ_ASSERT(value.as<int8_t>() == int(ordinal % 256) - 128); break;\n    case schema::Type::UINT16: KJ_ASSERT(value.as<uint16_t>() == ordinal * 13); break;\n    case schema::Type::BOOL: KJ_ASSERT(value.as<bool>() == (ordinal % 2 == 0)); break;\n    case schema::Type::TEXT: KJ_ASSERT(value.as<Text>() == kj::str(ordinal)); break;\n    case schema::Type::STRUCT: {\n      auto structValue = value.as<DynamicStruct>();\n      auto structType = structValue.getSchema();\n\n      KJ_IF_MAYBE(fieldI, structType.findFieldByName(\"i\")) {\n        // Type is \"StructType\"\n        KJ_ASSERT(structValue.get(*fieldI).as<uint32_t>() == ordinal);\n      } else {\n        // Type is \"Int32Struct\" or the like.\n        auto field = structType.getFieldByName(\"f0\");\n        checkExampleValue(structValue.get(field), ordinal,\n                          field.getProto().getSlot().getType(), sharedOrdinalCount);\n      }\n      break;\n    }\n    case schema::Type::ENUM: {\n      auto enumerant = KJ_ASSERT_NONNULL(value.as<DynamicEnum>().getEnumerant());\n      KJ_ASSERT(enumerant.getIndex() ==\n          ordinal % enumerant.getContainingEnum().getEnumerants().size());\n      break;\n    }\n    case schema::Type::LIST:\n      checkExampleValue(value.as<DynamicList>()[0], ordinal, type.getList().getElementType(),\n                        sharedOrdinalCount);\n      break;\n    default:\n      KJ_FAIL_ASSERT(\"You added a new possible field type!\");\n  }",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nvoid checkExampleValue(DynamicValue::Reader value, uint ordinal, schema::Type::Reader type,\n                       uint sharedOrdinalCount) {\n  switch (type.which()) {\n    case schema::Type::INT32: KJ_ASSERT(value.as<int32_t>() == ordinal * 47327); break;\n    case schema::Type::FLOAT64: KJ_ASSERT(value.as<double>() == ordinal * 313.25); break;\n    case schema::Type::INT8: KJ_ASSERT(value.as<int8_t>() == int(ordinal % 256) - 128); break;\n    case schema::Type::UINT16: KJ_ASSERT(value.as<uint16_t>() == ordinal * 13); break;\n    case schema::Type::BOOL: KJ_ASSERT(value.as<bool>() == (ordinal % 2 == 0)); break;\n    case schema::Type::TEXT: KJ_ASSERT(value.as<Text>() == kj::str(ordinal)); break;\n    case schema::Type::STRUCT: {\n      auto structValue = value.as<DynamicStruct>();\n      auto structType = structValue.getSchema();\n\n      KJ_IF_MAYBE(fieldI, structType.findFieldByName(\"i\")) {\n        // Type is \"StructType\"\n        KJ_ASSERT(structValue.get(*fieldI).as<uint32_t>() == ordinal);\n      } else {\n        // Type is \"Int32Struct\" or the like.\n        auto field = structType.getFieldByName(\"f0\");\n        checkExampleValue(structValue.get(field), ordinal,\n                          field.getProto().getSlot().getType(), sharedOrdinalCount);\n      }\n      break;\n    }\n    case schema::Type::ENUM: {\n      auto enumerant = KJ_ASSERT_NONNULL(value.as<DynamicEnum>().getEnumerant());\n      KJ_ASSERT(enumerant.getIndex() ==\n          ordinal % enumerant.getContainingEnum().getEnumerants().size());\n      break;\n    }\n    case schema::Type::LIST:\n      checkExampleValue(value.as<DynamicList>()[0], ordinal, type.getList().getElementType(),\n                        sharedOrdinalCount);\n      break;\n    default:\n      KJ_FAIL_ASSERT(\"You added a new possible field type!\");\n  }"
        }
      },
      {
        "call_info": {
          "callee": "fieldProto.getSlot",
          "args": [],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fieldProto.getSlot",
          "args": [],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getOrdinal",
          "args": [
            "field"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "getOrdinal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "451-461",
          "snippet": "uint getOrdinal(StructSchema::Field field) {\n  auto proto = field.getProto();\n  if (proto.getOrdinal().isExplicit()) {\n    return proto.getOrdinal().getExplicit();\n  }\n\n  KJ_ASSERT(proto.isGroup());\n\n  auto group = field.getType().asStruct();\n  return getOrdinal(group.getFields()[0]);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nuint getOrdinal(StructSchema::Field field) {\n  auto proto = field.getProto();\n  if (proto.getOrdinal().isExplicit()) {\n    return proto.getOrdinal().getExplicit();\n  }\n\n  KJ_ASSERT(proto.isGroup());\n\n  auto group = field.getType().asStruct();\n  return getOrdinal(group.getFields()[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fieldProto.which",
          "args": [],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getProto",
          "args": [],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nvoid checkExampleField(DynamicStruct::Reader reader, StructSchema::Field field,\n                       uint sharedOrdinalCount) {\n  auto fieldProto = field.getProto();\n  switch (fieldProto.which()) {\n    case schema::Field::SLOT: {\n      uint ordinal = getOrdinal(field);\n      if (ordinal < sharedOrdinalCount) {\n        checkExampleValue(reader.get(field), ordinal,\n                          fieldProto.getSlot().getType(), sharedOrdinalCount);\n      }\n      break;\n    }\n    case schema::Field::GROUP:\n      checkExampleStruct(reader.get(field).as<DynamicStruct>(), sharedOrdinalCount);\n      break;\n  }\n}"
  },
  {
    "function_name": "setExampleField",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "549-564",
    "snippet": "void setExampleField(DynamicStruct::Builder builder, StructSchema::Field field,\n                     uint sharedOrdinalCount) {\n  auto fieldProto = field.getProto();\n  switch (fieldProto.which()) {\n    case schema::Field::SLOT:\n      builder.adopt(field, makeExampleValue(\n          Orphanage::getForMessageContaining(builder),\n          getOrdinal(field), field.getType(), sharedOrdinalCount));\n      break;\n    case schema::Field::GROUP:\n      builder.adopt(field, makeExampleStruct(\n          Orphanage::getForMessageContaining(builder),\n          field.getType().asStruct(), sharedOrdinalCount));\n      break;\n  }\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.adopt",
          "args": [
            "field",
            "makeExampleStruct(\n          Orphanage::getForMessageContaining(builder),\n          field.getType().asStruct(), sharedOrdinalCount)"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "adopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "828-830",
          "snippet": "static inline void adopt(PointerBuilder builder, Orphan<AnyPointer>&& value) {\n    builder.adopt(kj::mv(value.builder));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void adopt(PointerBuilder builder, Orphan<AnyPointer>&& value) {\n    builder.adopt(kj::mv(value.builder));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "makeExampleStruct",
          "args": [
            "Orphanage::getForMessageContaining(builder)",
            "field.getType().asStruct()",
            "sharedOrdinalCount"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "makeExampleStruct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "584-612",
          "snippet": "Orphan<DynamicStruct> makeExampleStruct(\n    Orphanage orphanage, StructSchema schema, uint sharedOrdinalCount) {\n  // Initialize all fields of the struct via reflection, such that they can be verified using\n  // a different version of the struct.  sharedOrdinalCount is the number of ordinals shared by\n  // the two versions.  This is used mainly to avoid setting union members that the other version\n  // doesn't have.\n\n  Orphan<DynamicStruct> result = orphanage.newOrphan(schema);\n  auto builder = result.get();\n\n  for (auto field: schema.getNonUnionFields()) {\n    setExampleField(builder, field, sharedOrdinalCount);\n  }\n\n  auto unionFields = schema.getUnionFields();\n\n  // Pretend the union doesn't have any fields that aren't in the shared ordinal range.\n  uint range = unionFields.size();\n  while (range > 0 && getOrdinal(unionFields[range - 1]) >= sharedOrdinalCount) {\n    --range;\n  }\n\n  if (range > 0) {\n    auto field = unionFields[getOrdinal(unionFields[0]) % range];\n    setExampleField(builder, field, sharedOrdinalCount);\n  }\n\n  return kj::mv(result);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nOrphan<DynamicStruct> makeExampleStruct(\n    Orphanage orphanage, StructSchema schema, uint sharedOrdinalCount) {\n  // Initialize all fields of the struct via reflection, such that they can be verified using\n  // a different version of the struct.  sharedOrdinalCount is the number of ordinals shared by\n  // the two versions.  This is used mainly to avoid setting union members that the other version\n  // doesn't have.\n\n  Orphan<DynamicStruct> result = orphanage.newOrphan(schema);\n  auto builder = result.get();\n\n  for (auto field: schema.getNonUnionFields()) {\n    setExampleField(builder, field, sharedOrdinalCount);\n  }\n\n  auto unionFields = schema.getUnionFields();\n\n  // Pretend the union doesn't have any fields that aren't in the shared ordinal range.\n  uint range = unionFields.size();\n  while (range > 0 && getOrdinal(unionFields[range - 1]) >= sharedOrdinalCount) {\n    --range;\n  }\n\n  if (range > 0) {\n    auto field = unionFields[getOrdinal(unionFields[0]) % range];\n    setExampleField(builder, field, sharedOrdinalCount);\n  }\n\n  return kj::mv(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "field.getType",
          "args": [],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "Orphanage::getForMessageContaining",
          "args": [
            "builder"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "Orphanage::getForMessageContaining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/orphan.h",
          "lines": "279-281",
          "snippet": "Orphanage Orphanage::getForMessageContaining(BuilderType builder) {\n  return Orphanage(GetInnerBuilder<FromBuilder<BuilderType>>::apply(builder).getArena());\n}",
          "includes": [
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n\nOrphanage Orphanage::getForMessageContaining(BuilderType builder) {\n  return Orphanage(GetInnerBuilder<FromBuilder<BuilderType>>::apply(builder).getArena());\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeExampleValue",
          "args": [
            "Orphanage::getForMessageContaining(builder)",
            "getOrdinal(field)",
            "field.getType()",
            "sharedOrdinalCount"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "makeExampleValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "467-507",
          "snippet": "Orphan<DynamicValue> makeExampleValue(\n    Orphanage orphanage, uint ordinal, Type type, uint sharedOrdinalCount) {\n  switch (type.which()) {\n    case schema::Type::INT32: return ordinal * 47327;\n    case schema::Type::FLOAT64: return ordinal * 313.25;\n    case schema::Type::INT8: return int(ordinal % 256) - 128;\n    case schema::Type::UINT16: return ordinal * 13;\n    case schema::Type::BOOL: return ordinal % 2 == 0;\n    case schema::Type::TEXT: return orphanage.newOrphanCopy(Text::Reader(kj::str(ordinal)));\n    case schema::Type::STRUCT: {\n      auto structType = type.asStruct();\n      auto result = orphanage.newOrphan(structType);\n      auto builder = result.get();\n\n      KJ_IF_MAYBE(fieldI, structType.findFieldByName(\"i\")) {\n        // Type is \"StructType\"\n        builder.set(*fieldI, ordinal);\n      } else {\n        // Type is \"Int32Struct\" or the like.\n        auto field = structType.getFieldByName(\"f0\");\n        builder.adopt(field, makeExampleValue(\n            orphanage, ordinal, field.getType(), sharedOrdinalCount));\n      }\n\n      return kj::mv(result);\n    }\n    case schema::Type::ENUM: {\n      auto enumerants = type.asEnum().getEnumerants();\n      return DynamicEnum(enumerants[ordinal %enumerants.size()]);\n    }\n    case schema::Type::LIST: {\n      auto listType = type.asList();\n      auto elementType = listType.getElementType();\n      auto result = orphanage.newOrphan(listType, 1);\n      result.get().adopt(0, makeExampleValue(\n          orphanage, ordinal, elementType, sharedOrdinalCount));\n      return kj::mv(result);\n    }\n    default:\n      KJ_FAIL_ASSERT(\"You added a new possible field type!\");\n  }",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nOrphan<DynamicValue> makeExampleValue(\n    Orphanage orphanage, uint ordinal, Type type, uint sharedOrdinalCount) {\n  switch (type.which()) {\n    case schema::Type::INT32: return ordinal * 47327;\n    case schema::Type::FLOAT64: return ordinal * 313.25;\n    case schema::Type::INT8: return int(ordinal % 256) - 128;\n    case schema::Type::UINT16: return ordinal * 13;\n    case schema::Type::BOOL: return ordinal % 2 == 0;\n    case schema::Type::TEXT: return orphanage.newOrphanCopy(Text::Reader(kj::str(ordinal)));\n    case schema::Type::STRUCT: {\n      auto structType = type.asStruct();\n      auto result = orphanage.newOrphan(structType);\n      auto builder = result.get();\n\n      KJ_IF_MAYBE(fieldI, structType.findFieldByName(\"i\")) {\n        // Type is \"StructType\"\n        builder.set(*fieldI, ordinal);\n      } else {\n        // Type is \"Int32Struct\" or the like.\n        auto field = structType.getFieldByName(\"f0\");\n        builder.adopt(field, makeExampleValue(\n            orphanage, ordinal, field.getType(), sharedOrdinalCount));\n      }\n\n      return kj::mv(result);\n    }\n    case schema::Type::ENUM: {\n      auto enumerants = type.asEnum().getEnumerants();\n      return DynamicEnum(enumerants[ordinal %enumerants.size()]);\n    }\n    case schema::Type::LIST: {\n      auto listType = type.asList();\n      auto elementType = listType.getElementType();\n      auto result = orphanage.newOrphan(listType, 1);\n      result.get().adopt(0, makeExampleValue(\n          orphanage, ordinal, elementType, sharedOrdinalCount));\n      return kj::mv(result);\n    }\n    default:\n      KJ_FAIL_ASSERT(\"You added a new possible field type!\");\n  }"
        }
      },
      {
        "call_info": {
          "callee": "getOrdinal",
          "args": [
            "field"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "getOrdinal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "451-461",
          "snippet": "uint getOrdinal(StructSchema::Field field) {\n  auto proto = field.getProto();\n  if (proto.getOrdinal().isExplicit()) {\n    return proto.getOrdinal().getExplicit();\n  }\n\n  KJ_ASSERT(proto.isGroup());\n\n  auto group = field.getType().asStruct();\n  return getOrdinal(group.getFields()[0]);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nuint getOrdinal(StructSchema::Field field) {\n  auto proto = field.getProto();\n  if (proto.getOrdinal().isExplicit()) {\n    return proto.getOrdinal().getExplicit();\n  }\n\n  KJ_ASSERT(proto.isGroup());\n\n  auto group = field.getType().asStruct();\n  return getOrdinal(group.getFields()[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fieldProto.which",
          "args": [],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getProto",
          "args": [],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nvoid setExampleField(DynamicStruct::Builder builder, StructSchema::Field field,\n                     uint sharedOrdinalCount) {\n  auto fieldProto = field.getProto();\n  switch (fieldProto.which()) {\n    case schema::Field::SLOT:\n      builder.adopt(field, makeExampleValue(\n          Orphanage::getForMessageContaining(builder),\n          getOrdinal(field), field.getType(), sharedOrdinalCount));\n      break;\n    case schema::Field::GROUP:\n      builder.adopt(field, makeExampleStruct(\n          Orphanage::getForMessageContaining(builder),\n          field.getType().asStruct(), sharedOrdinalCount));\n      break;\n  }\n}"
  },
  {
    "function_name": "checkExampleValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "510-546",
    "snippet": "void checkExampleValue(DynamicValue::Reader value, uint ordinal, schema::Type::Reader type,\n                       uint sharedOrdinalCount) {\n  switch (type.which()) {\n    case schema::Type::INT32: KJ_ASSERT(value.as<int32_t>() == ordinal * 47327); break;\n    case schema::Type::FLOAT64: KJ_ASSERT(value.as<double>() == ordinal * 313.25); break;\n    case schema::Type::INT8: KJ_ASSERT(value.as<int8_t>() == int(ordinal % 256) - 128); break;\n    case schema::Type::UINT16: KJ_ASSERT(value.as<uint16_t>() == ordinal * 13); break;\n    case schema::Type::BOOL: KJ_ASSERT(value.as<bool>() == (ordinal % 2 == 0)); break;\n    case schema::Type::TEXT: KJ_ASSERT(value.as<Text>() == kj::str(ordinal)); break;\n    case schema::Type::STRUCT: {\n      auto structValue = value.as<DynamicStruct>();\n      auto structType = structValue.getSchema();\n\n      KJ_IF_MAYBE(fieldI, structType.findFieldByName(\"i\")) {\n        // Type is \"StructType\"\n        KJ_ASSERT(structValue.get(*fieldI).as<uint32_t>() == ordinal);\n      } else {\n        // Type is \"Int32Struct\" or the like.\n        auto field = structType.getFieldByName(\"f0\");\n        checkExampleValue(structValue.get(field), ordinal,\n                          field.getProto().getSlot().getType(), sharedOrdinalCount);\n      }\n      break;\n    }\n    case schema::Type::ENUM: {\n      auto enumerant = KJ_ASSERT_NONNULL(value.as<DynamicEnum>().getEnumerant());\n      KJ_ASSERT(enumerant.getIndex() ==\n          ordinal % enumerant.getContainingEnum().getEnumerants().size());\n      break;\n    }\n    case schema::Type::LIST:\n      checkExampleValue(value.as<DynamicList>()[0], ordinal, type.getList().getElementType(),\n                        sharedOrdinalCount);\n      break;\n    default:\n      KJ_FAIL_ASSERT(\"You added a new possible field type!\");\n  }",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"You added a new possible field type!\""
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getList",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getList",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.as<DynamicList>",
          "args": [],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "as",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "601-604",
          "snippet": "BuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nBuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "enumerant.getIndex() ==\n          ordinal % enumerant.getContainingEnum().getEnumerants().size()"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerant.getContainingEnum",
          "args": [],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "getContainingEnum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "396-396",
          "snippet": "inline EnumSchema getContainingEnum() const { return parent; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline EnumSchema getContainingEnum() const { return parent; }"
        }
      },
      {
        "call_info": {
          "callee": "enumerant.getIndex",
          "args": [],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "getIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "487-487",
          "snippet": "inline uint getIndex() const { return ordinal; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline uint getIndex() const { return ordinal; }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "value.as<DynamicEnum>().getEnumerant()"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getProto",
          "args": [],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "structValue.get",
          "args": [
            "field"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "structType.getFieldByName",
          "args": [
            "\"f0\""
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "structValue.get(*fieldI).as<uint32_t>() == ordinal"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structValue.get",
          "args": [],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "fieldI",
            "structType.findFieldByName(\"i\")"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "structType.findFieldByName",
          "args": [
            "\"i\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structValue.getSchema",
          "args": [],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "getSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "505-505",
          "snippet": "inline InterfaceSchema getSchema() const { return schema; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline InterfaceSchema getSchema() const { return schema; }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "value.as<Text>() == kj::str(ordinal)"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "ordinal"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "341-341",
          "snippet": "inline String str(String&& s) { return mv(s); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "value.as<bool>() == (ordinal % 2 == 0)"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "value.as<uint16_t>() == ordinal * 13"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "value.as<int8_t>() == int(ordinal % 256) - 128"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "ordinal % 256"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "Pipeline",
          "container": "AnyPointer::Pipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "243-243",
          "snippet": "inline explicit Pipeline(kj::Own<PipelineHook>&& hook): hook(kj::mv(hook)) {}",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Pipeline {\n    inline explicit Pipeline(kj::Own<PipelineHook>&& hook): hook(kj::mv(hook)) {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "value.as<double>() == ordinal * 313.25"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "value.as<int32_t>() == ordinal * 47327"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nvoid checkExampleValue(DynamicValue::Reader value, uint ordinal, schema::Type::Reader type,\n                       uint sharedOrdinalCount) {\n  switch (type.which()) {\n    case schema::Type::INT32: KJ_ASSERT(value.as<int32_t>() == ordinal * 47327); break;\n    case schema::Type::FLOAT64: KJ_ASSERT(value.as<double>() == ordinal * 313.25); break;\n    case schema::Type::INT8: KJ_ASSERT(value.as<int8_t>() == int(ordinal % 256) - 128); break;\n    case schema::Type::UINT16: KJ_ASSERT(value.as<uint16_t>() == ordinal * 13); break;\n    case schema::Type::BOOL: KJ_ASSERT(value.as<bool>() == (ordinal % 2 == 0)); break;\n    case schema::Type::TEXT: KJ_ASSERT(value.as<Text>() == kj::str(ordinal)); break;\n    case schema::Type::STRUCT: {\n      auto structValue = value.as<DynamicStruct>();\n      auto structType = structValue.getSchema();\n\n      KJ_IF_MAYBE(fieldI, structType.findFieldByName(\"i\")) {\n        // Type is \"StructType\"\n        KJ_ASSERT(structValue.get(*fieldI).as<uint32_t>() == ordinal);\n      } else {\n        // Type is \"Int32Struct\" or the like.\n        auto field = structType.getFieldByName(\"f0\");\n        checkExampleValue(structValue.get(field), ordinal,\n                          field.getProto().getSlot().getType(), sharedOrdinalCount);\n      }\n      break;\n    }\n    case schema::Type::ENUM: {\n      auto enumerant = KJ_ASSERT_NONNULL(value.as<DynamicEnum>().getEnumerant());\n      KJ_ASSERT(enumerant.getIndex() ==\n          ordinal % enumerant.getContainingEnum().getEnumerants().size());\n      break;\n    }\n    case schema::Type::LIST:\n      checkExampleValue(value.as<DynamicList>()[0], ordinal, type.getList().getElementType(),\n                        sharedOrdinalCount);\n      break;\n    default:\n      KJ_FAIL_ASSERT(\"You added a new possible field type!\");\n  }"
  },
  {
    "function_name": "makeExampleValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "467-507",
    "snippet": "Orphan<DynamicValue> makeExampleValue(\n    Orphanage orphanage, uint ordinal, Type type, uint sharedOrdinalCount) {\n  switch (type.which()) {\n    case schema::Type::INT32: return ordinal * 47327;\n    case schema::Type::FLOAT64: return ordinal * 313.25;\n    case schema::Type::INT8: return int(ordinal % 256) - 128;\n    case schema::Type::UINT16: return ordinal * 13;\n    case schema::Type::BOOL: return ordinal % 2 == 0;\n    case schema::Type::TEXT: return orphanage.newOrphanCopy(Text::Reader(kj::str(ordinal)));\n    case schema::Type::STRUCT: {\n      auto structType = type.asStruct();\n      auto result = orphanage.newOrphan(structType);\n      auto builder = result.get();\n\n      KJ_IF_MAYBE(fieldI, structType.findFieldByName(\"i\")) {\n        // Type is \"StructType\"\n        builder.set(*fieldI, ordinal);\n      } else {\n        // Type is \"Int32Struct\" or the like.\n        auto field = structType.getFieldByName(\"f0\");\n        builder.adopt(field, makeExampleValue(\n            orphanage, ordinal, field.getType(), sharedOrdinalCount));\n      }\n\n      return kj::mv(result);\n    }\n    case schema::Type::ENUM: {\n      auto enumerants = type.asEnum().getEnumerants();\n      return DynamicEnum(enumerants[ordinal %enumerants.size()]);\n    }\n    case schema::Type::LIST: {\n      auto listType = type.asList();\n      auto elementType = listType.getElementType();\n      auto result = orphanage.newOrphan(listType, 1);\n      result.get().adopt(0, makeExampleValue(\n          orphanage, ordinal, elementType, sharedOrdinalCount));\n      return kj::mv(result);\n    }\n    default:\n      KJ_FAIL_ASSERT(\"You added a new possible field type!\");\n  }",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"You added a new possible field type!\""
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.get",
          "args": [
            "0",
            "makeExampleValue(\n          orphanage, ordinal, elementType, sharedOrdinalCount)"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.get",
          "args": [],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan",
          "args": [
            "listType",
            "1"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listType.getElementType",
          "args": [],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.asList",
          "args": [],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DynamicEnum",
          "args": [
            "enumerants[ordinal %enumerants.size()]"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "DynamicEnum",
          "container": "DynamicEnum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "136-136",
          "snippet": "inline DynamicEnum(T&& value): DynamicEnum(toDynamic(value)) {}",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\nDynamicEnum {\n  inline DynamicEnum(T&& value): DynamicEnum(toDynamic(value)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "enumerants.size",
          "args": [],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type.asEnum",
          "args": [],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.asEnum",
          "args": [],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.adopt",
          "args": [
            "field",
            "makeExampleValue(\n            orphanage, ordinal, field.getType(), sharedOrdinalCount)"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "adopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "828-830",
          "snippet": "static inline void adopt(PointerBuilder builder, Orphan<AnyPointer>&& value) {\n    builder.adopt(kj::mv(value.builder));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void adopt(PointerBuilder builder, Orphan<AnyPointer>&& value) {\n    builder.adopt(kj::mv(value.builder));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "field.getType",
          "args": [],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "structType.getFieldByName",
          "args": [
            "\"f0\""
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.set",
          "args": [
            "*fieldI",
            "ordinal"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "872-874",
          "snippet": "static inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "fieldI",
            "structType.findFieldByName(\"i\")"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "structType.findFieldByName",
          "args": [
            "\"i\""
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan",
          "args": [
            "structType"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.asStruct",
          "args": [],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphanCopy",
          "args": [
            "Text::Reader(kj::str(ordinal))"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Text::Reader",
          "args": [
            "kj::str(ordinal)"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "Reader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/grammar.capnp.h",
          "lines": "3113-3113",
          "snippet": "inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline explicit Reader(::capnp::_::StructReader base): _reader(base) {}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "ordinal"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "341-341",
          "snippet": "inline String str(String&& s) { return mv(s); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
        }
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "ordinal % 256"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "Pipeline",
          "container": "AnyPointer::Pipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "243-243",
          "snippet": "inline explicit Pipeline(kj::Own<PipelineHook>&& hook): hook(kj::mv(hook)) {}",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Pipeline {\n    inline explicit Pipeline(kj::Own<PipelineHook>&& hook): hook(kj::mv(hook)) {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nOrphan<DynamicValue> makeExampleValue(\n    Orphanage orphanage, uint ordinal, Type type, uint sharedOrdinalCount) {\n  switch (type.which()) {\n    case schema::Type::INT32: return ordinal * 47327;\n    case schema::Type::FLOAT64: return ordinal * 313.25;\n    case schema::Type::INT8: return int(ordinal % 256) - 128;\n    case schema::Type::UINT16: return ordinal * 13;\n    case schema::Type::BOOL: return ordinal % 2 == 0;\n    case schema::Type::TEXT: return orphanage.newOrphanCopy(Text::Reader(kj::str(ordinal)));\n    case schema::Type::STRUCT: {\n      auto structType = type.asStruct();\n      auto result = orphanage.newOrphan(structType);\n      auto builder = result.get();\n\n      KJ_IF_MAYBE(fieldI, structType.findFieldByName(\"i\")) {\n        // Type is \"StructType\"\n        builder.set(*fieldI, ordinal);\n      } else {\n        // Type is \"Int32Struct\" or the like.\n        auto field = structType.getFieldByName(\"f0\");\n        builder.adopt(field, makeExampleValue(\n            orphanage, ordinal, field.getType(), sharedOrdinalCount));\n      }\n\n      return kj::mv(result);\n    }\n    case schema::Type::ENUM: {\n      auto enumerants = type.asEnum().getEnumerants();\n      return DynamicEnum(enumerants[ordinal %enumerants.size()]);\n    }\n    case schema::Type::LIST: {\n      auto listType = type.asList();\n      auto elementType = listType.getElementType();\n      auto result = orphanage.newOrphan(listType, 1);\n      result.get().adopt(0, makeExampleValue(\n          orphanage, ordinal, elementType, sharedOrdinalCount));\n      return kj::mv(result);\n    }\n    default:\n      KJ_FAIL_ASSERT(\"You added a new possible field type!\");\n  }"
  },
  {
    "function_name": "getOrdinal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "451-461",
    "snippet": "uint getOrdinal(StructSchema::Field field) {\n  auto proto = field.getProto();\n  if (proto.getOrdinal().isExplicit()) {\n    return proto.getOrdinal().getExplicit();\n  }\n\n  KJ_ASSERT(proto.isGroup());\n\n  auto group = field.getType().asStruct();\n  return getOrdinal(group.getFields()[0]);\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "group.getFields",
          "args": [],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getType",
          "args": [],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "proto.isGroup()"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.isGroup",
          "args": [],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getOrdinal",
          "args": [],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "getOrdinal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "486-486",
          "snippet": "inline uint16_t getOrdinal() const { return ordinal; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline uint16_t getOrdinal() const { return ordinal; }"
        }
      },
      {
        "call_info": {
          "callee": "field.getProto",
          "args": [],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nuint getOrdinal(StructSchema::Field field) {\n  auto proto = field.getProto();\n  if (proto.getOrdinal().isExplicit()) {\n    return proto.getOrdinal().getExplicit();\n  }\n\n  KJ_ASSERT(proto.isGroup());\n\n  auto group = field.getType().asStruct();\n  return getOrdinal(group.getFields()[0]);\n}"
  },
  {
    "function_name": "fieldChangeType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "380-438",
    "snippet": "static ChangeInfo fieldChangeType(Declaration::Builder decl, uint& nextOrdinal,\n                                  bool scopeHasUnion) {\n  auto field = decl.getField();\n\n  if (field.getDefaultValue().isNone()) {\n    // Change the type.\n    auto type = field.getType();\n    while (type.isApplication()) {\n      // Either change the list parameter, or revert to a non-list.\n      if (rand() % 2) {\n        type = type.getApplication().getParams()[0].getValue();\n      } else {\n        type.initRelativeName();\n      }\n    }\n    auto typeName = type.getRelativeName();\n    if (typeName.asReader().getValue().startsWith(\"Text\")) {\n      typeName.setValue(\"Int32\");\n    } else {\n      typeName.setValue(\"Text\");\n    }\n    return { INCOMPATIBLE, \"Change the type of a field.\" };\n  } else {\n    // Change the default value.\n    auto dval = field.getDefaultValue().getValue();\n    switch (dval.which()) {\n      case Expression::UNKNOWN: KJ_FAIL_ASSERT(\"unknown value expression?\");\n      case Expression::POSITIVE_INT: dval.setPositiveInt(dval.getPositiveInt() ^ 1); break;\n      case Expression::NEGATIVE_INT: dval.setNegativeInt(dval.getNegativeInt() ^ 1); break;\n      case Expression::FLOAT: dval.setFloat(-dval.getFloat()); break;\n      case Expression::RELATIVE_NAME: {\n        auto name = dval.getRelativeName();\n        auto nameText = name.asReader().getValue();\n        if (nameText == \"true\") {\n          name.setValue(\"false\");\n        } else if (nameText == \"false\") {\n          name.setValue(\"true\");\n        } else if (nameText == \"foo\") {\n          name.setValue(\"bar\");\n        } else {\n          name.setValue(\"foo\");\n        }\n        break;\n      }\n      case Expression::STRING:\n      case Expression::BINARY:\n      case Expression::LIST:\n      case Expression::TUPLE:\n        return { NO_CHANGE, \"Change the default value of a field, but it's a pointer field.\" };\n\n      case Expression::ABSOLUTE_NAME:\n      case Expression::IMPORT:\n      case Expression::APPLICATION:\n      case Expression::MEMBER:\n        KJ_FAIL_ASSERT(\"Unexpected expression type.\");\n    }\n    return { INCOMPATIBLE, \"Change the default value of a pritimive field.\" };\n  }\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Unexpected expression type.\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.setValue",
          "args": [
            "\"foo\""
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.setValue",
          "args": [
            "\"bar\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.setValue",
          "args": [
            "\"true\""
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.setValue",
          "args": [
            "\"false\""
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.asReader",
          "args": [],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "asReader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/grammar.capnp.h",
          "lines": "3149-3149",
          "snippet": "inline Reader asReader() const { return *this; }",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline Reader asReader() const { return *this; }"
        }
      },
      {
        "call_info": {
          "callee": "dval.getRelativeName",
          "args": [],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dval.setFloat",
          "args": [
            "-dval.getFloat()"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dval.getFloat",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dval.setNegativeInt",
          "args": [
            "dval.getNegativeInt() ^ 1"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dval.getNegativeInt",
          "args": [],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dval.setPositiveInt",
          "args": [
            "dval.getPositiveInt() ^ 1"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dval.getPositiveInt",
          "args": [],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"unknown value expression?\""
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dval.which",
          "args": [],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getDefaultValue",
          "args": [],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getDefaultValue",
          "args": [],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeName.setValue",
          "args": [
            "\"Text\""
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeName.setValue",
          "args": [
            "\"Int32\""
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeName.asReader",
          "args": [
            "\"Text\""
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getRelativeName",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.initRelativeName",
          "args": [],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getApplication",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getApplication",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getApplication",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rand",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "Annotation::Builder::disownBrand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.capnp.h",
          "lines": "7365-7368",
          "snippet": "inline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {\n  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(\n      _builder.getPointerField(1 * ::capnp::POINTERS));\n}",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {\n  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(\n      _builder.getPointerField(1 * ::capnp::POINTERS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "type.isApplication",
          "args": [],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getType",
          "args": [],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "field.getDefaultValue",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getDefaultValue",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getField",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nstatic ChangeInfo fieldChangeType(Declaration::Builder decl, uint& nextOrdinal,\n                                  bool scopeHasUnion) {\n  auto field = decl.getField();\n\n  if (field.getDefaultValue().isNone()) {\n    // Change the type.\n    auto type = field.getType();\n    while (type.isApplication()) {\n      // Either change the list parameter, or revert to a non-list.\n      if (rand() % 2) {\n        type = type.getApplication().getParams()[0].getValue();\n      } else {\n        type.initRelativeName();\n      }\n    }\n    auto typeName = type.getRelativeName();\n    if (typeName.asReader().getValue().startsWith(\"Text\")) {\n      typeName.setValue(\"Int32\");\n    } else {\n      typeName.setValue(\"Text\");\n    }\n    return { INCOMPATIBLE, \"Change the type of a field.\" };\n  } else {\n    // Change the default value.\n    auto dval = field.getDefaultValue().getValue();\n    switch (dval.which()) {\n      case Expression::UNKNOWN: KJ_FAIL_ASSERT(\"unknown value expression?\");\n      case Expression::POSITIVE_INT: dval.setPositiveInt(dval.getPositiveInt() ^ 1); break;\n      case Expression::NEGATIVE_INT: dval.setNegativeInt(dval.getNegativeInt() ^ 1); break;\n      case Expression::FLOAT: dval.setFloat(-dval.getFloat()); break;\n      case Expression::RELATIVE_NAME: {\n        auto name = dval.getRelativeName();\n        auto nameText = name.asReader().getValue();\n        if (nameText == \"true\") {\n          name.setValue(\"false\");\n        } else if (nameText == \"false\") {\n          name.setValue(\"true\");\n        } else if (nameText == \"foo\") {\n          name.setValue(\"bar\");\n        } else {\n          name.setValue(\"foo\");\n        }\n        break;\n      }\n      case Expression::STRING:\n      case Expression::BINARY:\n      case Expression::LIST:\n      case Expression::TUPLE:\n        return { NO_CHANGE, \"Change the default value of a field, but it's a pointer field.\" };\n\n      case Expression::ABSOLUTE_NAME:\n      case Expression::IMPORT:\n      case Expression::APPLICATION:\n      case Expression::MEMBER:\n        KJ_FAIL_ASSERT(\"Unexpected expression type.\");\n    }\n    return { INCOMPATIBLE, \"Change the default value of a pritimive field.\" };\n  }\n}"
  },
  {
    "function_name": "fieldExpandGroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "347-378",
    "snippet": "static ChangeInfo fieldExpandGroup(Declaration::Builder decl, uint& nextOrdinal,\n                                   bool scopeHasUnion) {\n  Declaration::Builder newDecl = decl.initNestedDecls(1)[0];\n  newDecl.adoptName(decl.disownName());\n  newDecl.getId().adoptOrdinal(decl.getId().disownOrdinal());\n\n  auto field = decl.getField();\n  auto newField = newDecl.initField();\n\n  newField.adoptType(field.disownType());\n  if (field.getDefaultValue().isValue()) {\n    newField.getDefaultValue().adoptValue(field.getDefaultValue().disownValue());\n  } else {\n    newField.getDefaultValue().setNone();\n  }\n\n  decl.initName().setValue(kj::str(\"g\", newDecl.getName().getValue()));\n  decl.getId().setUnspecified();\n\n  if (rand() % 2 == 0) {\n    decl.setGroup();\n  } else {\n    decl.setUnion();\n    if (!scopeHasUnion && rand() % 2 == 0) {\n      // Make it an unnamed union.\n      decl.getName().setValue(\"\");\n    }\n    structAddField(decl, nextOrdinal, scopeHasUnion);  // union must have two members\n  }\n\n  return { COMPATIBLE, \"Wrap a field in a singleton group.\" };\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "structAddField",
          "args": [
            "decl",
            "nextOrdinal",
            "scopeHasUnion"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "structAddField",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "176-193",
          "snippet": "static ChangeInfo structAddField(Declaration::Builder decl, uint& nextOrdinal, bool scopeHasUnion) {\n  auto fieldDecl = addNested(decl);\n\n  uint ordinal = nextOrdinal++;\n\n  fieldDecl.initName().setValue(kj::str(\"f\", ordinal));\n  fieldDecl.getId().initOrdinal().setValue(ordinal);\n\n  auto field = fieldDecl.initField();\n\n  auto makeValue = randomizeType(field.initType());\n  if (rand() % 4 == 0) {\n    makeValue(field.getDefaultValue().initValue());\n  } else {\n    field.getDefaultValue().setNone();\n  }\n  return { COMPATIBLE, \"Add field.\" };\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nstatic ChangeInfo structAddField(Declaration::Builder decl, uint& nextOrdinal, bool scopeHasUnion) {\n  auto fieldDecl = addNested(decl);\n\n  uint ordinal = nextOrdinal++;\n\n  fieldDecl.initName().setValue(kj::str(\"f\", ordinal));\n  fieldDecl.getId().initOrdinal().setValue(ordinal);\n\n  auto field = fieldDecl.initField();\n\n  auto makeValue = randomizeType(field.initType());\n  if (rand() % 4 == 0) {\n    makeValue(field.getDefaultValue().initValue());\n  } else {\n    field.getDefaultValue().setNone();\n  }\n  return { COMPATIBLE, \"Add field.\" };\n}"
        }
      },
      {
        "call_info": {
          "callee": "decl.getName",
          "args": [
            "\"\""
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getName",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rand",
          "args": [],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "Annotation::Builder::disownBrand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.capnp.h",
          "lines": "7365-7368",
          "snippet": "inline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {\n  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(\n      _builder.getPointerField(1 * ::capnp::POINTERS));\n}",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {\n  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(\n      _builder.getPointerField(1 * ::capnp::POINTERS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "decl.setUnion",
          "args": [],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.setGroup",
          "args": [],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getId",
          "args": [],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "decl.initName",
          "args": [
            "kj::str(\"g\", newDecl.getName().getValue())"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"g\"",
            "newDecl.getName().getValue()"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newDecl.getName",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newDecl.getName",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.initName",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newField.getDefaultValue",
          "args": [],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newField.getDefaultValue",
          "args": [],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newField.getDefaultValue",
          "args": [
            "field.getDefaultValue().disownValue()"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getDefaultValue",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getDefaultValue",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newField.getDefaultValue",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getDefaultValue",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getDefaultValue",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newField.adoptType",
          "args": [
            "field.disownType()"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.disownType",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newDecl.initField",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getField",
          "args": [],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newDecl.getId",
          "args": [
            "decl.getId().disownOrdinal()"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newDecl.adoptName",
          "args": [
            "decl.disownName()"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.disownName",
          "args": [],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.initNestedDecls",
          "args": [
            "1"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nstatic ChangeInfo fieldExpandGroup(Declaration::Builder decl, uint& nextOrdinal,\n                                   bool scopeHasUnion) {\n  Declaration::Builder newDecl = decl.initNestedDecls(1)[0];\n  newDecl.adoptName(decl.disownName());\n  newDecl.getId().adoptOrdinal(decl.getId().disownOrdinal());\n\n  auto field = decl.getField();\n  auto newField = newDecl.initField();\n\n  newField.adoptType(field.disownType());\n  if (field.getDefaultValue().isValue()) {\n    newField.getDefaultValue().adoptValue(field.getDefaultValue().disownValue());\n  } else {\n    newField.getDefaultValue().setNone();\n  }\n\n  decl.initName().setValue(kj::str(\"g\", newDecl.getName().getValue()));\n  decl.getId().setUnspecified();\n\n  if (rand() % 2 == 0) {\n    decl.setGroup();\n  } else {\n    decl.setUnion();\n    if (!scopeHasUnion && rand() % 2 == 0) {\n      // Make it an unnamed union.\n      decl.getName().setValue(\"\");\n    }\n    structAddField(decl, nextOrdinal, scopeHasUnion);  // union must have two members\n  }\n\n  return { COMPATIBLE, \"Wrap a field in a singleton group.\" };\n}"
  },
  {
    "function_name": "fieldUpgradeList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "318-345",
    "snippet": "static ChangeInfo fieldUpgradeList(Declaration::Builder decl, uint& nextOrdinal,\n                                   bool scopeHasUnion) {\n  // Upgrades a non-struct list to a struct list.\n\n  auto field = decl.getField();\n  if (field.getDefaultValue().isValue()) {\n    return { NO_CHANGE, \"Upgrade primitive list to struct list, but it had a default value.\" };\n  }\n\n  auto type = field.getType();\n  if (!type.isApplication()) {\n    return { NO_CHANGE, \"Upgrade primitive list to struct list, but it wasn't a list.\" };\n  }\n  auto typeParams = type.getApplication().getParams();\n\n  auto elementType = typeParams[0].getValue();\n  auto relativeName = elementType.getRelativeName();\n  auto nameText = relativeName.asReader().getValue();\n  if (nameText == \"StructType\" || nameText.endsWith(\"Struct\")) {\n    return { NO_CHANGE, \"Upgrade primitive list to struct list, but it was already a struct list.\"};\n  }\n  if (nameText == \"Bool\") {\n    return { NO_CHANGE, \"Upgrade primitive list to struct list, but bool lists can't be upgraded.\"};\n  }\n\n  relativeName.setValue(kj::str(nameText, \"Struct\"));\n  return { COMPATIBLE, \"Upgrade primitive list to struct list\" };\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "relativeName.setValue",
          "args": [
            "kj::str(nameText, \"Struct\")"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "nameText",
            "\"Struct\""
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nameText.endsWith",
          "args": [
            "\"Struct\""
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "endsWith",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "175-175",
          "snippet": "inline bool endsWith(const StringPtr& other) const { return StringPtr(*this).endsWith(other); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline bool endsWith(const StringPtr& other) const { return StringPtr(*this).endsWith(other); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "relativeName.asReader",
          "args": [],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "asReader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/grammar.capnp.h",
          "lines": "3149-3149",
          "snippet": "inline Reader asReader() const { return *this; }",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline Reader asReader() const { return *this; }"
        }
      },
      {
        "call_info": {
          "callee": "elementType.getRelativeName",
          "args": [],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeParams[0].getValue",
          "args": [],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getApplication",
          "args": [],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getApplication",
          "args": [],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.isApplication",
          "args": [],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getType",
          "args": [],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "field.getDefaultValue",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getDefaultValue",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getField",
          "args": [],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nstatic ChangeInfo fieldUpgradeList(Declaration::Builder decl, uint& nextOrdinal,\n                                   bool scopeHasUnion) {\n  // Upgrades a non-struct list to a struct list.\n\n  auto field = decl.getField();\n  if (field.getDefaultValue().isValue()) {\n    return { NO_CHANGE, \"Upgrade primitive list to struct list, but it had a default value.\" };\n  }\n\n  auto type = field.getType();\n  if (!type.isApplication()) {\n    return { NO_CHANGE, \"Upgrade primitive list to struct list, but it wasn't a list.\" };\n  }\n  auto typeParams = type.getApplication().getParams();\n\n  auto elementType = typeParams[0].getValue();\n  auto relativeName = elementType.getRelativeName();\n  auto nameText = relativeName.asReader().getValue();\n  if (nameText == \"StructType\" || nameText.endsWith(\"Struct\")) {\n    return { NO_CHANGE, \"Upgrade primitive list to struct list, but it was already a struct list.\"};\n  }\n  if (nameText == \"Bool\") {\n    return { NO_CHANGE, \"Upgrade primitive list to struct list, but bool lists can't be upgraded.\"};\n  }\n\n  relativeName.setValue(kj::str(nameText, \"Struct\"));\n  return { COMPATIBLE, \"Upgrade primitive list to struct list\" };\n}"
  },
  {
    "function_name": "structPermuteFields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "273-300",
    "snippet": "static ChangeInfo structPermuteFields(\n    Declaration::Builder decl, uint& nextOrdinal, bool scopeHasUnion) {\n  if (decl.getNestedDecls().size() == 0) {\n    return { NO_CHANGE, \"Permute field code order, but there were none.\" };\n  }\n\n  auto oldOrphan = decl.disownNestedDecls();\n  auto old = oldOrphan.get();\n\n  KJ_STACK_ARRAY(uint, mapping, old.size(), 16, 64);\n\n  for (uint i = 0; i < mapping.size(); i++) {\n    mapping[i] = i;\n  }\n  for (uint i = mapping.size() - 1; i > 0; i--) {\n    uint j = rand() % i;\n    uint temp = mapping[j];\n    mapping[j] = mapping[i];\n    mapping[i] = temp;\n  }\n\n  auto newNested = decl.initNestedDecls(old.size());\n  for (uint i = 0; i < old.size(); i++) {\n    newNested.setWithCaveats(i, old[mapping[i]]);\n  }\n\n  return { COMPATIBLE, \"Permute field code order.\" };\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "newNested.setWithCaveats",
          "args": [
            "i",
            "old[mapping[i]]"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "setWithCaveats",
          "container": "Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/list.h",
          "lines": "269-278",
          "snippet": "inline void setWithCaveats(uint index, const typename T::Reader& reader) {\n      // Mostly behaves like you'd expect `set` to behave, but with a caveat originating from\n      // the fact that structs in a struct list are allocated inline rather than by pointer:\n      // If the source struct is larger than the target struct -- say, because the source was built\n      // using a newer version of the schema that has additional fields -- it will be truncated,\n      // losing data.\n\n      KJ_IREQUIRE(index < size());\n      builder.getStructElement(index * ELEMENTS).copyContentFrom(reader._reader);\n    }",
          "includes": [
            "#include <iterator>",
            "#include <initializer_list>",
            "#include \"orphan.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <initializer_list>\n#include \"orphan.h\"\n#include \"layout.h\"\n\nBuilder {\n  inline void setWithCaveats(uint index, const typename T::Reader& reader) {\n        // Mostly behaves like you'd expect `set` to behave, but with a caveat originating from\n        // the fact that structs in a struct list are allocated inline rather than by pointer:\n        // If the source struct is larger than the target struct -- say, because the source was built\n        // using a newer version of the schema that has additional fields -- it will be truncated,\n        // losing data.\n  \n        KJ_IREQUIRE(index < size());\n        builder.getStructElement(index * ELEMENTS).copyContentFrom(reader._reader);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "old.size",
          "args": [],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "decl.initNestedDecls",
          "args": [
            "old.size()"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rand",
          "args": [],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "Annotation::Builder::disownBrand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.capnp.h",
          "lines": "7365-7368",
          "snippet": "inline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {\n  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(\n      _builder.getPointerField(1 * ::capnp::POINTERS));\n}",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {\n  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(\n      _builder.getPointerField(1 * ::capnp::POINTERS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_STACK_ARRAY",
          "args": [
            "uint",
            "mapping",
            "old.size()",
            "16",
            "64"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oldOrphan.get",
          "args": [],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "decl.disownNestedDecls",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getNestedDecls",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getNestedDecls",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nstatic ChangeInfo structPermuteFields(\n    Declaration::Builder decl, uint& nextOrdinal, bool scopeHasUnion) {\n  if (decl.getNestedDecls().size() == 0) {\n    return { NO_CHANGE, \"Permute field code order, but there were none.\" };\n  }\n\n  auto oldOrphan = decl.disownNestedDecls();\n  auto old = oldOrphan.get();\n\n  KJ_STACK_ARRAY(uint, mapping, old.size(), 16, 64);\n\n  for (uint i = 0; i < mapping.size(); i++) {\n    mapping[i] = i;\n  }\n  for (uint i = mapping.size() - 1; i > 0; i--) {\n    uint j = rand() % i;\n    uint temp = mapping[j];\n    mapping[j] = mapping[i];\n    mapping[i] = temp;\n  }\n\n  auto newNested = decl.initNestedDecls(old.size());\n  for (uint i = 0; i < old.size(); i++) {\n    newNested.setWithCaveats(i, old[mapping[i]]);\n  }\n\n  return { COMPATIBLE, \"Permute field code order.\" };\n}"
  },
  {
    "function_name": "structGroupifyFields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "224-271",
    "snippet": "static ChangeInfo structGroupifyFields(\n    Declaration::Builder decl, uint& nextOrdinal, bool scopeHasUnion) {\n  // Place a random subset of the fields into a group.\n\n  if (decl.isUnion()) {\n    return { NO_CHANGE,\n      \"Randomly make a group out of some fields, but I can't do this to a union.\" };\n  }\n\n  kj::Vector<Orphan<Declaration>> groupified;\n  kj::Vector<Orphan<Declaration>> notGroupified;\n  auto orphanage = Orphanage::getForMessageContaining(decl);\n\n  for (auto nested: decl.getNestedDecls()) {\n    if (rand() % 2) {\n      groupified.add(orphanage.newOrphanCopy(nested.asReader()));\n    } else {\n      notGroupified.add(orphanage.newOrphanCopy(nested.asReader()));\n    }\n  }\n\n  if (groupified.size() == 0) {\n    return { NO_CHANGE,\n      \"Randomly make a group out of some fields, but I ended up choosing none of them.\" };\n  }\n\n  auto newNested = decl.initNestedDecls(notGroupified.size() + 1);\n  uint index = rand() % (notGroupified.size() + 1);\n\n  for (uint i = 0; i < index; i++) {\n    newNested.adoptWithCaveats(i, kj::mv(notGroupified[i]));\n  }\n  for (uint i = index; i < notGroupified.size(); i++) {\n    newNested.adoptWithCaveats(i + 1, kj::mv(notGroupified[i]));\n  }\n\n  auto newGroup = newNested[index];\n  auto groupNested = newGroup.initNestedDecls(groupified.size());\n  for (uint i = 0; i < groupified.size(); i++) {\n    groupNested.adoptWithCaveats(i, kj::mv(groupified[i]));\n  }\n\n  newGroup.initName().setValue(kj::str(\"g\", nextOrdinal, \"x\", groupNested[0].getName().getValue()));\n  newGroup.getId().setUnspecified();\n  newGroup.setGroup();\n\n  return { SUBTLY_COMPATIBLE, \"Randomly group some set of existing fields.\" };\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "newGroup.setGroup",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newGroup.getId",
          "args": [],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "newGroup.initName",
          "args": [
            "kj::str(\"g\", nextOrdinal, \"x\", groupNested[0].getName().getValue())"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"g\"",
            "nextOrdinal",
            "\"x\"",
            "groupNested[0].getName().getValue()"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "groupNested[0].getName",
          "args": [],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "groupNested[0].getName",
          "args": [],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newGroup.initName",
          "args": [],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "groupNested.adoptWithCaveats",
          "args": [
            "i",
            "kj::mv(groupified[i])"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "adoptWithCaveats",
          "container": "Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/list.h",
          "lines": "251-268",
          "snippet": "inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n      // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n      // the fact that structs in a struct list are allocated inline rather than by pointer:\n      // * This actually performs a shallow copy, effectively adopting each of the orphan's\n      //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n      //   possibly wasting space in the message object.\n      // * If the orphan is larger than the target struct -- say, because the orphan was built\n      //   using a newer version of the schema that has additional fields -- it will be truncated,\n      //   losing data.\n\n      KJ_IREQUIRE(index < size());\n\n      // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n      // expanded under any circumstances.  We're just going to throw it away anyway, and\n      // transferContentFrom() already carefully compares the struct sizes before transferring.\n      builder.getStructElement(index * ELEMENTS).transferContentFrom(\n          orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n    }",
          "includes": [
            "#include <iterator>",
            "#include <initializer_list>",
            "#include \"orphan.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <initializer_list>\n#include \"orphan.h\"\n#include \"layout.h\"\n\nBuilder {\n  inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n        // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n        // the fact that structs in a struct list are allocated inline rather than by pointer:\n        // * This actually performs a shallow copy, effectively adopting each of the orphan's\n        //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n        //   possibly wasting space in the message object.\n        // * If the orphan is larger than the target struct -- say, because the orphan was built\n        //   using a newer version of the schema that has additional fields -- it will be truncated,\n        //   losing data.\n  \n        KJ_IREQUIRE(index < size());\n  \n        // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n        // expanded under any circumstances.  We're just going to throw it away anyway, and\n        // transferContentFrom() already carefully compares the struct sizes before transferring.\n        builder.getStructElement(index * ELEMENTS).transferContentFrom(\n            orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "groupified[i]"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "groupified.size",
          "args": [],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "newGroup.initNestedDecls",
          "args": [
            "groupified.size()"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "notGroupified[i]"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "notGroupified[i]"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rand",
          "args": [],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "Annotation::Builder::disownBrand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.capnp.h",
          "lines": "7365-7368",
          "snippet": "inline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {\n  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(\n      _builder.getPointerField(1 * ::capnp::POINTERS));\n}",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {\n  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(\n      _builder.getPointerField(1 * ::capnp::POINTERS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "decl.initNestedDecls",
          "args": [
            "notGroupified.size() + 1"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notGroupified.add",
          "args": [
            "orphanage.newOrphanCopy(nested.asReader())"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphanCopy",
          "args": [
            "nested.asReader()"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested.asReader",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "asReader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/grammar.capnp.h",
          "lines": "3149-3149",
          "snippet": "inline Reader asReader() const { return *this; }",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline Reader asReader() const { return *this; }"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphanCopy",
          "args": [
            "nested.asReader()"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getNestedDecls",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Orphanage::getForMessageContaining",
          "args": [
            "decl"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "Orphanage::getForMessageContaining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/orphan.h",
          "lines": "279-281",
          "snippet": "Orphanage Orphanage::getForMessageContaining(BuilderType builder) {\n  return Orphanage(GetInnerBuilder<FromBuilder<BuilderType>>::apply(builder).getArena());\n}",
          "includes": [
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n\nOrphanage Orphanage::getForMessageContaining(BuilderType builder) {\n  return Orphanage(GetInnerBuilder<FromBuilder<BuilderType>>::apply(builder).getArena());\n}"
        }
      },
      {
        "call_info": {
          "callee": "decl.isUnion",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nstatic ChangeInfo structGroupifyFields(\n    Declaration::Builder decl, uint& nextOrdinal, bool scopeHasUnion) {\n  // Place a random subset of the fields into a group.\n\n  if (decl.isUnion()) {\n    return { NO_CHANGE,\n      \"Randomly make a group out of some fields, but I can't do this to a union.\" };\n  }\n\n  kj::Vector<Orphan<Declaration>> groupified;\n  kj::Vector<Orphan<Declaration>> notGroupified;\n  auto orphanage = Orphanage::getForMessageContaining(decl);\n\n  for (auto nested: decl.getNestedDecls()) {\n    if (rand() % 2) {\n      groupified.add(orphanage.newOrphanCopy(nested.asReader()));\n    } else {\n      notGroupified.add(orphanage.newOrphanCopy(nested.asReader()));\n    }\n  }\n\n  if (groupified.size() == 0) {\n    return { NO_CHANGE,\n      \"Randomly make a group out of some fields, but I ended up choosing none of them.\" };\n  }\n\n  auto newNested = decl.initNestedDecls(notGroupified.size() + 1);\n  uint index = rand() % (notGroupified.size() + 1);\n\n  for (uint i = 0; i < index; i++) {\n    newNested.adoptWithCaveats(i, kj::mv(notGroupified[i]));\n  }\n  for (uint i = index; i < notGroupified.size(); i++) {\n    newNested.adoptWithCaveats(i + 1, kj::mv(notGroupified[i]));\n  }\n\n  auto newGroup = newNested[index];\n  auto groupNested = newGroup.initNestedDecls(groupified.size());\n  for (uint i = 0; i < groupified.size(); i++) {\n    groupNested.adoptWithCaveats(i, kj::mv(groupified[i]));\n  }\n\n  newGroup.initName().setValue(kj::str(\"g\", nextOrdinal, \"x\", groupNested[0].getName().getValue()));\n  newGroup.getId().setUnspecified();\n  newGroup.setGroup();\n\n  return { SUBTLY_COMPATIBLE, \"Randomly group some set of existing fields.\" };\n}"
  },
  {
    "function_name": "structModifyField",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "195-222",
    "snippet": "static ChangeInfo structModifyField(Declaration::Builder decl, uint& nextOrdinal,\n                                    bool scopeHasUnion) {\n  auto nested = decl.getNestedDecls();\n\n  if (nested.size() == 0) {\n    return { NO_CHANGE, \"Modify field, but there were none to modify.\" };\n  }\n\n  auto field = chooseFrom(nested);\n\n  bool hasUnion = false;\n  if (decl.isUnion()) {\n    hasUnion = true;\n  } else {\n    for (auto n: nested) {\n      if (n.isUnion() && n.getName().getValue().size() == 0) {\n        hasUnion = true;\n        break;\n      }\n    }\n  }\n\n  if (field.isGroup() || field.isUnion()) {\n    return chooseFrom(STRUCT_MODS)(field, nextOrdinal, hasUnion);\n  } else {\n    return chooseFrom(FIELD_MODS)(field, nextOrdinal, hasUnion);\n  }\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chooseFrom",
          "args": [
            "field",
            "nextOrdinal",
            "hasUnion"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chooseFrom",
          "args": [
            "FIELD_MODS"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "chooseFrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "53-55",
          "snippet": "auto chooseFrom(T arr) -> decltype(arr[0]) {\n  return arr[rand() % arr.size()];\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nauto chooseFrom(T arr) -> decltype(arr[0]) {\n  return arr[rand() % arr.size()];\n}"
        }
      },
      {
        "call_info": {
          "callee": "chooseFrom",
          "args": [
            "field",
            "nextOrdinal",
            "hasUnion"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.isUnion",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.isGroup",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n.getName",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n.getName",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n.getName",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n.isUnion",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.isUnion",
          "args": [],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested.size",
          "args": [],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "decl.getNestedDecls",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nstatic ChangeInfo structModifyField(Declaration::Builder decl, uint& nextOrdinal,\n                                    bool scopeHasUnion) {\n  auto nested = decl.getNestedDecls();\n\n  if (nested.size() == 0) {\n    return { NO_CHANGE, \"Modify field, but there were none to modify.\" };\n  }\n\n  auto field = chooseFrom(nested);\n\n  bool hasUnion = false;\n  if (decl.isUnion()) {\n    hasUnion = true;\n  } else {\n    for (auto n: nested) {\n      if (n.isUnion() && n.getName().getValue().size() == 0) {\n        hasUnion = true;\n        break;\n      }\n    }\n  }\n\n  if (field.isGroup() || field.isUnion()) {\n    return chooseFrom(STRUCT_MODS)(field, nextOrdinal, hasUnion);\n  } else {\n    return chooseFrom(FIELD_MODS)(field, nextOrdinal, hasUnion);\n  }\n}"
  },
  {
    "function_name": "structAddField",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "176-193",
    "snippet": "static ChangeInfo structAddField(Declaration::Builder decl, uint& nextOrdinal, bool scopeHasUnion) {\n  auto fieldDecl = addNested(decl);\n\n  uint ordinal = nextOrdinal++;\n\n  fieldDecl.initName().setValue(kj::str(\"f\", ordinal));\n  fieldDecl.getId().initOrdinal().setValue(ordinal);\n\n  auto field = fieldDecl.initField();\n\n  auto makeValue = randomizeType(field.initType());\n  if (rand() % 4 == 0) {\n    makeValue(field.getDefaultValue().initValue());\n  } else {\n    field.getDefaultValue().setNone();\n  }\n  return { COMPATIBLE, \"Add field.\" };\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "field.getDefaultValue",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getDefaultValue",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeValue",
          "args": [
            "field.getDefaultValue().initValue()"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getDefaultValue",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getDefaultValue",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rand",
          "args": [],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "Annotation::Builder::disownBrand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.capnp.h",
          "lines": "7365-7368",
          "snippet": "inline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {\n  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(\n      _builder.getPointerField(1 * ::capnp::POINTERS));\n}",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {\n  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(\n      _builder.getPointerField(1 * ::capnp::POINTERS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "randomizeType",
          "args": [
            "field.initType()"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.initType",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fieldDecl.initField",
          "args": [],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fieldDecl.getId",
          "args": [
            "ordinal"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fieldDecl.getId",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "fieldDecl.initName",
          "args": [
            "kj::str(\"f\", ordinal)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"f\"",
            "ordinal"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fieldDecl.initName",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addNested",
          "args": [
            "decl"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "addNested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "57-72",
          "snippet": "static Declaration::Builder addNested(Declaration::Builder parent) {\n  auto oldNestedOrphan = parent.disownNestedDecls();\n  auto oldNested = oldNestedOrphan.get();\n  auto newNested = parent.initNestedDecls(oldNested.size() + 1);\n\n  uint index = rand() % (oldNested.size() + 1);\n\n  for (uint i = 0; i < index; i++) {\n    newNested.setWithCaveats(i, oldNested[i]);\n  }\n  for (uint i = index + 1; i < newNested.size(); i++) {\n    newNested.setWithCaveats(i, oldNested[i - 1]);\n  }\n\n  return newNested[index];\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nstatic Declaration::Builder addNested(Declaration::Builder parent) {\n  auto oldNestedOrphan = parent.disownNestedDecls();\n  auto oldNested = oldNestedOrphan.get();\n  auto newNested = parent.initNestedDecls(oldNested.size() + 1);\n\n  uint index = rand() % (oldNested.size() + 1);\n\n  for (uint i = 0; i < index; i++) {\n    newNested.setWithCaveats(i, oldNested[i]);\n  }\n  for (uint i = index + 1; i < newNested.size(); i++) {\n    newNested.setWithCaveats(i, oldNested[i - 1]);\n  }\n\n  return newNested[index];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nstatic ChangeInfo structAddField(Declaration::Builder decl, uint& nextOrdinal, bool scopeHasUnion) {\n  auto fieldDecl = addNested(decl);\n\n  uint ordinal = nextOrdinal++;\n\n  fieldDecl.initName().setValue(kj::str(\"f\", ordinal));\n  fieldDecl.getId().initOrdinal().setValue(ordinal);\n\n  auto field = fieldDecl.initField();\n\n  auto makeValue = randomizeType(field.initType());\n  if (rand() % 4 == 0) {\n    makeValue(field.getDefaultValue().initValue());\n  } else {\n    field.getDefaultValue().setNone();\n  }\n  return { COMPATIBLE, \"Add field.\" };\n}"
  },
  {
    "function_name": "declChangeName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "163-174",
    "snippet": "static ChangeInfo declChangeName(Declaration::Builder decl, uint& nextOrdinal,\n                                 bool scopeHasUnion) {\n  auto name = decl.getName();\n  if (name.getValue().size() == 0) {\n    // Naming an unnamed union.\n    name.setValue(kj::str(\"unUnnamed\", nextOrdinal));\n    return { SUBTLY_COMPATIBLE, \"Assign name to unnamed union.\" };\n  } else {\n    name.setValue(kj::str(name.getValue(), \"Xx\"));\n    return { COMPATIBLE, \"Rename declaration.\" };\n  }\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "name.setValue",
          "args": [
            "kj::str(name.getValue(), \"Xx\")"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "name.getValue()",
            "\"Xx\""
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.getValue",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.setValue",
          "args": [
            "kj::str(\"unUnnamed\", nextOrdinal)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"unUnnamed\"",
            "nextOrdinal"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.getValue",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.getValue",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getName",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nstatic ChangeInfo declChangeName(Declaration::Builder decl, uint& nextOrdinal,\n                                 bool scopeHasUnion) {\n  auto name = decl.getName();\n  if (name.getValue().size() == 0) {\n    // Naming an unnamed union.\n    name.setValue(kj::str(\"unUnnamed\", nextOrdinal));\n    return { SUBTLY_COMPATIBLE, \"Assign name to unnamed union.\" };\n  } else {\n    name.setValue(kj::str(name.getValue(), \"Xx\"));\n    return { COMPATIBLE, \"Rename declaration.\" };\n  }\n}"
  },
  {
    "function_name": "ChangeInfo",
    "container": "ChangeInfo",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "154-155",
    "snippet": "ChangeInfo(ChangeKind kind, kj::String&& description)\n      : kind(kind), description(kj::mv(description)) {}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "description"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nChangeInfo {\n  ChangeInfo(ChangeKind kind, kj::String&& description)\n        : kind(kind), description(kj::mv(description)) {}\n}"
  },
  {
    "function_name": "ChangeInfo",
    "container": "ChangeInfo",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "152-153",
    "snippet": "ChangeInfo(ChangeKind kind, kj::StringPtr description)\n      : kind(kind), description(kj::str(description)) {}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "description"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "341-341",
          "snippet": "inline String str(String&& s) { return mv(s); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nChangeInfo {\n  ChangeInfo(ChangeKind kind, kj::StringPtr description)\n        : kind(kind), description(kj::str(description)) {}\n}"
  },
  {
    "function_name": "ChangeInfo",
    "container": "ChangeInfo",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "151-151",
    "snippet": "ChangeInfo(): kind(NO_CHANGE) {}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nChangeInfo {\n  ChangeInfo(): kind(NO_CHANGE) {}\n}"
  },
  {
    "function_name": "randomizeType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "120-136",
    "snippet": "static kj::ConstFunction<void(Expression::Builder)> randomizeType(Expression::Builder type) {\n  auto option = &chooseFrom(TYPE_OPTIONS);\n\n  if (rand() % 4 == 0) {\n    auto app = type.initApplication();\n    setDeclName(app.initFunction(), \"List\");\n    setDeclName(app.initParams(1)[0].initValue(), option->name);\n    return [option](Expression::Builder builder) {\n      for (auto element: builder.initList(rand() % 4 + 1)) {\n        option->makeValue(element);\n      }\n    };\n  } else {\n    setDeclName(type, option->name);\n    return option->makeValue.reference();\n  }\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "option->makeValue.reference",
          "args": [],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "reference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/function.h",
          "lines": "169-175",
          "snippet": "ConstFunction reference() const {\n    // Forms a new ConstFunction of the same type that delegates to this ConstFunction by reference.\n    // Therefore, this ConstFunction must outlive the returned ConstFunction, but otherwise they\n    // behave exactly the same.\n\n    return *impl;\n  }",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nConstFunction reference() const {\n    // Forms a new ConstFunction of the same type that delegates to this ConstFunction by reference.\n    // Therefore, this ConstFunction must outlive the returned ConstFunction, but otherwise they\n    // behave exactly the same.\n\n    return *impl;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "setDeclName",
          "args": [
            "type",
            "option->name"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "setDeclName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "116-118",
          "snippet": "void setDeclName(Expression::Builder decl, kj::StringPtr name) {\n  decl.initRelativeName().setValue(name);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nvoid setDeclName(Expression::Builder decl, kj::StringPtr name) {\n  decl.initRelativeName().setValue(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "option->makeValue",
          "args": [
            "element"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initList",
          "args": [
            "rand() % 4 + 1"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rand",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "Annotation::Builder::disownBrand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.capnp.h",
          "lines": "7365-7368",
          "snippet": "inline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {\n  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(\n      _builder.getPointerField(1 * ::capnp::POINTERS));\n}",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {\n  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(\n      _builder.getPointerField(1 * ::capnp::POINTERS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "app.initParams",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "app.initParams",
          "args": [
            "1"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "app.initFunction",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.initApplication",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chooseFrom",
          "args": [
            "TYPE_OPTIONS"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "chooseFrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "53-55",
          "snippet": "auto chooseFrom(T arr) -> decltype(arr[0]) {\n  return arr[rand() % arr.size()];\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nauto chooseFrom(T arr) -> decltype(arr[0]) {\n  return arr[rand() % arr.size()];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nstatic kj::ConstFunction<void(Expression::Builder)> randomizeType(Expression::Builder type) {\n  auto option = &chooseFrom(TYPE_OPTIONS);\n\n  if (rand() % 4 == 0) {\n    auto app = type.initApplication();\n    setDeclName(app.initFunction(), \"List\");\n    setDeclName(app.initParams(1)[0].initValue(), option->name);\n    return [option](Expression::Builder builder) {\n      for (auto element: builder.initList(rand() % 4 + 1)) {\n        option->makeValue(element);\n      }\n    };\n  } else {\n    setDeclName(type, option->name);\n    return option->makeValue.reference();\n  }\n}"
  },
  {
    "function_name": "setDeclName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "116-118",
    "snippet": "void setDeclName(Expression::Builder decl, kj::StringPtr name) {\n  decl.initRelativeName().setValue(name);\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "decl.initRelativeName",
          "args": [
            "name"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.initRelativeName",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nvoid setDeclName(Expression::Builder decl, kj::StringPtr name) {\n  decl.initRelativeName().setValue(name);\n}"
  },
  {
    "function_name": "addNested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "57-72",
    "snippet": "static Declaration::Builder addNested(Declaration::Builder parent) {\n  auto oldNestedOrphan = parent.disownNestedDecls();\n  auto oldNested = oldNestedOrphan.get();\n  auto newNested = parent.initNestedDecls(oldNested.size() + 1);\n\n  uint index = rand() % (oldNested.size() + 1);\n\n  for (uint i = 0; i < index; i++) {\n    newNested.setWithCaveats(i, oldNested[i]);\n  }\n  for (uint i = index + 1; i < newNested.size(); i++) {\n    newNested.setWithCaveats(i, oldNested[i - 1]);\n  }\n\n  return newNested[index];\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "newNested.setWithCaveats",
          "args": [
            "i",
            "oldNested[i - 1]"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "setWithCaveats",
          "container": "Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/list.h",
          "lines": "269-278",
          "snippet": "inline void setWithCaveats(uint index, const typename T::Reader& reader) {\n      // Mostly behaves like you'd expect `set` to behave, but with a caveat originating from\n      // the fact that structs in a struct list are allocated inline rather than by pointer:\n      // If the source struct is larger than the target struct -- say, because the source was built\n      // using a newer version of the schema that has additional fields -- it will be truncated,\n      // losing data.\n\n      KJ_IREQUIRE(index < size());\n      builder.getStructElement(index * ELEMENTS).copyContentFrom(reader._reader);\n    }",
          "includes": [
            "#include <iterator>",
            "#include <initializer_list>",
            "#include \"orphan.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <initializer_list>\n#include \"orphan.h\"\n#include \"layout.h\"\n\nBuilder {\n  inline void setWithCaveats(uint index, const typename T::Reader& reader) {\n        // Mostly behaves like you'd expect `set` to behave, but with a caveat originating from\n        // the fact that structs in a struct list are allocated inline rather than by pointer:\n        // If the source struct is larger than the target struct -- say, because the source was built\n        // using a newer version of the schema that has additional fields -- it will be truncated,\n        // losing data.\n  \n        KJ_IREQUIRE(index < size());\n        builder.getStructElement(index * ELEMENTS).copyContentFrom(reader._reader);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "newNested.size",
          "args": [],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rand",
          "args": [],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "Annotation::Builder::disownBrand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.capnp.h",
          "lines": "7365-7368",
          "snippet": "inline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {\n  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(\n      _builder.getPointerField(1 * ::capnp::POINTERS));\n}",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {\n  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(\n      _builder.getPointerField(1 * ::capnp::POINTERS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent.initNestedDecls",
          "args": [
            "oldNested.size() + 1"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oldNestedOrphan.get",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent.disownNestedDecls",
          "args": [],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nstatic Declaration::Builder addNested(Declaration::Builder parent) {\n  auto oldNestedOrphan = parent.disownNestedDecls();\n  auto oldNested = oldNestedOrphan.get();\n  auto newNested = parent.initNestedDecls(oldNested.size() + 1);\n\n  uint index = rand() % (oldNested.size() + 1);\n\n  for (uint i = 0; i < index; i++) {\n    newNested.setWithCaveats(i, oldNested[i]);\n  }\n  for (uint i = index + 1; i < newNested.size(); i++) {\n    newNested.setWithCaveats(i, oldNested[i - 1]);\n  }\n\n  return newNested[index];\n}"
  },
  {
    "function_name": "chooseFrom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
    "lines": "53-55",
    "snippet": "auto chooseFrom(T arr) -> decltype(arr[0]) {\n  return arr[rand() % arr.size()];\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <kj/io.h>",
      "#include <kj/main.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <kj/debug.h>",
      "#include <kj/function.h>",
      "#include \"compiler.h\"",
      "#include <capnp/pretty-print.h>",
      "#include <capnp/message.h>",
      "#include <capnp/schema-loader.h>",
      "#include <capnp/compiler/grammar.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arr.size",
          "args": [],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rand",
          "args": [],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "Annotation::Builder::disownBrand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.capnp.h",
          "lines": "7365-7368",
          "snippet": "inline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {\n  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(\n      _builder.getPointerField(1 * ::capnp::POINTERS));\n}",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline ::capnp::Orphan< ::capnp::schema::Brand> Annotation::Builder::disownBrand() {\n  return ::capnp::_::PointerHelpers< ::capnp::schema::Brand>::disown(\n      _builder.getPointerField(1 * ::capnp::POINTERS));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nauto chooseFrom(T arr) -> decltype(arr[0]) {\n  return arr[rand() % arr.size()];\n}"
  }
]