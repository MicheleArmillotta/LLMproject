[
  {
    "function_name": "SchemaLoader::loadNative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "2068-2070",
    "snippet": "void SchemaLoader::loadNative(const _::RawSchema* nativeSchema) {\n  impl.lockExclusive()->get()->loadNative(nativeSchema);\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "impl.lockExclusive",
          "args": [
            "nativeSchema"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "impl.lockExclusive",
          "args": [],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "impl.lockExclusive",
          "args": [],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid SchemaLoader::loadNative(const _::RawSchema* nativeSchema) {\n  impl.lockExclusive()->get()->loadNative(nativeSchema);\n}"
  },
  {
    "function_name": "SchemaLoader::getAllLoaded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "2064-2066",
    "snippet": "kj::Array<Schema> SchemaLoader::getAllLoaded() const {\n  return impl.lockShared()->get()->getAllLoaded();\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "impl.lockShared",
          "args": [],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "impl.lockShared",
          "args": [],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "impl.lockShared",
          "args": [],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nkj::Array<Schema> SchemaLoader::getAllLoaded() const {\n  return impl.lockShared()->get()->getAllLoaded();\n}"
  },
  {
    "function_name": "SchemaLoader::loadOnce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "2052-2062",
    "snippet": "Schema SchemaLoader::loadOnce(const schema::Node::Reader& reader) const {\n  auto locked = impl.lockExclusive();\n  auto getResult = locked->get()->tryGet(reader.getId());\n  if (getResult.schema == nullptr || getResult.schema->lazyInitializer != nullptr) {\n    // Doesn't exist yet, or the existing schema is a placeholder and therefore has not yet been\n    // seen publicly.  Go ahead and load the incoming reader.\n    return Schema(&locked->get()->load(reader, false)->defaultBrand);\n  } else {\n    return Schema(&getResult.schema->defaultBrand);\n  }\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Schema",
          "args": [
            "&getResult.schema->defaultBrand"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "structSizeFromSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.c++",
          "lines": "98-103",
          "snippet": "inline _::StructSize structSizeFromSchema(StructSchema schema) {\n  auto node = schema.getProto().getStruct();\n  return _::StructSize(\n      node.getDataWordCount() * WORDS,\n      node.getPointerCount() * POINTERS);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"dynamic.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"dynamic.h\"\n\ninline _::StructSize structSizeFromSchema(StructSchema schema) {\n  auto node = schema.getProto().getStruct();\n  return _::StructSize(\n      node.getDataWordCount() * WORDS,\n      node.getPointerCount() * POINTERS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locked->get",
          "args": [
            "reader",
            "false"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locked->get",
          "args": [],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "locked->get",
          "args": [
            "reader.getId()"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "reader.getId",
          "args": [],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "impl.lockExclusive",
          "args": [],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nSchema SchemaLoader::loadOnce(const schema::Node::Reader& reader) const {\n  auto locked = impl.lockExclusive();\n  auto getResult = locked->get()->tryGet(reader.getId());\n  if (getResult.schema == nullptr || getResult.schema->lazyInitializer != nullptr) {\n    // Doesn't exist yet, or the existing schema is a placeholder and therefore has not yet been\n    // seen publicly.  Go ahead and load the incoming reader.\n    return Schema(&locked->get()->load(reader, false)->defaultBrand);\n  } else {\n    return Schema(&getResult.schema->defaultBrand);\n  }\n}"
  },
  {
    "function_name": "SchemaLoader::load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "2048-2050",
    "snippet": "Schema SchemaLoader::load(const schema::Node::Reader& reader) {\n  return Schema(&impl.lockExclusive()->get()->load(reader, false)->defaultBrand);\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Schema",
          "args": [
            "&impl.lockExclusive()->get()->load(reader, false)->defaultBrand"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "structSizeFromSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.c++",
          "lines": "98-103",
          "snippet": "inline _::StructSize structSizeFromSchema(StructSchema schema) {\n  auto node = schema.getProto().getStruct();\n  return _::StructSize(\n      node.getDataWordCount() * WORDS,\n      node.getPointerCount() * POINTERS);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"dynamic.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"dynamic.h\"\n\ninline _::StructSize structSizeFromSchema(StructSchema schema) {\n  auto node = schema.getProto().getStruct();\n  return _::StructSize(\n      node.getDataWordCount() * WORDS,\n      node.getPointerCount() * POINTERS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "impl.lockExclusive",
          "args": [
            "reader",
            "false"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "impl.lockExclusive",
          "args": [],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "impl.lockExclusive",
          "args": [],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nSchema SchemaLoader::load(const schema::Node::Reader& reader) {\n  return Schema(&impl.lockExclusive()->get()->load(reader, false)->defaultBrand);\n}"
  },
  {
    "function_name": "SchemaLoader::getType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1990-2046",
    "snippet": "Type SchemaLoader::getType(schema::Type::Reader proto, Schema scope) const {\n  switch (proto.which()) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      return proto.which();\n\n    case schema::Type::STRUCT: {\n      auto structType = proto.getStruct();\n      return get(structType.getTypeId(), structType.getBrand(), scope).asStruct();\n    }\n\n    case schema::Type::ENUM: {\n      auto enumType = proto.getEnum();\n      return get(enumType.getTypeId(), enumType.getBrand(), scope).asEnum();\n    }\n\n    case schema::Type::INTERFACE: {\n      auto interfaceType = proto.getInterface();\n      return get(interfaceType.getTypeId(), interfaceType.getBrand(), scope)\n          .asInterface();\n    }\n\n    case schema::Type::LIST:\n      return ListSchema::of(getType(proto.getList().getElementType(), scope));\n\n    case schema::Type::ANY_POINTER: {\n      auto anyPointer = proto.getAnyPointer();\n      switch (anyPointer.which()) {\n        case schema::Type::AnyPointer::UNCONSTRAINED:\n          return schema::Type::ANY_POINTER;\n        case schema::Type::AnyPointer::PARAMETER: {\n          auto param = anyPointer.getParameter();\n          return scope.getBrandBinding(param.getScopeId(), param.getParameterIndex());\n        }\n        case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER:\n          // We don't support binding implicit method params here.\n          return schema::Type::ANY_POINTER;\n      }\n\n      KJ_UNREACHABLE;\n    }\n  }\n\n  KJ_UNREACHABLE;\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scope.getBrandBinding",
          "args": [
            "param.getScopeId()",
            "param.getParameterIndex()"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param.getParameterIndex",
          "args": [],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param.getScopeId",
          "args": [],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "getScopeId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "778-778",
          "snippet": "inline uint64_t getScopeId() { return leafId; }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t leafId;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t leafId;\n\ninline uint64_t getScopeId() { return leafId; }"
        }
      },
      {
        "call_info": {
          "callee": "anyPointer.getParameter",
          "args": [],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anyPointer.which",
          "args": [],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getAnyPointer",
          "args": [],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListSchema::of",
          "args": [
            "getType(proto.getList().getElementType(), scope)"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "ListSchema::of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "699-730",
          "snippet": "ListSchema ListSchema::of(schema::Type::Which primitiveType) {\n  switch (primitiveType) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      break;\n\n    case schema::Type::STRUCT:\n    case schema::Type::ENUM:\n    case schema::Type::INTERFACE:\n    case schema::Type::LIST:\n      KJ_FAIL_REQUIRE(\"Must use one of the other ListSchema::of() overloads for complex types.\");\n      break;\n\n    case schema::Type::ANY_POINTER:\n      KJ_FAIL_REQUIRE(\"List(AnyPointer) not supported.\");\n      break;\n  }\n\n  return ListSchema(primitiveType);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nListSchema ListSchema::of(schema::Type::Which primitiveType) {\n  switch (primitiveType) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      break;\n\n    case schema::Type::STRUCT:\n    case schema::Type::ENUM:\n    case schema::Type::INTERFACE:\n    case schema::Type::LIST:\n      KJ_FAIL_REQUIRE(\"Must use one of the other ListSchema::of() overloads for complex types.\");\n      break;\n\n    case schema::Type::ANY_POINTER:\n      KJ_FAIL_REQUIRE(\"List(AnyPointer) not supported.\");\n      break;\n  }\n\n  return ListSchema(primitiveType);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proto.getList",
          "args": [],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getList",
          "args": [],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get",
          "args": [],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "Orphan<DynamicValue>::get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.c++",
          "lines": "2005-2035",
          "snippet": "DynamicValue::Builder Orphan<DynamicValue>::get() {\n  switch (type) {\n    case DynamicValue::UNKNOWN: return nullptr;\n    case DynamicValue::VOID: return voidValue;\n    case DynamicValue::BOOL: return boolValue;\n    case DynamicValue::INT: return intValue;\n    case DynamicValue::UINT: return uintValue;\n    case DynamicValue::FLOAT: return floatValue;\n    case DynamicValue::ENUM: return enumValue;\n\n    case DynamicValue::TEXT: return builder.asText();\n    case DynamicValue::DATA: return builder.asData();\n    case DynamicValue::LIST:\n      if (listSchema.whichElementType() == schema::Type::STRUCT) {\n        return DynamicList::Builder(listSchema,\n            builder.asStructList(structSizeFromSchema(listSchema.getStructElementType())));\n      } else {\n        return DynamicList::Builder(listSchema,\n            builder.asList(elementSizeFor(listSchema.whichElementType())));\n      }\n    case DynamicValue::STRUCT:\n      return DynamicStruct::Builder(structSchema,\n          builder.asStruct(structSizeFromSchema(structSchema)));\n    case DynamicValue::CAPABILITY:\n      return DynamicCapability::Client(interfaceSchema, builder.asCapability());\n    case DynamicValue::ANY_POINTER:\n      KJ_FAIL_REQUIRE(\"Can't get() an AnyPointer orphan; there is no underlying pointer to \"\n                      \"wrap in an AnyPointer::Builder.\");\n  }\n  KJ_UNREACHABLE;\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"dynamic.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"dynamic.h\"\n\nDynamicValue::Builder Orphan<DynamicValue>::get() {\n  switch (type) {\n    case DynamicValue::UNKNOWN: return nullptr;\n    case DynamicValue::VOID: return voidValue;\n    case DynamicValue::BOOL: return boolValue;\n    case DynamicValue::INT: return intValue;\n    case DynamicValue::UINT: return uintValue;\n    case DynamicValue::FLOAT: return floatValue;\n    case DynamicValue::ENUM: return enumValue;\n\n    case DynamicValue::TEXT: return builder.asText();\n    case DynamicValue::DATA: return builder.asData();\n    case DynamicValue::LIST:\n      if (listSchema.whichElementType() == schema::Type::STRUCT) {\n        return DynamicList::Builder(listSchema,\n            builder.asStructList(structSizeFromSchema(listSchema.getStructElementType())));\n      } else {\n        return DynamicList::Builder(listSchema,\n            builder.asList(elementSizeFor(listSchema.whichElementType())));\n      }\n    case DynamicValue::STRUCT:\n      return DynamicStruct::Builder(structSchema,\n          builder.asStruct(structSizeFromSchema(structSchema)));\n    case DynamicValue::CAPABILITY:\n      return DynamicCapability::Client(interfaceSchema, builder.asCapability());\n    case DynamicValue::ANY_POINTER:\n      KJ_FAIL_REQUIRE(\"Can't get() an AnyPointer orphan; there is no underlying pointer to \"\n                      \"wrap in an AnyPointer::Builder.\");\n  }\n  KJ_UNREACHABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get",
          "args": [
            "interfaceType.getTypeId()",
            "interfaceType.getBrand()",
            "scope"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interfaceType.getBrand",
          "args": [],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interfaceType.getTypeId",
          "args": [],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getInterface",
          "args": [],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get",
          "args": [
            "enumType.getTypeId()",
            "enumType.getBrand()",
            "scope"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumType.getBrand",
          "args": [],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumType.getTypeId",
          "args": [],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getEnum",
          "args": [],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get",
          "args": [
            "structType.getTypeId()",
            "structType.getBrand()",
            "scope"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structType.getBrand",
          "args": [],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structType.getTypeId",
          "args": [],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getStruct",
          "args": [],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.which",
          "args": [],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.which",
          "args": [],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nType SchemaLoader::getType(schema::Type::Reader proto, Schema scope) const {\n  switch (proto.which()) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      return proto.which();\n\n    case schema::Type::STRUCT: {\n      auto structType = proto.getStruct();\n      return get(structType.getTypeId(), structType.getBrand(), scope).asStruct();\n    }\n\n    case schema::Type::ENUM: {\n      auto enumType = proto.getEnum();\n      return get(enumType.getTypeId(), enumType.getBrand(), scope).asEnum();\n    }\n\n    case schema::Type::INTERFACE: {\n      auto interfaceType = proto.getInterface();\n      return get(interfaceType.getTypeId(), interfaceType.getBrand(), scope)\n          .asInterface();\n    }\n\n    case schema::Type::LIST:\n      return ListSchema::of(getType(proto.getList().getElementType(), scope));\n\n    case schema::Type::ANY_POINTER: {\n      auto anyPointer = proto.getAnyPointer();\n      switch (anyPointer.which()) {\n        case schema::Type::AnyPointer::UNCONSTRAINED:\n          return schema::Type::ANY_POINTER;\n        case schema::Type::AnyPointer::PARAMETER: {\n          auto param = anyPointer.getParameter();\n          return scope.getBrandBinding(param.getScopeId(), param.getParameterIndex());\n        }\n        case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER:\n          // We don't support binding implicit method params here.\n          return schema::Type::ANY_POINTER;\n      }\n\n      KJ_UNREACHABLE;\n    }\n  }\n\n  KJ_UNREACHABLE;\n}"
  },
  {
    "function_name": "SchemaLoader::getUnbound",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1985-1988",
    "snippet": "Schema SchemaLoader::getUnbound(uint64_t id) const {\n  auto schema = get(id);\n  return Schema(impl.lockExclusive()->get()->getUnbound(schema.raw->generic));\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Schema",
          "args": [
            "impl.lockExclusive()->get()->getUnbound(schema.raw->generic)"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "structSizeFromSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.c++",
          "lines": "98-103",
          "snippet": "inline _::StructSize structSizeFromSchema(StructSchema schema) {\n  auto node = schema.getProto().getStruct();\n  return _::StructSize(\n      node.getDataWordCount() * WORDS,\n      node.getPointerCount() * POINTERS);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"dynamic.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"dynamic.h\"\n\ninline _::StructSize structSizeFromSchema(StructSchema schema) {\n  auto node = schema.getProto().getStruct();\n  return _::StructSize(\n      node.getDataWordCount() * WORDS,\n      node.getPointerCount() * POINTERS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "impl.lockExclusive",
          "args": [
            "schema.raw->generic"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "impl.lockExclusive",
          "args": [],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "impl.lockExclusive",
          "args": [],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get",
          "args": [
            "id"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "DynamicStruct::Pipeline::get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.c++",
          "lines": "926-928",
          "snippet": "DynamicValue::Pipeline DynamicStruct::Pipeline::get(kj::StringPtr name) {\n  return get(schema.getFieldByName(name));\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"dynamic.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"dynamic.h\"\n\nDynamicValue::Pipeline DynamicStruct::Pipeline::get(kj::StringPtr name) {\n  return get(schema.getFieldByName(name));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nSchema SchemaLoader::getUnbound(uint64_t id) const {\n  auto schema = get(id);\n  return Schema(impl.lockExclusive()->get()->getUnbound(schema.raw->generic));\n}"
  },
  {
    "function_name": "SchemaLoader::tryGet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1960-1983",
    "snippet": "kj::Maybe<Schema> SchemaLoader::tryGet(\n    uint64_t id, schema::Brand::Reader brand, Schema scope) const {\n  auto getResult = impl.lockShared()->get()->tryGet(id);\n  if (getResult.schema == nullptr || getResult.schema->lazyInitializer != nullptr) {\n    // This schema couldn't be found or has yet to be lazily loaded. If we have a lazy loader\n    // callback, invoke it now to try to get it to load this schema.\n    KJ_IF_MAYBE(c, getResult.callback) {\n      c->load(*this, id);\n    }\n    getResult = impl.lockShared()->get()->tryGet(id);\n  }\n  if (getResult.schema != nullptr && getResult.schema->lazyInitializer == nullptr) {\n    if (brand.getScopes().size() > 0) {\n      auto brandedSchema = impl.lockExclusive()->get()->makeBranded(\n          getResult.schema, brand, kj::arrayPtr(scope.raw->scopes, scope.raw->scopeCount));\n      brandedSchema->ensureInitialized();\n      return Schema(brandedSchema);\n    } else {\n      return Schema(&getResult.schema->defaultBrand);\n    }\n  } else {\n    return nullptr;\n  }\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Schema",
          "args": [
            "&getResult.schema->defaultBrand"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "structSizeFromSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.c++",
          "lines": "98-103",
          "snippet": "inline _::StructSize structSizeFromSchema(StructSchema schema) {\n  auto node = schema.getProto().getStruct();\n  return _::StructSize(\n      node.getDataWordCount() * WORDS,\n      node.getPointerCount() * POINTERS);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"dynamic.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"dynamic.h\"\n\ninline _::StructSize structSizeFromSchema(StructSchema schema) {\n  auto node = schema.getProto().getStruct();\n  return _::StructSize(\n      node.getDataWordCount() * WORDS,\n      node.getPointerCount() * POINTERS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brandedSchema->ensureInitialized",
          "args": [],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "ensureInitialized",
          "container": "RawSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "221-228",
          "snippet": "inline void ensureInitialized() const {\n    // Lazy initialization support.  Invoke to ensure that initialization has taken place.  This\n    // is required in particular when traversing the dependency list.  RawSchemas for compiled-in\n    // types are always initialized; only dynamically-loaded schemas may be lazy.\n\n    const Initializer* i = __atomic_load_n(&lazyInitializer, __ATOMIC_ACQUIRE);\n    if (i != nullptr) i->init(this);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nRawSchema {\n  inline void ensureInitialized() const {\n      // Lazy initialization support.  Invoke to ensure that initialization has taken place.  This\n      // is required in particular when traversing the dependency list.  RawSchemas for compiled-in\n      // types are always initialized; only dynamically-loaded schemas may be lazy.\n  \n      const Initializer* i = __atomic_load_n(&lazyInitializer, __ATOMIC_ACQUIRE);\n      if (i != nullptr) i->init(this);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "impl.lockExclusive",
          "args": [
            "getResult.schema",
            "brand",
            "kj::arrayPtr(scope.raw->scopes, scope.raw->scopeCount)"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "scope.raw->scopes",
            "scope.raw->scopeCount"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "impl.lockExclusive",
          "args": [],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "impl.lockExclusive",
          "args": [],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brand.getScopes",
          "args": [],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brand.getScopes",
          "args": [],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "impl.lockShared",
          "args": [
            "id"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "impl.lockShared",
          "args": [],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "impl.lockShared",
          "args": [],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->load",
          "args": [
            "*this",
            "id"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "load",
          "container": "FakeLoaderCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader-test.c++",
          "lines": "278-288",
          "snippet": "void load(const SchemaLoader& loader, uint64_t id) const override {\n    if (id == 1234) {\n      // Magic \"not found\" ID.\n      return;\n    }\n\n    EXPECT_EQ(node.getId(), id);\n    EXPECT_FALSE(loaded);\n    loaded = true;\n    loader.loadOnce(node);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"test-util.h\"",
            "#include <kj/compat/gtest.h>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"test-util.h\"\n#include <kj/compat/gtest.h>\n#include \"schema-loader.h\"\n\nFakeLoaderCallback {\n  void load(const SchemaLoader& loader, uint64_t id) const override {\n      if (id == 1234) {\n        // Magic \"not found\" ID.\n        return;\n      }\n  \n      EXPECT_EQ(node.getId(), id);\n      EXPECT_FALSE(loaded);\n      loaded = true;\n      loader.loadOnce(node);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "c",
            "getResult.callback"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "impl.lockShared",
          "args": [
            "id"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "impl.lockShared",
          "args": [],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "impl.lockShared",
          "args": [],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nkj::Maybe<Schema> SchemaLoader::tryGet(\n    uint64_t id, schema::Brand::Reader brand, Schema scope) const {\n  auto getResult = impl.lockShared()->get()->tryGet(id);\n  if (getResult.schema == nullptr || getResult.schema->lazyInitializer != nullptr) {\n    // This schema couldn't be found or has yet to be lazily loaded. If we have a lazy loader\n    // callback, invoke it now to try to get it to load this schema.\n    KJ_IF_MAYBE(c, getResult.callback) {\n      c->load(*this, id);\n    }\n    getResult = impl.lockShared()->get()->tryGet(id);\n  }\n  if (getResult.schema != nullptr && getResult.schema->lazyInitializer == nullptr) {\n    if (brand.getScopes().size() > 0) {\n      auto brandedSchema = impl.lockExclusive()->get()->makeBranded(\n          getResult.schema, brand, kj::arrayPtr(scope.raw->scopes, scope.raw->scopeCount));\n      brandedSchema->ensureInitialized();\n      return Schema(brandedSchema);\n    } else {\n      return Schema(&getResult.schema->defaultBrand);\n    }\n  } else {\n    return nullptr;\n  }\n}"
  },
  {
    "function_name": "SchemaLoader::get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1952-1958",
    "snippet": "Schema SchemaLoader::get(uint64_t id, schema::Brand::Reader brand, Schema scope) const {\n  KJ_IF_MAYBE(result, tryGet(id, brand, scope)) {\n    return *result;\n  } else {\n    KJ_FAIL_REQUIRE(\"no schema node loaded for id\", kj::hex(id));\n  }\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"no schema node loaded for id\"",
            "kj::hex(id)"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::hex",
          "args": [
            "id"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nSchema SchemaLoader::get(uint64_t id, schema::Brand::Reader brand, Schema scope) const {\n  KJ_IF_MAYBE(result, tryGet(id, brand, scope)) {\n    return *result;\n  } else {\n    KJ_FAIL_REQUIRE(\"no schema node loaded for id\", kj::hex(id));\n  }\n}"
  },
  {
    "function_name": "SchemaLoader::~SchemaLoader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1950-1950",
    "snippet": "SchemaLoader::~SchemaLoader() noexcept(false) {}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nSchemaLoader::~SchemaLoader() noexcept(false) {}"
  },
  {
    "function_name": "SchemaLoader::SchemaLoader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1948-1949",
    "snippet": "SchemaLoader::SchemaLoader(const LazyLoadCallback& callback)\n    : impl(kj::heap<Impl>(*this, callback)) {}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<Impl>",
          "args": [
            "*this",
            "callback"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nSchemaLoader::SchemaLoader(const LazyLoadCallback& callback)\n    : impl(kj::heap<Impl>(*this, callback)) {}"
  },
  {
    "function_name": "SchemaLoader::SchemaLoader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1947-1947",
    "snippet": "SchemaLoader::SchemaLoader(): impl(kj::heap<Impl>(*this)) {}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<Impl>",
          "args": [
            "*this"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nSchemaLoader::SchemaLoader(): impl(kj::heap<Impl>(*this)) {}"
  },
  {
    "function_name": "SchemaLoader::BrandedInitializerImpl::init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1918-1943",
    "snippet": "void SchemaLoader::BrandedInitializerImpl::init(const _::RawBrandedSchema* schema) const {\n  schema->generic->ensureInitialized();\n\n  auto lock = loader.impl.lockExclusive();\n\n  if (schema->lazyInitializer == nullptr) {\n    // Never mind, someone beat us to it.\n    return;\n  }\n\n  // Get the mutable version.\n  auto iter = lock->get()->brands.find(SchemaBindingsPair { schema->generic, schema->scopes });\n  KJ_ASSERT(iter != lock->get()->brands.end());\n\n  _::RawBrandedSchema* mutableSchema = iter->second;\n  KJ_ASSERT(mutableSchema == schema);\n\n  // Construct its dependency map.\n  auto deps = lock->get()->makeBrandedDependencies(mutableSchema->generic,\n      kj::arrayPtr(mutableSchema->scopes, mutableSchema->scopeCount));\n  mutableSchema->dependencies = deps.begin();\n  mutableSchema->dependencyCount = deps.size();\n\n  // It's initialized now, so disable the initializer.\n  __atomic_store_n(&mutableSchema->lazyInitializer, nullptr, __ATOMIC_RELEASE);\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__atomic_store_n",
          "args": [
            "&mutableSchema->lazyInitializer",
            "nullptr",
            "__ATOMIC_RELEASE"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deps.size",
          "args": [],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "deps.begin",
          "args": [],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "lock->get",
          "args": [
            "mutableSchema->generic",
            "kj::arrayPtr(mutableSchema->scopes, mutableSchema->scopeCount)"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "mutableSchema->scopes",
            "mutableSchema->scopeCount"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock->get",
          "args": [],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "mutableSchema == schema"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "iter != lock->get()->brands.end()"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock->get",
          "args": [
            "SchemaBindingsPair { schema->generic, schema->scopes }"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "loader.impl.lockExclusive",
          "args": [],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema->generic->ensureInitialized",
          "args": [],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "ensureInitialized",
          "container": "RawSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "221-228",
          "snippet": "inline void ensureInitialized() const {\n    // Lazy initialization support.  Invoke to ensure that initialization has taken place.  This\n    // is required in particular when traversing the dependency list.  RawSchemas for compiled-in\n    // types are always initialized; only dynamically-loaded schemas may be lazy.\n\n    const Initializer* i = __atomic_load_n(&lazyInitializer, __ATOMIC_ACQUIRE);\n    if (i != nullptr) i->init(this);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nRawSchema {\n  inline void ensureInitialized() const {\n      // Lazy initialization support.  Invoke to ensure that initialization has taken place.  This\n      // is required in particular when traversing the dependency list.  RawSchemas for compiled-in\n      // types are always initialized; only dynamically-loaded schemas may be lazy.\n  \n      const Initializer* i = __atomic_load_n(&lazyInitializer, __ATOMIC_ACQUIRE);\n      if (i != nullptr) i->init(this);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid SchemaLoader::BrandedInitializerImpl::init(const _::RawBrandedSchema* schema) const {\n  schema->generic->ensureInitialized();\n\n  auto lock = loader.impl.lockExclusive();\n\n  if (schema->lazyInitializer == nullptr) {\n    // Never mind, someone beat us to it.\n    return;\n  }\n\n  // Get the mutable version.\n  auto iter = lock->get()->brands.find(SchemaBindingsPair { schema->generic, schema->scopes });\n  KJ_ASSERT(iter != lock->get()->brands.end());\n\n  _::RawBrandedSchema* mutableSchema = iter->second;\n  KJ_ASSERT(mutableSchema == schema);\n\n  // Construct its dependency map.\n  auto deps = lock->get()->makeBrandedDependencies(mutableSchema->generic,\n      kj::arrayPtr(mutableSchema->scopes, mutableSchema->scopeCount));\n  mutableSchema->dependencies = deps.begin();\n  mutableSchema->dependencyCount = deps.size();\n\n  // It's initialized now, so disable the initializer.\n  __atomic_store_n(&mutableSchema->lazyInitializer, nullptr, __ATOMIC_RELEASE);\n}"
  },
  {
    "function_name": "SchemaLoader::InitializerImpl::init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1894-1916",
    "snippet": "void SchemaLoader::InitializerImpl::init(const _::RawSchema* schema) const {\n  KJ_IF_MAYBE(c, callback) {\n    c->load(loader, schema->id);\n  }\n\n  if (schema->lazyInitializer != nullptr) {\n    // The callback declined to load a schema.  We need to disable the initializer so that it\n    // doesn't get invoked again later, as we can no longer modify this schema once it is in use.\n\n    // Lock the loader for read to make sure no one is concurrently loading a replacement for this\n    // schema node.\n    auto lock = loader.impl.lockShared();\n\n    // Get the mutable version of the schema.\n    _::RawSchema* mutableSchema = lock->get()->tryGet(schema->id).schema;\n    KJ_ASSERT(mutableSchema == schema,\n              \"A schema not belonging to this loader used its initializer.\");\n\n    // Disable the initializer.\n    __atomic_store_n(&mutableSchema->lazyInitializer, nullptr, __ATOMIC_RELEASE);\n    __atomic_store_n(&mutableSchema->defaultBrand.lazyInitializer, nullptr, __ATOMIC_RELEASE);\n  }\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__atomic_store_n",
          "args": [
            "&mutableSchema->defaultBrand.lazyInitializer",
            "nullptr",
            "__ATOMIC_RELEASE"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_store_n",
          "args": [
            "&mutableSchema->lazyInitializer",
            "nullptr",
            "__ATOMIC_RELEASE"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "mutableSchema == schema",
            "\"A schema not belonging to this loader used its initializer.\""
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock->get",
          "args": [
            "schema->id"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "lock->get",
          "args": [],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "loader.impl.lockShared",
          "args": [],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->load",
          "args": [
            "loader",
            "schema->id"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "load",
          "container": "FakeLoaderCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader-test.c++",
          "lines": "278-288",
          "snippet": "void load(const SchemaLoader& loader, uint64_t id) const override {\n    if (id == 1234) {\n      // Magic \"not found\" ID.\n      return;\n    }\n\n    EXPECT_EQ(node.getId(), id);\n    EXPECT_FALSE(loaded);\n    loaded = true;\n    loader.loadOnce(node);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"test-util.h\"",
            "#include <kj/compat/gtest.h>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"test-util.h\"\n#include <kj/compat/gtest.h>\n#include \"schema-loader.h\"\n\nFakeLoaderCallback {\n  void load(const SchemaLoader& loader, uint64_t id) const override {\n      if (id == 1234) {\n        // Magic \"not found\" ID.\n        return;\n      }\n  \n      EXPECT_EQ(node.getId(), id);\n      EXPECT_FALSE(loaded);\n      loaded = true;\n      loader.loadOnce(node);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid SchemaLoader::InitializerImpl::init(const _::RawSchema* schema) const {\n  KJ_IF_MAYBE(c, callback) {\n    c->load(loader, schema->id);\n  }\n\n  if (schema->lazyInitializer != nullptr) {\n    // The callback declined to load a schema.  We need to disable the initializer so that it\n    // doesn't get invoked again later, as we can no longer modify this schema once it is in use.\n\n    // Lock the loader for read to make sure no one is concurrently loading a replacement for this\n    // schema node.\n    auto lock = loader.impl.lockShared();\n\n    // Get the mutable version of the schema.\n    _::RawSchema* mutableSchema = lock->get()->tryGet(schema->id).schema;\n    KJ_ASSERT(mutableSchema == schema,\n              \"A schema not belonging to this loader used its initializer.\");\n\n    // Disable the initializer.\n    __atomic_store_n(&mutableSchema->lazyInitializer, nullptr, __ATOMIC_RELEASE);\n    __atomic_store_n(&mutableSchema->defaultBrand.lazyInitializer, nullptr, __ATOMIC_RELEASE);\n  }\n}"
  },
  {
    "function_name": "SchemaLoader::Impl::applyStructSizeRequirement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1877-1892",
    "snippet": "void SchemaLoader::Impl::applyStructSizeRequirement(\n    _::RawSchema* raw, uint dataWordCount, uint pointerCount) {\n  auto node = readMessageUnchecked<schema::Node>(raw->encodedNode);\n\n  auto structNode = node.getStruct();\n  if (structNode.getDataWordCount() < dataWordCount ||\n      structNode.getPointerCount() < pointerCount) {\n    // Sizes need to be increased.  Must rewrite.\n    kj::ArrayPtr<word> words = rewriteStructNodeWithSizes(node, dataWordCount, pointerCount);\n\n    // We don't need to re-validate the node because we know this change could not possibly have\n    // invalidated it.  Just remake the unchecked message.\n    raw->encodedNode = words.begin();\n    raw->encodedSize = words.size();\n  }\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "words.size",
          "args": [],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "words.begin",
          "args": [],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "rewriteStructNodeWithSizes",
          "args": [
            "node",
            "dataWordCount",
            "pointerCount"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "SchemaLoader::Impl::rewriteStructNodeWithSizes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
          "lines": "1864-1875",
          "snippet": "kj::ArrayPtr<word> SchemaLoader::Impl::rewriteStructNodeWithSizes(\n    schema::Node::Reader node, uint dataWordCount, uint pointerCount) {\n  MallocMessageBuilder builder;\n  builder.setRoot(node);\n\n  auto root = builder.getRoot<schema::Node>();\n  auto newStruct = root.getStruct();\n  newStruct.setDataWordCount(kj::max(newStruct.getDataWordCount(), dataWordCount));\n  newStruct.setPointerCount(kj::max(newStruct.getPointerCount(), pointerCount));\n\n  return makeUncheckedNode(root);\n}",
          "includes": [
            "#include <algorithm>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/exception.h>",
            "#include <kj/debug.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include <map>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nkj::ArrayPtr<word> SchemaLoader::Impl::rewriteStructNodeWithSizes(\n    schema::Node::Reader node, uint dataWordCount, uint pointerCount) {\n  MallocMessageBuilder builder;\n  builder.setRoot(node);\n\n  auto root = builder.getRoot<schema::Node>();\n  auto newStruct = root.getStruct();\n  newStruct.setDataWordCount(kj::max(newStruct.getDataWordCount(), dataWordCount));\n  newStruct.setPointerCount(kj::max(newStruct.getPointerCount(), pointerCount));\n\n  return makeUncheckedNode(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "structNode.getPointerCount",
          "args": [],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getDataWordCount",
          "args": [],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getStruct",
          "args": [],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readMessageUnchecked<schema::Node>",
          "args": [
            "raw->encodedNode"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "readMessageUnchecked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.h",
          "lines": "466-468",
          "snippet": "typename RootType::Reader readMessageUnchecked(const word* data) {\n  return AnyPointer::Reader(_::PointerReader::getRootUnchecked(data)).getAs<RootType>();\n}",
          "includes": [
            "#include \"any.h\"",
            "#include \"layout.h\"",
            "#include \"common.h\"",
            "#include <kj/mutex.h>",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"any.h\"\n#include \"layout.h\"\n#include \"common.h\"\n#include <kj/mutex.h>\n#include <kj/memory.h>\n#include <kj/common.h>\n\ntypename RootType::Reader readMessageUnchecked(const word* data) {\n  return AnyPointer::Reader(_::PointerReader::getRootUnchecked(data)).getAs<RootType>();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid SchemaLoader::Impl::applyStructSizeRequirement(\n    _::RawSchema* raw, uint dataWordCount, uint pointerCount) {\n  auto node = readMessageUnchecked<schema::Node>(raw->encodedNode);\n\n  auto structNode = node.getStruct();\n  if (structNode.getDataWordCount() < dataWordCount ||\n      structNode.getPointerCount() < pointerCount) {\n    // Sizes need to be increased.  Must rewrite.\n    kj::ArrayPtr<word> words = rewriteStructNodeWithSizes(node, dataWordCount, pointerCount);\n\n    // We don't need to re-validate the node because we know this change could not possibly have\n    // invalidated it.  Just remake the unchecked message.\n    raw->encodedNode = words.begin();\n    raw->encodedSize = words.size();\n  }\n}"
  },
  {
    "function_name": "SchemaLoader::Impl::rewriteStructNodeWithSizes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1864-1875",
    "snippet": "kj::ArrayPtr<word> SchemaLoader::Impl::rewriteStructNodeWithSizes(\n    schema::Node::Reader node, uint dataWordCount, uint pointerCount) {\n  MallocMessageBuilder builder;\n  builder.setRoot(node);\n\n  auto root = builder.getRoot<schema::Node>();\n  auto newStruct = root.getStruct();\n  newStruct.setDataWordCount(kj::max(newStruct.getDataWordCount(), dataWordCount));\n  newStruct.setPointerCount(kj::max(newStruct.getPointerCount(), pointerCount));\n\n  return makeUncheckedNode(root);\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeUncheckedNode",
          "args": [
            "root"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "SchemaLoader::Impl::makeUncheckedNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
          "lines": "1838-1844",
          "snippet": "kj::ArrayPtr<word> SchemaLoader::Impl::makeUncheckedNode(schema::Node::Reader node) {\n  size_t size = node.totalSize().wordCount + 1;\n  kj::ArrayPtr<word> result = arena.allocateArray<word>(size);\n  memset(result.begin(), 0, size * sizeof(word));\n  copyToUnchecked(node, result);\n  return result;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/exception.h>",
            "#include <kj/debug.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include <map>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nkj::ArrayPtr<word> SchemaLoader::Impl::makeUncheckedNode(schema::Node::Reader node) {\n  size_t size = node.totalSize().wordCount + 1;\n  kj::ArrayPtr<word> result = arena.allocateArray<word>(size);\n  memset(result.begin(), 0, size * sizeof(word));\n  copyToUnchecked(node, result);\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "newStruct.setPointerCount",
          "args": [
            "kj::max(newStruct.getPointerCount(), pointerCount)"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::max",
          "args": [
            "newStruct.getPointerCount()",
            "pointerCount"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "486-488",
          "snippet": "auto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "newStruct.getPointerCount",
          "args": [],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newStruct.setDataWordCount",
          "args": [
            "kj::max(newStruct.getDataWordCount(), dataWordCount)"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newStruct.getDataWordCount",
          "args": [],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "root.getStruct",
          "args": [],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getRoot<schema::Node>",
          "args": [],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.setRoot",
          "args": [
            "node"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nkj::ArrayPtr<word> SchemaLoader::Impl::rewriteStructNodeWithSizes(\n    schema::Node::Reader node, uint dataWordCount, uint pointerCount) {\n  MallocMessageBuilder builder;\n  builder.setRoot(node);\n\n  auto root = builder.getRoot<schema::Node>();\n  auto newStruct = root.getStruct();\n  newStruct.setDataWordCount(kj::max(newStruct.getDataWordCount(), dataWordCount));\n  newStruct.setPointerCount(kj::max(newStruct.getPointerCount(), pointerCount));\n\n  return makeUncheckedNode(root);\n}"
  },
  {
    "function_name": "SchemaLoader::Impl::makeUncheckedNodeEnforcingSizeRequirements",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1846-1862",
    "snippet": "kj::ArrayPtr<word> SchemaLoader::Impl::makeUncheckedNodeEnforcingSizeRequirements(\n    schema::Node::Reader node) {\n  if (node.isStruct()) {\n    auto iter = structSizeRequirements.find(node.getId());\n    if (iter != structSizeRequirements.end()) {\n      auto requirement = iter->second;\n      auto structNode = node.getStruct();\n      if (structNode.getDataWordCount() < requirement.dataWordCount ||\n          structNode.getPointerCount() < requirement.pointerCount) {\n        return rewriteStructNodeWithSizes(node, requirement.dataWordCount,\n                                          requirement.pointerCount);\n      }\n    }\n  }\n\n  return makeUncheckedNode(node);\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeUncheckedNode",
          "args": [
            "node"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "SchemaLoader::Impl::makeUncheckedNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
          "lines": "1838-1844",
          "snippet": "kj::ArrayPtr<word> SchemaLoader::Impl::makeUncheckedNode(schema::Node::Reader node) {\n  size_t size = node.totalSize().wordCount + 1;\n  kj::ArrayPtr<word> result = arena.allocateArray<word>(size);\n  memset(result.begin(), 0, size * sizeof(word));\n  copyToUnchecked(node, result);\n  return result;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/exception.h>",
            "#include <kj/debug.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include <map>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nkj::ArrayPtr<word> SchemaLoader::Impl::makeUncheckedNode(schema::Node::Reader node) {\n  size_t size = node.totalSize().wordCount + 1;\n  kj::ArrayPtr<word> result = arena.allocateArray<word>(size);\n  memset(result.begin(), 0, size * sizeof(word));\n  copyToUnchecked(node, result);\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rewriteStructNodeWithSizes",
          "args": [
            "node",
            "requirement.dataWordCount",
            "requirement.pointerCount"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "SchemaLoader::Impl::rewriteStructNodeWithSizes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
          "lines": "1864-1875",
          "snippet": "kj::ArrayPtr<word> SchemaLoader::Impl::rewriteStructNodeWithSizes(\n    schema::Node::Reader node, uint dataWordCount, uint pointerCount) {\n  MallocMessageBuilder builder;\n  builder.setRoot(node);\n\n  auto root = builder.getRoot<schema::Node>();\n  auto newStruct = root.getStruct();\n  newStruct.setDataWordCount(kj::max(newStruct.getDataWordCount(), dataWordCount));\n  newStruct.setPointerCount(kj::max(newStruct.getPointerCount(), pointerCount));\n\n  return makeUncheckedNode(root);\n}",
          "includes": [
            "#include <algorithm>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/exception.h>",
            "#include <kj/debug.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include <map>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nkj::ArrayPtr<word> SchemaLoader::Impl::rewriteStructNodeWithSizes(\n    schema::Node::Reader node, uint dataWordCount, uint pointerCount) {\n  MallocMessageBuilder builder;\n  builder.setRoot(node);\n\n  auto root = builder.getRoot<schema::Node>();\n  auto newStruct = root.getStruct();\n  newStruct.setDataWordCount(kj::max(newStruct.getDataWordCount(), dataWordCount));\n  newStruct.setPointerCount(kj::max(newStruct.getPointerCount(), pointerCount));\n\n  return makeUncheckedNode(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "structNode.getPointerCount",
          "args": [],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getDataWordCount",
          "args": [],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getStruct",
          "args": [],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structSizeRequirements.end",
          "args": [],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      },
      {
        "call_info": {
          "callee": "structSizeRequirements.find",
          "args": [
            "node.getId()"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "191-202",
          "snippet": "kj::Maybe<T&> find(Id id) {\n    if (id < kj::size(low)) {\n      return low[id];\n    } else {\n      auto iter = high.find(id);\n      if (iter == high.end()) {\n        return nullptr;\n      } else {\n        return iter->second;\n      }\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  kj::Maybe<T&> find(Id id) {\n      if (id < kj::size(low)) {\n        return low[id];\n      } else {\n        auto iter = high.find(id);\n        if (iter == high.end()) {\n          return nullptr;\n        } else {\n          return iter->second;\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "node.getId",
          "args": [],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "node.isStruct",
          "args": [],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "isStruct",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "142-144",
          "snippet": "inline bool isStruct() {\n      return builder.isStruct();\n    }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline bool isStruct() {\n          return builder.isStruct();\n        }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nkj::ArrayPtr<word> SchemaLoader::Impl::makeUncheckedNodeEnforcingSizeRequirements(\n    schema::Node::Reader node) {\n  if (node.isStruct()) {\n    auto iter = structSizeRequirements.find(node.getId());\n    if (iter != structSizeRequirements.end()) {\n      auto requirement = iter->second;\n      auto structNode = node.getStruct();\n      if (structNode.getDataWordCount() < requirement.dataWordCount ||\n          structNode.getPointerCount() < requirement.pointerCount) {\n        return rewriteStructNodeWithSizes(node, requirement.dataWordCount,\n                                          requirement.pointerCount);\n      }\n    }\n  }\n\n  return makeUncheckedNode(node);\n}"
  },
  {
    "function_name": "SchemaLoader::Impl::makeUncheckedNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1838-1844",
    "snippet": "kj::ArrayPtr<word> SchemaLoader::Impl::makeUncheckedNode(schema::Node::Reader node) {\n  size_t size = node.totalSize().wordCount + 1;\n  kj::ArrayPtr<word> result = arena.allocateArray<word>(size);\n  memset(result.begin(), 0, size * sizeof(word));\n  copyToUnchecked(node, result);\n  return result;\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copyToUnchecked",
          "args": [
            "node",
            "result"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "result.begin()",
            "0",
            "size * sizeof(word)"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.begin",
          "args": [],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "arena.allocateArray<word>",
          "args": [
            "size"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.totalSize",
          "args": [],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "totalSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.capnp.h",
          "lines": "558-558",
          "snippet": "inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nkj::ArrayPtr<word> SchemaLoader::Impl::makeUncheckedNode(schema::Node::Reader node) {\n  size_t size = node.totalSize().wordCount + 1;\n  kj::ArrayPtr<word> result = arena.allocateArray<word>(size);\n  memset(result.begin(), 0, size * sizeof(word));\n  copyToUnchecked(node, result);\n  return result;\n}"
  },
  {
    "function_name": "SchemaLoader::Impl::requireStructSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1827-1836",
    "snippet": "void SchemaLoader::Impl::requireStructSize(uint64_t id, uint dataWordCount, uint pointerCount) {\n  auto& slot = structSizeRequirements[id];\n  slot.dataWordCount = kj::max(slot.dataWordCount, dataWordCount);\n  slot.pointerCount = kj::max(slot.pointerCount, pointerCount);\n\n  auto iter = schemas.find(id);\n  if (iter != schemas.end()) {\n    applyStructSizeRequirement(iter->second, dataWordCount, pointerCount);\n  }\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "applyStructSizeRequirement",
          "args": [
            "iter->second",
            "dataWordCount",
            "pointerCount"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "SchemaLoader::Impl::applyStructSizeRequirement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
          "lines": "1877-1892",
          "snippet": "void SchemaLoader::Impl::applyStructSizeRequirement(\n    _::RawSchema* raw, uint dataWordCount, uint pointerCount) {\n  auto node = readMessageUnchecked<schema::Node>(raw->encodedNode);\n\n  auto structNode = node.getStruct();\n  if (structNode.getDataWordCount() < dataWordCount ||\n      structNode.getPointerCount() < pointerCount) {\n    // Sizes need to be increased.  Must rewrite.\n    kj::ArrayPtr<word> words = rewriteStructNodeWithSizes(node, dataWordCount, pointerCount);\n\n    // We don't need to re-validate the node because we know this change could not possibly have\n    // invalidated it.  Just remake the unchecked message.\n    raw->encodedNode = words.begin();\n    raw->encodedSize = words.size();\n  }\n}",
          "includes": [
            "#include <algorithm>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/exception.h>",
            "#include <kj/debug.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include <map>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid SchemaLoader::Impl::applyStructSizeRequirement(\n    _::RawSchema* raw, uint dataWordCount, uint pointerCount) {\n  auto node = readMessageUnchecked<schema::Node>(raw->encodedNode);\n\n  auto structNode = node.getStruct();\n  if (structNode.getDataWordCount() < dataWordCount ||\n      structNode.getPointerCount() < pointerCount) {\n    // Sizes need to be increased.  Must rewrite.\n    kj::ArrayPtr<word> words = rewriteStructNodeWithSizes(node, dataWordCount, pointerCount);\n\n    // We don't need to re-validate the node because we know this change could not possibly have\n    // invalidated it.  Just remake the unchecked message.\n    raw->encodedNode = words.begin();\n    raw->encodedSize = words.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "schemas.end",
          "args": [],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      },
      {
        "call_info": {
          "callee": "schemas.find",
          "args": [
            "id"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "191-202",
          "snippet": "kj::Maybe<T&> find(Id id) {\n    if (id < kj::size(low)) {\n      return low[id];\n    } else {\n      auto iter = high.find(id);\n      if (iter == high.end()) {\n        return nullptr;\n      } else {\n        return iter->second;\n      }\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  kj::Maybe<T&> find(Id id) {\n      if (id < kj::size(low)) {\n        return low[id];\n      } else {\n        auto iter = high.find(id);\n        if (iter == high.end()) {\n          return nullptr;\n        } else {\n          return iter->second;\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::max",
          "args": [
            "slot.pointerCount",
            "pointerCount"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "486-488",
          "snippet": "auto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid SchemaLoader::Impl::requireStructSize(uint64_t id, uint dataWordCount, uint pointerCount) {\n  auto& slot = structSizeRequirements[id];\n  slot.dataWordCount = kj::max(slot.dataWordCount, dataWordCount);\n  slot.pointerCount = kj::max(slot.pointerCount, pointerCount);\n\n  auto iter = schemas.find(id);\n  if (iter != schemas.end()) {\n    applyStructSizeRequirement(iter->second, dataWordCount, pointerCount);\n  }\n}"
  },
  {
    "function_name": "SchemaLoader::Impl::getAllLoaded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1811-1825",
    "snippet": "kj::Array<Schema> SchemaLoader::Impl::getAllLoaded() const {\n  size_t count = 0;\n  for (auto& schema: schemas) {\n    if (schema.second->lazyInitializer == nullptr) ++count;\n  }\n\n  kj::Array<Schema> result = kj::heapArray<Schema>(count);\n  size_t i = 0;\n  for (auto& schema: schemas) {\n    if (schema.second->lazyInitializer == nullptr) {\n      result[i++] = Schema(&schema.second->defaultBrand);\n    }\n  }\n  return result;\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Schema",
          "args": [
            "&schema.second->defaultBrand"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "structSizeFromSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.c++",
          "lines": "98-103",
          "snippet": "inline _::StructSize structSizeFromSchema(StructSchema schema) {\n  auto node = schema.getProto().getStruct();\n  return _::StructSize(\n      node.getDataWordCount() * WORDS,\n      node.getPointerCount() * POINTERS);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"dynamic.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"dynamic.h\"\n\ninline _::StructSize structSizeFromSchema(StructSchema schema) {\n  auto node = schema.getProto().getStruct();\n  return _::StructSize(\n      node.getDataWordCount() * WORDS,\n      node.getPointerCount() * POINTERS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapArray<Schema>",
          "args": [
            "count"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "696-698",
          "snippet": "inline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nkj::Array<Schema> SchemaLoader::Impl::getAllLoaded() const {\n  size_t count = 0;\n  for (auto& schema: schemas) {\n    if (schema.second->lazyInitializer == nullptr) ++count;\n  }\n\n  kj::Array<Schema> result = kj::heapArray<Schema>(count);\n  size_t i = 0;\n  for (auto& schema: schemas) {\n    if (schema.second->lazyInitializer == nullptr) {\n      result[i++] = Schema(&schema.second->defaultBrand);\n    }\n  }\n  return result;\n}"
  },
  {
    "function_name": "SchemaLoader::Impl::tryGet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1783-1790",
    "snippet": "SchemaLoader::Impl::TryGetResult SchemaLoader::Impl::tryGet(uint64_t typeId) const {\n  auto iter = schemas.find(typeId);\n  if (iter == schemas.end()) {\n    return {nullptr, initializer.getCallback()};\n  } else {\n    return {iter->second, initializer.getCallback()};\n  }\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "initializer.getCallback",
          "args": [],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "getCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
          "lines": "88-88",
          "snippet": "inline kj::Maybe<const LazyLoadCallback&> getCallback() const { return callback; }",
          "includes": [
            "#include <algorithm>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/exception.h>",
            "#include <kj/debug.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include <map>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\ninline kj::Maybe<const LazyLoadCallback&> getCallback() const { return callback; }"
        }
      },
      {
        "call_info": {
          "callee": "schemas.end",
          "args": [],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      },
      {
        "call_info": {
          "callee": "schemas.find",
          "args": [
            "typeId"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "191-202",
          "snippet": "kj::Maybe<T&> find(Id id) {\n    if (id < kj::size(low)) {\n      return low[id];\n    } else {\n      auto iter = high.find(id);\n      if (iter == high.end()) {\n        return nullptr;\n      } else {\n        return iter->second;\n      }\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  kj::Maybe<T&> find(Id id) {\n      if (id < kj::size(low)) {\n        return low[id];\n      } else {\n        auto iter = high.find(id);\n        if (iter == high.end()) {\n          return nullptr;\n        } else {\n          return iter->second;\n        }\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nSchemaLoader::Impl::TryGetResult SchemaLoader::Impl::tryGet(uint64_t typeId) const {\n  auto iter = schemas.find(typeId);\n  if (iter == schemas.end()) {\n    return {nullptr, initializer.getCallback()};\n  } else {\n    return {iter->second, initializer.getCallback()};\n  }\n}"
  },
  {
    "function_name": "SchemaLoader::Impl::copyDeduped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1779-1781",
    "snippet": "kj::ArrayPtr<const T> SchemaLoader::Impl::copyDeduped(kj::ArrayPtr<T> values) {\n  return copyDeduped(kj::ArrayPtr<const T>(values));\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::ArrayPtr<const T>",
          "args": [
            "values"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayPtr",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1121-1121",
          "snippet": "inline constexpr ArrayPtr(T (&native)[size]): ptr(native), size_(size) {}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline constexpr ArrayPtr(T (&native)[size]): ptr(native), size_(size) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nkj::ArrayPtr<const T> SchemaLoader::Impl::copyDeduped(kj::ArrayPtr<T> values) {\n  return copyDeduped(kj::ArrayPtr<const T>(values));\n}"
  },
  {
    "function_name": "SchemaLoader::Impl::copyDeduped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1757-1776",
    "snippet": "kj::ArrayPtr<const T> SchemaLoader::Impl::copyDeduped(kj::ArrayPtr<const T> values) {\n  if (values.size() == 0) {\n    return kj::arrayPtr(kj::implicitCast<const T*>(nullptr), 0);\n  }\n\n  auto bytes = values.asBytes();\n\n  auto iter = dedupTable.find(bytes);\n  if (iter != dedupTable.end()) {\n    return kj::arrayPtr(reinterpret_cast<const T*>(iter->begin()), values.size());\n  }\n\n  // Need to make a new copy.\n  auto copy = arena.allocateArray<T>(values.size());\n  memcpy(copy.begin(), values.begin(), values.size() * sizeof(T));\n\n  KJ_ASSERT(dedupTable.insert(copy.asBytes()).second);\n\n  return copy;\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "dedupTable.insert(copy.asBytes()).second"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dedupTable.insert",
          "args": [
            "copy.asBytes()"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy.asBytes",
          "args": [],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "asBytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/blob.h",
          "lines": "128-128",
          "snippet": "inline kj::ArrayPtr<const byte> asBytes() const { return asArray().asBytes(); }",
          "includes": [
            "#include <string.h>",
            "#include \"common.h\"",
            "#include <kj/string.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"common.h\"\n#include <kj/string.h>\n#include <kj/common.h>\n\ninline kj::ArrayPtr<const byte> asBytes() const { return asArray().asBytes(); }"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "copy.begin()",
            "values.begin()",
            "values.size() * sizeof(T)"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "values.size",
          "args": [],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "values.begin",
          "args": [],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "arena.allocateArray<T>",
          "args": [
            "values.size()"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "reinterpret_cast<const T*>(iter->begin())",
            "values.size()"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const T*>",
          "args": [
            "iter->begin()"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dedupTable.end",
          "args": [],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      },
      {
        "call_info": {
          "callee": "dedupTable.find",
          "args": [
            "bytes"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "191-202",
          "snippet": "kj::Maybe<T&> find(Id id) {\n    if (id < kj::size(low)) {\n      return low[id];\n    } else {\n      auto iter = high.find(id);\n      if (iter == high.end()) {\n        return nullptr;\n      } else {\n        return iter->second;\n      }\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  kj::Maybe<T&> find(Id id) {\n      if (id < kj::size(low)) {\n        return low[id];\n      } else {\n        auto iter = high.find(id);\n        if (iter == high.end()) {\n          return nullptr;\n        } else {\n          return iter->second;\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::implicitCast<const T*>",
          "args": [
            "nullptr"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "implicitCast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1203-1207",
          "snippet": "To implicitCast(From&& from) {\n  // `implicitCast<T>(value)` casts `value` to type `T` only if the conversion is implicit.  Useful\n  // for e.g. resolving ambiguous overloads without sacrificing type-safety.\n  return kj::fwd<From>(from);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nTo implicitCast(From&& from) {\n  // `implicitCast<T>(value)` casts `value` to type `T` only if the conversion is implicit.  Useful\n  // for e.g. resolving ambiguous overloads without sacrificing type-safety.\n  return kj::fwd<From>(from);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nkj::ArrayPtr<const T> SchemaLoader::Impl::copyDeduped(kj::ArrayPtr<const T> values) {\n  if (values.size() == 0) {\n    return kj::arrayPtr(kj::implicitCast<const T*>(nullptr), 0);\n  }\n\n  auto bytes = values.asBytes();\n\n  auto iter = dedupTable.find(bytes);\n  if (iter != dedupTable.end()) {\n    return kj::arrayPtr(reinterpret_cast<const T*>(iter->begin()), values.size());\n  }\n\n  // Need to make a new copy.\n  auto copy = arena.allocateArray<T>(values.size());\n  memcpy(copy.begin(), values.begin(), values.size() * sizeof(T));\n\n  KJ_ASSERT(dedupTable.insert(copy.asBytes()).second);\n\n  return copy;\n}"
  },
  {
    "function_name": "SchemaLoader::Impl::makeDep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1726-1735",
    "snippet": "void SchemaLoader::Impl::makeDep(_::RawBrandedSchema::Binding& result,\n    uint64_t typeId, schema::Type::Which whichType, schema::Node::Which expectedKind,\n    schema::Brand::Reader brand, kj::StringPtr scopeName,\n    kj::Maybe<kj::ArrayPtr<const _::RawBrandedSchema::Scope>> brandBindings) {\n  const _::RawSchema* schema = loadEmpty(typeId,\n      kj::str(\"(unknown type; seen as dependency of \", scopeName, \")\"),\n      expectedKind, true);\n  result.which = static_cast<uint8_t>(whichType);\n  result.schema = makeBranded(schema, brand, brandBindings);\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeBranded",
          "args": [
            "schema",
            "brand",
            "brandBindings"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint8_t>",
          "args": [
            "whichType"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadEmpty",
          "args": [
            "typeId",
            "kj::str(\"(unknown type; seen as dependency of \", scopeName, \")\")",
            "expectedKind",
            "true"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"(unknown type; seen as dependency of \"",
            "scopeName",
            "\")\""
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid SchemaLoader::Impl::makeDep(_::RawBrandedSchema::Binding& result,\n    uint64_t typeId, schema::Type::Which whichType, schema::Node::Which expectedKind,\n    schema::Brand::Reader brand, kj::StringPtr scopeName,\n    kj::Maybe<kj::ArrayPtr<const _::RawBrandedSchema::Scope>> brandBindings) {\n  const _::RawSchema* schema = loadEmpty(typeId,\n      kj::str(\"(unknown type; seen as dependency of \", scopeName, \")\"),\n      expectedKind, true);\n  result.which = static_cast<uint8_t>(whichType);\n  result.schema = makeBranded(schema, brand, brandBindings);\n}"
  },
  {
    "function_name": "SchemaLoader::Impl::makeDep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1629-1721",
    "snippet": "void SchemaLoader::Impl::makeDep(_::RawBrandedSchema::Binding& result,\n    schema::Type::Reader type, kj::StringPtr scopeName,\n    kj::Maybe<kj::ArrayPtr<const _::RawBrandedSchema::Scope>> brandBindings) {\n  switch (type.which()) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      result.which = static_cast<uint8_t>(type.which());\n      return;\n\n    case schema::Type::STRUCT: {\n      auto structType = type.getStruct();\n      makeDep(result, structType.getTypeId(), schema::Type::STRUCT, schema::Node::STRUCT,\n              structType.getBrand(), scopeName, brandBindings);\n      return;\n    }\n    case schema::Type::ENUM: {\n      auto enumType = type.getEnum();\n      makeDep(result, enumType.getTypeId(), schema::Type::ENUM, schema::Node::ENUM,\n              enumType.getBrand(), scopeName, brandBindings);\n      return;\n    }\n    case schema::Type::INTERFACE: {\n      auto interfaceType = type.getInterface();\n      makeDep(result, interfaceType.getTypeId(), schema::Type::INTERFACE, schema::Node::INTERFACE,\n              interfaceType.getBrand(), scopeName, brandBindings);\n      return;\n    }\n\n    case schema::Type::LIST: {\n      makeDep(result, type.getList().getElementType(), scopeName, brandBindings);\n      ++result.listDepth;\n      return;\n    }\n\n    case schema::Type::ANY_POINTER: {\n      result.which = static_cast<uint8_t>(schema::Type::ANY_POINTER);\n      auto anyPointer = type.getAnyPointer();\n      switch (anyPointer.which()) {\n        case schema::Type::AnyPointer::UNCONSTRAINED:\n          return;\n        case schema::Type::AnyPointer::PARAMETER: {\n          auto param = anyPointer.getParameter();\n          uint64_t id = param.getScopeId();\n          uint16_t index = param.getParameterIndex();\n\n          KJ_IF_MAYBE(b, brandBindings) {\n            // TODO(perf): We could binary search here, but... bleh.\n            for (auto& scope: *b) {\n              if (scope.typeId == id) {\n                if (scope.isUnbound) {\n                  // Unbound brand parameter.\n                  result.scopeId = id;\n                  result.paramIndex = index;\n                  return;\n                } else if (index >= scope.bindingCount) {\n                  // Binding index out-of-range. Treat as AnyPointer. This is important to allow\n                  // new type parameters to be added to existing types without breaking dependent\n                  // schemas.\n                  return;\n                } else {\n                  result = scope.bindings[index];\n                  return;\n                }\n              }\n            }\n            return;\n          } else {\n            // Unbound brand parameter.\n            result.scopeId = id;\n            result.paramIndex = index;\n            return;\n          }\n        }\n        case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER:\n          result.isImplicitParameter = true;\n          result.paramIndex = anyPointer.getImplicitMethodParameter().getParameterIndex();\n          return;\n      }\n      KJ_UNREACHABLE;\n    }\n  }",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "anyPointer.getImplicitMethodParameter",
          "args": [],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anyPointer.getImplicitMethodParameter",
          "args": [],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param.getParameterIndex",
          "args": [],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param.getScopeId",
          "args": [],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "getScopeId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "778-778",
          "snippet": "inline uint64_t getScopeId() { return leafId; }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t leafId;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t leafId;\n\ninline uint64_t getScopeId() { return leafId; }"
        }
      },
      {
        "call_info": {
          "callee": "anyPointer.getParameter",
          "args": [],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anyPointer.which",
          "args": [],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getAnyPointer",
          "args": [],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint8_t>",
          "args": [
            "schema::Type::ANY_POINTER"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeDep",
          "args": [
            "result",
            "type.getList().getElementType()",
            "scopeName",
            "brandBindings"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getList",
          "args": [],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getList",
          "args": [],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interfaceType.getBrand",
          "args": [],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interfaceType.getTypeId",
          "args": [],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getInterface",
          "args": [],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumType.getBrand",
          "args": [],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumType.getTypeId",
          "args": [],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getEnum",
          "args": [],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structType.getBrand",
          "args": [],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structType.getTypeId",
          "args": [],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getStruct",
          "args": [],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint8_t>",
          "args": [
            "type.which()"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid SchemaLoader::Impl::makeDep(_::RawBrandedSchema::Binding& result,\n    schema::Type::Reader type, kj::StringPtr scopeName,\n    kj::Maybe<kj::ArrayPtr<const _::RawBrandedSchema::Scope>> brandBindings) {\n  switch (type.which()) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      result.which = static_cast<uint8_t>(type.which());\n      return;\n\n    case schema::Type::STRUCT: {\n      auto structType = type.getStruct();\n      makeDep(result, structType.getTypeId(), schema::Type::STRUCT, schema::Node::STRUCT,\n              structType.getBrand(), scopeName, brandBindings);\n      return;\n    }\n    case schema::Type::ENUM: {\n      auto enumType = type.getEnum();\n      makeDep(result, enumType.getTypeId(), schema::Type::ENUM, schema::Node::ENUM,\n              enumType.getBrand(), scopeName, brandBindings);\n      return;\n    }\n    case schema::Type::INTERFACE: {\n      auto interfaceType = type.getInterface();\n      makeDep(result, interfaceType.getTypeId(), schema::Type::INTERFACE, schema::Node::INTERFACE,\n              interfaceType.getBrand(), scopeName, brandBindings);\n      return;\n    }\n\n    case schema::Type::LIST: {\n      makeDep(result, type.getList().getElementType(), scopeName, brandBindings);\n      ++result.listDepth;\n      return;\n    }\n\n    case schema::Type::ANY_POINTER: {\n      result.which = static_cast<uint8_t>(schema::Type::ANY_POINTER);\n      auto anyPointer = type.getAnyPointer();\n      switch (anyPointer.which()) {\n        case schema::Type::AnyPointer::UNCONSTRAINED:\n          return;\n        case schema::Type::AnyPointer::PARAMETER: {\n          auto param = anyPointer.getParameter();\n          uint64_t id = param.getScopeId();\n          uint16_t index = param.getParameterIndex();\n\n          KJ_IF_MAYBE(b, brandBindings) {\n            // TODO(perf): We could binary search here, but... bleh.\n            for (auto& scope: *b) {\n              if (scope.typeId == id) {\n                if (scope.isUnbound) {\n                  // Unbound brand parameter.\n                  result.scopeId = id;\n                  result.paramIndex = index;\n                  return;\n                } else if (index >= scope.bindingCount) {\n                  // Binding index out-of-range. Treat as AnyPointer. This is important to allow\n                  // new type parameters to be added to existing types without breaking dependent\n                  // schemas.\n                  return;\n                } else {\n                  result = scope.bindings[index];\n                  return;\n                }\n              }\n            }\n            return;\n          } else {\n            // Unbound brand parameter.\n            result.scopeId = id;\n            result.paramIndex = index;\n            return;\n          }\n        }\n        case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER:\n          result.isImplicitParameter = true;\n          result.paramIndex = anyPointer.getImplicitMethodParameter().getParameterIndex();\n          return;\n      }\n      KJ_UNREACHABLE;\n    }\n  }"
  },
  {
    "function_name": "SchemaLoader::Impl::makeBrandedDependencies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1536-1617",
    "snippet": "kj::ArrayPtr<const _::RawBrandedSchema::Dependency>\nSchemaLoader::Impl::makeBrandedDependencies(\n    const _::RawSchema* schema,\n    kj::Maybe<kj::ArrayPtr<const _::RawBrandedSchema::Scope>> bindings) {\n  kj::StringPtr scopeName =\n      readMessageUnchecked<schema::Node>(schema->encodedNode).getDisplayName();\n\n  kj::Vector<_::RawBrandedSchema::Dependency> deps;\n\n  schema::Node::Reader node = readMessageUnchecked<schema::Node>(schema->encodedNode);\n\n#define ADD_ENTRY(kind, index, make) \\\n    if (const _::RawBrandedSchema* dep = make) { \\\n      auto& slot = deps.add(); \\\n      memset(&slot, 0, sizeof(slot)); \\\n      slot.location = _::RawBrandedSchema::makeDepLocation( \\\n        _::RawBrandedSchema::DepKind::kind, index); \\\n      slot.schema = dep; \\\n    }\n\n  switch (node.which()) {\n    case schema::Node::FILE:\n    case schema::Node::ENUM:\n    case schema::Node::ANNOTATION:\n      break;\n\n    case schema::Node::CONST:\n      ADD_ENTRY(CONST_TYPE, 0, makeDepSchema(\n          node.getConst().getType(), scopeName, bindings));\n      break;\n\n    case schema::Node::STRUCT: {\n      auto fields = node.getStruct().getFields();\n      for (auto i: kj::indices(fields)) {\n        auto field = fields[i];\n        switch (field.which()) {\n          case schema::Field::SLOT:\n            ADD_ENTRY(FIELD, i, makeDepSchema(\n                field.getSlot().getType(), scopeName, bindings))\n            break;\n          case schema::Field::GROUP: {\n            const _::RawSchema* group = loadEmpty(\n                field.getGroup().getTypeId(),\n                \"(unknown group type)\", schema::Node::STRUCT, true);\n            KJ_IF_MAYBE(b, bindings) {\n              ADD_ENTRY(FIELD, i, makeBranded(group, *b));\n            } else {\n              ADD_ENTRY(FIELD, i, getUnbound(group));\n            }\n            break;\n          }\n        }\n      }\n      break;\n    }\n\n    case schema::Node::INTERFACE: {\n      auto interface = node.getInterface();\n      {\n        auto superclasses = interface.getSuperclasses();\n        for (auto i: kj::indices(superclasses)) {\n          auto superclass = superclasses[i];\n          ADD_ENTRY(SUPERCLASS, i, makeDepSchema(\n              superclass.getId(), schema::Type::INTERFACE, schema::Node::INTERFACE,\n              superclass.getBrand(), scopeName, bindings))\n        }\n      }\n      {\n        auto methods = interface.getMethods();\n        for (auto i: kj::indices(methods)) {\n          auto method = methods[i];\n          ADD_ENTRY(METHOD_PARAMS, i, makeDepSchema(\n              method.getParamStructType(), schema::Type::STRUCT, schema::Node::STRUCT,\n              method.getParamBrand(), scopeName, bindings))\n          ADD_ENTRY(METHOD_RESULTS, i, makeDepSchema(\n              method.getResultStructType(), schema::Type::STRUCT, schema::Node::STRUCT,\n              method.getResultBrand(), scopeName, bindings))\n        }\n      }\n      break;\n    }\n  }",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADD_ENTRY",
          "args": [
            "METHOD_RESULTS",
            "i",
            "makeDepSchema(\n              method.getResultStructType(), schema::Type::STRUCT, schema::Node::STRUCT,\n              method.getResultBrand(), scopeName, bindings)"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeDepSchema",
          "args": [
            "method.getResultStructType()",
            "schema::Type::STRUCT",
            "schema::Node::STRUCT",
            "method.getResultBrand()",
            "scopeName",
            "bindings"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getResultBrand",
          "args": [],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getResultStructType",
          "args": [],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADD_ENTRY",
          "args": [
            "METHOD_PARAMS",
            "i",
            "makeDepSchema(\n              method.getParamStructType(), schema::Type::STRUCT, schema::Node::STRUCT,\n              method.getParamBrand(), scopeName, bindings)"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeDepSchema",
          "args": [
            "method.getParamStructType()",
            "schema::Type::STRUCT",
            "schema::Node::STRUCT",
            "method.getParamBrand()",
            "scopeName",
            "bindings"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getParamBrand",
          "args": [],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getParamStructType",
          "args": [],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "methods"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "interface.getMethods",
          "args": [],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADD_ENTRY",
          "args": [
            "SUPERCLASS",
            "i",
            "makeDepSchema(\n              superclass.getId(), schema::Type::INTERFACE, schema::Node::INTERFACE,\n              superclass.getBrand(), scopeName, bindings)"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeDepSchema",
          "args": [
            "superclass.getId()",
            "schema::Type::INTERFACE",
            "schema::Node::INTERFACE",
            "superclass.getBrand()",
            "scopeName",
            "bindings"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "superclass.getBrand",
          "args": [],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "superclass.getId",
          "args": [],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "interface.getSuperclasses",
          "args": [],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getInterface",
          "args": [],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADD_ENTRY",
          "args": [
            "FIELD",
            "i",
            "getUnbound(group)"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getUnbound",
          "args": [
            "group"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "SchemaLoader::getUnbound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
          "lines": "1985-1988",
          "snippet": "Schema SchemaLoader::getUnbound(uint64_t id) const {\n  auto schema = get(id);\n  return Schema(impl.lockExclusive()->get()->getUnbound(schema.raw->generic));\n}",
          "includes": [
            "#include <algorithm>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/exception.h>",
            "#include <kj/debug.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include <map>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nSchema SchemaLoader::getUnbound(uint64_t id) const {\n  auto schema = get(id);\n  return Schema(impl.lockExclusive()->get()->getUnbound(schema.raw->generic));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADD_ENTRY",
          "args": [
            "FIELD",
            "i",
            "makeBranded(group, *b)"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeBranded",
          "args": [
            "group",
            "*b"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadEmpty",
          "args": [
            "field.getGroup().getTypeId()",
            "\"(unknown group type)\"",
            "schema::Node::STRUCT",
            "true"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getGroup",
          "args": [],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getGroup",
          "args": [],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADD_ENTRY",
          "args": [
            "FIELD",
            "i",
            "makeDepSchema(\n                field.getSlot().getType(), scopeName, bindings)"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeDepSchema",
          "args": [
            "field.getSlot().getType()",
            "scopeName",
            "bindings"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getSlot",
          "args": [],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getSlot",
          "args": [],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.which",
          "args": [],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getStruct",
          "args": [],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getStruct",
          "args": [],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADD_ENTRY",
          "args": [
            "CONST_TYPE",
            "0",
            "makeDepSchema(\n          node.getConst().getType(), scopeName, bindings)"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeDepSchema",
          "args": [
            "node.getConst().getType()",
            "scopeName",
            "bindings"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getConst",
          "args": [],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getConst",
          "args": [],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.which",
          "args": [],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readMessageUnchecked<schema::Node>",
          "args": [
            "schema->encodedNode"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "readMessageUnchecked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.h",
          "lines": "466-468",
          "snippet": "typename RootType::Reader readMessageUnchecked(const word* data) {\n  return AnyPointer::Reader(_::PointerReader::getRootUnchecked(data)).getAs<RootType>();\n}",
          "includes": [
            "#include \"any.h\"",
            "#include \"layout.h\"",
            "#include \"common.h\"",
            "#include <kj/mutex.h>",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"any.h\"\n#include \"layout.h\"\n#include \"common.h\"\n#include <kj/mutex.h>\n#include <kj/memory.h>\n#include <kj/common.h>\n\ntypename RootType::Reader readMessageUnchecked(const word* data) {\n  return AnyPointer::Reader(_::PointerReader::getRootUnchecked(data)).getAs<RootType>();\n}"
        }
      },
      {
        "call_info": {
          "callee": "readMessageUnchecked<schema::Node>",
          "args": [],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nkj::ArrayPtr<const _::RawBrandedSchema::Dependency>\nSchemaLoader::Impl::makeBrandedDependencies(\n    const _::RawSchema* schema,\n    kj::Maybe<kj::ArrayPtr<const _::RawBrandedSchema::Scope>> bindings) {\n  kj::StringPtr scopeName =\n      readMessageUnchecked<schema::Node>(schema->encodedNode).getDisplayName();\n\n  kj::Vector<_::RawBrandedSchema::Dependency> deps;\n\n  schema::Node::Reader node = readMessageUnchecked<schema::Node>(schema->encodedNode);\n\n#define ADD_ENTRY(kind, index, make) \\\n    if (const _::RawBrandedSchema* dep = make) { \\\n      auto& slot = deps.add(); \\\n      memset(&slot, 0, sizeof(slot)); \\\n      slot.location = _::RawBrandedSchema::makeDepLocation( \\\n        _::RawBrandedSchema::DepKind::kind, index); \\\n      slot.schema = dep; \\\n    }\n\n  switch (node.which()) {\n    case schema::Node::FILE:\n    case schema::Node::ENUM:\n    case schema::Node::ANNOTATION:\n      break;\n\n    case schema::Node::CONST:\n      ADD_ENTRY(CONST_TYPE, 0, makeDepSchema(\n          node.getConst().getType(), scopeName, bindings));\n      break;\n\n    case schema::Node::STRUCT: {\n      auto fields = node.getStruct().getFields();\n      for (auto i: kj::indices(fields)) {\n        auto field = fields[i];\n        switch (field.which()) {\n          case schema::Field::SLOT:\n            ADD_ENTRY(FIELD, i, makeDepSchema(\n                field.getSlot().getType(), scopeName, bindings))\n            break;\n          case schema::Field::GROUP: {\n            const _::RawSchema* group = loadEmpty(\n                field.getGroup().getTypeId(),\n                \"(unknown group type)\", schema::Node::STRUCT, true);\n            KJ_IF_MAYBE(b, bindings) {\n              ADD_ENTRY(FIELD, i, makeBranded(group, *b));\n            } else {\n              ADD_ENTRY(FIELD, i, getUnbound(group));\n            }\n            break;\n          }\n        }\n      }\n      break;\n    }\n\n    case schema::Node::INTERFACE: {\n      auto interface = node.getInterface();\n      {\n        auto superclasses = interface.getSuperclasses();\n        for (auto i: kj::indices(superclasses)) {\n          auto superclass = superclasses[i];\n          ADD_ENTRY(SUPERCLASS, i, makeDepSchema(\n              superclass.getId(), schema::Type::INTERFACE, schema::Node::INTERFACE,\n              superclass.getBrand(), scopeName, bindings))\n        }\n      }\n      {\n        auto methods = interface.getMethods();\n        for (auto i: kj::indices(methods)) {\n          auto method = methods[i];\n          ADD_ENTRY(METHOD_PARAMS, i, makeDepSchema(\n              method.getParamStructType(), schema::Type::STRUCT, schema::Node::STRUCT,\n              method.getParamBrand(), scopeName, bindings))\n          ADD_ENTRY(METHOD_RESULTS, i, makeDepSchema(\n              method.getResultStructType(), schema::Type::STRUCT, schema::Node::STRUCT,\n              method.getResultBrand(), scopeName, bindings))\n        }\n      }\n      break;\n    }\n  }"
  },
  {
    "function_name": "checkDefaultCompatibility",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1201-1240",
    "snippet": "void checkDefaultCompatibility(const schema::Value::Reader& value,\n                                 const schema::Value::Reader& replacement) {\n    // Note that we test default compatibility only after testing type compatibility, and default\n    // values have already been validated as matching their types, so this should pass.\n    KJ_ASSERT(value.which() == replacement.which()) {\n      compatibility = INCOMPATIBLE;\n      return;\n    }\n\n    switch (value.which()) {\n#define HANDLE_TYPE(discrim, name) \\\n      case schema::Value::discrim: \\\n        VALIDATE_SCHEMA(value.get##name() == replacement.get##name(), \"default value changed\"); \\\n        break;\n      HANDLE_TYPE(VOID, Void);\n      HANDLE_TYPE(BOOL, Bool);\n      HANDLE_TYPE(INT8, Int8);\n      HANDLE_TYPE(INT16, Int16);\n      HANDLE_TYPE(INT32, Int32);\n      HANDLE_TYPE(INT64, Int64);\n      HANDLE_TYPE(UINT8, Uint8);\n      HANDLE_TYPE(UINT16, Uint16);\n      HANDLE_TYPE(UINT32, Uint32);\n      HANDLE_TYPE(UINT64, Uint64);\n      HANDLE_TYPE(FLOAT32, Float32);\n      HANDLE_TYPE(FLOAT64, Float64);\n      HANDLE_TYPE(ENUM, Enum);\n#undef HANDLE_TYPE\n\n      case schema::Value::TEXT:\n      case schema::Value::DATA:\n      case schema::Value::LIST:\n      case schema::Value::STRUCT:\n      case schema::Value::INTERFACE:\n      case schema::Value::ANY_POINTER:\n        // It's not a big deal if default values for pointers change, and it would be difficult for\n        // us to compare these defaults here, so just let it slide.\n        break;\n    }\n  }",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "ENUM",
            "Enum"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "FLOAT64",
            "Float64"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "FLOAT32",
            "Float32"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "UINT64",
            "Uint64"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "UINT32",
            "Uint32"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "UINT16",
            "Uint16"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "UINT8",
            "Uint8"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "INT64",
            "Int64"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "INT32",
            "Int32"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "INT16",
            "Int16"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "INT8",
            "Int8"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "BOOL",
            "Bool"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "VOID",
            "Void"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.which",
          "args": [],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "value.which() == replacement.which()"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.which",
          "args": [],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.which",
          "args": [],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid checkDefaultCompatibility(const schema::Value::Reader& value,\n                                 const schema::Value::Reader& replacement) {\n    // Note that we test default compatibility only after testing type compatibility, and default\n    // values have already been validated as matching their types, so this should pass.\n    KJ_ASSERT(value.which() == replacement.which()) {\n      compatibility = INCOMPATIBLE;\n      return;\n    }\n\n    switch (value.which()) {\n#define HANDLE_TYPE(discrim, name) \\\n      case schema::Value::discrim: \\\n        VALIDATE_SCHEMA(value.get##name() == replacement.get##name(), \"default value changed\"); \\\n        break;\n      HANDLE_TYPE(VOID, Void);\n      HANDLE_TYPE(BOOL, Bool);\n      HANDLE_TYPE(INT8, Int8);\n      HANDLE_TYPE(INT16, Int16);\n      HANDLE_TYPE(INT32, Int32);\n      HANDLE_TYPE(INT64, Int64);\n      HANDLE_TYPE(UINT8, Uint8);\n      HANDLE_TYPE(UINT16, Uint16);\n      HANDLE_TYPE(UINT32, Uint32);\n      HANDLE_TYPE(UINT64, Uint64);\n      HANDLE_TYPE(FLOAT32, Float32);\n      HANDLE_TYPE(FLOAT64, Float64);\n      HANDLE_TYPE(ENUM, Enum);\n#undef HANDLE_TYPE\n\n      case schema::Value::TEXT:\n      case schema::Value::DATA:\n      case schema::Value::LIST:\n      case schema::Value::STRUCT:\n      case schema::Value::INTERFACE:\n      case schema::Value::ANY_POINTER:\n        // It's not a big deal if default values for pointers change, and it would be difficult for\n        // us to compare these defaults here, so just let it slide.\n        break;\n    }\n  }"
  },
  {
    "function_name": "canUpgradeToAnyPointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "1171-1199",
    "snippet": "bool canUpgradeToAnyPointer(const schema::Type::Reader& type) {\n    switch (type.which()) {\n      case schema::Type::VOID:\n      case schema::Type::BOOL:\n      case schema::Type::INT8:\n      case schema::Type::INT16:\n      case schema::Type::INT32:\n      case schema::Type::INT64:\n      case schema::Type::UINT8:\n      case schema::Type::UINT16:\n      case schema::Type::UINT32:\n      case schema::Type::UINT64:\n      case schema::Type::FLOAT32:\n      case schema::Type::FLOAT64:\n      case schema::Type::ENUM:\n        return false;\n\n      case schema::Type::TEXT:\n      case schema::Type::DATA:\n      case schema::Type::LIST:\n      case schema::Type::STRUCT:\n      case schema::Type::INTERFACE:\n      case schema::Type::ANY_POINTER:\n        return true;\n    }\n\n    // Be lenient with unknown types.\n    return true;\n  }",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nbool canUpgradeToAnyPointer(const schema::Type::Reader& type) {\n    switch (type.which()) {\n      case schema::Type::VOID:\n      case schema::Type::BOOL:\n      case schema::Type::INT8:\n      case schema::Type::INT16:\n      case schema::Type::INT32:\n      case schema::Type::INT64:\n      case schema::Type::UINT8:\n      case schema::Type::UINT16:\n      case schema::Type::UINT32:\n      case schema::Type::UINT64:\n      case schema::Type::FLOAT32:\n      case schema::Type::FLOAT64:\n      case schema::Type::ENUM:\n        return false;\n\n      case schema::Type::TEXT:\n      case schema::Type::DATA:\n      case schema::Type::LIST:\n      case schema::Type::STRUCT:\n      case schema::Type::INTERFACE:\n      case schema::Type::ANY_POINTER:\n        return true;\n    }\n\n    // Be lenient with unknown types.\n    return true;\n  }"
  },
  {
    "function_name": "canUpgradeToData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "638-1169",
    "snippet": "class SchemaLoader::CompatibilityChecker {\npublic:\n  CompatibilityChecker(SchemaLoader::Impl& loader): loader(loader) {}\n\n  bool shouldReplace(const schema::Node::Reader& existingNode,\n                     const schema::Node::Reader& replacement,\n                     bool preferReplacementIfEquivalent) {\n    this->existingNode = existingNode;\n    this->replacementNode = replacement;\n\n    KJ_CONTEXT(\"checking compatibility with previously-loaded node of the same id\",\n               existingNode.getDisplayName());\n\n    KJ_DREQUIRE(existingNode.getId() == replacement.getId());\n\n    nodeName = existingNode.getDisplayName();\n    compatibility = EQUIVALENT;\n\n    checkCompatibility(existingNode, replacement);\n\n    // Prefer the newer schema.\n    return preferReplacementIfEquivalent ? compatibility != OLDER : compatibility == NEWER;\n  }\n\nprivate:\n  SchemaLoader::Impl& loader;\n  Text::Reader nodeName;\n  schema::Node::Reader existingNode;\n  schema::Node::Reader replacementNode;\n\n  enum Compatibility {\n    EQUIVALENT,\n    OLDER,\n    NEWER,\n    INCOMPATIBLE\n  };\n  Compatibility compatibility;\n\n#define VALIDATE_SCHEMA(condition, ...) \\\n  KJ_REQUIRE(condition, ##__VA_ARGS__) { compatibility = INCOMPATIBLE; return; }\n#define FAIL_VALIDATE_SCHEMA(...) \\\n  KJ_FAIL_REQUIRE(__VA_ARGS__) { compatibility = INCOMPATIBLE; return; }\n\n  void replacementIsNewer() {\n    switch (compatibility) {\n      case EQUIVALENT:\n        compatibility = NEWER;\n        break;\n      case OLDER:\n        FAIL_VALIDATE_SCHEMA(\"Schema node contains some changes that are upgrades and some \"\n            \"that are downgrades.  All changes must be in the same direction for compatibility.\");\n        break;\n      case NEWER:\n        break;\n      case INCOMPATIBLE:\n        break;\n    }\n  }\n\n  void replacementIsOlder() {\n    switch (compatibility) {\n      case EQUIVALENT:\n        compatibility = OLDER;\n        break;\n      case OLDER:\n        break;\n      case NEWER:\n        FAIL_VALIDATE_SCHEMA(\"Schema node contains some changes that are upgrades and some \"\n            \"that are downgrades.  All changes must be in the same direction for compatibility.\");\n        break;\n      case INCOMPATIBLE:\n        break;\n    }\n  }\n\n  void checkCompatibility(const schema::Node::Reader& node,\n                          const schema::Node::Reader& replacement) {\n    // Returns whether `replacement` is equivalent, older than, newer than, or incompatible with\n    // `node`.  If exceptions are enabled, this will throw an exception on INCOMPATIBLE.\n\n    VALIDATE_SCHEMA(node.which() == replacement.which(),\n                    \"kind of declaration changed\");\n\n    // No need to check compatibility of most of the non-body parts of the node:\n    // - Arbitrary renaming and moving between scopes is allowed.\n    // - Annotations are ignored for compatibility purposes.\n\n    if (replacement.getParameters().size() > node.getParameters().size()) {\n      replacementIsNewer();\n    } else if (replacement.getParameters().size() < node.getParameters().size()) {\n      replacementIsOlder();\n    }\n\n    switch (node.which()) {\n      case schema::Node::FILE:\n        verifyVoid(node.getFile());\n        break;\n      case schema::Node::STRUCT:\n        checkCompatibility(node.getStruct(), replacement.getStruct(),\n                           node.getScopeId(), replacement.getScopeId());\n        break;\n      case schema::Node::ENUM:\n        checkCompatibility(node.getEnum(), replacement.getEnum());\n        break;\n      case schema::Node::INTERFACE:\n        checkCompatibility(node.getInterface(), replacement.getInterface());\n        break;\n      case schema::Node::CONST:\n        checkCompatibility(node.getConst(), replacement.getConst());\n        break;\n      case schema::Node::ANNOTATION:\n        checkCompatibility(node.getAnnotation(), replacement.getAnnotation());\n        break;\n    }\n  }\n\n  void checkCompatibility(const schema::Node::Struct::Reader& structNode,\n                          const schema::Node::Struct::Reader& replacement,\n                          uint64_t scopeId, uint64_t replacementScopeId) {\n    if (replacement.getDataWordCount() > structNode.getDataWordCount()) {\n      replacementIsNewer();\n    } else if (replacement.getDataWordCount() < structNode.getDataWordCount()) {\n      replacementIsOlder();\n    }\n    if (replacement.getPointerCount() > structNode.getPointerCount()) {\n      replacementIsNewer();\n    } else if (replacement.getPointerCount() < structNode.getPointerCount()) {\n      replacementIsOlder();\n    }\n    if (replacement.getDiscriminantCount() > structNode.getDiscriminantCount()) {\n      replacementIsNewer();\n    } else if (replacement.getDiscriminantCount() < structNode.getDiscriminantCount()) {\n      replacementIsOlder();\n    }\n\n    if (replacement.getDiscriminantCount() > 0 && structNode.getDiscriminantCount() > 0) {\n      VALIDATE_SCHEMA(replacement.getDiscriminantOffset() == structNode.getDiscriminantOffset(),\n                      \"union discriminant position changed\");\n    }\n\n    // The shared members should occupy corresponding positions in the member lists, since the\n    // lists are sorted by ordinal.\n    auto fields = structNode.getFields();\n    auto replacementFields = replacement.getFields();\n    uint count = std::min(fields.size(), replacementFields.size());\n\n    if (replacementFields.size() > fields.size()) {\n      replacementIsNewer();\n    } else if (replacementFields.size() < fields.size()) {\n      replacementIsOlder();\n    }\n\n    for (uint i = 0; i < count; i++) {\n      checkCompatibility(fields[i], replacementFields[i]);\n    }\n\n    // For the moment, we allow \"upgrading\" from non-group to group, mainly so that the\n    // placeholders we generate for group parents (which in the absence of more info, we assume to\n    // be non-groups) can be replaced with groups.\n    //\n    // TODO(cleanup):  The placeholder approach is really breaking down.  Maybe we need to maintain\n    //   a list of expectations for nodes we haven't loaded yet.\n    if (structNode.getIsGroup()) {\n      if (replacement.getIsGroup()) {\n        VALIDATE_SCHEMA(replacementScopeId == scopeId, \"group node's scope changed\");\n      } else {\n        replacementIsOlder();\n      }\n    } else {\n      if (replacement.getIsGroup()) {\n        replacementIsNewer();\n      }\n    }\n  }\n\n  void checkCompatibility(const schema::Field::Reader& field,\n                          const schema::Field::Reader& replacement) {\n    KJ_CONTEXT(\"comparing struct field\", field.getName());\n\n    // A field that is initially not in a union can be upgraded to be in one, as long as it has\n    // discriminant 0.\n    uint discriminant = hasDiscriminantValue(field) ? field.getDiscriminantValue() : 0;\n    uint replacementDiscriminant =\n        hasDiscriminantValue(replacement) ? replacement.getDiscriminantValue() : 0;\n    VALIDATE_SCHEMA(discriminant == replacementDiscriminant, \"Field discriminant changed.\");\n\n    switch (field.which()) {\n      case schema::Field::SLOT: {\n        auto slot = field.getSlot();\n\n        switch (replacement.which()) {\n          case schema::Field::SLOT: {\n            auto replacementSlot = replacement.getSlot();\n\n            checkCompatibility(slot.getType(), replacementSlot.getType(),\n                               NO_UPGRADE_TO_STRUCT);\n            checkDefaultCompatibility(slot.getDefaultValue(),\n                                      replacementSlot.getDefaultValue());\n\n            VALIDATE_SCHEMA(slot.getOffset() == replacementSlot.getOffset(),\n                            \"field position changed\");\n            break;\n          }\n          case schema::Field::GROUP:\n            checkUpgradeToStruct(slot.getType(), replacement.getGroup().getTypeId(),\n                                 existingNode, field);\n            break;\n        }\n\n        break;\n      }\n\n      case schema::Field::GROUP:\n        switch (replacement.which()) {\n          case schema::Field::SLOT:\n            checkUpgradeToStruct(replacement.getSlot().getType(), field.getGroup().getTypeId(),\n                                 replacementNode, replacement);\n            break;\n          case schema::Field::GROUP:\n            VALIDATE_SCHEMA(field.getGroup().getTypeId() == replacement.getGroup().getTypeId(),\n                            \"group id changed\");\n            break;\n        }\n        break;\n    }\n  }\n\n  void checkCompatibility(const schema::Node::Enum::Reader& enumNode,\n                          const schema::Node::Enum::Reader& replacement) {\n    uint size = enumNode.getEnumerants().size();\n    uint replacementSize = replacement.getEnumerants().size();\n    if (replacementSize > size) {\n      replacementIsNewer();\n    } else if (replacementSize < size) {\n      replacementIsOlder();\n    }\n  }\n\n  void checkCompatibility(const schema::Node::Interface::Reader& interfaceNode,\n                          const schema::Node::Interface::Reader& replacement) {\n    {\n      // Check superclasses.\n\n      kj::Vector<uint64_t> superclasses;\n      kj::Vector<uint64_t> replacementSuperclasses;\n      for (auto superclass: interfaceNode.getSuperclasses()) {\n        superclasses.add(superclass.getId());\n      }\n      for (auto superclass: replacement.getSuperclasses()) {\n        replacementSuperclasses.add(superclass.getId());\n      }\n      std::sort(superclasses.begin(), superclasses.end());\n      std::sort(replacementSuperclasses.begin(), replacementSuperclasses.end());\n\n      auto iter = superclasses.begin();\n      auto replacementIter = replacementSuperclasses.begin();\n\n      while (iter != superclasses.end() || replacementIter != replacementSuperclasses.end()) {\n        if (iter == superclasses.end()) {\n          replacementIsNewer();\n          break;\n        } else if (replacementIter == replacementSuperclasses.end()) {\n          replacementIsOlder();\n          break;\n        } else if (*iter < *replacementIter) {\n          replacementIsOlder();\n          ++iter;\n        } else if (*iter > *replacementIter) {\n          replacementIsNewer();\n          ++replacementIter;\n        } else {\n          ++iter;\n          ++replacementIter;\n        }\n      }\n    }\n\n    auto methods = interfaceNode.getMethods();\n    auto replacementMethods = replacement.getMethods();\n\n    if (replacementMethods.size() > methods.size()) {\n      replacementIsNewer();\n    } else if (replacementMethods.size() < methods.size()) {\n      replacementIsOlder();\n    }\n\n    uint count = std::min(methods.size(), replacementMethods.size());\n\n    for (uint i = 0; i < count; i++) {\n      checkCompatibility(methods[i], replacementMethods[i]);\n    }\n  }\n\n  void checkCompatibility(const schema::Method::Reader& method,\n                          const schema::Method::Reader& replacement) {\n    KJ_CONTEXT(\"comparing method\", method.getName());\n\n    // TODO(someday):  Allow named parameter list to be replaced by compatible struct type.\n    VALIDATE_SCHEMA(method.getParamStructType() == replacement.getParamStructType(),\n                    \"Updated method has different parameters.\");\n    VALIDATE_SCHEMA(method.getResultStructType() == replacement.getResultStructType(),\n                    \"Updated method has different results.\");\n  }\n\n  void checkCompatibility(const schema::Node::Const::Reader& constNode,\n                          const schema::Node::Const::Reader& replacement) {\n    // Who cares?  These don't appear on the wire.\n  }\n\n  void checkCompatibility(const schema::Node::Annotation::Reader& annotationNode,\n                          const schema::Node::Annotation::Reader& replacement) {\n    // Who cares?  These don't appear on the wire.\n  }\n\n  enum UpgradeToStructMode {\n    ALLOW_UPGRADE_TO_STRUCT,\n    NO_UPGRADE_TO_STRUCT\n  };\n\n  void checkCompatibility(const schema::Type::Reader& type,\n                          const schema::Type::Reader& replacement,\n                          UpgradeToStructMode upgradeToStructMode) {\n    if (replacement.which() != type.which()) {\n      // Check for allowed \"upgrade\" to Data or AnyPointer.\n      if (replacement.isData() && canUpgradeToData(type)) {\n        replacementIsNewer();\n        return;\n      } else if (type.isData() && canUpgradeToData(replacement)) {\n        replacementIsOlder();\n        return;\n      } else if (replacement.isAnyPointer() && canUpgradeToAnyPointer(type)) {\n        replacementIsNewer();\n        return;\n      } else if (type.isAnyPointer() && canUpgradeToAnyPointer(replacement)) {\n        replacementIsOlder();\n        return;\n      }\n\n      if (upgradeToStructMode == ALLOW_UPGRADE_TO_STRUCT) {\n        if (type.isStruct()) {\n          checkUpgradeToStruct(replacement, type.getStruct().getTypeId());\n          return;\n        } else if (replacement.isStruct()) {\n          checkUpgradeToStruct(type, replacement.getStruct().getTypeId());\n          return;\n        }\n      }\n\n      FAIL_VALIDATE_SCHEMA(\"a type was changed\");\n    }\n\n    switch (type.which()) {\n      case schema::Type::VOID:\n      case schema::Type::BOOL:\n      case schema::Type::INT8:\n      case schema::Type::INT16:\n      case schema::Type::INT32:\n      case schema::Type::INT64:\n      case schema::Type::UINT8:\n      case schema::Type::UINT16:\n      case schema::Type::UINT32:\n      case schema::Type::UINT64:\n      case schema::Type::FLOAT32:\n      case schema::Type::FLOAT64:\n      case schema::Type::TEXT:\n      case schema::Type::DATA:\n      case schema::Type::ANY_POINTER:\n        return;\n\n      case schema::Type::LIST:\n        checkCompatibility(type.getList().getElementType(), replacement.getList().getElementType(),\n                           ALLOW_UPGRADE_TO_STRUCT);\n        return;\n\n      case schema::Type::ENUM:\n        VALIDATE_SCHEMA(replacement.getEnum().getTypeId() == type.getEnum().getTypeId(),\n                        \"type changed enum type\");\n        return;\n\n      case schema::Type::STRUCT:\n        // TODO(someday):  If the IDs don't match, we should compare the two structs for\n        //   compatibility.  This is tricky, though, because the new type's target may not yet be\n        //   loaded.  In that case we could take the old type, make a copy of it, assign the new\n        //   ID to the copy, and load() that.  That forces any struct type loaded for that ID to\n        //   be compatible.  However, that has another problem, which is that it could be that the\n        //   whole reason the type was replaced was to fork that type, and so an incompatibility\n        //   could be very much expected.  This could be a rat hole...\n        VALIDATE_SCHEMA(replacement.getStruct().getTypeId() == type.getStruct().getTypeId(),\n                        \"type changed to incompatible struct type\");\n        return;\n\n      case schema::Type::INTERFACE:\n        VALIDATE_SCHEMA(replacement.getInterface().getTypeId() == type.getInterface().getTypeId(),\n                        \"type changed to incompatible interface type\");\n        return;\n    }\n\n    // We assume unknown types (from newer versions of Cap'n Proto?) are equivalent.\n  }\n\n  void checkUpgradeToStruct(const schema::Type::Reader& type, uint64_t structTypeId,\n                            kj::Maybe<schema::Node::Reader> matchSize = nullptr,\n                            kj::Maybe<schema::Field::Reader> matchPosition = nullptr) {\n    // We can't just look up the target struct and check it because it may not have been loaded\n    // yet.  Instead, we contrive a struct that looks like what we want and load() that, which\n    // guarantees that any incompatibility will be caught either now or when the real version of\n    // that struct is loaded.\n\n    word scratch[32];\n    memset(scratch, 0, sizeof(scratch));\n    MallocMessageBuilder builder(scratch);\n    auto node = builder.initRoot<schema::Node>();\n    node.setId(structTypeId);\n    node.setDisplayName(kj::str(\"(unknown type used in \", nodeName, \")\"));\n    auto structNode = node.initStruct();\n\n    switch (type.which()) {\n      case schema::Type::VOID:\n        structNode.setDataWordCount(0);\n        structNode.setPointerCount(0);\n        break;\n\n      case schema::Type::BOOL:\n        structNode.setDataWordCount(1);\n        structNode.setPointerCount(0);\n        break;\n\n      case schema::Type::INT8:\n      case schema::Type::UINT8:\n        structNode.setDataWordCount(1);\n        structNode.setPointerCount(0);\n        break;\n\n      case schema::Type::INT16:\n      case schema::Type::UINT16:\n      case schema::Type::ENUM:\n        structNode.setDataWordCount(1);\n        structNode.setPointerCount(0);\n        break;\n\n      case schema::Type::INT32:\n      case schema::Type::UINT32:\n      case schema::Type::FLOAT32:\n        structNode.setDataWordCount(1);\n        structNode.setPointerCount(0);\n        break;\n\n      case schema::Type::INT64:\n      case schema::Type::UINT64:\n      case schema::Type::FLOAT64:\n        structNode.setDataWordCount(1);\n        structNode.setPointerCount(0);\n        break;\n\n      case schema::Type::TEXT:\n      case schema::Type::DATA:\n      case schema::Type::LIST:\n      case schema::Type::STRUCT:\n      case schema::Type::INTERFACE:\n      case schema::Type::ANY_POINTER:\n        structNode.setDataWordCount(0);\n        structNode.setPointerCount(1);\n        break;\n    }\n\n    KJ_IF_MAYBE(s, matchSize) {\n      auto match = s->getStruct();\n      structNode.setDataWordCount(match.getDataWordCount());\n      structNode.setPointerCount(match.getPointerCount());\n    }\n\n    auto field = structNode.initFields(1)[0];\n    field.setName(\"member0\");\n    field.setCodeOrder(0);\n    auto slot = field.initSlot();\n    slot.setType(type);\n\n    KJ_IF_MAYBE(p, matchPosition) {\n      if (p->getOrdinal().isExplicit()) {\n        field.getOrdinal().setExplicit(p->getOrdinal().getExplicit());\n      } else {\n        field.getOrdinal().setImplicit();\n      }\n      auto matchSlot = p->getSlot();\n      slot.setOffset(matchSlot.getOffset());\n      slot.setDefaultValue(matchSlot.getDefaultValue());\n    } else {\n      field.getOrdinal().setExplicit(0);\n      slot.setOffset(0);\n\n      schema::Value::Builder value = slot.initDefaultValue();\n      switch (type.which()) {\n        case schema::Type::VOID: value.setVoid(); break;\n        case schema::Type::BOOL: value.setBool(false); break;\n        case schema::Type::INT8: value.setInt8(0); break;\n        case schema::Type::INT16: value.setInt16(0); break;\n        case schema::Type::INT32: value.setInt32(0); break;\n        case schema::Type::INT64: value.setInt64(0); break;\n        case schema::Type::UINT8: value.setUint8(0); break;\n        case schema::Type::UINT16: value.setUint16(0); break;\n        case schema::Type::UINT32: value.setUint32(0); break;\n        case schema::Type::UINT64: value.setUint64(0); break;\n        case schema::Type::FLOAT32: value.setFloat32(0); break;\n        case schema::Type::FLOAT64: value.setFloat64(0); break;\n        case schema::Type::ENUM: value.setEnum(0); break;\n        case schema::Type::TEXT: value.adoptText(Orphan<Text>()); break;\n        case schema::Type::DATA: value.adoptData(Orphan<Data>()); break;\n        case schema::Type::LIST: value.initList(); break;\n        case schema::Type::STRUCT: value.initStruct(); break;\n        case schema::Type::INTERFACE: value.setInterface(); break;\n        case schema::Type::ANY_POINTER: value.initAnyPointer(); break;\n      }\n    }\n\n    loader.load(node, true);\n  }\n\n  bool canUpgradeToData(const schema::Type::Reader& type) {\n    if (type.isText()) {\n      return true;\n    } else if (type.isList()) {\n      switch (type.getList().getElementType().which()) {\n        case schema::Type::INT8:\n        case schema::Type::UINT8:\n          return true;\n        default:\n          return false;\n      }\n    } else {\n      return false;\n    }\n  }",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "type.getList",
          "args": [],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getList",
          "args": [],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getList",
          "args": [],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.isList",
          "args": [],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "145-147",
          "snippet": "inline bool isList() {\n      return builder.isList();\n    }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline bool isList() {\n          return builder.isList();\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type.isText",
          "args": [],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.initAnyPointer",
          "args": [],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.setInterface",
          "args": [],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.initStruct",
          "args": [],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.initList",
          "args": [],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.adoptData",
          "args": [
            "Orphan<Data>()"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Orphan<Data>",
          "args": [],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "OrphanBuilder",
          "container": "OrphanBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "709-709",
          "snippet": "inline OrphanBuilder(): segment(nullptr), location(nullptr) { memset(&tag, 0, sizeof(tag)); }",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nOrphanBuilder {\n  inline OrphanBuilder(): segment(nullptr), location(nullptr) { memset(&tag, 0, sizeof(tag)); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.adoptText",
          "args": [
            "Orphan<Text>()"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.setEnum",
          "args": [
            "0"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.setFloat64",
          "args": [
            "0"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.setFloat32",
          "args": [
            "0"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.setUint64",
          "args": [
            "0"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.setUint32",
          "args": [
            "0"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.setUint16",
          "args": [
            "0"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.setUint8",
          "args": [
            "0"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.setInt64",
          "args": [
            "0"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.setInt32",
          "args": [
            "0"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.setInt16",
          "args": [
            "0"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.setInt8",
          "args": [
            "0"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.setBool",
          "args": [
            "false"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.setVoid",
          "args": [],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.initDefaultValue",
          "args": [],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.setOffset",
          "args": [
            "0"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getOrdinal",
          "args": [
            "0"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "getOrdinal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "451-461",
          "snippet": "uint getOrdinal(StructSchema::Field field) {\n  auto proto = field.getProto();\n  if (proto.getOrdinal().isExplicit()) {\n    return proto.getOrdinal().getExplicit();\n  }\n\n  KJ_ASSERT(proto.isGroup());\n\n  auto group = field.getType().asStruct();\n  return getOrdinal(group.getFields()[0]);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nuint getOrdinal(StructSchema::Field field) {\n  auto proto = field.getProto();\n  if (proto.getOrdinal().isExplicit()) {\n    return proto.getOrdinal().getExplicit();\n  }\n\n  KJ_ASSERT(proto.isGroup());\n\n  auto group = field.getType().asStruct();\n  return getOrdinal(group.getFields()[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "field.getOrdinal",
          "args": [],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "getOrdinal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "486-486",
          "snippet": "inline uint16_t getOrdinal() const { return ordinal; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline uint16_t getOrdinal() const { return ordinal; }"
        }
      },
      {
        "call_info": {
          "callee": "slot.setDefaultValue",
          "args": [
            "matchSlot.getDefaultValue()"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "matchSlot.getDefaultValue",
          "args": [],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.setOffset",
          "args": [
            "matchSlot.getOffset()"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "matchSlot.getOffset",
          "args": [],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->getSlot",
          "args": [],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.setType",
          "args": [
            "type"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.initSlot",
          "args": [],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.setCodeOrder",
          "args": [
            "0"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.setName",
          "args": [
            "\"member0\""
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.initFields",
          "args": [
            "1"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.setPointerCount",
          "args": [
            "match.getPointerCount()"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match.getPointerCount",
          "args": [],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.setDataWordCount",
          "args": [
            "match.getDataWordCount()"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match.getDataWordCount",
          "args": [],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s->getStruct",
          "args": [],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.setPointerCount",
          "args": [
            "1"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.setDataWordCount",
          "args": [
            "0"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.setPointerCount",
          "args": [
            "0"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.setDataWordCount",
          "args": [
            "1"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.setPointerCount",
          "args": [
            "0"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.setDataWordCount",
          "args": [
            "1"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.setPointerCount",
          "args": [
            "0"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.setDataWordCount",
          "args": [
            "1"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.setPointerCount",
          "args": [
            "0"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.setDataWordCount",
          "args": [
            "1"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.setPointerCount",
          "args": [
            "0"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.setDataWordCount",
          "args": [
            "1"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.setPointerCount",
          "args": [
            "0"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.setDataWordCount",
          "args": [
            "0"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.initStruct",
          "args": [],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.setDisplayName",
          "args": [
            "kj::str(\"(unknown type used in \", nodeName, \")\")"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"(unknown type used in \"",
            "nodeName",
            "\")\""
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.setId",
          "args": [
            "structTypeId"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initRoot<schema::Node>",
          "args": [],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "scratch",
            "0",
            "sizeof(scratch)"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "replacement.getInterface().getTypeId() == type.getInterface().getTypeId()",
            "\"type changed to incompatible interface type\""
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getInterface",
          "args": [],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getInterface",
          "args": [],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getInterface",
          "args": [],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getInterface",
          "args": [],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "replacement.getStruct().getTypeId() == type.getStruct().getTypeId()",
            "\"type changed to incompatible struct type\""
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getStruct",
          "args": [],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getStruct",
          "args": [],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getStruct",
          "args": [],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getStruct",
          "args": [],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "replacement.getEnum().getTypeId() == type.getEnum().getTypeId()",
            "\"type changed enum type\""
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getEnum",
          "args": [],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getEnum",
          "args": [],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getEnum",
          "args": [],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getEnum",
          "args": [],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkCompatibility",
          "args": [
            "type.getList().getElementType()",
            "replacement.getList().getElementType()",
            "ALLOW_UPGRADE_TO_STRUCT"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getList",
          "args": [],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getList",
          "args": [],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getList",
          "args": [],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getList",
          "args": [],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FAIL_VALIDATE_SCHEMA",
          "args": [
            "\"a type was changed\""
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkUpgradeToStruct",
          "args": [
            "type",
            "replacement.getStruct().getTypeId()"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getStruct",
          "args": [],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getStruct",
          "args": [],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.isStruct",
          "args": [],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "isStruct",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "142-144",
          "snippet": "inline bool isStruct() {\n      return builder.isStruct();\n    }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline bool isStruct() {\n          return builder.isStruct();\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkUpgradeToStruct",
          "args": [
            "replacement",
            "type.getStruct().getTypeId()"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getStruct",
          "args": [],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getStruct",
          "args": [],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsOlder",
          "args": [],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "canUpgradeToAnyPointer",
          "args": [
            "replacement"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "canUpgradeToAnyPointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
          "lines": "1171-1199",
          "snippet": "bool canUpgradeToAnyPointer(const schema::Type::Reader& type) {\n    switch (type.which()) {\n      case schema::Type::VOID:\n      case schema::Type::BOOL:\n      case schema::Type::INT8:\n      case schema::Type::INT16:\n      case schema::Type::INT32:\n      case schema::Type::INT64:\n      case schema::Type::UINT8:\n      case schema::Type::UINT16:\n      case schema::Type::UINT32:\n      case schema::Type::UINT64:\n      case schema::Type::FLOAT32:\n      case schema::Type::FLOAT64:\n      case schema::Type::ENUM:\n        return false;\n\n      case schema::Type::TEXT:\n      case schema::Type::DATA:\n      case schema::Type::LIST:\n      case schema::Type::STRUCT:\n      case schema::Type::INTERFACE:\n      case schema::Type::ANY_POINTER:\n        return true;\n    }\n\n    // Be lenient with unknown types.\n    return true;\n  }",
          "includes": [
            "#include <algorithm>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/exception.h>",
            "#include <kj/debug.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include <map>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nbool canUpgradeToAnyPointer(const schema::Type::Reader& type) {\n    switch (type.which()) {\n      case schema::Type::VOID:\n      case schema::Type::BOOL:\n      case schema::Type::INT8:\n      case schema::Type::INT16:\n      case schema::Type::INT32:\n      case schema::Type::INT64:\n      case schema::Type::UINT8:\n      case schema::Type::UINT16:\n      case schema::Type::UINT32:\n      case schema::Type::UINT64:\n      case schema::Type::FLOAT32:\n      case schema::Type::FLOAT64:\n      case schema::Type::ENUM:\n        return false;\n\n      case schema::Type::TEXT:\n      case schema::Type::DATA:\n      case schema::Type::LIST:\n      case schema::Type::STRUCT:\n      case schema::Type::INTERFACE:\n      case schema::Type::ANY_POINTER:\n        return true;\n    }\n\n    // Be lenient with unknown types.\n    return true;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "type.isAnyPointer",
          "args": [],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsNewer",
          "args": [],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.isAnyPointer",
          "args": [],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsOlder",
          "args": [],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "canUpgradeToData",
          "args": [
            "replacement"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.isData",
          "args": [],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsNewer",
          "args": [],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "canUpgradeToData",
          "args": [
            "type"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.isData",
          "args": [],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.which",
          "args": [],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "method.getResultStructType() == replacement.getResultStructType()",
            "\"Updated method has different results.\""
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getResultStructType",
          "args": [],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getResultStructType",
          "args": [],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "method.getParamStructType() == replacement.getParamStructType()",
            "\"Updated method has different parameters.\""
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getParamStructType",
          "args": [],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getParamStructType",
          "args": [],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_CONTEXT",
          "args": [
            "\"comparing method\"",
            "method.getName()"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getName",
          "args": [],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkCompatibility",
          "args": [
            "methods[i]",
            "replacementMethods[i]"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::min",
          "args": [
            "methods.size()",
            "replacementMethods.size()"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "473-475",
          "snippet": "auto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "replacementMethods.size",
          "args": [],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "replacementIsOlder",
          "args": [],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsNewer",
          "args": [],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getMethods",
          "args": [],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interfaceNode.getMethods",
          "args": [],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsNewer",
          "args": [],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsOlder",
          "args": [],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsOlder",
          "args": [],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementSuperclasses.end",
          "args": [],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      },
      {
        "call_info": {
          "callee": "replacementIsNewer",
          "args": [],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementSuperclasses.begin",
          "args": [],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "std::sort",
          "args": [
            "replacementSuperclasses.begin()",
            "replacementSuperclasses.end()"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::sort",
          "args": [
            "superclasses.begin()",
            "superclasses.end()"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementSuperclasses.add",
          "args": [
            "superclass.getId()"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "superclass.getId",
          "args": [],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "replacement.getSuperclasses",
          "args": [],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interfaceNode.getSuperclasses",
          "args": [],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsOlder",
          "args": [],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsNewer",
          "args": [],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getEnumerants",
          "args": [],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getEnumerants",
          "args": [],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumNode.getEnumerants",
          "args": [],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumNode.getEnumerants",
          "args": [],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "field.getGroup().getTypeId() == replacement.getGroup().getTypeId()",
            "\"group id changed\""
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getGroup",
          "args": [],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getGroup",
          "args": [],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getGroup",
          "args": [],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getGroup",
          "args": [],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkUpgradeToStruct",
          "args": [
            "replacement.getSlot().getType()",
            "field.getGroup().getTypeId()",
            "replacementNode",
            "replacement"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getGroup",
          "args": [],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getGroup",
          "args": [],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getSlot",
          "args": [],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getSlot",
          "args": [],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.which",
          "args": [],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkUpgradeToStruct",
          "args": [
            "slot.getType()",
            "replacement.getGroup().getTypeId()",
            "existingNode",
            "field"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getGroup",
          "args": [],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getGroup",
          "args": [],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.getType",
          "args": [],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "slot.getOffset() == replacementSlot.getOffset()",
            "\"field position changed\""
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementSlot.getOffset",
          "args": [],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.getOffset",
          "args": [],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkDefaultCompatibility",
          "args": [
            "slot.getDefaultValue()",
            "replacementSlot.getDefaultValue()"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "checkDefaultCompatibility",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
          "lines": "1201-1240",
          "snippet": "void checkDefaultCompatibility(const schema::Value::Reader& value,\n                                 const schema::Value::Reader& replacement) {\n    // Note that we test default compatibility only after testing type compatibility, and default\n    // values have already been validated as matching their types, so this should pass.\n    KJ_ASSERT(value.which() == replacement.which()) {\n      compatibility = INCOMPATIBLE;\n      return;\n    }\n\n    switch (value.which()) {\n#define HANDLE_TYPE(discrim, name) \\\n      case schema::Value::discrim: \\\n        VALIDATE_SCHEMA(value.get##name() == replacement.get##name(), \"default value changed\"); \\\n        break;\n      HANDLE_TYPE(VOID, Void);\n      HANDLE_TYPE(BOOL, Bool);\n      HANDLE_TYPE(INT8, Int8);\n      HANDLE_TYPE(INT16, Int16);\n      HANDLE_TYPE(INT32, Int32);\n      HANDLE_TYPE(INT64, Int64);\n      HANDLE_TYPE(UINT8, Uint8);\n      HANDLE_TYPE(UINT16, Uint16);\n      HANDLE_TYPE(UINT32, Uint32);\n      HANDLE_TYPE(UINT64, Uint64);\n      HANDLE_TYPE(FLOAT32, Float32);\n      HANDLE_TYPE(FLOAT64, Float64);\n      HANDLE_TYPE(ENUM, Enum);\n#undef HANDLE_TYPE\n\n      case schema::Value::TEXT:\n      case schema::Value::DATA:\n      case schema::Value::LIST:\n      case schema::Value::STRUCT:\n      case schema::Value::INTERFACE:\n      case schema::Value::ANY_POINTER:\n        // It's not a big deal if default values for pointers change, and it would be difficult for\n        // us to compare these defaults here, so just let it slide.\n        break;\n    }\n  }",
          "includes": [
            "#include <algorithm>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/exception.h>",
            "#include <kj/debug.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include <map>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid checkDefaultCompatibility(const schema::Value::Reader& value,\n                                 const schema::Value::Reader& replacement) {\n    // Note that we test default compatibility only after testing type compatibility, and default\n    // values have already been validated as matching their types, so this should pass.\n    KJ_ASSERT(value.which() == replacement.which()) {\n      compatibility = INCOMPATIBLE;\n      return;\n    }\n\n    switch (value.which()) {\n#define HANDLE_TYPE(discrim, name) \\\n      case schema::Value::discrim: \\\n        VALIDATE_SCHEMA(value.get##name() == replacement.get##name(), \"default value changed\"); \\\n        break;\n      HANDLE_TYPE(VOID, Void);\n      HANDLE_TYPE(BOOL, Bool);\n      HANDLE_TYPE(INT8, Int8);\n      HANDLE_TYPE(INT16, Int16);\n      HANDLE_TYPE(INT32, Int32);\n      HANDLE_TYPE(INT64, Int64);\n      HANDLE_TYPE(UINT8, Uint8);\n      HANDLE_TYPE(UINT16, Uint16);\n      HANDLE_TYPE(UINT32, Uint32);\n      HANDLE_TYPE(UINT64, Uint64);\n      HANDLE_TYPE(FLOAT32, Float32);\n      HANDLE_TYPE(FLOAT64, Float64);\n      HANDLE_TYPE(ENUM, Enum);\n#undef HANDLE_TYPE\n\n      case schema::Value::TEXT:\n      case schema::Value::DATA:\n      case schema::Value::LIST:\n      case schema::Value::STRUCT:\n      case schema::Value::INTERFACE:\n      case schema::Value::ANY_POINTER:\n        // It's not a big deal if default values for pointers change, and it would be difficult for\n        // us to compare these defaults here, so just let it slide.\n        break;\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "replacementSlot.getDefaultValue",
          "args": [],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.getDefaultValue",
          "args": [],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkCompatibility",
          "args": [
            "slot.getType()",
            "replacementSlot.getType()",
            "NO_UPGRADE_TO_STRUCT"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getSlot",
          "args": [],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.which",
          "args": [],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getSlot",
          "args": [],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.which",
          "args": [],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "discriminant == replacementDiscriminant",
            "\"Field discriminant changed.\""
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getDiscriminantValue",
          "args": [],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hasDiscriminantValue",
          "args": [
            "replacement"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "hasDiscriminantValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
          "lines": "78-80",
          "snippet": "bool hasDiscriminantValue(const schema::Field::Reader& reader) {\n  return reader.getDiscriminantValue() != schema::Field::NO_DISCRIMINANT;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/exception.h>",
            "#include <kj/debug.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include <map>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nbool hasDiscriminantValue(const schema::Field::Reader& reader) {\n  return reader.getDiscriminantValue() != schema::Field::NO_DISCRIMINANT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "field.getDiscriminantValue",
          "args": [],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_CONTEXT",
          "args": [
            "\"comparing struct field\"",
            "field.getName()"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getName",
          "args": [],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsNewer",
          "args": [],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getIsGroup",
          "args": [],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsOlder",
          "args": [],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "replacementScopeId == scopeId",
            "\"group node's scope changed\""
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getIsGroup",
          "args": [],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getIsGroup",
          "args": [],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkCompatibility",
          "args": [
            "fields[i]",
            "replacementFields[i]"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsOlder",
          "args": [],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsNewer",
          "args": [],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getFields",
          "args": [],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getFields",
          "args": [],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "replacement.getDiscriminantOffset() == structNode.getDiscriminantOffset()",
            "\"union discriminant position changed\""
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getDiscriminantOffset",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getDiscriminantOffset",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getDiscriminantCount",
          "args": [],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getDiscriminantCount",
          "args": [],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsOlder",
          "args": [],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getDiscriminantCount",
          "args": [],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getDiscriminantCount",
          "args": [],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsNewer",
          "args": [],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getDiscriminantCount",
          "args": [],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getDiscriminantCount",
          "args": [],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsOlder",
          "args": [],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getPointerCount",
          "args": [],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getPointerCount",
          "args": [],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsNewer",
          "args": [],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getPointerCount",
          "args": [],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getPointerCount",
          "args": [],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsOlder",
          "args": [],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getDataWordCount",
          "args": [],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getDataWordCount",
          "args": [],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsNewer",
          "args": [],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getDataWordCount",
          "args": [],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getDataWordCount",
          "args": [],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkCompatibility",
          "args": [
            "node.getAnnotation()",
            "replacement.getAnnotation()"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getAnnotation",
          "args": [],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getAnnotation",
          "args": [],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkCompatibility",
          "args": [
            "node.getConst()",
            "replacement.getConst()"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getConst",
          "args": [],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getConst",
          "args": [],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkCompatibility",
          "args": [
            "node.getInterface()",
            "replacement.getInterface()"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getInterface",
          "args": [],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getInterface",
          "args": [],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkCompatibility",
          "args": [
            "node.getEnum()",
            "replacement.getEnum()"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getEnum",
          "args": [],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getEnum",
          "args": [],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkCompatibility",
          "args": [
            "node.getStruct()",
            "replacement.getStruct()",
            "node.getScopeId()",
            "replacement.getScopeId()"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getScopeId",
          "args": [],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "getScopeId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "778-778",
          "snippet": "inline uint64_t getScopeId() { return leafId; }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t leafId;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t leafId;\n\ninline uint64_t getScopeId() { return leafId; }"
        }
      },
      {
        "call_info": {
          "callee": "replacement.getStruct",
          "args": [],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getStruct",
          "args": [],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verifyVoid",
          "args": [
            "node.getFile()"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "verifyVoid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
          "lines": "231-231",
          "snippet": "inline static void verifyVoid(Void value) {}",
          "includes": [
            "#include <algorithm>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/exception.h>",
            "#include <kj/debug.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include <map>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\ninline static void verifyVoid(Void value) {}"
        }
      },
      {
        "call_info": {
          "callee": "node.getFile",
          "args": [],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.which",
          "args": [],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsOlder",
          "args": [],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getParameters",
          "args": [],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getParameters",
          "args": [],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getParameters",
          "args": [],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getParameters",
          "args": [],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacementIsNewer",
          "args": [],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getParameters",
          "args": [],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getParameters",
          "args": [],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getParameters",
          "args": [],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.getParameters",
          "args": [],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "node.which() == replacement.which()",
            "\"kind of declaration changed\""
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.which",
          "args": [],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.which",
          "args": [],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FAIL_VALIDATE_SCHEMA",
          "args": [
            "\"Schema node contains some changes that are upgrades and some \"\n            \"that are downgrades.  All changes must be in the same direction for compatibility.\""
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FAIL_VALIDATE_SCHEMA",
          "args": [
            "\"Schema node contains some changes that are upgrades and some \"\n            \"that are downgrades.  All changes must be in the same direction for compatibility.\""
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkCompatibility",
          "args": [
            "existingNode",
            "replacement"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "existingNode.getDisplayName",
          "args": [],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "getDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "416-418",
          "snippet": "kj::StringPtr getDisplayName() const override {\n    return displayName;\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::StringPtr getDisplayName() const override {\n    return displayName;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "existingNode.getId() == replacement.getId()"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_CONTEXT",
          "args": [
            "\"checking compatibility with previously-loaded node of the same id\"",
            "existingNode.getDisplayName()"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nclass SchemaLoader::CompatibilityChecker {\npublic:\n  CompatibilityChecker(SchemaLoader::Impl& loader): loader(loader) {}\n\n  bool shouldReplace(const schema::Node::Reader& existingNode,\n                     const schema::Node::Reader& replacement,\n                     bool preferReplacementIfEquivalent) {\n    this->existingNode = existingNode;\n    this->replacementNode = replacement;\n\n    KJ_CONTEXT(\"checking compatibility with previously-loaded node of the same id\",\n               existingNode.getDisplayName());\n\n    KJ_DREQUIRE(existingNode.getId() == replacement.getId());\n\n    nodeName = existingNode.getDisplayName();\n    compatibility = EQUIVALENT;\n\n    checkCompatibility(existingNode, replacement);\n\n    // Prefer the newer schema.\n    return preferReplacementIfEquivalent ? compatibility != OLDER : compatibility == NEWER;\n  }\n\nprivate:\n  SchemaLoader::Impl& loader;\n  Text::Reader nodeName;\n  schema::Node::Reader existingNode;\n  schema::Node::Reader replacementNode;\n\n  enum Compatibility {\n    EQUIVALENT,\n    OLDER,\n    NEWER,\n    INCOMPATIBLE\n  };\n  Compatibility compatibility;\n\n#define VALIDATE_SCHEMA(condition, ...) \\\n  KJ_REQUIRE(condition, ##__VA_ARGS__) { compatibility = INCOMPATIBLE; return; }\n#define FAIL_VALIDATE_SCHEMA(...) \\\n  KJ_FAIL_REQUIRE(__VA_ARGS__) { compatibility = INCOMPATIBLE; return; }\n\n  void replacementIsNewer() {\n    switch (compatibility) {\n      case EQUIVALENT:\n        compatibility = NEWER;\n        break;\n      case OLDER:\n        FAIL_VALIDATE_SCHEMA(\"Schema node contains some changes that are upgrades and some \"\n            \"that are downgrades.  All changes must be in the same direction for compatibility.\");\n        break;\n      case NEWER:\n        break;\n      case INCOMPATIBLE:\n        break;\n    }\n  }\n\n  void replacementIsOlder() {\n    switch (compatibility) {\n      case EQUIVALENT:\n        compatibility = OLDER;\n        break;\n      case OLDER:\n        break;\n      case NEWER:\n        FAIL_VALIDATE_SCHEMA(\"Schema node contains some changes that are upgrades and some \"\n            \"that are downgrades.  All changes must be in the same direction for compatibility.\");\n        break;\n      case INCOMPATIBLE:\n        break;\n    }\n  }\n\n  void checkCompatibility(const schema::Node::Reader& node,\n                          const schema::Node::Reader& replacement) {\n    // Returns whether `replacement` is equivalent, older than, newer than, or incompatible with\n    // `node`.  If exceptions are enabled, this will throw an exception on INCOMPATIBLE.\n\n    VALIDATE_SCHEMA(node.which() == replacement.which(),\n                    \"kind of declaration changed\");\n\n    // No need to check compatibility of most of the non-body parts of the node:\n    // - Arbitrary renaming and moving between scopes is allowed.\n    // - Annotations are ignored for compatibility purposes.\n\n    if (replacement.getParameters().size() > node.getParameters().size()) {\n      replacementIsNewer();\n    } else if (replacement.getParameters().size() < node.getParameters().size()) {\n      replacementIsOlder();\n    }\n\n    switch (node.which()) {\n      case schema::Node::FILE:\n        verifyVoid(node.getFile());\n        break;\n      case schema::Node::STRUCT:\n        checkCompatibility(node.getStruct(), replacement.getStruct(),\n                           node.getScopeId(), replacement.getScopeId());\n        break;\n      case schema::Node::ENUM:\n        checkCompatibility(node.getEnum(), replacement.getEnum());\n        break;\n      case schema::Node::INTERFACE:\n        checkCompatibility(node.getInterface(), replacement.getInterface());\n        break;\n      case schema::Node::CONST:\n        checkCompatibility(node.getConst(), replacement.getConst());\n        break;\n      case schema::Node::ANNOTATION:\n        checkCompatibility(node.getAnnotation(), replacement.getAnnotation());\n        break;\n    }\n  }\n\n  void checkCompatibility(const schema::Node::Struct::Reader& structNode,\n                          const schema::Node::Struct::Reader& replacement,\n                          uint64_t scopeId, uint64_t replacementScopeId) {\n    if (replacement.getDataWordCount() > structNode.getDataWordCount()) {\n      replacementIsNewer();\n    } else if (replacement.getDataWordCount() < structNode.getDataWordCount()) {\n      replacementIsOlder();\n    }\n    if (replacement.getPointerCount() > structNode.getPointerCount()) {\n      replacementIsNewer();\n    } else if (replacement.getPointerCount() < structNode.getPointerCount()) {\n      replacementIsOlder();\n    }\n    if (replacement.getDiscriminantCount() > structNode.getDiscriminantCount()) {\n      replacementIsNewer();\n    } else if (replacement.getDiscriminantCount() < structNode.getDiscriminantCount()) {\n      replacementIsOlder();\n    }\n\n    if (replacement.getDiscriminantCount() > 0 && structNode.getDiscriminantCount() > 0) {\n      VALIDATE_SCHEMA(replacement.getDiscriminantOffset() == structNode.getDiscriminantOffset(),\n                      \"union discriminant position changed\");\n    }\n\n    // The shared members should occupy corresponding positions in the member lists, since the\n    // lists are sorted by ordinal.\n    auto fields = structNode.getFields();\n    auto replacementFields = replacement.getFields();\n    uint count = std::min(fields.size(), replacementFields.size());\n\n    if (replacementFields.size() > fields.size()) {\n      replacementIsNewer();\n    } else if (replacementFields.size() < fields.size()) {\n      replacementIsOlder();\n    }\n\n    for (uint i = 0; i < count; i++) {\n      checkCompatibility(fields[i], replacementFields[i]);\n    }\n\n    // For the moment, we allow \"upgrading\" from non-group to group, mainly so that the\n    // placeholders we generate for group parents (which in the absence of more info, we assume to\n    // be non-groups) can be replaced with groups.\n    //\n    // TODO(cleanup):  The placeholder approach is really breaking down.  Maybe we need to maintain\n    //   a list of expectations for nodes we haven't loaded yet.\n    if (structNode.getIsGroup()) {\n      if (replacement.getIsGroup()) {\n        VALIDATE_SCHEMA(replacementScopeId == scopeId, \"group node's scope changed\");\n      } else {\n        replacementIsOlder();\n      }\n    } else {\n      if (replacement.getIsGroup()) {\n        replacementIsNewer();\n      }\n    }\n  }\n\n  void checkCompatibility(const schema::Field::Reader& field,\n                          const schema::Field::Reader& replacement) {\n    KJ_CONTEXT(\"comparing struct field\", field.getName());\n\n    // A field that is initially not in a union can be upgraded to be in one, as long as it has\n    // discriminant 0.\n    uint discriminant = hasDiscriminantValue(field) ? field.getDiscriminantValue() : 0;\n    uint replacementDiscriminant =\n        hasDiscriminantValue(replacement) ? replacement.getDiscriminantValue() : 0;\n    VALIDATE_SCHEMA(discriminant == replacementDiscriminant, \"Field discriminant changed.\");\n\n    switch (field.which()) {\n      case schema::Field::SLOT: {\n        auto slot = field.getSlot();\n\n        switch (replacement.which()) {\n          case schema::Field::SLOT: {\n            auto replacementSlot = replacement.getSlot();\n\n            checkCompatibility(slot.getType(), replacementSlot.getType(),\n                               NO_UPGRADE_TO_STRUCT);\n            checkDefaultCompatibility(slot.getDefaultValue(),\n                                      replacementSlot.getDefaultValue());\n\n            VALIDATE_SCHEMA(slot.getOffset() == replacementSlot.getOffset(),\n                            \"field position changed\");\n            break;\n          }\n          case schema::Field::GROUP:\n            checkUpgradeToStruct(slot.getType(), replacement.getGroup().getTypeId(),\n                                 existingNode, field);\n            break;\n        }\n\n        break;\n      }\n\n      case schema::Field::GROUP:\n        switch (replacement.which()) {\n          case schema::Field::SLOT:\n            checkUpgradeToStruct(replacement.getSlot().getType(), field.getGroup().getTypeId(),\n                                 replacementNode, replacement);\n            break;\n          case schema::Field::GROUP:\n            VALIDATE_SCHEMA(field.getGroup().getTypeId() == replacement.getGroup().getTypeId(),\n                            \"group id changed\");\n            break;\n        }\n        break;\n    }\n  }\n\n  void checkCompatibility(const schema::Node::Enum::Reader& enumNode,\n                          const schema::Node::Enum::Reader& replacement) {\n    uint size = enumNode.getEnumerants().size();\n    uint replacementSize = replacement.getEnumerants().size();\n    if (replacementSize > size) {\n      replacementIsNewer();\n    } else if (replacementSize < size) {\n      replacementIsOlder();\n    }\n  }\n\n  void checkCompatibility(const schema::Node::Interface::Reader& interfaceNode,\n                          const schema::Node::Interface::Reader& replacement) {\n    {\n      // Check superclasses.\n\n      kj::Vector<uint64_t> superclasses;\n      kj::Vector<uint64_t> replacementSuperclasses;\n      for (auto superclass: interfaceNode.getSuperclasses()) {\n        superclasses.add(superclass.getId());\n      }\n      for (auto superclass: replacement.getSuperclasses()) {\n        replacementSuperclasses.add(superclass.getId());\n      }\n      std::sort(superclasses.begin(), superclasses.end());\n      std::sort(replacementSuperclasses.begin(), replacementSuperclasses.end());\n\n      auto iter = superclasses.begin();\n      auto replacementIter = replacementSuperclasses.begin();\n\n      while (iter != superclasses.end() || replacementIter != replacementSuperclasses.end()) {\n        if (iter == superclasses.end()) {\n          replacementIsNewer();\n          break;\n        } else if (replacementIter == replacementSuperclasses.end()) {\n          replacementIsOlder();\n          break;\n        } else if (*iter < *replacementIter) {\n          replacementIsOlder();\n          ++iter;\n        } else if (*iter > *replacementIter) {\n          replacementIsNewer();\n          ++replacementIter;\n        } else {\n          ++iter;\n          ++replacementIter;\n        }\n      }\n    }\n\n    auto methods = interfaceNode.getMethods();\n    auto replacementMethods = replacement.getMethods();\n\n    if (replacementMethods.size() > methods.size()) {\n      replacementIsNewer();\n    } else if (replacementMethods.size() < methods.size()) {\n      replacementIsOlder();\n    }\n\n    uint count = std::min(methods.size(), replacementMethods.size());\n\n    for (uint i = 0; i < count; i++) {\n      checkCompatibility(methods[i], replacementMethods[i]);\n    }\n  }\n\n  void checkCompatibility(const schema::Method::Reader& method,\n                          const schema::Method::Reader& replacement) {\n    KJ_CONTEXT(\"comparing method\", method.getName());\n\n    // TODO(someday):  Allow named parameter list to be replaced by compatible struct type.\n    VALIDATE_SCHEMA(method.getParamStructType() == replacement.getParamStructType(),\n                    \"Updated method has different parameters.\");\n    VALIDATE_SCHEMA(method.getResultStructType() == replacement.getResultStructType(),\n                    \"Updated method has different results.\");\n  }\n\n  void checkCompatibility(const schema::Node::Const::Reader& constNode,\n                          const schema::Node::Const::Reader& replacement) {\n    // Who cares?  These don't appear on the wire.\n  }\n\n  void checkCompatibility(const schema::Node::Annotation::Reader& annotationNode,\n                          const schema::Node::Annotation::Reader& replacement) {\n    // Who cares?  These don't appear on the wire.\n  }\n\n  enum UpgradeToStructMode {\n    ALLOW_UPGRADE_TO_STRUCT,\n    NO_UPGRADE_TO_STRUCT\n  };\n\n  void checkCompatibility(const schema::Type::Reader& type,\n                          const schema::Type::Reader& replacement,\n                          UpgradeToStructMode upgradeToStructMode) {\n    if (replacement.which() != type.which()) {\n      // Check for allowed \"upgrade\" to Data or AnyPointer.\n      if (replacement.isData() && canUpgradeToData(type)) {\n        replacementIsNewer();\n        return;\n      } else if (type.isData() && canUpgradeToData(replacement)) {\n        replacementIsOlder();\n        return;\n      } else if (replacement.isAnyPointer() && canUpgradeToAnyPointer(type)) {\n        replacementIsNewer();\n        return;\n      } else if (type.isAnyPointer() && canUpgradeToAnyPointer(replacement)) {\n        replacementIsOlder();\n        return;\n      }\n\n      if (upgradeToStructMode == ALLOW_UPGRADE_TO_STRUCT) {\n        if (type.isStruct()) {\n          checkUpgradeToStruct(replacement, type.getStruct().getTypeId());\n          return;\n        } else if (replacement.isStruct()) {\n          checkUpgradeToStruct(type, replacement.getStruct().getTypeId());\n          return;\n        }\n      }\n\n      FAIL_VALIDATE_SCHEMA(\"a type was changed\");\n    }\n\n    switch (type.which()) {\n      case schema::Type::VOID:\n      case schema::Type::BOOL:\n      case schema::Type::INT8:\n      case schema::Type::INT16:\n      case schema::Type::INT32:\n      case schema::Type::INT64:\n      case schema::Type::UINT8:\n      case schema::Type::UINT16:\n      case schema::Type::UINT32:\n      case schema::Type::UINT64:\n      case schema::Type::FLOAT32:\n      case schema::Type::FLOAT64:\n      case schema::Type::TEXT:\n      case schema::Type::DATA:\n      case schema::Type::ANY_POINTER:\n        return;\n\n      case schema::Type::LIST:\n        checkCompatibility(type.getList().getElementType(), replacement.getList().getElementType(),\n                           ALLOW_UPGRADE_TO_STRUCT);\n        return;\n\n      case schema::Type::ENUM:\n        VALIDATE_SCHEMA(replacement.getEnum().getTypeId() == type.getEnum().getTypeId(),\n                        \"type changed enum type\");\n        return;\n\n      case schema::Type::STRUCT:\n        // TODO(someday):  If the IDs don't match, we should compare the two structs for\n        //   compatibility.  This is tricky, though, because the new type's target may not yet be\n        //   loaded.  In that case we could take the old type, make a copy of it, assign the new\n        //   ID to the copy, and load() that.  That forces any struct type loaded for that ID to\n        //   be compatible.  However, that has another problem, which is that it could be that the\n        //   whole reason the type was replaced was to fork that type, and so an incompatibility\n        //   could be very much expected.  This could be a rat hole...\n        VALIDATE_SCHEMA(replacement.getStruct().getTypeId() == type.getStruct().getTypeId(),\n                        \"type changed to incompatible struct type\");\n        return;\n\n      case schema::Type::INTERFACE:\n        VALIDATE_SCHEMA(replacement.getInterface().getTypeId() == type.getInterface().getTypeId(),\n                        \"type changed to incompatible interface type\");\n        return;\n    }\n\n    // We assume unknown types (from newer versions of Cap'n Proto?) are equivalent.\n  }\n\n  void checkUpgradeToStruct(const schema::Type::Reader& type, uint64_t structTypeId,\n                            kj::Maybe<schema::Node::Reader> matchSize = nullptr,\n                            kj::Maybe<schema::Field::Reader> matchPosition = nullptr) {\n    // We can't just look up the target struct and check it because it may not have been loaded\n    // yet.  Instead, we contrive a struct that looks like what we want and load() that, which\n    // guarantees that any incompatibility will be caught either now or when the real version of\n    // that struct is loaded.\n\n    word scratch[32];\n    memset(scratch, 0, sizeof(scratch));\n    MallocMessageBuilder builder(scratch);\n    auto node = builder.initRoot<schema::Node>();\n    node.setId(structTypeId);\n    node.setDisplayName(kj::str(\"(unknown type used in \", nodeName, \")\"));\n    auto structNode = node.initStruct();\n\n    switch (type.which()) {\n      case schema::Type::VOID:\n        structNode.setDataWordCount(0);\n        structNode.setPointerCount(0);\n        break;\n\n      case schema::Type::BOOL:\n        structNode.setDataWordCount(1);\n        structNode.setPointerCount(0);\n        break;\n\n      case schema::Type::INT8:\n      case schema::Type::UINT8:\n        structNode.setDataWordCount(1);\n        structNode.setPointerCount(0);\n        break;\n\n      case schema::Type::INT16:\n      case schema::Type::UINT16:\n      case schema::Type::ENUM:\n        structNode.setDataWordCount(1);\n        structNode.setPointerCount(0);\n        break;\n\n      case schema::Type::INT32:\n      case schema::Type::UINT32:\n      case schema::Type::FLOAT32:\n        structNode.setDataWordCount(1);\n        structNode.setPointerCount(0);\n        break;\n\n      case schema::Type::INT64:\n      case schema::Type::UINT64:\n      case schema::Type::FLOAT64:\n        structNode.setDataWordCount(1);\n        structNode.setPointerCount(0);\n        break;\n\n      case schema::Type::TEXT:\n      case schema::Type::DATA:\n      case schema::Type::LIST:\n      case schema::Type::STRUCT:\n      case schema::Type::INTERFACE:\n      case schema::Type::ANY_POINTER:\n        structNode.setDataWordCount(0);\n        structNode.setPointerCount(1);\n        break;\n    }\n\n    KJ_IF_MAYBE(s, matchSize) {\n      auto match = s->getStruct();\n      structNode.setDataWordCount(match.getDataWordCount());\n      structNode.setPointerCount(match.getPointerCount());\n    }\n\n    auto field = structNode.initFields(1)[0];\n    field.setName(\"member0\");\n    field.setCodeOrder(0);\n    auto slot = field.initSlot();\n    slot.setType(type);\n\n    KJ_IF_MAYBE(p, matchPosition) {\n      if (p->getOrdinal().isExplicit()) {\n        field.getOrdinal().setExplicit(p->getOrdinal().getExplicit());\n      } else {\n        field.getOrdinal().setImplicit();\n      }\n      auto matchSlot = p->getSlot();\n      slot.setOffset(matchSlot.getOffset());\n      slot.setDefaultValue(matchSlot.getDefaultValue());\n    } else {\n      field.getOrdinal().setExplicit(0);\n      slot.setOffset(0);\n\n      schema::Value::Builder value = slot.initDefaultValue();\n      switch (type.which()) {\n        case schema::Type::VOID: value.setVoid(); break;\n        case schema::Type::BOOL: value.setBool(false); break;\n        case schema::Type::INT8: value.setInt8(0); break;\n        case schema::Type::INT16: value.setInt16(0); break;\n        case schema::Type::INT32: value.setInt32(0); break;\n        case schema::Type::INT64: value.setInt64(0); break;\n        case schema::Type::UINT8: value.setUint8(0); break;\n        case schema::Type::UINT16: value.setUint16(0); break;\n        case schema::Type::UINT32: value.setUint32(0); break;\n        case schema::Type::UINT64: value.setUint64(0); break;\n        case schema::Type::FLOAT32: value.setFloat32(0); break;\n        case schema::Type::FLOAT64: value.setFloat64(0); break;\n        case schema::Type::ENUM: value.setEnum(0); break;\n        case schema::Type::TEXT: value.adoptText(Orphan<Text>()); break;\n        case schema::Type::DATA: value.adoptData(Orphan<Data>()); break;\n        case schema::Type::LIST: value.initList(); break;\n        case schema::Type::STRUCT: value.initStruct(); break;\n        case schema::Type::INTERFACE: value.setInterface(); break;\n        case schema::Type::ANY_POINTER: value.initAnyPointer(); break;\n      }\n    }\n\n    loader.load(node, true);\n  }\n\n  bool canUpgradeToData(const schema::Type::Reader& type) {\n    if (type.isText()) {\n      return true;\n    } else if (type.isList()) {\n      switch (type.getList().getElementType().which()) {\n        case schema::Type::INT8:\n        case schema::Type::UINT8:\n          return true;\n        default:\n          return false;\n      }\n    } else {\n      return false;\n    }\n  }"
  },
  {
    "function_name": "validateTypeId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "617-630",
    "snippet": "void validateTypeId(uint64_t id, schema::Node::Which expectedKind) {\n    _::RawSchema* existing = loader.tryGet(id).schema;\n    if (existing != nullptr) {\n      auto node = readMessageUnchecked<schema::Node>(existing->encodedNode);\n      VALIDATE_SCHEMA(node.which() == expectedKind,\n          \"expected a different kind of node for this ID\",\n          id, (uint)expectedKind, (uint)node.which(), node.getDisplayName());\n      dependencies.insert(std::make_pair(id, existing));\n      return;\n    }\n\n    dependencies.insert(std::make_pair(id, loader.loadEmpty(\n        id, kj::str(\"(unknown type used by \", nodeName , \")\"), expectedKind, true)));\n  }",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dependencies.insert",
          "args": [
            "std::make_pair(id, loader.loadEmpty(\n        id, kj::str(\"(unknown type used by \", nodeName , \")\"), expectedKind, true))"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "id",
            "loader.loadEmpty(\n        id, kj::str(\"(unknown type used by \", nodeName , \")\"), expectedKind, true)"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loader.loadEmpty",
          "args": [
            "id",
            "kj::str(\"(unknown type used by \", nodeName , \")\")",
            "expectedKind",
            "true"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"(unknown type used by \"",
            "nodeName",
            "\")\""
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dependencies.insert",
          "args": [
            "std::make_pair(id, existing)"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "id",
            "existing"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "node.which() == expectedKind",
            "\"expected a different kind of node for this ID\"",
            "id",
            "(uint)expectedKind",
            "(uint)node.which()",
            "node.getDisplayName()"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getDisplayName",
          "args": [],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "getDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "416-418",
          "snippet": "kj::StringPtr getDisplayName() const override {\n    return displayName;\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::StringPtr getDisplayName() const override {\n    return displayName;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "node.which",
          "args": [],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.which",
          "args": [],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readMessageUnchecked<schema::Node>",
          "args": [
            "existing->encodedNode"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "readMessageUnchecked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.h",
          "lines": "466-468",
          "snippet": "typename RootType::Reader readMessageUnchecked(const word* data) {\n  return AnyPointer::Reader(_::PointerReader::getRootUnchecked(data)).getAs<RootType>();\n}",
          "includes": [
            "#include \"any.h\"",
            "#include \"layout.h\"",
            "#include \"common.h\"",
            "#include <kj/mutex.h>",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"any.h\"\n#include \"layout.h\"\n#include \"common.h\"\n#include <kj/mutex.h>\n#include <kj/memory.h>\n#include <kj/common.h>\n\ntypename RootType::Reader readMessageUnchecked(const word* data) {\n  return AnyPointer::Reader(_::PointerReader::getRootUnchecked(data)).getAs<RootType>();\n}"
        }
      },
      {
        "call_info": {
          "callee": "loader.tryGet",
          "args": [
            "id"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid validateTypeId(uint64_t id, schema::Node::Which expectedKind) {\n    _::RawSchema* existing = loader.tryGet(id).schema;\n    if (existing != nullptr) {\n      auto node = readMessageUnchecked<schema::Node>(existing->encodedNode);\n      VALIDATE_SCHEMA(node.which() == expectedKind,\n          \"expected a different kind of node for this ID\",\n          id, (uint)expectedKind, (uint)node.which(), node.getDisplayName());\n      dependencies.insert(std::make_pair(id, existing));\n      return;\n    }\n\n    dependencies.insert(std::make_pair(id, loader.loadEmpty(\n        id, kj::str(\"(unknown type used by \", nodeName , \")\"), expectedKind, true)));\n  }"
  },
  {
    "function_name": "validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "565-615",
    "snippet": "void validate(const schema::Brand::Reader& brand) {\n    for (auto scope: brand.getScopes()) {\n      switch (scope.which()) {\n        case schema::Brand::Scope::BIND:\n          for (auto binding: scope.getBind()) {\n            switch (binding.which()) {\n              case schema::Brand::Binding::UNBOUND:\n                break;\n              case schema::Brand::Binding::TYPE: {\n                auto type = binding.getType();\n                validate(type);\n                bool isPointer = true;\n                switch (type.which()) {\n                  case schema::Type::VOID:\n                  case schema::Type::BOOL:\n                  case schema::Type::INT8:\n                  case schema::Type::INT16:\n                  case schema::Type::INT32:\n                  case schema::Type::INT64:\n                  case schema::Type::UINT8:\n                  case schema::Type::UINT16:\n                  case schema::Type::UINT32:\n                  case schema::Type::UINT64:\n                  case schema::Type::FLOAT32:\n                  case schema::Type::FLOAT64:\n                  case schema::Type::ENUM:\n                    isPointer = false;\n                    break;\n\n                  case schema::Type::TEXT:\n                  case schema::Type::DATA:\n                  case schema::Type::ANY_POINTER:\n                  case schema::Type::STRUCT:\n                  case schema::Type::INTERFACE:\n                  case schema::Type::LIST:\n                    isPointer = true;\n                    break;\n                }\n                VALIDATE_SCHEMA(isPointer,\n                    \"generic type parameter must be a pointer type\", type);\n\n                break;\n              }\n            }\n          }\n          break;\n        case schema::Brand::Scope::INHERIT:\n          break;\n      }\n    }\n  }",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "isPointer",
            "\"generic type parameter must be a pointer type\"",
            "type"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "binding.getType",
          "args": [],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "binding.which",
          "args": [],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scope.getBind",
          "args": [],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scope.which",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brand.getScopes",
          "args": [],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid validate(const schema::Brand::Reader& brand) {\n    for (auto scope: brand.getScopes()) {\n      switch (scope.which()) {\n        case schema::Brand::Scope::BIND:\n          for (auto binding: scope.getBind()) {\n            switch (binding.which()) {\n              case schema::Brand::Binding::UNBOUND:\n                break;\n              case schema::Brand::Binding::TYPE: {\n                auto type = binding.getType();\n                validate(type);\n                bool isPointer = true;\n                switch (type.which()) {\n                  case schema::Type::VOID:\n                  case schema::Type::BOOL:\n                  case schema::Type::INT8:\n                  case schema::Type::INT16:\n                  case schema::Type::INT32:\n                  case schema::Type::INT64:\n                  case schema::Type::UINT8:\n                  case schema::Type::UINT16:\n                  case schema::Type::UINT32:\n                  case schema::Type::UINT64:\n                  case schema::Type::FLOAT32:\n                  case schema::Type::FLOAT64:\n                  case schema::Type::ENUM:\n                    isPointer = false;\n                    break;\n\n                  case schema::Type::TEXT:\n                  case schema::Type::DATA:\n                  case schema::Type::ANY_POINTER:\n                  case schema::Type::STRUCT:\n                  case schema::Type::INTERFACE:\n                  case schema::Type::LIST:\n                    isPointer = true;\n                    break;\n                }\n                VALIDATE_SCHEMA(isPointer,\n                    \"generic type parameter must be a pointer type\", type);\n\n                break;\n              }\n            }\n          }\n          break;\n        case schema::Brand::Scope::INHERIT:\n          break;\n      }\n    }\n  }"
  },
  {
    "function_name": "validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "519-563",
    "snippet": "void validate(const schema::Type::Reader& type) {\n    switch (type.which()) {\n      case schema::Type::VOID:\n      case schema::Type::BOOL:\n      case schema::Type::INT8:\n      case schema::Type::INT16:\n      case schema::Type::INT32:\n      case schema::Type::INT64:\n      case schema::Type::UINT8:\n      case schema::Type::UINT16:\n      case schema::Type::UINT32:\n      case schema::Type::UINT64:\n      case schema::Type::FLOAT32:\n      case schema::Type::FLOAT64:\n      case schema::Type::TEXT:\n      case schema::Type::DATA:\n      case schema::Type::ANY_POINTER:\n        break;\n\n      case schema::Type::STRUCT: {\n        auto structType = type.getStruct();\n        validateTypeId(structType.getTypeId(), schema::Node::STRUCT);\n        validate(structType.getBrand());\n        break;\n      }\n      case schema::Type::ENUM: {\n        auto enumType = type.getEnum();\n        validateTypeId(enumType.getTypeId(), schema::Node::ENUM);\n        validate(enumType.getBrand());\n        break;\n      }\n      case schema::Type::INTERFACE: {\n        auto interfaceType = type.getInterface();\n        validateTypeId(interfaceType.getTypeId(), schema::Node::INTERFACE);\n        validate(interfaceType.getBrand());\n        break;\n      }\n\n      case schema::Type::LIST:\n        validate(type.getList().getElementType());\n        break;\n    }\n\n    // We intentionally allow unknown types.\n  }",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "type.getList",
          "args": [],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getList",
          "args": [],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interfaceType.getBrand",
          "args": [],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validateTypeId",
          "args": [
            "interfaceType.getTypeId()",
            "schema::Node::INTERFACE"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "validateTypeId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
          "lines": "617-630",
          "snippet": "void validateTypeId(uint64_t id, schema::Node::Which expectedKind) {\n    _::RawSchema* existing = loader.tryGet(id).schema;\n    if (existing != nullptr) {\n      auto node = readMessageUnchecked<schema::Node>(existing->encodedNode);\n      VALIDATE_SCHEMA(node.which() == expectedKind,\n          \"expected a different kind of node for this ID\",\n          id, (uint)expectedKind, (uint)node.which(), node.getDisplayName());\n      dependencies.insert(std::make_pair(id, existing));\n      return;\n    }\n\n    dependencies.insert(std::make_pair(id, loader.loadEmpty(\n        id, kj::str(\"(unknown type used by \", nodeName , \")\"), expectedKind, true)));\n  }",
          "includes": [
            "#include <algorithm>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/exception.h>",
            "#include <kj/debug.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include <map>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid validateTypeId(uint64_t id, schema::Node::Which expectedKind) {\n    _::RawSchema* existing = loader.tryGet(id).schema;\n    if (existing != nullptr) {\n      auto node = readMessageUnchecked<schema::Node>(existing->encodedNode);\n      VALIDATE_SCHEMA(node.which() == expectedKind,\n          \"expected a different kind of node for this ID\",\n          id, (uint)expectedKind, (uint)node.which(), node.getDisplayName());\n      dependencies.insert(std::make_pair(id, existing));\n      return;\n    }\n\n    dependencies.insert(std::make_pair(id, loader.loadEmpty(\n        id, kj::str(\"(unknown type used by \", nodeName , \")\"), expectedKind, true)));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "interfaceType.getTypeId",
          "args": [],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getInterface",
          "args": [],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumType.getBrand",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumType.getTypeId",
          "args": [],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getEnum",
          "args": [],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structType.getBrand",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structType.getTypeId",
          "args": [],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getStruct",
          "args": [],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid validate(const schema::Type::Reader& type) {\n    switch (type.which()) {\n      case schema::Type::VOID:\n      case schema::Type::BOOL:\n      case schema::Type::INT8:\n      case schema::Type::INT16:\n      case schema::Type::INT32:\n      case schema::Type::INT64:\n      case schema::Type::UINT8:\n      case schema::Type::UINT16:\n      case schema::Type::UINT32:\n      case schema::Type::UINT64:\n      case schema::Type::FLOAT32:\n      case schema::Type::FLOAT64:\n      case schema::Type::TEXT:\n      case schema::Type::DATA:\n      case schema::Type::ANY_POINTER:\n        break;\n\n      case schema::Type::STRUCT: {\n        auto structType = type.getStruct();\n        validateTypeId(structType.getTypeId(), schema::Node::STRUCT);\n        validate(structType.getBrand());\n        break;\n      }\n      case schema::Type::ENUM: {\n        auto enumType = type.getEnum();\n        validateTypeId(enumType.getTypeId(), schema::Node::ENUM);\n        validate(enumType.getBrand());\n        break;\n      }\n      case schema::Type::INTERFACE: {\n        auto interfaceType = type.getInterface();\n        validateTypeId(interfaceType.getTypeId(), schema::Node::INTERFACE);\n        validate(interfaceType.getBrand());\n        break;\n      }\n\n      case schema::Type::LIST:\n        validate(type.getList().getElementType());\n        break;\n    }\n\n    // We intentionally allow unknown types.\n  }"
  },
  {
    "function_name": "validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "478-517",
    "snippet": "void validate(const schema::Type::Reader& type, const schema::Value::Reader& value,\n                uint* dataSizeInBits, bool* isPointer) {\n    validate(type);\n\n    schema::Value::Which expectedValueType = schema::Value::VOID;\n    bool hadCase = false;\n    switch (type.which()) {\n#define HANDLE_TYPE(name, bits, ptr) \\\n      case schema::Type::name: \\\n        expectedValueType = schema::Value::name; \\\n        *dataSizeInBits = bits; *isPointer = ptr; \\\n        hadCase = true; \\\n        break;\n      HANDLE_TYPE(VOID, 0, false)\n      HANDLE_TYPE(BOOL, 1, false)\n      HANDLE_TYPE(INT8, 8, false)\n      HANDLE_TYPE(INT16, 16, false)\n      HANDLE_TYPE(INT32, 32, false)\n      HANDLE_TYPE(INT64, 64, false)\n      HANDLE_TYPE(UINT8, 8, false)\n      HANDLE_TYPE(UINT16, 16, false)\n      HANDLE_TYPE(UINT32, 32, false)\n      HANDLE_TYPE(UINT64, 64, false)\n      HANDLE_TYPE(FLOAT32, 32, false)\n      HANDLE_TYPE(FLOAT64, 64, false)\n      HANDLE_TYPE(TEXT, 0, true)\n      HANDLE_TYPE(DATA, 0, true)\n      HANDLE_TYPE(LIST, 0, true)\n      HANDLE_TYPE(ENUM, 16, false)\n      HANDLE_TYPE(STRUCT, 0, true)\n      HANDLE_TYPE(INTERFACE, 0, true)\n      HANDLE_TYPE(ANY_POINTER, 0, true)\n#undef HANDLE_TYPE\n    }\n\n    if (hadCase) {\n      VALIDATE_SCHEMA(value.which() == expectedValueType, \"Value did not match type.\",\n                      (uint)value.which(), (uint)expectedValueType);\n    }\n  }",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "value.which() == expectedValueType",
            "\"Value did not match type.\"",
            "(uint)value.which()",
            "(uint)expectedValueType"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.which",
          "args": [],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.which",
          "args": [],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "ANY_POINTER",
            "0",
            "true"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "INTERFACE",
            "0",
            "true"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "STRUCT",
            "0",
            "true"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "ENUM",
            "16",
            "false"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "LIST",
            "0",
            "true"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "DATA",
            "0",
            "true"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "TEXT",
            "0",
            "true"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "FLOAT64",
            "64",
            "false"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "FLOAT32",
            "32",
            "false"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "UINT64",
            "64",
            "false"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "UINT32",
            "32",
            "false"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "UINT16",
            "16",
            "false"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "UINT8",
            "8",
            "false"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "INT64",
            "64",
            "false"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "INT32",
            "32",
            "false"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "INT16",
            "16",
            "false"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "INT8",
            "8",
            "false"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "BOOL",
            "1",
            "false"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_TYPE",
          "args": [
            "VOID",
            "0",
            "false"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid validate(const schema::Type::Reader& type, const schema::Value::Reader& value,\n                uint* dataSizeInBits, bool* isPointer) {\n    validate(type);\n\n    schema::Value::Which expectedValueType = schema::Value::VOID;\n    bool hadCase = false;\n    switch (type.which()) {\n#define HANDLE_TYPE(name, bits, ptr) \\\n      case schema::Type::name: \\\n        expectedValueType = schema::Value::name; \\\n        *dataSizeInBits = bits; *isPointer = ptr; \\\n        hadCase = true; \\\n        break;\n      HANDLE_TYPE(VOID, 0, false)\n      HANDLE_TYPE(BOOL, 1, false)\n      HANDLE_TYPE(INT8, 8, false)\n      HANDLE_TYPE(INT16, 16, false)\n      HANDLE_TYPE(INT32, 32, false)\n      HANDLE_TYPE(INT64, 64, false)\n      HANDLE_TYPE(UINT8, 8, false)\n      HANDLE_TYPE(UINT16, 16, false)\n      HANDLE_TYPE(UINT32, 32, false)\n      HANDLE_TYPE(UINT64, 64, false)\n      HANDLE_TYPE(FLOAT32, 32, false)\n      HANDLE_TYPE(FLOAT64, 64, false)\n      HANDLE_TYPE(TEXT, 0, true)\n      HANDLE_TYPE(DATA, 0, true)\n      HANDLE_TYPE(LIST, 0, true)\n      HANDLE_TYPE(ENUM, 16, false)\n      HANDLE_TYPE(STRUCT, 0, true)\n      HANDLE_TYPE(INTERFACE, 0, true)\n      HANDLE_TYPE(ANY_POINTER, 0, true)\n#undef HANDLE_TYPE\n    }\n\n    if (hadCase) {\n      VALIDATE_SCHEMA(value.which() == expectedValueType, \"Value did not match type.\",\n                      (uint)value.which(), (uint)expectedValueType);\n    }\n  }"
  },
  {
    "function_name": "validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "474-476",
    "snippet": "void validate(const schema::Node::Annotation::Reader& annotationNode) {\n    validate(annotationNode.getType());\n  }",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "annotationNode.getType",
          "args": [],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid validate(const schema::Node::Annotation::Reader& annotationNode) {\n    validate(annotationNode.getType());\n  }"
  },
  {
    "function_name": "validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "468-472",
    "snippet": "void validate(const schema::Node::Const::Reader& constNode) {\n    uint dummy1;\n    bool dummy2;\n    validate(constNode.getType(), constNode.getValue(), &dummy1, &dummy2);\n  }",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "constNode.getValue",
          "args": [],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "constNode.getType",
          "args": [],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid validate(const schema::Node::Const::Reader& constNode) {\n    uint dummy1;\n    bool dummy2;\n    validate(constNode.getType(), constNode.getValue(), &dummy1, &dummy2);\n  }"
  },
  {
    "function_name": "validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "441-466",
    "snippet": "void validate(const schema::Node::Interface::Reader& interfaceNode) {\n    for (auto extend: interfaceNode.getSuperclasses()) {\n      validateTypeId(extend.getId(), schema::Node::INTERFACE);\n      validate(extend.getBrand());\n    }\n\n    auto methods = interfaceNode.getMethods();\n    KJ_STACK_ARRAY(bool, sawCodeOrder, methods.size(), 32, 256);\n    memset(sawCodeOrder.begin(), 0, sawCodeOrder.size() * sizeof(sawCodeOrder[0]));\n\n    uint index = 0;\n    for (auto method: methods) {\n      KJ_CONTEXT(\"validating method\", method.getName());\n      validateMemberName(method.getName(), index++);\n\n      VALIDATE_SCHEMA(method.getCodeOrder() < methods.size() &&\n                      !sawCodeOrder[method.getCodeOrder()],\n                      \"invalid codeOrder\");\n      sawCodeOrder[method.getCodeOrder()] = true;\n\n      validateTypeId(method.getParamStructType(), schema::Node::STRUCT);\n      validate(method.getParamBrand());\n      validateTypeId(method.getResultStructType(), schema::Node::STRUCT);\n      validate(method.getResultBrand());\n    }\n  }",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "method.getResultBrand",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validateTypeId",
          "args": [
            "method.getResultStructType()",
            "schema::Node::STRUCT"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "validateTypeId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
          "lines": "617-630",
          "snippet": "void validateTypeId(uint64_t id, schema::Node::Which expectedKind) {\n    _::RawSchema* existing = loader.tryGet(id).schema;\n    if (existing != nullptr) {\n      auto node = readMessageUnchecked<schema::Node>(existing->encodedNode);\n      VALIDATE_SCHEMA(node.which() == expectedKind,\n          \"expected a different kind of node for this ID\",\n          id, (uint)expectedKind, (uint)node.which(), node.getDisplayName());\n      dependencies.insert(std::make_pair(id, existing));\n      return;\n    }\n\n    dependencies.insert(std::make_pair(id, loader.loadEmpty(\n        id, kj::str(\"(unknown type used by \", nodeName , \")\"), expectedKind, true)));\n  }",
          "includes": [
            "#include <algorithm>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/exception.h>",
            "#include <kj/debug.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include <map>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid validateTypeId(uint64_t id, schema::Node::Which expectedKind) {\n    _::RawSchema* existing = loader.tryGet(id).schema;\n    if (existing != nullptr) {\n      auto node = readMessageUnchecked<schema::Node>(existing->encodedNode);\n      VALIDATE_SCHEMA(node.which() == expectedKind,\n          \"expected a different kind of node for this ID\",\n          id, (uint)expectedKind, (uint)node.which(), node.getDisplayName());\n      dependencies.insert(std::make_pair(id, existing));\n      return;\n    }\n\n    dependencies.insert(std::make_pair(id, loader.loadEmpty(\n        id, kj::str(\"(unknown type used by \", nodeName , \")\"), expectedKind, true)));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "method.getResultStructType",
          "args": [],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getParamBrand",
          "args": [],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getParamStructType",
          "args": [],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getCodeOrder",
          "args": [],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "method.getCodeOrder() < methods.size() &&\n                      !sawCodeOrder[method.getCodeOrder()]",
            "\"invalid codeOrder\""
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getCodeOrder",
          "args": [],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "methods.size",
          "args": [],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "method.getCodeOrder",
          "args": [],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validateMemberName",
          "args": [
            "method.getName()",
            "index++"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getName",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_CONTEXT",
          "args": [
            "\"validating method\"",
            "method.getName()"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getName",
          "args": [],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n    for",
          "args": [
            "auto method:methods"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interfaceNode.getMethods",
          "args": [],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extend.getBrand",
          "args": [],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extend.getId",
          "args": [],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "interfaceNode.getSuperclasses",
          "args": [],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid validate(const schema::Node::Interface::Reader& interfaceNode) {\n    for (auto extend: interfaceNode.getSuperclasses()) {\n      validateTypeId(extend.getId(), schema::Node::INTERFACE);\n      validate(extend.getBrand());\n    }\n\n    auto methods = interfaceNode.getMethods();\n    KJ_STACK_ARRAY(bool, sawCodeOrder, methods.size(), 32, 256);\n    memset(sawCodeOrder.begin(), 0, sawCodeOrder.size() * sizeof(sawCodeOrder[0]));\n\n    uint index = 0;\n    for (auto method: methods) {\n      KJ_CONTEXT(\"validating method\", method.getName());\n      validateMemberName(method.getName(), index++);\n\n      VALIDATE_SCHEMA(method.getCodeOrder() < methods.size() &&\n                      !sawCodeOrder[method.getCodeOrder()],\n                      \"invalid codeOrder\");\n      sawCodeOrder[method.getCodeOrder()] = true;\n\n      validateTypeId(method.getParamStructType(), schema::Node::STRUCT);\n      validate(method.getParamBrand());\n      validateTypeId(method.getResultStructType(), schema::Node::STRUCT);\n      validate(method.getResultBrand());\n    }\n  }"
  },
  {
    "function_name": "validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "235-439",
    "snippet": "class SchemaLoader::Validator {\npublic:\n  Validator(SchemaLoader::Impl& loader): loader(loader) {}\n\n  bool validate(const schema::Node::Reader& node) {\n    isValid = true;\n    nodeName = node.getDisplayName();\n    dependencies.clear();\n\n    KJ_CONTEXT(\"validating schema node\", nodeName, (uint)node.which());\n\n    if (node.getParameters().size() > 0) {\n      KJ_REQUIRE(node.getIsGeneric(), \"if parameter list is non-empty, isGeneric must be true\") {\n        isValid = false;\n        return false;\n      }\n    }\n\n    switch (node.which()) {\n      case schema::Node::FILE:\n        verifyVoid(node.getFile());\n        break;\n      case schema::Node::STRUCT:\n        validate(node.getStruct(), node.getScopeId());\n        break;\n      case schema::Node::ENUM:\n        validate(node.getEnum());\n        break;\n      case schema::Node::INTERFACE:\n        validate(node.getInterface());\n        break;\n      case schema::Node::CONST:\n        validate(node.getConst());\n        break;\n      case schema::Node::ANNOTATION:\n        validate(node.getAnnotation());\n        break;\n    }\n\n    // We accept and pass through node types we don't recognize.\n    return isValid;\n  }\n\n  const _::RawSchema** makeDependencyArray(uint32_t* count) {\n    *count = dependencies.size();\n    kj::ArrayPtr<const _::RawSchema*> result =\n        loader.arena.allocateArray<const _::RawSchema*>(*count);\n    uint pos = 0;\n    for (auto& dep: dependencies) {\n      result[pos++] = dep.second;\n    }\n    KJ_DASSERT(pos == *count);\n    return result.begin();\n  }\n\n  const uint16_t* makeMemberInfoArray(uint32_t* count) {\n    *count = members.size();\n    kj::ArrayPtr<uint16_t> result = loader.arena.allocateArray<uint16_t>(*count);\n    uint pos = 0;\n    for (auto& member: members) {\n      result[pos++] = member.second;\n    }\n    KJ_DASSERT(pos == *count);\n    return result.begin();\n  }\n\n  const uint16_t* makeMembersByDiscriminantArray() {\n    return membersByDiscriminant.begin();\n  }\n\nprivate:\n  SchemaLoader::Impl& loader;\n  Text::Reader nodeName;\n  bool isValid;\n  std::map<uint64_t, _::RawSchema*> dependencies;\n\n  // Maps name -> index for each member.\n  std::map<Text::Reader, uint> members;\n\n  kj::ArrayPtr<uint16_t> membersByDiscriminant;\n\n#define VALIDATE_SCHEMA(condition, ...) \\\n  KJ_REQUIRE(condition, ##__VA_ARGS__) { isValid = false; return; }\n#define FAIL_VALIDATE_SCHEMA(...) \\\n  KJ_FAIL_REQUIRE(__VA_ARGS__) { isValid = false; return; }\n\n  void validateMemberName(kj::StringPtr name, uint index) {\n    bool isNewName = members.insert(std::make_pair(name, index)).second;\n    VALIDATE_SCHEMA(isNewName, \"duplicate name\", name);\n  }\n\n  void validate(const schema::Node::Struct::Reader& structNode, uint64_t scopeId) {\n    uint dataSizeInBits = structNode.getDataWordCount() * 64;\n    uint pointerCount = structNode.getPointerCount();\n\n    auto fields = structNode.getFields();\n\n    KJ_STACK_ARRAY(bool, sawCodeOrder, fields.size(), 32, 256);\n    memset(sawCodeOrder.begin(), 0, sawCodeOrder.size() * sizeof(sawCodeOrder[0]));\n\n    KJ_STACK_ARRAY(bool, sawDiscriminantValue, structNode.getDiscriminantCount(), 32, 256);\n    memset(sawDiscriminantValue.begin(), 0,\n           sawDiscriminantValue.size() * sizeof(sawDiscriminantValue[0]));\n\n    if (structNode.getDiscriminantCount() > 0) {\n      VALIDATE_SCHEMA(structNode.getDiscriminantCount() != 1,\n                      \"union must have at least two members\");\n      VALIDATE_SCHEMA(structNode.getDiscriminantCount() <= fields.size(),\n                      \"struct can't have more union fields than total fields\");\n\n      VALIDATE_SCHEMA((structNode.getDiscriminantOffset() + 1) * 16 <= dataSizeInBits,\n                      \"union discriminant is out-of-bounds\");\n    }\n\n    membersByDiscriminant = loader.arena.allocateArray<uint16_t>(fields.size());\n    uint discriminantPos = 0;\n    uint nonDiscriminantPos = structNode.getDiscriminantCount();\n\n    uint index = 0;\n    uint nextOrdinal = 0;\n    for (auto field: fields) {\n      KJ_CONTEXT(\"validating struct field\", field.getName());\n\n      validateMemberName(field.getName(), index);\n      VALIDATE_SCHEMA(field.getCodeOrder() < sawCodeOrder.size() &&\n                      !sawCodeOrder[field.getCodeOrder()],\n                      \"invalid codeOrder\");\n      sawCodeOrder[field.getCodeOrder()] = true;\n\n      auto ordinal = field.getOrdinal();\n      if (ordinal.isExplicit()) {\n        VALIDATE_SCHEMA(ordinal.getExplicit() >= nextOrdinal,\n                        \"fields were not ordered by ordinal\");\n        nextOrdinal = ordinal.getExplicit() + 1;\n      }\n\n      if (hasDiscriminantValue(field)) {\n        VALIDATE_SCHEMA(field.getDiscriminantValue() < sawDiscriminantValue.size() &&\n                        !sawDiscriminantValue[field.getDiscriminantValue()],\n                        \"invalid discriminantValue\");\n        sawDiscriminantValue[field.getDiscriminantValue()] = true;\n\n        membersByDiscriminant[discriminantPos++] = index;\n      } else {\n        VALIDATE_SCHEMA(nonDiscriminantPos <= fields.size(),\n                        \"discriminantCount did not match fields\");\n        membersByDiscriminant[nonDiscriminantPos++] = index;\n      }\n\n      switch (field.which()) {\n        case schema::Field::SLOT: {\n          auto slot = field.getSlot();\n\n          uint fieldBits = 0;\n          bool fieldIsPointer = false;\n          validate(slot.getType(), slot.getDefaultValue(), &fieldBits, &fieldIsPointer);\n          VALIDATE_SCHEMA(fieldBits * (slot.getOffset() + 1) <= dataSizeInBits &&\n                          fieldIsPointer * (slot.getOffset() + 1) <= pointerCount,\n                          \"field offset out-of-bounds\",\n                          slot.getOffset(), dataSizeInBits, pointerCount);\n\n          break;\n        }\n\n        case schema::Field::GROUP:\n          // Require that the group is a struct node.\n          validateTypeId(field.getGroup().getTypeId(), schema::Node::STRUCT);\n          break;\n      }\n\n      ++index;\n    }\n\n    // If the above code is correct, these should pass.\n    KJ_ASSERT(discriminantPos == structNode.getDiscriminantCount());\n    KJ_ASSERT(nonDiscriminantPos == fields.size());\n\n    if (structNode.getIsGroup()) {\n      VALIDATE_SCHEMA(scopeId != 0, \"group node missing scopeId\");\n\n      // Require that the group's scope has at least the same size as the group, so that anyone\n      // constructing an instance of the outer scope can safely read/write the group.\n      loader.requireStructSize(scopeId, structNode.getDataWordCount(),\n                               structNode.getPointerCount());\n\n      // Require that the parent type is a struct.\n      validateTypeId(scopeId, schema::Node::STRUCT);\n    }\n  }\n\n  void validate(const schema::Node::Enum::Reader& enumNode) {\n    auto enumerants = enumNode.getEnumerants();\n    KJ_STACK_ARRAY(bool, sawCodeOrder, enumerants.size(), 32, 256);\n    memset(sawCodeOrder.begin(), 0, sawCodeOrder.size() * sizeof(sawCodeOrder[0]));\n\n    uint index = 0;\n    for (auto enumerant: enumerants) {\n      validateMemberName(enumerant.getName(), index++);\n\n      VALIDATE_SCHEMA(enumerant.getCodeOrder() < enumerants.size() &&\n                      !sawCodeOrder[enumerant.getCodeOrder()],\n                      \"invalid codeOrder\", enumerant.getName());\n      sawCodeOrder[enumerant.getCodeOrder()] = true;\n    }\n  }",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enumerant.getCodeOrder",
          "args": [],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "enumerant.getCodeOrder() < enumerants.size() &&\n                      !sawCodeOrder[enumerant.getCodeOrder()]",
            "\"invalid codeOrder\"",
            "enumerant.getName()"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerant.getName",
          "args": [],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerant.getCodeOrder",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerants.size",
          "args": [],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "enumerant.getCodeOrder",
          "args": [],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validateMemberName",
          "args": [
            "enumerant.getName()",
            "index++"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerant.getName",
          "args": [],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n    for",
          "args": [
            "auto enumerant:enumerants"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumNode.getEnumerants",
          "args": [],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validateTypeId",
          "args": [
            "scopeId",
            "schema::Node::STRUCT"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "validateTypeId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
          "lines": "617-630",
          "snippet": "void validateTypeId(uint64_t id, schema::Node::Which expectedKind) {\n    _::RawSchema* existing = loader.tryGet(id).schema;\n    if (existing != nullptr) {\n      auto node = readMessageUnchecked<schema::Node>(existing->encodedNode);\n      VALIDATE_SCHEMA(node.which() == expectedKind,\n          \"expected a different kind of node for this ID\",\n          id, (uint)expectedKind, (uint)node.which(), node.getDisplayName());\n      dependencies.insert(std::make_pair(id, existing));\n      return;\n    }\n\n    dependencies.insert(std::make_pair(id, loader.loadEmpty(\n        id, kj::str(\"(unknown type used by \", nodeName , \")\"), expectedKind, true)));\n  }",
          "includes": [
            "#include <algorithm>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/exception.h>",
            "#include <kj/debug.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include <map>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nvoid validateTypeId(uint64_t id, schema::Node::Which expectedKind) {\n    _::RawSchema* existing = loader.tryGet(id).schema;\n    if (existing != nullptr) {\n      auto node = readMessageUnchecked<schema::Node>(existing->encodedNode);\n      VALIDATE_SCHEMA(node.which() == expectedKind,\n          \"expected a different kind of node for this ID\",\n          id, (uint)expectedKind, (uint)node.which(), node.getDisplayName());\n      dependencies.insert(std::make_pair(id, existing));\n      return;\n    }\n\n    dependencies.insert(std::make_pair(id, loader.loadEmpty(\n        id, kj::str(\"(unknown type used by \", nodeName , \")\"), expectedKind, true)));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "loader.requireStructSize",
          "args": [
            "scopeId",
            "structNode.getDataWordCount()",
            "structNode.getPointerCount()"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getPointerCount",
          "args": [],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getDataWordCount",
          "args": [],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "scopeId != 0",
            "\"group node missing scopeId\""
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getDiscriminantCount",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getGroup",
          "args": [],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getGroup",
          "args": [],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "fieldBits * (slot.getOffset() + 1) <= dataSizeInBits &&\n                          fieldIsPointer * (slot.getOffset() + 1) <= pointerCount",
            "\"field offset out-of-bounds\"",
            "slot.getOffset()",
            "dataSizeInBits",
            "pointerCount"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.getOffset",
          "args": [],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.getOffset",
          "args": [],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.getOffset",
          "args": [],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.getDefaultValue",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.getType",
          "args": [],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "field.getSlot",
          "args": [],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.which",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "nonDiscriminantPos <= fields.size()",
            "\"discriminantCount did not match fields\""
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getDiscriminantValue",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "field.getDiscriminantValue() < sawDiscriminantValue.size() &&\n                        !sawDiscriminantValue[field.getDiscriminantValue()]",
            "\"invalid discriminantValue\""
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getDiscriminantValue",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getDiscriminantValue",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hasDiscriminantValue",
          "args": [
            "field"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "hasDiscriminantValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
          "lines": "78-80",
          "snippet": "bool hasDiscriminantValue(const schema::Field::Reader& reader) {\n  return reader.getDiscriminantValue() != schema::Field::NO_DISCRIMINANT;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/exception.h>",
            "#include <kj/debug.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include <map>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nbool hasDiscriminantValue(const schema::Field::Reader& reader) {\n  return reader.getDiscriminantValue() != schema::Field::NO_DISCRIMINANT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ordinal.getExplicit",
          "args": [],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "ordinal.getExplicit() >= nextOrdinal",
            "\"fields were not ordered by ordinal\""
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ordinal.getExplicit",
          "args": [],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ordinal.isExplicit",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getOrdinal",
          "args": [],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "getOrdinal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "486-486",
          "snippet": "inline uint16_t getOrdinal() const { return ordinal; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline uint16_t getOrdinal() const { return ordinal; }"
        }
      },
      {
        "call_info": {
          "callee": "field.getCodeOrder",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "field.getCodeOrder() < sawCodeOrder.size() &&\n                      !sawCodeOrder[field.getCodeOrder()]",
            "\"invalid codeOrder\""
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getCodeOrder",
          "args": [],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getCodeOrder",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validateMemberName",
          "args": [
            "field.getName()",
            "index"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getName",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_CONTEXT",
          "args": [
            "\"validating struct field\"",
            "field.getName()"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getName",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getDiscriminantCount",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loader.arena.allocateArray<uint16_t>",
          "args": [
            "fields.size()"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getFields",
          "args": [],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getPointerCount",
          "args": [],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.getDataWordCount",
          "args": [],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALIDATE_SCHEMA",
          "args": [
            "isNewName",
            "\"duplicate name\"",
            "name"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "members.insert",
          "args": [
            "std::make_pair(name, index)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "name",
            "index"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membersByDiscriminant.begin",
          "args": [],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "pos == *count"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loader.arena.allocateArray<uint16_t>",
          "args": [
            "*count"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "pos == *count"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loader.arena.allocateArray<const _::RawSchema*>",
          "args": [
            "*count"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getAnnotation",
          "args": [],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getConst",
          "args": [],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getInterface",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getEnum",
          "args": [],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate",
          "args": [
            "node.getStruct()",
            "node.getScopeId()"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getScopeId",
          "args": [],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "getScopeId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "778-778",
          "snippet": "inline uint64_t getScopeId() { return leafId; }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t leafId;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t leafId;\n\ninline uint64_t getScopeId() { return leafId; }"
        }
      },
      {
        "call_info": {
          "callee": "node.getStruct",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verifyVoid",
          "args": [
            "node.getFile()"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "verifyVoid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
          "lines": "231-231",
          "snippet": "inline static void verifyVoid(Void value) {}",
          "includes": [
            "#include <algorithm>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/exception.h>",
            "#include <kj/debug.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include <map>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include \"schema-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\ninline static void verifyVoid(Void value) {}"
        }
      },
      {
        "call_info": {
          "callee": "node.getFile",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.which",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "node.getIsGeneric()",
            "\"if parameter list is non-empty, isGeneric must be true\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getIsGeneric",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getParameters",
          "args": [],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getParameters",
          "args": [],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_CONTEXT",
          "args": [
            "\"validating schema node\"",
            "nodeName",
            "(uint)node.which()"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.which",
          "args": [],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dependencies.clear",
          "args": [],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "TestPipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed-test.c++",
          "lines": "51-54",
          "snippet": "void clear(size_t preferredReadSize = kj::maxValue) {\n    resetRead(preferredReadSize);\n    data.clear();\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <stdlib.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"serialize-packed.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <stdlib.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nTestPipe {\n  void clear(size_t preferredReadSize = kj::maxValue) {\n      resetRead(preferredReadSize);\n      data.clear();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "node.getDisplayName",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "getDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "416-418",
          "snippet": "kj::StringPtr getDisplayName() const override {\n    return displayName;\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::StringPtr getDisplayName() const override {\n    return displayName;\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nclass SchemaLoader::Validator {\npublic:\n  Validator(SchemaLoader::Impl& loader): loader(loader) {}\n\n  bool validate(const schema::Node::Reader& node) {\n    isValid = true;\n    nodeName = node.getDisplayName();\n    dependencies.clear();\n\n    KJ_CONTEXT(\"validating schema node\", nodeName, (uint)node.which());\n\n    if (node.getParameters().size() > 0) {\n      KJ_REQUIRE(node.getIsGeneric(), \"if parameter list is non-empty, isGeneric must be true\") {\n        isValid = false;\n        return false;\n      }\n    }\n\n    switch (node.which()) {\n      case schema::Node::FILE:\n        verifyVoid(node.getFile());\n        break;\n      case schema::Node::STRUCT:\n        validate(node.getStruct(), node.getScopeId());\n        break;\n      case schema::Node::ENUM:\n        validate(node.getEnum());\n        break;\n      case schema::Node::INTERFACE:\n        validate(node.getInterface());\n        break;\n      case schema::Node::CONST:\n        validate(node.getConst());\n        break;\n      case schema::Node::ANNOTATION:\n        validate(node.getAnnotation());\n        break;\n    }\n\n    // We accept and pass through node types we don't recognize.\n    return isValid;\n  }\n\n  const _::RawSchema** makeDependencyArray(uint32_t* count) {\n    *count = dependencies.size();\n    kj::ArrayPtr<const _::RawSchema*> result =\n        loader.arena.allocateArray<const _::RawSchema*>(*count);\n    uint pos = 0;\n    for (auto& dep: dependencies) {\n      result[pos++] = dep.second;\n    }\n    KJ_DASSERT(pos == *count);\n    return result.begin();\n  }\n\n  const uint16_t* makeMemberInfoArray(uint32_t* count) {\n    *count = members.size();\n    kj::ArrayPtr<uint16_t> result = loader.arena.allocateArray<uint16_t>(*count);\n    uint pos = 0;\n    for (auto& member: members) {\n      result[pos++] = member.second;\n    }\n    KJ_DASSERT(pos == *count);\n    return result.begin();\n  }\n\n  const uint16_t* makeMembersByDiscriminantArray() {\n    return membersByDiscriminant.begin();\n  }\n\nprivate:\n  SchemaLoader::Impl& loader;\n  Text::Reader nodeName;\n  bool isValid;\n  std::map<uint64_t, _::RawSchema*> dependencies;\n\n  // Maps name -> index for each member.\n  std::map<Text::Reader, uint> members;\n\n  kj::ArrayPtr<uint16_t> membersByDiscriminant;\n\n#define VALIDATE_SCHEMA(condition, ...) \\\n  KJ_REQUIRE(condition, ##__VA_ARGS__) { isValid = false; return; }\n#define FAIL_VALIDATE_SCHEMA(...) \\\n  KJ_FAIL_REQUIRE(__VA_ARGS__) { isValid = false; return; }\n\n  void validateMemberName(kj::StringPtr name, uint index) {\n    bool isNewName = members.insert(std::make_pair(name, index)).second;\n    VALIDATE_SCHEMA(isNewName, \"duplicate name\", name);\n  }\n\n  void validate(const schema::Node::Struct::Reader& structNode, uint64_t scopeId) {\n    uint dataSizeInBits = structNode.getDataWordCount() * 64;\n    uint pointerCount = structNode.getPointerCount();\n\n    auto fields = structNode.getFields();\n\n    KJ_STACK_ARRAY(bool, sawCodeOrder, fields.size(), 32, 256);\n    memset(sawCodeOrder.begin(), 0, sawCodeOrder.size() * sizeof(sawCodeOrder[0]));\n\n    KJ_STACK_ARRAY(bool, sawDiscriminantValue, structNode.getDiscriminantCount(), 32, 256);\n    memset(sawDiscriminantValue.begin(), 0,\n           sawDiscriminantValue.size() * sizeof(sawDiscriminantValue[0]));\n\n    if (structNode.getDiscriminantCount() > 0) {\n      VALIDATE_SCHEMA(structNode.getDiscriminantCount() != 1,\n                      \"union must have at least two members\");\n      VALIDATE_SCHEMA(structNode.getDiscriminantCount() <= fields.size(),\n                      \"struct can't have more union fields than total fields\");\n\n      VALIDATE_SCHEMA((structNode.getDiscriminantOffset() + 1) * 16 <= dataSizeInBits,\n                      \"union discriminant is out-of-bounds\");\n    }\n\n    membersByDiscriminant = loader.arena.allocateArray<uint16_t>(fields.size());\n    uint discriminantPos = 0;\n    uint nonDiscriminantPos = structNode.getDiscriminantCount();\n\n    uint index = 0;\n    uint nextOrdinal = 0;\n    for (auto field: fields) {\n      KJ_CONTEXT(\"validating struct field\", field.getName());\n\n      validateMemberName(field.getName(), index);\n      VALIDATE_SCHEMA(field.getCodeOrder() < sawCodeOrder.size() &&\n                      !sawCodeOrder[field.getCodeOrder()],\n                      \"invalid codeOrder\");\n      sawCodeOrder[field.getCodeOrder()] = true;\n\n      auto ordinal = field.getOrdinal();\n      if (ordinal.isExplicit()) {\n        VALIDATE_SCHEMA(ordinal.getExplicit() >= nextOrdinal,\n                        \"fields were not ordered by ordinal\");\n        nextOrdinal = ordinal.getExplicit() + 1;\n      }\n\n      if (hasDiscriminantValue(field)) {\n        VALIDATE_SCHEMA(field.getDiscriminantValue() < sawDiscriminantValue.size() &&\n                        !sawDiscriminantValue[field.getDiscriminantValue()],\n                        \"invalid discriminantValue\");\n        sawDiscriminantValue[field.getDiscriminantValue()] = true;\n\n        membersByDiscriminant[discriminantPos++] = index;\n      } else {\n        VALIDATE_SCHEMA(nonDiscriminantPos <= fields.size(),\n                        \"discriminantCount did not match fields\");\n        membersByDiscriminant[nonDiscriminantPos++] = index;\n      }\n\n      switch (field.which()) {\n        case schema::Field::SLOT: {\n          auto slot = field.getSlot();\n\n          uint fieldBits = 0;\n          bool fieldIsPointer = false;\n          validate(slot.getType(), slot.getDefaultValue(), &fieldBits, &fieldIsPointer);\n          VALIDATE_SCHEMA(fieldBits * (slot.getOffset() + 1) <= dataSizeInBits &&\n                          fieldIsPointer * (slot.getOffset() + 1) <= pointerCount,\n                          \"field offset out-of-bounds\",\n                          slot.getOffset(), dataSizeInBits, pointerCount);\n\n          break;\n        }\n\n        case schema::Field::GROUP:\n          // Require that the group is a struct node.\n          validateTypeId(field.getGroup().getTypeId(), schema::Node::STRUCT);\n          break;\n      }\n\n      ++index;\n    }\n\n    // If the above code is correct, these should pass.\n    KJ_ASSERT(discriminantPos == structNode.getDiscriminantCount());\n    KJ_ASSERT(nonDiscriminantPos == fields.size());\n\n    if (structNode.getIsGroup()) {\n      VALIDATE_SCHEMA(scopeId != 0, \"group node missing scopeId\");\n\n      // Require that the group's scope has at least the same size as the group, so that anyone\n      // constructing an instance of the outer scope can safely read/write the group.\n      loader.requireStructSize(scopeId, structNode.getDataWordCount(),\n                               structNode.getPointerCount());\n\n      // Require that the parent type is a struct.\n      validateTypeId(scopeId, schema::Node::STRUCT);\n    }\n  }\n\n  void validate(const schema::Node::Enum::Reader& enumNode) {\n    auto enumerants = enumNode.getEnumerants();\n    KJ_STACK_ARRAY(bool, sawCodeOrder, enumerants.size(), 32, 256);\n    memset(sawCodeOrder.begin(), 0, sawCodeOrder.size() * sizeof(sawCodeOrder[0]));\n\n    uint index = 0;\n    for (auto enumerant: enumerants) {\n      validateMemberName(enumerant.getName(), index++);\n\n      VALIDATE_SCHEMA(enumerant.getCodeOrder() < enumerants.size() &&\n                      !sawCodeOrder[enumerant.getCodeOrder()],\n                      \"invalid codeOrder\", enumerant.getName());\n      sawCodeOrder[enumerant.getCodeOrder()] = true;\n    }\n  }"
  },
  {
    "function_name": "verifyVoid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "231-231",
    "snippet": "inline static void verifyVoid(Void value) {}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\ninline static void verifyVoid(Void value) {}"
  },
  {
    "function_name": "Impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "113-114",
    "snippet": "inline Impl(const SchemaLoader& loader, const LazyLoadCallback& callback)\n      : initializer(loader, callback), brandedInitializer(loader) {}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\ninline Impl(const SchemaLoader& loader, const LazyLoadCallback& callback)\n      : initializer(loader, callback), brandedInitializer(loader) {}"
  },
  {
    "function_name": "Impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "111-112",
    "snippet": "inline explicit Impl(const SchemaLoader& loader)\n      : initializer(loader), brandedInitializer(loader) {}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\ninline explicit Impl(const SchemaLoader& loader)\n      : initializer(loader), brandedInitializer(loader) {}"
  },
  {
    "function_name": "BrandedInitializerImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "101-101",
    "snippet": "inline explicit BrandedInitializerImpl(const SchemaLoader& loader): loader(loader) {}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\ninline explicit BrandedInitializerImpl(const SchemaLoader& loader): loader(loader) {}"
  },
  {
    "function_name": "getCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "88-88",
    "snippet": "inline kj::Maybe<const LazyLoadCallback&> getCallback() const { return callback; }",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\ninline kj::Maybe<const LazyLoadCallback&> getCallback() const { return callback; }"
  },
  {
    "function_name": "InitializerImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "85-86",
    "snippet": "inline InitializerImpl(const SchemaLoader& loader, const LazyLoadCallback& callback)\n      : loader(loader), callback(callback) {}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\ninline InitializerImpl(const SchemaLoader& loader, const LazyLoadCallback& callback)\n      : loader(loader), callback(callback) {}"
  },
  {
    "function_name": "InitializerImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "84-84",
    "snippet": "inline explicit InitializerImpl(const SchemaLoader& loader): loader(loader), callback(nullptr) {}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\ninline explicit InitializerImpl(const SchemaLoader& loader): loader(loader), callback(nullptr) {}"
  },
  {
    "function_name": "hasDiscriminantValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-loader.c++",
    "lines": "78-80",
    "snippet": "bool hasDiscriminantValue(const schema::Field::Reader& reader) {\n  return reader.getDiscriminantValue() != schema::Field::NO_DISCRIMINANT;\n}",
    "includes": [
      "#include <algorithm>",
      "#include <kj/vector.h>",
      "#include <kj/arena.h>",
      "#include <kj/exception.h>",
      "#include <kj/debug.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include <map>",
      "#include <unordered_set>",
      "#include <unordered_map>",
      "#include \"schema-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reader.getDiscriminantValue",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/exception.h>\n#include <kj/debug.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include \"schema-loader.h\"\n\nbool hasDiscriminantValue(const schema::Field::Reader& reader) {\n  return reader.getDiscriminantValue() != schema::Field::NO_DISCRIMINANT;\n}"
  }
]