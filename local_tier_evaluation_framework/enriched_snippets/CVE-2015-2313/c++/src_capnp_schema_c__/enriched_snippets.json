[
  {
    "function_name": "Type::requireUsableAs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "871-902",
    "snippet": "void Type::requireUsableAs(Type expected) const {\n  KJ_REQUIRE(baseType == expected.baseType && listDepth == expected.listDepth,\n             \"This type is not compatible with the requested native type.\");\n\n  switch (baseType) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n    case schema::Type::ANY_POINTER:\n      break;\n\n    case schema::Type::STRUCT:\n    case schema::Type::ENUM:\n    case schema::Type::INTERFACE:\n      Schema(schema).requireUsableAs(expected.schema->generic);\n      break;\n\n    case schema::Type::LIST:\n      KJ_UNREACHABLE;\n  }\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Schema",
          "args": [
            "expected.schema->generic"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "ListSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "734-734",
          "snippet": "inline explicit ListSchema(Type elementType): elementType(elementType) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline explicit ListSchema(Type elementType): elementType(elementType) {}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "baseType == expected.baseType && listDepth == expected.listDepth",
            "\"This type is not compatible with the requested native type.\""
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nvoid Type::requireUsableAs(Type expected) const {\n  KJ_REQUIRE(baseType == expected.baseType && listDepth == expected.listDepth,\n             \"This type is not compatible with the requested native type.\");\n\n  switch (baseType) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n    case schema::Type::ANY_POINTER:\n      break;\n\n    case schema::Type::STRUCT:\n    case schema::Type::ENUM:\n    case schema::Type::INTERFACE:\n      Schema(schema).requireUsableAs(expected.schema->generic);\n      break;\n\n    case schema::Type::LIST:\n      KJ_UNREACHABLE;\n  }\n}"
  },
  {
    "function_name": "Type::operator==",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "830-869",
    "snippet": "bool Type::operator==(const Type& other) const {\n  if (baseType != other.baseType || listDepth != other.listDepth) {\n    return false;\n  }\n\n  switch (baseType) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      return true;\n\n    case schema::Type::STRUCT:\n    case schema::Type::ENUM:\n    case schema::Type::INTERFACE:\n      return schema == other.schema;\n\n    case schema::Type::LIST:\n      KJ_UNREACHABLE;\n\n    case schema::Type::ANY_POINTER:\n      return scopeId == other.scopeId &&\n          // Trying to comply with strict aliasing rules. Hopefully the compiler realizes that\n          // both branches compile to the same instructions and can optimize it away.\n          (scopeId != 0 || isImplicitParam ? paramIndex == other.paramIndex\n                                           : anyPointerKind == other.anyPointerKind);\n  }\n\n  KJ_UNREACHABLE;\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nbool Type::operator==(const Type& other) const {\n  if (baseType != other.baseType || listDepth != other.listDepth) {\n    return false;\n  }\n\n  switch (baseType) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      return true;\n\n    case schema::Type::STRUCT:\n    case schema::Type::ENUM:\n    case schema::Type::INTERFACE:\n      return schema == other.schema;\n\n    case schema::Type::LIST:\n      KJ_UNREACHABLE;\n\n    case schema::Type::ANY_POINTER:\n      return scopeId == other.scopeId &&\n          // Trying to comply with strict aliasing rules. Hopefully the compiler realizes that\n          // both branches compile to the same instructions and can optimize it away.\n          (scopeId != 0 || isImplicitParam ? paramIndex == other.paramIndex\n                                           : anyPointerKind == other.anyPointerKind);\n  }\n\n  KJ_UNREACHABLE;\n}"
  },
  {
    "function_name": "Type::getImplicitParameter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "819-828",
    "snippet": "kj::Maybe<Type::ImplicitParameter> Type::getImplicitParameter() const {\n  KJ_REQUIRE(isAnyPointer(),\n      \"Type::getImplicitParameter() can only be called on AnyPointer types.\");\n\n  if (isImplicitParam) {\n    return ImplicitParameter { paramIndex };\n  } else {\n    return nullptr;\n  }\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "isAnyPointer()",
            "\"Type::getImplicitParameter() can only be called on AnyPointer types.\""
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isAnyPointer",
          "args": [],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "Type::isAnyPointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "920-922",
          "snippet": "inline bool Type::isAnyPointer() const {\n  return baseType == schema::Type::ANY_POINTER && listDepth == 0;\n}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline bool Type::isAnyPointer() const {\n  return baseType == schema::Type::ANY_POINTER && listDepth == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nkj::Maybe<Type::ImplicitParameter> Type::getImplicitParameter() const {\n  KJ_REQUIRE(isAnyPointer(),\n      \"Type::getImplicitParameter() can only be called on AnyPointer types.\");\n\n  if (isImplicitParam) {\n    return ImplicitParameter { paramIndex };\n  } else {\n    return nullptr;\n  }\n}"
  },
  {
    "function_name": "Type::getBrandParameter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "809-817",
    "snippet": "kj::Maybe<Type::BrandParameter> Type::getBrandParameter() const {\n  KJ_REQUIRE(isAnyPointer(), \"Type::getBrandParameter() can only be called on AnyPointer types.\");\n\n  if (scopeId == 0) {\n    return nullptr;\n  } else {\n    return BrandParameter { scopeId, paramIndex };\n  }\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "isAnyPointer()",
            "\"Type::getBrandParameter() can only be called on AnyPointer types.\""
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isAnyPointer",
          "args": [],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "Type::isAnyPointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "920-922",
          "snippet": "inline bool Type::isAnyPointer() const {\n  return baseType == schema::Type::ANY_POINTER && listDepth == 0;\n}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline bool Type::isAnyPointer() const {\n  return baseType == schema::Type::ANY_POINTER && listDepth == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nkj::Maybe<Type::BrandParameter> Type::getBrandParameter() const {\n  KJ_REQUIRE(isAnyPointer(), \"Type::getBrandParameter() can only be called on AnyPointer types.\");\n\n  if (scopeId == 0) {\n    return nullptr;\n  } else {\n    return BrandParameter { scopeId, paramIndex };\n  }\n}"
  },
  {
    "function_name": "Type::asList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "800-807",
    "snippet": "ListSchema Type::asList() const {\n  KJ_REQUIRE(isList(), \"Type::asList(): Not a list.\") {\n    return ListSchema::of(schema::Type::VOID);\n  }\n  Type elementType = *this;\n  --elementType.listDepth;\n  return ListSchema::of(elementType);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ListSchema::of",
          "args": [
            "elementType"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "ListSchema::of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "699-730",
          "snippet": "ListSchema ListSchema::of(schema::Type::Which primitiveType) {\n  switch (primitiveType) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      break;\n\n    case schema::Type::STRUCT:\n    case schema::Type::ENUM:\n    case schema::Type::INTERFACE:\n    case schema::Type::LIST:\n      KJ_FAIL_REQUIRE(\"Must use one of the other ListSchema::of() overloads for complex types.\");\n      break;\n\n    case schema::Type::ANY_POINTER:\n      KJ_FAIL_REQUIRE(\"List(AnyPointer) not supported.\");\n      break;\n  }\n\n  return ListSchema(primitiveType);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nListSchema ListSchema::of(schema::Type::Which primitiveType) {\n  switch (primitiveType) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      break;\n\n    case schema::Type::STRUCT:\n    case schema::Type::ENUM:\n    case schema::Type::INTERFACE:\n    case schema::Type::LIST:\n      KJ_FAIL_REQUIRE(\"Must use one of the other ListSchema::of() overloads for complex types.\");\n      break;\n\n    case schema::Type::ANY_POINTER:\n      KJ_FAIL_REQUIRE(\"List(AnyPointer) not supported.\");\n      break;\n  }\n\n  return ListSchema(primitiveType);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "isList()",
            "\"Type::asList(): Not a list.\""
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isList",
          "args": [],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "Type::isList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "914-914",
          "snippet": "inline bool Type::isList   () const { return listDepth > 0; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline bool Type::isList   () const { return listDepth > 0; }"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nListSchema Type::asList() const {\n  KJ_REQUIRE(isList(), \"Type::asList(): Not a list.\") {\n    return ListSchema::of(schema::Type::VOID);\n  }\n  Type elementType = *this;\n  --elementType.listDepth;\n  return ListSchema::of(elementType);\n}"
  },
  {
    "function_name": "Type::asInterface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "793-799",
    "snippet": "InterfaceSchema Type::asInterface() const {\n  KJ_REQUIRE(isInterface(), \"Tried to interpret a non-interface type as an interface.\") {\n    return InterfaceSchema();\n  }\n  KJ_ASSERT(schema != nullptr);\n  return InterfaceSchema(Schema(schema));\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "InterfaceSchema",
          "args": [
            "Schema(schema)"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "InterfaceSchema",
          "container": "InterfaceSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "465-465",
          "snippet": "InterfaceSchema(Schema base): Schema(base) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nInterfaceSchema {\n  InterfaceSchema(Schema base): Schema(base) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Schema",
          "args": [
            "schema"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "ListSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "734-734",
          "snippet": "inline explicit ListSchema(Type elementType): elementType(elementType) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline explicit ListSchema(Type elementType): elementType(elementType) {}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "schema != nullptr"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InterfaceSchema",
          "args": [],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "fromImpl",
          "container": "InterfaceSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "466-468",
          "snippet": "static inline InterfaceSchema fromImpl() {\n    return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n  }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nInterfaceSchema {\n  static inline InterfaceSchema fromImpl() {\n      return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "isInterface()",
            "\"Tried to interpret a non-interface type as an interface.\""
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isInterface",
          "args": [],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "Type::isInterface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "917-919",
          "snippet": "inline bool Type::isInterface() const {\n  return baseType == schema::Type::INTERFACE && listDepth == 0;\n}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline bool Type::isInterface() const {\n  return baseType == schema::Type::INTERFACE && listDepth == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nInterfaceSchema Type::asInterface() const {\n  KJ_REQUIRE(isInterface(), \"Tried to interpret a non-interface type as an interface.\") {\n    return InterfaceSchema();\n  }\n  KJ_ASSERT(schema != nullptr);\n  return InterfaceSchema(Schema(schema));\n}"
  },
  {
    "function_name": "Type::asEnum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "786-792",
    "snippet": "EnumSchema Type::asEnum() const {\n  KJ_REQUIRE(isEnum(), \"Tried to interpret a non-enum type as an enum.\") {\n    return EnumSchema();\n  }\n  KJ_ASSERT(schema != nullptr);\n  return EnumSchema(Schema(schema));\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EnumSchema",
          "args": [
            "Schema(schema)"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "EnumSchema",
          "container": "EnumSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "383-383",
          "snippet": "EnumSchema(Schema base): Schema(base) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nEnumSchema {\n  EnumSchema(Schema base): Schema(base) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Schema",
          "args": [
            "schema"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "ListSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "734-734",
          "snippet": "inline explicit ListSchema(Type elementType): elementType(elementType) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline explicit ListSchema(Type elementType): elementType(elementType) {}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "schema != nullptr"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EnumSchema",
          "args": [],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "fromImpl",
          "container": "EnumSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "384-386",
          "snippet": "static inline EnumSchema fromImpl() {\n    return EnumSchema(Schema(&_::rawBrandedSchema<T>()));\n  }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nEnumSchema {\n  static inline EnumSchema fromImpl() {\n      return EnumSchema(Schema(&_::rawBrandedSchema<T>()));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "isEnum()",
            "\"Tried to interpret a non-enum type as an enum.\""
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isEnum",
          "args": [],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "Type::isEnum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "915-915",
          "snippet": "inline bool Type::isEnum   () const { return baseType == schema::Type::ENUM     && listDepth == 0; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline bool Type::isEnum   () const { return baseType == schema::Type::ENUM     && listDepth == 0; }"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nEnumSchema Type::asEnum() const {\n  KJ_REQUIRE(isEnum(), \"Tried to interpret a non-enum type as an enum.\") {\n    return EnumSchema();\n  }\n  KJ_ASSERT(schema != nullptr);\n  return EnumSchema(Schema(schema));\n}"
  },
  {
    "function_name": "Type::asStruct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "779-785",
    "snippet": "StructSchema Type::asStruct() const {\n  KJ_REQUIRE(isStruct(), \"Tried to interpret a non-struct type as a struct.\") {\n    return StructSchema();\n  }\n  KJ_ASSERT(schema != nullptr);\n  return StructSchema(Schema(schema));\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StructSchema",
          "args": [
            "Schema(schema)"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "StructSchema",
          "container": "StructSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "261-261",
          "snippet": "StructSchema(Schema base): Schema(base) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nStructSchema {\n  StructSchema(Schema base): Schema(base) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Schema",
          "args": [
            "schema"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "ListSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "734-734",
          "snippet": "inline explicit ListSchema(Type elementType): elementType(elementType) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline explicit ListSchema(Type elementType): elementType(elementType) {}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "schema != nullptr"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StructSchema",
          "args": [],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "fromImpl",
          "container": "StructSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "262-264",
          "snippet": "static inline StructSchema fromImpl() {\n    return StructSchema(Schema(&_::rawBrandedSchema<T>()));\n  }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nStructSchema {\n  static inline StructSchema fromImpl() {\n      return StructSchema(Schema(&_::rawBrandedSchema<T>()));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "isStruct()",
            "\"Tried to interpret a non-struct type as a struct.\""
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isStruct",
          "args": [],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "Type::isStruct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "916-916",
          "snippet": "inline bool Type::isStruct () const { return baseType == schema::Type::STRUCT   && listDepth == 0; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline bool Type::isStruct () const { return baseType == schema::Type::STRUCT   && listDepth == 0; }"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nStructSchema Type::asStruct() const {\n  KJ_REQUIRE(isStruct(), \"Tried to interpret a non-struct type as a struct.\") {\n    return StructSchema();\n  }\n  KJ_ASSERT(schema != nullptr);\n  return StructSchema(Schema(schema));\n}"
  },
  {
    "function_name": "ListSchema::of",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "732-775",
    "snippet": "ListSchema ListSchema::of(schema::Type::Reader elementType, Schema context) {\n  // This method is deprecated because it can only be implemented in terms of other deprecated\n  // methods. Temporarily disable warnings for those other deprecated methods.\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n\n  switch (elementType.which()) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      return of(elementType.which());\n\n    case schema::Type::STRUCT:\n      return of(context.getDependency(elementType.getStruct().getTypeId()).asStruct());\n\n    case schema::Type::ENUM:\n      return of(context.getDependency(elementType.getEnum().getTypeId()).asEnum());\n\n    case schema::Type::INTERFACE:\n      return of(context.getDependency(elementType.getInterface().getTypeId()).asInterface());\n\n    case schema::Type::LIST:\n      return of(of(elementType.getList().getElementType(), context));\n\n    case schema::Type::ANY_POINTER:\n      KJ_FAIL_REQUIRE(\"List(AnyPointer) not supported.\");\n      return ListSchema();\n  }\n\n  // Unknown type is acceptable.\n  return ListSchema(elementType.which());\n#pragma GCC diagnostic pop\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ListSchema",
          "args": [
            "elementType.which()"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "ListSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "734-734",
          "snippet": "inline explicit ListSchema(Type elementType): elementType(elementType) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline explicit ListSchema(Type elementType): elementType(elementType) {}"
        }
      },
      {
        "call_info": {
          "callee": "elementType.which",
          "args": [],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListSchema",
          "args": [],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"List(AnyPointer) not supported.\""
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementType.getList",
          "args": [],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementType.getList",
          "args": [],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getDependency",
          "args": [],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getDependency",
          "args": [
            "elementType.getInterface().getTypeId()"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementType.getInterface",
          "args": [],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementType.getInterface",
          "args": [],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getDependency",
          "args": [],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getDependency",
          "args": [
            "elementType.getEnum().getTypeId()"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementType.getEnum",
          "args": [],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementType.getEnum",
          "args": [],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getDependency",
          "args": [],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getDependency",
          "args": [
            "elementType.getStruct().getTypeId()"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementType.getStruct",
          "args": [],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementType.getStruct",
          "args": [],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementType.which",
          "args": [],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementType.which",
          "args": [],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nListSchema ListSchema::of(schema::Type::Reader elementType, Schema context) {\n  // This method is deprecated because it can only be implemented in terms of other deprecated\n  // methods. Temporarily disable warnings for those other deprecated methods.\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n\n  switch (elementType.which()) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      return of(elementType.which());\n\n    case schema::Type::STRUCT:\n      return of(context.getDependency(elementType.getStruct().getTypeId()).asStruct());\n\n    case schema::Type::ENUM:\n      return of(context.getDependency(elementType.getEnum().getTypeId()).asEnum());\n\n    case schema::Type::INTERFACE:\n      return of(context.getDependency(elementType.getInterface().getTypeId()).asInterface());\n\n    case schema::Type::LIST:\n      return of(of(elementType.getList().getElementType(), context));\n\n    case schema::Type::ANY_POINTER:\n      KJ_FAIL_REQUIRE(\"List(AnyPointer) not supported.\");\n      return ListSchema();\n  }\n\n  // Unknown type is acceptable.\n  return ListSchema(elementType.which());\n#pragma GCC diagnostic pop\n}"
  },
  {
    "function_name": "ListSchema::of",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "699-730",
    "snippet": "ListSchema ListSchema::of(schema::Type::Which primitiveType) {\n  switch (primitiveType) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      break;\n\n    case schema::Type::STRUCT:\n    case schema::Type::ENUM:\n    case schema::Type::INTERFACE:\n    case schema::Type::LIST:\n      KJ_FAIL_REQUIRE(\"Must use one of the other ListSchema::of() overloads for complex types.\");\n      break;\n\n    case schema::Type::ANY_POINTER:\n      KJ_FAIL_REQUIRE(\"List(AnyPointer) not supported.\");\n      break;\n  }\n\n  return ListSchema(primitiveType);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ListSchema",
          "args": [
            "primitiveType"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "ListSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "734-734",
          "snippet": "inline explicit ListSchema(Type elementType): elementType(elementType) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline explicit ListSchema(Type elementType): elementType(elementType) {}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"List(AnyPointer) not supported.\""
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Must use one of the other ListSchema::of() overloads for complex types.\""
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nListSchema ListSchema::of(schema::Type::Which primitiveType) {\n  switch (primitiveType) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      break;\n\n    case schema::Type::STRUCT:\n    case schema::Type::ENUM:\n    case schema::Type::INTERFACE:\n    case schema::Type::LIST:\n      KJ_FAIL_REQUIRE(\"Must use one of the other ListSchema::of() overloads for complex types.\");\n      break;\n\n    case schema::Type::ANY_POINTER:\n      KJ_FAIL_REQUIRE(\"List(AnyPointer) not supported.\");\n      break;\n  }\n\n  return ListSchema(primitiveType);\n}"
  },
  {
    "function_name": "ConstSchema::getType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "692-695",
    "snippet": "Type ConstSchema::getType() const {\n  return interpretType(getProto().getConst().getType(),\n      _::RawBrandedSchema::makeDepLocation(_::RawBrandedSchema::DepKind::CONST_TYPE, 0));\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "interpretType",
          "args": [
            "getProto().getConst().getType()",
            "_::RawBrandedSchema::makeDepLocation(_::RawBrandedSchema::DepKind::CONST_TYPE, 0)"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::interpretType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "335-390",
          "snippet": "Type Schema::interpretType(schema::Type::Reader proto, uint location) const {\n  switch (proto.which()) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      return proto.which();\n\n    case schema::Type::STRUCT: {\n      auto structType = proto.getStruct();\n      return getDependency(structType.getTypeId(), location).asStruct();\n    }\n\n    case schema::Type::ENUM: {\n      auto enumType = proto.getEnum();\n      return getDependency(enumType.getTypeId(), location).asEnum();\n    }\n\n    case schema::Type::INTERFACE: {\n      auto interfaceType = proto.getInterface();\n      return getDependency(interfaceType.getTypeId(), location).asInterface();\n    }\n\n    case schema::Type::LIST:\n      return ListSchema::of(interpretType(proto.getList().getElementType(), location));\n\n    case schema::Type::ANY_POINTER: {\n      auto anyPointer = proto.getAnyPointer();\n      switch (anyPointer.which()) {\n        case schema::Type::AnyPointer::UNCONSTRAINED:\n          return anyPointer.getUnconstrained().which();\n        case schema::Type::AnyPointer::PARAMETER: {\n          auto param = anyPointer.getParameter();\n          return getBrandBinding(param.getScopeId(), param.getParameterIndex());\n        }\n        case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER:\n          return Type(Type::ImplicitParameter {\n              anyPointer.getImplicitMethodParameter().getParameterIndex() });\n      }\n\n      KJ_UNREACHABLE;\n    }\n  }\n\n  KJ_UNREACHABLE;\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nType Schema::interpretType(schema::Type::Reader proto, uint location) const {\n  switch (proto.which()) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      return proto.which();\n\n    case schema::Type::STRUCT: {\n      auto structType = proto.getStruct();\n      return getDependency(structType.getTypeId(), location).asStruct();\n    }\n\n    case schema::Type::ENUM: {\n      auto enumType = proto.getEnum();\n      return getDependency(enumType.getTypeId(), location).asEnum();\n    }\n\n    case schema::Type::INTERFACE: {\n      auto interfaceType = proto.getInterface();\n      return getDependency(interfaceType.getTypeId(), location).asInterface();\n    }\n\n    case schema::Type::LIST:\n      return ListSchema::of(interpretType(proto.getList().getElementType(), location));\n\n    case schema::Type::ANY_POINTER: {\n      auto anyPointer = proto.getAnyPointer();\n      switch (anyPointer.which()) {\n        case schema::Type::AnyPointer::UNCONSTRAINED:\n          return anyPointer.getUnconstrained().which();\n        case schema::Type::AnyPointer::PARAMETER: {\n          auto param = anyPointer.getParameter();\n          return getBrandBinding(param.getScopeId(), param.getParameterIndex());\n        }\n        case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER:\n          return Type(Type::ImplicitParameter {\n              anyPointer.getImplicitMethodParameter().getParameterIndex() });\n      }\n\n      KJ_UNREACHABLE;\n    }\n  }\n\n  KJ_UNREACHABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_::RawBrandedSchema::makeDepLocation",
          "args": [
            "_::RawBrandedSchema::DepKind::CONST_TYPE",
            "0"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "makeDepLocation",
          "container": "RawBrandedSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "147-152",
          "snippet": "static inline uint makeDepLocation(DepKind kind, uint index) {\n    // Make a number representing the location of a particular dependency within its parent\n    // schema.\n\n    return (static_cast<uint>(kind) << 24) | index;\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nRawBrandedSchema {\n  static inline uint makeDepLocation(DepKind kind, uint index) {\n      // Make a number representing the location of a particular dependency within its parent\n      // schema.\n  \n      return (static_cast<uint>(kind) << 24) | index;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nType ConstSchema::getType() const {\n  return interpretType(getProto().getConst().getType(),\n      _::RawBrandedSchema::makeDepLocation(_::RawBrandedSchema::DepKind::CONST_TYPE, 0));\n}"
  },
  {
    "function_name": "ConstSchema::getValueSchemaOffset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "688-690",
    "snippet": "uint32_t ConstSchema::getValueSchemaOffset() const {\n  return getSchemaOffset(getProto().getConst().getValue());\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getSchemaOffset",
          "args": [
            "getProto().getConst().getValue()"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getSchemaOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "304-329",
          "snippet": "uint32_t Schema::getSchemaOffset(const schema::Value::Reader& value) const {\n  const word* ptr;\n\n  switch (value.which()) {\n    case schema::Value::TEXT:\n      ptr = reinterpret_cast<const word*>(value.getText().begin());\n      break;\n    case schema::Value::DATA:\n      ptr = reinterpret_cast<const word*>(value.getData().begin());\n      break;\n    case schema::Value::STRUCT:\n      ptr = value.getStruct().getAs<_::UncheckedMessage>();\n      break;\n    case schema::Value::LIST:\n      ptr = value.getList().getAs<_::UncheckedMessage>();\n      break;\n    case schema::Value::ANY_POINTER:\n      ptr = value.getAnyPointer().getAs<_::UncheckedMessage>();\n      break;\n    default:\n      KJ_FAIL_ASSERT(\"getDefaultValueSchemaOffset() can only be called on struct, list, \"\n                     \"and any-pointer fields.\");\n  }\n\n  return ptr - raw->generic->encodedNode;\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nuint32_t Schema::getSchemaOffset(const schema::Value::Reader& value) const {\n  const word* ptr;\n\n  switch (value.which()) {\n    case schema::Value::TEXT:\n      ptr = reinterpret_cast<const word*>(value.getText().begin());\n      break;\n    case schema::Value::DATA:\n      ptr = reinterpret_cast<const word*>(value.getData().begin());\n      break;\n    case schema::Value::STRUCT:\n      ptr = value.getStruct().getAs<_::UncheckedMessage>();\n      break;\n    case schema::Value::LIST:\n      ptr = value.getList().getAs<_::UncheckedMessage>();\n      break;\n    case schema::Value::ANY_POINTER:\n      ptr = value.getAnyPointer().getAs<_::UncheckedMessage>();\n      break;\n    default:\n      KJ_FAIL_ASSERT(\"getDefaultValueSchemaOffset() can only be called on struct, list, \"\n                     \"and any-pointer fields.\");\n  }\n\n  return ptr - raw->generic->encodedNode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nuint32_t ConstSchema::getValueSchemaOffset() const {\n  return getSchemaOffset(getProto().getConst().getValue());\n}"
  },
  {
    "function_name": "InterfaceSchema::SuperclassList::operator[]",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "679-684",
    "snippet": "InterfaceSchema InterfaceSchema::SuperclassList::operator[](uint index) const {\n  auto superclass = list[index];\n  uint location = _::RawBrandedSchema::makeDepLocation(\n      _::RawBrandedSchema::DepKind::SUPERCLASS, index);\n  return parent.getDependency(superclass.getId(), location).asInterface();\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parent.getDependency",
          "args": [],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent.getDependency",
          "args": [
            "superclass.getId()",
            "location"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "superclass.getId",
          "args": [],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_::RawBrandedSchema::makeDepLocation",
          "args": [
            "_::RawBrandedSchema::DepKind::SUPERCLASS",
            "index"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "makeDepLocation",
          "container": "RawBrandedSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "147-152",
          "snippet": "static inline uint makeDepLocation(DepKind kind, uint index) {\n    // Make a number representing the location of a particular dependency within its parent\n    // schema.\n\n    return (static_cast<uint>(kind) << 24) | index;\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nRawBrandedSchema {\n  static inline uint makeDepLocation(DepKind kind, uint index) {\n      // Make a number representing the location of a particular dependency within its parent\n      // schema.\n  \n      return (static_cast<uint>(kind) << 24) | index;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nInterfaceSchema InterfaceSchema::SuperclassList::operator[](uint index) const {\n  auto superclass = list[index];\n  uint location = _::RawBrandedSchema::makeDepLocation(\n      _::RawBrandedSchema::DepKind::SUPERCLASS, index);\n  return parent.getDependency(superclass.getId(), location).asInterface();\n}"
  },
  {
    "function_name": "InterfaceSchema::Method::getResultType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "672-677",
    "snippet": "StructSchema InterfaceSchema::Method::getResultType() const {\n  auto proto = getProto();\n  uint location = _::RawBrandedSchema::makeDepLocation(\n      _::RawBrandedSchema::DepKind::METHOD_RESULTS, ordinal);\n  return parent.getDependency(proto.getResultStructType(), location).asStruct();\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parent.getDependency",
          "args": [],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent.getDependency",
          "args": [
            "proto.getResultStructType()",
            "location"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getResultStructType",
          "args": [],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::RawBrandedSchema::makeDepLocation",
          "args": [
            "_::RawBrandedSchema::DepKind::METHOD_RESULTS",
            "ordinal"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "makeDepLocation",
          "container": "RawBrandedSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "147-152",
          "snippet": "static inline uint makeDepLocation(DepKind kind, uint index) {\n    // Make a number representing the location of a particular dependency within its parent\n    // schema.\n\n    return (static_cast<uint>(kind) << 24) | index;\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nRawBrandedSchema {\n  static inline uint makeDepLocation(DepKind kind, uint index) {\n      // Make a number representing the location of a particular dependency within its parent\n      // schema.\n  \n      return (static_cast<uint>(kind) << 24) | index;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nStructSchema InterfaceSchema::Method::getResultType() const {\n  auto proto = getProto();\n  uint location = _::RawBrandedSchema::makeDepLocation(\n      _::RawBrandedSchema::DepKind::METHOD_RESULTS, ordinal);\n  return parent.getDependency(proto.getResultStructType(), location).asStruct();\n}"
  },
  {
    "function_name": "InterfaceSchema::Method::getParamType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "665-670",
    "snippet": "StructSchema InterfaceSchema::Method::getParamType() const {\n  auto proto = getProto();\n  uint location = _::RawBrandedSchema::makeDepLocation(\n      _::RawBrandedSchema::DepKind::METHOD_PARAMS, ordinal);\n  return parent.getDependency(proto.getParamStructType(), location).asStruct();\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parent.getDependency",
          "args": [],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent.getDependency",
          "args": [
            "proto.getParamStructType()",
            "location"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getParamStructType",
          "args": [],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::RawBrandedSchema::makeDepLocation",
          "args": [
            "_::RawBrandedSchema::DepKind::METHOD_PARAMS",
            "ordinal"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "makeDepLocation",
          "container": "RawBrandedSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "147-152",
          "snippet": "static inline uint makeDepLocation(DepKind kind, uint index) {\n    // Make a number representing the location of a particular dependency within its parent\n    // schema.\n\n    return (static_cast<uint>(kind) << 24) | index;\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nRawBrandedSchema {\n  static inline uint makeDepLocation(DepKind kind, uint index) {\n      // Make a number representing the location of a particular dependency within its parent\n      // schema.\n  \n      return (static_cast<uint>(kind) << 24) | index;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nStructSchema InterfaceSchema::Method::getParamType() const {\n  auto proto = getProto();\n  uint location = _::RawBrandedSchema::makeDepLocation(\n      _::RawBrandedSchema::DepKind::METHOD_PARAMS, ordinal);\n  return parent.getDependency(proto.getParamStructType(), location).asStruct();\n}"
  },
  {
    "function_name": "InterfaceSchema::findSuperclass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "640-663",
    "snippet": "kj::Maybe<InterfaceSchema> InterfaceSchema::findSuperclass(uint64_t typeId, uint& counter) const {\n  // Security:  Don't let someone DOS us with a dynamic schema containing cyclic inheritance.\n  KJ_REQUIRE(counter++ < MAX_SUPERCLASSES, \"Cyclic or absurdly-large inheritance graph detected.\") {\n    return nullptr;\n  }\n\n  if (typeId == raw->generic->id) {\n    return *this;\n  }\n\n  // TODO(perf):  This may be somewhat slow.  See findMethodByName() for discussion.\n  auto superclasses = getProto().getInterface().getSuperclasses();\n  for (auto i: kj::indices(superclasses)) {\n    auto superclass = superclasses[i];\n    uint location = _::RawBrandedSchema::makeDepLocation(\n        _::RawBrandedSchema::DepKind::SUPERCLASS, i);\n    KJ_IF_MAYBE(result, getDependency(superclass.getId(), location).asInterface()\n                            .findSuperclass(typeId, counter)) {\n      return *result;\n    }\n  }\n\n  return nullptr;\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static constexpr uint MAX_SUPERCLASSES = 64;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "result",
            "getDependency(superclass.getId(), location).asInterface()\n                            .findSuperclass(typeId, counter)"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "getDependency",
          "args": [
            "typeId",
            "counter"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getDependency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "196-241",
          "snippet": "Schema Schema::getDependency(uint64_t id, uint location) const {\n  {\n    // Binary search dependency list.\n    uint lower = 0;\n    uint upper = raw->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      auto candidate = raw->dependencies[mid];\n      if (candidate.location == location) {\n        candidate.schema->ensureInitialized();\n        return Schema(candidate.schema);\n      } else if (candidate.location < location) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  {\n    uint lower = 0;\n    uint upper = raw->generic->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      const _::RawSchema* candidate = raw->generic->dependencies[mid];\n\n      uint64_t candidateId = candidate->id;\n      if (candidateId == id) {\n        candidate->ensureInitialized();\n        return Schema(&candidate->defaultBrand);\n      } else if (candidateId < id) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  KJ_FAIL_REQUIRE(\"Requested ID not found in dependency table.\", kj::hex(id)) {\n    return Schema();\n  }\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nSchema Schema::getDependency(uint64_t id, uint location) const {\n  {\n    // Binary search dependency list.\n    uint lower = 0;\n    uint upper = raw->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      auto candidate = raw->dependencies[mid];\n      if (candidate.location == location) {\n        candidate.schema->ensureInitialized();\n        return Schema(candidate.schema);\n      } else if (candidate.location < location) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  {\n    uint lower = 0;\n    uint upper = raw->generic->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      const _::RawSchema* candidate = raw->generic->dependencies[mid];\n\n      uint64_t candidateId = candidate->id;\n      if (candidateId == id) {\n        candidate->ensureInitialized();\n        return Schema(&candidate->defaultBrand);\n      } else if (candidateId < id) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  KJ_FAIL_REQUIRE(\"Requested ID not found in dependency table.\", kj::hex(id)) {\n    return Schema();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getDependency",
          "args": [],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "superclass.getId",
          "args": [],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_::RawBrandedSchema::makeDepLocation",
          "args": [
            "_::RawBrandedSchema::DepKind::SUPERCLASS",
            "i"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "makeDepLocation",
          "container": "RawBrandedSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "147-152",
          "snippet": "static inline uint makeDepLocation(DepKind kind, uint index) {\n    // Make a number representing the location of a particular dependency within its parent\n    // schema.\n\n    return (static_cast<uint>(kind) << 24) | index;\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nRawBrandedSchema {\n  static inline uint makeDepLocation(DepKind kind, uint index) {\n      // Make a number representing the location of a particular dependency within its parent\n      // schema.\n  \n      return (static_cast<uint>(kind) << 24) | index;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "superclasses"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "counter++ < MAX_SUPERCLASSES",
            "\"Cyclic or absurdly-large inheritance graph detected.\""
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nstatic constexpr uint MAX_SUPERCLASSES = 64;\n\nkj::Maybe<InterfaceSchema> InterfaceSchema::findSuperclass(uint64_t typeId, uint& counter) const {\n  // Security:  Don't let someone DOS us with a dynamic schema containing cyclic inheritance.\n  KJ_REQUIRE(counter++ < MAX_SUPERCLASSES, \"Cyclic or absurdly-large inheritance graph detected.\") {\n    return nullptr;\n  }\n\n  if (typeId == raw->generic->id) {\n    return *this;\n  }\n\n  // TODO(perf):  This may be somewhat slow.  See findMethodByName() for discussion.\n  auto superclasses = getProto().getInterface().getSuperclasses();\n  for (auto i: kj::indices(superclasses)) {\n    auto superclass = superclasses[i];\n    uint location = _::RawBrandedSchema::makeDepLocation(\n        _::RawBrandedSchema::DepKind::SUPERCLASS, i);\n    KJ_IF_MAYBE(result, getDependency(superclass.getId(), location).asInterface()\n                            .findSuperclass(typeId, counter)) {\n      return *result;\n    }\n  }\n\n  return nullptr;\n}"
  },
  {
    "function_name": "InterfaceSchema::findSuperclass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "631-638",
    "snippet": "kj::Maybe<InterfaceSchema> InterfaceSchema::findSuperclass(uint64_t typeId) const {\n  if (typeId == _::NULL_INTERFACE_SCHEMA.id) {\n    // We consider all interfaces to extend the null schema.\n    return InterfaceSchema();\n  }\n  uint counter = 0;\n  return findSuperclass(typeId, counter);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "InterfaceSchema",
          "args": [],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "fromImpl",
          "container": "InterfaceSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "466-468",
          "snippet": "static inline InterfaceSchema fromImpl() {\n    return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n  }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nInterfaceSchema {\n  static inline InterfaceSchema fromImpl() {\n      return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nkj::Maybe<InterfaceSchema> InterfaceSchema::findSuperclass(uint64_t typeId) const {\n  if (typeId == _::NULL_INTERFACE_SCHEMA.id) {\n    // We consider all interfaces to extend the null schema.\n    return InterfaceSchema();\n  }\n  uint counter = 0;\n  return findSuperclass(typeId, counter);\n}"
  },
  {
    "function_name": "InterfaceSchema::extends",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "607-629",
    "snippet": "bool InterfaceSchema::extends(InterfaceSchema other, uint& counter) const {\n  // Security:  Don't let someone DOS us with a dynamic schema containing cyclic inheritance.\n  KJ_REQUIRE(counter++ < MAX_SUPERCLASSES, \"Cyclic or absurdly-large inheritance graph detected.\") {\n    return nullptr;\n  }\n\n  if (other == *this) {\n    return true;\n  }\n\n  // TODO(perf):  This may be somewhat slow.  See findMethodByName() for discussion.\n  auto superclasses = getProto().getInterface().getSuperclasses();\n  for (auto i: kj::indices(superclasses)) {\n    auto superclass = superclasses[i];\n    uint location = _::RawBrandedSchema::makeDepLocation(\n        _::RawBrandedSchema::DepKind::SUPERCLASS, i);\n    if (getDependency(superclass.getId(), location).asInterface().extends(other, counter)) {\n      return true;\n    }\n  }\n\n  return false;\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static constexpr uint MAX_SUPERCLASSES = 64;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "getDependency",
          "args": [
            "other",
            "counter"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getDependency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "196-241",
          "snippet": "Schema Schema::getDependency(uint64_t id, uint location) const {\n  {\n    // Binary search dependency list.\n    uint lower = 0;\n    uint upper = raw->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      auto candidate = raw->dependencies[mid];\n      if (candidate.location == location) {\n        candidate.schema->ensureInitialized();\n        return Schema(candidate.schema);\n      } else if (candidate.location < location) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  {\n    uint lower = 0;\n    uint upper = raw->generic->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      const _::RawSchema* candidate = raw->generic->dependencies[mid];\n\n      uint64_t candidateId = candidate->id;\n      if (candidateId == id) {\n        candidate->ensureInitialized();\n        return Schema(&candidate->defaultBrand);\n      } else if (candidateId < id) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  KJ_FAIL_REQUIRE(\"Requested ID not found in dependency table.\", kj::hex(id)) {\n    return Schema();\n  }\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nSchema Schema::getDependency(uint64_t id, uint location) const {\n  {\n    // Binary search dependency list.\n    uint lower = 0;\n    uint upper = raw->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      auto candidate = raw->dependencies[mid];\n      if (candidate.location == location) {\n        candidate.schema->ensureInitialized();\n        return Schema(candidate.schema);\n      } else if (candidate.location < location) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  {\n    uint lower = 0;\n    uint upper = raw->generic->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      const _::RawSchema* candidate = raw->generic->dependencies[mid];\n\n      uint64_t candidateId = candidate->id;\n      if (candidateId == id) {\n        candidate->ensureInitialized();\n        return Schema(&candidate->defaultBrand);\n      } else if (candidateId < id) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  KJ_FAIL_REQUIRE(\"Requested ID not found in dependency table.\", kj::hex(id)) {\n    return Schema();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getDependency",
          "args": [],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "superclass.getId",
          "args": [],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_::RawBrandedSchema::makeDepLocation",
          "args": [
            "_::RawBrandedSchema::DepKind::SUPERCLASS",
            "i"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "makeDepLocation",
          "container": "RawBrandedSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "147-152",
          "snippet": "static inline uint makeDepLocation(DepKind kind, uint index) {\n    // Make a number representing the location of a particular dependency within its parent\n    // schema.\n\n    return (static_cast<uint>(kind) << 24) | index;\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nRawBrandedSchema {\n  static inline uint makeDepLocation(DepKind kind, uint index) {\n      // Make a number representing the location of a particular dependency within its parent\n      // schema.\n  \n      return (static_cast<uint>(kind) << 24) | index;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "superclasses"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "counter++ < MAX_SUPERCLASSES",
            "\"Cyclic or absurdly-large inheritance graph detected.\""
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nstatic constexpr uint MAX_SUPERCLASSES = 64;\n\nbool InterfaceSchema::extends(InterfaceSchema other, uint& counter) const {\n  // Security:  Don't let someone DOS us with a dynamic schema containing cyclic inheritance.\n  KJ_REQUIRE(counter++ < MAX_SUPERCLASSES, \"Cyclic or absurdly-large inheritance graph detected.\") {\n    return nullptr;\n  }\n\n  if (other == *this) {\n    return true;\n  }\n\n  // TODO(perf):  This may be somewhat slow.  See findMethodByName() for discussion.\n  auto superclasses = getProto().getInterface().getSuperclasses();\n  for (auto i: kj::indices(superclasses)) {\n    auto superclass = superclasses[i];\n    uint location = _::RawBrandedSchema::makeDepLocation(\n        _::RawBrandedSchema::DepKind::SUPERCLASS, i);\n    if (getDependency(superclass.getId(), location).asInterface().extends(other, counter)) {\n      return true;\n    }\n  }\n\n  return false;\n}"
  },
  {
    "function_name": "InterfaceSchema::extends",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "598-605",
    "snippet": "bool InterfaceSchema::extends(InterfaceSchema other) const {\n  if (other.raw->generic == &_::NULL_INTERFACE_SCHEMA) {\n    // We consider all interfaces to extend the null schema.\n    return true;\n  }\n  uint counter = 0;\n  return extends(other, counter);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nbool InterfaceSchema::extends(InterfaceSchema other) const {\n  if (other.raw->generic == &_::NULL_INTERFACE_SCHEMA) {\n    // We consider all interfaces to extend the null schema.\n    return true;\n  }\n  uint counter = 0;\n  return extends(other, counter);\n}"
  },
  {
    "function_name": "InterfaceSchema::getSuperclasses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "594-596",
    "snippet": "InterfaceSchema::SuperclassList InterfaceSchema::getSuperclasses() const {\n  return SuperclassList(*this, getProto().getInterface().getSuperclasses());\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SuperclassList",
          "args": [
            "*this",
            "getProto().getInterface().getSuperclasses()"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "SuperclassList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "544-545",
          "snippet": "inline SuperclassList(InterfaceSchema parent, List<schema::Superclass>::Reader list)\n      : parent(parent), list(list) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline SuperclassList(InterfaceSchema parent, List<schema::Superclass>::Reader list)\n      : parent(parent), list(list) {}"
        }
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nInterfaceSchema::SuperclassList InterfaceSchema::getSuperclasses() const {\n  return SuperclassList(*this, getProto().getInterface().getSuperclasses());\n}"
  },
  {
    "function_name": "InterfaceSchema::getMethodByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "586-592",
    "snippet": "InterfaceSchema::Method InterfaceSchema::getMethodByName(kj::StringPtr name) const {\n  KJ_IF_MAYBE(method, findMethodByName(name)) {\n    return *method;\n  } else {\n    KJ_FAIL_REQUIRE(\"interface has no such method\", name);\n  }\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"interface has no such method\"",
            "name"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nInterfaceSchema::Method InterfaceSchema::getMethodByName(kj::StringPtr name) const {\n  KJ_IF_MAYBE(method, findMethodByName(name)) {\n    return *method;\n  } else {\n    KJ_FAIL_REQUIRE(\"interface has no such method\", name);\n  }\n}"
  },
  {
    "function_name": "InterfaceSchema::findMethodByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "553-584",
    "snippet": "kj::Maybe<InterfaceSchema::Method> InterfaceSchema::findMethodByName(\n    kj::StringPtr name, uint& counter) const {\n  // Security:  Don't let someone DOS us with a dynamic schema containing cyclic inheritance.\n  KJ_REQUIRE(counter++ < MAX_SUPERCLASSES, \"Cyclic or absurdly-large inheritance graph detected.\") {\n    return nullptr;\n  }\n\n  auto result = findSchemaMemberByName(raw->generic, name, getMethods());\n\n  if (result == nullptr) {\n    // Search superclasses.\n    // TODO(perf):  This may be somewhat slow, and in the case of lots of diamond dependencies it\n    //   could get pathological.  Arguably we should generate a flat list of transitive\n    //   superclasses to search and store it in the RawSchema.  It's problematic, though, because\n    //   this means that a dynamically-loaded RawSchema cannot be correctly constructed until all\n    //   superclasses have been loaded, which imposes an ordering requirement on SchemaLoader or\n    //   requires updating subclasses whenever a new superclass is loaded.\n    auto superclasses = getProto().getInterface().getSuperclasses();\n    for (auto i: kj::indices(superclasses)) {\n      auto superclass = superclasses[i];\n      uint location = _::RawBrandedSchema::makeDepLocation(\n          _::RawBrandedSchema::DepKind::SUPERCLASS, i);\n      result = getDependency(superclass.getId(), location)\n          .asInterface().findMethodByName(name, counter);\n      if (result != nullptr) {\n        break;\n      }\n    }\n  }\n\n  return result;\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static constexpr uint MAX_SUPERCLASSES = 64;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "getDependency",
          "args": [
            "name",
            "counter"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getDependency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "196-241",
          "snippet": "Schema Schema::getDependency(uint64_t id, uint location) const {\n  {\n    // Binary search dependency list.\n    uint lower = 0;\n    uint upper = raw->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      auto candidate = raw->dependencies[mid];\n      if (candidate.location == location) {\n        candidate.schema->ensureInitialized();\n        return Schema(candidate.schema);\n      } else if (candidate.location < location) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  {\n    uint lower = 0;\n    uint upper = raw->generic->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      const _::RawSchema* candidate = raw->generic->dependencies[mid];\n\n      uint64_t candidateId = candidate->id;\n      if (candidateId == id) {\n        candidate->ensureInitialized();\n        return Schema(&candidate->defaultBrand);\n      } else if (candidateId < id) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  KJ_FAIL_REQUIRE(\"Requested ID not found in dependency table.\", kj::hex(id)) {\n    return Schema();\n  }\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nSchema Schema::getDependency(uint64_t id, uint location) const {\n  {\n    // Binary search dependency list.\n    uint lower = 0;\n    uint upper = raw->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      auto candidate = raw->dependencies[mid];\n      if (candidate.location == location) {\n        candidate.schema->ensureInitialized();\n        return Schema(candidate.schema);\n      } else if (candidate.location < location) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  {\n    uint lower = 0;\n    uint upper = raw->generic->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      const _::RawSchema* candidate = raw->generic->dependencies[mid];\n\n      uint64_t candidateId = candidate->id;\n      if (candidateId == id) {\n        candidate->ensureInitialized();\n        return Schema(&candidate->defaultBrand);\n      } else if (candidateId < id) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  KJ_FAIL_REQUIRE(\"Requested ID not found in dependency table.\", kj::hex(id)) {\n    return Schema();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getDependency",
          "args": [],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "superclass.getId",
          "args": [],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_::RawBrandedSchema::makeDepLocation",
          "args": [
            "_::RawBrandedSchema::DepKind::SUPERCLASS",
            "i"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "makeDepLocation",
          "container": "RawBrandedSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "147-152",
          "snippet": "static inline uint makeDepLocation(DepKind kind, uint index) {\n    // Make a number representing the location of a particular dependency within its parent\n    // schema.\n\n    return (static_cast<uint>(kind) << 24) | index;\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nRawBrandedSchema {\n  static inline uint makeDepLocation(DepKind kind, uint index) {\n      // Make a number representing the location of a particular dependency within its parent\n      // schema.\n  \n      return (static_cast<uint>(kind) << 24) | index;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "superclasses"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "findSchemaMemberByName",
          "args": [
            "raw->generic",
            "name",
            "getMethods()"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "findSchemaMemberByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "434-456",
          "snippet": "auto findSchemaMemberByName(const _::RawSchema* raw, kj::StringPtr name, List&& list)\n    -> kj::Maybe<decltype(list[0])> {\n  uint lower = 0;\n  uint upper = raw->memberCount;\n\n  while (lower < upper) {\n    uint mid = (lower + upper) / 2;\n\n    uint16_t memberIndex = raw->membersByName[mid];\n\n    auto candidate = list[memberIndex];\n    kj::StringPtr candidateName = candidate.getProto().getName();\n    if (candidateName == name) {\n      return candidate;\n    } else if (candidateName < name) {\n      lower = mid + 1;\n    } else {\n      upper = mid;\n    }\n  }\n\n  return nullptr;\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nauto findSchemaMemberByName(const _::RawSchema* raw, kj::StringPtr name, List&& list)\n    -> kj::Maybe<decltype(list[0])> {\n  uint lower = 0;\n  uint upper = raw->memberCount;\n\n  while (lower < upper) {\n    uint mid = (lower + upper) / 2;\n\n    uint16_t memberIndex = raw->membersByName[mid];\n\n    auto candidate = list[memberIndex];\n    kj::StringPtr candidateName = candidate.getProto().getName();\n    if (candidateName == name) {\n      return candidate;\n    } else if (candidateName < name) {\n      lower = mid + 1;\n    } else {\n      upper = mid;\n    }\n  }\n\n  return nullptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getMethods",
          "args": [],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "InterfaceSchema::getMethods",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "542-544",
          "snippet": "InterfaceSchema::MethodList InterfaceSchema::getMethods() const {\n  return MethodList(*this, getProto().getInterface().getMethods());\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nInterfaceSchema::MethodList InterfaceSchema::getMethods() const {\n  return MethodList(*this, getProto().getInterface().getMethods());\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "counter++ < MAX_SUPERCLASSES",
            "\"Cyclic or absurdly-large inheritance graph detected.\""
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nstatic constexpr uint MAX_SUPERCLASSES = 64;\n\nkj::Maybe<InterfaceSchema::Method> InterfaceSchema::findMethodByName(\n    kj::StringPtr name, uint& counter) const {\n  // Security:  Don't let someone DOS us with a dynamic schema containing cyclic inheritance.\n  KJ_REQUIRE(counter++ < MAX_SUPERCLASSES, \"Cyclic or absurdly-large inheritance graph detected.\") {\n    return nullptr;\n  }\n\n  auto result = findSchemaMemberByName(raw->generic, name, getMethods());\n\n  if (result == nullptr) {\n    // Search superclasses.\n    // TODO(perf):  This may be somewhat slow, and in the case of lots of diamond dependencies it\n    //   could get pathological.  Arguably we should generate a flat list of transitive\n    //   superclasses to search and store it in the RawSchema.  It's problematic, though, because\n    //   this means that a dynamically-loaded RawSchema cannot be correctly constructed until all\n    //   superclasses have been loaded, which imposes an ordering requirement on SchemaLoader or\n    //   requires updating subclasses whenever a new superclass is loaded.\n    auto superclasses = getProto().getInterface().getSuperclasses();\n    for (auto i: kj::indices(superclasses)) {\n      auto superclass = superclasses[i];\n      uint location = _::RawBrandedSchema::makeDepLocation(\n          _::RawBrandedSchema::DepKind::SUPERCLASS, i);\n      result = getDependency(superclass.getId(), location)\n          .asInterface().findMethodByName(name, counter);\n      if (result != nullptr) {\n        break;\n      }\n    }\n  }\n\n  return result;\n}"
  },
  {
    "function_name": "InterfaceSchema::findMethodByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "546-549",
    "snippet": "kj::Maybe<InterfaceSchema::Method> InterfaceSchema::findMethodByName(kj::StringPtr name) const {\n  uint counter = 0;\n  return findMethodByName(name, counter);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nkj::Maybe<InterfaceSchema::Method> InterfaceSchema::findMethodByName(kj::StringPtr name) const {\n  uint counter = 0;\n  return findMethodByName(name, counter);\n}"
  },
  {
    "function_name": "InterfaceSchema::getMethods",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "542-544",
    "snippet": "InterfaceSchema::MethodList InterfaceSchema::getMethods() const {\n  return MethodList(*this, getProto().getInterface().getMethods());\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MethodList",
          "args": [
            "*this",
            "getProto().getInterface().getMethods()"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "MethodList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "523-524",
          "snippet": "inline MethodList(InterfaceSchema parent, List<schema::Method>::Reader list)\n      : parent(parent), list(list) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline MethodList(InterfaceSchema parent, List<schema::Method>::Reader list)\n      : parent(parent), list(list) {}"
        }
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nInterfaceSchema::MethodList InterfaceSchema::getMethods() const {\n  return MethodList(*this, getProto().getInterface().getMethods());\n}"
  },
  {
    "function_name": "EnumSchema::getEnumerantByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "532-538",
    "snippet": "EnumSchema::Enumerant EnumSchema::getEnumerantByName(kj::StringPtr name) const {\n  KJ_IF_MAYBE(enumerant, findEnumerantByName(name)) {\n    return *enumerant;\n  } else {\n    KJ_FAIL_REQUIRE(\"enum has no such enumerant\", name);\n  }\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"enum has no such enumerant\"",
            "name"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nEnumSchema::Enumerant EnumSchema::getEnumerantByName(kj::StringPtr name) const {\n  KJ_IF_MAYBE(enumerant, findEnumerantByName(name)) {\n    return *enumerant;\n  } else {\n    KJ_FAIL_REQUIRE(\"enum has no such enumerant\", name);\n  }\n}"
  },
  {
    "function_name": "EnumSchema::findEnumerantByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "528-530",
    "snippet": "kj::Maybe<EnumSchema::Enumerant> EnumSchema::findEnumerantByName(kj::StringPtr name) const {\n  return findSchemaMemberByName(raw->generic, name, getEnumerants());\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "findSchemaMemberByName",
          "args": [
            "raw->generic",
            "name",
            "getEnumerants()"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "findSchemaMemberByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "434-456",
          "snippet": "auto findSchemaMemberByName(const _::RawSchema* raw, kj::StringPtr name, List&& list)\n    -> kj::Maybe<decltype(list[0])> {\n  uint lower = 0;\n  uint upper = raw->memberCount;\n\n  while (lower < upper) {\n    uint mid = (lower + upper) / 2;\n\n    uint16_t memberIndex = raw->membersByName[mid];\n\n    auto candidate = list[memberIndex];\n    kj::StringPtr candidateName = candidate.getProto().getName();\n    if (candidateName == name) {\n      return candidate;\n    } else if (candidateName < name) {\n      lower = mid + 1;\n    } else {\n      upper = mid;\n    }\n  }\n\n  return nullptr;\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nauto findSchemaMemberByName(const _::RawSchema* raw, kj::StringPtr name, List&& list)\n    -> kj::Maybe<decltype(list[0])> {\n  uint lower = 0;\n  uint upper = raw->memberCount;\n\n  while (lower < upper) {\n    uint mid = (lower + upper) / 2;\n\n    uint16_t memberIndex = raw->membersByName[mid];\n\n    auto candidate = list[memberIndex];\n    kj::StringPtr candidateName = candidate.getProto().getName();\n    if (candidateName == name) {\n      return candidate;\n    } else if (candidateName < name) {\n      lower = mid + 1;\n    } else {\n      upper = mid;\n    }\n  }\n\n  return nullptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getEnumerants",
          "args": [],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "EnumSchema::getEnumerants",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "524-526",
          "snippet": "EnumSchema::EnumerantList EnumSchema::getEnumerants() const {\n  return EnumerantList(*this, getProto().getEnum().getEnumerants());\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nEnumSchema::EnumerantList EnumSchema::getEnumerants() const {\n  return EnumerantList(*this, getProto().getEnum().getEnumerants());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nkj::Maybe<EnumSchema::Enumerant> EnumSchema::findEnumerantByName(kj::StringPtr name) const {\n  return findSchemaMemberByName(raw->generic, name, getEnumerants());\n}"
  },
  {
    "function_name": "EnumSchema::getEnumerants",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "524-526",
    "snippet": "EnumSchema::EnumerantList EnumSchema::getEnumerants() const {\n  return EnumerantList(*this, getProto().getEnum().getEnumerants());\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EnumerantList",
          "args": [
            "*this",
            "getProto().getEnum().getEnumerants()"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "EnumerantList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "430-431",
          "snippet": "inline EnumerantList(EnumSchema parent, List<schema::Enumerant>::Reader list)\n      : parent(parent), list(list) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline EnumerantList(EnumSchema parent, List<schema::Enumerant>::Reader list)\n      : parent(parent), list(list) {}"
        }
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nEnumSchema::EnumerantList EnumSchema::getEnumerants() const {\n  return EnumerantList(*this, getProto().getEnum().getEnumerants());\n}"
  },
  {
    "function_name": "KJ_STRINGIFY",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "518-520",
    "snippet": "kj::StringPtr KJ_STRINGIFY(const StructSchema::Field& field) {\n  return field.getProto().getName();\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "field.getProto",
          "args": [],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nkj::StringPtr KJ_STRINGIFY(const StructSchema::Field& field) {\n  return field.getProto().getName();\n}"
  },
  {
    "function_name": "StructSchema::Field::getDefaultValueSchemaOffset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "514-516",
    "snippet": "uint32_t StructSchema::Field::getDefaultValueSchemaOffset() const {\n  return parent.getSchemaOffset(proto.getSlot().getDefaultValue());\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parent.getSchemaOffset",
          "args": [
            "proto.getSlot().getDefaultValue()"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getSlot",
          "args": [],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getSlot",
          "args": [],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nuint32_t StructSchema::Field::getDefaultValueSchemaOffset() const {\n  return parent.getSchemaOffset(proto.getSlot().getDefaultValue());\n}"
  },
  {
    "function_name": "StructSchema::Field::getType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "500-512",
    "snippet": "Type StructSchema::Field::getType() const {\n  auto proto = getProto();\n  uint location = _::RawBrandedSchema::makeDepLocation(_::RawBrandedSchema::DepKind::FIELD, index);\n\n  switch (proto.which()) {\n    case schema::Field::SLOT:\n      return parent.interpretType(proto.getSlot().getType(), location);\n\n    case schema::Field::GROUP:\n      return parent.getDependency(proto.getGroup().getTypeId(), location).asStruct();\n  }\n  KJ_UNREACHABLE;\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parent.getDependency",
          "args": [],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent.getDependency",
          "args": [
            "proto.getGroup().getTypeId()",
            "location"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getGroup",
          "args": [],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getGroup",
          "args": [],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent.interpretType",
          "args": [
            "proto.getSlot().getType()",
            "location"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getSlot",
          "args": [],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getSlot",
          "args": [],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.which",
          "args": [],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::RawBrandedSchema::makeDepLocation",
          "args": [
            "_::RawBrandedSchema::DepKind::FIELD",
            "index"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "makeDepLocation",
          "container": "RawBrandedSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "147-152",
          "snippet": "static inline uint makeDepLocation(DepKind kind, uint index) {\n    // Make a number representing the location of a particular dependency within its parent\n    // schema.\n\n    return (static_cast<uint>(kind) << 24) | index;\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nRawBrandedSchema {\n  static inline uint makeDepLocation(DepKind kind, uint index) {\n      // Make a number representing the location of a particular dependency within its parent\n      // schema.\n  \n      return (static_cast<uint>(kind) << 24) | index;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nType StructSchema::Field::getType() const {\n  auto proto = getProto();\n  uint location = _::RawBrandedSchema::makeDepLocation(_::RawBrandedSchema::DepKind::FIELD, index);\n\n  switch (proto.which()) {\n    case schema::Field::SLOT:\n      return parent.interpretType(proto.getSlot().getType(), location);\n\n    case schema::Field::GROUP:\n      return parent.getDependency(proto.getGroup().getTypeId(), location).asStruct();\n  }\n  KJ_UNREACHABLE;\n}"
  },
  {
    "function_name": "StructSchema::getFieldByDiscriminant",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "490-498",
    "snippet": "kj::Maybe<StructSchema::Field> StructSchema::getFieldByDiscriminant(uint16_t discriminant) const {\n  auto unionFields = getUnionFields();\n\n  if (discriminant >= unionFields.size()) {\n    return nullptr;\n  } else {\n    return unionFields[discriminant];\n  }\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unionFields.size",
          "args": [],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "533-533",
          "snippet": "inline uint size() const { return list.size(); }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline uint size() const { return list.size(); }"
        }
      },
      {
        "call_info": {
          "callee": "getUnionFields",
          "args": [],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "StructSchema::getUnionFields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "464-468",
          "snippet": "StructSchema::FieldSubset StructSchema::getUnionFields() const {\n  auto proto = getProto().getStruct();\n  return FieldSubset(*this, proto.getFields(),\n                     raw->generic->membersByDiscriminant, proto.getDiscriminantCount());\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nStructSchema::FieldSubset StructSchema::getUnionFields() const {\n  auto proto = getProto().getStruct();\n  return FieldSubset(*this, proto.getFields(),\n                     raw->generic->membersByDiscriminant, proto.getDiscriminantCount());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nkj::Maybe<StructSchema::Field> StructSchema::getFieldByDiscriminant(uint16_t discriminant) const {\n  auto unionFields = getUnionFields();\n\n  if (discriminant >= unionFields.size()) {\n    return nullptr;\n  } else {\n    return unionFields[discriminant];\n  }\n}"
  },
  {
    "function_name": "StructSchema::getFieldByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "482-487",
    "snippet": "StructSchema::Field StructSchema::getFieldByName(kj::StringPtr name) const {\n  KJ_IF_MAYBE(member, findFieldByName(name)) {\n    return *member;\n  } else {\n    KJ_FAIL_REQUIRE(\"struct has no such member\", name);\n  }",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"struct has no such member\"",
            "name"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nStructSchema::Field StructSchema::getFieldByName(kj::StringPtr name) const {\n  KJ_IF_MAYBE(member, findFieldByName(name)) {\n    return *member;\n  } else {\n    KJ_FAIL_REQUIRE(\"struct has no such member\", name);\n  }"
  },
  {
    "function_name": "StructSchema::findFieldByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "478-480",
    "snippet": "kj::Maybe<StructSchema::Field> StructSchema::findFieldByName(kj::StringPtr name) const {\n  return findSchemaMemberByName(raw->generic, name, getFields());\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "findSchemaMemberByName",
          "args": [
            "raw->generic",
            "name",
            "getFields()"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "findSchemaMemberByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "434-456",
          "snippet": "auto findSchemaMemberByName(const _::RawSchema* raw, kj::StringPtr name, List&& list)\n    -> kj::Maybe<decltype(list[0])> {\n  uint lower = 0;\n  uint upper = raw->memberCount;\n\n  while (lower < upper) {\n    uint mid = (lower + upper) / 2;\n\n    uint16_t memberIndex = raw->membersByName[mid];\n\n    auto candidate = list[memberIndex];\n    kj::StringPtr candidateName = candidate.getProto().getName();\n    if (candidateName == name) {\n      return candidate;\n    } else if (candidateName < name) {\n      lower = mid + 1;\n    } else {\n      upper = mid;\n    }\n  }\n\n  return nullptr;\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nauto findSchemaMemberByName(const _::RawSchema* raw, kj::StringPtr name, List&& list)\n    -> kj::Maybe<decltype(list[0])> {\n  uint lower = 0;\n  uint upper = raw->memberCount;\n\n  while (lower < upper) {\n    uint mid = (lower + upper) / 2;\n\n    uint16_t memberIndex = raw->membersByName[mid];\n\n    auto candidate = list[memberIndex];\n    kj::StringPtr candidateName = candidate.getProto().getName();\n    if (candidateName == name) {\n      return candidate;\n    } else if (candidateName < name) {\n      lower = mid + 1;\n    } else {\n      upper = mid;\n    }\n  }\n\n  return nullptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getFields",
          "args": [],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "StructSchema::getFields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "460-462",
          "snippet": "StructSchema::FieldList StructSchema::getFields() const {\n  return FieldList(*this, getProto().getStruct().getFields());\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nStructSchema::FieldList StructSchema::getFields() const {\n  return FieldList(*this, getProto().getStruct().getFields());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nkj::Maybe<StructSchema::Field> StructSchema::findFieldByName(kj::StringPtr name) const {\n  return findSchemaMemberByName(raw->generic, name, getFields());\n}"
  },
  {
    "function_name": "StructSchema::getNonUnionFields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "470-476",
    "snippet": "StructSchema::FieldSubset StructSchema::getNonUnionFields() const {\n  auto proto = getProto().getStruct();\n  auto fields = proto.getFields();\n  auto offset = proto.getDiscriminantCount();\n  auto size = fields.size() - offset;\n  return FieldSubset(*this, fields, raw->generic->membersByDiscriminant + offset, size);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FieldSubset",
          "args": [
            "*this",
            "fields",
            "raw->generic->membersByDiscriminant + offset",
            "size"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "FieldSubset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "359-361",
          "snippet": "inline FieldSubset(StructSchema parent, List<schema::Field>::Reader list,\n                     const uint16_t* indices, uint size)\n      : parent(parent), list(list), indices(indices), size_(size) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline FieldSubset(StructSchema parent, List<schema::Field>::Reader list,\n                     const uint16_t* indices, uint size)\n      : parent(parent), list(list), indices(indices), size_(size) {}"
        }
      },
      {
        "call_info": {
          "callee": "fields.size",
          "args": [],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "533-533",
          "snippet": "inline uint size() const { return list.size(); }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline uint size() const { return list.size(); }"
        }
      },
      {
        "call_info": {
          "callee": "proto.getDiscriminantCount",
          "args": [],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getFields",
          "args": [],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nStructSchema::FieldSubset StructSchema::getNonUnionFields() const {\n  auto proto = getProto().getStruct();\n  auto fields = proto.getFields();\n  auto offset = proto.getDiscriminantCount();\n  auto size = fields.size() - offset;\n  return FieldSubset(*this, fields, raw->generic->membersByDiscriminant + offset, size);\n}"
  },
  {
    "function_name": "StructSchema::getUnionFields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "464-468",
    "snippet": "StructSchema::FieldSubset StructSchema::getUnionFields() const {\n  auto proto = getProto().getStruct();\n  return FieldSubset(*this, proto.getFields(),\n                     raw->generic->membersByDiscriminant, proto.getDiscriminantCount());\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FieldSubset",
          "args": [
            "*this",
            "proto.getFields()",
            "raw->generic->membersByDiscriminant",
            "proto.getDiscriminantCount()"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "FieldSubset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "359-361",
          "snippet": "inline FieldSubset(StructSchema parent, List<schema::Field>::Reader list,\n                     const uint16_t* indices, uint size)\n      : parent(parent), list(list), indices(indices), size_(size) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline FieldSubset(StructSchema parent, List<schema::Field>::Reader list,\n                     const uint16_t* indices, uint size)\n      : parent(parent), list(list), indices(indices), size_(size) {}"
        }
      },
      {
        "call_info": {
          "callee": "proto.getDiscriminantCount",
          "args": [],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getFields",
          "args": [],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nStructSchema::FieldSubset StructSchema::getUnionFields() const {\n  auto proto = getProto().getStruct();\n  return FieldSubset(*this, proto.getFields(),\n                     raw->generic->membersByDiscriminant, proto.getDiscriminantCount());\n}"
  },
  {
    "function_name": "StructSchema::getFields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "460-462",
    "snippet": "StructSchema::FieldList StructSchema::getFields() const {\n  return FieldList(*this, getProto().getStruct().getFields());\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FieldList",
          "args": [
            "*this",
            "getProto().getStruct().getFields()"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "FieldList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "334-335",
          "snippet": "inline FieldList(StructSchema parent, List<schema::Field>::Reader list)\n      : parent(parent), list(list) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline FieldList(StructSchema parent, List<schema::Field>::Reader list)\n      : parent(parent), list(list) {}"
        }
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nStructSchema::FieldList StructSchema::getFields() const {\n  return FieldList(*this, getProto().getStruct().getFields());\n}"
  },
  {
    "function_name": "findSchemaMemberByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "434-456",
    "snippet": "auto findSchemaMemberByName(const _::RawSchema* raw, kj::StringPtr name, List&& list)\n    -> kj::Maybe<decltype(list[0])> {\n  uint lower = 0;\n  uint upper = raw->memberCount;\n\n  while (lower < upper) {\n    uint mid = (lower + upper) / 2;\n\n    uint16_t memberIndex = raw->membersByName[mid];\n\n    auto candidate = list[memberIndex];\n    kj::StringPtr candidateName = candidate.getProto().getName();\n    if (candidateName == name) {\n      return candidate;\n    } else if (candidateName < name) {\n      lower = mid + 1;\n    } else {\n      upper = mid;\n    }\n  }\n\n  return nullptr;\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "candidate.getProto",
          "args": [],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nauto findSchemaMemberByName(const _::RawSchema* raw, kj::StringPtr name, List&& list)\n    -> kj::Maybe<decltype(list[0])> {\n  uint lower = 0;\n  uint upper = raw->memberCount;\n\n  while (lower < upper) {\n    uint mid = (lower + upper) / 2;\n\n    uint16_t memberIndex = raw->membersByName[mid];\n\n    auto candidate = list[memberIndex];\n    kj::StringPtr candidateName = candidate.getProto().getName();\n    if (candidateName == name) {\n      return candidate;\n    } else if (candidateName < name) {\n      lower = mid + 1;\n    } else {\n      upper = mid;\n    }\n  }\n\n  return nullptr;\n}"
  },
  {
    "function_name": "KJ_STRINGIFY",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "425-427",
    "snippet": "kj::StringPtr KJ_STRINGIFY(const Schema& schema) {\n  return schema.getProto().getDisplayName();\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schema.getProto",
          "args": [],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nkj::StringPtr KJ_STRINGIFY(const Schema& schema) {\n  return schema.getProto().getDisplayName();\n}"
  },
  {
    "function_name": "Schema::BrandArgumentList::operator[]",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "392-423",
    "snippet": "Type Schema::BrandArgumentList::operator[](uint index) const {\n  if (isUnbound) {\n    return Type::BrandParameter { scopeId, index };\n  }\n\n  if (index >= size_) {\n    // Binding index out-of-range. Treat as AnyPointer. This is important to allow new\n    // type parameters to be added to existing types without breaking dependent\n    // schemas.\n    return schema::Type::ANY_POINTER;\n  }\n\n  auto& binding = bindings[index];\n  Type result;\n  if (binding.which == (uint)schema::Type::ANY_POINTER) {\n    if (binding.scopeId != 0) {\n      result = Type::BrandParameter { binding.scopeId, binding.paramIndex };\n    } else if (binding.isImplicitParameter) {\n      result = Type::ImplicitParameter { binding.paramIndex };\n    } else {\n      result = static_cast<schema::Type::AnyPointer::Unconstrained::Which>(binding.paramIndex);\n    }\n  } else if (binding.schema == nullptr) {\n    // Builtin / primitive type.\n    result = static_cast<schema::Type::Which>(binding.which);\n  } else {\n    binding.schema->ensureInitialized();\n    result = Type(static_cast<schema::Type::Which>(binding.which), binding.schema);\n  }\n\n  return result.wrapInList(binding.listDepth);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.wrapInList",
          "args": [
            "binding.listDepth"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Type",
          "args": [
            "static_cast<schema::Type::Which>(binding.which)",
            "binding.schema"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::interpretType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "335-390",
          "snippet": "Type Schema::interpretType(schema::Type::Reader proto, uint location) const {\n  switch (proto.which()) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      return proto.which();\n\n    case schema::Type::STRUCT: {\n      auto structType = proto.getStruct();\n      return getDependency(structType.getTypeId(), location).asStruct();\n    }\n\n    case schema::Type::ENUM: {\n      auto enumType = proto.getEnum();\n      return getDependency(enumType.getTypeId(), location).asEnum();\n    }\n\n    case schema::Type::INTERFACE: {\n      auto interfaceType = proto.getInterface();\n      return getDependency(interfaceType.getTypeId(), location).asInterface();\n    }\n\n    case schema::Type::LIST:\n      return ListSchema::of(interpretType(proto.getList().getElementType(), location));\n\n    case schema::Type::ANY_POINTER: {\n      auto anyPointer = proto.getAnyPointer();\n      switch (anyPointer.which()) {\n        case schema::Type::AnyPointer::UNCONSTRAINED:\n          return anyPointer.getUnconstrained().which();\n        case schema::Type::AnyPointer::PARAMETER: {\n          auto param = anyPointer.getParameter();\n          return getBrandBinding(param.getScopeId(), param.getParameterIndex());\n        }\n        case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER:\n          return Type(Type::ImplicitParameter {\n              anyPointer.getImplicitMethodParameter().getParameterIndex() });\n      }\n\n      KJ_UNREACHABLE;\n    }\n  }\n\n  KJ_UNREACHABLE;\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nType Schema::interpretType(schema::Type::Reader proto, uint location) const {\n  switch (proto.which()) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      return proto.which();\n\n    case schema::Type::STRUCT: {\n      auto structType = proto.getStruct();\n      return getDependency(structType.getTypeId(), location).asStruct();\n    }\n\n    case schema::Type::ENUM: {\n      auto enumType = proto.getEnum();\n      return getDependency(enumType.getTypeId(), location).asEnum();\n    }\n\n    case schema::Type::INTERFACE: {\n      auto interfaceType = proto.getInterface();\n      return getDependency(interfaceType.getTypeId(), location).asInterface();\n    }\n\n    case schema::Type::LIST:\n      return ListSchema::of(interpretType(proto.getList().getElementType(), location));\n\n    case schema::Type::ANY_POINTER: {\n      auto anyPointer = proto.getAnyPointer();\n      switch (anyPointer.which()) {\n        case schema::Type::AnyPointer::UNCONSTRAINED:\n          return anyPointer.getUnconstrained().which();\n        case schema::Type::AnyPointer::PARAMETER: {\n          auto param = anyPointer.getParameter();\n          return getBrandBinding(param.getScopeId(), param.getParameterIndex());\n        }\n        case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER:\n          return Type(Type::ImplicitParameter {\n              anyPointer.getImplicitMethodParameter().getParameterIndex() });\n      }\n\n      KJ_UNREACHABLE;\n    }\n  }\n\n  KJ_UNREACHABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<schema::Type::Which>",
          "args": [
            "binding.which"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "binding.schema->ensureInitialized",
          "args": [],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "ensureInitialized",
          "container": "RawSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "221-228",
          "snippet": "inline void ensureInitialized() const {\n    // Lazy initialization support.  Invoke to ensure that initialization has taken place.  This\n    // is required in particular when traversing the dependency list.  RawSchemas for compiled-in\n    // types are always initialized; only dynamically-loaded schemas may be lazy.\n\n    const Initializer* i = __atomic_load_n(&lazyInitializer, __ATOMIC_ACQUIRE);\n    if (i != nullptr) i->init(this);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nRawSchema {\n  inline void ensureInitialized() const {\n      // Lazy initialization support.  Invoke to ensure that initialization has taken place.  This\n      // is required in particular when traversing the dependency list.  RawSchemas for compiled-in\n      // types are always initialized; only dynamically-loaded schemas may be lazy.\n  \n      const Initializer* i = __atomic_load_n(&lazyInitializer, __ATOMIC_ACQUIRE);\n      if (i != nullptr) i->init(this);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<schema::Type::Which>",
          "args": [
            "binding.which"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<schema::Type::AnyPointer::Unconstrained::Which>",
          "args": [
            "binding.paramIndex"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nType Schema::BrandArgumentList::operator[](uint index) const {\n  if (isUnbound) {\n    return Type::BrandParameter { scopeId, index };\n  }\n\n  if (index >= size_) {\n    // Binding index out-of-range. Treat as AnyPointer. This is important to allow new\n    // type parameters to be added to existing types without breaking dependent\n    // schemas.\n    return schema::Type::ANY_POINTER;\n  }\n\n  auto& binding = bindings[index];\n  Type result;\n  if (binding.which == (uint)schema::Type::ANY_POINTER) {\n    if (binding.scopeId != 0) {\n      result = Type::BrandParameter { binding.scopeId, binding.paramIndex };\n    } else if (binding.isImplicitParameter) {\n      result = Type::ImplicitParameter { binding.paramIndex };\n    } else {\n      result = static_cast<schema::Type::AnyPointer::Unconstrained::Which>(binding.paramIndex);\n    }\n  } else if (binding.schema == nullptr) {\n    // Builtin / primitive type.\n    result = static_cast<schema::Type::Which>(binding.which);\n  } else {\n    binding.schema->ensureInitialized();\n    result = Type(static_cast<schema::Type::Which>(binding.which), binding.schema);\n  }\n\n  return result.wrapInList(binding.listDepth);\n}"
  },
  {
    "function_name": "Schema::interpretType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "335-390",
    "snippet": "Type Schema::interpretType(schema::Type::Reader proto, uint location) const {\n  switch (proto.which()) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      return proto.which();\n\n    case schema::Type::STRUCT: {\n      auto structType = proto.getStruct();\n      return getDependency(structType.getTypeId(), location).asStruct();\n    }\n\n    case schema::Type::ENUM: {\n      auto enumType = proto.getEnum();\n      return getDependency(enumType.getTypeId(), location).asEnum();\n    }\n\n    case schema::Type::INTERFACE: {\n      auto interfaceType = proto.getInterface();\n      return getDependency(interfaceType.getTypeId(), location).asInterface();\n    }\n\n    case schema::Type::LIST:\n      return ListSchema::of(interpretType(proto.getList().getElementType(), location));\n\n    case schema::Type::ANY_POINTER: {\n      auto anyPointer = proto.getAnyPointer();\n      switch (anyPointer.which()) {\n        case schema::Type::AnyPointer::UNCONSTRAINED:\n          return anyPointer.getUnconstrained().which();\n        case schema::Type::AnyPointer::PARAMETER: {\n          auto param = anyPointer.getParameter();\n          return getBrandBinding(param.getScopeId(), param.getParameterIndex());\n        }\n        case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER:\n          return Type(Type::ImplicitParameter {\n              anyPointer.getImplicitMethodParameter().getParameterIndex() });\n      }\n\n      KJ_UNREACHABLE;\n    }\n  }\n\n  KJ_UNREACHABLE;\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Type",
          "args": [
            "Type::ImplicitParameter {\n              anyPointer.getImplicitMethodParameter().getParameterIndex() }"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "Type::Type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "883-885",
          "snippet": "inline Type::Type(ImplicitParameter param)\n    : baseType(schema::Type::ANY_POINTER), listDepth(0), isImplicitParam(true),\n      paramIndex(param.index), scopeId(0) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline Type::Type(ImplicitParameter param)\n    : baseType(schema::Type::ANY_POINTER), listDepth(0), isImplicitParam(true),\n      paramIndex(param.index), scopeId(0) {}"
        }
      },
      {
        "call_info": {
          "callee": "anyPointer.getImplicitMethodParameter",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anyPointer.getImplicitMethodParameter",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getBrandBinding",
          "args": [
            "param.getScopeId()",
            "param.getParameterIndex()"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getBrandBinding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "331-333",
          "snippet": "Type Schema::getBrandBinding(uint64_t scopeId, uint index) const {\n  return getBrandArgumentsAtScope(scopeId)[index];\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nType Schema::getBrandBinding(uint64_t scopeId, uint index) const {\n  return getBrandArgumentsAtScope(scopeId)[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "param.getParameterIndex",
          "args": [],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param.getScopeId",
          "args": [],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "getScopeId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "778-778",
          "snippet": "inline uint64_t getScopeId() { return leafId; }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t leafId;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t leafId;\n\ninline uint64_t getScopeId() { return leafId; }"
        }
      },
      {
        "call_info": {
          "callee": "anyPointer.getParameter",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anyPointer.getUnconstrained",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anyPointer.getUnconstrained",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anyPointer.which",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getAnyPointer",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListSchema::of",
          "args": [
            "interpretType(proto.getList().getElementType(), location)"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "ListSchema::of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "699-730",
          "snippet": "ListSchema ListSchema::of(schema::Type::Which primitiveType) {\n  switch (primitiveType) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      break;\n\n    case schema::Type::STRUCT:\n    case schema::Type::ENUM:\n    case schema::Type::INTERFACE:\n    case schema::Type::LIST:\n      KJ_FAIL_REQUIRE(\"Must use one of the other ListSchema::of() overloads for complex types.\");\n      break;\n\n    case schema::Type::ANY_POINTER:\n      KJ_FAIL_REQUIRE(\"List(AnyPointer) not supported.\");\n      break;\n  }\n\n  return ListSchema(primitiveType);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nListSchema ListSchema::of(schema::Type::Which primitiveType) {\n  switch (primitiveType) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      break;\n\n    case schema::Type::STRUCT:\n    case schema::Type::ENUM:\n    case schema::Type::INTERFACE:\n    case schema::Type::LIST:\n      KJ_FAIL_REQUIRE(\"Must use one of the other ListSchema::of() overloads for complex types.\");\n      break;\n\n    case schema::Type::ANY_POINTER:\n      KJ_FAIL_REQUIRE(\"List(AnyPointer) not supported.\");\n      break;\n  }\n\n  return ListSchema(primitiveType);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proto.getList",
          "args": [],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getList",
          "args": [],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getDependency",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getDependency",
          "args": [
            "interfaceType.getTypeId()",
            "location"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getDependency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "196-241",
          "snippet": "Schema Schema::getDependency(uint64_t id, uint location) const {\n  {\n    // Binary search dependency list.\n    uint lower = 0;\n    uint upper = raw->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      auto candidate = raw->dependencies[mid];\n      if (candidate.location == location) {\n        candidate.schema->ensureInitialized();\n        return Schema(candidate.schema);\n      } else if (candidate.location < location) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  {\n    uint lower = 0;\n    uint upper = raw->generic->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      const _::RawSchema* candidate = raw->generic->dependencies[mid];\n\n      uint64_t candidateId = candidate->id;\n      if (candidateId == id) {\n        candidate->ensureInitialized();\n        return Schema(&candidate->defaultBrand);\n      } else if (candidateId < id) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  KJ_FAIL_REQUIRE(\"Requested ID not found in dependency table.\", kj::hex(id)) {\n    return Schema();\n  }\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nSchema Schema::getDependency(uint64_t id, uint location) const {\n  {\n    // Binary search dependency list.\n    uint lower = 0;\n    uint upper = raw->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      auto candidate = raw->dependencies[mid];\n      if (candidate.location == location) {\n        candidate.schema->ensureInitialized();\n        return Schema(candidate.schema);\n      } else if (candidate.location < location) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  {\n    uint lower = 0;\n    uint upper = raw->generic->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      const _::RawSchema* candidate = raw->generic->dependencies[mid];\n\n      uint64_t candidateId = candidate->id;\n      if (candidateId == id) {\n        candidate->ensureInitialized();\n        return Schema(&candidate->defaultBrand);\n      } else if (candidateId < id) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  KJ_FAIL_REQUIRE(\"Requested ID not found in dependency table.\", kj::hex(id)) {\n    return Schema();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "interfaceType.getTypeId",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getInterface",
          "args": [],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getDependency",
          "args": [],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumType.getTypeId",
          "args": [],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getEnum",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getDependency",
          "args": [],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structType.getTypeId",
          "args": [],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getStruct",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.which",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.which",
          "args": [],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nType Schema::interpretType(schema::Type::Reader proto, uint location) const {\n  switch (proto.which()) {\n    case schema::Type::VOID:\n    case schema::Type::BOOL:\n    case schema::Type::INT8:\n    case schema::Type::INT16:\n    case schema::Type::INT32:\n    case schema::Type::INT64:\n    case schema::Type::UINT8:\n    case schema::Type::UINT16:\n    case schema::Type::UINT32:\n    case schema::Type::UINT64:\n    case schema::Type::FLOAT32:\n    case schema::Type::FLOAT64:\n    case schema::Type::TEXT:\n    case schema::Type::DATA:\n      return proto.which();\n\n    case schema::Type::STRUCT: {\n      auto structType = proto.getStruct();\n      return getDependency(structType.getTypeId(), location).asStruct();\n    }\n\n    case schema::Type::ENUM: {\n      auto enumType = proto.getEnum();\n      return getDependency(enumType.getTypeId(), location).asEnum();\n    }\n\n    case schema::Type::INTERFACE: {\n      auto interfaceType = proto.getInterface();\n      return getDependency(interfaceType.getTypeId(), location).asInterface();\n    }\n\n    case schema::Type::LIST:\n      return ListSchema::of(interpretType(proto.getList().getElementType(), location));\n\n    case schema::Type::ANY_POINTER: {\n      auto anyPointer = proto.getAnyPointer();\n      switch (anyPointer.which()) {\n        case schema::Type::AnyPointer::UNCONSTRAINED:\n          return anyPointer.getUnconstrained().which();\n        case schema::Type::AnyPointer::PARAMETER: {\n          auto param = anyPointer.getParameter();\n          return getBrandBinding(param.getScopeId(), param.getParameterIndex());\n        }\n        case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER:\n          return Type(Type::ImplicitParameter {\n              anyPointer.getImplicitMethodParameter().getParameterIndex() });\n      }\n\n      KJ_UNREACHABLE;\n    }\n  }\n\n  KJ_UNREACHABLE;\n}"
  },
  {
    "function_name": "Schema::getBrandBinding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "331-333",
    "snippet": "Type Schema::getBrandBinding(uint64_t scopeId, uint index) const {\n  return getBrandArgumentsAtScope(scopeId)[index];\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getBrandArgumentsAtScope",
          "args": [
            "scopeId"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getBrandArgumentsAtScope",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "243-259",
          "snippet": "Schema::BrandArgumentList Schema::getBrandArgumentsAtScope(uint64_t scopeId) const {\n  KJ_REQUIRE(getProto().getIsGeneric(), \"Not a generic type.\", getProto().getDisplayName());\n\n  for (auto scope: kj::range(raw->scopes, raw->scopes + raw->scopeCount)) {\n    if (scope->typeId == scopeId) {\n      // OK, this scope matches the scope we're looking for.\n      if (scope->isUnbound) {\n        return BrandArgumentList(scopeId, true);\n      } else {\n        return BrandArgumentList(scopeId, scope->bindingCount, scope->bindings);\n      }\n    }\n  }\n\n  // This scope is not listed in the scopes list.\n  return BrandArgumentList(scopeId, raw->isUnbound());\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nSchema::BrandArgumentList Schema::getBrandArgumentsAtScope(uint64_t scopeId) const {\n  KJ_REQUIRE(getProto().getIsGeneric(), \"Not a generic type.\", getProto().getDisplayName());\n\n  for (auto scope: kj::range(raw->scopes, raw->scopes + raw->scopeCount)) {\n    if (scope->typeId == scopeId) {\n      // OK, this scope matches the scope we're looking for.\n      if (scope->isUnbound) {\n        return BrandArgumentList(scopeId, true);\n      } else {\n        return BrandArgumentList(scopeId, scope->bindingCount, scope->bindings);\n      }\n    }\n  }\n\n  // This scope is not listed in the scopes list.\n  return BrandArgumentList(scopeId, raw->isUnbound());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nType Schema::getBrandBinding(uint64_t scopeId, uint index) const {\n  return getBrandArgumentsAtScope(scopeId)[index];\n}"
  },
  {
    "function_name": "Schema::getSchemaOffset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "304-329",
    "snippet": "uint32_t Schema::getSchemaOffset(const schema::Value::Reader& value) const {\n  const word* ptr;\n\n  switch (value.which()) {\n    case schema::Value::TEXT:\n      ptr = reinterpret_cast<const word*>(value.getText().begin());\n      break;\n    case schema::Value::DATA:\n      ptr = reinterpret_cast<const word*>(value.getData().begin());\n      break;\n    case schema::Value::STRUCT:\n      ptr = value.getStruct().getAs<_::UncheckedMessage>();\n      break;\n    case schema::Value::LIST:\n      ptr = value.getList().getAs<_::UncheckedMessage>();\n      break;\n    case schema::Value::ANY_POINTER:\n      ptr = value.getAnyPointer().getAs<_::UncheckedMessage>();\n      break;\n    default:\n      KJ_FAIL_ASSERT(\"getDefaultValueSchemaOffset() can only be called on struct, list, \"\n                     \"and any-pointer fields.\");\n  }\n\n  return ptr - raw->generic->encodedNode;\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"getDefaultValueSchemaOffset() can only be called on struct, list, \"\n                     \"and any-pointer fields.\""
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getAnyPointer",
          "args": [],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getAnyPointer",
          "args": [],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getList",
          "args": [],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getList",
          "args": [],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getStruct",
          "args": [],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getStruct",
          "args": [],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const word*>",
          "args": [
            "value.getData().begin()"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getData",
          "args": [],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getData",
          "args": [],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const word*>",
          "args": [
            "value.getText().begin()"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getText",
          "args": [],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getText",
          "args": [],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.which",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nuint32_t Schema::getSchemaOffset(const schema::Value::Reader& value) const {\n  const word* ptr;\n\n  switch (value.which()) {\n    case schema::Value::TEXT:\n      ptr = reinterpret_cast<const word*>(value.getText().begin());\n      break;\n    case schema::Value::DATA:\n      ptr = reinterpret_cast<const word*>(value.getData().begin());\n      break;\n    case schema::Value::STRUCT:\n      ptr = value.getStruct().getAs<_::UncheckedMessage>();\n      break;\n    case schema::Value::LIST:\n      ptr = value.getList().getAs<_::UncheckedMessage>();\n      break;\n    case schema::Value::ANY_POINTER:\n      ptr = value.getAnyPointer().getAs<_::UncheckedMessage>();\n      break;\n    default:\n      KJ_FAIL_ASSERT(\"getDefaultValueSchemaOffset() can only be called on struct, list, \"\n                     \"and any-pointer fields.\");\n  }\n\n  return ptr - raw->generic->encodedNode;\n}"
  },
  {
    "function_name": "Schema::requireUsableAs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "298-302",
    "snippet": "void Schema::requireUsableAs(const _::RawSchema* expected) const {\n  KJ_REQUIRE(raw->generic == expected ||\n             (expected != nullptr && raw->generic->canCastTo == expected),\n             \"This schema is not compatible with the requested native type.\");\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "raw->generic == expected ||\n             (expected != nullptr && raw->generic->canCastTo == expected)",
            "\"This schema is not compatible with the requested native type.\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nvoid Schema::requireUsableAs(const _::RawSchema* expected) const {\n  KJ_REQUIRE(raw->generic == expected ||\n             (expected != nullptr && raw->generic->canCastTo == expected),\n             \"This schema is not compatible with the requested native type.\");\n}"
  },
  {
    "function_name": "Schema::getShortDisplayName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "293-296",
    "snippet": "kj::StringPtr Schema::getShortDisplayName() const {\n  auto proto = getProto();\n  return proto.getDisplayName().slice(proto.getDisplayNamePrefixLength());\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proto.getDisplayName",
          "args": [
            "proto.getDisplayNamePrefixLength()"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getDisplayNamePrefixLength",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getDisplayName",
          "args": [],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "getDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "416-418",
          "snippet": "kj::StringPtr getDisplayName() const override {\n    return displayName;\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::StringPtr getDisplayName() const override {\n    return displayName;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nkj::StringPtr Schema::getShortDisplayName() const {\n  auto proto = getProto();\n  return proto.getDisplayName().slice(proto.getDisplayNamePrefixLength());\n}"
  },
  {
    "function_name": "Schema::asConst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "285-291",
    "snippet": "ConstSchema Schema::asConst() const {\n  KJ_REQUIRE(getProto().isConst(), \"Tried to use non-constant schema as a constant.\",\n             getProto().getDisplayName()) {\n    return ConstSchema();\n  }\n  return ConstSchema(*this);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ConstSchema",
          "args": [
            "*this"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "ConstSchema",
          "container": "ConstSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "574-574",
          "snippet": "ConstSchema(Schema base): Schema(base) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nConstSchema {\n  ConstSchema(Schema base): Schema(base) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "getProto().isConst()",
            "\"Tried to use non-constant schema as a constant.\"",
            "getProto().getDisplayName()"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nConstSchema Schema::asConst() const {\n  KJ_REQUIRE(getProto().isConst(), \"Tried to use non-constant schema as a constant.\",\n             getProto().getDisplayName()) {\n    return ConstSchema();\n  }\n  return ConstSchema(*this);\n}"
  },
  {
    "function_name": "Schema::asInterface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "277-283",
    "snippet": "InterfaceSchema Schema::asInterface() const {\n  KJ_REQUIRE(getProto().isInterface(), \"Tried to use non-interface schema as an interface.\",\n             getProto().getDisplayName()) {\n    return InterfaceSchema();\n  }\n  return InterfaceSchema(*this);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "InterfaceSchema",
          "args": [
            "*this"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "InterfaceSchema",
          "container": "InterfaceSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "465-465",
          "snippet": "InterfaceSchema(Schema base): Schema(base) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nInterfaceSchema {\n  InterfaceSchema(Schema base): Schema(base) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "InterfaceSchema",
          "args": [],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "fromImpl",
          "container": "InterfaceSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "466-468",
          "snippet": "static inline InterfaceSchema fromImpl() {\n    return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n  }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nInterfaceSchema {\n  static inline InterfaceSchema fromImpl() {\n      return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "getProto().isInterface()",
            "\"Tried to use non-interface schema as an interface.\"",
            "getProto().getDisplayName()"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nInterfaceSchema Schema::asInterface() const {\n  KJ_REQUIRE(getProto().isInterface(), \"Tried to use non-interface schema as an interface.\",\n             getProto().getDisplayName()) {\n    return InterfaceSchema();\n  }\n  return InterfaceSchema(*this);\n}"
  },
  {
    "function_name": "Schema::asEnum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "269-275",
    "snippet": "EnumSchema Schema::asEnum() const {\n  KJ_REQUIRE(getProto().isEnum(), \"Tried to use non-enum schema as an enum.\",\n             getProto().getDisplayName()) {\n    return EnumSchema();\n  }\n  return EnumSchema(*this);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EnumSchema",
          "args": [
            "*this"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "EnumSchema",
          "container": "EnumSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "383-383",
          "snippet": "EnumSchema(Schema base): Schema(base) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nEnumSchema {\n  EnumSchema(Schema base): Schema(base) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EnumSchema",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "fromImpl",
          "container": "EnumSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "384-386",
          "snippet": "static inline EnumSchema fromImpl() {\n    return EnumSchema(Schema(&_::rawBrandedSchema<T>()));\n  }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nEnumSchema {\n  static inline EnumSchema fromImpl() {\n      return EnumSchema(Schema(&_::rawBrandedSchema<T>()));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "getProto().isEnum()",
            "\"Tried to use non-enum schema as an enum.\"",
            "getProto().getDisplayName()"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nEnumSchema Schema::asEnum() const {\n  KJ_REQUIRE(getProto().isEnum(), \"Tried to use non-enum schema as an enum.\",\n             getProto().getDisplayName()) {\n    return EnumSchema();\n  }\n  return EnumSchema(*this);\n}"
  },
  {
    "function_name": "Schema::asStruct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "261-267",
    "snippet": "StructSchema Schema::asStruct() const {\n  KJ_REQUIRE(getProto().isStruct(), \"Tried to use non-struct schema as a struct.\",\n             getProto().getDisplayName()) {\n    return StructSchema();\n  }\n  return StructSchema(*this);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StructSchema",
          "args": [
            "*this"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "StructSchema",
          "container": "StructSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "261-261",
          "snippet": "StructSchema(Schema base): Schema(base) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nStructSchema {\n  StructSchema(Schema base): Schema(base) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "StructSchema",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "fromImpl",
          "container": "StructSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "262-264",
          "snippet": "static inline StructSchema fromImpl() {\n    return StructSchema(Schema(&_::rawBrandedSchema<T>()));\n  }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nStructSchema {\n  static inline StructSchema fromImpl() {\n      return StructSchema(Schema(&_::rawBrandedSchema<T>()));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "getProto().isStruct()",
            "\"Tried to use non-struct schema as a struct.\"",
            "getProto().getDisplayName()"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nStructSchema Schema::asStruct() const {\n  KJ_REQUIRE(getProto().isStruct(), \"Tried to use non-struct schema as a struct.\",\n             getProto().getDisplayName()) {\n    return StructSchema();\n  }\n  return StructSchema(*this);\n}"
  },
  {
    "function_name": "Schema::getBrandArgumentsAtScope",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "243-259",
    "snippet": "Schema::BrandArgumentList Schema::getBrandArgumentsAtScope(uint64_t scopeId) const {\n  KJ_REQUIRE(getProto().getIsGeneric(), \"Not a generic type.\", getProto().getDisplayName());\n\n  for (auto scope: kj::range(raw->scopes, raw->scopes + raw->scopeCount)) {\n    if (scope->typeId == scopeId) {\n      // OK, this scope matches the scope we're looking for.\n      if (scope->isUnbound) {\n        return BrandArgumentList(scopeId, true);\n      } else {\n        return BrandArgumentList(scopeId, scope->bindingCount, scope->bindings);\n      }\n    }\n  }\n\n  // This scope is not listed in the scopes list.\n  return BrandArgumentList(scopeId, raw->isUnbound());\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BrandArgumentList",
          "args": [
            "scopeId",
            "raw->isUnbound()"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "BrandArgumentList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "213-214",
          "snippet": "inline BrandArgumentList(uint64_t scopeId, bool isUnbound)\n      : scopeId(scopeId), size_(0), isUnbound(isUnbound), bindings(nullptr) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline BrandArgumentList(uint64_t scopeId, bool isUnbound)\n      : scopeId(scopeId), size_(0), isUnbound(isUnbound), bindings(nullptr) {}"
        }
      },
      {
        "call_info": {
          "callee": "raw->isUnbound",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::range",
          "args": [
            "raw->scopes",
            "raw->scopes + raw->scopeCount"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "642-642",
          "snippet": "inline constexpr Range<Decay<T>> range(T begin, T end) { return Range<Decay<T>>(begin, end); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<Decay<T>> range(T begin, T end) { return Range<Decay<T>>(begin, end); }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "getProto().getIsGeneric()",
            "\"Not a generic type.\"",
            "getProto().getDisplayName()"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getProto",
          "args": [],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "Schema::getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
          "lines": "188-190",
          "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nSchema::BrandArgumentList Schema::getBrandArgumentsAtScope(uint64_t scopeId) const {\n  KJ_REQUIRE(getProto().getIsGeneric(), \"Not a generic type.\", getProto().getDisplayName());\n\n  for (auto scope: kj::range(raw->scopes, raw->scopes + raw->scopeCount)) {\n    if (scope->typeId == scopeId) {\n      // OK, this scope matches the scope we're looking for.\n      if (scope->isUnbound) {\n        return BrandArgumentList(scopeId, true);\n      } else {\n        return BrandArgumentList(scopeId, scope->bindingCount, scope->bindings);\n      }\n    }\n  }\n\n  // This scope is not listed in the scopes list.\n  return BrandArgumentList(scopeId, raw->isUnbound());\n}"
  },
  {
    "function_name": "Schema::getDependency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "196-241",
    "snippet": "Schema Schema::getDependency(uint64_t id, uint location) const {\n  {\n    // Binary search dependency list.\n    uint lower = 0;\n    uint upper = raw->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      auto candidate = raw->dependencies[mid];\n      if (candidate.location == location) {\n        candidate.schema->ensureInitialized();\n        return Schema(candidate.schema);\n      } else if (candidate.location < location) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  {\n    uint lower = 0;\n    uint upper = raw->generic->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      const _::RawSchema* candidate = raw->generic->dependencies[mid];\n\n      uint64_t candidateId = candidate->id;\n      if (candidateId == id) {\n        candidate->ensureInitialized();\n        return Schema(&candidate->defaultBrand);\n      } else if (candidateId < id) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  KJ_FAIL_REQUIRE(\"Requested ID not found in dependency table.\", kj::hex(id)) {\n    return Schema();\n  }\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Schema",
          "args": [],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "ConstSchema",
          "container": "ConstSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "558-558",
          "snippet": "inline ConstSchema(): Schema(&_::NULL_CONST_SCHEMA.defaultBrand) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nConstSchema {\n  inline ConstSchema(): Schema(&_::NULL_CONST_SCHEMA.defaultBrand) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Requested ID not found in dependency table.\"",
            "kj::hex(id)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::hex",
          "args": [
            "id"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Schema",
          "args": [
            "&candidate->defaultBrand"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "ListSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "734-734",
          "snippet": "inline explicit ListSchema(Type elementType): elementType(elementType) {}",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline explicit ListSchema(Type elementType): elementType(elementType) {}"
        }
      },
      {
        "call_info": {
          "callee": "candidate->ensureInitialized",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "ensureInitialized",
          "container": "RawSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "221-228",
          "snippet": "inline void ensureInitialized() const {\n    // Lazy initialization support.  Invoke to ensure that initialization has taken place.  This\n    // is required in particular when traversing the dependency list.  RawSchemas for compiled-in\n    // types are always initialized; only dynamically-loaded schemas may be lazy.\n\n    const Initializer* i = __atomic_load_n(&lazyInitializer, __ATOMIC_ACQUIRE);\n    if (i != nullptr) i->init(this);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nRawSchema {\n  inline void ensureInitialized() const {\n      // Lazy initialization support.  Invoke to ensure that initialization has taken place.  This\n      // is required in particular when traversing the dependency list.  RawSchemas for compiled-in\n      // types are always initialized; only dynamically-loaded schemas may be lazy.\n  \n      const Initializer* i = __atomic_load_n(&lazyInitializer, __ATOMIC_ACQUIRE);\n      if (i != nullptr) i->init(this);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nSchema Schema::getDependency(uint64_t id, uint location) const {\n  {\n    // Binary search dependency list.\n    uint lower = 0;\n    uint upper = raw->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      auto candidate = raw->dependencies[mid];\n      if (candidate.location == location) {\n        candidate.schema->ensureInitialized();\n        return Schema(candidate.schema);\n      } else if (candidate.location < location) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  {\n    uint lower = 0;\n    uint upper = raw->generic->dependencyCount;\n\n    while (lower < upper) {\n      uint mid = (lower + upper) / 2;\n\n      const _::RawSchema* candidate = raw->generic->dependencies[mid];\n\n      uint64_t candidateId = candidate->id;\n      if (candidateId == id) {\n        candidate->ensureInitialized();\n        return Schema(&candidate->defaultBrand);\n      } else if (candidateId < id) {\n        lower = mid + 1;\n      } else {\n        upper = mid;\n      }\n    }\n  }\n\n  KJ_FAIL_REQUIRE(\"Requested ID not found in dependency table.\", kj::hex(id)) {\n    return Schema();\n  }\n}"
  },
  {
    "function_name": "Schema::asUncheckedMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "192-194",
    "snippet": "kj::ArrayPtr<const word> Schema::asUncheckedMessage() const {\n  return kj::arrayPtr(raw->generic->encodedNode, raw->generic->encodedSize);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "raw->generic->encodedNode",
            "raw->generic->encodedSize"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nkj::ArrayPtr<const word> Schema::asUncheckedMessage() const {\n  return kj::arrayPtr(raw->generic->encodedNode, raw->generic->encodedSize);\n}"
  },
  {
    "function_name": "Schema::getProto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.c++",
    "lines": "188-190",
    "snippet": "schema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"schema.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readMessageUnchecked<schema::Node>",
          "args": [
            "raw->generic->encodedNode"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "readMessageUnchecked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message.h",
          "lines": "466-468",
          "snippet": "typename RootType::Reader readMessageUnchecked(const word* data) {\n  return AnyPointer::Reader(_::PointerReader::getRootUnchecked(data)).getAs<RootType>();\n}",
          "includes": [
            "#include \"any.h\"",
            "#include \"layout.h\"",
            "#include \"common.h\"",
            "#include <kj/mutex.h>",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"any.h\"\n#include \"layout.h\"\n#include \"common.h\"\n#include <kj/mutex.h>\n#include <kj/memory.h>\n#include <kj/common.h>\n\ntypename RootType::Reader readMessageUnchecked(const word* data) {\n  return AnyPointer::Reader(_::PointerReader::getRootUnchecked(data)).getAs<RootType>();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"message.h\"\n#include \"schema.h\"\n\nschema::Node::Reader Schema::getProto() const {\n  return readMessageUnchecked<schema::Node>(raw->generic->encodedNode);\n}"
  }
]