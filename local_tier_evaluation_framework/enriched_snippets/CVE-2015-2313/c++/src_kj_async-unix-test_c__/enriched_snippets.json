[
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
    "lines": "474-501",
    "snippet": "TEST(AsyncUnixTest, Wake) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  EXPECT_FALSE(port.poll());\n  port.wake();\n  EXPECT_TRUE(port.poll());\n  EXPECT_FALSE(port.poll());\n\n  port.wake();\n  EXPECT_TRUE(port.wait());\n\n  {\n    auto promise = port.atSteadyTime(port.steadyTime());\n    EXPECT_FALSE(port.wait());\n  }\n\n  bool woken = false;\n  Thread thread([&]() {\n    delay();\n    woken = true;\n    port.wake();\n  });\n\n  EXPECT_TRUE(port.wait());\n}",
    "includes": [
      "#include <algorithm>",
      "#include <pthread.h>",
      "#include <kj/compat/gtest.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"debug.h\"",
      "#include \"thread.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "port.wait()"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.wait",
          "args": [],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "wait",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "666-666",
          "snippet": "bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "port.wake",
          "args": [],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "wake",
          "container": "NullEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "189-193",
          "snippet": "void wake() const override {\n    // TODO(someday): Implement using condvar.\n    kj::throwRecoverableException(KJ_EXCEPTION(UNIMPLEMENTED,\n        \"Cross-thread events are not yet implemented for EventLoops with no EventPort.\"));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nNullEventPort {\n  void wake() const override {\n      // TODO(someday): Implement using condvar.\n      kj::throwRecoverableException(KJ_EXCEPTION(UNIMPLEMENTED,\n          \"Cross-thread events are not yet implemented for EventLoops with no EventPort.\"));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "36-36",
          "snippet": "inline void delay() { usleep(10000); }",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\ninline void delay() { usleep(10000); }"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "port.wait()"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.atSteadyTime",
          "args": [
            "port.steadyTime()"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.steadyTime",
          "args": [],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "steadyTime",
          "container": "UnixEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.h",
          "lines": "90-90",
          "snippet": "TimePoint steadyTime() { return frozenSteadyTime; }",
          "includes": [
            "#include <signal.h>",
            "#include \"io.h\"",
            "#include \"vector.h\"",
            "#include \"time.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include \"io.h\"\n#include \"vector.h\"\n#include \"time.h\"\n#include \"async.h\"\n\nUnixEventPort {\n  TimePoint steadyTime() { return frozenSteadyTime; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "port.wait()"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "port.poll()"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.poll",
          "args": [],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "poll",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "667-667",
          "snippet": "bool poll() override { return false; }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  bool poll() override { return false; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "port.poll()"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "port.poll()"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "captureSignals",
          "args": [],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "captureSignals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "45-56",
          "snippet": "void captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nvoid captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nTEST(AsyncUnixTest, Wake) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  EXPECT_FALSE(port.poll());\n  port.wake();\n  EXPECT_TRUE(port.poll());\n  EXPECT_FALSE(port.poll());\n\n  port.wake();\n  EXPECT_TRUE(port.wait());\n\n  {\n    auto promise = port.atSteadyTime(port.steadyTime());\n    EXPECT_FALSE(port.wait());\n  }\n\n  bool woken = false;\n  Thread thread([&]() {\n    delay();\n    woken = true;\n    port.wake();\n  });\n\n  EXPECT_TRUE(port.wait());\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
    "lines": "441-472",
    "snippet": "TEST(AsyncUnixTest, SteadyTimers) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  auto start = port.steadyTime();\n  kj::Vector<TimePoint> expected;\n  kj::Vector<TimePoint> actual;\n\n  auto addTimer = [&](Duration delay) {\n    expected.add(max(start + delay, start));\n    port.atSteadyTime(start + delay).then([&]() {\n      actual.add(port.steadyTime());\n    }).detach([](Exception&& e) { ADD_FAILURE() << str(e).cStr(); });\n  };\n\n  addTimer(30 * MILLISECONDS);\n  addTimer(40 * MILLISECONDS);\n  addTimer(20350 * MICROSECONDS);\n  addTimer(30 * MILLISECONDS);\n  addTimer(-10 * MILLISECONDS);\n\n  std::sort(expected.begin(), expected.end());\n  port.atSteadyTime(expected.back() + MILLISECONDS).wait(waitScope);\n\n  ASSERT_EQ(expected.size(), actual.size());\n  for (int i = 0; i < expected.size(); ++i) {\n    KJ_EXPECT(expected[i] <= actual[i], \"Actual time for timer i is too early.\",\n              i, ((expected[i] - actual[i]) / NANOSECONDS));\n  }\n}",
    "includes": [
      "#include <algorithm>",
      "#include <pthread.h>",
      "#include <kj/compat/gtest.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"debug.h\"",
      "#include \"thread.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_EXPECT",
          "args": [
            "expected[i] <= actual[i]",
            "\"Actual time for timer i is too early.\"",
            "i",
            "((expected[i] - actual[i]) / NANOSECONDS)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected.size",
          "args": [],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "expected.size()",
            "actual.size()"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.atSteadyTime",
          "args": [
            "waitScope"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.atSteadyTime",
          "args": [
            "expected.back() + MILLISECONDS"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected.back",
          "args": [],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::sort",
          "args": [
            "expected.begin()",
            "expected.end()"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected.end",
          "args": [],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "693-693",
          "snippet": "inline Iterator end() const { return Iterator(value, count); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator end() const { return Iterator(value, count); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expected.begin",
          "args": [],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addTimer",
          "args": [
            "-10 * MILLISECONDS"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addTimer",
          "args": [
            "30 * MILLISECONDS"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addTimer",
          "args": [
            "20350 * MICROSECONDS"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addTimer",
          "args": [
            "40 * MILLISECONDS"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addTimer",
          "args": [
            "30 * MILLISECONDS"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.atSteadyTime",
          "args": [
            "[](Exception&& e) { ADD_FAILURE() << str(e).cStr(); }"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "destroy",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "115-117",
          "snippet": "void destroy() {\n    doAll(destroyVariant<Variants>()...);\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  void destroy() {\n      doAll(destroyVariant<Variants>()...);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "e"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "destroyObject",
          "container": "Arena",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.h",
          "lines": "129-131",
          "snippet": "static void destroyObject(void* pointer) {\n    dtor(*reinterpret_cast<T*>(pointer));\n  }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nArena {\n  static void destroyObject(void* pointer) {\n      dtor(*reinterpret_cast<T*>(pointer));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADD_FAILURE",
          "args": [],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.atSteadyTime",
          "args": [
            "[&]() {\n      actual.add(port.steadyTime());\n    }"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "actual.add",
          "args": [
            "port.steadyTime()"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "port.steadyTime",
          "args": [],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "steadyTime",
          "container": "UnixEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.h",
          "lines": "90-90",
          "snippet": "TimePoint steadyTime() { return frozenSteadyTime; }",
          "includes": [
            "#include <signal.h>",
            "#include \"io.h\"",
            "#include \"vector.h\"",
            "#include \"time.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include \"io.h\"\n#include \"vector.h\"\n#include \"time.h\"\n#include \"async.h\"\n\nUnixEventPort {\n  TimePoint steadyTime() { return frozenSteadyTime; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "port.atSteadyTime",
          "args": [
            "start + delay"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "start + delay",
            "start"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "486-488",
          "snippet": "auto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "captureSignals",
          "args": [],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "captureSignals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "45-56",
          "snippet": "void captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nvoid captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nTEST(AsyncUnixTest, SteadyTimers) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  auto start = port.steadyTime();\n  kj::Vector<TimePoint> expected;\n  kj::Vector<TimePoint> actual;\n\n  auto addTimer = [&](Duration delay) {\n    expected.add(max(start + delay, start));\n    port.atSteadyTime(start + delay).then([&]() {\n      actual.add(port.steadyTime());\n    }).detach([](Exception&& e) { ADD_FAILURE() << str(e).cStr(); });\n  };\n\n  addTimer(30 * MILLISECONDS);\n  addTimer(40 * MILLISECONDS);\n  addTimer(20350 * MICROSECONDS);\n  addTimer(30 * MILLISECONDS);\n  addTimer(-10 * MILLISECONDS);\n\n  std::sort(expected.begin(), expected.end());\n  port.atSteadyTime(expected.back() + MILLISECONDS).wait(waitScope);\n\n  ASSERT_EQ(expected.size(), actual.size());\n  for (int i = 0; i < expected.size(); ++i) {\n    KJ_EXPECT(expected[i] <= actual[i], \"Actual time for timer i is too early.\",\n              i, ((expected[i] - actual[i]) / NANOSECONDS));\n  }\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
    "lines": "402-439",
    "snippet": "TEST(AsyncUnixTest, WriteObserver) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  int pipefds[2];\n  KJ_SYSCALL(pipe(pipefds));\n  kj::AutoCloseFd infd(pipefds[0]), outfd(pipefds[1]);\n  setNonblocking(outfd);\n\n  UnixEventPort::FdObserver observer(port, outfd, UnixEventPort::FdObserver::OBSERVE_WRITE);\n\n  // Fill buffer.\n  ssize_t n;\n  do {\n    KJ_NONBLOCKING_SYSCALL(n = write(outfd, \"foo\", 3));\n  } while (n >= 0);\n\n  bool writable = false;\n  auto promise = observer.whenBecomesWritable()\n      .then([&]() { writable = true; }).eagerlyEvaluate(nullptr);\n\n  loop.run();\n  port.poll();\n  loop.run();\n\n  EXPECT_FALSE(writable);\n\n  char buffer[4096];\n  KJ_SYSCALL(read(infd, &buffer, sizeof(buffer)));\n\n  loop.run();\n  port.poll();\n  loop.run();\n\n  EXPECT_TRUE(writable);\n}",
    "includes": [
      "#include <algorithm>",
      "#include <pthread.h>",
      "#include <kj/compat/gtest.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"debug.h\"",
      "#include \"thread.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "writable"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loop.run",
          "args": [],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": "RunnableImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "257-259",
          "snippet": "void run() override {\n    func();\n  }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nRunnableImpl {\n  void run() override {\n      func();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "port.poll",
          "args": [],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "poll",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "667-667",
          "snippet": "bool poll() override { return false; }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  bool poll() override { return false; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "read(infd, &buffer, sizeof(buffer))"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "infd",
            "&buffer",
            "sizeof(buffer)"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "AsyncInputStream::read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1340-1342",
          "snippet": "Promise<void> AsyncInputStream::read(void* buffer, size_t bytes) {\n  return read(buffer, bytes, bytes).then([](size_t) {});\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nPromise<void> AsyncInputStream::read(void* buffer, size_t bytes) {\n  return read(buffer, bytes, bytes).then([](size_t) {});\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "writable"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesWritable",
          "args": [
            "nullptr"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesWritable",
          "args": [
            "[&]() { writable = true; }"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesWritable",
          "args": [],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_NONBLOCKING_SYSCALL",
          "args": [
            "n = write(outfd, \"foo\", 3)"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "outfd",
            "\"foo\"",
            "3"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "TestRunner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "426-439",
          "snippet": "void write(Color color, StringPtr prefix, StringPtr message) {\n    StringPtr startColor, endColor;\n    if (useColor) {\n      switch (color) {\n        case RED:   startColor = \"\\033[0;1;31m\"; break;\n        case GREEN: startColor = \"\\033[0;1;32m\"; break;\n        case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n      }\n      endColor = \"\\033[0m\";\n    }\n\n    String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n    write(text);\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  void write(Color color, StringPtr prefix, StringPtr message) {\n      StringPtr startColor, endColor;\n      if (useColor) {\n        switch (color) {\n          case RED:   startColor = \"\\033[0;1;31m\"; break;\n          case GREEN: startColor = \"\\033[0;1;32m\"; break;\n          case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n        }\n        endColor = \"\\033[0m\";\n      }\n  \n      String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n      write(text);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setNonblocking",
          "args": [
            "outfd"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "setNonblocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "394-400",
          "snippet": "static void setNonblocking(int fd) {\n  int flags;\n  KJ_SYSCALL(flags = fcntl(fd, F_GETFL));\n  if ((flags & O_NONBLOCK) == 0) {\n    KJ_SYSCALL(fcntl(fd, F_SETFL, flags | O_NONBLOCK));\n  }\n}",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nstatic void setNonblocking(int fd) {\n  int flags;\n  KJ_SYSCALL(flags = fcntl(fd, F_GETFL));\n  if ((flags & O_NONBLOCK) == 0) {\n    KJ_SYSCALL(fcntl(fd, F_SETFL, flags | O_NONBLOCK));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pipe(pipefds)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipefds"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "84-86",
          "snippet": "inline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "captureSignals",
          "args": [],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "captureSignals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "45-56",
          "snippet": "void captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nvoid captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nTEST(AsyncUnixTest, WriteObserver) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  int pipefds[2];\n  KJ_SYSCALL(pipe(pipefds));\n  kj::AutoCloseFd infd(pipefds[0]), outfd(pipefds[1]);\n  setNonblocking(outfd);\n\n  UnixEventPort::FdObserver observer(port, outfd, UnixEventPort::FdObserver::OBSERVE_WRITE);\n\n  // Fill buffer.\n  ssize_t n;\n  do {\n    KJ_NONBLOCKING_SYSCALL(n = write(outfd, \"foo\", 3));\n  } while (n >= 0);\n\n  bool writable = false;\n  auto promise = observer.whenBecomesWritable()\n      .then([&]() { writable = true; }).eagerlyEvaluate(nullptr);\n\n  loop.run();\n  port.poll();\n  loop.run();\n\n  EXPECT_FALSE(writable);\n\n  char buffer[4096];\n  KJ_SYSCALL(read(infd, &buffer, sizeof(buffer)));\n\n  loop.run();\n  port.poll();\n  loop.run();\n\n  EXPECT_TRUE(writable);\n}"
  },
  {
    "function_name": "setNonblocking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
    "lines": "394-400",
    "snippet": "static void setNonblocking(int fd) {\n  int flags;\n  KJ_SYSCALL(flags = fcntl(fd, F_GETFL));\n  if ((flags & O_NONBLOCK) == 0) {\n    KJ_SYSCALL(fcntl(fd, F_SETFL, flags | O_NONBLOCK));\n  }\n}",
    "includes": [
      "#include <algorithm>",
      "#include <pthread.h>",
      "#include <kj/compat/gtest.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"debug.h\"",
      "#include \"thread.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fcntl(fd, F_SETFL, flags | O_NONBLOCK)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_SETFL",
            "flags | O_NONBLOCK"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "flags = fcntl(fd, F_GETFL)"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_GETFL"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nstatic void setNonblocking(int fd) {\n  int flags;\n  KJ_SYSCALL(flags = fcntl(fd, F_GETFL));\n  if ((flags & O_NONBLOCK) == 0) {\n    KJ_SYSCALL(fcntl(fd, F_SETFL, flags | O_NONBLOCK));\n  }\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
    "lines": "348-392",
    "snippet": "TEST(AsyncUnixTest, ReadObserverNoWait) {\n  // Verify that UnixEventPort::poll() correctly receives pending FD events.\n\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  int pipefds[2];\n  KJ_SYSCALL(pipe(pipefds));\n  KJ_DEFER({ close(pipefds[1]); close(pipefds[0]); });\n  UnixEventPort::FdObserver observer(port, pipefds[0],\n      UnixEventPort::FdObserver::OBSERVE_READ);\n\n  int pipefds2[2];\n  KJ_SYSCALL(pipe(pipefds2));\n  KJ_DEFER({ close(pipefds2[1]); close(pipefds2[0]); });\n  UnixEventPort::FdObserver observer2(port, pipefds2[0],\n      UnixEventPort::FdObserver::OBSERVE_READ);\n\n  int receivedCount = 0;\n  observer.whenBecomesReadable().then([&]() {\n    receivedCount++;\n  }).detach([](Exception&& e) { ADD_FAILURE() << str(e).cStr(); });\n  observer2.whenBecomesReadable().then([&]() {\n    receivedCount++;\n  }).detach([](Exception&& e) { ADD_FAILURE() << str(e).cStr(); });\n\n  KJ_SYSCALL(write(pipefds[1], \"foo\", 3));\n  KJ_SYSCALL(write(pipefds2[1], \"bar\", 3));\n\n  EXPECT_EQ(0, receivedCount);\n\n  loop.run();\n\n  EXPECT_EQ(0, receivedCount);\n\n  port.poll();\n\n  EXPECT_EQ(0, receivedCount);\n\n  loop.run();\n\n  EXPECT_EQ(2, receivedCount);\n}",
    "includes": [
      "#include <algorithm>",
      "#include <pthread.h>",
      "#include <kj/compat/gtest.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"debug.h\"",
      "#include \"thread.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "receivedCount"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loop.run",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": "RunnableImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "257-259",
          "snippet": "void run() override {\n    func();\n  }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nRunnableImpl {\n  void run() override {\n      func();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "receivedCount"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.poll",
          "args": [],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "poll",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "667-667",
          "snippet": "bool poll() override { return false; }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  bool poll() override { return false; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "receivedCount"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "receivedCount"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "write(pipefds2[1], \"bar\", 3)"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "pipefds2[1]",
            "\"bar\"",
            "3"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "TestRunner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "426-439",
          "snippet": "void write(Color color, StringPtr prefix, StringPtr message) {\n    StringPtr startColor, endColor;\n    if (useColor) {\n      switch (color) {\n        case RED:   startColor = \"\\033[0;1;31m\"; break;\n        case GREEN: startColor = \"\\033[0;1;32m\"; break;\n        case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n      }\n      endColor = \"\\033[0m\";\n    }\n\n    String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n    write(text);\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  void write(Color color, StringPtr prefix, StringPtr message) {\n      StringPtr startColor, endColor;\n      if (useColor) {\n        switch (color) {\n          case RED:   startColor = \"\\033[0;1;31m\"; break;\n          case GREEN: startColor = \"\\033[0;1;32m\"; break;\n          case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n        }\n        endColor = \"\\033[0m\";\n      }\n  \n      String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n      write(text);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "write(pipefds[1], \"foo\", 3)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer2.whenBecomesReadable",
          "args": [
            "[](Exception&& e) { ADD_FAILURE() << str(e).cStr(); }"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "destroy",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "115-117",
          "snippet": "void destroy() {\n    doAll(destroyVariant<Variants>()...);\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  void destroy() {\n      doAll(destroyVariant<Variants>()...);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "e"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "destroyObject",
          "container": "Arena",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.h",
          "lines": "129-131",
          "snippet": "static void destroyObject(void* pointer) {\n    dtor(*reinterpret_cast<T*>(pointer));\n  }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nArena {\n  static void destroyObject(void* pointer) {\n      dtor(*reinterpret_cast<T*>(pointer));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADD_FAILURE",
          "args": [],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer2.whenBecomesReadable",
          "args": [
            "[&]() {\n    receivedCount++;\n  }"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer2.whenBecomesReadable",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [
            "[](Exception&& e) { ADD_FAILURE() << str(e).cStr(); }"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADD_FAILURE",
          "args": [],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [
            "[&]() {\n    receivedCount++;\n  }"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "{ close(pipefds2[1]); close(pipefds2[0]); }"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipefds2[0]"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "57-59",
          "snippet": "inline int close(int fd) {\n  return ::_close(fd);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int close(int fd) {\n  return ::_close(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pipe(pipefds2)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipefds2"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "84-86",
          "snippet": "inline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "{ close(pipefds[1]); close(pipefds[0]); }"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pipe(pipefds)"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "captureSignals",
          "args": [],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "captureSignals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "45-56",
          "snippet": "void captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nvoid captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nTEST(AsyncUnixTest, ReadObserverNoWait) {\n  // Verify that UnixEventPort::poll() correctly receives pending FD events.\n\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  int pipefds[2];\n  KJ_SYSCALL(pipe(pipefds));\n  KJ_DEFER({ close(pipefds[1]); close(pipefds[0]); });\n  UnixEventPort::FdObserver observer(port, pipefds[0],\n      UnixEventPort::FdObserver::OBSERVE_READ);\n\n  int pipefds2[2];\n  KJ_SYSCALL(pipe(pipefds2));\n  KJ_DEFER({ close(pipefds2[1]); close(pipefds2[0]); });\n  UnixEventPort::FdObserver observer2(port, pipefds2[0],\n      UnixEventPort::FdObserver::OBSERVE_READ);\n\n  int receivedCount = 0;\n  observer.whenBecomesReadable().then([&]() {\n    receivedCount++;\n  }).detach([](Exception&& e) { ADD_FAILURE() << str(e).cStr(); });\n  observer2.whenBecomesReadable().then([&]() {\n    receivedCount++;\n  }).detach([](Exception&& e) { ADD_FAILURE() << str(e).cStr(); });\n\n  KJ_SYSCALL(write(pipefds[1], \"foo\", 3));\n  KJ_SYSCALL(write(pipefds2[1], \"bar\", 3));\n\n  EXPECT_EQ(0, receivedCount);\n\n  loop.run();\n\n  EXPECT_EQ(0, receivedCount);\n\n  port.poll();\n\n  EXPECT_EQ(0, receivedCount);\n\n  loop.run();\n\n  EXPECT_EQ(2, receivedCount);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
    "lines": "326-346",
    "snippet": "TEST(AsyncUnixTest, ReadObserverAsync) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  // Make a pipe and wait on its read end while another thread writes to it.\n  int pipefds[2];\n  KJ_SYSCALL(pipe(pipefds));\n  KJ_DEFER({ close(pipefds[1]); close(pipefds[0]); });\n  UnixEventPort::FdObserver observer(port, pipefds[0],\n      UnixEventPort::FdObserver::OBSERVE_READ);\n\n  Thread thread([&]() {\n    delay();\n    KJ_SYSCALL(write(pipefds[1], \"foo\", 3));\n  });\n\n  // Wait for the event in this thread.\n  observer.whenBecomesReadable().wait(waitScope);\n}",
    "includes": [
      "#include <algorithm>",
      "#include <pthread.h>",
      "#include <kj/compat/gtest.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"debug.h\"",
      "#include \"thread.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [
            "waitScope"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "write(pipefds[1], \"foo\", 3)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "pipefds[1]",
            "\"foo\"",
            "3"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "TestRunner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "426-439",
          "snippet": "void write(Color color, StringPtr prefix, StringPtr message) {\n    StringPtr startColor, endColor;\n    if (useColor) {\n      switch (color) {\n        case RED:   startColor = \"\\033[0;1;31m\"; break;\n        case GREEN: startColor = \"\\033[0;1;32m\"; break;\n        case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n      }\n      endColor = \"\\033[0m\";\n    }\n\n    String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n    write(text);\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  void write(Color color, StringPtr prefix, StringPtr message) {\n      StringPtr startColor, endColor;\n      if (useColor) {\n        switch (color) {\n          case RED:   startColor = \"\\033[0;1;31m\"; break;\n          case GREEN: startColor = \"\\033[0;1;32m\"; break;\n          case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n        }\n        endColor = \"\\033[0m\";\n      }\n  \n      String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n      write(text);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "36-36",
          "snippet": "inline void delay() { usleep(10000); }",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\ninline void delay() { usleep(10000); }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "{ close(pipefds[1]); close(pipefds[0]); }"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipefds[0]"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "57-59",
          "snippet": "inline int close(int fd) {\n  return ::_close(fd);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int close(int fd) {\n  return ::_close(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pipe(pipefds)"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipefds"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "84-86",
          "snippet": "inline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "captureSignals",
          "args": [],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "captureSignals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "45-56",
          "snippet": "void captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nvoid captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nTEST(AsyncUnixTest, ReadObserverAsync) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  // Make a pipe and wait on its read end while another thread writes to it.\n  int pipefds[2];\n  KJ_SYSCALL(pipe(pipefds));\n  KJ_DEFER({ close(pipefds[1]); close(pipefds[0]); });\n  UnixEventPort::FdObserver observer(port, pipefds[0],\n      UnixEventPort::FdObserver::OBSERVE_READ);\n\n  Thread thread([&]() {\n    delay();\n    KJ_SYSCALL(write(pipefds[1], \"foo\", 3));\n  });\n\n  // Wait for the event in this thread.\n  observer.whenBecomesReadable().wait(waitScope);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
    "lines": "298-324",
    "snippet": "TEST(AsyncUnixTest, ReadObserverMultiReceive) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  int pipefds[2];\n  KJ_SYSCALL(pipe(pipefds));\n  KJ_DEFER({ close(pipefds[1]); close(pipefds[0]); });\n\n  UnixEventPort::FdObserver observer(port, pipefds[0],\n      UnixEventPort::FdObserver::OBSERVE_READ);\n  KJ_SYSCALL(write(pipefds[1], \"foo\", 3));\n\n  int pipefds2[2];\n  KJ_SYSCALL(pipe(pipefds2));\n  KJ_DEFER({ close(pipefds2[1]); close(pipefds2[0]); });\n\n  UnixEventPort::FdObserver observer2(port, pipefds2[0],\n      UnixEventPort::FdObserver::OBSERVE_READ);\n  KJ_SYSCALL(write(pipefds2[1], \"bar\", 3));\n\n  auto promise1 = observer.whenBecomesReadable();\n  auto promise2 = observer2.whenBecomesReadable();\n  promise1.wait(waitScope);\n  promise2.wait(waitScope);\n}",
    "includes": [
      "#include <algorithm>",
      "#include <pthread.h>",
      "#include <kj/compat/gtest.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"debug.h\"",
      "#include \"thread.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise2.wait",
          "args": [
            "waitScope"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise1.wait",
          "args": [
            "waitScope"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer2.whenBecomesReadable",
          "args": [],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "write(pipefds2[1], \"bar\", 3)"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "pipefds2[1]",
            "\"bar\"",
            "3"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "TestRunner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "426-439",
          "snippet": "void write(Color color, StringPtr prefix, StringPtr message) {\n    StringPtr startColor, endColor;\n    if (useColor) {\n      switch (color) {\n        case RED:   startColor = \"\\033[0;1;31m\"; break;\n        case GREEN: startColor = \"\\033[0;1;32m\"; break;\n        case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n      }\n      endColor = \"\\033[0m\";\n    }\n\n    String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n    write(text);\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  void write(Color color, StringPtr prefix, StringPtr message) {\n      StringPtr startColor, endColor;\n      if (useColor) {\n        switch (color) {\n          case RED:   startColor = \"\\033[0;1;31m\"; break;\n          case GREEN: startColor = \"\\033[0;1;32m\"; break;\n          case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n        }\n        endColor = \"\\033[0m\";\n      }\n  \n      String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n      write(text);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "{ close(pipefds2[1]); close(pipefds2[0]); }"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipefds2[0]"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "57-59",
          "snippet": "inline int close(int fd) {\n  return ::_close(fd);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int close(int fd) {\n  return ::_close(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pipe(pipefds2)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipefds2"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "84-86",
          "snippet": "inline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "write(pipefds[1], \"foo\", 3)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "{ close(pipefds[1]); close(pipefds[0]); }"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pipe(pipefds)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "captureSignals",
          "args": [],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "captureSignals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "45-56",
          "snippet": "void captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nvoid captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nTEST(AsyncUnixTest, ReadObserverMultiReceive) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  int pipefds[2];\n  KJ_SYSCALL(pipe(pipefds));\n  KJ_DEFER({ close(pipefds[1]); close(pipefds[0]); });\n\n  UnixEventPort::FdObserver observer(port, pipefds[0],\n      UnixEventPort::FdObserver::OBSERVE_READ);\n  KJ_SYSCALL(write(pipefds[1], \"foo\", 3));\n\n  int pipefds2[2];\n  KJ_SYSCALL(pipe(pipefds2));\n  KJ_DEFER({ close(pipefds2[1]); close(pipefds2[0]); });\n\n  UnixEventPort::FdObserver observer2(port, pipefds2[0],\n      UnixEventPort::FdObserver::OBSERVE_READ);\n  KJ_SYSCALL(write(pipefds2[1], \"bar\", 3));\n\n  auto promise1 = observer.whenBecomesReadable();\n  auto promise2 = observer2.whenBecomesReadable();\n  promise1.wait(waitScope);\n  promise2.wait(waitScope);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
    "lines": "268-296",
    "snippet": "TEST(AsyncUnixTest, ReadObserverMultiListen) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  int bogusPipefds[2];\n  KJ_SYSCALL(pipe(bogusPipefds));\n  KJ_DEFER({ close(bogusPipefds[1]); close(bogusPipefds[0]); });\n\n  UnixEventPort::FdObserver bogusObserver(port, bogusPipefds[0],\n      UnixEventPort::FdObserver::OBSERVE_READ);\n\n  bogusObserver.whenBecomesReadable().then([]() {\n    ADD_FAILURE() << \"Received wrong poll.\";\n  }).detach([](kj::Exception&& exception) {\n    ADD_FAILURE() << kj::str(exception).cStr();\n  });\n\n  int pipefds[2];\n  KJ_SYSCALL(pipe(pipefds));\n  KJ_DEFER({ close(pipefds[1]); close(pipefds[0]); });\n\n  UnixEventPort::FdObserver observer(port, pipefds[0],\n      UnixEventPort::FdObserver::OBSERVE_READ);\n  KJ_SYSCALL(write(pipefds[1], \"foo\", 3));\n\n  observer.whenBecomesReadable().wait(waitScope);\n}",
    "includes": [
      "#include <algorithm>",
      "#include <pthread.h>",
      "#include <kj/compat/gtest.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"debug.h\"",
      "#include \"thread.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [
            "waitScope"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "write(pipefds[1], \"foo\", 3)"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "pipefds[1]",
            "\"foo\"",
            "3"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "TestRunner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "426-439",
          "snippet": "void write(Color color, StringPtr prefix, StringPtr message) {\n    StringPtr startColor, endColor;\n    if (useColor) {\n      switch (color) {\n        case RED:   startColor = \"\\033[0;1;31m\"; break;\n        case GREEN: startColor = \"\\033[0;1;32m\"; break;\n        case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n      }\n      endColor = \"\\033[0m\";\n    }\n\n    String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n    write(text);\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  void write(Color color, StringPtr prefix, StringPtr message) {\n      StringPtr startColor, endColor;\n      if (useColor) {\n        switch (color) {\n          case RED:   startColor = \"\\033[0;1;31m\"; break;\n          case GREEN: startColor = \"\\033[0;1;32m\"; break;\n          case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n        }\n        endColor = \"\\033[0m\";\n      }\n  \n      String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n      write(text);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "{ close(pipefds[1]); close(pipefds[0]); }"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipefds[0]"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "57-59",
          "snippet": "inline int close(int fd) {\n  return ::_close(fd);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int close(int fd) {\n  return ::_close(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pipe(pipefds)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipefds"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "84-86",
          "snippet": "inline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bogusObserver.whenBecomesReadable",
          "args": [
            "[](kj::Exception&& exception) {\n    ADD_FAILURE() << kj::str(exception).cStr();\n  }"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "331-339",
          "snippet": "String str(Params&&... params) {\n  // Magic function which builds a string from a bunch of arbitrary values.  Example:\n  //     str(1, \" / \", 2, \" = \", 0.5)\n  // returns:\n  //     \"1 / 2 = 0.5\"\n  // To teach `str` how to stringify a type, see `Stringifier`.\n\n  return _::concat(toCharSequence(kj::fwd<Params>(params))...);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString str(Params&&... params) {\n  // Magic function which builds a string from a bunch of arbitrary values.  Example:\n  //     str(1, \" / \", 2, \" = \", 0.5)\n  // returns:\n  //     \"1 / 2 = 0.5\"\n  // To teach `str` how to stringify a type, see `Stringifier`.\n\n  return _::concat(toCharSequence(kj::fwd<Params>(params))...);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADD_FAILURE",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bogusObserver.whenBecomesReadable",
          "args": [
            "[]() {\n    ADD_FAILURE() << \"Received wrong poll.\";\n  }"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADD_FAILURE",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bogusObserver.whenBecomesReadable",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "{ close(bogusPipefds[1]); close(bogusPipefds[0]); }"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pipe(bogusPipefds)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "captureSignals",
          "args": [],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "captureSignals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "45-56",
          "snippet": "void captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nvoid captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nTEST(AsyncUnixTest, ReadObserverMultiListen) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  int bogusPipefds[2];\n  KJ_SYSCALL(pipe(bogusPipefds));\n  KJ_DEFER({ close(bogusPipefds[1]); close(bogusPipefds[0]); });\n\n  UnixEventPort::FdObserver bogusObserver(port, bogusPipefds[0],\n      UnixEventPort::FdObserver::OBSERVE_READ);\n\n  bogusObserver.whenBecomesReadable().then([]() {\n    ADD_FAILURE() << \"Received wrong poll.\";\n  }).detach([](kj::Exception&& exception) {\n    ADD_FAILURE() << kj::str(exception).cStr();\n  });\n\n  int pipefds[2];\n  KJ_SYSCALL(pipe(pipefds));\n  KJ_DEFER({ close(pipefds[1]); close(pipefds[0]); });\n\n  UnixEventPort::FdObserver observer(port, pipefds[0],\n      UnixEventPort::FdObserver::OBSERVE_READ);\n  KJ_SYSCALL(write(pipefds[1], \"foo\", 3));\n\n  observer.whenBecomesReadable().wait(waitScope);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
    "lines": "235-266",
    "snippet": "TEST(AsyncUnixTest, ReadObserver) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  int pipefds[2];\n  KJ_SYSCALL(pipe(pipefds));\n  kj::AutoCloseFd infd(pipefds[0]), outfd(pipefds[1]);\n\n  UnixEventPort::FdObserver observer(port, infd, UnixEventPort::FdObserver::OBSERVE_READ);\n\n  KJ_SYSCALL(write(outfd, \"foo\", 3));\n\n  observer.whenBecomesReadable().wait(waitScope);\n\n#if __linux__  // platform known to support POLLRDHUP\n  EXPECT_FALSE(KJ_ASSERT_NONNULL(observer.atEndHint()));\n\n  char buffer[4096];\n  ssize_t n;\n  KJ_SYSCALL(n = read(infd, &buffer, sizeof(buffer)));\n  EXPECT_EQ(3, n);\n\n  KJ_SYSCALL(write(outfd, \"bar\", 3));\n  outfd = nullptr;\n\n  observer.whenBecomesReadable().wait(waitScope);\n\n  EXPECT_TRUE(KJ_ASSERT_NONNULL(observer.atEndHint()));\n#endif\n}",
    "includes": [
      "#include <algorithm>",
      "#include <pthread.h>",
      "#include <kj/compat/gtest.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"debug.h\"",
      "#include \"thread.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "KJ_ASSERT_NONNULL(observer.atEndHint())"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "observer.atEndHint()"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.atEndHint",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "atEndHint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.h",
          "lines": "191-191",
          "snippet": "inline Maybe<bool> atEndHint() { return atEnd; }",
          "includes": [
            "#include <signal.h>",
            "#include \"io.h\"",
            "#include \"vector.h\"",
            "#include \"time.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include \"io.h\"\n#include \"vector.h\"\n#include \"time.h\"\n#include \"async.h\"\n\ninline Maybe<bool> atEndHint() { return atEnd; }"
        }
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [
            "waitScope"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "write(outfd, \"bar\", 3)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "outfd",
            "\"bar\"",
            "3"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "TestRunner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "426-439",
          "snippet": "void write(Color color, StringPtr prefix, StringPtr message) {\n    StringPtr startColor, endColor;\n    if (useColor) {\n      switch (color) {\n        case RED:   startColor = \"\\033[0;1;31m\"; break;\n        case GREEN: startColor = \"\\033[0;1;32m\"; break;\n        case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n      }\n      endColor = \"\\033[0m\";\n    }\n\n    String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n    write(text);\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  void write(Color color, StringPtr prefix, StringPtr message) {\n      StringPtr startColor, endColor;\n      if (useColor) {\n        switch (color) {\n          case RED:   startColor = \"\\033[0;1;31m\"; break;\n          case GREEN: startColor = \"\\033[0;1;32m\"; break;\n          case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n        }\n        endColor = \"\\033[0m\";\n      }\n  \n      String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n      write(text);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "n"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "n = read(infd, &buffer, sizeof(buffer))"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "infd",
            "&buffer",
            "sizeof(buffer)"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "AsyncInputStream::read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1340-1342",
          "snippet": "Promise<void> AsyncInputStream::read(void* buffer, size_t bytes) {\n  return read(buffer, bytes, bytes).then([](size_t) {});\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nPromise<void> AsyncInputStream::read(void* buffer, size_t bytes) {\n  return read(buffer, bytes, bytes).then([](size_t) {});\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "KJ_ASSERT_NONNULL(observer.atEndHint())"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "observer.atEndHint()"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [
            "waitScope"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "write(outfd, \"foo\", 3)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pipe(pipefds)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipefds"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "84-86",
          "snippet": "inline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "captureSignals",
          "args": [],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "captureSignals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "45-56",
          "snippet": "void captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nvoid captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nTEST(AsyncUnixTest, ReadObserver) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  int pipefds[2];\n  KJ_SYSCALL(pipe(pipefds));\n  kj::AutoCloseFd infd(pipefds[0]), outfd(pipefds[1]);\n\n  UnixEventPort::FdObserver observer(port, infd, UnixEventPort::FdObserver::OBSERVE_READ);\n\n  KJ_SYSCALL(write(outfd, \"foo\", 3));\n\n  observer.whenBecomesReadable().wait(waitScope);\n\n#if __linux__  // platform known to support POLLRDHUP\n  EXPECT_FALSE(KJ_ASSERT_NONNULL(observer.atEndHint()));\n\n  char buffer[4096];\n  ssize_t n;\n  KJ_SYSCALL(n = read(infd, &buffer, sizeof(buffer)));\n  EXPECT_EQ(3, n);\n\n  KJ_SYSCALL(write(outfd, \"bar\", 3));\n  outfd = nullptr;\n\n  observer.whenBecomesReadable().wait(waitScope);\n\n  EXPECT_TRUE(KJ_ASSERT_NONNULL(observer.atEndHint()));\n#endif\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
    "lines": "190-231",
    "snippet": "TEST(AsyncUnixTest, SignalsNoWait) {\n  // Verify that UnixEventPort::poll() correctly receives pending signals.\n\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  bool receivedSigurg = false;\n  bool receivedSigio = false;\n  port.onSignal(SIGURG).then([&](siginfo_t&& info) {\n    receivedSigurg = true;\n    EXPECT_EQ(SIGURG, info.si_signo);\n    EXPECT_SI_CODE(SI_USER, info.si_code);\n  }).detach([](Exception&& e) { KJ_FAIL_EXPECT(e); });\n  port.onSignal(SIGIO).then([&](siginfo_t&& info) {\n    receivedSigio = true;\n    EXPECT_EQ(SIGIO, info.si_signo);\n    EXPECT_SI_CODE(SI_USER, info.si_code);\n  }).detach([](Exception&& e) { KJ_FAIL_EXPECT(e); });\n\n  kill(getpid(), SIGURG);\n  kill(getpid(), SIGIO);\n\n  EXPECT_FALSE(receivedSigurg);\n  EXPECT_FALSE(receivedSigio);\n\n  loop.run();\n\n  EXPECT_FALSE(receivedSigurg);\n  EXPECT_FALSE(receivedSigio);\n\n  port.poll();\n\n  EXPECT_FALSE(receivedSigurg);\n  EXPECT_FALSE(receivedSigio);\n\n  loop.run();\n\n  EXPECT_TRUE(receivedSigurg);\n  EXPECT_TRUE(receivedSigio);\n}",
    "includes": [
      "#include <algorithm>",
      "#include <pthread.h>",
      "#include <kj/compat/gtest.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"debug.h\"",
      "#include \"thread.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [
      "#define EXPECT_SI_CODE EXPECT_EQ"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "receivedSigio"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "receivedSigurg"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loop.run",
          "args": [],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": "RunnableImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "257-259",
          "snippet": "void run() override {\n    func();\n  }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nRunnableImpl {\n  void run() override {\n      func();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "receivedSigio"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "receivedSigurg"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.poll",
          "args": [],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "poll",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "667-667",
          "snippet": "bool poll() override { return false; }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  bool poll() override { return false; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "receivedSigio"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "receivedSigurg"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "receivedSigio"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "receivedSigurg"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "getpid()",
            "SIGIO"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "getpid()",
            "SIGURG"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "[](Exception&& e) { KJ_FAIL_EXPECT(e); }"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_EXPECT",
          "args": [
            "e"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "[&](siginfo_t&& info) {\n    receivedSigio = true;\n    EXPECT_EQ(SIGIO, info.si_signo);\n    EXPECT_SI_CODE(SI_USER, info.si_code);\n  }"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_SI_CODE",
          "args": [
            "SI_USER",
            "info.si_code"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "SIGIO",
            "info.si_signo"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "SIGIO"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "[](Exception&& e) { KJ_FAIL_EXPECT(e); }"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_EXPECT",
          "args": [
            "e"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "[&](siginfo_t&& info) {\n    receivedSigurg = true;\n    EXPECT_EQ(SIGURG, info.si_signo);\n    EXPECT_SI_CODE(SI_USER, info.si_code);\n  }"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_SI_CODE",
          "args": [
            "SI_USER",
            "info.si_code"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "SIGURG",
            "info.si_signo"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "SIGURG"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "captureSignals",
          "args": [],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "captureSignals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "45-56",
          "snippet": "void captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nvoid captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\n#define EXPECT_SI_CODE EXPECT_EQ\n\nTEST(AsyncUnixTest, SignalsNoWait) {\n  // Verify that UnixEventPort::poll() correctly receives pending signals.\n\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  bool receivedSigurg = false;\n  bool receivedSigio = false;\n  port.onSignal(SIGURG).then([&](siginfo_t&& info) {\n    receivedSigurg = true;\n    EXPECT_EQ(SIGURG, info.si_signo);\n    EXPECT_SI_CODE(SI_USER, info.si_code);\n  }).detach([](Exception&& e) { KJ_FAIL_EXPECT(e); });\n  port.onSignal(SIGIO).then([&](siginfo_t&& info) {\n    receivedSigio = true;\n    EXPECT_EQ(SIGIO, info.si_signo);\n    EXPECT_SI_CODE(SI_USER, info.si_code);\n  }).detach([](Exception&& e) { KJ_FAIL_EXPECT(e); });\n\n  kill(getpid(), SIGURG);\n  kill(getpid(), SIGIO);\n\n  EXPECT_FALSE(receivedSigurg);\n  EXPECT_FALSE(receivedSigio);\n\n  loop.run();\n\n  EXPECT_FALSE(receivedSigurg);\n  EXPECT_FALSE(receivedSigio);\n\n  port.poll();\n\n  EXPECT_FALSE(receivedSigurg);\n  EXPECT_FALSE(receivedSigio);\n\n  loop.run();\n\n  EXPECT_TRUE(receivedSigurg);\n  EXPECT_TRUE(receivedSigio);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
    "lines": "165-183",
    "snippet": "TEST(AsyncUnixTest, SignalsAsync) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  // Arrange for a signal to be sent from another thread.\n  pthread_t mainThread = pthread_self();\n  Thread thread([&]() {\n    delay();\n    pthread_kill(mainThread, SIGURG);\n  });\n\n  siginfo_t info = port.onSignal(SIGURG).wait(waitScope);\n  EXPECT_EQ(SIGURG, info.si_signo);\n#if __linux__\n  EXPECT_SI_CODE(SI_TKILL, info.si_code);\n#endif\n}",
    "includes": [
      "#include <algorithm>",
      "#include <pthread.h>",
      "#include <kj/compat/gtest.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"debug.h\"",
      "#include \"thread.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [
      "#define EXPECT_SI_CODE EXPECT_EQ"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_SI_CODE",
          "args": [
            "SI_TKILL",
            "info.si_code"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "SIGURG",
            "info.si_signo"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "waitScope"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "SIGURG"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_kill",
          "args": [
            "mainThread",
            "SIGURG"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "36-36",
          "snippet": "inline void delay() { usleep(10000); }",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\ninline void delay() { usleep(10000); }"
        }
      },
      {
        "call_info": {
          "callee": "pthread_self",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "captureSignals",
          "args": [],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "captureSignals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "45-56",
          "snippet": "void captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nvoid captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\n#define EXPECT_SI_CODE EXPECT_EQ\n\nTEST(AsyncUnixTest, SignalsAsync) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  // Arrange for a signal to be sent from another thread.\n  pthread_t mainThread = pthread_self();\n  Thread thread([&]() {\n    delay();\n    pthread_kill(mainThread, SIGURG);\n  });\n\n  siginfo_t info = port.onSignal(SIGURG).wait(waitScope);\n  EXPECT_EQ(SIGURG, info.si_signo);\n#if __linux__\n  EXPECT_SI_CODE(SI_TKILL, info.si_code);\n#endif\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
    "lines": "145-161",
    "snippet": "TEST(AsyncUnixTest, SignalsMultiReceive) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  kill(getpid(), SIGURG);\n  kill(getpid(), SIGIO);\n\n  siginfo_t info = port.onSignal(SIGURG).wait(waitScope);\n  EXPECT_EQ(SIGURG, info.si_signo);\n  EXPECT_SI_CODE(SI_USER, info.si_code);\n\n  info = port.onSignal(SIGIO).wait(waitScope);\n  EXPECT_EQ(SIGIO, info.si_signo);\n  EXPECT_SI_CODE(SI_USER, info.si_code);\n}",
    "includes": [
      "#include <algorithm>",
      "#include <pthread.h>",
      "#include <kj/compat/gtest.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"debug.h\"",
      "#include \"thread.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [
      "#define EXPECT_SI_CODE EXPECT_EQ"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_SI_CODE",
          "args": [
            "SI_USER",
            "info.si_code"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "SIGIO",
            "info.si_signo"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "waitScope"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "SIGIO"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_SI_CODE",
          "args": [
            "SI_USER",
            "info.si_code"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "SIGURG",
            "info.si_signo"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "waitScope"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "SIGURG"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "getpid()",
            "SIGIO"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "getpid()",
            "SIGURG"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "captureSignals",
          "args": [],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "captureSignals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "45-56",
          "snippet": "void captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nvoid captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\n#define EXPECT_SI_CODE EXPECT_EQ\n\nTEST(AsyncUnixTest, SignalsMultiReceive) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  kill(getpid(), SIGURG);\n  kill(getpid(), SIGIO);\n\n  siginfo_t info = port.onSignal(SIGURG).wait(waitScope);\n  EXPECT_EQ(SIGURG, info.si_signo);\n  EXPECT_SI_CODE(SI_USER, info.si_code);\n\n  info = port.onSignal(SIGIO).wait(waitScope);\n  EXPECT_EQ(SIGIO, info.si_signo);\n  EXPECT_SI_CODE(SI_USER, info.si_code);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
    "lines": "121-138",
    "snippet": "TEST(AsyncUnixTest, SignalsMultiListen) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  port.onSignal(SIGIO).then([](siginfo_t&&) {\n    KJ_FAIL_EXPECT(\"Received wrong signal.\");\n  }).detach([](kj::Exception&& exception) {\n    KJ_FAIL_EXPECT(exception);\n  });\n\n  kill(getpid(), SIGURG);\n\n  siginfo_t info = port.onSignal(SIGURG).wait(waitScope);\n  EXPECT_EQ(SIGURG, info.si_signo);\n  EXPECT_SI_CODE(SI_USER, info.si_code);\n}",
    "includes": [
      "#include <algorithm>",
      "#include <pthread.h>",
      "#include <kj/compat/gtest.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"debug.h\"",
      "#include \"thread.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [
      "#define EXPECT_SI_CODE EXPECT_EQ"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_SI_CODE",
          "args": [
            "SI_USER",
            "info.si_code"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "SIGURG",
            "info.si_signo"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "waitScope"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "SIGURG"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "getpid()",
            "SIGURG"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "[](kj::Exception&& exception) {\n    KJ_FAIL_EXPECT(exception);\n  }"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_EXPECT",
          "args": [
            "exception"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "[](siginfo_t&&) {\n    KJ_FAIL_EXPECT(\"Received wrong signal.\");\n  }"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_EXPECT",
          "args": [
            "\"Received wrong signal.\""
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "SIGIO"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "captureSignals",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "captureSignals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "45-56",
          "snippet": "void captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nvoid captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\n#define EXPECT_SI_CODE EXPECT_EQ\n\nTEST(AsyncUnixTest, SignalsMultiListen) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  port.onSignal(SIGIO).then([](siginfo_t&&) {\n    KJ_FAIL_EXPECT(\"Received wrong signal.\");\n  }).detach([](kj::Exception&& exception) {\n    KJ_FAIL_EXPECT(exception);\n  });\n\n  kill(getpid(), SIGURG);\n\n  siginfo_t info = port.onSignal(SIGURG).wait(waitScope);\n  EXPECT_EQ(SIGURG, info.si_signo);\n  EXPECT_SI_CODE(SI_USER, info.si_code);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
    "lines": "96-118",
    "snippet": "TEST(AsyncUnixTest, SignalWithPointerValue) {\n  // This tests that if we use sigqueue() to attach a value to the signal, that value is received\n  // correctly.  Note that this only works on platforms that support real-time signals -- even\n  // though the signal we're sending is SIGURG, the sigqueue() system call is introduced by RT\n  // signals.  Hence this test won't run on e.g. Mac OSX.\n  //\n  // Also, Android's bionic does not appear to support sigqueue() even though the kernel does.\n\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  union sigval value;\n  memset(&value, 0, sizeof(value));\n  value.sival_ptr = &port;\n  sigqueue(getpid(), SIGURG, value);\n\n  siginfo_t info = port.onSignal(SIGURG).wait(waitScope);\n  EXPECT_EQ(SIGURG, info.si_signo);\n  EXPECT_SI_CODE(SI_QUEUE, info.si_code);\n  EXPECT_EQ(&port, info.si_value.sival_ptr);\n}",
    "includes": [
      "#include <algorithm>",
      "#include <pthread.h>",
      "#include <kj/compat/gtest.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"debug.h\"",
      "#include \"thread.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [
      "#define EXPECT_SI_CODE EXPECT_EQ"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "&port",
            "info.si_value.sival_ptr"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_SI_CODE",
          "args": [
            "SI_QUEUE",
            "info.si_code"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "SIGURG",
            "info.si_signo"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "waitScope"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "SIGURG"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigqueue",
          "args": [
            "getpid()",
            "SIGURG",
            "value"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&value",
            "0",
            "sizeof(value)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "captureSignals",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "captureSignals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "45-56",
          "snippet": "void captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nvoid captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\n#define EXPECT_SI_CODE EXPECT_EQ\n\nTEST(AsyncUnixTest, SignalWithPointerValue) {\n  // This tests that if we use sigqueue() to attach a value to the signal, that value is received\n  // correctly.  Note that this only works on platforms that support real-time signals -- even\n  // though the signal we're sending is SIGURG, the sigqueue() system call is introduced by RT\n  // signals.  Hence this test won't run on e.g. Mac OSX.\n  //\n  // Also, Android's bionic does not appear to support sigqueue() even though the kernel does.\n\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  union sigval value;\n  memset(&value, 0, sizeof(value));\n  value.sival_ptr = &port;\n  sigqueue(getpid(), SIGURG, value);\n\n  siginfo_t info = port.onSignal(SIGURG).wait(waitScope);\n  EXPECT_EQ(SIGURG, info.si_signo);\n  EXPECT_SI_CODE(SI_QUEUE, info.si_code);\n  EXPECT_EQ(&port, info.si_value.sival_ptr);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
    "lines": "72-94",
    "snippet": "TEST(AsyncUnixTest, SignalWithValue) {\n  // This tests that if we use sigqueue() to attach a value to the signal, that value is received\n  // correctly.  Note that this only works on platforms that support real-time signals -- even\n  // though the signal we're sending is SIGURG, the sigqueue() system call is introduced by RT\n  // signals.  Hence this test won't run on e.g. Mac OSX.\n  //\n  // Also, Android's bionic does not appear to support sigqueue() even though the kernel does.\n\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  union sigval value;\n  memset(&value, 0, sizeof(value));\n  value.sival_int = 123;\n  sigqueue(getpid(), SIGURG, value);\n\n  siginfo_t info = port.onSignal(SIGURG).wait(waitScope);\n  EXPECT_EQ(SIGURG, info.si_signo);\n  EXPECT_SI_CODE(SI_QUEUE, info.si_code);\n  EXPECT_EQ(123, info.si_value.sival_int);\n}",
    "includes": [
      "#include <algorithm>",
      "#include <pthread.h>",
      "#include <kj/compat/gtest.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"debug.h\"",
      "#include \"thread.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [
      "#define EXPECT_SI_CODE EXPECT_EQ"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "info.si_value.sival_int"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_SI_CODE",
          "args": [
            "SI_QUEUE",
            "info.si_code"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "SIGURG",
            "info.si_signo"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "waitScope"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "SIGURG"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigqueue",
          "args": [
            "getpid()",
            "SIGURG",
            "value"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&value",
            "0",
            "sizeof(value)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "captureSignals",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "captureSignals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "45-56",
          "snippet": "void captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nvoid captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\n#define EXPECT_SI_CODE EXPECT_EQ\n\nTEST(AsyncUnixTest, SignalWithValue) {\n  // This tests that if we use sigqueue() to attach a value to the signal, that value is received\n  // correctly.  Note that this only works on platforms that support real-time signals -- even\n  // though the signal we're sending is SIGURG, the sigqueue() system call is introduced by RT\n  // signals.  Hence this test won't run on e.g. Mac OSX.\n  //\n  // Also, Android's bionic does not appear to support sigqueue() even though the kernel does.\n\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  union sigval value;\n  memset(&value, 0, sizeof(value));\n  value.sival_int = 123;\n  sigqueue(getpid(), SIGURG, value);\n\n  siginfo_t info = port.onSignal(SIGURG).wait(waitScope);\n  EXPECT_EQ(SIGURG, info.si_signo);\n  EXPECT_SI_CODE(SI_QUEUE, info.si_code);\n  EXPECT_EQ(123, info.si_value.sival_int);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
    "lines": "58-69",
    "snippet": "TEST(AsyncUnixTest, Signals) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  kill(getpid(), SIGURG);\n\n  siginfo_t info = port.onSignal(SIGURG).wait(waitScope);\n  EXPECT_EQ(SIGURG, info.si_signo);\n  EXPECT_SI_CODE(SI_USER, info.si_code);\n}",
    "includes": [
      "#include <algorithm>",
      "#include <pthread.h>",
      "#include <kj/compat/gtest.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"debug.h\"",
      "#include \"thread.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [
      "#define EXPECT_SI_CODE EXPECT_EQ"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_SI_CODE",
          "args": [
            "SI_USER",
            "info.si_code"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "SIGURG",
            "info.si_signo"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "waitScope"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.onSignal",
          "args": [
            "SIGURG"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "getpid()",
            "SIGURG"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "captureSignals",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "captureSignals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
          "lines": "45-56",
          "snippet": "void captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}",
          "includes": [
            "#include <algorithm>",
            "#include <pthread.h>",
            "#include <kj/compat/gtest.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"debug.h\"",
            "#include \"thread.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nvoid captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\n#define EXPECT_SI_CODE EXPECT_EQ\n\nTEST(AsyncUnixTest, Signals) {\n  captureSignals();\n  UnixEventPort port;\n  EventLoop loop(port);\n  WaitScope waitScope(loop);\n\n  kill(getpid(), SIGURG);\n\n  siginfo_t info = port.onSignal(SIGURG).wait(waitScope);\n  EXPECT_EQ(SIGURG, info.si_signo);\n  EXPECT_SI_CODE(SI_USER, info.si_code);\n}"
  },
  {
    "function_name": "captureSignals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
    "lines": "45-56",
    "snippet": "void captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}",
    "includes": [
      "#include <algorithm>",
      "#include <pthread.h>",
      "#include <kj/compat/gtest.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"debug.h\"",
      "#include \"thread.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UnixEventPort::captureSignal",
          "args": [
            "SIGIO"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "UnixEventPort::captureSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "209-219",
          "snippet": "void UnixEventPort::captureSignal(int signum) {\n  if (reservedSignal == SIGUSR1) {\n    KJ_REQUIRE(signum != SIGUSR1,\n               \"Sorry, SIGUSR1 is reserved by the UnixEventPort implementation.  You may call \"\n               \"UnixEventPort::setReservedSignal() to reserve a different signal.\");\n  } else {\n    KJ_REQUIRE(signum != reservedSignal,\n               \"Can't capture signal reserved using setReservedSignal().\", signum);\n  }\n  registerSignalHandler(signum);\n}",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid UnixEventPort::captureSignal(int signum) {\n  if (reservedSignal == SIGUSR1) {\n    KJ_REQUIRE(signum != SIGUSR1,\n               \"Sorry, SIGUSR1 is reserved by the UnixEventPort implementation.  You may call \"\n               \"UnixEventPort::setReservedSignal() to reserve a different signal.\");\n  } else {\n    KJ_REQUIRE(signum != reservedSignal,\n               \"Can't capture signal reserved using setReservedSignal().\", signum);\n  }\n  registerSignalHandler(signum);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\nvoid captureSignals() {\n  static bool captured = false;\n  if (!captured) {\n    captured = true;\n\n    // We use SIGIO and SIGURG as our test signals because they're two signals that we can be\n    // reasonably confident won't otherwise be delivered to any KJ or Cap'n Proto test.  We can't\n    // use SIGUSR1 because it is reserved by UnixEventPort and SIGUSR2 is used by Valgrind on OSX.\n    UnixEventPort::captureSignal(SIGURG);\n    UnixEventPort::captureSignal(SIGIO);\n  }\n}"
  },
  {
    "function_name": "delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix-test.c++",
    "lines": "36-36",
    "snippet": "inline void delay() { usleep(10000); }",
    "includes": [
      "#include <algorithm>",
      "#include <pthread.h>",
      "#include <kj/compat/gtest.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"debug.h\"",
      "#include \"thread.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10000"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <pthread.h>\n#include <kj/compat/gtest.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"debug.h\"\n#include \"thread.h\"\n#include \"async-unix.h\"\n\ninline void delay() { usleep(10000); }"
  }
]