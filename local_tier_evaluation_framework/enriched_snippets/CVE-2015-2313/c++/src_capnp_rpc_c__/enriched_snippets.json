[
  {
    "function_name": "restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2626-2635",
    "snippet": "Capability::Client restore(_::StructReader vatId, AnyPointer::Reader objectId) {\n    KJ_IF_MAYBE(connection, network.baseConnect(vatId)) {\n      auto& state = getConnectionState(kj::mv(*connection));\n      return Capability::Client(state.restore(objectId));\n    } else KJ_IF_MAYBE(r, restorer) {\n      return r->baseRestore(objectId);\n    } else {\n      return Capability::Client(newBrokenCap(\n          \"SturdyRef referred to a local object but there is no local SturdyRef restorer.\"));\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Capability::Client",
          "args": [
            "newBrokenCap(\n          \"SturdyRef referred to a local object but there is no local SturdyRef restorer.\")"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newBrokenCap",
          "args": [
            "\"SturdyRef referred to a local object but there is no local SturdyRef restorer.\""
          ],
          "line": 2633
        },
        "resolved": true,
        "details": {
          "function_name": "newBrokenCap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "620-622",
          "snippet": "kj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}"
        }
      },
      {
        "call_info": {
          "callee": "r->baseRestore",
          "args": [
            "objectId"
          ],
          "line": 2631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Capability::Client",
          "args": [
            "state.restore(objectId)"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getConnectionState",
          "args": [
            "kj::mv(*connection)"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*connection"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "connection",
            "network.baseConnect(vatId)"
          ],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "network.baseConnect",
          "args": [
            "vatId"
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nCapability::Client restore(_::StructReader vatId, AnyPointer::Reader objectId) {\n    KJ_IF_MAYBE(connection, network.baseConnect(vatId)) {\n      auto& state = getConnectionState(kj::mv(*connection));\n      return Capability::Client(state.restore(objectId));\n    } else KJ_IF_MAYBE(r, restorer) {\n      return r->baseRestore(objectId);\n    } else {\n      return Capability::Client(newBrokenCap(\n          \"SturdyRef referred to a local object but there is no local SturdyRef restorer.\"));\n    }"
  },
  {
    "function_name": "bootstrap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2620-2624",
    "snippet": "Capability::Client bootstrap(_::StructReader vatId) {\n    // For now we delegate to restore() since it's equivalent, but eventually we'll remove restore()\n    // and implement bootstrap() directly.\n    return restore(vatId, AnyPointer::Reader());\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "restore",
          "args": [
            "vatId",
            "AnyPointer::Reader()"
          ],
          "line": 2623
        },
        "resolved": true,
        "details": {
          "function_name": "RpcSystem<VatId>::restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.h",
          "lines": "366-369",
          "snippet": "Capability::Client RpcSystem<VatId>::restore(\n    typename VatId::Reader hostId, AnyPointer::Reader objectId) {\n  return baseRestore(_::PointerHelpers<VatId>::getInternalReader(hostId), objectId);\n}",
          "includes": [
            "#include \"rpc-prelude.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc-prelude.h\"\n#include \"capability.h\"\n\nCapability::Client RpcSystem<VatId>::restore(\n    typename VatId::Reader hostId, AnyPointer::Reader objectId) {\n  return baseRestore(_::PointerHelpers<VatId>::getInternalReader(hostId), objectId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AnyPointer::Reader",
          "args": [],
          "line": 2623
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "AnyPointer::Reader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "97-99",
          "snippet": "inline bool isList() {\n      return reader.isList();\n    }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Reader {\n    inline bool isList() {\n          return reader.isList();\n        }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nCapability::Client bootstrap(_::StructReader vatId) {\n    // For now we delegate to restore() since it's equivalent, but eventually we'll remove restore()\n    // and implement bootstrap() directly.\n    return restore(vatId, AnyPointer::Reader());\n  }"
  },
  {
    "function_name": "Impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2600-2603",
    "snippet": "Impl(VatNetworkBase& network, SturdyRefRestorerBase& restorer)\n      : network(network), restorer(restorer), tasks(*this) {\n    tasks.add(acceptLoop());\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "acceptLoop()"
          ],
          "line": 2602
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "acceptLoop",
          "args": [],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImpl(VatNetworkBase& network, SturdyRefRestorerBase& restorer)\n      : network(network), restorer(restorer), tasks(*this) {\n    tasks.add(acceptLoop());\n  }"
  },
  {
    "function_name": "Impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2594-2599",
    "snippet": "Impl(VatNetworkBase& network, kj::Maybe<Capability::Client> bootstrapInterface,\n       kj::Maybe<RealmGateway<>::Client> gateway)\n      : network(network), bootstrapInterface(kj::mv(bootstrapInterface)),\n        gateway(kj::mv(gateway)), tasks(*this) {\n    tasks.add(acceptLoop());\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "acceptLoop()"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "acceptLoop",
          "args": [],
          "line": 2598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "gateway"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "bootstrapInterface"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImpl(VatNetworkBase& network, kj::Maybe<Capability::Client> bootstrapInterface,\n       kj::Maybe<RealmGateway<>::Client> gateway)\n      : network(network), bootstrapInterface(kj::mv(bootstrapInterface)),\n        gateway(kj::mv(gateway)), tasks(*this) {\n    tasks.add(acceptLoop());\n  }"
  },
  {
    "function_name": "handleDisembargo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2503-2567",
    "snippet": "void handleDisembargo(const rpc::Disembargo::Reader& disembargo) {\n    auto context = disembargo.getContext();\n    switch (context.which()) {\n      case rpc::Disembargo::Context::SENDER_LOOPBACK: {\n        kj::Own<ClientHook> target;\n\n        KJ_IF_MAYBE(t, getMessageTarget(disembargo.getTarget())) {\n          target = kj::mv(*t);\n        } else {\n          // Exception already reported.\n          return;\n        }\n\n        for (;;) {\n          KJ_IF_MAYBE(r, target->getResolved()) {\n            target = r->addRef();\n          } else {\n            break;\n          }\n        }\n\n        KJ_REQUIRE(target->getBrand() == this,\n                   \"'Disembargo' of type 'senderLoopback' sent to an object that does not point \"\n                   \"back to the sender.\") {\n          return;\n        }\n\n        EmbargoId embargoId = context.getSenderLoopback();\n\n        // We need to insert an evalLater() here to make sure that any pending calls towards this\n        // cap have had time to find their way through the event loop.\n        tasks.add(kj::evalLater(kj::mvCapture(\n            target, [this,embargoId](kj::Own<ClientHook>&& target) {\n          if (!connection.is<Connected>()) {\n            return;\n          }\n\n          RpcClient& downcasted = kj::downcast<RpcClient>(*target);\n\n          auto message = connection.get<Connected>()->newOutgoingMessage(\n              messageSizeHint<rpc::Disembargo>() + MESSAGE_TARGET_SIZE_HINT);\n          auto builder = message->getBody().initAs<rpc::Message>().initDisembargo();\n\n          {\n            auto redirect = downcasted.writeTarget(builder.initTarget());\n\n            // Disembargoes should only be sent to capabilities that were previously the subject of\n            // a `Resolve` message.  But `writeTarget` only ever returns non-null when called on\n            // a PromiseClient.  The code which sends `Resolve` and `Return` should have replaced\n            // any promise with a direct node in order to solve the Tribble 4-way race condition.\n            // See the documentation of Disembargo in rpc.capnp for more.\n            KJ_REQUIRE(redirect == nullptr,\n                       \"'Disembargo' of type 'senderLoopback' sent to an object that does not \"\n                       \"appear to have been the subject of a previous 'Resolve' message.\") {\n              return;\n            }\n          }\n\n          builder.getContext().setReceiverLoopback(embargoId);\n\n          message->send();\n        })));\n\n        break;\n      }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "auto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "kj::evalLater(kj::mvCapture(\n            target, [this,embargoId](kj::Own<ClientHook>&& target) {\n          if (!connection.is<Connected>()) {\n            return;\n          }\n\n          RpcClient& downcasted = kj::downcast<RpcClient>(*target);\n\n          auto message = connection.get<Connected>()->newOutgoingMessage(\n              messageSizeHint<rpc::Disembargo>() + MESSAGE_TARGET_SIZE_HINT);\n          auto builder = message->getBody().initAs<rpc::Message>().initDisembargo();\n\n          {\n            auto redirect = downcasted.writeTarget(builder.initTarget());\n\n            // Disembargoes should only be sent to capabilities that were previously the subject of\n            // a `Resolve` message.  But `writeTarget` only ever returns non-null when called on\n            // a PromiseClient.  The code which sends `Resolve` and `Return` should have replaced\n            // any promise with a direct node in order to solve the Tribble 4-way race condition.\n            // See the documentation of Disembargo in rpc.capnp for more.\n            KJ_REQUIRE(redirect == nullptr,\n                       \"'Disembargo' of type 'senderLoopback' sent to an object that does not \"\n                       \"appear to have been the subject of a previous 'Resolve' message.\") {\n              return;\n            }\n          }\n\n          builder.getContext().setReceiverLoopback(embargoId);\n\n          message->send();\n        }))"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::evalLater",
          "args": [
            "kj::mvCapture(\n            target, [this,embargoId](kj::Own<ClientHook>&& target) {\n          if (!connection.is<Connected>()) {\n            return;\n          }\n\n          RpcClient& downcasted = kj::downcast<RpcClient>(*target);\n\n          auto message = connection.get<Connected>()->newOutgoingMessage(\n              messageSizeHint<rpc::Disembargo>() + MESSAGE_TARGET_SIZE_HINT);\n          auto builder = message->getBody().initAs<rpc::Message>().initDisembargo();\n\n          {\n            auto redirect = downcasted.writeTarget(builder.initTarget());\n\n            // Disembargoes should only be sent to capabilities that were previously the subject of\n            // a `Resolve` message.  But `writeTarget` only ever returns non-null when called on\n            // a PromiseClient.  The code which sends `Resolve` and `Return` should have replaced\n            // any promise with a direct node in order to solve the Tribble 4-way race condition.\n            // See the documentation of Disembargo in rpc.capnp for more.\n            KJ_REQUIRE(redirect == nullptr,\n                       \"'Disembargo' of type 'senderLoopback' sent to an object that does not \"\n                       \"appear to have been the subject of a previous 'Resolve' message.\") {\n              return;\n            }\n          }\n\n          builder.getContext().setReceiverLoopback(embargoId);\n\n          message->send();\n        })"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mvCapture",
          "args": [
            "target",
            "[this,embargoId](kj::Own<ClientHook>&& target) {\n          if (!connection.is<Connected>()) {\n            return;\n          }\n\n          RpcClient& downcasted = kj::downcast<RpcClient>(*target);\n\n          auto message = connection.get<Connected>()->newOutgoingMessage(\n              messageSizeHint<rpc::Disembargo>() + MESSAGE_TARGET_SIZE_HINT);\n          auto builder = message->getBody().initAs<rpc::Message>().initDisembargo();\n\n          {\n            auto redirect = downcasted.writeTarget(builder.initTarget());\n\n            // Disembargoes should only be sent to capabilities that were previously the subject of\n            // a `Resolve` message.  But `writeTarget` only ever returns non-null when called on\n            // a PromiseClient.  The code which sends `Resolve` and `Return` should have replaced\n            // any promise with a direct node in order to solve the Tribble 4-way race condition.\n            // See the documentation of Disembargo in rpc.capnp for more.\n            KJ_REQUIRE(redirect == nullptr,\n                       \"'Disembargo' of type 'senderLoopback' sent to an object that does not \"\n                       \"appear to have been the subject of a previous 'Resolve' message.\") {\n              return;\n            }\n          }\n\n          builder.getContext().setReceiverLoopback(embargoId);\n\n          message->send();\n        }"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "message->send",
          "args": [],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "builder.getContext",
          "args": [
            "embargoId"
          ],
          "line": 2561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getContext",
          "args": [],
          "line": 2561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "redirect == nullptr",
            "\"'Disembargo' of type 'senderLoopback' sent to an object that does not \"\n                       \"appear to have been the subject of a previous 'Resolve' message.\""
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "downcasted.writeTarget",
          "args": [
            "builder.initTarget()"
          ],
          "line": 2547
        },
        "resolved": true,
        "details": {
          "function_name": "writeTarget",
          "container": "RpcConnectionState::NoInterceptClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "949-951",
          "snippet": "kj::Maybe<kj::Own<ClientHook>> writeTarget(rpc::MessageTarget::Builder target) override {\n      return inner->writeTarget(target);\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  NoInterceptClient {\n    kj::Maybe<kj::Own<ClientHook>> writeTarget(rpc::MessageTarget::Builder target) override {\n          return inner->writeTarget(target);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.initTarget",
          "args": [],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message->getBody",
          "args": [],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "getBody",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "106-108",
          "snippet": "AnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nAnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "connection.get<Connected>",
          "args": [
            "messageSizeHint<rpc::Disembargo>() + MESSAGE_TARGET_SIZE_HINT"
          ],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "messageSizeHint<rpc::Disembargo>",
          "args": [],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "messageSizeHint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "40-42",
          "snippet": "inline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\ninline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}"
        }
      },
      {
        "call_info": {
          "callee": "connection.get<Connected>",
          "args": [],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::downcast<RpcClient>",
          "args": [
            "*target"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connection.is<Connected>",
          "args": [],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getSenderLoopback",
          "args": [],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "target->getBrand() == this",
            "\"'Disembargo' of type 'senderLoopback' sent to an object that does not point \"\n                   \"back to the sender.\""
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target->getBrand",
          "args": [],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r->addRef",
          "args": [],
          "line": 2518
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1648-1650",
          "snippet": "kj::Own<RpcResponse> addRef() override {\n      return kj::addRef(*this);\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  kj::Own<RpcResponse> addRef() override {\n        return kj::addRef(*this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "r",
            "target->getResolved()"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "target->getResolved",
          "args": [],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "getResolved",
          "container": "RpcConnectionState::NoInterceptClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "966-968",
          "snippet": "kj::Maybe<ClientHook&> getResolved() override {\n      return nullptr;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  NoInterceptClient {\n    kj::Maybe<ClientHook&> getResolved() override {\n          return nullptr;\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*t"
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getMessageTarget",
          "args": [
            "disembargo.getTarget()"
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "getMessageTarget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2261-2272",
          "snippet": "kj::Maybe<kj::Own<ClientHook>> getMessageTarget(const rpc::MessageTarget::Reader& target) {\n    switch (target.which()) {\n      case rpc::MessageTarget::IMPORTED_CAP: {\n        KJ_IF_MAYBE(exp, exports.find(target.getImportedCap())) {\n          return exp->clientHook->addRef();\n        } else {\n          KJ_FAIL_REQUIRE(\"Message target is not a current export ID.\") {\n            return nullptr;\n          }\n        }\n        break;\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<ClientHook>> getMessageTarget(const rpc::MessageTarget::Reader& target) {\n    switch (target.which()) {\n      case rpc::MessageTarget::IMPORTED_CAP: {\n        KJ_IF_MAYBE(exp, exports.find(target.getImportedCap())) {\n          return exp->clientHook->addRef();\n        } else {\n          KJ_FAIL_REQUIRE(\"Message target is not a current export ID.\") {\n            return nullptr;\n          }\n        }\n        break;\n      }"
        }
      },
      {
        "call_info": {
          "callee": "disembargo.getTarget",
          "args": [],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.which",
          "args": [],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disembargo.getContext",
          "args": [],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));\n\nvoid handleDisembargo(const rpc::Disembargo::Reader& disembargo) {\n    auto context = disembargo.getContext();\n    switch (context.which()) {\n      case rpc::Disembargo::Context::SENDER_LOOPBACK: {\n        kj::Own<ClientHook> target;\n\n        KJ_IF_MAYBE(t, getMessageTarget(disembargo.getTarget())) {\n          target = kj::mv(*t);\n        } else {\n          // Exception already reported.\n          return;\n        }\n\n        for (;;) {\n          KJ_IF_MAYBE(r, target->getResolved()) {\n            target = r->addRef();\n          } else {\n            break;\n          }\n        }\n\n        KJ_REQUIRE(target->getBrand() == this,\n                   \"'Disembargo' of type 'senderLoopback' sent to an object that does not point \"\n                   \"back to the sender.\") {\n          return;\n        }\n\n        EmbargoId embargoId = context.getSenderLoopback();\n\n        // We need to insert an evalLater() here to make sure that any pending calls towards this\n        // cap have had time to find their way through the event loop.\n        tasks.add(kj::evalLater(kj::mvCapture(\n            target, [this,embargoId](kj::Own<ClientHook>&& target) {\n          if (!connection.is<Connected>()) {\n            return;\n          }\n\n          RpcClient& downcasted = kj::downcast<RpcClient>(*target);\n\n          auto message = connection.get<Connected>()->newOutgoingMessage(\n              messageSizeHint<rpc::Disembargo>() + MESSAGE_TARGET_SIZE_HINT);\n          auto builder = message->getBody().initAs<rpc::Message>().initDisembargo();\n\n          {\n            auto redirect = downcasted.writeTarget(builder.initTarget());\n\n            // Disembargoes should only be sent to capabilities that were previously the subject of\n            // a `Resolve` message.  But `writeTarget` only ever returns non-null when called on\n            // a PromiseClient.  The code which sends `Resolve` and `Return` should have replaced\n            // any promise with a direct node in order to solve the Tribble 4-way race condition.\n            // See the documentation of Disembargo in rpc.capnp for more.\n            KJ_REQUIRE(redirect == nullptr,\n                       \"'Disembargo' of type 'senderLoopback' sent to an object that does not \"\n                       \"appear to have been the subject of a previous 'Resolve' message.\") {\n              return;\n            }\n          }\n\n          builder.getContext().setReceiverLoopback(embargoId);\n\n          message->send();\n        })));\n\n        break;\n      }"
  },
  {
    "function_name": "releaseExports",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2497-2501",
    "snippet": "void releaseExports(kj::ArrayPtr<ExportId> exports) {\n    for (auto exportId: exports) {\n      releaseExport(exportId, 1);\n    }\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "releaseExport",
          "args": [
            "exportId",
            "1"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "releaseExport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2479-2493",
          "snippet": "void releaseExport(ExportId id, uint refcount) {\n    KJ_IF_MAYBE(exp, exports.find(id)) {\n      KJ_REQUIRE(refcount <= exp->refcount, \"Tried to drop export's refcount below zero.\") {\n        return;\n      }\n\n      exp->refcount -= refcount;\n      if (exp->refcount == 0) {\n        exportsByCap.erase(exp->clientHook);\n        exports.erase(id, *exp);\n      }\n    } else {\n      KJ_FAIL_REQUIRE(\"Tried to release invalid export ID.\") {\n        return;\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid releaseExport(ExportId id, uint refcount) {\n    KJ_IF_MAYBE(exp, exports.find(id)) {\n      KJ_REQUIRE(refcount <= exp->refcount, \"Tried to drop export's refcount below zero.\") {\n        return;\n      }\n\n      exp->refcount -= refcount;\n      if (exp->refcount == 0) {\n        exportsByCap.erase(exp->clientHook);\n        exports.erase(id, *exp);\n      }\n    } else {\n      KJ_FAIL_REQUIRE(\"Tried to release invalid export ID.\") {\n        return;\n      }"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid releaseExports(kj::ArrayPtr<ExportId> exports) {\n    for (auto exportId: exports) {\n      releaseExport(exportId, 1);\n    }\n  }"
  },
  {
    "function_name": "releaseExport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2479-2493",
    "snippet": "void releaseExport(ExportId id, uint refcount) {\n    KJ_IF_MAYBE(exp, exports.find(id)) {\n      KJ_REQUIRE(refcount <= exp->refcount, \"Tried to drop export's refcount below zero.\") {\n        return;\n      }\n\n      exp->refcount -= refcount;\n      if (exp->refcount == 0) {\n        exportsByCap.erase(exp->clientHook);\n        exports.erase(id, *exp);\n      }\n    } else {\n      KJ_FAIL_REQUIRE(\"Tried to release invalid export ID.\") {\n        return;\n      }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Tried to release invalid export ID.\""
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exports.erase",
          "args": [
            "id",
            "*exp"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "ExportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "140-151",
          "snippet": "T erase(Id id, T& entry) {\n    // Remove an entry from the table and return it.  We return it so that the caller can be\n    // careful to release it (possibly invoking arbitrary destructors) at a time that makes sense.\n    // `entry` is a reference to the entry being released -- we require this in order to prove\n    // that the caller has already done a find() to check that this entry exists.  We can't check\n    // ourselves because the caller may have nullified the entry in the meantime.\n    KJ_DREQUIRE(&entry == &slots[id]);\n    T toRelease = kj::mv(slots[id]);\n    slots[id] = T();\n    freeIds.push(id);\n    return toRelease;\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nExportTable {\n  T erase(Id id, T& entry) {\n      // Remove an entry from the table and return it.  We return it so that the caller can be\n      // careful to release it (possibly invoking arbitrary destructors) at a time that makes sense.\n      // `entry` is a reference to the entry being released -- we require this in order to prove\n      // that the caller has already done a find() to check that this entry exists.  We can't check\n      // ourselves because the caller may have nullified the entry in the meantime.\n      KJ_DREQUIRE(&entry == &slots[id]);\n      T toRelease = kj::mv(slots[id]);\n      slots[id] = T();\n      freeIds.push(id);\n      return toRelease;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "refcount <= exp->refcount",
            "\"Tried to drop export's refcount below zero.\""
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exp",
            "exports.find(id)"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "exports.find",
          "args": [
            "id"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "191-202",
          "snippet": "kj::Maybe<T&> find(Id id) {\n    if (id < kj::size(low)) {\n      return low[id];\n    } else {\n      auto iter = high.find(id);\n      if (iter == high.end()) {\n        return nullptr;\n      } else {\n        return iter->second;\n      }\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  kj::Maybe<T&> find(Id id) {\n      if (id < kj::size(low)) {\n        return low[id];\n      } else {\n        auto iter = high.find(id);\n        if (iter == high.end()) {\n          return nullptr;\n        } else {\n          return iter->second;\n        }\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid releaseExport(ExportId id, uint refcount) {\n    KJ_IF_MAYBE(exp, exports.find(id)) {\n      KJ_REQUIRE(refcount <= exp->refcount, \"Tried to drop export's refcount below zero.\") {\n        return;\n      }\n\n      exp->refcount -= refcount;\n      if (exp->refcount == 0) {\n        exportsByCap.erase(exp->clientHook);\n        exports.erase(id, *exp);\n      }\n    } else {\n      KJ_FAIL_REQUIRE(\"Tried to release invalid export ID.\") {\n        return;\n      }"
  },
  {
    "function_name": "handleRelease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2475-2477",
    "snippet": "void handleRelease(const rpc::Release::Reader& release) {\n    releaseExport(release.getId(), release.getReferenceCount());\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "releaseExport",
          "args": [
            "release.getId()",
            "release.getReferenceCount()"
          ],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "releaseExport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2479-2493",
          "snippet": "void releaseExport(ExportId id, uint refcount) {\n    KJ_IF_MAYBE(exp, exports.find(id)) {\n      KJ_REQUIRE(refcount <= exp->refcount, \"Tried to drop export's refcount below zero.\") {\n        return;\n      }\n\n      exp->refcount -= refcount;\n      if (exp->refcount == 0) {\n        exportsByCap.erase(exp->clientHook);\n        exports.erase(id, *exp);\n      }\n    } else {\n      KJ_FAIL_REQUIRE(\"Tried to release invalid export ID.\") {\n        return;\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid releaseExport(ExportId id, uint refcount) {\n    KJ_IF_MAYBE(exp, exports.find(id)) {\n      KJ_REQUIRE(refcount <= exp->refcount, \"Tried to drop export's refcount below zero.\") {\n        return;\n      }\n\n      exp->refcount -= refcount;\n      if (exp->refcount == 0) {\n        exportsByCap.erase(exp->clientHook);\n        exports.erase(id, *exp);\n      }\n    } else {\n      KJ_FAIL_REQUIRE(\"Tried to release invalid export ID.\") {\n        return;\n      }"
        }
      },
      {
        "call_info": {
          "callee": "release.getReferenceCount",
          "args": [],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release.getId",
          "args": [],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid handleRelease(const rpc::Release::Reader& release) {\n    releaseExport(release.getId(), release.getReferenceCount());\n  }"
  },
  {
    "function_name": "KJ_IF_MAYBE",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2462-2464",
    "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fulfiller->get",
          "args": [
            "kj::mv(*e)"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*e"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fulfiller->get",
          "args": [],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
  },
  {
    "function_name": "handleResolve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2433-2444",
    "snippet": "void handleResolve(const rpc::Resolve::Reader& resolve) {\n    kj::Own<ClientHook> replacement;\n    kj::Maybe<kj::Exception> exception;\n\n    // Extract the replacement capability.\n    switch (resolve.which()) {\n      case rpc::Resolve::CAP:\n        KJ_IF_MAYBE(cap, receiveCap(resolve.getCap())) {\n          replacement = kj::mv(*cap);\n        } else {\n          KJ_FAIL_REQUIRE(\"'Resolve' contained 'CapDescriptor.none'.\") { return; }\n        }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"'Resolve' contained 'CapDescriptor.none'.\""
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*cap"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "cap",
            "receiveCap(resolve.getCap())"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "receiveCap",
          "args": [
            "resolve.getCap()"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "receiveCap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1191-1224",
          "snippet": "kj::Maybe<kj::Own<ClientHook>> receiveCap(rpc::CapDescriptor::Reader descriptor) {\n    switch (descriptor.which()) {\n      case rpc::CapDescriptor::NONE:\n        return nullptr;\n\n      case rpc::CapDescriptor::SENDER_HOSTED:\n        return import(descriptor.getSenderHosted(), false);\n      case rpc::CapDescriptor::SENDER_PROMISE:\n        return import(descriptor.getSenderPromise(), true);\n\n      case rpc::CapDescriptor::RECEIVER_HOSTED:\n        KJ_IF_MAYBE(exp, exports.find(descriptor.getReceiverHosted())) {\n          return exp->clientHook->addRef();\n        } else {\n          return newBrokenCap(\"invalid 'receiverHosted' export ID\");\n        }\n\n      case rpc::CapDescriptor::RECEIVER_ANSWER: {\n        auto promisedAnswer = descriptor.getReceiverAnswer();\n\n        KJ_IF_MAYBE(answer, answers.find(promisedAnswer.getQuestionId())) {\n          if (answer->active) {\n            KJ_IF_MAYBE(pipeline, answer->pipeline) {\n              KJ_IF_MAYBE(ops, toPipelineOps(promisedAnswer.getTransform())) {\n                return pipeline->get()->getPipelinedCap(*ops);\n              } else {\n                return newBrokenCap(\"unrecognized pipeline ops\");\n              }\n            }\n          }\n        }\n\n        return newBrokenCap(\"invalid 'receiverAnswer'\");\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "auto& answer = answers[answerId];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto& answer = answers[answerId];\n\nkj::Maybe<kj::Own<ClientHook>> receiveCap(rpc::CapDescriptor::Reader descriptor) {\n    switch (descriptor.which()) {\n      case rpc::CapDescriptor::NONE:\n        return nullptr;\n\n      case rpc::CapDescriptor::SENDER_HOSTED:\n        return import(descriptor.getSenderHosted(), false);\n      case rpc::CapDescriptor::SENDER_PROMISE:\n        return import(descriptor.getSenderPromise(), true);\n\n      case rpc::CapDescriptor::RECEIVER_HOSTED:\n        KJ_IF_MAYBE(exp, exports.find(descriptor.getReceiverHosted())) {\n          return exp->clientHook->addRef();\n        } else {\n          return newBrokenCap(\"invalid 'receiverHosted' export ID\");\n        }\n\n      case rpc::CapDescriptor::RECEIVER_ANSWER: {\n        auto promisedAnswer = descriptor.getReceiverAnswer();\n\n        KJ_IF_MAYBE(answer, answers.find(promisedAnswer.getQuestionId())) {\n          if (answer->active) {\n            KJ_IF_MAYBE(pipeline, answer->pipeline) {\n              KJ_IF_MAYBE(ops, toPipelineOps(promisedAnswer.getTransform())) {\n                return pipeline->get()->getPipelinedCap(*ops);\n              } else {\n                return newBrokenCap(\"unrecognized pipeline ops\");\n              }\n            }\n          }\n        }\n\n        return newBrokenCap(\"invalid 'receiverAnswer'\");\n      }"
        }
      },
      {
        "call_info": {
          "callee": "resolve.getCap",
          "args": [],
          "line": 2440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolve.which",
          "args": [],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid handleResolve(const rpc::Resolve::Reader& resolve) {\n    kj::Own<ClientHook> replacement;\n    kj::Maybe<kj::Exception> exception;\n\n    // Extract the replacement capability.\n    switch (resolve.which()) {\n      case rpc::Resolve::CAP:\n        KJ_IF_MAYBE(cap, receiveCap(resolve.getCap())) {\n          replacement = kj::mv(*cap);\n        } else {\n          KJ_FAIL_REQUIRE(\"'Resolve' contained 'CapDescriptor.none'.\") { return; }\n        }"
  },
  {
    "function_name": "handleFinish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2399-2425",
    "snippet": "void handleFinish(const rpc::Finish::Reader& finish) {\n    // Delay release of these things until return so that transitive destructors don't accidentally\n    // modify the answer table and invalidate our pointer into it.\n    kj::Array<ExportId> exportsToRelease;\n    KJ_DEFER(releaseExports(exportsToRelease));\n    Answer answerToRelease;\n    kj::Maybe<kj::Own<PipelineHook>> pipelineToRelease;\n\n    KJ_IF_MAYBE(answer, answers.find(finish.getQuestionId())) {\n      KJ_REQUIRE(answer->active, \"'Finish' for invalid question ID.\") { return; }\n\n      if (finish.getReleaseResultCaps()) {\n        exportsToRelease = kj::mv(answer->resultExports);\n      } else {\n        answer->resultExports = nullptr;\n      }\n\n      pipelineToRelease = kj::mv(answer->pipeline);\n\n      // If the call isn't actually done yet, cancel it.  Otherwise, we can go ahead and erase the\n      // question from the table.\n      KJ_IF_MAYBE(context, answer->callContext) {\n        context->requestCancel();\n      } else {\n        answerToRelease = answers.erase(finish.getQuestionId());\n      }\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "auto& answer = answers[answerId];",
      "auto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "answers.erase",
          "args": [
            "finish.getQuestionId()"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "204-216",
          "snippet": "T erase(Id id) {\n    // Remove an entry from the table and return it.  We return it so that the caller can be\n    // careful to release it (possibly invoking arbitrary destructors) at a time that makes sense.\n    if (id < kj::size(low)) {\n      T toRelease = kj::mv(low[id]);\n      low[id] = T();\n      return toRelease;\n    } else {\n      T toRelease = kj::mv(high[id]);\n      high.erase(id);\n      return toRelease;\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  T erase(Id id) {\n      // Remove an entry from the table and return it.  We return it so that the caller can be\n      // careful to release it (possibly invoking arbitrary destructors) at a time that makes sense.\n      if (id < kj::size(low)) {\n        T toRelease = kj::mv(low[id]);\n        low[id] = T();\n        return toRelease;\n      } else {\n        T toRelease = kj::mv(high[id]);\n        high.erase(id);\n        return toRelease;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish.getQuestionId",
          "args": [],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->requestCancel",
          "args": [],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "context",
            "answer->callContext"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "answer->pipeline"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "answer->resultExports"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish.getReleaseResultCaps",
          "args": [],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "answer->active",
            "\"'Finish' for invalid question ID.\""
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "answers.find",
          "args": [
            "finish.getQuestionId()"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "191-202",
          "snippet": "kj::Maybe<T&> find(Id id) {\n    if (id < kj::size(low)) {\n      return low[id];\n    } else {\n      auto iter = high.find(id);\n      if (iter == high.end()) {\n        return nullptr;\n      } else {\n        return iter->second;\n      }\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  kj::Maybe<T&> find(Id id) {\n      if (id < kj::size(low)) {\n        return low[id];\n      } else {\n        auto iter = high.find(id);\n        if (iter == high.end()) {\n          return nullptr;\n        } else {\n          return iter->second;\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish.getQuestionId",
          "args": [],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "releaseExports(exportsToRelease)"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "releaseExports",
          "args": [
            "exportsToRelease"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "releaseExports",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2497-2501",
          "snippet": "void releaseExports(kj::ArrayPtr<ExportId> exports) {\n    for (auto exportId: exports) {\n      releaseExport(exportId, 1);\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid releaseExports(kj::ArrayPtr<ExportId> exports) {\n    for (auto exportId: exports) {\n      releaseExport(exportId, 1);\n    }\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto& answer = answers[answerId];\nauto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));\n\nvoid handleFinish(const rpc::Finish::Reader& finish) {\n    // Delay release of these things until return so that transitive destructors don't accidentally\n    // modify the answer table and invalidate our pointer into it.\n    kj::Array<ExportId> exportsToRelease;\n    KJ_DEFER(releaseExports(exportsToRelease));\n    Answer answerToRelease;\n    kj::Maybe<kj::Own<PipelineHook>> pipelineToRelease;\n\n    KJ_IF_MAYBE(answer, answers.find(finish.getQuestionId())) {\n      KJ_REQUIRE(answer->active, \"'Finish' for invalid question ID.\") { return; }\n\n      if (finish.getReleaseResultCaps()) {\n        exportsToRelease = kj::mv(answer->resultExports);\n      } else {\n        answer->resultExports = nullptr;\n      }\n\n      pipelineToRelease = kj::mv(answer->pipeline);\n\n      // If the call isn't actually done yet, cancel it.  Otherwise, we can go ahead and erase the\n      // question from the table.\n      KJ_IF_MAYBE(context, answer->callContext) {\n        context->requestCancel();\n      } else {\n        answerToRelease = answers.erase(finish.getQuestionId());\n      }\n    }"
  },
  {
    "function_name": "getMessageTarget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2261-2272",
    "snippet": "kj::Maybe<kj::Own<ClientHook>> getMessageTarget(const rpc::MessageTarget::Reader& target) {\n    switch (target.which()) {\n      case rpc::MessageTarget::IMPORTED_CAP: {\n        KJ_IF_MAYBE(exp, exports.find(target.getImportedCap())) {\n          return exp->clientHook->addRef();\n        } else {\n          KJ_FAIL_REQUIRE(\"Message target is not a current export ID.\") {\n            return nullptr;\n          }\n        }\n        break;\n      }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Message target is not a current export ID.\""
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp->clientHook->addRef",
          "args": [],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": "SingleCapPipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2064-2066",
          "snippet": "kj::Own<PipelineHook> addRef() override {\n      return kj::addRef(*this);\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nSingleCapPipeline {\n  kj::Own<PipelineHook> addRef() override {\n        return kj::addRef(*this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exp",
            "exports.find(target.getImportedCap())"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "exports.find",
          "args": [
            "target.getImportedCap()"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "191-202",
          "snippet": "kj::Maybe<T&> find(Id id) {\n    if (id < kj::size(low)) {\n      return low[id];\n    } else {\n      auto iter = high.find(id);\n      if (iter == high.end()) {\n        return nullptr;\n      } else {\n        return iter->second;\n      }\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  kj::Maybe<T&> find(Id id) {\n      if (id < kj::size(low)) {\n        return low[id];\n      } else {\n        auto iter = high.find(id);\n        if (iter == high.end()) {\n          return nullptr;\n        } else {\n          return iter->second;\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "target.getImportedCap",
          "args": [],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.which",
          "args": [],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<ClientHook>> getMessageTarget(const rpc::MessageTarget::Reader& target) {\n    switch (target.which()) {\n      case rpc::MessageTarget::IMPORTED_CAP: {\n        KJ_IF_MAYBE(exp, exports.find(target.getImportedCap())) {\n          return exp->clientHook->addRef();\n        } else {\n          KJ_FAIL_REQUIRE(\"Message target is not a current export ID.\") {\n            return nullptr;\n          }\n        }\n        break;\n      }"
  },
  {
    "function_name": "startCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2234-2259",
    "snippet": "ClientHook::VoidPromiseAndPipeline startCall(\n      uint64_t interfaceId, uint64_t methodId,\n      kj::Own<ClientHook>&& capability, kj::Own<CallContextHook>&& context) {\n    if (interfaceId == typeId<Persistent<>>() && methodId == 0) {\n      KJ_IF_MAYBE(g, gateway) {\n        // Wait, this is a call to Persistent.save() and we need to translate it through our\n        // gateway.\n\n        auto params = context->getParams().getAs<Persistent<>::SaveParams>();\n\n        auto requestSize = params.totalSize();\n        ++requestSize.capCount;\n        requestSize.wordCount += sizeInWords<RealmGateway<>::ExportParams>();\n\n        auto request = g->exportRequest(requestSize);\n        request.setCap(Persistent<>::Client(capability->addRef()));\n        request.setParams(params);\n\n        context->allowCancellation();\n        context->releaseParams();\n        return context->directTailCall(RequestHook::from(kj::mv(request)));\n      }\n    }\n\n    return capability->call(interfaceId, methodId, context->addRef());\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
      "AnyPointer::Reader params;",
      "auto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "capability->call",
          "args": [
            "interfaceId",
            "methodId",
            "context->addRef()"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "call",
          "container": "RpcConnectionState::NoInterceptClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "961-964",
          "snippet": "VoidPromiseAndPipeline call(uint64_t interfaceId, uint16_t methodId,\n                                kj::Own<CallContextHook>&& context) override {\n      return inner->callNoIntercept(interfaceId, methodId, kj::mv(context));\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "auto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));\n\nRpcConnectionState {\n  NoInterceptClient {\n    VoidPromiseAndPipeline call(uint64_t interfaceId, uint16_t methodId,\n                                    kj::Own<CallContextHook>&& context) override {\n          return inner->callNoIntercept(interfaceId, methodId, kj::mv(context));\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context->addRef",
          "args": [],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": "SingleCapPipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2064-2066",
          "snippet": "kj::Own<PipelineHook> addRef() override {\n      return kj::addRef(*this);\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nSingleCapPipeline {\n  kj::Own<PipelineHook> addRef() override {\n        return kj::addRef(*this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context->directTailCall",
          "args": [
            "RequestHook::from(kj::mv(request))"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RequestHook::from",
          "args": [
            "kj::mv(request)"
          ],
          "line": 2254
        },
        "resolved": true,
        "details": {
          "function_name": "from",
          "container": "RequestHook",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.h",
          "lines": "354-356",
          "snippet": "inline static kj::Own<RequestHook> from(Request<T, U>&& request) {\n    return kj::mv(request.hook);\n  }",
          "includes": [
            "#include \"pointer-helpers.h\"",
            "#include \"any.h\"",
            "#include <kj/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pointer-helpers.h\"\n#include \"any.h\"\n#include <kj/async.h>\n\nRequestHook {\n  inline static kj::Own<RequestHook> from(Request<T, U>&& request) {\n      return kj::mv(request.hook);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "request"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->releaseParams",
          "args": [],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->allowCancellation",
          "args": [],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "allowCancellation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1858-1867",
          "snippet": "void allowCancellation() override {\n      bool previouslyRequestedButNotAllowed = cancellationFlags == CANCEL_REQUESTED;\n      cancellationFlags |= CANCEL_ALLOWED;\n\n      if (previouslyRequestedButNotAllowed) {\n        // We just set CANCEL_ALLOWED, and CANCEL_REQUESTED was already set previously.  Initiate\n        // the cancellation.\n        cancelFulfiller->fulfill();\n      }\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint8_t cancellationFlags = 0;",
            "kj::Own<kj::PromiseFulfiller<void>> cancelFulfiller;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nuint8_t cancellationFlags = 0;\nkj::Own<kj::PromiseFulfiller<void>> cancelFulfiller;\n\nvoid allowCancellation() override {\n      bool previouslyRequestedButNotAllowed = cancellationFlags == CANCEL_REQUESTED;\n      cancellationFlags |= CANCEL_ALLOWED;\n\n      if (previouslyRequestedButNotAllowed) {\n        // We just set CANCEL_ALLOWED, and CANCEL_REQUESTED was already set previously.  Initiate\n        // the cancellation.\n        cancelFulfiller->fulfill();\n      }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "request.setParams",
          "args": [
            "params"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setCap",
          "args": [
            "Persistent<>::Client(capability->addRef())"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Persistent<>::Client",
          "args": [
            "capability->addRef()"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g->exportRequest",
          "args": [
            "requestSize"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sizeInWords<RealmGateway<>::ExportParams>",
          "args": [],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.totalSize",
          "args": [],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "totalSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.capnp.h",
          "lines": "558-558",
          "snippet": "inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }"
        }
      },
      {
        "call_info": {
          "callee": "context->getParams",
          "args": [],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getParams",
          "args": [],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeId<Persistent<>>",
          "args": [],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nAnyPointer::Reader params;\nauto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));\n\nClientHook::VoidPromiseAndPipeline startCall(\n      uint64_t interfaceId, uint64_t methodId,\n      kj::Own<ClientHook>&& capability, kj::Own<CallContextHook>&& context) {\n    if (interfaceId == typeId<Persistent<>>() && methodId == 0) {\n      KJ_IF_MAYBE(g, gateway) {\n        // Wait, this is a call to Persistent.save() and we need to translate it through our\n        // gateway.\n\n        auto params = context->getParams().getAs<Persistent<>::SaveParams>();\n\n        auto requestSize = params.totalSize();\n        ++requestSize.capCount;\n        requestSize.wordCount += sizeInWords<RealmGateway<>::ExportParams>();\n\n        auto request = g->exportRequest(requestSize);\n        request.setCap(Persistent<>::Client(capability->addRef()));\n        request.setParams(params);\n\n        context->allowCancellation();\n        context->releaseParams();\n        return context->directTailCall(RequestHook::from(kj::mv(request)));\n      }\n    }\n\n    return capability->call(interfaceId, methodId, context->addRef());\n  }"
  },
  {
    "function_name": "handleCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2142-2150",
    "snippet": "void handleCall(kj::Own<IncomingRpcMessage>&& message, const rpc::Call::Reader& call) {\n    kj::Own<ClientHook> capability;\n\n    KJ_IF_MAYBE(t, getMessageTarget(call.getTarget())) {\n      capability = kj::mv(*t);\n    } else {\n      // Exception already reported.\n      return;\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*t"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "t",
            "getMessageTarget(call.getTarget())"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "getMessageTarget",
          "args": [
            "call.getTarget()"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "getMessageTarget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2261-2272",
          "snippet": "kj::Maybe<kj::Own<ClientHook>> getMessageTarget(const rpc::MessageTarget::Reader& target) {\n    switch (target.which()) {\n      case rpc::MessageTarget::IMPORTED_CAP: {\n        KJ_IF_MAYBE(exp, exports.find(target.getImportedCap())) {\n          return exp->clientHook->addRef();\n        } else {\n          KJ_FAIL_REQUIRE(\"Message target is not a current export ID.\") {\n            return nullptr;\n          }\n        }\n        break;\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<ClientHook>> getMessageTarget(const rpc::MessageTarget::Reader& target) {\n    switch (target.which()) {\n      case rpc::MessageTarget::IMPORTED_CAP: {\n        KJ_IF_MAYBE(exp, exports.find(target.getImportedCap())) {\n          return exp->clientHook->addRef();\n        } else {\n          KJ_FAIL_REQUIRE(\"Message target is not a current export ID.\") {\n            return nullptr;\n          }\n        }\n        break;\n      }"
        }
      },
      {
        "call_info": {
          "callee": "call.getTarget",
          "args": [],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid handleCall(kj::Own<IncomingRpcMessage>&& message, const rpc::Call::Reader& call) {\n    kj::Own<ClientHook> capability;\n\n    KJ_IF_MAYBE(t, getMessageTarget(call.getTarget())) {\n      capability = kj::mv(*t);\n    } else {\n      // Exception already reported.\n      return;\n    }"
  },
  {
    "function_name": "handleBootstrap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2080-2122",
    "snippet": "void handleBootstrap(kj::Own<IncomingRpcMessage>&& message,\n                       const rpc::Bootstrap::Reader& bootstrap) {\n    AnswerId answerId = bootstrap.getQuestionId();\n\n    if (!connection.is<Connected>()) {\n      // Disconnected; ignore.\n      return;\n    }\n\n    auto response = connection.get<Connected>()->newOutgoingMessage(\n        messageSizeHint<rpc::Return>() + sizeInWords<rpc::CapDescriptor>() + 32);\n\n    rpc::Return::Builder ret = response->getBody().getAs<rpc::Message>().initReturn();\n    ret.setAnswerId(answerId);\n\n    kj::Own<ClientHook> capHook;\n    kj::Array<ExportId> resultExports;\n    KJ_DEFER(releaseExports(resultExports));  // in case something goes wrong\n\n    // Call the restorer and initialize the answer.\n    KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n      Capability::Client cap = nullptr;\n      KJ_IF_MAYBE(r, restorer) {\n        cap = r->baseRestore(bootstrap.getDeprecatedObjectId());\n      } else KJ_IF_MAYBE(b, bootstrapInterface) {\n        if (bootstrap.hasDeprecatedObjectId()) {\n          KJ_FAIL_REQUIRE(\"This vat only supports a bootstrap interface, not the old \"\n                          \"Cap'n-Proto-0.4-style named exports.\") { return; }\n        } else {\n          cap = *b;\n        }\n      } else {\n        KJ_FAIL_REQUIRE(\"This vat does not expose any public/bootstrap interfaces.\") { return; }\n      }\n\n      auto payload = ret.initResults();\n      payload.getContent().setAs<Capability>(kj::mv(cap));\n\n      auto capTable = response->getCapTable();\n      KJ_DASSERT(capTable.size() == 1);\n      resultExports = writeDescriptors(capTable, payload);\n      capHook = KJ_ASSERT_NONNULL(capTable[0])->addRef();\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "AnswerId answerId;",
      "kj::Maybe<kj::Own<RpcServerResponse>> response;",
      "auto& answer = answers[answerId];",
      "auto payload = call.getParams();",
      "AnswerId answerId = call.getQuestionId();"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "capTable[0]"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeDescriptors",
          "args": [
            "capTable",
            "payload"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exception",
            "kj::runCatchingExceptions([&]() {\n      Capability::Client cap = nullptr;\n      KJ_IF_MAYBE(r, restorer) {\n        cap = r->baseRestore(bootstrap.getDeprecatedObjectId());\n      } else KJ_IF_MAYBE(b, bootstrapInterface) {\n        if (bootstrap.hasDeprecatedObjectId()) {\n          KJ_FAIL_REQUIRE(\"This vat only supports a bootstrap interface, not the old \"\n                          \"Cap'n-Proto-0.4-style named exports.\") { return; }\n        } else {\n          cap = *b;\n        }\n      } else {\n        KJ_FAIL_REQUIRE(\"This vat does not expose any public/bootstrap interfaces.\") { return; }\n      }\n\n      auto payload = ret.initResults();\n      payload.getContent().setAs<Capability>(kj::mv(cap));\n\n      auto capTable = response->getCapTable();\n      KJ_DASSERT(capTable.size() == 1)"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() {\n      Capability::Client cap = nullptr;\n      KJ_IF_MAYBE(r, restorer) {\n        cap = r->baseRestore(bootstrap.getDeprecatedObjectId());\n      } else KJ_IF_MAYBE(b, bootstrapInterface) {\n        if (bootstrap.hasDeprecatedObjectId()) {\n          KJ_FAIL_REQUIRE(\"This vat only supports a bootstrap interface, not the old \"\n                          \"Cap'n-Proto-0.4-style named exports.\") { return; }\n        } else {\n          cap = *b;\n        }\n      } else {\n        KJ_FAIL_REQUIRE(\"This vat does not expose any public/bootstrap interfaces.\") { return; }\n      }\n\n      auto payload = ret.initResults();\n      payload.getContent().setAs<Capability>(kj::mv(cap));\n\n      auto capTable = response->getCapTable();\n      KJ_DASSERT(capTable.size() == 1"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "[&]",
          "args": [],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "[&]",
          "args": [],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "[&]",
          "args": [
            "kj::mv(cap)"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "cap"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "[&]",
          "args": [],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "[&]",
          "args": [],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"This vat does not expose any public/bootstrap interfaces.\""
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"This vat only supports a bootstrap interface, not the old \"\n                          \"Cap'n-Proto-0.4-style named exports.\""
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bootstrap.hasDeprecatedObjectId",
          "args": [],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r->baseRestore",
          "args": [
            "bootstrap.getDeprecatedObjectId()"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bootstrap.getDeprecatedObjectId",
          "args": [],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "releaseExports(resultExports)"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "releaseExports",
          "args": [
            "resultExports"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "releaseExports",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2497-2501",
          "snippet": "void releaseExports(kj::ArrayPtr<ExportId> exports) {\n    for (auto exportId: exports) {\n      releaseExport(exportId, 1);\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid releaseExports(kj::ArrayPtr<ExportId> exports) {\n    for (auto exportId: exports) {\n      releaseExport(exportId, 1);\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "ret.setAnswerId",
          "args": [
            "answerId"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response->getBody",
          "args": [],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "getBody",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "106-108",
          "snippet": "AnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nAnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "connection.get<Connected>",
          "args": [
            "messageSizeHint<rpc::Return>() + sizeInWords<rpc::CapDescriptor>() + 32"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "sizeInWords<rpc::CapDescriptor>",
          "args": [],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "sizeInWords",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "496-502",
          "snippet": "inline constexpr uint sizeInWords() {\n  // Return the size, in words, of a Struct type, if allocated free-standing (not in a list).\n  // May be useful for pre-computing space needed in order to precisely allocate messages.\n\n  return (WordCount32(_::structSize<T>().data) +\n      _::structSize<T>().pointers * WORDS_PER_POINTER) / WORDS;\n}",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\ninline constexpr uint sizeInWords() {\n  // Return the size, in words, of a Struct type, if allocated free-standing (not in a list).\n  // May be useful for pre-computing space needed in order to precisely allocate messages.\n\n  return (WordCount32(_::structSize<T>().data) +\n      _::structSize<T>().pointers * WORDS_PER_POINTER) / WORDS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "messageSizeHint<rpc::Return>",
          "args": [],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "messageSizeHint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "40-42",
          "snippet": "inline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\ninline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}"
        }
      },
      {
        "call_info": {
          "callee": "connection.get<Connected>",
          "args": [],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "connection.is<Connected>",
          "args": [],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bootstrap.getQuestionId",
          "args": [],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nAnswerId answerId;\nkj::Maybe<kj::Own<RpcServerResponse>> response;\nauto& answer = answers[answerId];\nauto payload = call.getParams();\nAnswerId answerId = call.getQuestionId();\n\nvoid handleBootstrap(kj::Own<IncomingRpcMessage>&& message,\n                       const rpc::Bootstrap::Reader& bootstrap) {\n    AnswerId answerId = bootstrap.getQuestionId();\n\n    if (!connection.is<Connected>()) {\n      // Disconnected; ignore.\n      return;\n    }\n\n    auto response = connection.get<Connected>()->newOutgoingMessage(\n        messageSizeHint<rpc::Return>() + sizeInWords<rpc::CapDescriptor>() + 32);\n\n    rpc::Return::Builder ret = response->getBody().getAs<rpc::Message>().initReturn();\n    ret.setAnswerId(answerId);\n\n    kj::Own<ClientHook> capHook;\n    kj::Array<ExportId> resultExports;\n    KJ_DEFER(releaseExports(resultExports));  // in case something goes wrong\n\n    // Call the restorer and initialize the answer.\n    KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n      Capability::Client cap = nullptr;\n      KJ_IF_MAYBE(r, restorer) {\n        cap = r->baseRestore(bootstrap.getDeprecatedObjectId());\n      } else KJ_IF_MAYBE(b, bootstrapInterface) {\n        if (bootstrap.hasDeprecatedObjectId()) {\n          KJ_FAIL_REQUIRE(\"This vat only supports a bootstrap interface, not the old \"\n                          \"Cap'n-Proto-0.4-style named exports.\") { return; }\n        } else {\n          cap = *b;\n        }\n      } else {\n        KJ_FAIL_REQUIRE(\"This vat does not expose any public/bootstrap interfaces.\") { return; }\n      }\n\n      auto payload = ret.initResults();\n      payload.getContent().setAs<Capability>(kj::mv(cap));\n\n      auto capTable = response->getCapTable();\n      KJ_DASSERT(capTable.size() == 1);\n      resultExports = writeDescriptors(capTable, payload);\n      capHook = KJ_ASSERT_NONNULL(capTable[0])->addRef();\n    }"
  },
  {
    "function_name": "getPipelinedCap",
    "container": "SingleCapPipeline",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2068-2074",
    "snippet": "kj::Own<ClientHook> getPipelinedCap(kj::ArrayPtr<const PipelineOp> ops) override {\n      if (ops.size() == 0) {\n        return cap->addRef();\n      } else {\n        return newBrokenCap(\"Invalid pipeline transform.\");\n      }\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "newBrokenCap",
          "args": [
            "\"Invalid pipeline transform.\""
          ],
          "line": 2072
        },
        "resolved": true,
        "details": {
          "function_name": "newBrokenCap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "620-622",
          "snippet": "kj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap->addRef",
          "args": [],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": "SingleCapPipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2064-2066",
          "snippet": "kj::Own<PipelineHook> addRef() override {\n      return kj::addRef(*this);\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nSingleCapPipeline {\n  kj::Own<PipelineHook> addRef() override {\n        return kj::addRef(*this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops.size",
          "args": [],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nSingleCapPipeline {\n  kj::Own<ClientHook> getPipelinedCap(kj::ArrayPtr<const PipelineOp> ops) override {\n        if (ops.size() == 0) {\n          return cap->addRef();\n        } else {\n          return newBrokenCap(\"Invalid pipeline transform.\");\n        }\n      }\n}"
  },
  {
    "function_name": "addRef",
    "container": "SingleCapPipeline",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2064-2066",
    "snippet": "kj::Own<PipelineHook> addRef() override {\n      return kj::addRef(*this);\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nSingleCapPipeline {\n  kj::Own<PipelineHook> addRef() override {\n        return kj::addRef(*this);\n      }\n}"
  },
  {
    "function_name": "SingleCapPipeline",
    "container": "SingleCapPipeline",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2061-2062",
    "snippet": "SingleCapPipeline(kj::Own<ClientHook>&& cap)\n        : cap(kj::mv(cap)) {}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "cap"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nSingleCapPipeline {\n  SingleCapPipeline(kj::Own<ClientHook>&& cap)\n          : cap(kj::mv(cap)) {}\n}"
  },
  {
    "function_name": "handleAbort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2052-2054",
    "snippet": "void handleAbort(const rpc::Exception::Reader& exception) {\n    kj::throwRecoverableException(toException(exception));\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::throwRecoverableException",
          "args": [
            "toException(exception)"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "throwRecoverableException",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "353-355",
          "snippet": "void throwRecoverableException(kj::Exception&& exception) {\n  getExceptionCallback().onRecoverableException(kj::mv(exception));\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid throwRecoverableException(kj::Exception&& exception) {\n  getExceptionCallback().onRecoverableException(kj::mv(exception));\n}"
        }
      },
      {
        "call_info": {
          "callee": "toException",
          "args": [
            "exception"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "toException",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "109-112",
          "snippet": "kj::Exception toException(const rpc::Exception::Reader& exception) {\n  return kj::Exception(static_cast<kj::Exception::Type>(exception.getType()),\n      \"(remote)\", 0, kj::str(\"remote exception: \", exception.getReason()));\n}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Exception toException(const rpc::Exception::Reader& exception) {\n  return kj::Exception(static_cast<kj::Exception::Type>(exception.getType()),\n      \"(remote)\", 0, kj::str(\"remote exception: \", exception.getReason()));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid handleAbort(const rpc::Exception::Reader& exception) {\n    kj::throwRecoverableException(toException(exception));\n  }"
  },
  {
    "function_name": "handleUnimplemented",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "2021-2050",
    "snippet": "void handleUnimplemented(const rpc::Message::Reader& message) {\n    switch (message.which()) {\n      case rpc::Message::RESOLVE: {\n        auto cap = message.getResolve().getCap();\n        switch (cap.which()) {\n          case rpc::CapDescriptor::NONE:\n            // Nothing to do (but this ought never to happen).\n            break;\n          case rpc::CapDescriptor::SENDER_HOSTED:\n            releaseExport(cap.getSenderHosted(), 1);\n            break;\n          case rpc::CapDescriptor::SENDER_PROMISE:\n            releaseExport(cap.getSenderPromise(), 1);\n            break;\n          case rpc::CapDescriptor::RECEIVER_ANSWER:\n          case rpc::CapDescriptor::RECEIVER_HOSTED:\n            // Nothing to do.\n            break;\n          case rpc::CapDescriptor::THIRD_PARTY_HOSTED:\n            releaseExport(cap.getThirdPartyHosted().getVineId(), 1);\n            break;\n        }\n        break;\n      }\n\n      default:\n        KJ_FAIL_ASSERT(\"Peer did not implement required RPC message type.\", (uint)message.which());\n        break;\n    }\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Peer did not implement required RPC message type.\"",
            "(uint)message.which()"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.which",
          "args": [],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "releaseExport",
          "args": [
            "cap.getThirdPartyHosted().getVineId()",
            "1"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "releaseExport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2479-2493",
          "snippet": "void releaseExport(ExportId id, uint refcount) {\n    KJ_IF_MAYBE(exp, exports.find(id)) {\n      KJ_REQUIRE(refcount <= exp->refcount, \"Tried to drop export's refcount below zero.\") {\n        return;\n      }\n\n      exp->refcount -= refcount;\n      if (exp->refcount == 0) {\n        exportsByCap.erase(exp->clientHook);\n        exports.erase(id, *exp);\n      }\n    } else {\n      KJ_FAIL_REQUIRE(\"Tried to release invalid export ID.\") {\n        return;\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid releaseExport(ExportId id, uint refcount) {\n    KJ_IF_MAYBE(exp, exports.find(id)) {\n      KJ_REQUIRE(refcount <= exp->refcount, \"Tried to drop export's refcount below zero.\") {\n        return;\n      }\n\n      exp->refcount -= refcount;\n      if (exp->refcount == 0) {\n        exportsByCap.erase(exp->clientHook);\n        exports.erase(id, *exp);\n      }\n    } else {\n      KJ_FAIL_REQUIRE(\"Tried to release invalid export ID.\") {\n        return;\n      }"
        }
      },
      {
        "call_info": {
          "callee": "cap.getThirdPartyHosted",
          "args": [],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap.getThirdPartyHosted",
          "args": [],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap.getSenderPromise",
          "args": [],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap.getSenderHosted",
          "args": [],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap.which",
          "args": [],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getResolve",
          "args": [],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getResolve",
          "args": [],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.which",
          "args": [],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid handleUnimplemented(const rpc::Message::Reader& message) {\n    switch (message.which()) {\n      case rpc::Message::RESOLVE: {\n        auto cap = message.getResolve().getCap();\n        switch (cap.which()) {\n          case rpc::CapDescriptor::NONE:\n            // Nothing to do (but this ought never to happen).\n            break;\n          case rpc::CapDescriptor::SENDER_HOSTED:\n            releaseExport(cap.getSenderHosted(), 1);\n            break;\n          case rpc::CapDescriptor::SENDER_PROMISE:\n            releaseExport(cap.getSenderPromise(), 1);\n            break;\n          case rpc::CapDescriptor::RECEIVER_ANSWER:\n          case rpc::CapDescriptor::RECEIVER_HOSTED:\n            // Nothing to do.\n            break;\n          case rpc::CapDescriptor::THIRD_PARTY_HOSTED:\n            releaseExport(cap.getThirdPartyHosted().getVineId(), 1);\n            break;\n        }\n        break;\n      }\n\n      default:\n        KJ_FAIL_ASSERT(\"Peer did not implement required RPC message type.\", (uint)message.which());\n        break;\n    }\n  }"
  },
  {
    "function_name": "handleMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1969-2019",
    "snippet": "void handleMessage(kj::Own<IncomingRpcMessage> message) {\n    auto reader = message->getBody().getAs<rpc::Message>();\n\n    switch (reader.which()) {\n      case rpc::Message::UNIMPLEMENTED:\n        handleUnimplemented(reader.getUnimplemented());\n        break;\n\n      case rpc::Message::ABORT:\n        handleAbort(reader.getAbort());\n        break;\n\n      case rpc::Message::BOOTSTRAP:\n        handleBootstrap(kj::mv(message), reader.getBootstrap());\n        break;\n\n      case rpc::Message::CALL:\n        handleCall(kj::mv(message), reader.getCall());\n        break;\n\n      case rpc::Message::RETURN:\n        handleReturn(kj::mv(message), reader.getReturn());\n        break;\n\n      case rpc::Message::FINISH:\n        handleFinish(reader.getFinish());\n        break;\n\n      case rpc::Message::RESOLVE:\n        handleResolve(reader.getResolve());\n        break;\n\n      case rpc::Message::RELEASE:\n        handleRelease(reader.getRelease());\n        break;\n\n      case rpc::Message::DISEMBARGO:\n        handleDisembargo(reader.getDisembargo());\n        break;\n\n      default: {\n        if (connection.is<Connected>()) {\n          auto message = connection.get<Connected>()->newOutgoingMessage(\n              firstSegmentSize(reader.totalSize(), messageSizeHint<void>()));\n          message->getBody().initAs<rpc::Message>().setUnimplemented(reader);\n          message->send();\n        }\n        break;\n      }\n    }\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "message->send",
          "args": [],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "message->getBody",
          "args": [
            "reader"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message->getBody",
          "args": [],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "getBody",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "106-108",
          "snippet": "AnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nAnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "connection.get<Connected>",
          "args": [
            "firstSegmentSize(reader.totalSize(), messageSizeHint<void>())"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "firstSegmentSize",
          "args": [
            "reader.totalSize()",
            "messageSizeHint<void>()"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "messageSizeHint<void>",
          "args": [],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "messageSizeHint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "40-42",
          "snippet": "inline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\ninline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}"
        }
      },
      {
        "call_info": {
          "callee": "reader.totalSize",
          "args": [],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "totalSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.capnp.h",
          "lines": "558-558",
          "snippet": "inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }"
        }
      },
      {
        "call_info": {
          "callee": "connection.get<Connected>",
          "args": [],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "connection.is<Connected>",
          "args": [],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "handleDisembargo",
          "args": [
            "reader.getDisembargo()"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.getDisembargo",
          "args": [],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handleRelease",
          "args": [
            "reader.getRelease()"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "handleRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2475-2477",
          "snippet": "void handleRelease(const rpc::Release::Reader& release) {\n    releaseExport(release.getId(), release.getReferenceCount());\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid handleRelease(const rpc::Release::Reader& release) {\n    releaseExport(release.getId(), release.getReferenceCount());\n  }"
        }
      },
      {
        "call_info": {
          "callee": "reader.getRelease",
          "args": [],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handleResolve",
          "args": [
            "reader.getResolve()"
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "handleResolve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2433-2444",
          "snippet": "void handleResolve(const rpc::Resolve::Reader& resolve) {\n    kj::Own<ClientHook> replacement;\n    kj::Maybe<kj::Exception> exception;\n\n    // Extract the replacement capability.\n    switch (resolve.which()) {\n      case rpc::Resolve::CAP:\n        KJ_IF_MAYBE(cap, receiveCap(resolve.getCap())) {\n          replacement = kj::mv(*cap);\n        } else {\n          KJ_FAIL_REQUIRE(\"'Resolve' contained 'CapDescriptor.none'.\") { return; }\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid handleResolve(const rpc::Resolve::Reader& resolve) {\n    kj::Own<ClientHook> replacement;\n    kj::Maybe<kj::Exception> exception;\n\n    // Extract the replacement capability.\n    switch (resolve.which()) {\n      case rpc::Resolve::CAP:\n        KJ_IF_MAYBE(cap, receiveCap(resolve.getCap())) {\n          replacement = kj::mv(*cap);\n        } else {\n          KJ_FAIL_REQUIRE(\"'Resolve' contained 'CapDescriptor.none'.\") { return; }\n        }"
        }
      },
      {
        "call_info": {
          "callee": "reader.getResolve",
          "args": [],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handleFinish",
          "args": [
            "reader.getFinish()"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "handleFinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2399-2425",
          "snippet": "void handleFinish(const rpc::Finish::Reader& finish) {\n    // Delay release of these things until return so that transitive destructors don't accidentally\n    // modify the answer table and invalidate our pointer into it.\n    kj::Array<ExportId> exportsToRelease;\n    KJ_DEFER(releaseExports(exportsToRelease));\n    Answer answerToRelease;\n    kj::Maybe<kj::Own<PipelineHook>> pipelineToRelease;\n\n    KJ_IF_MAYBE(answer, answers.find(finish.getQuestionId())) {\n      KJ_REQUIRE(answer->active, \"'Finish' for invalid question ID.\") { return; }\n\n      if (finish.getReleaseResultCaps()) {\n        exportsToRelease = kj::mv(answer->resultExports);\n      } else {\n        answer->resultExports = nullptr;\n      }\n\n      pipelineToRelease = kj::mv(answer->pipeline);\n\n      // If the call isn't actually done yet, cancel it.  Otherwise, we can go ahead and erase the\n      // question from the table.\n      KJ_IF_MAYBE(context, answer->callContext) {\n        context->requestCancel();\n      } else {\n        answerToRelease = answers.erase(finish.getQuestionId());\n      }\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "auto& answer = answers[answerId];",
            "auto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto& answer = answers[answerId];\nauto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));\n\nvoid handleFinish(const rpc::Finish::Reader& finish) {\n    // Delay release of these things until return so that transitive destructors don't accidentally\n    // modify the answer table and invalidate our pointer into it.\n    kj::Array<ExportId> exportsToRelease;\n    KJ_DEFER(releaseExports(exportsToRelease));\n    Answer answerToRelease;\n    kj::Maybe<kj::Own<PipelineHook>> pipelineToRelease;\n\n    KJ_IF_MAYBE(answer, answers.find(finish.getQuestionId())) {\n      KJ_REQUIRE(answer->active, \"'Finish' for invalid question ID.\") { return; }\n\n      if (finish.getReleaseResultCaps()) {\n        exportsToRelease = kj::mv(answer->resultExports);\n      } else {\n        answer->resultExports = nullptr;\n      }\n\n      pipelineToRelease = kj::mv(answer->pipeline);\n\n      // If the call isn't actually done yet, cancel it.  Otherwise, we can go ahead and erase the\n      // question from the table.\n      KJ_IF_MAYBE(context, answer->callContext) {\n        context->requestCancel();\n      } else {\n        answerToRelease = answers.erase(finish.getQuestionId());\n      }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "reader.getFinish",
          "args": [],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handleReturn",
          "args": [
            "kj::mv(message)",
            "reader.getReturn()"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.getReturn",
          "args": [],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "message"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handleCall",
          "args": [
            "kj::mv(message)",
            "reader.getCall()"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "handleCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2142-2150",
          "snippet": "void handleCall(kj::Own<IncomingRpcMessage>&& message, const rpc::Call::Reader& call) {\n    kj::Own<ClientHook> capability;\n\n    KJ_IF_MAYBE(t, getMessageTarget(call.getTarget())) {\n      capability = kj::mv(*t);\n    } else {\n      // Exception already reported.\n      return;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid handleCall(kj::Own<IncomingRpcMessage>&& message, const rpc::Call::Reader& call) {\n    kj::Own<ClientHook> capability;\n\n    KJ_IF_MAYBE(t, getMessageTarget(call.getTarget())) {\n      capability = kj::mv(*t);\n    } else {\n      // Exception already reported.\n      return;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "reader.getCall",
          "args": [],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "getCall",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1325-1327",
          "snippet": "inline rpc::Call::Builder getCall() {\n      return callBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline rpc::Call::Builder getCall() {\n        return callBuilder;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "message"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handleBootstrap",
          "args": [
            "kj::mv(message)",
            "reader.getBootstrap()"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.getBootstrap",
          "args": [],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "message"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handleAbort",
          "args": [
            "reader.getAbort()"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "handleAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2052-2054",
          "snippet": "void handleAbort(const rpc::Exception::Reader& exception) {\n    kj::throwRecoverableException(toException(exception));\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid handleAbort(const rpc::Exception::Reader& exception) {\n    kj::throwRecoverableException(toException(exception));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "reader.getAbort",
          "args": [],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handleUnimplemented",
          "args": [
            "reader.getUnimplemented()"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "handleUnimplemented",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2021-2050",
          "snippet": "void handleUnimplemented(const rpc::Message::Reader& message) {\n    switch (message.which()) {\n      case rpc::Message::RESOLVE: {\n        auto cap = message.getResolve().getCap();\n        switch (cap.which()) {\n          case rpc::CapDescriptor::NONE:\n            // Nothing to do (but this ought never to happen).\n            break;\n          case rpc::CapDescriptor::SENDER_HOSTED:\n            releaseExport(cap.getSenderHosted(), 1);\n            break;\n          case rpc::CapDescriptor::SENDER_PROMISE:\n            releaseExport(cap.getSenderPromise(), 1);\n            break;\n          case rpc::CapDescriptor::RECEIVER_ANSWER:\n          case rpc::CapDescriptor::RECEIVER_HOSTED:\n            // Nothing to do.\n            break;\n          case rpc::CapDescriptor::THIRD_PARTY_HOSTED:\n            releaseExport(cap.getThirdPartyHosted().getVineId(), 1);\n            break;\n        }\n        break;\n      }\n\n      default:\n        KJ_FAIL_ASSERT(\"Peer did not implement required RPC message type.\", (uint)message.which());\n        break;\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid handleUnimplemented(const rpc::Message::Reader& message) {\n    switch (message.which()) {\n      case rpc::Message::RESOLVE: {\n        auto cap = message.getResolve().getCap();\n        switch (cap.which()) {\n          case rpc::CapDescriptor::NONE:\n            // Nothing to do (but this ought never to happen).\n            break;\n          case rpc::CapDescriptor::SENDER_HOSTED:\n            releaseExport(cap.getSenderHosted(), 1);\n            break;\n          case rpc::CapDescriptor::SENDER_PROMISE:\n            releaseExport(cap.getSenderPromise(), 1);\n            break;\n          case rpc::CapDescriptor::RECEIVER_ANSWER:\n          case rpc::CapDescriptor::RECEIVER_HOSTED:\n            // Nothing to do.\n            break;\n          case rpc::CapDescriptor::THIRD_PARTY_HOSTED:\n            releaseExport(cap.getThirdPartyHosted().getVineId(), 1);\n            break;\n        }\n        break;\n      }\n\n      default:\n        KJ_FAIL_ASSERT(\"Peer did not implement required RPC message type.\", (uint)message.which());\n        break;\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "reader.getUnimplemented",
          "args": [],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.which",
          "args": [],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid handleMessage(kj::Own<IncomingRpcMessage> message) {\n    auto reader = message->getBody().getAs<rpc::Message>();\n\n    switch (reader.which()) {\n      case rpc::Message::UNIMPLEMENTED:\n        handleUnimplemented(reader.getUnimplemented());\n        break;\n\n      case rpc::Message::ABORT:\n        handleAbort(reader.getAbort());\n        break;\n\n      case rpc::Message::BOOTSTRAP:\n        handleBootstrap(kj::mv(message), reader.getBootstrap());\n        break;\n\n      case rpc::Message::CALL:\n        handleCall(kj::mv(message), reader.getCall());\n        break;\n\n      case rpc::Message::RETURN:\n        handleReturn(kj::mv(message), reader.getReturn());\n        break;\n\n      case rpc::Message::FINISH:\n        handleFinish(reader.getFinish());\n        break;\n\n      case rpc::Message::RESOLVE:\n        handleResolve(reader.getResolve());\n        break;\n\n      case rpc::Message::RELEASE:\n        handleRelease(reader.getRelease());\n        break;\n\n      case rpc::Message::DISEMBARGO:\n        handleDisembargo(reader.getDisembargo());\n        break;\n\n      default: {\n        if (connection.is<Connected>()) {\n          auto message = connection.get<Connected>()->newOutgoingMessage(\n              firstSegmentSize(reader.totalSize(), messageSizeHint<void>()));\n          message->getBody().initAs<rpc::Message>().setUnimplemented(reader);\n          message->send();\n        }\n        break;\n      }\n    }\n  }"
  },
  {
    "function_name": "messageLoop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1946-1967",
    "snippet": "kj::Promise<void> messageLoop() {\n    if (!connection.is<Connected>()) {\n      return kj::READY_NOW;\n    }\n\n    return connection.get<Connected>()->receiveIncomingMessage().then(\n        [this](kj::Maybe<kj::Own<IncomingRpcMessage>>&& message) {\n      KJ_IF_MAYBE(m, message) {\n        handleMessage(kj::mv(*m));\n        return true;\n      } else {\n        disconnect(KJ_EXCEPTION(DISCONNECTED, \"Peer disconnected.\"));\n        return false;\n      }\n    }).then([this](bool keepGoing) {\n      // No exceptions; continue loop.\n      //\n      // (We do this in a separate continuation to handle the case where exceptions are\n      // disabled.)\n      if (keepGoing) tasks.add(messageLoop());\n    });\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "connection.get<Connected>",
          "args": [
            "[this](bool keepGoing) {\n      // No exceptions; continue loop.\n      //\n      // (We do this in a separate continuation to handle the case where exceptions are\n      // disabled.)\n      if (keepGoing) tasks.add(messageLoop());\n    }"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "messageLoop()"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "messageLoop",
          "args": [],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disconnect",
          "args": [
            "KJ_EXCEPTION(DISCONNECTED, \"Peer disconnected.\")"
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "disconnect",
          "container": "TestNetworkAdapter::ConnectionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "226-235",
          "snippet": "void disconnect(kj::Exception&& exception) {\n      while (!fulfillers.empty()) {\n        fulfillers.front()->reject(kj::cp(exception));\n        fulfillers.pop();\n      }\n\n      networkException = kj::mv(exception);\n\n      tasks = nullptr;\n    }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    void disconnect(kj::Exception&& exception) {\n          while (!fulfillers.empty()) {\n            fulfillers.front()->reject(kj::cp(exception));\n            fulfillers.pop();\n          }\n    \n          networkException = kj::mv(exception);\n    \n          tasks = nullptr;\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_EXCEPTION",
          "args": [
            "DISCONNECTED",
            "\"Peer disconnected.\""
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handleMessage",
          "args": [
            "kj::mv(*m)"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "handleMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1969-2019",
          "snippet": "void handleMessage(kj::Own<IncomingRpcMessage> message) {\n    auto reader = message->getBody().getAs<rpc::Message>();\n\n    switch (reader.which()) {\n      case rpc::Message::UNIMPLEMENTED:\n        handleUnimplemented(reader.getUnimplemented());\n        break;\n\n      case rpc::Message::ABORT:\n        handleAbort(reader.getAbort());\n        break;\n\n      case rpc::Message::BOOTSTRAP:\n        handleBootstrap(kj::mv(message), reader.getBootstrap());\n        break;\n\n      case rpc::Message::CALL:\n        handleCall(kj::mv(message), reader.getCall());\n        break;\n\n      case rpc::Message::RETURN:\n        handleReturn(kj::mv(message), reader.getReturn());\n        break;\n\n      case rpc::Message::FINISH:\n        handleFinish(reader.getFinish());\n        break;\n\n      case rpc::Message::RESOLVE:\n        handleResolve(reader.getResolve());\n        break;\n\n      case rpc::Message::RELEASE:\n        handleRelease(reader.getRelease());\n        break;\n\n      case rpc::Message::DISEMBARGO:\n        handleDisembargo(reader.getDisembargo());\n        break;\n\n      default: {\n        if (connection.is<Connected>()) {\n          auto message = connection.get<Connected>()->newOutgoingMessage(\n              firstSegmentSize(reader.totalSize(), messageSizeHint<void>()));\n          message->getBody().initAs<rpc::Message>().setUnimplemented(reader);\n          message->send();\n        }\n        break;\n      }\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid handleMessage(kj::Own<IncomingRpcMessage> message) {\n    auto reader = message->getBody().getAs<rpc::Message>();\n\n    switch (reader.which()) {\n      case rpc::Message::UNIMPLEMENTED:\n        handleUnimplemented(reader.getUnimplemented());\n        break;\n\n      case rpc::Message::ABORT:\n        handleAbort(reader.getAbort());\n        break;\n\n      case rpc::Message::BOOTSTRAP:\n        handleBootstrap(kj::mv(message), reader.getBootstrap());\n        break;\n\n      case rpc::Message::CALL:\n        handleCall(kj::mv(message), reader.getCall());\n        break;\n\n      case rpc::Message::RETURN:\n        handleReturn(kj::mv(message), reader.getReturn());\n        break;\n\n      case rpc::Message::FINISH:\n        handleFinish(reader.getFinish());\n        break;\n\n      case rpc::Message::RESOLVE:\n        handleResolve(reader.getResolve());\n        break;\n\n      case rpc::Message::RELEASE:\n        handleRelease(reader.getRelease());\n        break;\n\n      case rpc::Message::DISEMBARGO:\n        handleDisembargo(reader.getDisembargo());\n        break;\n\n      default: {\n        if (connection.is<Connected>()) {\n          auto message = connection.get<Connected>()->newOutgoingMessage(\n              firstSegmentSize(reader.totalSize(), messageSizeHint<void>()));\n          message->getBody().initAs<rpc::Message>().setUnimplemented(reader);\n          message->send();\n        }\n        break;\n      }\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*m"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connection.get<Connected>",
          "args": [],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "connection.is<Connected>",
          "args": [],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Promise<void> messageLoop() {\n    if (!connection.is<Connected>()) {\n      return kj::READY_NOW;\n    }\n\n    return connection.get<Connected>()->receiveIncomingMessage().then(\n        [this](kj::Maybe<kj::Own<IncomingRpcMessage>>&& message) {\n      KJ_IF_MAYBE(m, message) {\n        handleMessage(kj::mv(*m));\n        return true;\n      } else {\n        disconnect(KJ_EXCEPTION(DISCONNECTED, \"Peer disconnected.\"));\n        return false;\n      }\n    }).then([this](bool keepGoing) {\n      // No exceptions; continue loop.\n      //\n      // (We do this in a separate continuation to handle the case where exceptions are\n      // disabled.)\n      if (keepGoing) tasks.add(messageLoop());\n    });\n  }"
  },
  {
    "function_name": "cleanupAnswerTable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1917-1940",
    "snippet": "void cleanupAnswerTable(kj::Array<ExportId> resultExports, bool shouldFreePipeline) {\n      // We need to remove the `callContext` pointer -- which points back to us -- from the\n      // answer table.  Or we might even be responsible for removing the entire answer table\n      // entry.\n\n      if (cancellationFlags & CANCEL_REQUESTED) {\n        // Already received `Finish` so it's our job to erase the table entry. We shouldn't have\n        // sent results if canceled, so we shouldn't have an export list to deal with.\n        KJ_ASSERT(resultExports.size() == 0);\n        connectionState->answers.erase(answerId);\n      } else {\n        // We just have to null out callContext and set the exports.\n        auto& answer = connectionState->answers[answerId];\n        answer.callContext = nullptr;\n        answer.resultExports = kj::mv(resultExports);\n\n        if (shouldFreePipeline) {\n          // We can free the pipeline early, because we know all pipeline calls are invalid (e.g.\n          // because there are no caps in the result to receive pipeline requests).\n          KJ_ASSERT(resultExports.size() == 0);\n          answer.pipeline = nullptr;\n        }\n      }\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "auto results = response->getResultsBuilder();",
      "AnswerId answerId;",
      "uint8_t cancellationFlags = 0;",
      "auto& answer = answers[answerId];",
      "AnswerId answerId = call.getQuestionId();"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "resultExports.size() == 0"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resultExports.size",
          "args": [],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "resultExports"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectionState->answers.erase",
          "args": [
            "answerId"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "204-216",
          "snippet": "T erase(Id id) {\n    // Remove an entry from the table and return it.  We return it so that the caller can be\n    // careful to release it (possibly invoking arbitrary destructors) at a time that makes sense.\n    if (id < kj::size(low)) {\n      T toRelease = kj::mv(low[id]);\n      low[id] = T();\n      return toRelease;\n    } else {\n      T toRelease = kj::mv(high[id]);\n      high.erase(id);\n      return toRelease;\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  T erase(Id id) {\n      // Remove an entry from the table and return it.  We return it so that the caller can be\n      // careful to release it (possibly invoking arbitrary destructors) at a time that makes sense.\n      if (id < kj::size(low)) {\n        T toRelease = kj::mv(low[id]);\n        low[id] = T();\n        return toRelease;\n      } else {\n        T toRelease = kj::mv(high[id]);\n        high.erase(id);\n        return toRelease;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "resultExports.size() == 0"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto results = response->getResultsBuilder();\nAnswerId answerId;\nuint8_t cancellationFlags = 0;\nauto& answer = answers[answerId];\nAnswerId answerId = call.getQuestionId();\n\nvoid cleanupAnswerTable(kj::Array<ExportId> resultExports, bool shouldFreePipeline) {\n      // We need to remove the `callContext` pointer -- which points back to us -- from the\n      // answer table.  Or we might even be responsible for removing the entire answer table\n      // entry.\n\n      if (cancellationFlags & CANCEL_REQUESTED) {\n        // Already received `Finish` so it's our job to erase the table entry. We shouldn't have\n        // sent results if canceled, so we shouldn't have an export list to deal with.\n        KJ_ASSERT(resultExports.size() == 0);\n        connectionState->answers.erase(answerId);\n      } else {\n        // We just have to null out callContext and set the exports.\n        auto& answer = connectionState->answers[answerId];\n        answer.callContext = nullptr;\n        answer.resultExports = kj::mv(resultExports);\n\n        if (shouldFreePipeline) {\n          // We can free the pipeline early, because we know all pipeline calls are invalid (e.g.\n          // because there are no caps in the result to receive pipeline requests).\n          KJ_ASSERT(resultExports.size() == 0);\n          answer.pipeline = nullptr;\n        }\n      }\n    }"
  },
  {
    "function_name": "isFirstResponder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1908-1915",
    "snippet": "bool isFirstResponder() {\n      if (responseSent) {\n        return false;\n      } else {\n        responseSent = true;\n        return true;\n      }\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool responseSent = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nbool responseSent = false;\n\nbool isFirstResponder() {\n      if (responseSent) {\n        return false;\n      } else {\n        responseSent = true;\n        return true;\n      }\n    }"
  },
  {
    "function_name": "addRef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1868-1870",
    "snippet": "kj::Own<CallContextHook> addRef() override {\n      return kj::addRef(*this);\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Own<CallContextHook> addRef() override {\n      return kj::addRef(*this);\n    }"
  },
  {
    "function_name": "allowCancellation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1858-1867",
    "snippet": "void allowCancellation() override {\n      bool previouslyRequestedButNotAllowed = cancellationFlags == CANCEL_REQUESTED;\n      cancellationFlags |= CANCEL_ALLOWED;\n\n      if (previouslyRequestedButNotAllowed) {\n        // We just set CANCEL_ALLOWED, and CANCEL_REQUESTED was already set previously.  Initiate\n        // the cancellation.\n        cancelFulfiller->fulfill();\n      }\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "uint8_t cancellationFlags = 0;",
      "kj::Own<kj::PromiseFulfiller<void>> cancelFulfiller;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cancelFulfiller->fulfill",
          "args": [],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "fulfill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "68-72",
          "snippet": "void fulfill() {\n    fulfiller.fulfill();\n    port.timers->timers.erase(pos);\n    pos = port.timers->timers.end();\n  }",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid fulfill() {\n    fulfiller.fulfill();\n    port.timers->timers.erase(pos);\n    pos = port.timers->timers.end();\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nuint8_t cancellationFlags = 0;\nkj::Own<kj::PromiseFulfiller<void>> cancelFulfiller;\n\nvoid allowCancellation() override {\n      bool previouslyRequestedButNotAllowed = cancellationFlags == CANCEL_REQUESTED;\n      cancellationFlags |= CANCEL_ALLOWED;\n\n      if (previouslyRequestedButNotAllowed) {\n        // We just set CANCEL_ALLOWED, and CANCEL_REQUESTED was already set previously.  Initiate\n        // the cancellation.\n        cancelFulfiller->fulfill();\n      }\n    }"
  },
  {
    "function_name": "onTailCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1853-1857",
    "snippet": "kj::Promise<AnyPointer::Pipeline> onTailCall() override {\n      auto paf = kj::newPromiseAndFulfiller<AnyPointer::Pipeline>();\n      tailCallPipelineFulfiller = kj::mv(paf.fulfiller);\n      return kj::mv(paf.promise);\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<kj::PromiseFulfiller<AnyPointer::Pipeline>>> tailCallPipelineFulfiller;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.promise"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<AnyPointer::Pipeline>",
          "args": [],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<kj::PromiseFulfiller<AnyPointer::Pipeline>>> tailCallPipelineFulfiller;\n\nkj::Promise<AnyPointer::Pipeline> onTailCall() override {\n      auto paf = kj::newPromiseAndFulfiller<AnyPointer::Pipeline>();\n      tailCallPipelineFulfiller = kj::mv(paf.fulfiller);\n      return kj::mv(paf.promise);\n    }"
  },
  {
    "function_name": "directTailCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1810-1852",
    "snippet": "ClientHook::VoidPromiseAndPipeline directTailCall(kj::Own<RequestHook>&& request) override {\n      KJ_REQUIRE(response == nullptr,\n                 \"Can't call tailCall() after initializing the results struct.\");\n\n      if (request->getBrand() == connectionState.get() && !redirectResults) {\n        // The tail call is headed towards the peer that called us in the first place, so we can\n        // optimize out the return trip.\n\n        KJ_IF_MAYBE(tailInfo, kj::downcast<RpcRequest>(*request).tailSend()) {\n          if (isFirstResponder()) {\n            if (connectionState->connection.is<Connected>()) {\n              auto message = connectionState->connection.get<Connected>()->newOutgoingMessage(\n                  messageSizeHint<rpc::Return>());\n              auto builder = message->getBody().initAs<rpc::Message>().initReturn();\n\n              builder.setAnswerId(answerId);\n              builder.setReleaseParamCaps(false);\n              builder.setTakeFromOtherQuestion(tailInfo->questionId);\n\n              message->send();\n            }\n\n            // There are no caps in our return message, but of course the tail results could have\n            // caps, so we must continue to honor pipeline calls (and just bounce them back).\n            cleanupAnswerTable(nullptr, false);\n          }\n          return { kj::mv(tailInfo->promise), kj::mv(tailInfo->pipeline) };\n        }\n      }\n\n      // Just forwarding to another local call.\n      auto promise = request->send();\n\n      // Wait for response.\n      auto voidPromise = promise.then([this](Response<AnyPointer>&& tailResponse) {\n        // Copy the response.\n        // TODO(perf):  It would be nice if we could somehow make the response get built in-place\n        //   but requires some refactoring.\n        getResults(tailResponse.targetSize()).set(tailResponse);\n      });\n\n      return { kj::mv(voidPromise), PipelineHook::from(kj::mv(promise)) };\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "auto results = response->getResultsBuilder();",
      "AnswerId answerId;",
      "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
      "kj::Maybe<kj::Own<RpcServerResponse>> response;",
      "bool redirectResults = false;",
      "bool redirectResults;",
      "AnswerId answerId = call.getQuestionId();"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PipelineHook::from",
          "args": [
            "kj::mv(promise)"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "PipelineHook::from",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "909-911",
          "snippet": "inline kj::Own<PipelineHook> PipelineHook::from(Pipeline&& pipeline) {\n  return FromImpl<T>::apply(kj::fwd<Pipeline>(pipeline));\n}",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline kj::Own<PipelineHook> PipelineHook::from(Pipeline&& pipeline) {\n  return FromImpl<T>::apply(kj::fwd<Pipeline>(pipeline));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promise"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "voidPromise"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "[this](Response<AnyPointer>&& tailResponse) {\n        // Copy the response.\n        // TODO(perf):  It would be nice if we could somehow make the response get built in-place\n        //   but requires some refactoring.\n        getResults(tailResponse.targetSize()).set(tailResponse);\n      }"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getResults",
          "args": [
            "tailResponse"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "154-161",
          "snippet": "AnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<Response<AnyPointer>> response;",
            "AnyPointer::Builder responseBuilder = nullptr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<Response<AnyPointer>> response;\nAnyPointer::Builder responseBuilder = nullptr;\n\nAnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "tailResponse.targetSize",
          "args": [],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request->send",
          "args": [],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "tailInfo->pipeline"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "tailInfo->promise"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleanupAnswerTable",
          "args": [
            "nullptr",
            "false"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "cleanupAnswerTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1917-1940",
          "snippet": "void cleanupAnswerTable(kj::Array<ExportId> resultExports, bool shouldFreePipeline) {\n      // We need to remove the `callContext` pointer -- which points back to us -- from the\n      // answer table.  Or we might even be responsible for removing the entire answer table\n      // entry.\n\n      if (cancellationFlags & CANCEL_REQUESTED) {\n        // Already received `Finish` so it's our job to erase the table entry. We shouldn't have\n        // sent results if canceled, so we shouldn't have an export list to deal with.\n        KJ_ASSERT(resultExports.size() == 0);\n        connectionState->answers.erase(answerId);\n      } else {\n        // We just have to null out callContext and set the exports.\n        auto& answer = connectionState->answers[answerId];\n        answer.callContext = nullptr;\n        answer.resultExports = kj::mv(resultExports);\n\n        if (shouldFreePipeline) {\n          // We can free the pipeline early, because we know all pipeline calls are invalid (e.g.\n          // because there are no caps in the result to receive pipeline requests).\n          KJ_ASSERT(resultExports.size() == 0);\n          answer.pipeline = nullptr;\n        }\n      }\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "auto results = response->getResultsBuilder();",
            "AnswerId answerId;",
            "uint8_t cancellationFlags = 0;",
            "auto& answer = answers[answerId];",
            "AnswerId answerId = call.getQuestionId();"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto results = response->getResultsBuilder();\nAnswerId answerId;\nuint8_t cancellationFlags = 0;\nauto& answer = answers[answerId];\nAnswerId answerId = call.getQuestionId();\n\nvoid cleanupAnswerTable(kj::Array<ExportId> resultExports, bool shouldFreePipeline) {\n      // We need to remove the `callContext` pointer -- which points back to us -- from the\n      // answer table.  Or we might even be responsible for removing the entire answer table\n      // entry.\n\n      if (cancellationFlags & CANCEL_REQUESTED) {\n        // Already received `Finish` so it's our job to erase the table entry. We shouldn't have\n        // sent results if canceled, so we shouldn't have an export list to deal with.\n        KJ_ASSERT(resultExports.size() == 0);\n        connectionState->answers.erase(answerId);\n      } else {\n        // We just have to null out callContext and set the exports.\n        auto& answer = connectionState->answers[answerId];\n        answer.callContext = nullptr;\n        answer.resultExports = kj::mv(resultExports);\n\n        if (shouldFreePipeline) {\n          // We can free the pipeline early, because we know all pipeline calls are invalid (e.g.\n          // because there are no caps in the result to receive pipeline requests).\n          KJ_ASSERT(resultExports.size() == 0);\n          answer.pipeline = nullptr;\n        }\n      }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "builder.setTakeFromOtherQuestion",
          "args": [
            "tailInfo->questionId"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setReleaseParamCaps",
          "args": [
            "false"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setAnswerId",
          "args": [
            "answerId"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message->getBody",
          "args": [],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "getBody",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "106-108",
          "snippet": "AnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nAnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "connectionState->connection.get<Connected>",
          "args": [
            "messageSizeHint<rpc::Return>()"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "messageSizeHint<rpc::Return>",
          "args": [],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "messageSizeHint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "40-42",
          "snippet": "inline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\ninline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}"
        }
      },
      {
        "call_info": {
          "callee": "connectionState->connection.get<Connected>",
          "args": [],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "connectionState->connection.is<Connected>",
          "args": [],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isFirstResponder",
          "args": [],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "isFirstResponder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1908-1915",
          "snippet": "bool isFirstResponder() {\n      if (responseSent) {\n        return false;\n      } else {\n        responseSent = true;\n        return true;\n      }\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool responseSent = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nbool responseSent = false;\n\nbool isFirstResponder() {\n      if (responseSent) {\n        return false;\n      } else {\n        responseSent = true;\n        return true;\n      }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "tailInfo",
            "kj::downcast<RpcRequest>(*request).tailSend()"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "kj::downcast<RpcRequest>",
          "args": [],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "downcast",
          "container": "Own",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "154-166",
          "snippet": "Own<U> downcast() {\n    // Downcast the pointer to Own<U>, destroying the original pointer.  If this pointer does not\n    // actually point at an instance of U, the results are undefined (throws an exception in debug\n    // mode if RTTI is enabled, otherwise you're on your own).\n\n    Own<U> result;\n    if (ptr != nullptr) {\n      result.ptr = &kj::downcast<U>(*ptr);\n      result.disposer = disposer;\n      ptr = nullptr;\n    }\n    return result;\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  Own<U> downcast() {\n      // Downcast the pointer to Own<U>, destroying the original pointer.  If this pointer does not\n      // actually point at an instance of U, the results are undefined (throws an exception in debug\n      // mode if RTTI is enabled, otherwise you're on your own).\n  \n      Own<U> result;\n      if (ptr != nullptr) {\n        result.ptr = &kj::downcast<U>(*ptr);\n        result.disposer = disposer;\n        ptr = nullptr;\n      }\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::downcast<RpcRequest>",
          "args": [
            "*request"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request->getBrand",
          "args": [],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "response == nullptr",
            "\"Can't call tailCall() after initializing the results struct.\""
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto results = response->getResultsBuilder();\nAnswerId answerId;\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nkj::Maybe<kj::Own<RpcServerResponse>> response;\nbool redirectResults = false;\nbool redirectResults;\nAnswerId answerId = call.getQuestionId();\n\nClientHook::VoidPromiseAndPipeline directTailCall(kj::Own<RequestHook>&& request) override {\n      KJ_REQUIRE(response == nullptr,\n                 \"Can't call tailCall() after initializing the results struct.\");\n\n      if (request->getBrand() == connectionState.get() && !redirectResults) {\n        // The tail call is headed towards the peer that called us in the first place, so we can\n        // optimize out the return trip.\n\n        KJ_IF_MAYBE(tailInfo, kj::downcast<RpcRequest>(*request).tailSend()) {\n          if (isFirstResponder()) {\n            if (connectionState->connection.is<Connected>()) {\n              auto message = connectionState->connection.get<Connected>()->newOutgoingMessage(\n                  messageSizeHint<rpc::Return>());\n              auto builder = message->getBody().initAs<rpc::Message>().initReturn();\n\n              builder.setAnswerId(answerId);\n              builder.setReleaseParamCaps(false);\n              builder.setTakeFromOtherQuestion(tailInfo->questionId);\n\n              message->send();\n            }\n\n            // There are no caps in our return message, but of course the tail results could have\n            // caps, so we must continue to honor pipeline calls (and just bounce them back).\n            cleanupAnswerTable(nullptr, false);\n          }\n          return { kj::mv(tailInfo->promise), kj::mv(tailInfo->pipeline) };\n        }\n      }\n\n      // Just forwarding to another local call.\n      auto promise = request->send();\n\n      // Wait for response.\n      auto voidPromise = promise.then([this](Response<AnyPointer>&& tailResponse) {\n        // Copy the response.\n        // TODO(perf):  It would be nice if we could somehow make the response get built in-place\n        //   but requires some refactoring.\n        getResults(tailResponse.targetSize()).set(tailResponse);\n      });\n\n      return { kj::mv(voidPromise), PipelineHook::from(kj::mv(promise)) };\n    }"
  },
  {
    "function_name": "tailCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1803-1809",
    "snippet": "kj::Promise<void> tailCall(kj::Own<RequestHook>&& request) override {\n      auto result = directTailCall(kj::mv(request));\n      KJ_IF_MAYBE(f, tailCallPipelineFulfiller) {\n        f->get()->fulfill(AnyPointer::Pipeline(kj::mv(result.pipeline)));\n      }\n      return kj::mv(result.promise);\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
      "kj::Maybe<kj::Own<kj::PromiseFulfiller<AnyPointer::Pipeline>>> tailCallPipelineFulfiller;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result.promise"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f->get",
          "args": [
            "AnyPointer::Pipeline(kj::mv(result.pipeline))"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "AnyPointer::Pipeline",
          "args": [
            "kj::mv(result.pipeline)"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "Pipeline",
          "container": "AnyPointer::Pipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "243-243",
          "snippet": "inline explicit Pipeline(kj::Own<PipelineHook>&& hook): hook(kj::mv(hook)) {}",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Pipeline {\n    inline explicit Pipeline(kj::Own<PipelineHook>&& hook): hook(kj::mv(hook)) {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result.pipeline"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f->get",
          "args": [],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "directTailCall",
          "args": [
            "kj::mv(request)"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "request"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nkj::Maybe<kj::Own<kj::PromiseFulfiller<AnyPointer::Pipeline>>> tailCallPipelineFulfiller;\n\nkj::Promise<void> tailCall(kj::Own<RequestHook>&& request) override {\n      auto result = directTailCall(kj::mv(request));\n      KJ_IF_MAYBE(f, tailCallPipelineFulfiller) {\n        f->get()->fulfill(AnyPointer::Pipeline(kj::mv(result.pipeline)));\n      }\n      return kj::mv(result.promise);\n    }"
  },
  {
    "function_name": "sendReturn",
    "container": "RpcCallContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1708-1732",
    "snippet": "void sendReturn() {\n      KJ_ASSERT(!redirectResults);\n\n      // Avoid sending results if canceled so that we don't have to figure out whether or not\n      // `releaseResultCaps` was set in the already-received `Finish`.\n      if (!(cancellationFlags & CANCEL_REQUESTED) && isFirstResponder()) {\n        KJ_ASSERT(connectionState->connection.is<Connected>(),\n                  \"Cancellation should have been requested on disconnect.\") {\n          return;\n        }\n\n        if (response == nullptr) getResults(MessageSize{0, 0});  // force initialization of response\n\n        returnMessage.setAnswerId(answerId);\n        returnMessage.setReleaseParamCaps(false);\n\n        auto exports = kj::downcast<RpcServerResponseImpl>(*KJ_ASSERT_NONNULL(response)).send();\n        KJ_IF_MAYBE(e, exports) {\n          // Caps were returned, so we can't free the pipeline yet.\n          cleanupAnswerTable(kj::mv(*e), false);\n        } else {\n          // No caps in the results, therefore the pipeline is irrelevant.\n          cleanupAnswerTable(nullptr, true);\n        }\n      }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "auto results = response->getResultsBuilder();",
      "AnswerId answerId;",
      "kj::Maybe<kj::Own<RpcServerResponse>> response;",
      "rpc::Return::Builder returnMessage;",
      "bool redirectResults = false;",
      "uint8_t cancellationFlags = 0;",
      "bool redirectResults;",
      "AnswerId answerId = call.getQuestionId();"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanupAnswerTable",
          "args": [
            "nullptr",
            "true"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "cleanupAnswerTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1917-1940",
          "snippet": "void cleanupAnswerTable(kj::Array<ExportId> resultExports, bool shouldFreePipeline) {\n      // We need to remove the `callContext` pointer -- which points back to us -- from the\n      // answer table.  Or we might even be responsible for removing the entire answer table\n      // entry.\n\n      if (cancellationFlags & CANCEL_REQUESTED) {\n        // Already received `Finish` so it's our job to erase the table entry. We shouldn't have\n        // sent results if canceled, so we shouldn't have an export list to deal with.\n        KJ_ASSERT(resultExports.size() == 0);\n        connectionState->answers.erase(answerId);\n      } else {\n        // We just have to null out callContext and set the exports.\n        auto& answer = connectionState->answers[answerId];\n        answer.callContext = nullptr;\n        answer.resultExports = kj::mv(resultExports);\n\n        if (shouldFreePipeline) {\n          // We can free the pipeline early, because we know all pipeline calls are invalid (e.g.\n          // because there are no caps in the result to receive pipeline requests).\n          KJ_ASSERT(resultExports.size() == 0);\n          answer.pipeline = nullptr;\n        }\n      }\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "auto results = response->getResultsBuilder();",
            "AnswerId answerId;",
            "uint8_t cancellationFlags = 0;",
            "auto& answer = answers[answerId];",
            "AnswerId answerId = call.getQuestionId();"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto results = response->getResultsBuilder();\nAnswerId answerId;\nuint8_t cancellationFlags = 0;\nauto& answer = answers[answerId];\nAnswerId answerId = call.getQuestionId();\n\nvoid cleanupAnswerTable(kj::Array<ExportId> resultExports, bool shouldFreePipeline) {\n      // We need to remove the `callContext` pointer -- which points back to us -- from the\n      // answer table.  Or we might even be responsible for removing the entire answer table\n      // entry.\n\n      if (cancellationFlags & CANCEL_REQUESTED) {\n        // Already received `Finish` so it's our job to erase the table entry. We shouldn't have\n        // sent results if canceled, so we shouldn't have an export list to deal with.\n        KJ_ASSERT(resultExports.size() == 0);\n        connectionState->answers.erase(answerId);\n      } else {\n        // We just have to null out callContext and set the exports.\n        auto& answer = connectionState->answers[answerId];\n        answer.callContext = nullptr;\n        answer.resultExports = kj::mv(resultExports);\n\n        if (shouldFreePipeline) {\n          // We can free the pipeline early, because we know all pipeline calls are invalid (e.g.\n          // because there are no caps in the result to receive pipeline requests).\n          KJ_ASSERT(resultExports.size() == 0);\n          answer.pipeline = nullptr;\n        }\n      }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*e"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::downcast<RpcServerResponseImpl>",
          "args": [],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "downcast",
          "container": "Own",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "154-166",
          "snippet": "Own<U> downcast() {\n    // Downcast the pointer to Own<U>, destroying the original pointer.  If this pointer does not\n    // actually point at an instance of U, the results are undefined (throws an exception in debug\n    // mode if RTTI is enabled, otherwise you're on your own).\n\n    Own<U> result;\n    if (ptr != nullptr) {\n      result.ptr = &kj::downcast<U>(*ptr);\n      result.disposer = disposer;\n      ptr = nullptr;\n    }\n    return result;\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  Own<U> downcast() {\n      // Downcast the pointer to Own<U>, destroying the original pointer.  If this pointer does not\n      // actually point at an instance of U, the results are undefined (throws an exception in debug\n      // mode if RTTI is enabled, otherwise you're on your own).\n  \n      Own<U> result;\n      if (ptr != nullptr) {\n        result.ptr = &kj::downcast<U>(*ptr);\n        result.disposer = disposer;\n        ptr = nullptr;\n      }\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::downcast<RpcServerResponseImpl>",
          "args": [
            "*KJ_ASSERT_NONNULL(response)"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "response"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "returnMessage.setReleaseParamCaps",
          "args": [
            "false"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "returnMessage.setAnswerId",
          "args": [
            "answerId"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getResults",
          "args": [
            "MessageSize{0, 0}"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "154-161",
          "snippet": "AnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<Response<AnyPointer>> response;",
            "AnyPointer::Builder responseBuilder = nullptr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<Response<AnyPointer>> response;\nAnyPointer::Builder responseBuilder = nullptr;\n\nAnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "connectionState->connection.is<Connected>()",
            "\"Cancellation should have been requested on disconnect.\""
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectionState->connection.is<Connected>",
          "args": [],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isFirstResponder",
          "args": [],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "isFirstResponder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1908-1915",
          "snippet": "bool isFirstResponder() {\n      if (responseSent) {\n        return false;\n      } else {\n        responseSent = true;\n        return true;\n      }\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool responseSent = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nbool responseSent = false;\n\nbool isFirstResponder() {\n      if (responseSent) {\n        return false;\n      } else {\n        responseSent = true;\n        return true;\n      }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "!redirectResults"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto results = response->getResultsBuilder();\nAnswerId answerId;\nkj::Maybe<kj::Own<RpcServerResponse>> response;\nrpc::Return::Builder returnMessage;\nbool redirectResults = false;\nuint8_t cancellationFlags = 0;\nbool redirectResults;\nAnswerId answerId = call.getQuestionId();\n\nRpcCallContext {\n  void sendReturn() {\n        KJ_ASSERT(!redirectResults);\n  \n        // Avoid sending results if canceled so that we don't have to figure out whether or not\n        // `releaseResultCaps` was set in the already-received `Finish`.\n        if (!(cancellationFlags & CANCEL_REQUESTED) && isFirstResponder()) {\n          KJ_ASSERT(connectionState->connection.is<Connected>(),\n                    \"Cancellation should have been requested on disconnect.\") {\n            return;\n          }\n  \n          if (response == nullptr) getResults(MessageSize{0, 0});  // force initialization of response\n  \n          returnMessage.setAnswerId(answerId);\n          returnMessage.setReleaseParamCaps(false);\n  \n          auto exports = kj::downcast<RpcServerResponseImpl>(*KJ_ASSERT_NONNULL(response)).send();\n          KJ_IF_MAYBE(e, exports) {\n            // Caps were returned, so we can't free the pipeline yet.\n            cleanupAnswerTable(kj::mv(*e), false);\n          } else {\n            // No caps in the results, therefore the pipeline is irrelevant.\n            cleanupAnswerTable(nullptr, true);\n          }\n        }\n}"
  },
  {
    "function_name": "consumeRedirectedResponse",
    "container": "RpcCallContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1698-1706",
    "snippet": "kj::Own<RpcResponse> consumeRedirectedResponse() {\n      KJ_ASSERT(redirectResults);\n\n      if (response == nullptr) getResults(MessageSize{0, 0});  // force initialization of response\n\n      // Note that the context needs to keep its own reference to the response so that it doesn't\n      // get GC'd until the PipelineHook drops its reference to the context.\n      return kj::downcast<LocallyRedirectedRpcResponse>(*KJ_ASSERT_NONNULL(response)).addRef();\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<RpcServerResponse>> response;",
      "bool redirectResults = false;",
      "bool redirectResults;",
      "auto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::downcast<LocallyRedirectedRpcResponse>",
          "args": [],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "downcast",
          "container": "Own",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "154-166",
          "snippet": "Own<U> downcast() {\n    // Downcast the pointer to Own<U>, destroying the original pointer.  If this pointer does not\n    // actually point at an instance of U, the results are undefined (throws an exception in debug\n    // mode if RTTI is enabled, otherwise you're on your own).\n\n    Own<U> result;\n    if (ptr != nullptr) {\n      result.ptr = &kj::downcast<U>(*ptr);\n      result.disposer = disposer;\n      ptr = nullptr;\n    }\n    return result;\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  Own<U> downcast() {\n      // Downcast the pointer to Own<U>, destroying the original pointer.  If this pointer does not\n      // actually point at an instance of U, the results are undefined (throws an exception in debug\n      // mode if RTTI is enabled, otherwise you're on your own).\n  \n      Own<U> result;\n      if (ptr != nullptr) {\n        result.ptr = &kj::downcast<U>(*ptr);\n        result.disposer = disposer;\n        ptr = nullptr;\n      }\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::downcast<LocallyRedirectedRpcResponse>",
          "args": [
            "*KJ_ASSERT_NONNULL(response)"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "response"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getResults",
          "args": [
            "MessageSize{0, 0}"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "154-161",
          "snippet": "AnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<Response<AnyPointer>> response;",
            "AnyPointer::Builder responseBuilder = nullptr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<Response<AnyPointer>> response;\nAnyPointer::Builder responseBuilder = nullptr;\n\nAnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "redirectResults"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<RpcServerResponse>> response;\nbool redirectResults = false;\nbool redirectResults;\nauto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));\n\nRpcCallContext {\n  kj::Own<RpcResponse> consumeRedirectedResponse() {\n        KJ_ASSERT(redirectResults);\n  \n        if (response == nullptr) getResults(MessageSize{0, 0});  // force initialization of response\n  \n        // Note that the context needs to keep its own reference to the response so that it doesn't\n        // get GC'd until the PipelineHook drops its reference to the context.\n        return kj::downcast<LocallyRedirectedRpcResponse>(*KJ_ASSERT_NONNULL(response)).addRef();\n      }\n}"
  },
  {
    "function_name": "RpcCallContext",
    "container": "RpcCallContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1658-1667",
    "snippet": "RpcCallContext(RpcConnectionState& connectionState, AnswerId answerId,\n                   kj::Own<IncomingRpcMessage>&& request, const AnyPointer::Reader& params,\n                   bool redirectResults, kj::Own<kj::PromiseFulfiller<void>>&& cancelFulfiller)\n        : connectionState(kj::addRef(connectionState)),\n          answerId(answerId),\n          request(kj::mv(request)),\n          params(params),\n          returnMessage(nullptr),\n          redirectResults(redirectResults),\n          cancelFulfiller(kj::mv(cancelFulfiller)) {}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "AnswerId answerId;",
      "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
      "AnyPointer::Reader params;",
      "rpc::Return::Builder returnMessage;",
      "bool redirectResults = false;",
      "kj::Own<kj::PromiseFulfiller<void>> cancelFulfiller;",
      "bool redirectResults;",
      "AnswerId answerId = call.getQuestionId();"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "cancelFulfiller"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "request"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "connectionState"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nAnswerId answerId;\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nAnyPointer::Reader params;\nrpc::Return::Builder returnMessage;\nbool redirectResults = false;\nkj::Own<kj::PromiseFulfiller<void>> cancelFulfiller;\nbool redirectResults;\nAnswerId answerId = call.getQuestionId();\n\nRpcCallContext {\n  RpcCallContext(RpcConnectionState& connectionState, AnswerId answerId,\n                     kj::Own<IncomingRpcMessage>&& request, const AnyPointer::Reader& params,\n                     bool redirectResults, kj::Own<kj::PromiseFulfiller<void>>&& cancelFulfiller)\n          : connectionState(kj::addRef(connectionState)),\n            answerId(answerId),\n            request(kj::mv(request)),\n            params(params),\n            returnMessage(nullptr),\n            redirectResults(redirectResults),\n            cancelFulfiller(kj::mv(cancelFulfiller)) {}\n}"
  },
  {
    "function_name": "addRef",
    "container": "LocallyRedirectedRpcResponse",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1648-1650",
    "snippet": "kj::Own<RpcResponse> addRef() override {\n      return kj::addRef(*this);\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  kj::Own<RpcResponse> addRef() override {\n        return kj::addRef(*this);\n      }\n}"
  },
  {
    "function_name": "getResults",
    "container": "LocallyRedirectedRpcResponse",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1644-1646",
    "snippet": "AnyPointer::Reader getResults() override {\n      return message.getRoot<AnyPointer>();\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "message.getRoot<AnyPointer>",
          "args": [],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  AnyPointer::Reader getResults() override {\n        return message.getRoot<AnyPointer>();\n      }\n}"
  },
  {
    "function_name": "getResultsBuilder",
    "container": "LocallyRedirectedRpcResponse",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1640-1642",
    "snippet": "AnyPointer::Builder getResultsBuilder() override {\n      return message.getRoot<AnyPointer>();\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "message.getRoot<AnyPointer>",
          "args": [],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  AnyPointer::Builder getResultsBuilder() override {\n        return message.getRoot<AnyPointer>();\n      }\n}"
  },
  {
    "function_name": "LocallyRedirectedRpcResponse",
    "container": "LocallyRedirectedRpcResponse",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1636-1638",
    "snippet": "LocallyRedirectedRpcResponse(kj::Maybe<MessageSize> sizeHint)\n        : message(sizeHint.map([](MessageSize size) { return size.wordCount; })\n                          .orDefault(SUGGESTED_FIRST_SEGMENT_WORDS)) {}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sizeHint.map",
          "args": [
            "SUGGESTED_FIRST_SEGMENT_WORDS"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1083-1089",
          "snippet": "auto map(Func&& f) -> Maybe<decltype(f(instance<T&>()))> {\n    if (ptr == nullptr) {\n      return nullptr;\n    } else {\n      return f(*ptr);\n    }\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto map(Func&& f) -> Maybe<decltype(f(instance<T&>()))> {\n    if (ptr == nullptr) {\n      return nullptr;\n    } else {\n      return f(*ptr);\n    }\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  LocallyRedirectedRpcResponse(kj::Maybe<MessageSize> sizeHint)\n          : message(sizeHint.map([](MessageSize size) { return size.wordCount; })\n                            .orDefault(SUGGESTED_FIRST_SEGMENT_WORDS)) {}\n}"
  },
  {
    "function_name": "send",
    "container": "RpcServerResponseImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1600-1625",
    "snippet": "kj::Maybe<kj::Array<ExportId>> send() {\n      // Send the response and return the export list.  Returns nullptr if there were no caps.\n      // (Could return a non-null empty array if there were caps but none of them were exports.)\n\n      // Build the cap table.\n      auto capTable = message->getCapTable();\n      auto exports = connectionState.writeDescriptors(capTable, payload);\n\n      // Capabilities that we are returning are subject to embargos. See `Disembargo` in rpc.capnp.\n      // As explained there, in order to deal with the Tribble 4-way race condition, we need to\n      // make sure that if we're returning any remote promises, that we ignore any subsequent\n      // resolution of those promises for the purpose of pipelined requests on this answer. Luckily,\n      // we can modify the cap table in-place.\n      for (auto& slot: capTable) {\n        KJ_IF_MAYBE(cap, slot) {\n          slot = connectionState.getInnermostClient(**cap);\n        }\n      }\n\n      message->send();\n      if (capTable.size() == 0) {\n        return nullptr;\n      } else {\n        return kj::mv(exports);\n      }\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<RpcServerResponse>> response;",
      "auto& answer = answers[answerId];",
      "auto payload = call.getParams();"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exports"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capTable.size",
          "args": [],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "message->send",
          "args": [],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "connectionState.getInnermostClient",
          "args": [
            "**cap"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "getInnermostClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1056-1064",
          "snippet": "kj::Own<ClientHook> getInnermostClient(ClientHook& client) {\n    ClientHook* ptr = &client;\n    for (;;) {\n      KJ_IF_MAYBE(inner, ptr->getResolved()) {\n        ptr = inner;\n      } else {\n        break;\n      }\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Own<ClientHook> getInnermostClient(ClientHook& client) {\n    ClientHook* ptr = &client;\n    for (;;) {\n      KJ_IF_MAYBE(inner, ptr->getResolved()) {\n        ptr = inner;\n      } else {\n        break;\n      }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "connectionState.writeDescriptors",
          "args": [
            "capTable",
            "payload"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message->getCapTable",
          "args": [],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "getCapTable",
          "container": "BuilderArena",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
          "lines": "270-270",
          "snippet": "inline kj::ArrayPtr<kj::Maybe<kj::Own<ClientHook>>> getCapTable() { return capTable; }",
          "includes": [
            "#include \"capability.h\"",
            "#include <unordered_map>",
            "#include \"layout.h\"",
            "#include \"message.h\"",
            "#include \"common.h\"",
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/mutex.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\nBuilderArena {\n  inline kj::ArrayPtr<kj::Maybe<kj::Own<ClientHook>>> getCapTable() { return capTable; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<RpcServerResponse>> response;\nauto& answer = answers[answerId];\nauto payload = call.getParams();\n\nRpcServerResponseImpl {\n  kj::Maybe<kj::Array<ExportId>> send() {\n        // Send the response and return the export list.  Returns nullptr if there were no caps.\n        // (Could return a non-null empty array if there were caps but none of them were exports.)\n  \n        // Build the cap table.\n        auto capTable = message->getCapTable();\n        auto exports = connectionState.writeDescriptors(capTable, payload);\n  \n        // Capabilities that we are returning are subject to embargos. See `Disembargo` in rpc.capnp.\n        // As explained there, in order to deal with the Tribble 4-way race condition, we need to\n        // make sure that if we're returning any remote promises, that we ignore any subsequent\n        // resolution of those promises for the purpose of pipelined requests on this answer. Luckily,\n        // we can modify the cap table in-place.\n        for (auto& slot: capTable) {\n          KJ_IF_MAYBE(cap, slot) {\n            slot = connectionState.getInnermostClient(**cap);\n          }\n        }\n  \n        message->send();\n        if (capTable.size() == 0) {\n          return nullptr;\n        } else {\n          return kj::mv(exports);\n        }\n      }\n}"
  },
  {
    "function_name": "getResultsBuilder",
    "container": "RpcServerResponseImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1596-1598",
    "snippet": "AnyPointer::Builder getResultsBuilder() override {\n      return payload.getContent();\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "auto payload = call.getParams();"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "payload.getContent",
          "args": [],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "getContent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1232-1234",
          "snippet": "MaybeTruncated<ArrayPtr<const byte>> getContent() override {\n    return { contentBuffer.slice(0, receivedSize), contentTruncated };\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nMaybeTruncated<ArrayPtr<const byte>> getContent() override {\n    return { contentBuffer.slice(0, receivedSize), contentTruncated };\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto payload = call.getParams();\n\nRpcServerResponseImpl {\n  AnyPointer::Builder getResultsBuilder() override {\n        return payload.getContent();\n      }\n}"
  },
  {
    "function_name": "RpcServerResponseImpl",
    "container": "RpcServerResponseImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1589-1594",
    "snippet": "RpcServerResponseImpl(RpcConnectionState& connectionState,\n                          kj::Own<OutgoingRpcMessage>&& message,\n                          rpc::Payload::Builder payload)\n        : connectionState(connectionState),\n          message(kj::mv(message)),\n          payload(payload) {}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "auto payload = call.getParams();"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "message"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto payload = call.getParams();\n\nRpcServerResponseImpl {\n  RpcServerResponseImpl(RpcConnectionState& connectionState,\n                            kj::Own<OutgoingRpcMessage>&& message,\n                            rpc::Payload::Builder payload)\n          : connectionState(connectionState),\n            message(kj::mv(message)),\n            payload(payload) {}\n}"
  },
  {
    "function_name": "addRef",
    "container": "RpcResponseImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1568-1570",
    "snippet": "kj::Own<RpcResponse> addRef() override {\n      return kj::addRef(*this);\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcResponseImpl {\n  kj::Own<RpcResponse> addRef() override {\n        return kj::addRef(*this);\n      }\n}"
  },
  {
    "function_name": "getResults",
    "container": "RpcResponseImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1564-1566",
    "snippet": "AnyPointer::Reader getResults() override {\n      return reader;\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcResponseImpl {\n  AnyPointer::Reader getResults() override {\n        return reader;\n      }\n}"
  },
  {
    "function_name": "RpcResponseImpl",
    "container": "RpcResponseImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1555-1562",
    "snippet": "RpcResponseImpl(RpcConnectionState& connectionState,\n                    kj::Own<QuestionRef>&& questionRef,\n                    kj::Own<IncomingRpcMessage>&& message,\n                    AnyPointer::Reader results)\n        : connectionState(kj::addRef(connectionState)),\n          message(kj::mv(message)),\n          reader(results),\n          questionRef(kj::mv(questionRef)) {}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "auto results = response->getResultsBuilder();"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "questionRef"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "message"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "connectionState"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto results = response->getResultsBuilder();\n\nRpcResponseImpl {\n  RpcResponseImpl(RpcConnectionState& connectionState,\n                      kj::Own<QuestionRef>&& questionRef,\n                      kj::Own<IncomingRpcMessage>&& message,\n                      AnyPointer::Reader results)\n          : connectionState(kj::addRef(connectionState)),\n            message(kj::mv(message)),\n            reader(results),\n            questionRef(kj::mv(questionRef)) {}\n}"
  },
  {
    "function_name": "if",
    "container": "RpcPipeline",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1516-1518",
    "snippet": "else if (state.is<Resolved>()) {\n        return state.get<Resolved>()->getResults().getPipelinedCap(ops);\n      }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "state.get<Resolved>",
          "args": [
            "ops"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "state.get<Resolved>",
          "args": [],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcPipeline {\n  else if (state.is<Resolved>()) {\n          return state.get<Resolved>()->getResults().getPipelinedCap(ops);\n        }\n}"
  },
  {
    "function_name": "getPipelinedCap",
    "container": "RpcPipeline",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1498-1516",
    "snippet": "kj::Own<ClientHook> getPipelinedCap(kj::Array<PipelineOp>&& ops) override {\n      if (state.is<Waiting>()) {\n        // Wrap a PipelineClient in a PromiseClient.\n        auto pipelineClient = kj::refcounted<PipelineClient>(\n            *connectionState, kj::addRef(*state.get<Waiting>()), kj::heapArray(ops.asPtr()));\n\n        KJ_IF_MAYBE(r, redirectLater) {\n          auto resolutionPromise = r->addBranch().then(kj::mvCapture(ops,\n              [](kj::Array<PipelineOp> ops, kj::Own<RpcResponse>&& response) {\n                return response->getResults().getPipelinedCap(ops);\n              }));\n\n          return kj::refcounted<PromiseClient>(\n              *connectionState, kj::mv(pipelineClient), kj::mv(resolutionPromise), nullptr);\n        } else {\n          // Oh, this pipeline will never get redirected, so just return the PipelineClient.\n          return kj::mv(pipelineClient);\n        }\n      }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<RpcServerResponse>> response;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "return kj::mv",
          "args": [
            "pipelineClient"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::refcounted<PromiseClient>",
          "args": [
            "*connectionState",
            "kj::mv(pipelineClient)",
            "kj::mv(resolutionPromise)",
            "nullptr"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "resolutionPromise"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "pipelineClient"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r->addBranch",
          "args": [
            "kj::mvCapture(ops,\n              [](kj::Array<PipelineOp> ops, kj::Own<RpcResponse>&& response) {\n                return response->getResults().getPipelinedCap(ops);\n              })"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mvCapture",
          "args": [
            "ops",
            "[](kj::Array<PipelineOp> ops, kj::Own<RpcResponse>&& response) {\n                return response->getResults().getPipelinedCap(ops);\n              }"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "response->getResults",
          "args": [
            "ops"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "154-161",
          "snippet": "AnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<Response<AnyPointer>> response;",
            "AnyPointer::Builder responseBuilder = nullptr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<Response<AnyPointer>> response;\nAnyPointer::Builder responseBuilder = nullptr;\n\nAnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "response->getResults",
          "args": [],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1644-1646",
          "snippet": "AnyPointer::Reader getResults() override {\n      return message.getRoot<AnyPointer>();\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  AnyPointer::Reader getResults() override {\n        return message.getRoot<AnyPointer>();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r->addBranch",
          "args": [],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "addBranch",
          "container": "ForkHub",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "396-398",
          "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::refcounted<PipelineClient>",
          "args": [
            "*connectionState",
            "kj::addRef(*state.get<Waiting>())",
            "kj::heapArray(ops.asPtr())"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArray",
          "args": [
            "ops.asPtr()"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "696-698",
          "snippet": "inline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops.asPtr",
          "args": [],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "asPtr",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "313-315",
          "snippet": "inline ArrayPtr<const T> asPtr() const {\n    return arrayPtr(ptr, pos);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  inline ArrayPtr<const T> asPtr() const {\n      return arrayPtr(ptr, pos);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*state.get<Waiting>()"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "state.get<Waiting>",
          "args": [],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "state.is<Waiting>",
          "args": [],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<RpcServerResponse>> response;\n\nRpcPipeline {\n  kj::Own<ClientHook> getPipelinedCap(kj::Array<PipelineOp>&& ops) override {\n        if (state.is<Waiting>()) {\n          // Wrap a PipelineClient in a PromiseClient.\n          auto pipelineClient = kj::refcounted<PipelineClient>(\n              *connectionState, kj::addRef(*state.get<Waiting>()), kj::heapArray(ops.asPtr()));\n  \n          KJ_IF_MAYBE(r, redirectLater) {\n            auto resolutionPromise = r->addBranch().then(kj::mvCapture(ops,\n                [](kj::Array<PipelineOp> ops, kj::Own<RpcResponse>&& response) {\n                  return response->getResults().getPipelinedCap(ops);\n                }));\n  \n            return kj::refcounted<PromiseClient>(\n                *connectionState, kj::mv(pipelineClient), kj::mv(resolutionPromise), nullptr);\n          } else {\n            // Oh, this pipeline will never get redirected, so just return the PipelineClient.\n            return kj::mv(pipelineClient);\n          }\n        }\n}"
  },
  {
    "function_name": "getPipelinedCap",
    "container": "RpcPipeline",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1490-1496",
    "snippet": "kj::Own<ClientHook> getPipelinedCap(kj::ArrayPtr<const PipelineOp> ops) override {\n      auto copy = kj::heapArrayBuilder<PipelineOp>(ops.size());\n      for (auto& op: ops) {\n        copy.add(op);\n      }\n      return getPipelinedCap(copy.finish());\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy.finish",
          "args": [],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy.add",
          "args": [
            "op"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapArrayBuilder<PipelineOp>",
          "args": [
            "ops.size()"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "heapArrayBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "410-416",
          "snippet": "inline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops.size",
          "args": [],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcPipeline {\n  kj::Own<ClientHook> getPipelinedCap(kj::ArrayPtr<const PipelineOp> ops) override {\n        auto copy = kj::heapArrayBuilder<PipelineOp>(ops.size());\n        for (auto& op: ops) {\n          copy.add(op);\n        }\n        return getPipelinedCap(copy.finish());\n      }\n}"
  },
  {
    "function_name": "addRef",
    "container": "RpcPipeline",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1486-1488",
    "snippet": "kj::Own<PipelineHook> addRef() override {\n      return kj::addRef(*this);\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcPipeline {\n  kj::Own<PipelineHook> addRef() override {\n        return kj::addRef(*this);\n      }\n}"
  },
  {
    "function_name": "RpcPipeline",
    "container": "RpcPipeline",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1476-1482",
    "snippet": "RpcPipeline(RpcConnectionState& connectionState, kj::Own<QuestionRef>&& questionRef)\n        : connectionState(kj::addRef(connectionState)),\n          resolveSelfPromise(nullptr) {\n      // Construct a new RpcPipeline that is never expected to resolve.\n\n      state.init<Waiting>(kj::mv(questionRef));\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "state.init<Waiting>",
          "args": [
            "kj::mv(questionRef)"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/pointer-helpers.h",
          "lines": "51-53",
          "snippet": "static inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"layout.h\"\n\nstatic inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "questionRef"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "connectionState"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcPipeline {\n  RpcPipeline(RpcConnectionState& connectionState, kj::Own<QuestionRef>&& questionRef)\n          : connectionState(kj::addRef(connectionState)),\n            resolveSelfPromise(nullptr) {\n        // Construct a new RpcPipeline that is never expected to resolve.\n  \n        state.init<Waiting>(kj::mv(questionRef));\n      }\n}"
  },
  {
    "function_name": "RpcPipeline",
    "container": "RpcPipeline",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1457-1474",
    "snippet": "RpcPipeline(RpcConnectionState& connectionState, kj::Own<QuestionRef>&& questionRef,\n                kj::Promise<kj::Own<RpcResponse>>&& redirectLaterParam)\n        : connectionState(kj::addRef(connectionState)),\n          redirectLater(redirectLaterParam.fork()),\n          resolveSelfPromise(KJ_ASSERT_NONNULL(redirectLater).addBranch().then(\n              [this](kj::Own<RpcResponse>&& response) {\n                resolve(kj::mv(response));\n              }, [this](kj::Exception&& exception) {\n                resolve(kj::mv(exception));\n              }).eagerlyEvaluate([&](kj::Exception&& e) {\n                // Make any exceptions thrown from resolve() go to the connection's TaskSet which\n                // will cause the connection to be terminated.\n                connectionState.tasks.add(kj::mv(e));\n              })) {\n      // Construct a new RpcPipeline.\n\n      state.init<Waiting>(kj::mv(questionRef));\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<RpcServerResponse>> response;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "state.init<Waiting>",
          "args": [
            "kj::mv(questionRef)"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/pointer-helpers.h",
          "lines": "51-53",
          "snippet": "static inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"layout.h\"\n\nstatic inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "questionRef"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "[&](kj::Exception&& e) {\n                // Make any exceptions thrown from resolve() go to the connection's TaskSet which\n                // will cause the connection to be terminated.\n                connectionState.tasks.add(kj::mv(e));\n              }"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectionState.tasks.add",
          "args": [
            "kj::mv(e)"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "e"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "[this](kj::Own<RpcResponse>&& response) {\n                resolve(kj::mv(response));\n              }",
            "[this](kj::Exception&& exception) {\n                resolve(kj::mv(exception));\n              }"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolve",
          "args": [
            "kj::mv(exception)"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "resolveConstant",
          "container": "ValueResolverGlue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
          "lines": "1349-1352",
          "snippet": "kj::Maybe<DynamicValue::Reader> resolveConstant(Expression::Reader name) {\n      errorReporter.addErrorOn(name, kj::str(\"External constants not allowed in encode input.\"));\n      return nullptr;\n    }",
          "includes": [
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <process.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/main.h>",
            "#include <iostream>",
            "#include \"../message.h\"",
            "#include <kj/debug.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/vector.h>",
            "#include <capnp/schema.capnp.h>",
            "#include <capnp/pretty-print.h>",
            "#include \"node-translator.h\"",
            "#include \"module-loader.h\"",
            "#include \"compiler.h\"",
            "#include \"parser.h\"",
            "#include \"lexer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CapnpParser parser(arena.getOrphanage(), errorReporter);",
            "ValueResolverGlue resolver(compiler->getLoader(), errorReporter);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nCapnpParser parser(arena.getOrphanage(), errorReporter);\nValueResolverGlue resolver(compiler->getLoader(), errorReporter);\n\nValueResolverGlue {\n  kj::Maybe<DynamicValue::Reader> resolveConstant(Expression::Reader name) {\n        errorReporter.addErrorOn(name, kj::str(\"External constants not allowed in encode input.\"));\n        return nullptr;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "response"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "redirectLater"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirectLaterParam.fork",
          "args": [],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "connectionState"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<RpcServerResponse>> response;\n\nRpcPipeline {\n  RpcPipeline(RpcConnectionState& connectionState, kj::Own<QuestionRef>&& questionRef,\n                  kj::Promise<kj::Own<RpcResponse>>&& redirectLaterParam)\n          : connectionState(kj::addRef(connectionState)),\n            redirectLater(redirectLaterParam.fork()),\n            resolveSelfPromise(KJ_ASSERT_NONNULL(redirectLater).addBranch().then(\n                [this](kj::Own<RpcResponse>&& response) {\n                  resolve(kj::mv(response));\n                }, [this](kj::Exception&& exception) {\n                  resolve(kj::mv(exception));\n                }).eagerlyEvaluate([&](kj::Exception&& e) {\n                  // Make any exceptions thrown from resolve() go to the connection's TaskSet which\n                  // will cause the connection to be terminated.\n                  connectionState.tasks.add(kj::mv(e));\n                })) {\n        // Construct a new RpcPipeline.\n  \n        state.init<Waiting>(kj::mv(questionRef));\n      }\n}"
  },
  {
    "function_name": "send",
    "container": "RpcRequest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1329-1364",
    "snippet": "RemotePromise<AnyPointer> send() override {\n      if (!connectionState->connection.is<Connected>()) {\n        // Connection is broken.\n        const kj::Exception& e = connectionState->connection.get<Disconnected>();\n        return RemotePromise<AnyPointer>(\n            kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n            AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n      }\n\n      KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n        // Whoops, this capability has been redirected while we were building the request!\n        // We'll have to make a new request and do a copy.  Ick.\n\n        auto replacement = redirect->get()->newCall(\n            callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n        replacement.set(paramsBuilder);\n        return replacement.send();\n      } else {\n        auto sendResult = sendInternal(false);\n\n        auto forkedPromise = sendResult.promise.fork();\n\n        // The pipeline must get notified of resolution before the app does to maintain ordering.\n        auto pipeline = kj::refcounted<RpcPipeline>(\n            *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n\n        auto appPromise = forkedPromise.addBranch().then(\n            [=](kj::Own<RpcResponse>&& response) {\n              auto reader = response->getResults();\n              return Response<AnyPointer>(reader, kj::mv(response));\n            });\n\n        return RemotePromise<AnyPointer>(\n            kj::mv(appPromise),\n            AnyPointer::Pipeline(kj::mv(pipeline)));\n      }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
      "kj::Maybe<kj::Own<RpcServerResponse>> response;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RemotePromise<AnyPointer>",
          "args": [
            "kj::mv(appPromise)",
            "AnyPointer::Pipeline(kj::mv(pipeline))"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "RemotePromise",
          "container": "RemotePromise",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.h",
          "lines": "53-55",
          "snippet": "inline RemotePromise(kj::Promise<Response<T>>&& promise, typename T::Pipeline&& pipeline)\n      : kj::Promise<Response<T>>(kj::mv(promise)),\n        T::Pipeline(kj::mv(pipeline)) {}",
          "includes": [
            "#include \"pointer-helpers.h\"",
            "#include \"any.h\"",
            "#include <kj/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pointer-helpers.h\"\n#include \"any.h\"\n#include <kj/async.h>\n\nRemotePromise {\n  inline RemotePromise(kj::Promise<Response<T>>&& promise, typename T::Pipeline&& pipeline)\n        : kj::Promise<Response<T>>(kj::mv(promise)),\n          T::Pipeline(kj::mv(pipeline)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AnyPointer::Pipeline",
          "args": [
            "kj::mv(pipeline)"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "Pipeline",
          "container": "AnyPointer::Pipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "243-243",
          "snippet": "inline explicit Pipeline(kj::Own<PipelineHook>&& hook): hook(kj::mv(hook)) {}",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Pipeline {\n    inline explicit Pipeline(kj::Own<PipelineHook>&& hook): hook(kj::mv(hook)) {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "pipeline"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "appPromise"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "forkedPromise.addBranch",
          "args": [
            "[=](kj::Own<RpcResponse>&& response) {\n              auto reader = response->getResults();\n              return Response<AnyPointer>(reader, kj::mv(response));\n            }"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Response<AnyPointer>",
          "args": [
            "reader",
            "kj::mv(response)"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "LocallyRedirectedRpcResponse",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1636-1638",
          "snippet": "LocallyRedirectedRpcResponse(kj::Maybe<MessageSize> sizeHint)\n        : message(sizeHint.map([](MessageSize size) { return size.wordCount; })\n                          .orDefault(SUGGESTED_FIRST_SEGMENT_WORDS)) {}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  LocallyRedirectedRpcResponse(kj::Maybe<MessageSize> sizeHint)\n          : message(sizeHint.map([](MessageSize size) { return size.wordCount; })\n                            .orDefault(SUGGESTED_FIRST_SEGMENT_WORDS)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "response"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response->getResults",
          "args": [],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1644-1646",
          "snippet": "AnyPointer::Reader getResults() override {\n      return message.getRoot<AnyPointer>();\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  AnyPointer::Reader getResults() override {\n        return message.getRoot<AnyPointer>();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "forkedPromise.addBranch",
          "args": [],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "addBranch",
          "container": "ForkHub",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "396-398",
          "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::refcounted<RpcPipeline>",
          "args": [
            "*connectionState",
            "kj::mv(sendResult.questionRef)",
            "forkedPromise.addBranch()"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "sendResult.questionRef"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendResult.promise.fork",
          "args": [],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendInternal",
          "args": [
            "false"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replacement.send",
          "args": [],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "replacement.set",
          "args": [
            "paramsBuilder"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirect->get",
          "args": [
            "callBuilder.getInterfaceId()",
            "callBuilder.getMethodId()",
            "paramsBuilder.targetSize()"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paramsBuilder.targetSize",
          "args": [],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callBuilder.getMethodId",
          "args": [],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callBuilder.getInterfaceId",
          "args": [],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirect->get",
          "args": [],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "redirect",
            "target->writeTarget(callBuilder.getTarget())"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "target->writeTarget",
          "args": [
            "callBuilder.getTarget()"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "writeTarget",
          "container": "RpcConnectionState::NoInterceptClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "949-951",
          "snippet": "kj::Maybe<kj::Own<ClientHook>> writeTarget(rpc::MessageTarget::Builder target) override {\n      return inner->writeTarget(target);\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  NoInterceptClient {\n    kj::Maybe<kj::Own<ClientHook>> writeTarget(rpc::MessageTarget::Builder target) override {\n          return inner->writeTarget(target);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "callBuilder.getTarget",
          "args": [],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newBrokenPipeline",
          "args": [
            "kj::cp(e)"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "newBrokenPipeline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "624-626",
          "snippet": "kj::Own<PipelineHook> newBrokenPipeline(kj::Exception&& reason) {\n  return kj::refcounted<BrokenPipeline>(kj::mv(reason));\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<PipelineHook> newBrokenPipeline(kj::Exception&& reason) {\n  return kj::refcounted<BrokenPipeline>(kj::mv(reason));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::cp",
          "args": [
            "e"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "cp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "461-461",
          "snippet": "constexpr T cp(const T& t) noexcept { return t; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nconstexpr T cp(const T& t) noexcept { return t; }"
        }
      },
      {
        "call_info": {
          "callee": "kj::Promise<Response<AnyPointer>>",
          "args": [
            "kj::cp(e)"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectionState->connection.is<Connected>",
          "args": [],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nkj::Maybe<kj::Own<RpcServerResponse>> response;\n\nRpcRequest {\n  RemotePromise<AnyPointer> send() override {\n        if (!connectionState->connection.is<Connected>()) {\n          // Connection is broken.\n          const kj::Exception& e = connectionState->connection.get<Disconnected>();\n          return RemotePromise<AnyPointer>(\n              kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n              AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n        }\n  \n        KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n          // Whoops, this capability has been redirected while we were building the request!\n          // We'll have to make a new request and do a copy.  Ick.\n  \n          auto replacement = redirect->get()->newCall(\n              callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n          replacement.set(paramsBuilder);\n          return replacement.send();\n        } else {\n          auto sendResult = sendInternal(false);\n  \n          auto forkedPromise = sendResult.promise.fork();\n  \n          // The pipeline must get notified of resolution before the app does to maintain ordering.\n          auto pipeline = kj::refcounted<RpcPipeline>(\n              *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n  \n          auto appPromise = forkedPromise.addBranch().then(\n              [=](kj::Own<RpcResponse>&& response) {\n                auto reader = response->getResults();\n                return Response<AnyPointer>(reader, kj::mv(response));\n              });\n  \n          return RemotePromise<AnyPointer>(\n              kj::mv(appPromise),\n              AnyPointer::Pipeline(kj::mv(pipeline)));\n        }\n}"
  },
  {
    "function_name": "getCall",
    "container": "RpcRequest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1325-1327",
    "snippet": "inline rpc::Call::Builder getCall() {\n      return callBuilder;\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline rpc::Call::Builder getCall() {\n        return callBuilder;\n      }\n}"
  },
  {
    "function_name": "getRoot",
    "container": "RpcRequest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1322-1324",
    "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
  },
  {
    "function_name": "RpcRequest",
    "container": "RpcRequest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1312-1320",
    "snippet": "RpcRequest(RpcConnectionState& connectionState, VatNetworkBase::Connection& connection,\n               kj::Maybe<MessageSize> sizeHint, kj::Own<RpcClient>&& target)\n        : connectionState(kj::addRef(connectionState)),\n          target(kj::mv(target)),\n          message(connection.newOutgoingMessage(\n              firstSegmentSize(sizeHint, messageSizeHint<rpc::Call>() +\n                  sizeInWords<rpc::Payload>() + MESSAGE_TARGET_SIZE_HINT))),\n          callBuilder(message->getBody().getAs<rpc::Message>().initCall()),\n          paramsBuilder(callBuilder.getParams().getContent()) {}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "callBuilder.getParams",
          "args": [],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callBuilder.getParams",
          "args": [],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message->getBody",
          "args": [],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "getBody",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "106-108",
          "snippet": "AnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nAnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "connection.newOutgoingMessage",
          "args": [
            "firstSegmentSize(sizeHint, messageSizeHint<rpc::Call>() +\n                  sizeInWords<rpc::Payload>() + MESSAGE_TARGET_SIZE_HINT)"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "newOutgoingMessage",
          "container": "TestNetworkAdapter::ConnectionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "305-307",
          "snippet": "kj::Own<OutgoingRpcMessage> newOutgoingMessage(uint firstSegmentWordSize) override {\n      return kj::heap<OutgoingRpcMessageImpl>(*this, firstSegmentWordSize);\n    }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    kj::Own<OutgoingRpcMessage> newOutgoingMessage(uint firstSegmentWordSize) override {\n          return kj::heap<OutgoingRpcMessageImpl>(*this, firstSegmentWordSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "firstSegmentSize",
          "args": [
            "sizeHint",
            "messageSizeHint<rpc::Call>() +\n                  sizeInWords<rpc::Payload>() + MESSAGE_TARGET_SIZE_HINT"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sizeInWords<rpc::Payload>",
          "args": [],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "sizeInWords",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "496-502",
          "snippet": "inline constexpr uint sizeInWords() {\n  // Return the size, in words, of a Struct type, if allocated free-standing (not in a list).\n  // May be useful for pre-computing space needed in order to precisely allocate messages.\n\n  return (WordCount32(_::structSize<T>().data) +\n      _::structSize<T>().pointers * WORDS_PER_POINTER) / WORDS;\n}",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\ninline constexpr uint sizeInWords() {\n  // Return the size, in words, of a Struct type, if allocated free-standing (not in a list).\n  // May be useful for pre-computing space needed in order to precisely allocate messages.\n\n  return (WordCount32(_::structSize<T>().data) +\n      _::structSize<T>().pointers * WORDS_PER_POINTER) / WORDS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "messageSizeHint<rpc::Call>",
          "args": [],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "messageSizeHint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "40-42",
          "snippet": "inline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\ninline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "target"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "connectionState"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  RpcRequest(RpcConnectionState& connectionState, VatNetworkBase::Connection& connection,\n                 kj::Maybe<MessageSize> sizeHint, kj::Own<RpcClient>&& target)\n          : connectionState(kj::addRef(connectionState)),\n            target(kj::mv(target)),\n            message(connection.newOutgoingMessage(\n                firstSegmentSize(sizeHint, messageSizeHint<rpc::Call>() +\n                    sizeInWords<rpc::Payload>() + MESSAGE_TARGET_SIZE_HINT))),\n            callBuilder(message->getBody().getAs<rpc::Message>().initCall()),\n            paramsBuilder(callBuilder.getParams().getContent()) {}\n}"
  },
  {
    "function_name": "reject",
    "container": "QuestionRef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1299-1301",
    "snippet": "void reject(kj::Exception&& exception) {\n      fulfiller->reject(kj::mv(exception));\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  void reject(kj::Exception&& exception) {\n        fulfiller->reject(kj::mv(exception));\n      }\n}"
  },
  {
    "function_name": "fulfill",
    "container": "QuestionRef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1295-1297",
    "snippet": "void fulfill(kj::Promise<kj::Own<RpcResponse>>&& promise) {\n      fulfiller->fulfill(kj::mv(promise));\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promise"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  void fulfill(kj::Promise<kj::Own<RpcResponse>>&& promise) {\n        fulfiller->fulfill(kj::mv(promise));\n      }\n}"
  },
  {
    "function_name": "fulfill",
    "container": "QuestionRef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1291-1293",
    "snippet": "void fulfill(kj::Own<RpcResponse>&& response) {\n      fulfiller->fulfill(kj::mv(response));\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<RpcServerResponse>> response;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "response"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<RpcServerResponse>> response;\n\nQuestionRef {\n  void fulfill(kj::Own<RpcResponse>&& response) {\n        fulfiller->fulfill(kj::mv(response));\n      }\n}"
  },
  {
    "function_name": "getId",
    "container": "QuestionRef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1289-1289",
    "snippet": "inline QuestionId getId() const { return id; }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
  },
  {
    "function_name": "QuestionRef",
    "container": "QuestionRef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1252-1255",
    "snippet": "inline QuestionRef(\n        RpcConnectionState& connectionState, QuestionId id,\n        kj::Own<kj::PromiseFulfiller<kj::Promise<kj::Own<RpcResponse>>>> fulfiller)\n        : connectionState(kj::addRef(connectionState)), id(id), fulfiller(kj::mv(fulfiller)) {}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "fulfiller"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "connectionState"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionRef(\n          RpcConnectionState& connectionState, QuestionId id,\n          kj::Own<kj::PromiseFulfiller<kj::Promise<kj::Own<RpcResponse>>>> fulfiller)\n          : connectionState(kj::addRef(connectionState)), id(id), fulfiller(kj::mv(fulfiller)) {}\n}"
  },
  {
    "function_name": "receiveCap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1191-1224",
    "snippet": "kj::Maybe<kj::Own<ClientHook>> receiveCap(rpc::CapDescriptor::Reader descriptor) {\n    switch (descriptor.which()) {\n      case rpc::CapDescriptor::NONE:\n        return nullptr;\n\n      case rpc::CapDescriptor::SENDER_HOSTED:\n        return import(descriptor.getSenderHosted(), false);\n      case rpc::CapDescriptor::SENDER_PROMISE:\n        return import(descriptor.getSenderPromise(), true);\n\n      case rpc::CapDescriptor::RECEIVER_HOSTED:\n        KJ_IF_MAYBE(exp, exports.find(descriptor.getReceiverHosted())) {\n          return exp->clientHook->addRef();\n        } else {\n          return newBrokenCap(\"invalid 'receiverHosted' export ID\");\n        }\n\n      case rpc::CapDescriptor::RECEIVER_ANSWER: {\n        auto promisedAnswer = descriptor.getReceiverAnswer();\n\n        KJ_IF_MAYBE(answer, answers.find(promisedAnswer.getQuestionId())) {\n          if (answer->active) {\n            KJ_IF_MAYBE(pipeline, answer->pipeline) {\n              KJ_IF_MAYBE(ops, toPipelineOps(promisedAnswer.getTransform())) {\n                return pipeline->get()->getPipelinedCap(*ops);\n              } else {\n                return newBrokenCap(\"unrecognized pipeline ops\");\n              }\n            }\n          }\n        }\n\n        return newBrokenCap(\"invalid 'receiverAnswer'\");\n      }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "auto& answer = answers[answerId];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "newBrokenCap",
          "args": [
            "\"invalid 'receiverAnswer'\""
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "newBrokenCap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "620-622",
          "snippet": "kj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipeline->get",
          "args": [
            "*ops"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "pipeline->get",
          "args": [],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "ops",
            "toPipelineOps(promisedAnswer.getTransform())"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "toPipelineOps",
          "args": [
            "promisedAnswer.getTransform()"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "toPipelineOps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "69-89",
          "snippet": "kj::Maybe<kj::Array<PipelineOp>> toPipelineOps(List<rpc::PromisedAnswer::Op>::Reader ops) {\n  auto result = kj::heapArrayBuilder<PipelineOp>(ops.size());\n  for (auto opReader: ops) {\n    PipelineOp op;\n    switch (opReader.which()) {\n      case rpc::PromisedAnswer::Op::NOOP:\n        op.type = PipelineOp::NOOP;\n        break;\n      case rpc::PromisedAnswer::Op::GET_POINTER_FIELD:\n        op.type = PipelineOp::GET_POINTER_FIELD;\n        op.pointerIndex = opReader.getGetPointerField();\n        break;\n      default:\n        KJ_FAIL_REQUIRE(\"Unsupported pipeline op.\", (uint)opReader.which()) {\n          return nullptr;\n        }\n    }\n    result.add(op);\n  }\n  return result.finish();\n}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Array<PipelineOp>> toPipelineOps(List<rpc::PromisedAnswer::Op>::Reader ops) {\n  auto result = kj::heapArrayBuilder<PipelineOp>(ops.size());\n  for (auto opReader: ops) {\n    PipelineOp op;\n    switch (opReader.which()) {\n      case rpc::PromisedAnswer::Op::NOOP:\n        op.type = PipelineOp::NOOP;\n        break;\n      case rpc::PromisedAnswer::Op::GET_POINTER_FIELD:\n        op.type = PipelineOp::GET_POINTER_FIELD;\n        op.pointerIndex = opReader.getGetPointerField();\n        break;\n      default:\n        KJ_FAIL_REQUIRE(\"Unsupported pipeline op.\", (uint)opReader.which()) {\n          return nullptr;\n        }\n    }\n    result.add(op);\n  }\n  return result.finish();\n}"
        }
      },
      {
        "call_info": {
          "callee": "promisedAnswer.getTransform",
          "args": [],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "answers.find",
          "args": [
            "promisedAnswer.getQuestionId()"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "191-202",
          "snippet": "kj::Maybe<T&> find(Id id) {\n    if (id < kj::size(low)) {\n      return low[id];\n    } else {\n      auto iter = high.find(id);\n      if (iter == high.end()) {\n        return nullptr;\n      } else {\n        return iter->second;\n      }\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  kj::Maybe<T&> find(Id id) {\n      if (id < kj::size(low)) {\n        return low[id];\n      } else {\n        auto iter = high.find(id);\n        if (iter == high.end()) {\n          return nullptr;\n        } else {\n          return iter->second;\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "promisedAnswer.getQuestionId",
          "args": [],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "descriptor.getReceiverAnswer",
          "args": [],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp->clientHook->addRef",
          "args": [],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": "SingleCapPipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2064-2066",
          "snippet": "kj::Own<PipelineHook> addRef() override {\n      return kj::addRef(*this);\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nSingleCapPipeline {\n  kj::Own<PipelineHook> addRef() override {\n        return kj::addRef(*this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "descriptor.getReceiverHosted",
          "args": [],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "import",
          "args": [
            "descriptor.getSenderPromise()",
            "true"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "import",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1149-1161",
          "snippet": "kj::Own<ClientHook> import(ImportId importId, bool isPromise) {\n    // Receive a new import.\n\n    auto& import = imports[importId];\n    kj::Own<ImportClient> importClient;\n\n    // Create the ImportClient, or if one already exists, use it.\n    KJ_IF_MAYBE(c, import.importClient) {\n      importClient = kj::addRef(*c);\n    } else {\n      importClient = kj::refcounted<ImportClient>(*this, importId);\n      import.importClient = *importClient;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "else if (import->importClient != nullptr)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nelse if (import->importClient != nullptr);\n\nkj::Own<ClientHook> import(ImportId importId, bool isPromise) {\n    // Receive a new import.\n\n    auto& import = imports[importId];\n    kj::Own<ImportClient> importClient;\n\n    // Create the ImportClient, or if one already exists, use it.\n    KJ_IF_MAYBE(c, import.importClient) {\n      importClient = kj::addRef(*c);\n    } else {\n      importClient = kj::refcounted<ImportClient>(*this, importId);\n      import.importClient = *importClient;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "descriptor.getSenderPromise",
          "args": [],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "descriptor.getSenderHosted",
          "args": [],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "descriptor.which",
          "args": [],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto& answer = answers[answerId];\n\nkj::Maybe<kj::Own<ClientHook>> receiveCap(rpc::CapDescriptor::Reader descriptor) {\n    switch (descriptor.which()) {\n      case rpc::CapDescriptor::NONE:\n        return nullptr;\n\n      case rpc::CapDescriptor::SENDER_HOSTED:\n        return import(descriptor.getSenderHosted(), false);\n      case rpc::CapDescriptor::SENDER_PROMISE:\n        return import(descriptor.getSenderPromise(), true);\n\n      case rpc::CapDescriptor::RECEIVER_HOSTED:\n        KJ_IF_MAYBE(exp, exports.find(descriptor.getReceiverHosted())) {\n          return exp->clientHook->addRef();\n        } else {\n          return newBrokenCap(\"invalid 'receiverHosted' export ID\");\n        }\n\n      case rpc::CapDescriptor::RECEIVER_ANSWER: {\n        auto promisedAnswer = descriptor.getReceiverAnswer();\n\n        KJ_IF_MAYBE(answer, answers.find(promisedAnswer.getQuestionId())) {\n          if (answer->active) {\n            KJ_IF_MAYBE(pipeline, answer->pipeline) {\n              KJ_IF_MAYBE(ops, toPipelineOps(promisedAnswer.getTransform())) {\n                return pipeline->get()->getPipelinedCap(*ops);\n              } else {\n                return newBrokenCap(\"unrecognized pipeline ops\");\n              }\n            }\n          }\n        }\n\n        return newBrokenCap(\"invalid 'receiverAnswer'\");\n      }"
  },
  {
    "function_name": "import",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1149-1161",
    "snippet": "kj::Own<ClientHook> import(ImportId importId, bool isPromise) {\n    // Receive a new import.\n\n    auto& import = imports[importId];\n    kj::Own<ImportClient> importClient;\n\n    // Create the ImportClient, or if one already exists, use it.\n    KJ_IF_MAYBE(c, import.importClient) {\n      importClient = kj::addRef(*c);\n    } else {\n      importClient = kj::refcounted<ImportClient>(*this, importId);\n      import.importClient = *importClient;\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "else if (import->importClient != nullptr)"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::refcounted<ImportClient>",
          "args": [
            "*this",
            "importId"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*c"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "c",
            "import.importClient"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nelse if (import->importClient != nullptr);\n\nkj::Own<ClientHook> import(ImportId importId, bool isPromise) {\n    // Receive a new import.\n\n    auto& import = imports[importId];\n    kj::Own<ImportClient> importClient;\n\n    // Create the ImportClient, or if one already exists, use it.\n    KJ_IF_MAYBE(c, import.importClient) {\n      importClient = kj::addRef(*c);\n    } else {\n      importClient = kj::refcounted<ImportClient>(*this, importId);\n      import.importClient = *importClient;\n    }"
  },
  {
    "function_name": "resolveExportedPromise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1073-1144",
    "snippet": "kj::Promise<void> resolveExportedPromise(\n      ExportId exportId, kj::Promise<kj::Own<ClientHook>>&& promise) {\n    // Implements exporting of a promise.  The promise has been exported under the given ID, and is\n    // to eventually resolve to the ClientHook produced by `promise`.  This method waits for that\n    // resolve to happen and then sends the appropriate `Resolve` message to the peer.\n\n    return promise.then(\n        [this,exportId](kj::Own<ClientHook>&& resolution) -> kj::Promise<void> {\n      // Successful resolution.\n\n      KJ_ASSERT(connection.is<Connected>(),\n                \"Resolving export should have been canceled on disconnect.\") {\n        return kj::READY_NOW;\n      }\n\n      // Get the innermost ClientHook backing the resolved client.  This includes traversing\n      // PromiseClients that haven't resolved yet to their underlying ImportClient or\n      // PipelineClient, so that we get a remote promise that might resolve later.  This is\n      // important to make sure that if the peer sends a `Disembargo` back to us, it bounces back\n      // correctly instead of going to the result of some future resolution.  See the documentation\n      // for `Disembargo` in `rpc.capnp`.\n      resolution = getInnermostClient(*resolution);\n\n      // Update the export table to point at this object instead.  We know that our entry in the\n      // export table is still live because when it is destroyed the asynchronous resolution task\n      // (i.e. this code) is canceled.\n      auto& exp = KJ_ASSERT_NONNULL(exports.find(exportId));\n      exportsByCap.erase(exp.clientHook);\n      exp.clientHook = kj::mv(resolution);\n\n      if (exp.clientHook->getBrand() != this) {\n        // We're resolving to a local capability.  If we're resolving to a promise, we might be\n        // able to reuse our export table entry and avoid sending a message.\n\n        KJ_IF_MAYBE(promise, exp.clientHook->whenMoreResolved()) {\n          // We're replacing a promise with another local promise.  In this case, we might actually\n          // be able to just reuse the existing export table entry to represent the new promise --\n          // unless it already has an entry.  Let's check.\n\n          auto insertResult = exportsByCap.insert(std::make_pair(exp.clientHook.get(), exportId));\n\n          if (insertResult.second) {\n            // The new promise was not already in the table, therefore the existing export table\n            // entry has now been repurposed to represent it.  There is no need to send a resolve\n            // message at all.  We do, however, have to start resolving the next promise.\n            return resolveExportedPromise(exportId, kj::mv(*promise));\n          }\n        }\n      }\n\n      // OK, we have to send a `Resolve` message.\n      auto message = connection.get<Connected>()->newOutgoingMessage(\n          messageSizeHint<rpc::Resolve>() + sizeInWords<rpc::CapDescriptor>() + 16);\n      auto resolve = message->getBody().initAs<rpc::Message>().initResolve();\n      resolve.setPromiseId(exportId);\n      writeDescriptor(*exp.clientHook, resolve.initCap());\n      message->send();\n\n      return kj::READY_NOW;\n    }, [this,exportId](kj::Exception&& exception) {\n      // send error resolution\n      auto message = connection.get<Connected>()->newOutgoingMessage(\n          messageSizeHint<rpc::Resolve>() + exceptionSizeHint(exception) + 8);\n      auto resolve = message->getBody().initAs<rpc::Message>().initResolve();\n      resolve.setPromiseId(exportId);\n      fromException(exception, resolve.initException());\n      message->send();\n    }).eagerlyEvaluate([this](kj::Exception&& exception) {\n      // Put the exception on the TaskSet which will cause the connection to be terminated.\n      tasks.add(kj::mv(exception));\n    });\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "[this](kj::Exception&& exception) {\n      // Put the exception on the TaskSet which will cause the connection to be terminated.\n      tasks.add(kj::mv(exception));\n    }"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "kj::mv(exception)"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "[this,exportId](kj::Own<ClientHook>&& resolution) -> kj::Promise<void> {\n      // Successful resolution.\n\n      KJ_ASSERT(connection.is<Connected>(),\n                \"Resolving export should have been canceled on disconnect.\") {\n        return kj::READY_NOW;\n      }\n\n      // Get the innermost ClientHook backing the resolved client.  This includes traversing\n      // PromiseClients that haven't resolved yet to their underlying ImportClient or\n      // PipelineClient, so that we get a remote promise that might resolve later.  This is\n      // important to make sure that if the peer sends a `Disembargo` back to us, it bounces back\n      // correctly instead of going to the result of some future resolution.  See the documentation\n      // for `Disembargo` in `rpc.capnp`.\n      resolution = getInnermostClient(*resolution);\n\n      // Update the export table to point at this object instead.  We know that our entry in the\n      // export table is still live because when it is destroyed the asynchronous resolution task\n      // (i.e. this code) is canceled.\n      auto& exp = KJ_ASSERT_NONNULL(exports.find(exportId));\n      exportsByCap.erase(exp.clientHook);\n      exp.clientHook = kj::mv(resolution);\n\n      if (exp.clientHook->getBrand() != this) {\n        // We're resolving to a local capability.  If we're resolving to a promise, we might be\n        // able to reuse our export table entry and avoid sending a message.\n\n        KJ_IF_MAYBE(promise, exp.clientHook->whenMoreResolved()) {\n          // We're replacing a promise with another local promise.  In this case, we might actually\n          // be able to just reuse the existing export table entry to represent the new promise --\n          // unless it already has an entry.  Let's check.\n\n          auto insertResult = exportsByCap.insert(std::make_pair(exp.clientHook.get(), exportId));\n\n          if (insertResult.second) {\n            // The new promise was not already in the table, therefore the existing export table\n            // entry has now been repurposed to represent it.  There is no need to send a resolve\n            // message at all.  We do, however, have to start resolving the next promise.\n            return resolveExportedPromise(exportId, kj::mv(*promise));\n          }\n        }\n      }\n\n      // OK, we have to send a `Resolve` message.\n      auto message = connection.get<Connected>()->newOutgoingMessage(\n          messageSizeHint<rpc::Resolve>() + sizeInWords<rpc::CapDescriptor>() + 16);\n      auto resolve = message->getBody().initAs<rpc::Message>().initResolve();\n      resolve.setPromiseId(exportId);\n      writeDescriptor(*exp.clientHook, resolve.initCap());\n      message->send();\n\n      return kj::READY_NOW;\n    }",
            "[this,exportId](kj::Exception&& exception) {\n      // send error resolution\n      auto message = connection.get<Connected>()->newOutgoingMessage(\n          messageSizeHint<rpc::Resolve>() + exceptionSizeHint(exception) + 8);\n      auto resolve = message->getBody().initAs<rpc::Message>().initResolve();\n      resolve.setPromiseId(exportId);\n      fromException(exception, resolve.initException());\n      message->send();\n    }"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message->send",
          "args": [],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "fromException",
          "args": [
            "exception",
            "resolve.initException()"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "fromException",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "114-119",
          "snippet": "void fromException(const kj::Exception& exception, rpc::Exception::Builder builder) {\n  // TODO(someday):  Indicate the remote server name as part of the stack trace.  Maybe even\n  //   transmit stack traces?\n  builder.setReason(exception.getDescription());\n  builder.setType(static_cast<rpc::Exception::Type>(exception.getType()));\n}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid fromException(const kj::Exception& exception, rpc::Exception::Builder builder) {\n  // TODO(someday):  Indicate the remote server name as part of the stack trace.  Maybe even\n  //   transmit stack traces?\n  builder.setReason(exception.getDescription());\n  builder.setType(static_cast<rpc::Exception::Type>(exception.getType()));\n}"
        }
      },
      {
        "call_info": {
          "callee": "resolve.initException",
          "args": [],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolve.setPromiseId",
          "args": [
            "exportId"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message->getBody",
          "args": [],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "getBody",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "106-108",
          "snippet": "AnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nAnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "connection.get<Connected>",
          "args": [
            "messageSizeHint<rpc::Resolve>() + exceptionSizeHint(exception) + 8"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "exceptionSizeHint",
          "args": [
            "exception"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "exceptionSizeHint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "121-123",
          "snippet": "uint exceptionSizeHint(const kj::Exception& exception) {\n  return sizeInWords<rpc::Exception>() + exception.getDescription().size() / sizeof(word) + 1;\n}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nuint exceptionSizeHint(const kj::Exception& exception) {\n  return sizeInWords<rpc::Exception>() + exception.getDescription().size() / sizeof(word) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "messageSizeHint<rpc::Resolve>",
          "args": [],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "messageSizeHint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "40-42",
          "snippet": "inline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\ninline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}"
        }
      },
      {
        "call_info": {
          "callee": "connection.get<Connected>",
          "args": [],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeDescriptor",
          "args": [
            "*exp.clientHook",
            "resolve.initCap()"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "writeDescriptor",
          "container": "RpcConnectionState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "978-989",
          "snippet": "kj::Maybe<ExportId> writeDescriptor(ClientHook& cap, rpc::CapDescriptor::Builder descriptor) {\n    // Write a descriptor for the given capability.\n\n    // Find the innermost wrapped capability.\n    ClientHook* inner = &cap;\n    for (;;) {\n      KJ_IF_MAYBE(resolved, inner->getResolved()) {\n        inner = resolved;\n      } else {\n        break;\n      }\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  kj::Maybe<ExportId> writeDescriptor(ClientHook& cap, rpc::CapDescriptor::Builder descriptor) {\n      // Write a descriptor for the given capability.\n  \n      // Find the innermost wrapped capability.\n      ClientHook* inner = &cap;\n      for (;;) {\n        KJ_IF_MAYBE(resolved, inner->getResolved()) {\n          inner = resolved;\n        } else {\n          break;\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "resolve.initCap",
          "args": [],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolve.setPromiseId",
          "args": [
            "exportId"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sizeInWords<rpc::CapDescriptor>",
          "args": [],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "sizeInWords",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "496-502",
          "snippet": "inline constexpr uint sizeInWords() {\n  // Return the size, in words, of a Struct type, if allocated free-standing (not in a list).\n  // May be useful for pre-computing space needed in order to precisely allocate messages.\n\n  return (WordCount32(_::structSize<T>().data) +\n      _::structSize<T>().pointers * WORDS_PER_POINTER) / WORDS;\n}",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\ninline constexpr uint sizeInWords() {\n  // Return the size, in words, of a Struct type, if allocated free-standing (not in a list).\n  // May be useful for pre-computing space needed in order to precisely allocate messages.\n\n  return (WordCount32(_::structSize<T>().data) +\n      _::structSize<T>().pointers * WORDS_PER_POINTER) / WORDS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "resolveExportedPromise",
          "args": [
            "exportId",
            "kj::mv(*promise)"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*promise"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exportsByCap.insert",
          "args": [
            "std::make_pair(exp.clientHook.get(), exportId)"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "exp.clientHook.get()",
            "exportId"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "promise",
            "exp.clientHook->whenMoreResolved()"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "exp.clientHook->whenMoreResolved",
          "args": [],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "whenMoreResolved",
          "container": "RpcConnectionState::NoInterceptClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "970-972",
          "snippet": "kj::Maybe<kj::Promise<kj::Own<ClientHook>>> whenMoreResolved() override {\n      return nullptr;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  NoInterceptClient {\n    kj::Maybe<kj::Promise<kj::Own<ClientHook>>> whenMoreResolved() override {\n          return nullptr;\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp.clientHook->getBrand",
          "args": [],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "resolution"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exportsByCap.erase",
          "args": [
            "exp.clientHook"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "204-216",
          "snippet": "T erase(Id id) {\n    // Remove an entry from the table and return it.  We return it so that the caller can be\n    // careful to release it (possibly invoking arbitrary destructors) at a time that makes sense.\n    if (id < kj::size(low)) {\n      T toRelease = kj::mv(low[id]);\n      low[id] = T();\n      return toRelease;\n    } else {\n      T toRelease = kj::mv(high[id]);\n      high.erase(id);\n      return toRelease;\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  T erase(Id id) {\n      // Remove an entry from the table and return it.  We return it so that the caller can be\n      // careful to release it (possibly invoking arbitrary destructors) at a time that makes sense.\n      if (id < kj::size(low)) {\n        T toRelease = kj::mv(low[id]);\n        low[id] = T();\n        return toRelease;\n      } else {\n        T toRelease = kj::mv(high[id]);\n        high.erase(id);\n        return toRelease;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "exports.find(exportId)"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exports.find",
          "args": [
            "exportId"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "191-202",
          "snippet": "kj::Maybe<T&> find(Id id) {\n    if (id < kj::size(low)) {\n      return low[id];\n    } else {\n      auto iter = high.find(id);\n      if (iter == high.end()) {\n        return nullptr;\n      } else {\n        return iter->second;\n      }\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  kj::Maybe<T&> find(Id id) {\n      if (id < kj::size(low)) {\n        return low[id];\n      } else {\n        auto iter = high.find(id);\n        if (iter == high.end()) {\n          return nullptr;\n        } else {\n          return iter->second;\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getInnermostClient",
          "args": [
            "*resolution"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "getInnermostClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1056-1064",
          "snippet": "kj::Own<ClientHook> getInnermostClient(ClientHook& client) {\n    ClientHook* ptr = &client;\n    for (;;) {\n      KJ_IF_MAYBE(inner, ptr->getResolved()) {\n        ptr = inner;\n      } else {\n        break;\n      }\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Own<ClientHook> getInnermostClient(ClientHook& client) {\n    ClientHook* ptr = &client;\n    for (;;) {\n      KJ_IF_MAYBE(inner, ptr->getResolved()) {\n        ptr = inner;\n      } else {\n        break;\n      }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "connection.is<Connected>()",
            "\"Resolving export should have been canceled on disconnect.\""
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connection.is<Connected>",
          "args": [],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Promise<void> resolveExportedPromise(\n      ExportId exportId, kj::Promise<kj::Own<ClientHook>>&& promise) {\n    // Implements exporting of a promise.  The promise has been exported under the given ID, and is\n    // to eventually resolve to the ClientHook produced by `promise`.  This method waits for that\n    // resolve to happen and then sends the appropriate `Resolve` message to the peer.\n\n    return promise.then(\n        [this,exportId](kj::Own<ClientHook>&& resolution) -> kj::Promise<void> {\n      // Successful resolution.\n\n      KJ_ASSERT(connection.is<Connected>(),\n                \"Resolving export should have been canceled on disconnect.\") {\n        return kj::READY_NOW;\n      }\n\n      // Get the innermost ClientHook backing the resolved client.  This includes traversing\n      // PromiseClients that haven't resolved yet to their underlying ImportClient or\n      // PipelineClient, so that we get a remote promise that might resolve later.  This is\n      // important to make sure that if the peer sends a `Disembargo` back to us, it bounces back\n      // correctly instead of going to the result of some future resolution.  See the documentation\n      // for `Disembargo` in `rpc.capnp`.\n      resolution = getInnermostClient(*resolution);\n\n      // Update the export table to point at this object instead.  We know that our entry in the\n      // export table is still live because when it is destroyed the asynchronous resolution task\n      // (i.e. this code) is canceled.\n      auto& exp = KJ_ASSERT_NONNULL(exports.find(exportId));\n      exportsByCap.erase(exp.clientHook);\n      exp.clientHook = kj::mv(resolution);\n\n      if (exp.clientHook->getBrand() != this) {\n        // We're resolving to a local capability.  If we're resolving to a promise, we might be\n        // able to reuse our export table entry and avoid sending a message.\n\n        KJ_IF_MAYBE(promise, exp.clientHook->whenMoreResolved()) {\n          // We're replacing a promise with another local promise.  In this case, we might actually\n          // be able to just reuse the existing export table entry to represent the new promise --\n          // unless it already has an entry.  Let's check.\n\n          auto insertResult = exportsByCap.insert(std::make_pair(exp.clientHook.get(), exportId));\n\n          if (insertResult.second) {\n            // The new promise was not already in the table, therefore the existing export table\n            // entry has now been repurposed to represent it.  There is no need to send a resolve\n            // message at all.  We do, however, have to start resolving the next promise.\n            return resolveExportedPromise(exportId, kj::mv(*promise));\n          }\n        }\n      }\n\n      // OK, we have to send a `Resolve` message.\n      auto message = connection.get<Connected>()->newOutgoingMessage(\n          messageSizeHint<rpc::Resolve>() + sizeInWords<rpc::CapDescriptor>() + 16);\n      auto resolve = message->getBody().initAs<rpc::Message>().initResolve();\n      resolve.setPromiseId(exportId);\n      writeDescriptor(*exp.clientHook, resolve.initCap());\n      message->send();\n\n      return kj::READY_NOW;\n    }, [this,exportId](kj::Exception&& exception) {\n      // send error resolution\n      auto message = connection.get<Connected>()->newOutgoingMessage(\n          messageSizeHint<rpc::Resolve>() + exceptionSizeHint(exception) + 8);\n      auto resolve = message->getBody().initAs<rpc::Message>().initResolve();\n      resolve.setPromiseId(exportId);\n      fromException(exception, resolve.initException());\n      message->send();\n    }).eagerlyEvaluate([this](kj::Exception&& exception) {\n      // Put the exception on the TaskSet which will cause the connection to be terminated.\n      tasks.add(kj::mv(exception));\n    });\n  }"
  },
  {
    "function_name": "getInnermostClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1056-1064",
    "snippet": "kj::Own<ClientHook> getInnermostClient(ClientHook& client) {\n    ClientHook* ptr = &client;\n    for (;;) {\n      KJ_IF_MAYBE(inner, ptr->getResolved()) {\n        ptr = inner;\n      } else {\n        break;\n      }\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "inner",
            "ptr->getResolved()"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "ptr->getResolved",
          "args": [],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "getResolved",
          "container": "RpcConnectionState::NoInterceptClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "966-968",
          "snippet": "kj::Maybe<ClientHook&> getResolved() override {\n      return nullptr;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  NoInterceptClient {\n    kj::Maybe<ClientHook&> getResolved() override {\n          return nullptr;\n        }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Own<ClientHook> getInnermostClient(ClientHook& client) {\n    ClientHook* ptr = &client;\n    for (;;) {\n      KJ_IF_MAYBE(inner, ptr->getResolved()) {\n        ptr = inner;\n      } else {\n        break;\n      }\n    }"
  },
  {
    "function_name": "writeTarget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1038-1054",
    "snippet": "kj::Maybe<kj::Own<ClientHook>> writeTarget(ClientHook& cap, rpc::MessageTarget::Builder target) {\n    // If calls to the given capability should pass over this connection, fill in `target`\n    // appropriately for such a call and return nullptr.  Otherwise, return a `ClientHook` to which\n    // the call should be forwarded; the caller should then delegate the call to that `ClientHook`.\n    //\n    // The main case where this ends up returning non-null is if `cap` is a promise that has\n    // recently resolved.  The application might have started building a request before the promise\n    // resolved, and so the request may have been built on the assumption that it would be sent over\n    // this network connection, but then the promise resolved to point somewhere else before the\n    // request was sent.  Now the request has to be redirected to the new target instead.\n\n    if (cap.getBrand() == this) {\n      return kj::downcast<RpcClient>(cap).writeTarget(target);\n    } else {\n      return cap.addRef();\n    }\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<IncomingRpcMessage>> request;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cap.addRef",
          "args": [],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": "SingleCapPipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2064-2066",
          "snippet": "kj::Own<PipelineHook> addRef() override {\n      return kj::addRef(*this);\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nSingleCapPipeline {\n  kj::Own<PipelineHook> addRef() override {\n        return kj::addRef(*this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::downcast<RpcClient>",
          "args": [
            "target"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::downcast<RpcClient>",
          "args": [
            "cap"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap.getBrand",
          "args": [],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\n\nkj::Maybe<kj::Own<ClientHook>> writeTarget(ClientHook& cap, rpc::MessageTarget::Builder target) {\n    // If calls to the given capability should pass over this connection, fill in `target`\n    // appropriately for such a call and return nullptr.  Otherwise, return a `ClientHook` to which\n    // the call should be forwarded; the caller should then delegate the call to that `ClientHook`.\n    //\n    // The main case where this ends up returning non-null is if `cap` is a promise that has\n    // recently resolved.  The application might have started building a request before the promise\n    // resolved, and so the request may have been built on the assumption that it would be sent over\n    // this network connection, but then the promise resolved to point somewhere else before the\n    // request was sent.  Now the request has to be redirected to the new target instead.\n\n    if (cap.getBrand() == this) {\n      return kj::downcast<RpcClient>(cap).writeTarget(target);\n    } else {\n      return cap.addRef();\n    }\n  }"
  },
  {
    "function_name": "writeDescriptors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "1022-1034",
    "snippet": "kj::Array<ExportId> writeDescriptors(kj::ArrayPtr<kj::Maybe<kj::Own<ClientHook>>> capTable,\n                                       rpc::Payload::Builder payload) {\n    auto capTableBuilder = payload.initCapTable(capTable.size());\n    kj::Vector<ExportId> exports(capTable.size());\n    for (uint i: kj::indices(capTable)) {\n      KJ_IF_MAYBE(cap, capTable[i]) {\n        KJ_IF_MAYBE(exportId, writeDescriptor(**cap, capTableBuilder[i])) {\n          exports.add(*exportId);\n        }\n      } else {\n        capTableBuilder[i].setNone();\n      }\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "auto payload = call.getParams();"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "capTableBuilder[i].setNone",
          "args": [],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exports.add",
          "args": [
            "*exportId"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exportId",
            "writeDescriptor(**cap, capTableBuilder[i])"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "writeDescriptor",
          "args": [
            "**cap",
            "capTableBuilder[i]"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "writeDescriptor",
          "container": "RpcConnectionState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "978-989",
          "snippet": "kj::Maybe<ExportId> writeDescriptor(ClientHook& cap, rpc::CapDescriptor::Builder descriptor) {\n    // Write a descriptor for the given capability.\n\n    // Find the innermost wrapped capability.\n    ClientHook* inner = &cap;\n    for (;;) {\n      KJ_IF_MAYBE(resolved, inner->getResolved()) {\n        inner = resolved;\n      } else {\n        break;\n      }\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  kj::Maybe<ExportId> writeDescriptor(ClientHook& cap, rpc::CapDescriptor::Builder descriptor) {\n      // Write a descriptor for the given capability.\n  \n      // Find the innermost wrapped capability.\n      ClientHook* inner = &cap;\n      for (;;) {\n        KJ_IF_MAYBE(resolved, inner->getResolved()) {\n          inner = resolved;\n        } else {\n          break;\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "capTable"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "capTable.size",
          "args": [],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "payload.initCapTable",
          "args": [
            "capTable.size()"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "initCapTable",
          "container": "ReaderArena",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
          "lines": "217-222",
          "snippet": "inline void initCapTable(kj::Array<kj::Maybe<kj::Own<ClientHook>>> capTable) {\n    // Imbues the arena with a capability table.  This is not passed to the constructor because the\n    // table itself may be built based on some other part of the message (as is the case with the\n    // RPC protocol).\n    this->capTable = kj::mv(capTable);\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <unordered_map>",
            "#include \"layout.h\"",
            "#include \"message.h\"",
            "#include \"common.h\"",
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/mutex.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\nReaderArena {\n  inline void initCapTable(kj::Array<kj::Maybe<kj::Own<ClientHook>>> capTable) {\n      // Imbues the arena with a capability table.  This is not passed to the constructor because the\n      // table itself may be built based on some other part of the message (as is the case with the\n      // RPC protocol).\n      this->capTable = kj::mv(capTable);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto payload = call.getParams();\n\nkj::Array<ExportId> writeDescriptors(kj::ArrayPtr<kj::Maybe<kj::Own<ClientHook>>> capTable,\n                                       rpc::Payload::Builder payload) {\n    auto capTableBuilder = payload.initCapTable(capTable.size());\n    kj::Vector<ExportId> exports(capTable.size());\n    for (uint i: kj::indices(capTable)) {\n      KJ_IF_MAYBE(cap, capTable[i]) {\n        KJ_IF_MAYBE(exportId, writeDescriptor(**cap, capTableBuilder[i])) {\n          exports.add(*exportId);\n        }\n      } else {\n        capTableBuilder[i].setNone();\n      }\n    }"
  },
  {
    "function_name": "writeDescriptor",
    "container": "RpcConnectionState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "978-989",
    "snippet": "kj::Maybe<ExportId> writeDescriptor(ClientHook& cap, rpc::CapDescriptor::Builder descriptor) {\n    // Write a descriptor for the given capability.\n\n    // Find the innermost wrapped capability.\n    ClientHook* inner = &cap;\n    for (;;) {\n      KJ_IF_MAYBE(resolved, inner->getResolved()) {\n        inner = resolved;\n      } else {\n        break;\n      }\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "resolved",
            "inner->getResolved()"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "inner->getResolved",
          "args": [],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "getResolved",
          "container": "RpcConnectionState::NoInterceptClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "966-968",
          "snippet": "kj::Maybe<ClientHook&> getResolved() override {\n      return nullptr;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  NoInterceptClient {\n    kj::Maybe<ClientHook&> getResolved() override {\n          return nullptr;\n        }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  kj::Maybe<ExportId> writeDescriptor(ClientHook& cap, rpc::CapDescriptor::Builder descriptor) {\n      // Write a descriptor for the given capability.\n  \n      // Find the innermost wrapped capability.\n      ClientHook* inner = &cap;\n      for (;;) {\n        KJ_IF_MAYBE(resolved, inner->getResolved()) {\n          inner = resolved;\n        } else {\n          break;\n        }\n      }\n}"
  },
  {
    "function_name": "whenMoreResolved",
    "container": "RpcConnectionState::NoInterceptClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "970-972",
    "snippet": "kj::Maybe<kj::Promise<kj::Own<ClientHook>>> whenMoreResolved() override {\n      return nullptr;\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  NoInterceptClient {\n    kj::Maybe<kj::Promise<kj::Own<ClientHook>>> whenMoreResolved() override {\n          return nullptr;\n        }\n  }\n}"
  },
  {
    "function_name": "getResolved",
    "container": "RpcConnectionState::NoInterceptClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "966-968",
    "snippet": "kj::Maybe<ClientHook&> getResolved() override {\n      return nullptr;\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  NoInterceptClient {\n    kj::Maybe<ClientHook&> getResolved() override {\n          return nullptr;\n        }\n  }\n}"
  },
  {
    "function_name": "call",
    "container": "RpcConnectionState::NoInterceptClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "961-964",
    "snippet": "VoidPromiseAndPipeline call(uint64_t interfaceId, uint16_t methodId,\n                                kj::Own<CallContextHook>&& context) override {\n      return inner->callNoIntercept(interfaceId, methodId, kj::mv(context));\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "auto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inner->callNoIntercept",
          "args": [
            "interfaceId",
            "methodId",
            "kj::mv(context)"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "callNoIntercept",
          "container": "RpcConnectionState::RpcClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "641-655",
          "snippet": "VoidPromiseAndPipeline callNoIntercept(uint64_t interfaceId, uint16_t methodId,\n                                           kj::Own<CallContextHook>&& context) {\n      // Implement call() by copying params and results messages.\n\n      auto params = context->getParams();\n      auto request = newCall(interfaceId, methodId, params.targetSize());\n\n      request.set(params);\n      context->releaseParams();\n\n      // We can and should propagate cancellation.\n      context->allowCancellation();\n\n      return context->directTailCall(RequestHook::from(kj::mv(request)));\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "auto results = response->getResultsBuilder();",
            "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
            "AnyPointer::Reader params;",
            "auto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto results = response->getResultsBuilder();\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nAnyPointer::Reader params;\nauto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));\n\nRpcConnectionState {\n  RpcClient {\n    VoidPromiseAndPipeline callNoIntercept(uint64_t interfaceId, uint16_t methodId,\n                                               kj::Own<CallContextHook>&& context) {\n          // Implement call() by copying params and results messages.\n    \n          auto params = context->getParams();\n          auto request = newCall(interfaceId, methodId, params.targetSize());\n    \n          request.set(params);\n          context->releaseParams();\n    \n          // We can and should propagate cancellation.\n          context->allowCancellation();\n    \n          return context->directTailCall(RequestHook::from(kj::mv(request)));\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "context"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));\n\nRpcConnectionState {\n  NoInterceptClient {\n    VoidPromiseAndPipeline call(uint64_t interfaceId, uint16_t methodId,\n                                    kj::Own<CallContextHook>&& context) override {\n          return inner->callNoIntercept(interfaceId, methodId, kj::mv(context));\n        }\n  }\n}"
  },
  {
    "function_name": "newCall",
    "container": "RpcConnectionState::NoInterceptClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "957-960",
    "snippet": "Request<AnyPointer, AnyPointer> newCall(\n        uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) override {\n      return inner->newCallNoIntercept(interfaceId, methodId, sizeHint);\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inner->newCallNoIntercept",
          "args": [
            "interfaceId",
            "methodId",
            "sizeHint"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "newCallNoIntercept",
          "container": "RpcConnectionState::RpcClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "598-614",
          "snippet": "Request<AnyPointer, AnyPointer> newCallNoIntercept(\n        uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) {\n      if (!connectionState->connection.is<Connected>()) {\n        return newBrokenRequest(kj::cp(connectionState->connection.get<Disconnected>()), sizeHint);\n      }\n\n      auto request = kj::heap<RpcRequest>(\n          *connectionState, *connectionState->connection.get<Connected>(),\n          sizeHint, kj::addRef(*this));\n      auto callBuilder = request->getCall();\n\n      callBuilder.setInterfaceId(interfaceId);\n      callBuilder.setMethodId(methodId);\n\n      auto root = request->getRoot();\n      return Request<AnyPointer, AnyPointer>(root, kj::mv(request));\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<IncomingRpcMessage>> request;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\n\nRpcConnectionState {\n  RpcClient {\n    Request<AnyPointer, AnyPointer> newCallNoIntercept(\n            uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) {\n          if (!connectionState->connection.is<Connected>()) {\n            return newBrokenRequest(kj::cp(connectionState->connection.get<Disconnected>()), sizeHint);\n          }\n    \n          auto request = kj::heap<RpcRequest>(\n              *connectionState, *connectionState->connection.get<Connected>(),\n              sizeHint, kj::addRef(*this));\n          auto callBuilder = request->getCall();\n    \n          callBuilder.setInterfaceId(interfaceId);\n          callBuilder.setMethodId(methodId);\n    \n          auto root = request->getRoot();\n          return Request<AnyPointer, AnyPointer>(root, kj::mv(request));\n        }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  NoInterceptClient {\n    Request<AnyPointer, AnyPointer> newCall(\n            uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) override {\n          return inner->newCallNoIntercept(interfaceId, methodId, sizeHint);\n        }\n  }\n}"
  },
  {
    "function_name": "getInnermostClient",
    "container": "RpcConnectionState::NoInterceptClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "953-955",
    "snippet": "kj::Own<ClientHook> getInnermostClient() override {\n      return inner->getInnermostClient();\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  NoInterceptClient {\n    kj::Own<ClientHook> getInnermostClient() override {\n          return inner->getInnermostClient();\n        }\n  }\n}"
  },
  {
    "function_name": "writeTarget",
    "container": "RpcConnectionState::NoInterceptClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "949-951",
    "snippet": "kj::Maybe<kj::Own<ClientHook>> writeTarget(rpc::MessageTarget::Builder target) override {\n      return inner->writeTarget(target);\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  NoInterceptClient {\n    kj::Maybe<kj::Own<ClientHook>> writeTarget(rpc::MessageTarget::Builder target) override {\n          return inner->writeTarget(target);\n        }\n  }\n}"
  },
  {
    "function_name": "writeDescriptor",
    "container": "RpcConnectionState::NoInterceptClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "945-947",
    "snippet": "kj::Maybe<ExportId> writeDescriptor(rpc::CapDescriptor::Builder descriptor) override {\n      return inner->writeDescriptor(descriptor);\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  NoInterceptClient {\n    kj::Maybe<ExportId> writeDescriptor(rpc::CapDescriptor::Builder descriptor) override {\n          return inner->writeDescriptor(descriptor);\n        }\n  }\n}"
  },
  {
    "function_name": "NoInterceptClient",
    "container": "RpcConnectionState::NoInterceptClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "941-943",
    "snippet": "NoInterceptClient(RpcClient& inner)\n        : RpcClient(*inner.connectionState),\n          inner(kj::addRef(inner)) {}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "inner"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  NoInterceptClient {\n    NoInterceptClient(RpcClient& inner)\n            : RpcClient(*inner.connectionState),\n              inner(kj::addRef(inner)) {}\n  }\n}"
  },
  {
    "function_name": "resolve",
    "container": "RpcConnectionState::PromiseClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "883-926",
    "snippet": "void resolve(kj::Own<ClientHook> replacement, bool isError) {\n      if (replacement->getBrand() != connectionState.get() && receivedCall && !isError &&\n          connectionState->connection.is<Connected>()) {\n        // The new capability is hosted locally, not on the remote machine.  And, we had made calls\n        // to the promise.  We need to make sure those calls echo back to us before we allow new\n        // calls to go directly to the local capability, so we need to set a local embargo and send\n        // a `Disembargo` to echo through the peer.\n\n        auto message = connectionState->connection.get<Connected>()->newOutgoingMessage(\n            messageSizeHint<rpc::Disembargo>() + MESSAGE_TARGET_SIZE_HINT);\n\n        auto disembargo = message->getBody().initAs<rpc::Message>().initDisembargo();\n\n        {\n          auto redirect = connectionState->writeTarget(*cap, disembargo.initTarget());\n          KJ_ASSERT(redirect == nullptr,\n                    \"Original promise target should always be from this RPC connection.\");\n        }\n\n        EmbargoId embargoId;\n        Embargo& embargo = connectionState->embargoes.next(embargoId);\n\n        disembargo.getContext().setSenderLoopback(embargoId);\n\n        auto paf = kj::newPromiseAndFulfiller<void>();\n        embargo.fulfiller = kj::mv(paf.fulfiller);\n\n        // Make a promise which resolves to `replacement` as soon as the `Disembargo` comes back.\n        auto embargoPromise = paf.promise.then(\n            kj::mvCapture(replacement, [this](kj::Own<ClientHook>&& replacement) {\n              return kj::mv(replacement);\n            }));\n\n        // We need to queue up calls in the meantime, so we'll resolve ourselves to a local promise\n        // client instead.\n        replacement = newLocalPromiseClient(kj::mv(embargoPromise));\n\n        // Send the `Disembargo`.\n        message->send();\n      }\n\n      cap = replacement->addRef();\n      isResolved = true;\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "replacement->addRef",
          "args": [],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": "SingleCapPipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2064-2066",
          "snippet": "kj::Own<PipelineHook> addRef() override {\n      return kj::addRef(*this);\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nSingleCapPipeline {\n  kj::Own<PipelineHook> addRef() override {\n        return kj::addRef(*this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "message->send",
          "args": [],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "newLocalPromiseClient",
          "args": [
            "kj::mv(embargoPromise)"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "newLocalPromiseClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "534-536",
          "snippet": "kj::Own<ClientHook> newLocalPromiseClient(kj::Promise<kj::Own<ClientHook>>&& promise) {\n  return kj::refcounted<QueuedClient>(kj::mv(promise));\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> newLocalPromiseClient(kj::Promise<kj::Own<ClientHook>>&& promise) {\n  return kj::refcounted<QueuedClient>(kj::mv(promise));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "embargoPromise"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "kj::mvCapture(replacement, [this](kj::Own<ClientHook>&& replacement) {\n              return kj::mv(replacement);\n            })"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mvCapture",
          "args": [
            "replacement",
            "[this](kj::Own<ClientHook>&& replacement) {\n              return kj::mv(replacement);\n            }"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "replacement"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<void>",
          "args": [],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      },
      {
        "call_info": {
          "callee": "disembargo.getContext",
          "args": [
            "embargoId"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disembargo.getContext",
          "args": [],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectionState->embargoes.next",
          "args": [
            "embargoId"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "redirect == nullptr",
            "\"Original promise target should always be from this RPC connection.\""
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectionState->writeTarget",
          "args": [
            "*cap",
            "disembargo.initTarget()"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "writeTarget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1038-1054",
          "snippet": "kj::Maybe<kj::Own<ClientHook>> writeTarget(ClientHook& cap, rpc::MessageTarget::Builder target) {\n    // If calls to the given capability should pass over this connection, fill in `target`\n    // appropriately for such a call and return nullptr.  Otherwise, return a `ClientHook` to which\n    // the call should be forwarded; the caller should then delegate the call to that `ClientHook`.\n    //\n    // The main case where this ends up returning non-null is if `cap` is a promise that has\n    // recently resolved.  The application might have started building a request before the promise\n    // resolved, and so the request may have been built on the assumption that it would be sent over\n    // this network connection, but then the promise resolved to point somewhere else before the\n    // request was sent.  Now the request has to be redirected to the new target instead.\n\n    if (cap.getBrand() == this) {\n      return kj::downcast<RpcClient>(cap).writeTarget(target);\n    } else {\n      return cap.addRef();\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<IncomingRpcMessage>> request;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\n\nkj::Maybe<kj::Own<ClientHook>> writeTarget(ClientHook& cap, rpc::MessageTarget::Builder target) {\n    // If calls to the given capability should pass over this connection, fill in `target`\n    // appropriately for such a call and return nullptr.  Otherwise, return a `ClientHook` to which\n    // the call should be forwarded; the caller should then delegate the call to that `ClientHook`.\n    //\n    // The main case where this ends up returning non-null is if `cap` is a promise that has\n    // recently resolved.  The application might have started building a request before the promise\n    // resolved, and so the request may have been built on the assumption that it would be sent over\n    // this network connection, but then the promise resolved to point somewhere else before the\n    // request was sent.  Now the request has to be redirected to the new target instead.\n\n    if (cap.getBrand() == this) {\n      return kj::downcast<RpcClient>(cap).writeTarget(target);\n    } else {\n      return cap.addRef();\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "disembargo.initTarget",
          "args": [],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message->getBody",
          "args": [],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "getBody",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "106-108",
          "snippet": "AnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nAnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "connectionState->connection.get<Connected>",
          "args": [
            "messageSizeHint<rpc::Disembargo>() + MESSAGE_TARGET_SIZE_HINT"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "messageSizeHint<rpc::Disembargo>",
          "args": [],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "messageSizeHint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "40-42",
          "snippet": "inline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\ninline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}"
        }
      },
      {
        "call_info": {
          "callee": "connectionState->connection.get<Connected>",
          "args": [],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "connectionState->connection.is<Connected>",
          "args": [],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "replacement->getBrand",
          "args": [],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  PromiseClient {\n    void resolve(kj::Own<ClientHook> replacement, bool isError) {\n          if (replacement->getBrand() != connectionState.get() && receivedCall && !isError &&\n              connectionState->connection.is<Connected>()) {\n            // The new capability is hosted locally, not on the remote machine.  And, we had made calls\n            // to the promise.  We need to make sure those calls echo back to us before we allow new\n            // calls to go directly to the local capability, so we need to set a local embargo and send\n            // a `Disembargo` to echo through the peer.\n    \n            auto message = connectionState->connection.get<Connected>()->newOutgoingMessage(\n                messageSizeHint<rpc::Disembargo>() + MESSAGE_TARGET_SIZE_HINT);\n    \n            auto disembargo = message->getBody().initAs<rpc::Message>().initDisembargo();\n    \n            {\n              auto redirect = connectionState->writeTarget(*cap, disembargo.initTarget());\n              KJ_ASSERT(redirect == nullptr,\n                        \"Original promise target should always be from this RPC connection.\");\n            }\n    \n            EmbargoId embargoId;\n            Embargo& embargo = connectionState->embargoes.next(embargoId);\n    \n            disembargo.getContext().setSenderLoopback(embargoId);\n    \n            auto paf = kj::newPromiseAndFulfiller<void>();\n            embargo.fulfiller = kj::mv(paf.fulfiller);\n    \n            // Make a promise which resolves to `replacement` as soon as the `Disembargo` comes back.\n            auto embargoPromise = paf.promise.then(\n                kj::mvCapture(replacement, [this](kj::Own<ClientHook>&& replacement) {\n                  return kj::mv(replacement);\n                }));\n    \n            // We need to queue up calls in the meantime, so we'll resolve ourselves to a local promise\n            // client instead.\n            replacement = newLocalPromiseClient(kj::mv(embargoPromise));\n    \n            // Send the `Disembargo`.\n            message->send();\n          }\n    \n          cap = replacement->addRef();\n          isResolved = true;\n        }\n  }\n}"
  },
  {
    "function_name": "whenMoreResolved",
    "container": "RpcConnectionState::PromiseClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "866-868",
    "snippet": "kj::Maybe<kj::Promise<kj::Own<ClientHook>>> whenMoreResolved() override {\n      return fork.addBranch();\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fork.addBranch",
          "args": [],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "addBranch",
          "container": "ForkHub",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "396-398",
          "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  PromiseClient {\n    kj::Maybe<kj::Promise<kj::Own<ClientHook>>> whenMoreResolved() override {\n          return fork.addBranch();\n        }\n  }\n}"
  },
  {
    "function_name": "getResolved",
    "container": "RpcConnectionState::PromiseClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "858-864",
    "snippet": "kj::Maybe<ClientHook&> getResolved() override {\n      if (isResolved) {\n        return *cap;\n      } else {\n        return nullptr;\n      }\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  PromiseClient {\n    kj::Maybe<ClientHook&> getResolved() override {\n          if (isResolved) {\n            return *cap;\n          } else {\n            return nullptr;\n          }\n        }\n  }\n}"
  },
  {
    "function_name": "call",
    "container": "RpcConnectionState::PromiseClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "852-856",
    "snippet": "VoidPromiseAndPipeline call(uint64_t interfaceId, uint16_t methodId,\n                                kj::Own<CallContextHook>&& context) override {\n      receivedCall = true;\n      return cap->call(interfaceId, methodId, kj::mv(context));\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "auto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "context"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));\n\nRpcConnectionState {\n  PromiseClient {\n    VoidPromiseAndPipeline call(uint64_t interfaceId, uint16_t methodId,\n                                    kj::Own<CallContextHook>&& context) override {\n          receivedCall = true;\n          return cap->call(interfaceId, methodId, kj::mv(context));\n        }\n  }\n}"
  },
  {
    "function_name": "newCall",
    "container": "RpcConnectionState::PromiseClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "846-850",
    "snippet": "Request<AnyPointer, AnyPointer> newCall(\n        uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) override {\n      receivedCall = true;\n      return cap->newCall(interfaceId, methodId, sizeHint);\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  PromiseClient {\n    Request<AnyPointer, AnyPointer> newCall(\n            uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) override {\n          receivedCall = true;\n          return cap->newCall(interfaceId, methodId, sizeHint);\n        }\n  }\n}"
  },
  {
    "function_name": "getInnermostClient",
    "container": "RpcConnectionState::PromiseClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "839-842",
    "snippet": "kj::Own<ClientHook> getInnermostClient() override {\n      receivedCall = true;\n      return connectionState->getInnermostClient(*cap);\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  PromiseClient {\n    kj::Own<ClientHook> getInnermostClient() override {\n          receivedCall = true;\n          return connectionState->getInnermostClient(*cap);\n        }\n  }\n}"
  },
  {
    "function_name": "writeTarget",
    "container": "RpcConnectionState::PromiseClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "833-837",
    "snippet": "kj::Maybe<kj::Own<ClientHook>> writeTarget(\n        rpc::MessageTarget::Builder target) override {\n      receivedCall = true;\n      return connectionState->writeTarget(*cap, target);\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  PromiseClient {\n    kj::Maybe<kj::Own<ClientHook>> writeTarget(\n            rpc::MessageTarget::Builder target) override {\n          receivedCall = true;\n          return connectionState->writeTarget(*cap, target);\n        }\n  }\n}"
  },
  {
    "function_name": "writeDescriptor",
    "container": "RpcConnectionState::PromiseClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "828-831",
    "snippet": "kj::Maybe<ExportId> writeDescriptor(rpc::CapDescriptor::Builder descriptor) override {\n      receivedCall = true;\n      return connectionState->writeDescriptor(*cap, descriptor);\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  PromiseClient {\n    kj::Maybe<ExportId> writeDescriptor(rpc::CapDescriptor::Builder descriptor) override {\n          receivedCall = true;\n          return connectionState->writeDescriptor(*cap, descriptor);\n        }\n  }\n}"
  },
  {
    "function_name": "PromiseClient",
    "container": "RpcConnectionState::PromiseClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "785-810",
    "snippet": "PromiseClient(RpcConnectionState& connectionState,\n                  kj::Own<ClientHook> initial,\n                  kj::Promise<kj::Own<ClientHook>> eventual,\n                  kj::Maybe<ImportId> importId)\n        : RpcClient(connectionState),\n          isResolved(false),\n          cap(kj::mv(initial)),\n          importId(importId),\n          fork(eventual.fork()),\n          resolveSelfPromise(fork.addBranch().then(\n              [this](kj::Own<ClientHook>&& resolution) {\n                resolve(kj::mv(resolution), false);\n              }, [this](kj::Exception&& exception) {\n                resolve(newBrokenCap(kj::mv(exception)), true);\n              }).eagerlyEvaluate([&](kj::Exception&& e) {\n                // Make any exceptions thrown from resolve() go to the connection's TaskSet which\n                // will cause the connection to be terminated.\n                connectionState.tasks.add(kj::mv(e));\n              })) {\n      // Create a client that starts out forwarding all calls to `initial` but, once `eventual`\n      // resolves, will forward there instead.  In addition, `whenMoreResolved()` will return a fork\n      // of `eventual`.  Note that this means the application could hold on to `eventual` even after\n      // the `PromiseClient` is destroyed; `eventual` must therefore make sure to hold references to\n      // anything that needs to stay alive in order to resolve it correctly (such as making sure the\n      // import ID is not released).\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fork.addBranch",
          "args": [
            "[&](kj::Exception&& e) {\n                // Make any exceptions thrown from resolve() go to the connection's TaskSet which\n                // will cause the connection to be terminated.\n                connectionState.tasks.add(kj::mv(e));\n              }"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectionState.tasks.add",
          "args": [
            "kj::mv(e)"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "e"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork.addBranch",
          "args": [
            "[this](kj::Own<ClientHook>&& resolution) {\n                resolve(kj::mv(resolution), false);\n              }",
            "[this](kj::Exception&& exception) {\n                resolve(newBrokenCap(kj::mv(exception)), true);\n              }"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolve",
          "args": [
            "newBrokenCap(kj::mv(exception))",
            "true"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newBrokenCap",
          "args": [
            "kj::mv(exception)"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "newBrokenCap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "620-622",
          "snippet": "kj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolve",
          "args": [
            "kj::mv(resolution)",
            "false"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "resolution"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork.addBranch",
          "args": [],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "addBranch",
          "container": "ForkHub",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "396-398",
          "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "eventual.fork",
          "args": [],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "initial"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  PromiseClient {\n    PromiseClient(RpcConnectionState& connectionState,\n                      kj::Own<ClientHook> initial,\n                      kj::Promise<kj::Own<ClientHook>> eventual,\n                      kj::Maybe<ImportId> importId)\n            : RpcClient(connectionState),\n              isResolved(false),\n              cap(kj::mv(initial)),\n              importId(importId),\n              fork(eventual.fork()),\n              resolveSelfPromise(fork.addBranch().then(\n                  [this](kj::Own<ClientHook>&& resolution) {\n                    resolve(kj::mv(resolution), false);\n                  }, [this](kj::Exception&& exception) {\n                    resolve(newBrokenCap(kj::mv(exception)), true);\n                  }).eagerlyEvaluate([&](kj::Exception&& e) {\n                    // Make any exceptions thrown from resolve() go to the connection's TaskSet which\n                    // will cause the connection to be terminated.\n                    connectionState.tasks.add(kj::mv(e));\n                  })) {\n          // Create a client that starts out forwarding all calls to `initial` but, once `eventual`\n          // resolves, will forward there instead.  In addition, `whenMoreResolved()` will return a fork\n          // of `eventual`.  Note that this means the application could hold on to `eventual` even after\n          // the `PromiseClient` is destroyed; `eventual` must therefore make sure to hold references to\n          // anything that needs to stay alive in order to resolve it correctly (such as making sure the\n          // import ID is not released).\n        }\n  }\n}"
  },
  {
    "function_name": "whenMoreResolved",
    "container": "RpcConnectionState::PipelineClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "771-773",
    "snippet": "kj::Maybe<kj::Promise<kj::Own<ClientHook>>> whenMoreResolved() override {\n      return nullptr;\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  PipelineClient {\n    kj::Maybe<kj::Promise<kj::Own<ClientHook>>> whenMoreResolved() override {\n          return nullptr;\n        }\n  }\n}"
  },
  {
    "function_name": "getResolved",
    "container": "RpcConnectionState::PipelineClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "767-769",
    "snippet": "kj::Maybe<ClientHook&> getResolved() override {\n      return nullptr;\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  PipelineClient {\n    kj::Maybe<ClientHook&> getResolved() override {\n          return nullptr;\n        }\n  }\n}"
  },
  {
    "function_name": "getInnermostClient",
    "container": "RpcConnectionState::PipelineClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "761-763",
    "snippet": "kj::Own<ClientHook> getInnermostClient() override {\n      return kj::addRef(*this);\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  PipelineClient {\n    kj::Own<ClientHook> getInnermostClient() override {\n          return kj::addRef(*this);\n        }\n  }\n}"
  },
  {
    "function_name": "writeTarget",
    "container": "RpcConnectionState::PipelineClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "753-759",
    "snippet": "kj::Maybe<kj::Own<ClientHook>> writeTarget(\n        rpc::MessageTarget::Builder target) override {\n      auto builder = target.initPromisedAnswer();\n      builder.setQuestionId(questionRef->getId());\n      builder.adoptTransform(fromPipelineOps(Orphanage::getForMessageContaining(builder), ops));\n      return nullptr;\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.adoptTransform",
          "args": [
            "fromPipelineOps(Orphanage::getForMessageContaining(builder), ops)"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fromPipelineOps",
          "args": [
            "Orphanage::getForMessageContaining(builder)",
            "ops"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "fromPipelineOps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "91-107",
          "snippet": "Orphan<List<rpc::PromisedAnswer::Op>> fromPipelineOps(\n    Orphanage orphanage, kj::ArrayPtr<const PipelineOp> ops) {\n  auto result = orphanage.newOrphan<List<rpc::PromisedAnswer::Op>>(ops.size());\n  auto builder = result.get();\n  for (uint i: kj::indices(ops)) {\n    rpc::PromisedAnswer::Op::Builder opBuilder = builder[i];\n    switch (ops[i].type) {\n      case PipelineOp::NOOP:\n        opBuilder.setNoop();\n        break;\n      case PipelineOp::GET_POINTER_FIELD:\n        opBuilder.setGetPointerField(ops[i].pointerIndex);\n        break;\n    }\n  }\n  return result;\n}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nOrphan<List<rpc::PromisedAnswer::Op>> fromPipelineOps(\n    Orphanage orphanage, kj::ArrayPtr<const PipelineOp> ops) {\n  auto result = orphanage.newOrphan<List<rpc::PromisedAnswer::Op>>(ops.size());\n  auto builder = result.get();\n  for (uint i: kj::indices(ops)) {\n    rpc::PromisedAnswer::Op::Builder opBuilder = builder[i];\n    switch (ops[i].type) {\n      case PipelineOp::NOOP:\n        opBuilder.setNoop();\n        break;\n      case PipelineOp::GET_POINTER_FIELD:\n        opBuilder.setGetPointerField(ops[i].pointerIndex);\n        break;\n    }\n  }\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Orphanage::getForMessageContaining",
          "args": [
            "builder"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "Orphanage::getForMessageContaining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/orphan.h",
          "lines": "279-281",
          "snippet": "Orphanage Orphanage::getForMessageContaining(BuilderType builder) {\n  return Orphanage(GetInnerBuilder<FromBuilder<BuilderType>>::apply(builder).getArena());\n}",
          "includes": [
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n\nOrphanage Orphanage::getForMessageContaining(BuilderType builder) {\n  return Orphanage(GetInnerBuilder<FromBuilder<BuilderType>>::apply(builder).getArena());\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.setQuestionId",
          "args": [
            "questionRef->getId()"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "questionRef->getId",
          "args": [],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "target.initPromisedAnswer",
          "args": [],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  PipelineClient {\n    kj::Maybe<kj::Own<ClientHook>> writeTarget(\n            rpc::MessageTarget::Builder target) override {\n          auto builder = target.initPromisedAnswer();\n          builder.setQuestionId(questionRef->getId());\n          builder.adoptTransform(fromPipelineOps(Orphanage::getForMessageContaining(builder), ops));\n          return nullptr;\n        }\n  }\n}"
  },
  {
    "function_name": "writeDescriptor",
    "container": "RpcConnectionState::PipelineClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "745-751",
    "snippet": "kj::Maybe<ExportId> writeDescriptor(rpc::CapDescriptor::Builder descriptor) override {\n      auto promisedAnswer = descriptor.initReceiverAnswer();\n      promisedAnswer.setQuestionId(questionRef->getId());\n      promisedAnswer.adoptTransform(fromPipelineOps(\n          Orphanage::getForMessageContaining(descriptor), ops));\n      return nullptr;\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promisedAnswer.adoptTransform",
          "args": [
            "fromPipelineOps(\n          Orphanage::getForMessageContaining(descriptor), ops)"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fromPipelineOps",
          "args": [
            "Orphanage::getForMessageContaining(descriptor)",
            "ops"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "fromPipelineOps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "91-107",
          "snippet": "Orphan<List<rpc::PromisedAnswer::Op>> fromPipelineOps(\n    Orphanage orphanage, kj::ArrayPtr<const PipelineOp> ops) {\n  auto result = orphanage.newOrphan<List<rpc::PromisedAnswer::Op>>(ops.size());\n  auto builder = result.get();\n  for (uint i: kj::indices(ops)) {\n    rpc::PromisedAnswer::Op::Builder opBuilder = builder[i];\n    switch (ops[i].type) {\n      case PipelineOp::NOOP:\n        opBuilder.setNoop();\n        break;\n      case PipelineOp::GET_POINTER_FIELD:\n        opBuilder.setGetPointerField(ops[i].pointerIndex);\n        break;\n    }\n  }\n  return result;\n}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nOrphan<List<rpc::PromisedAnswer::Op>> fromPipelineOps(\n    Orphanage orphanage, kj::ArrayPtr<const PipelineOp> ops) {\n  auto result = orphanage.newOrphan<List<rpc::PromisedAnswer::Op>>(ops.size());\n  auto builder = result.get();\n  for (uint i: kj::indices(ops)) {\n    rpc::PromisedAnswer::Op::Builder opBuilder = builder[i];\n    switch (ops[i].type) {\n      case PipelineOp::NOOP:\n        opBuilder.setNoop();\n        break;\n      case PipelineOp::GET_POINTER_FIELD:\n        opBuilder.setGetPointerField(ops[i].pointerIndex);\n        break;\n    }\n  }\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Orphanage::getForMessageContaining",
          "args": [
            "descriptor"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "Orphanage::getForMessageContaining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/orphan.h",
          "lines": "279-281",
          "snippet": "Orphanage Orphanage::getForMessageContaining(BuilderType builder) {\n  return Orphanage(GetInnerBuilder<FromBuilder<BuilderType>>::apply(builder).getArena());\n}",
          "includes": [
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n\nOrphanage Orphanage::getForMessageContaining(BuilderType builder) {\n  return Orphanage(GetInnerBuilder<FromBuilder<BuilderType>>::apply(builder).getArena());\n}"
        }
      },
      {
        "call_info": {
          "callee": "promisedAnswer.setQuestionId",
          "args": [
            "questionRef->getId()"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "questionRef->getId",
          "args": [],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "descriptor.initReceiverAnswer",
          "args": [],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  PipelineClient {\n    kj::Maybe<ExportId> writeDescriptor(rpc::CapDescriptor::Builder descriptor) override {\n          auto promisedAnswer = descriptor.initReceiverAnswer();\n          promisedAnswer.setQuestionId(questionRef->getId());\n          promisedAnswer.adoptTransform(fromPipelineOps(\n              Orphanage::getForMessageContaining(descriptor), ops));\n          return nullptr;\n        }\n  }\n}"
  },
  {
    "function_name": "PipelineClient",
    "container": "RpcConnectionState::PipelineClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "740-743",
    "snippet": "PipelineClient(RpcConnectionState& connectionState,\n                   kj::Own<QuestionRef>&& questionRef,\n                   kj::Array<PipelineOp>&& ops)\n        : RpcClient(connectionState), questionRef(kj::mv(questionRef)), ops(kj::mv(ops)) {}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "ops"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "questionRef"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  PipelineClient {\n    PipelineClient(RpcConnectionState& connectionState,\n                       kj::Own<QuestionRef>&& questionRef,\n                       kj::Array<PipelineOp>&& ops)\n            : RpcClient(connectionState), questionRef(kj::mv(questionRef)), ops(kj::mv(ops)) {}\n  }\n}"
  },
  {
    "function_name": "whenMoreResolved",
    "container": "RpcConnectionState::ImportClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "723-725",
    "snippet": "kj::Maybe<kj::Promise<kj::Own<ClientHook>>> whenMoreResolved() override {\n      return nullptr;\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  ImportClient {\n    kj::Maybe<kj::Promise<kj::Own<ClientHook>>> whenMoreResolved() override {\n          return nullptr;\n        }\n  }\n}"
  },
  {
    "function_name": "getResolved",
    "container": "RpcConnectionState::ImportClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "719-721",
    "snippet": "kj::Maybe<ClientHook&> getResolved() override {\n      return nullptr;\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  ImportClient {\n    kj::Maybe<ClientHook&> getResolved() override {\n          return nullptr;\n        }\n  }\n}"
  },
  {
    "function_name": "getInnermostClient",
    "container": "RpcConnectionState::ImportClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "713-715",
    "snippet": "kj::Own<ClientHook> getInnermostClient() override {\n      return kj::addRef(*this);\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  ImportClient {\n    kj::Own<ClientHook> getInnermostClient() override {\n          return kj::addRef(*this);\n        }\n  }\n}"
  },
  {
    "function_name": "writeTarget",
    "container": "RpcConnectionState::ImportClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "707-711",
    "snippet": "kj::Maybe<kj::Own<ClientHook>> writeTarget(\n        rpc::MessageTarget::Builder target) override {\n      target.setImportedCap(importId);\n      return nullptr;\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "target.setImportedCap",
          "args": [
            "importId"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  ImportClient {\n    kj::Maybe<kj::Own<ClientHook>> writeTarget(\n            rpc::MessageTarget::Builder target) override {\n          target.setImportedCap(importId);\n          return nullptr;\n        }\n  }\n}"
  },
  {
    "function_name": "writeDescriptor",
    "container": "RpcConnectionState::ImportClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "702-705",
    "snippet": "kj::Maybe<ExportId> writeDescriptor(rpc::CapDescriptor::Builder descriptor) override {\n      descriptor.setReceiverHosted(importId);\n      return nullptr;\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "descriptor.setReceiverHosted",
          "args": [
            "importId"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  ImportClient {\n    kj::Maybe<ExportId> writeDescriptor(rpc::CapDescriptor::Builder descriptor) override {\n          descriptor.setReceiverHosted(importId);\n          return nullptr;\n        }\n  }\n}"
  },
  {
    "function_name": "addRemoteRef",
    "container": "RpcConnectionState::ImportClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "697-700",
    "snippet": "void addRemoteRef() {\n      // Add a new RemoteRef and return a new ref to this client representing it.\n      ++remoteRefcount;\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  ImportClient {\n    void addRemoteRef() {\n          // Add a new RemoteRef and return a new ref to this client representing it.\n          ++remoteRefcount;\n        }\n  }\n}"
  },
  {
    "function_name": "ImportClient",
    "container": "RpcConnectionState::ImportClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "671-672",
    "snippet": "ImportClient(RpcConnectionState& connectionState, ImportId importId)\n        : RpcClient(connectionState), importId(importId) {}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  ImportClient {\n    ImportClient(RpcConnectionState& connectionState, ImportId importId)\n            : RpcClient(connectionState), importId(importId) {}\n  }\n}"
  },
  {
    "function_name": "addRef",
    "container": "RpcConnectionState::RpcClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "657-659",
    "snippet": "kj::Own<ClientHook> addRef() override {\n      return kj::addRef(*this);\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  RpcClient {\n    kj::Own<ClientHook> addRef() override {\n          return kj::addRef(*this);\n        }\n  }\n}"
  },
  {
    "function_name": "callNoIntercept",
    "container": "RpcConnectionState::RpcClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "641-655",
    "snippet": "VoidPromiseAndPipeline callNoIntercept(uint64_t interfaceId, uint16_t methodId,\n                                           kj::Own<CallContextHook>&& context) {\n      // Implement call() by copying params and results messages.\n\n      auto params = context->getParams();\n      auto request = newCall(interfaceId, methodId, params.targetSize());\n\n      request.set(params);\n      context->releaseParams();\n\n      // We can and should propagate cancellation.\n      context->allowCancellation();\n\n      return context->directTailCall(RequestHook::from(kj::mv(request)));\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "auto results = response->getResultsBuilder();",
      "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
      "AnyPointer::Reader params;",
      "auto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "context->directTailCall",
          "args": [
            "RequestHook::from(kj::mv(request))"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RequestHook::from",
          "args": [
            "kj::mv(request)"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "from",
          "container": "RequestHook",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.h",
          "lines": "354-356",
          "snippet": "inline static kj::Own<RequestHook> from(Request<T, U>&& request) {\n    return kj::mv(request.hook);\n  }",
          "includes": [
            "#include \"pointer-helpers.h\"",
            "#include \"any.h\"",
            "#include <kj/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pointer-helpers.h\"\n#include \"any.h\"\n#include <kj/async.h>\n\nRequestHook {\n  inline static kj::Own<RequestHook> from(Request<T, U>&& request) {\n      return kj::mv(request.hook);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "request"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->allowCancellation",
          "args": [],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "allowCancellation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1858-1867",
          "snippet": "void allowCancellation() override {\n      bool previouslyRequestedButNotAllowed = cancellationFlags == CANCEL_REQUESTED;\n      cancellationFlags |= CANCEL_ALLOWED;\n\n      if (previouslyRequestedButNotAllowed) {\n        // We just set CANCEL_ALLOWED, and CANCEL_REQUESTED was already set previously.  Initiate\n        // the cancellation.\n        cancelFulfiller->fulfill();\n      }\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint8_t cancellationFlags = 0;",
            "kj::Own<kj::PromiseFulfiller<void>> cancelFulfiller;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nuint8_t cancellationFlags = 0;\nkj::Own<kj::PromiseFulfiller<void>> cancelFulfiller;\n\nvoid allowCancellation() override {\n      bool previouslyRequestedButNotAllowed = cancellationFlags == CANCEL_REQUESTED;\n      cancellationFlags |= CANCEL_ALLOWED;\n\n      if (previouslyRequestedButNotAllowed) {\n        // We just set CANCEL_ALLOWED, and CANCEL_REQUESTED was already set previously.  Initiate\n        // the cancellation.\n        cancelFulfiller->fulfill();\n      }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "context->releaseParams",
          "args": [],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.set",
          "args": [
            "params"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "newCall",
          "args": [
            "interfaceId",
            "methodId",
            "params.targetSize()"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "newCall",
          "container": "RpcConnectionState::NoInterceptClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "957-960",
          "snippet": "Request<AnyPointer, AnyPointer> newCall(\n        uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) override {\n      return inner->newCallNoIntercept(interfaceId, methodId, sizeHint);\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  NoInterceptClient {\n    Request<AnyPointer, AnyPointer> newCall(\n            uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) override {\n          return inner->newCallNoIntercept(interfaceId, methodId, sizeHint);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.targetSize",
          "args": [],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getParams",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto results = response->getResultsBuilder();\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nAnyPointer::Reader params;\nauto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));\n\nRpcConnectionState {\n  RpcClient {\n    VoidPromiseAndPipeline callNoIntercept(uint64_t interfaceId, uint16_t methodId,\n                                               kj::Own<CallContextHook>&& context) {\n          // Implement call() by copying params and results messages.\n    \n          auto params = context->getParams();\n          auto request = newCall(interfaceId, methodId, params.targetSize());\n    \n          request.set(params);\n          context->releaseParams();\n    \n          // We can and should propagate cancellation.\n          context->allowCancellation();\n    \n          return context->directTailCall(RequestHook::from(kj::mv(request)));\n        }\n  }\n}"
  },
  {
    "function_name": "call",
    "container": "RpcConnectionState::RpcClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "616-639",
    "snippet": "VoidPromiseAndPipeline call(uint64_t interfaceId, uint16_t methodId,\n                                kj::Own<CallContextHook>&& context) override {\n      if (interfaceId == typeId<Persistent<>>() && methodId == 0) {\n        KJ_IF_MAYBE(g, connectionState->gateway) {\n          // Wait, this is a call to Persistent.save() and we need to translate it through our\n          // gateway.\n          auto params = context->getParams().getAs<Persistent<>::SaveParams>();\n\n          auto requestSize = params.totalSize();\n          ++requestSize.capCount;\n          requestSize.wordCount += sizeInWords<RealmGateway<>::ImportParams>();\n\n          auto request = g->importRequest(requestSize);\n          request.setCap(Persistent<>::Client(kj::refcounted<NoInterceptClient>(*this)));\n          request.setParams(params);\n\n          context->allowCancellation();\n          context->releaseParams();\n          return context->directTailCall(RequestHook::from(kj::mv(request)));\n        }\n      }\n\n      return callNoIntercept(interfaceId, methodId, kj::mv(context));\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
      "AnyPointer::Reader params;",
      "auto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "callNoIntercept",
          "args": [
            "interfaceId",
            "methodId",
            "kj::mv(context)"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "callNoIntercept",
          "container": "RpcConnectionState::RpcClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "641-655",
          "snippet": "VoidPromiseAndPipeline callNoIntercept(uint64_t interfaceId, uint16_t methodId,\n                                           kj::Own<CallContextHook>&& context) {\n      // Implement call() by copying params and results messages.\n\n      auto params = context->getParams();\n      auto request = newCall(interfaceId, methodId, params.targetSize());\n\n      request.set(params);\n      context->releaseParams();\n\n      // We can and should propagate cancellation.\n      context->allowCancellation();\n\n      return context->directTailCall(RequestHook::from(kj::mv(request)));\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "auto results = response->getResultsBuilder();",
            "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
            "AnyPointer::Reader params;",
            "auto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto results = response->getResultsBuilder();\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nAnyPointer::Reader params;\nauto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));\n\nRpcConnectionState {\n  RpcClient {\n    VoidPromiseAndPipeline callNoIntercept(uint64_t interfaceId, uint16_t methodId,\n                                               kj::Own<CallContextHook>&& context) {\n          // Implement call() by copying params and results messages.\n    \n          auto params = context->getParams();\n          auto request = newCall(interfaceId, methodId, params.targetSize());\n    \n          request.set(params);\n          context->releaseParams();\n    \n          // We can and should propagate cancellation.\n          context->allowCancellation();\n    \n          return context->directTailCall(RequestHook::from(kj::mv(request)));\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "context"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->directTailCall",
          "args": [
            "RequestHook::from(kj::mv(request))"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RequestHook::from",
          "args": [
            "kj::mv(request)"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "from",
          "container": "RequestHook",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.h",
          "lines": "354-356",
          "snippet": "inline static kj::Own<RequestHook> from(Request<T, U>&& request) {\n    return kj::mv(request.hook);\n  }",
          "includes": [
            "#include \"pointer-helpers.h\"",
            "#include \"any.h\"",
            "#include <kj/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pointer-helpers.h\"\n#include \"any.h\"\n#include <kj/async.h>\n\nRequestHook {\n  inline static kj::Own<RequestHook> from(Request<T, U>&& request) {\n      return kj::mv(request.hook);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "request"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->releaseParams",
          "args": [],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->allowCancellation",
          "args": [],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "allowCancellation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1858-1867",
          "snippet": "void allowCancellation() override {\n      bool previouslyRequestedButNotAllowed = cancellationFlags == CANCEL_REQUESTED;\n      cancellationFlags |= CANCEL_ALLOWED;\n\n      if (previouslyRequestedButNotAllowed) {\n        // We just set CANCEL_ALLOWED, and CANCEL_REQUESTED was already set previously.  Initiate\n        // the cancellation.\n        cancelFulfiller->fulfill();\n      }\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint8_t cancellationFlags = 0;",
            "kj::Own<kj::PromiseFulfiller<void>> cancelFulfiller;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nuint8_t cancellationFlags = 0;\nkj::Own<kj::PromiseFulfiller<void>> cancelFulfiller;\n\nvoid allowCancellation() override {\n      bool previouslyRequestedButNotAllowed = cancellationFlags == CANCEL_REQUESTED;\n      cancellationFlags |= CANCEL_ALLOWED;\n\n      if (previouslyRequestedButNotAllowed) {\n        // We just set CANCEL_ALLOWED, and CANCEL_REQUESTED was already set previously.  Initiate\n        // the cancellation.\n        cancelFulfiller->fulfill();\n      }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "request.setParams",
          "args": [
            "params"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setCap",
          "args": [
            "Persistent<>::Client(kj::refcounted<NoInterceptClient>(*this))"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Persistent<>::Client",
          "args": [
            "kj::refcounted<NoInterceptClient>(*this)"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::refcounted<NoInterceptClient>",
          "args": [
            "*this"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g->importRequest",
          "args": [
            "requestSize"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sizeInWords<RealmGateway<>::ImportParams>",
          "args": [],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.totalSize",
          "args": [],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "totalSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.capnp.h",
          "lines": "558-558",
          "snippet": "inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }"
        }
      },
      {
        "call_info": {
          "callee": "context->getParams",
          "args": [],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getParams",
          "args": [],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "g",
            "connectionState->gateway"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "typeId<Persistent<>>",
          "args": [],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nAnyPointer::Reader params;\nauto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));\n\nRpcConnectionState {\n  RpcClient {\n    VoidPromiseAndPipeline call(uint64_t interfaceId, uint16_t methodId,\n                                    kj::Own<CallContextHook>&& context) override {\n          if (interfaceId == typeId<Persistent<>>() && methodId == 0) {\n            KJ_IF_MAYBE(g, connectionState->gateway) {\n              // Wait, this is a call to Persistent.save() and we need to translate it through our\n              // gateway.\n              auto params = context->getParams().getAs<Persistent<>::SaveParams>();\n    \n              auto requestSize = params.totalSize();\n              ++requestSize.capCount;\n              requestSize.wordCount += sizeInWords<RealmGateway<>::ImportParams>();\n    \n              auto request = g->importRequest(requestSize);\n              request.setCap(Persistent<>::Client(kj::refcounted<NoInterceptClient>(*this)));\n              request.setParams(params);\n    \n              context->allowCancellation();\n              context->releaseParams();\n              return context->directTailCall(RequestHook::from(kj::mv(request)));\n            }\n          }\n    \n          return callNoIntercept(interfaceId, methodId, kj::mv(context));\n        }\n  }\n}"
  },
  {
    "function_name": "newCallNoIntercept",
    "container": "RpcConnectionState::RpcClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "598-614",
    "snippet": "Request<AnyPointer, AnyPointer> newCallNoIntercept(\n        uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) {\n      if (!connectionState->connection.is<Connected>()) {\n        return newBrokenRequest(kj::cp(connectionState->connection.get<Disconnected>()), sizeHint);\n      }\n\n      auto request = kj::heap<RpcRequest>(\n          *connectionState, *connectionState->connection.get<Connected>(),\n          sizeHint, kj::addRef(*this));\n      auto callBuilder = request->getCall();\n\n      callBuilder.setInterfaceId(interfaceId);\n      callBuilder.setMethodId(methodId);\n\n      auto root = request->getRoot();\n      return Request<AnyPointer, AnyPointer>(root, kj::mv(request));\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<IncomingRpcMessage>> request;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Request<AnyPointer, AnyPointer>",
          "args": [
            "root",
            "kj::mv(request)"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "DynamicCapability::Client::newRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic-capability.c++",
          "lines": "50-53",
          "snippet": "Request<DynamicStruct, DynamicStruct> DynamicCapability::Client::newRequest(\n    kj::StringPtr methodName, kj::Maybe<MessageSize> sizeHint) {\n  return newRequest(schema.getMethodByName(methodName), sizeHint);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"dynamic.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"dynamic.h\"\n\nRequest<DynamicStruct, DynamicStruct> DynamicCapability::Client::newRequest(\n    kj::StringPtr methodName, kj::Maybe<MessageSize> sizeHint) {\n  return newRequest(schema.getMethodByName(methodName), sizeHint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "request"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request->getRoot",
          "args": [],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "callBuilder.setMethodId",
          "args": [
            "methodId"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callBuilder.setInterfaceId",
          "args": [
            "interfaceId"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request->getCall",
          "args": [],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "getCall",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1325-1327",
          "snippet": "inline rpc::Call::Builder getCall() {\n      return callBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline rpc::Call::Builder getCall() {\n        return callBuilder;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<RpcRequest>",
          "args": [
            "*connectionState",
            "*connectionState->connection.get<Connected>()",
            "sizeHint",
            "kj::addRef(*this)"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "connectionState->connection.get<Connected>",
          "args": [],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "newBrokenRequest",
          "args": [
            "kj::cp(connectionState->connection.get<Disconnected>())",
            "sizeHint"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "newBrokenRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "628-633",
          "snippet": "Request<AnyPointer, AnyPointer> newBrokenRequest(\n    kj::Exception&& reason, kj::Maybe<MessageSize> sizeHint) {\n  auto hook = kj::heap<BrokenRequest>(kj::mv(reason), sizeHint);\n  auto root = hook->message.getRoot<AnyPointer>();\n  return Request<AnyPointer, AnyPointer>(root, kj::mv(hook));\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nRequest<AnyPointer, AnyPointer> newBrokenRequest(\n    kj::Exception&& reason, kj::Maybe<MessageSize> sizeHint) {\n  auto hook = kj::heap<BrokenRequest>(kj::mv(reason), sizeHint);\n  auto root = hook->message.getRoot<AnyPointer>();\n  return Request<AnyPointer, AnyPointer>(root, kj::mv(hook));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::cp",
          "args": [
            "connectionState->connection.get<Disconnected>()"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "cp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "461-461",
          "snippet": "constexpr T cp(const T& t) noexcept { return t; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nconstexpr T cp(const T& t) noexcept { return t; }"
        }
      },
      {
        "call_info": {
          "callee": "connectionState->connection.is<Connected>",
          "args": [],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\n\nRpcConnectionState {\n  RpcClient {\n    Request<AnyPointer, AnyPointer> newCallNoIntercept(\n            uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) {\n          if (!connectionState->connection.is<Connected>()) {\n            return newBrokenRequest(kj::cp(connectionState->connection.get<Disconnected>()), sizeHint);\n          }\n    \n          auto request = kj::heap<RpcRequest>(\n              *connectionState, *connectionState->connection.get<Connected>(),\n              sizeHint, kj::addRef(*this));\n          auto callBuilder = request->getCall();\n    \n          callBuilder.setInterfaceId(interfaceId);\n          callBuilder.setMethodId(methodId);\n    \n          auto root = request->getRoot();\n          return Request<AnyPointer, AnyPointer>(root, kj::mv(request));\n        }\n  }\n}"
  },
  {
    "function_name": "newCall",
    "container": "RpcConnectionState::RpcClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "561-596",
    "snippet": "Request<AnyPointer, AnyPointer> newCall(\n        uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) override {\n      if (interfaceId == typeId<Persistent<>>() && methodId == 0) {\n        KJ_IF_MAYBE(g, connectionState->gateway) {\n          // Wait, this is a call to Persistent.save() and we need to translate it through our\n          // gateway.\n          //\n          // We pull a neat trick here: We actually end up returning a RequestHook for an import\n          // request on the gateway cap, but with the \"root\" of the request actually pointing\n          // to the \"params\" field of the real request.\n\n          sizeHint = sizeHint.map([](MessageSize hint) {\n            ++hint.capCount;\n            hint.wordCount += sizeInWords<RealmGateway<>::ImportParams>();\n            return hint;\n          });\n\n          auto request = g->importRequest(sizeHint);\n          request.setCap(Persistent<>::Client(kj::refcounted<NoInterceptClient>(*this)));\n\n          // Awkwardly, request.initParams() would return a SaveParams struct, but to construct\n          // the Request<AnyPointer, AnyPointer> to return we need an AnyPointer::Builder, and you\n          // can't go backwards from a struct builder to an AnyPointer builder. So instead we\n          // manually get at the pointer by converting the outer request to AnyStruct and then\n          // pulling the pointer from the pointer section.\n          auto pointers = toAny(request).getPointerSection();\n          KJ_ASSERT(pointers.size() >= 2);\n          auto paramsPtr = pointers[1];\n          KJ_ASSERT(paramsPtr.isNull());\n\n          return Request<AnyPointer, AnyPointer>(paramsPtr, RequestHook::from(kj::mv(request)));\n        }\n      }\n\n      return newCallNoIntercept(interfaceId, methodId, sizeHint);\n    }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
      "AnyPointer::Reader params;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "newCallNoIntercept",
          "args": [
            "interfaceId",
            "methodId",
            "sizeHint"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "newCallNoIntercept",
          "container": "RpcConnectionState::RpcClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "598-614",
          "snippet": "Request<AnyPointer, AnyPointer> newCallNoIntercept(\n        uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) {\n      if (!connectionState->connection.is<Connected>()) {\n        return newBrokenRequest(kj::cp(connectionState->connection.get<Disconnected>()), sizeHint);\n      }\n\n      auto request = kj::heap<RpcRequest>(\n          *connectionState, *connectionState->connection.get<Connected>(),\n          sizeHint, kj::addRef(*this));\n      auto callBuilder = request->getCall();\n\n      callBuilder.setInterfaceId(interfaceId);\n      callBuilder.setMethodId(methodId);\n\n      auto root = request->getRoot();\n      return Request<AnyPointer, AnyPointer>(root, kj::mv(request));\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<IncomingRpcMessage>> request;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\n\nRpcConnectionState {\n  RpcClient {\n    Request<AnyPointer, AnyPointer> newCallNoIntercept(\n            uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) {\n          if (!connectionState->connection.is<Connected>()) {\n            return newBrokenRequest(kj::cp(connectionState->connection.get<Disconnected>()), sizeHint);\n          }\n    \n          auto request = kj::heap<RpcRequest>(\n              *connectionState, *connectionState->connection.get<Connected>(),\n              sizeHint, kj::addRef(*this));\n          auto callBuilder = request->getCall();\n    \n          callBuilder.setInterfaceId(interfaceId);\n          callBuilder.setMethodId(methodId);\n    \n          auto root = request->getRoot();\n          return Request<AnyPointer, AnyPointer>(root, kj::mv(request));\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Request<AnyPointer, AnyPointer>",
          "args": [
            "paramsPtr",
            "RequestHook::from(kj::mv(request))"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "DynamicCapability::Client::newRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic-capability.c++",
          "lines": "50-53",
          "snippet": "Request<DynamicStruct, DynamicStruct> DynamicCapability::Client::newRequest(\n    kj::StringPtr methodName, kj::Maybe<MessageSize> sizeHint) {\n  return newRequest(schema.getMethodByName(methodName), sizeHint);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"dynamic.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"dynamic.h\"\n\nRequest<DynamicStruct, DynamicStruct> DynamicCapability::Client::newRequest(\n    kj::StringPtr methodName, kj::Maybe<MessageSize> sizeHint) {\n  return newRequest(schema.getMethodByName(methodName), sizeHint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RequestHook::from",
          "args": [
            "kj::mv(request)"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "from",
          "container": "RequestHook",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.h",
          "lines": "354-356",
          "snippet": "inline static kj::Own<RequestHook> from(Request<T, U>&& request) {\n    return kj::mv(request.hook);\n  }",
          "includes": [
            "#include \"pointer-helpers.h\"",
            "#include \"any.h\"",
            "#include <kj/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pointer-helpers.h\"\n#include \"any.h\"\n#include <kj/async.h>\n\nRequestHook {\n  inline static kj::Own<RequestHook> from(Request<T, U>&& request) {\n      return kj::mv(request.hook);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "request"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "paramsPtr.isNull()"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paramsPtr.isNull",
          "args": [],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "pointers.size() >= 2"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pointers.size",
          "args": [],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "toAny",
          "args": [],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toAny",
          "args": [
            "request"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "toAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "350-353",
          "snippet": "inline BuilderFor<AnyTypeFor<FromBuilder<T>>> toAny(T&& value) {\n  return BuilderFor<AnyTypeFor<FromBuilder<T>>>(\n      _::PointerHelpers<FromBuilder<T>>::getInternalBuilder(kj::mv(value)));\n}",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline BuilderFor<AnyTypeFor<FromBuilder<T>>> toAny(T&& value) {\n  return BuilderFor<AnyTypeFor<FromBuilder<T>>>(\n      _::PointerHelpers<FromBuilder<T>>::getInternalBuilder(kj::mv(value)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.setCap",
          "args": [
            "Persistent<>::Client(kj::refcounted<NoInterceptClient>(*this))"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Persistent<>::Client",
          "args": [
            "kj::refcounted<NoInterceptClient>(*this)"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::refcounted<NoInterceptClient>",
          "args": [
            "*this"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g->importRequest",
          "args": [
            "sizeHint"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sizeHint.map",
          "args": [
            "[](MessageSize hint) {\n            ++hint.capCount;\n            hint.wordCount += sizeInWords<RealmGateway<>::ImportParams>();\n            return hint;\n          }"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1083-1089",
          "snippet": "auto map(Func&& f) -> Maybe<decltype(f(instance<T&>()))> {\n    if (ptr == nullptr) {\n      return nullptr;\n    } else {\n      return f(*ptr);\n    }\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto map(Func&& f) -> Maybe<decltype(f(instance<T&>()))> {\n    if (ptr == nullptr) {\n      return nullptr;\n    } else {\n      return f(*ptr);\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "sizeInWords<RealmGateway<>::ImportParams>",
          "args": [],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "g",
            "connectionState->gateway"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "typeId<Persistent<>>",
          "args": [],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nAnyPointer::Reader params;\n\nRpcConnectionState {\n  RpcClient {\n    Request<AnyPointer, AnyPointer> newCall(\n            uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) override {\n          if (interfaceId == typeId<Persistent<>>() && methodId == 0) {\n            KJ_IF_MAYBE(g, connectionState->gateway) {\n              // Wait, this is a call to Persistent.save() and we need to translate it through our\n              // gateway.\n              //\n              // We pull a neat trick here: We actually end up returning a RequestHook for an import\n              // request on the gateway cap, but with the \"root\" of the request actually pointing\n              // to the \"params\" field of the real request.\n    \n              sizeHint = sizeHint.map([](MessageSize hint) {\n                ++hint.capCount;\n                hint.wordCount += sizeInWords<RealmGateway<>::ImportParams>();\n                return hint;\n              });\n    \n              auto request = g->importRequest(sizeHint);\n              request.setCap(Persistent<>::Client(kj::refcounted<NoInterceptClient>(*this)));\n    \n              // Awkwardly, request.initParams() would return a SaveParams struct, but to construct\n              // the Request<AnyPointer, AnyPointer> to return we need an AnyPointer::Builder, and you\n              // can't go backwards from a struct builder to an AnyPointer builder. So instead we\n              // manually get at the pointer by converting the outer request to AnyStruct and then\n              // pulling the pointer from the pointer section.\n              auto pointers = toAny(request).getPointerSection();\n              KJ_ASSERT(pointers.size() >= 2);\n              auto paramsPtr = pointers[1];\n              KJ_ASSERT(paramsPtr.isNull());\n    \n              return Request<AnyPointer, AnyPointer>(paramsPtr, RequestHook::from(kj::mv(request)));\n            }\n          }\n    \n          return newCallNoIntercept(interfaceId, methodId, sizeHint);\n        }\n  }\n}"
  },
  {
    "function_name": "RpcClient",
    "container": "RpcConnectionState::RpcClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "533-534",
    "snippet": "RpcClient(RpcConnectionState& connectionState)\n        : connectionState(kj::addRef(connectionState)) {}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "connectionState"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  RpcClient {\n    RpcClient(RpcConnectionState& connectionState)\n            : connectionState(kj::addRef(connectionState)) {}\n  }\n}"
  },
  {
    "function_name": "disconnect",
    "container": "RpcConnectionState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "290-374",
    "snippet": "void disconnect(kj::Exception&& exception) {\n    if (!connection.is<Connected>()) {\n      // Already disconnected.\n      return;\n    }\n\n    kj::Exception networkException(kj::Exception::Type::DISCONNECTED,\n        exception.getFile(), exception.getLine(), kj::heapString(exception.getDescription()));\n\n    KJ_IF_MAYBE(newException, kj::runCatchingExceptions([&]() {\n      // Carefully pull all the objects out of the tables prior to releasing them because their\n      // destructors could come back and mess with the tables.\n      kj::Vector<kj::Own<PipelineHook>> pipelinesToRelease;\n      kj::Vector<kj::Own<ClientHook>> clientsToRelease;\n      kj::Vector<kj::Promise<kj::Own<RpcResponse>>> tailCallsToRelease;\n      kj::Vector<kj::Promise<void>> resolveOpsToRelease;\n\n      // All current questions complete with exceptions.\n      questions.forEach([&](QuestionId id, Question& question) {\n        KJ_IF_MAYBE(questionRef, question.selfRef) {\n          // QuestionRef still present.\n          questionRef->reject(kj::cp(networkException));\n        }\n      });\n\n      answers.forEach([&](AnswerId id, Answer& answer) {\n        KJ_IF_MAYBE(p, answer.pipeline) {\n          pipelinesToRelease.add(kj::mv(*p));\n        }\n\n        KJ_IF_MAYBE(promise, answer.redirectedResults) {\n          tailCallsToRelease.add(kj::mv(*promise));\n        }\n\n        KJ_IF_MAYBE(context, answer.callContext) {\n          context->requestCancel();\n        }\n      });\n\n      exports.forEach([&](ExportId id, Export& exp) {\n        clientsToRelease.add(kj::mv(exp.clientHook));\n        resolveOpsToRelease.add(kj::mv(exp.resolveOp));\n        exp = Export();\n      });\n\n      imports.forEach([&](ImportId id, Import& import) {\n        KJ_IF_MAYBE(f, import.promiseFulfiller) {\n          f->get()->reject(kj::cp(networkException));\n        }\n      });\n\n      embargoes.forEach([&](EmbargoId id, Embargo& embargo) {\n        KJ_IF_MAYBE(f, embargo.fulfiller) {\n          f->get()->reject(kj::cp(networkException));\n        }\n      });\n    })) {\n      // Some destructor must have thrown an exception.  There is no appropriate place to report\n      // these errors.\n      KJ_LOG(ERROR, \"Uncaught exception when destroying capabilities dropped by disconnect.\",\n             *newException);\n    }\n\n    // Send an abort message, but ignore failure.\n    kj::runCatchingExceptions([&]() {\n      auto message = connection.get<Connected>()->newOutgoingMessage(\n          messageSizeHint<void>() + exceptionSizeHint(exception));\n      fromException(exception, message->getBody().getAs<rpc::Message>().initAbort());\n      message->send();\n    });\n\n    // Indicate disconnect.\n    auto shutdownPromise = connection.get<Connected>()->shutdown()\n        .attach(kj::mv(connection.get<Connected>()))\n        .then([]() -> kj::Promise<void> { return kj::READY_NOW; },\n              [](kj::Exception&& e) -> kj::Promise<void> {\n          // Don't report disconnects as an error.\n          if (e.getType() != kj::Exception::Type::DISCONNECTED) {\n            return kj::mv(e);\n          }\n          return kj::READY_NOW;\n        });\n    disconnectFulfiller->fulfill(DisconnectInfo { kj::mv(shutdownPromise) });\n    connection.init<Disconnected>(kj::mv(networkException));\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "auto& answer = answers[answerId];",
      "auto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "connection.init<Disconnected>",
          "args": [
            "kj::mv(networkException)"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/pointer-helpers.h",
          "lines": "51-53",
          "snippet": "static inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"layout.h\"\n\nstatic inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "networkException"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disconnectFulfiller->fulfill",
          "args": [
            "DisconnectInfo { kj::mv(shutdownPromise) }"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "fulfill",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1295-1297",
          "snippet": "void fulfill(kj::Promise<kj::Own<RpcResponse>>&& promise) {\n      fulfiller->fulfill(kj::mv(promise));\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  void fulfill(kj::Promise<kj::Own<RpcResponse>>&& promise) {\n        fulfiller->fulfill(kj::mv(promise));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "shutdownPromise"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connection.get<Connected>",
          "args": [
            "[]() -> kj::Promise<void> { return kj::READY_NOW; }",
            "[](kj::Exception&& e) -> kj::Promise<void> {\n          // Don't report disconnects as an error.\n          if (e.getType() != kj::Exception::Type::DISCONNECTED) {\n            return kj::mv(e);\n          }\n          return kj::READY_NOW;\n        }"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "e"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getType",
          "args": [],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "80-80",
          "snippet": "Type getType() const { return type; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  Type getType() const { return type; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "connection.get<Connected>",
          "args": [
            "kj::mv(connection.get<Connected>())"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "connection.get<Connected>()"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connection.get<Connected>",
          "args": [],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() {\n      auto message = connection.get<Connected>()->newOutgoingMessage(\n          messageSizeHint<void>() + exceptionSizeHint(exception));\n      fromException(exception, message->getBody().getAs<rpc::Message>().initAbort());\n      message->send();\n    }"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message->send",
          "args": [],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "fromException",
          "args": [
            "exception",
            "message->getBody().getAs<rpc::Message>().initAbort()"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "fromException",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "114-119",
          "snippet": "void fromException(const kj::Exception& exception, rpc::Exception::Builder builder) {\n  // TODO(someday):  Indicate the remote server name as part of the stack trace.  Maybe even\n  //   transmit stack traces?\n  builder.setReason(exception.getDescription());\n  builder.setType(static_cast<rpc::Exception::Type>(exception.getType()));\n}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid fromException(const kj::Exception& exception, rpc::Exception::Builder builder) {\n  // TODO(someday):  Indicate the remote server name as part of the stack trace.  Maybe even\n  //   transmit stack traces?\n  builder.setReason(exception.getDescription());\n  builder.setType(static_cast<rpc::Exception::Type>(exception.getType()));\n}"
        }
      },
      {
        "call_info": {
          "callee": "message->getBody",
          "args": [],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "getBody",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "106-108",
          "snippet": "AnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nAnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "exceptionSizeHint",
          "args": [
            "exception"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "exceptionSizeHint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "121-123",
          "snippet": "uint exceptionSizeHint(const kj::Exception& exception) {\n  return sizeInWords<rpc::Exception>() + exception.getDescription().size() / sizeof(word) + 1;\n}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nuint exceptionSizeHint(const kj::Exception& exception) {\n  return sizeInWords<rpc::Exception>() + exception.getDescription().size() / sizeof(word) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "messageSizeHint<void>",
          "args": [],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "messageSizeHint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "40-42",
          "snippet": "inline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\ninline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "\"Uncaught exception when destroying capabilities dropped by disconnect.\"",
            "*newException"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "newException",
            "kj::runCatchingExceptions([&]() {\n      // Carefully pull all the objects out of the tables prior to releasing them because their\n      // destructors could come back and mess with the tables.\n      kj::Vector<kj::Own<PipelineHook>> pipelinesToRelease;\n      kj::Vector<kj::Own<ClientHook>> clientsToRelease;\n      kj::Vector<kj::Promise<kj::Own<RpcResponse>>> tailCallsToRelease;\n      kj::Vector<kj::Promise<void>> resolveOpsToRelease;\n\n      // All current questions complete with exceptions.\n      questions.forEach([&](QuestionId id, Question& question) {\n        KJ_IF_MAYBE(questionRef, question.selfRef) {\n          // QuestionRef still present.\n          questionRef->reject(kj::cp(networkException));\n        }\n      });\n\n      answers.forEach([&](AnswerId id, Answer& answer) {\n        KJ_IF_MAYBE(p, answer.pipeline) {\n          pipelinesToRelease.add(kj::mv(*p));\n        }\n\n        KJ_IF_MAYBE(promise, answer.redirectedResults) {\n          tailCallsToRelease.add(kj::mv(*promise));\n        }\n\n        KJ_IF_MAYBE(context, answer.callContext) {\n          context->requestCancel();\n        }\n      });\n\n      exports.forEach([&](ExportId id, Export& exp) {\n        clientsToRelease.add(kj::mv(exp.clientHook));\n        resolveOpsToRelease.add(kj::mv(exp.resolveOp));\n        exp = Export();\n      });\n\n      imports.forEach([&](ImportId id, Import& import) {\n        KJ_IF_MAYBE(f, import.promiseFulfiller) {\n          f->get()->reject(kj::cp(networkException));\n        }\n      });\n\n      embargoes.forEach([&](EmbargoId id, Embargo& embargo) {\n        KJ_IF_MAYBE(f, embargo.fulfiller) {\n          f->get()->reject(kj::cp(networkException));\n        }\n      });\n    })"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() {\n      // Carefully pull all the objects out of the tables prior to releasing them because their\n      // destructors could come back and mess with the tables.\n      kj::Vector<kj::Own<PipelineHook>> pipelinesToRelease;\n      kj::Vector<kj::Own<ClientHook>> clientsToRelease;\n      kj::Vector<kj::Promise<kj::Own<RpcResponse>>> tailCallsToRelease;\n      kj::Vector<kj::Promise<void>> resolveOpsToRelease;\n\n      // All current questions complete with exceptions.\n      questions.forEach([&](QuestionId id, Question& question) {\n        KJ_IF_MAYBE(questionRef, question.selfRef) {\n          // QuestionRef still present.\n          questionRef->reject(kj::cp(networkException));\n        }\n      });\n\n      answers.forEach([&](AnswerId id, Answer& answer) {\n        KJ_IF_MAYBE(p, answer.pipeline) {\n          pipelinesToRelease.add(kj::mv(*p));\n        }\n\n        KJ_IF_MAYBE(promise, answer.redirectedResults) {\n          tailCallsToRelease.add(kj::mv(*promise));\n        }\n\n        KJ_IF_MAYBE(context, answer.callContext) {\n          context->requestCancel();\n        }\n      });\n\n      exports.forEach([&](ExportId id, Export& exp) {\n        clientsToRelease.add(kj::mv(exp.clientHook));\n        resolveOpsToRelease.add(kj::mv(exp.resolveOp));\n        exp = Export();\n      });\n\n      imports.forEach([&](ImportId id, Import& import) {\n        KJ_IF_MAYBE(f, import.promiseFulfiller) {\n          f->get()->reject(kj::cp(networkException));\n        }\n      });\n\n      embargoes.forEach([&](EmbargoId id, Embargo& embargo) {\n        KJ_IF_MAYBE(f, embargo.fulfiller) {\n          f->get()->reject(kj::cp(networkException));\n        }\n      });\n    }"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "embargoes.forEach",
          "args": [
            "[&](EmbargoId id, Embargo& embargo) {\n        KJ_IF_MAYBE(f, embargo.fulfiller) {\n          f->get()->reject(kj::cp(networkException));\n        }\n      }"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "forEach",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "219-226",
          "snippet": "void forEach(Func&& func) {\n    for (Id i: kj::indices(low)) {\n      func(i, low[i]);\n    }\n    for (auto& entry: high) {\n      func(entry.first, entry.second);\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  void forEach(Func&& func) {\n      for (Id i: kj::indices(low)) {\n        func(i, low[i]);\n      }\n      for (auto& entry: high) {\n        func(entry.first, entry.second);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::cp",
          "args": [
            "networkException"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "cp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "461-461",
          "snippet": "constexpr T cp(const T& t) noexcept { return t; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nconstexpr T cp(const T& t) noexcept { return t; }"
        }
      },
      {
        "call_info": {
          "callee": "f->get",
          "args": [],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Export",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolveOpsToRelease.add",
          "args": [
            "kj::mv(exp.resolveOp)"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exp.resolveOp"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exp.clientHook"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->requestCancel",
          "args": [],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*promise"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*p"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "questionRef->reject",
          "args": [
            "kj::cp(networkException)"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "reject",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1299-1301",
          "snippet": "void reject(kj::Exception&& exception) {\n      fulfiller->reject(kj::mv(exception));\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  void reject(kj::Exception&& exception) {\n        fulfiller->reject(kj::mv(exception));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "exception.getDescription()"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exception.getDescription",
          "args": [],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "getDescription",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "81-81",
          "snippet": "StringPtr getDescription() const { return description; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  StringPtr getDescription() const { return description; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exception.getLine",
          "args": [],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "getLine",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "79-79",
          "snippet": "int getLine() const { return line; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  int getLine() const { return line; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exception.getFile",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connection.is<Connected>",
          "args": [],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nauto& answer = answers[answerId];\nauto context = kj::refcounted<RpcCallContext>(\n        *this, answerId, kj::mv(message), payload.getContent(),\n        redirectResults, kj::mv(cancelPaf.fulfiller));\n\nRpcConnectionState {\n  void disconnect(kj::Exception&& exception) {\n      if (!connection.is<Connected>()) {\n        // Already disconnected.\n        return;\n      }\n  \n      kj::Exception networkException(kj::Exception::Type::DISCONNECTED,\n          exception.getFile(), exception.getLine(), kj::heapString(exception.getDescription()));\n  \n      KJ_IF_MAYBE(newException, kj::runCatchingExceptions([&]() {\n        // Carefully pull all the objects out of the tables prior to releasing them because their\n        // destructors could come back and mess with the tables.\n        kj::Vector<kj::Own<PipelineHook>> pipelinesToRelease;\n        kj::Vector<kj::Own<ClientHook>> clientsToRelease;\n        kj::Vector<kj::Promise<kj::Own<RpcResponse>>> tailCallsToRelease;\n        kj::Vector<kj::Promise<void>> resolveOpsToRelease;\n  \n        // All current questions complete with exceptions.\n        questions.forEach([&](QuestionId id, Question& question) {\n          KJ_IF_MAYBE(questionRef, question.selfRef) {\n            // QuestionRef still present.\n            questionRef->reject(kj::cp(networkException));\n          }\n        });\n  \n        answers.forEach([&](AnswerId id, Answer& answer) {\n          KJ_IF_MAYBE(p, answer.pipeline) {\n            pipelinesToRelease.add(kj::mv(*p));\n          }\n  \n          KJ_IF_MAYBE(promise, answer.redirectedResults) {\n            tailCallsToRelease.add(kj::mv(*promise));\n          }\n  \n          KJ_IF_MAYBE(context, answer.callContext) {\n            context->requestCancel();\n          }\n        });\n  \n        exports.forEach([&](ExportId id, Export& exp) {\n          clientsToRelease.add(kj::mv(exp.clientHook));\n          resolveOpsToRelease.add(kj::mv(exp.resolveOp));\n          exp = Export();\n        });\n  \n        imports.forEach([&](ImportId id, Import& import) {\n          KJ_IF_MAYBE(f, import.promiseFulfiller) {\n            f->get()->reject(kj::cp(networkException));\n          }\n        });\n  \n        embargoes.forEach([&](EmbargoId id, Embargo& embargo) {\n          KJ_IF_MAYBE(f, embargo.fulfiller) {\n            f->get()->reject(kj::cp(networkException));\n          }\n        });\n      })) {\n        // Some destructor must have thrown an exception.  There is no appropriate place to report\n        // these errors.\n        KJ_LOG(ERROR, \"Uncaught exception when destroying capabilities dropped by disconnect.\",\n               *newException);\n      }\n  \n      // Send an abort message, but ignore failure.\n      kj::runCatchingExceptions([&]() {\n        auto message = connection.get<Connected>()->newOutgoingMessage(\n            messageSizeHint<void>() + exceptionSizeHint(exception));\n        fromException(exception, message->getBody().getAs<rpc::Message>().initAbort());\n        message->send();\n      });\n  \n      // Indicate disconnect.\n      auto shutdownPromise = connection.get<Connected>()->shutdown()\n          .attach(kj::mv(connection.get<Connected>()))\n          .then([]() -> kj::Promise<void> { return kj::READY_NOW; },\n                [](kj::Exception&& e) -> kj::Promise<void> {\n            // Don't report disconnects as an error.\n            if (e.getType() != kj::Exception::Type::DISCONNECTED) {\n              return kj::mv(e);\n            }\n            return kj::READY_NOW;\n          });\n      disconnectFulfiller->fulfill(DisconnectInfo { kj::mv(shutdownPromise) });\n      connection.init<Disconnected>(kj::mv(networkException));\n    }\n}"
  },
  {
    "function_name": "taskFailed",
    "container": "RpcConnectionState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "286-288",
    "snippet": "void taskFailed(kj::Exception&& exception) override {\n    disconnect(kj::mv(exception));\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disconnect",
          "args": [
            "kj::mv(exception)"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "disconnect",
          "container": "TestNetworkAdapter::ConnectionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "226-235",
          "snippet": "void disconnect(kj::Exception&& exception) {\n      while (!fulfillers.empty()) {\n        fulfillers.front()->reject(kj::cp(exception));\n        fulfillers.pop();\n      }\n\n      networkException = kj::mv(exception);\n\n      tasks = nullptr;\n    }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    void disconnect(kj::Exception&& exception) {\n          while (!fulfillers.empty()) {\n            fulfillers.front()->reject(kj::cp(exception));\n            fulfillers.pop();\n          }\n    \n          networkException = kj::mv(exception);\n    \n          tasks = nullptr;\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  void taskFailed(kj::Exception&& exception) override {\n      disconnect(kj::mv(exception));\n    }\n}"
  },
  {
    "function_name": "restore",
    "container": "RpcConnectionState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "253-284",
    "snippet": "kj::Own<ClientHook> restore(AnyPointer::Reader objectId) {\n    if (connection.is<Disconnected>()) {\n      return newBrokenCap(kj::cp(connection.get<Disconnected>()));\n    }\n\n    QuestionId questionId;\n    auto& question = questions.next(questionId);\n\n    question.isAwaitingReturn = true;\n\n    auto paf = kj::newPromiseAndFulfiller<kj::Promise<kj::Own<RpcResponse>>>();\n\n    auto questionRef = kj::refcounted<QuestionRef>(*this, questionId, kj::mv(paf.fulfiller));\n    question.selfRef = *questionRef;\n\n    paf.promise = paf.promise.attach(kj::addRef(*questionRef));\n\n    {\n      auto message = connection.get<Connected>()->newOutgoingMessage(\n          objectId.targetSize().wordCount + messageSizeHint<rpc::Bootstrap>());\n\n      auto builder = message->getBody().initAs<rpc::Message>().initBootstrap();\n      builder.setQuestionId(questionId);\n      builder.getDeprecatedObjectId().set(objectId);\n\n      message->send();\n    }\n\n    auto pipeline = kj::refcounted<RpcPipeline>(*this, kj::mv(questionRef), kj::mv(paf.promise));\n\n    return pipeline->getPipelinedCap(kj::Array<const PipelineOp>(nullptr));\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipeline->getPipelinedCap",
          "args": [
            "kj::Array<const PipelineOp>(nullptr)"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "getPipelinedCap",
          "container": "SingleCapPipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2068-2074",
          "snippet": "kj::Own<ClientHook> getPipelinedCap(kj::ArrayPtr<const PipelineOp> ops) override {\n      if (ops.size() == 0) {\n        return cap->addRef();\n      } else {\n        return newBrokenCap(\"Invalid pipeline transform.\");\n      }\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nSingleCapPipeline {\n  kj::Own<ClientHook> getPipelinedCap(kj::ArrayPtr<const PipelineOp> ops) override {\n        if (ops.size() == 0) {\n          return cap->addRef();\n        } else {\n          return newBrokenCap(\"Invalid pipeline transform.\");\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::Array<const PipelineOp>",
          "args": [
            "nullptr"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "Array",
          "container": "Array",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "141-145",
          "snippet": "inline Array(Array<RemoveConstOrDisable<T>>&& other) noexcept\n      : ptr(other.ptr), size_(other.size_), disposer(other.disposer) {\n    other.ptr = nullptr;\n    other.size_ = 0;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArray {\n  inline Array(Array<RemoveConstOrDisable<T>>&& other) noexcept\n        : ptr(other.ptr), size_(other.size_), disposer(other.disposer) {\n      other.ptr = nullptr;\n      other.size_ = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::refcounted<RpcPipeline>",
          "args": [
            "*this",
            "kj::mv(questionRef)",
            "kj::mv(paf.promise)"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.promise"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "questionRef"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message->send",
          "args": [],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "builder.getDeprecatedObjectId",
          "args": [
            "objectId"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getDeprecatedObjectId",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setQuestionId",
          "args": [
            "questionId"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message->getBody",
          "args": [],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "getBody",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "106-108",
          "snippet": "AnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nAnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "connection.get<Connected>",
          "args": [
            "objectId.targetSize().wordCount + messageSizeHint<rpc::Bootstrap>()"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "messageSizeHint<rpc::Bootstrap>",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "messageSizeHint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "40-42",
          "snippet": "inline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\ninline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}"
        }
      },
      {
        "call_info": {
          "callee": "objectId.targetSize",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connection.get<Connected>",
          "args": [],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "paf.promise.attach",
          "args": [
            "kj::addRef(*questionRef)"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "attach",
          "container": "TestNetworkAdapter::ConnectionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "219-224",
          "snippet": "void attach(ConnectionImpl& other) {\n      KJ_REQUIRE(partner == nullptr);\n      KJ_REQUIRE(other.partner == nullptr);\n      partner = other;\n      other.partner = *this;\n    }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    void attach(ConnectionImpl& other) {\n          KJ_REQUIRE(partner == nullptr);\n          KJ_REQUIRE(other.partner == nullptr);\n          partner = other;\n          other.partner = *this;\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*questionRef"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::refcounted<QuestionRef>",
          "args": [
            "*this",
            "questionId",
            "kj::mv(paf.fulfiller)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<kj::Promise<kj::Own<RpcResponse>>>",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "questions.next",
          "args": [
            "questionId"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newBrokenCap",
          "args": [
            "kj::cp(connection.get<Disconnected>())"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "newBrokenCap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "620-622",
          "snippet": "kj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::cp",
          "args": [
            "connection.get<Disconnected>()"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "cp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "461-461",
          "snippet": "constexpr T cp(const T& t) noexcept { return t; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nconstexpr T cp(const T& t) noexcept { return t; }"
        }
      },
      {
        "call_info": {
          "callee": "connection.is<Disconnected>",
          "args": [],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  kj::Own<ClientHook> restore(AnyPointer::Reader objectId) {\n      if (connection.is<Disconnected>()) {\n        return newBrokenCap(kj::cp(connection.get<Disconnected>()));\n      }\n  \n      QuestionId questionId;\n      auto& question = questions.next(questionId);\n  \n      question.isAwaitingReturn = true;\n  \n      auto paf = kj::newPromiseAndFulfiller<kj::Promise<kj::Own<RpcResponse>>>();\n  \n      auto questionRef = kj::refcounted<QuestionRef>(*this, questionId, kj::mv(paf.fulfiller));\n      question.selfRef = *questionRef;\n  \n      paf.promise = paf.promise.attach(kj::addRef(*questionRef));\n  \n      {\n        auto message = connection.get<Connected>()->newOutgoingMessage(\n            objectId.targetSize().wordCount + messageSizeHint<rpc::Bootstrap>());\n  \n        auto builder = message->getBody().initAs<rpc::Message>().initBootstrap();\n        builder.setQuestionId(questionId);\n        builder.getDeprecatedObjectId().set(objectId);\n  \n        message->send();\n      }\n  \n      auto pipeline = kj::refcounted<RpcPipeline>(*this, kj::mv(questionRef), kj::mv(paf.promise));\n  \n      return pipeline->getPipelinedCap(kj::Array<const PipelineOp>(nullptr));\n    }\n}"
  },
  {
    "function_name": "RpcConnectionState",
    "container": "RpcConnectionState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "242-251",
    "snippet": "RpcConnectionState(kj::Maybe<Capability::Client> bootstrapInterface,\n                     kj::Maybe<RealmGateway<>::Client> gateway,\n                     kj::Maybe<SturdyRefRestorerBase&> restorer,\n                     kj::Own<VatNetworkBase::Connection>&& connectionParam,\n                     kj::Own<kj::PromiseFulfiller<DisconnectInfo>>&& disconnectFulfiller)\n      : bootstrapInterface(kj::mv(bootstrapInterface)), gateway(kj::mv(gateway)),\n        restorer(restorer), disconnectFulfiller(kj::mv(disconnectFulfiller)), tasks(*this) {\n    connection.init<Connected>(kj::mv(connectionParam));\n    tasks.add(messageLoop());\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "messageLoop()"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "messageLoop",
          "args": [],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connection.init<Connected>",
          "args": [
            "kj::mv(connectionParam)"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/pointer-helpers.h",
          "lines": "51-53",
          "snippet": "static inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"layout.h\"\n\nstatic inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "connectionParam"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "disconnectFulfiller"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "gateway"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "bootstrapInterface"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcConnectionState {\n  RpcConnectionState(kj::Maybe<Capability::Client> bootstrapInterface,\n                       kj::Maybe<RealmGateway<>::Client> gateway,\n                       kj::Maybe<SturdyRefRestorerBase&> restorer,\n                       kj::Own<VatNetworkBase::Connection>&& connectionParam,\n                       kj::Own<kj::PromiseFulfiller<DisconnectInfo>>&& disconnectFulfiller)\n        : bootstrapInterface(kj::mv(bootstrapInterface)), gateway(kj::mv(gateway)),\n          restorer(restorer), disconnectFulfiller(kj::mv(disconnectFulfiller)), tasks(*this) {\n      connection.init<Connected>(kj::mv(connectionParam));\n      tasks.add(messageLoop());\n    }\n}"
  },
  {
    "function_name": "forEach",
    "container": "ImportTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "219-226",
    "snippet": "void forEach(Func&& func) {\n    for (Id i: kj::indices(low)) {\n      func(i, low[i]);\n    }\n    for (auto& entry: high) {\n      func(entry.first, entry.second);\n    }\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "func",
          "args": [
            "entry.first",
            "entry.second"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "i",
            "low[i]"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "low"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  void forEach(Func&& func) {\n      for (Id i: kj::indices(low)) {\n        func(i, low[i]);\n      }\n      for (auto& entry: high) {\n        func(entry.first, entry.second);\n      }\n    }\n}"
  },
  {
    "function_name": "erase",
    "container": "ImportTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "204-216",
    "snippet": "T erase(Id id) {\n    // Remove an entry from the table and return it.  We return it so that the caller can be\n    // careful to release it (possibly invoking arbitrary destructors) at a time that makes sense.\n    if (id < kj::size(low)) {\n      T toRelease = kj::mv(low[id]);\n      low[id] = T();\n      return toRelease;\n    } else {\n      T toRelease = kj::mv(high[id]);\n      high.erase(id);\n      return toRelease;\n    }\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "high[id]"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T",
          "args": [],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "onDisconnect",
          "container": "TwoPartyVatNetwork",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.h",
          "lines": "58-58",
          "snippet": "kj::Promise<void> onDisconnect() { return disconnectPromise.addBranch(); }",
          "includes": [
            "#include <capnp/rpc-twoparty.capnp.h>",
            "#include <kj/async-io.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc-twoparty.capnp.h>\n#include <kj/async-io.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nTwoPartyVatNetwork {\n  kj::Promise<void> onDisconnect() { return disconnectPromise.addBranch(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "low[id]"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::size",
          "args": [
            "low"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "493-493",
          "snippet": "inline constexpr size_t size(T&& arr) { return arr.size(); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr size_t size(T&& arr) { return arr.size(); }"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  T erase(Id id) {\n      // Remove an entry from the table and return it.  We return it so that the caller can be\n      // careful to release it (possibly invoking arbitrary destructors) at a time that makes sense.\n      if (id < kj::size(low)) {\n        T toRelease = kj::mv(low[id]);\n        low[id] = T();\n        return toRelease;\n      } else {\n        T toRelease = kj::mv(high[id]);\n        high.erase(id);\n        return toRelease;\n      }\n    }\n}"
  },
  {
    "function_name": "find",
    "container": "ImportTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "191-202",
    "snippet": "kj::Maybe<T&> find(Id id) {\n    if (id < kj::size(low)) {\n      return low[id];\n    } else {\n      auto iter = high.find(id);\n      if (iter == high.end()) {\n        return nullptr;\n      } else {\n        return iter->second;\n      }\n    }\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "high.end",
          "args": [],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      },
      {
        "call_info": {
          "callee": "kj::size",
          "args": [
            "low"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "493-493",
          "snippet": "inline constexpr size_t size(T&& arr) { return arr.size(); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr size_t size(T&& arr) { return arr.size(); }"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  kj::Maybe<T&> find(Id id) {\n      if (id < kj::size(low)) {\n        return low[id];\n      } else {\n        auto iter = high.find(id);\n        if (iter == high.end()) {\n          return nullptr;\n        } else {\n          return iter->second;\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "forEach",
    "container": "ExportTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "165-171",
    "snippet": "void forEach(Func&& func) {\n    for (Id i = 0; i < slots.size(); i++) {\n      if (slots[i] != nullptr) {\n        func(i, slots[i]);\n      }\n    }\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "func",
          "args": [
            "i",
            "slots[i]"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slots.size",
          "args": [],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nExportTable {\n  void forEach(Func&& func) {\n      for (Id i = 0; i < slots.size(); i++) {\n        if (slots[i] != nullptr) {\n          func(i, slots[i]);\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "erase",
    "container": "ExportTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "140-151",
    "snippet": "T erase(Id id, T& entry) {\n    // Remove an entry from the table and return it.  We return it so that the caller can be\n    // careful to release it (possibly invoking arbitrary destructors) at a time that makes sense.\n    // `entry` is a reference to the entry being released -- we require this in order to prove\n    // that the caller has already done a find() to check that this entry exists.  We can't check\n    // ourselves because the caller may have nullified the entry in the meantime.\n    KJ_DREQUIRE(&entry == &slots[id]);\n    T toRelease = kj::mv(slots[id]);\n    slots[id] = T();\n    freeIds.push(id);\n    return toRelease;\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeIds.push",
          "args": [
            "id"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "onDisconnect",
          "container": "TwoPartyVatNetwork",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.h",
          "lines": "58-58",
          "snippet": "kj::Promise<void> onDisconnect() { return disconnectPromise.addBranch(); }",
          "includes": [
            "#include <capnp/rpc-twoparty.capnp.h>",
            "#include <kj/async-io.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc-twoparty.capnp.h>\n#include <kj/async-io.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nTwoPartyVatNetwork {\n  kj::Promise<void> onDisconnect() { return disconnectPromise.addBranch(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "slots[id]"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "&entry == &slots[id]"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nExportTable {\n  T erase(Id id, T& entry) {\n      // Remove an entry from the table and return it.  We return it so that the caller can be\n      // careful to release it (possibly invoking arbitrary destructors) at a time that makes sense.\n      // `entry` is a reference to the entry being released -- we require this in order to prove\n      // that the caller has already done a find() to check that this entry exists.  We can't check\n      // ourselves because the caller may have nullified the entry in the meantime.\n      KJ_DREQUIRE(&entry == &slots[id]);\n      T toRelease = kj::mv(slots[id]);\n      slots[id] = T();\n      freeIds.push(id);\n      return toRelease;\n    }\n}"
  },
  {
    "function_name": "find",
    "container": "ExportTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "132-138",
    "snippet": "kj::Maybe<T&> find(Id id) {\n    if (id < slots.size() && slots[id] != nullptr) {\n      return slots[id];\n    } else {\n      return nullptr;\n    }\n  }",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slots.size",
          "args": [],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nExportTable {\n  kj::Maybe<T&> find(Id id) {\n      if (id < slots.size() && slots[id] != nullptr) {\n        return slots[id];\n      } else {\n        return nullptr;\n      }\n    }\n}"
  },
  {
    "function_name": "exceptionSizeHint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "121-123",
    "snippet": "uint exceptionSizeHint(const kj::Exception& exception) {\n  return sizeInWords<rpc::Exception>() + exception.getDescription().size() / sizeof(word) + 1;\n}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception.getDescription",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "getDescription",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "81-81",
          "snippet": "StringPtr getDescription() const { return description; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  StringPtr getDescription() const { return description; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sizeInWords<rpc::Exception>",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "sizeInWords",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "496-502",
          "snippet": "inline constexpr uint sizeInWords() {\n  // Return the size, in words, of a Struct type, if allocated free-standing (not in a list).\n  // May be useful for pre-computing space needed in order to precisely allocate messages.\n\n  return (WordCount32(_::structSize<T>().data) +\n      _::structSize<T>().pointers * WORDS_PER_POINTER) / WORDS;\n}",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\ninline constexpr uint sizeInWords() {\n  // Return the size, in words, of a Struct type, if allocated free-standing (not in a list).\n  // May be useful for pre-computing space needed in order to precisely allocate messages.\n\n  return (WordCount32(_::structSize<T>().data) +\n      _::structSize<T>().pointers * WORDS_PER_POINTER) / WORDS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nuint exceptionSizeHint(const kj::Exception& exception) {\n  return sizeInWords<rpc::Exception>() + exception.getDescription().size() / sizeof(word) + 1;\n}"
  },
  {
    "function_name": "fromException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "114-119",
    "snippet": "void fromException(const kj::Exception& exception, rpc::Exception::Builder builder) {\n  // TODO(someday):  Indicate the remote server name as part of the stack trace.  Maybe even\n  //   transmit stack traces?\n  builder.setReason(exception.getDescription());\n  builder.setType(static_cast<rpc::Exception::Type>(exception.getType()));\n}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.setType",
          "args": [
            "static_cast<rpc::Exception::Type>(exception.getType())"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<rpc::Exception::Type>",
          "args": [
            "exception.getType()"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception.getType",
          "args": [],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "builder.setReason",
          "args": [
            "exception.getDescription()"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception.getDescription",
          "args": [],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "getDescription",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "81-81",
          "snippet": "StringPtr getDescription() const { return description; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  StringPtr getDescription() const { return description; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nvoid fromException(const kj::Exception& exception, rpc::Exception::Builder builder) {\n  // TODO(someday):  Indicate the remote server name as part of the stack trace.  Maybe even\n  //   transmit stack traces?\n  builder.setReason(exception.getDescription());\n  builder.setType(static_cast<rpc::Exception::Type>(exception.getType()));\n}"
  },
  {
    "function_name": "toException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "109-112",
    "snippet": "kj::Exception toException(const rpc::Exception::Reader& exception) {\n  return kj::Exception(static_cast<kj::Exception::Type>(exception.getType()),\n      \"(remote)\", 0, kj::str(\"remote exception: \", exception.getReason()));\n}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::Exception",
          "args": [
            "static_cast<kj::Exception::Type>(exception.getType())",
            "\"(remote)\"",
            "0",
            "kj::str(\"remote exception: \", exception.getReason())"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"remote exception: \"",
            "exception.getReason()"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception.getReason",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<kj::Exception::Type>",
          "args": [
            "exception.getType()"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception.getType",
          "args": [],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Exception toException(const rpc::Exception::Reader& exception) {\n  return kj::Exception(static_cast<kj::Exception::Type>(exception.getType()),\n      \"(remote)\", 0, kj::str(\"remote exception: \", exception.getReason()));\n}"
  },
  {
    "function_name": "fromPipelineOps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "91-107",
    "snippet": "Orphan<List<rpc::PromisedAnswer::Op>> fromPipelineOps(\n    Orphanage orphanage, kj::ArrayPtr<const PipelineOp> ops) {\n  auto result = orphanage.newOrphan<List<rpc::PromisedAnswer::Op>>(ops.size());\n  auto builder = result.get();\n  for (uint i: kj::indices(ops)) {\n    rpc::PromisedAnswer::Op::Builder opBuilder = builder[i];\n    switch (ops[i].type) {\n      case PipelineOp::NOOP:\n        opBuilder.setNoop();\n        break;\n      case PipelineOp::GET_POINTER_FIELD:\n        opBuilder.setGetPointerField(ops[i].pointerIndex);\n        break;\n    }\n  }\n  return result;\n}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "opBuilder.setGetPointerField",
          "args": [
            "ops[i].pointerIndex"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opBuilder.setNoop",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "ops"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.get",
          "args": [],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<List<rpc::PromisedAnswer::Op>>",
          "args": [
            "ops.size()"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops.size",
          "args": [],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nOrphan<List<rpc::PromisedAnswer::Op>> fromPipelineOps(\n    Orphanage orphanage, kj::ArrayPtr<const PipelineOp> ops) {\n  auto result = orphanage.newOrphan<List<rpc::PromisedAnswer::Op>>(ops.size());\n  auto builder = result.get();\n  for (uint i: kj::indices(ops)) {\n    rpc::PromisedAnswer::Op::Builder opBuilder = builder[i];\n    switch (ops[i].type) {\n      case PipelineOp::NOOP:\n        opBuilder.setNoop();\n        break;\n      case PipelineOp::GET_POINTER_FIELD:\n        opBuilder.setGetPointerField(ops[i].pointerIndex);\n        break;\n    }\n  }\n  return result;\n}"
  },
  {
    "function_name": "toPipelineOps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "69-89",
    "snippet": "kj::Maybe<kj::Array<PipelineOp>> toPipelineOps(List<rpc::PromisedAnswer::Op>::Reader ops) {\n  auto result = kj::heapArrayBuilder<PipelineOp>(ops.size());\n  for (auto opReader: ops) {\n    PipelineOp op;\n    switch (opReader.which()) {\n      case rpc::PromisedAnswer::Op::NOOP:\n        op.type = PipelineOp::NOOP;\n        break;\n      case rpc::PromisedAnswer::Op::GET_POINTER_FIELD:\n        op.type = PipelineOp::GET_POINTER_FIELD;\n        op.pointerIndex = opReader.getGetPointerField();\n        break;\n      default:\n        KJ_FAIL_REQUIRE(\"Unsupported pipeline op.\", (uint)opReader.which()) {\n          return nullptr;\n        }\n    }\n    result.add(op);\n  }\n  return result.finish();\n}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.finish",
          "args": [],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.add",
          "args": [
            "op"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Unsupported pipeline op.\"",
            "(uint)opReader.which()"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opReader.which",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opReader.getGetPointerField",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opReader.which",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArrayBuilder<PipelineOp>",
          "args": [
            "ops.size()"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "heapArrayBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "410-416",
          "snippet": "inline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops.size",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Array<PipelineOp>> toPipelineOps(List<rpc::PromisedAnswer::Op>::Reader ops) {\n  auto result = kj::heapArrayBuilder<PipelineOp>(ops.size());\n  for (auto opReader: ops) {\n    PipelineOp op;\n    switch (opReader.which()) {\n      case rpc::PromisedAnswer::Op::NOOP:\n        op.type = PipelineOp::NOOP;\n        break;\n      case rpc::PromisedAnswer::Op::GET_POINTER_FIELD:\n        op.type = PipelineOp::GET_POINTER_FIELD;\n        op.pointerIndex = opReader.getGetPointerField();\n        break;\n      default:\n        KJ_FAIL_REQUIRE(\"Unsupported pipeline op.\", (uint)opReader.which()) {\n          return nullptr;\n        }\n    }\n    result.add(op);\n  }\n  return result.finish();\n}"
  },
  {
    "function_name": "firstSegmentSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "61-67",
    "snippet": "uint firstSegmentSize(kj::Maybe<MessageSize> sizeHint, uint additional) {\n  KJ_IF_MAYBE(s, sizeHint) {\n    return copySizeHint(*s) + additional;\n  } else {\n    return 0;\n  }\n}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copySizeHint",
          "args": [
            "*s"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "copySizeHint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "56-59",
          "snippet": "uint copySizeHint(MessageSize size) {\n  uint64_t sizeHint = size.wordCount + size.capCount * CAP_DESCRIPTOR_SIZE_HINT;\n  return kj::min(MAX_SIZE_HINT, sizeHint);\n}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nuint copySizeHint(MessageSize size) {\n  uint64_t sizeHint = size.wordCount + size.capCount * CAP_DESCRIPTOR_SIZE_HINT;\n  return kj::min(MAX_SIZE_HINT, sizeHint);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nuint firstSegmentSize(kj::Maybe<MessageSize> sizeHint, uint additional) {\n  KJ_IF_MAYBE(s, sizeHint) {\n    return copySizeHint(*s) + additional;\n  } else {\n    return 0;\n  }\n}"
  },
  {
    "function_name": "copySizeHint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "56-59",
    "snippet": "uint copySizeHint(MessageSize size) {\n  uint64_t sizeHint = size.wordCount + size.capCount * CAP_DESCRIPTOR_SIZE_HINT;\n  return kj::min(MAX_SIZE_HINT, sizeHint);\n}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::min",
          "args": [
            "MAX_SIZE_HINT",
            "sizeHint"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "473-475",
          "snippet": "auto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nuint copySizeHint(MessageSize size) {\n  uint64_t sizeHint = size.wordCount + size.capCount * CAP_DESCRIPTOR_SIZE_HINT;\n  return kj::min(MAX_SIZE_HINT, sizeHint);\n}"
  },
  {
    "function_name": "messageSizeHint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
    "lines": "40-42",
    "snippet": "inline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}",
    "includes": [
      "#include <capnp/rpc.capnp.h>",
      "#include <queue>",
      "#include <map>",
      "#include <unordered_map>",
      "#include <kj/function.h>",
      "#include <kj/one-of.h>",
      "#include <kj/async.h>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sizeInWords<T>",
          "args": [],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "sizeInWords",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "496-502",
          "snippet": "inline constexpr uint sizeInWords() {\n  // Return the size, in words, of a Struct type, if allocated free-standing (not in a list).\n  // May be useful for pre-computing space needed in order to precisely allocate messages.\n\n  return (WordCount32(_::structSize<T>().data) +\n      _::structSize<T>().pointers * WORDS_PER_POINTER) / WORDS;\n}",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\ninline constexpr uint sizeInWords() {\n  // Return the size, in words, of a Struct type, if allocated free-standing (not in a list).\n  // May be useful for pre-computing space needed in order to precisely allocate messages.\n\n  return (WordCount32(_::structSize<T>().data) +\n      _::structSize<T>().pointers * WORDS_PER_POINTER) / WORDS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\ninline constexpr uint messageSizeHint() {\n  return 1 + sizeInWords<rpc::Message>() + sizeInWords<T>();\n}"
  }
]