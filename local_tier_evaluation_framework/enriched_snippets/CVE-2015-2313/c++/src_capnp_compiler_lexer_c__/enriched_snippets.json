[
  {
    "function_name": "Lexer::~Lexer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer.c++",
    "lines": "291-291",
    "snippet": "Lexer::~Lexer() noexcept(false) {}",
    "includes": [
      "#include <kj/debug.h>",
      "#include <kj/parse/char.h>",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/debug.h>\n#include <kj/parse/char.h>\n#include \"lexer.h\"\n\nLexer::~Lexer() noexcept(false) {}"
  },
  {
    "function_name": "Lexer::Lexer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer.c++",
    "lines": "146-289",
    "snippet": "Lexer::Lexer(Orphanage orphanageParam, ErrorReporter& errorReporter)\n    : orphanage(orphanageParam) {\n\n  // Note that because passing an lvalue to a parser constructor uses it by-referencee, it's safe\n  // for us to use parsers.tokenSequence even though we haven't yet constructed it.\n  auto& tokenSequence = parsers.tokenSequence;\n\n  auto& commaDelimitedList = arena.copy(p::transform(\n      p::sequence(tokenSequence, p::many(p::sequence(p::exactChar<','>(), tokenSequence))),\n      [this](kj::Array<Orphan<Token>>&& first, kj::Array<kj::Array<Orphan<Token>>>&& rest)\n          -> kj::Array<kj::Array<Orphan<Token>>> {\n        if (first == nullptr && rest == nullptr) {\n          // Completely empty list.\n          return nullptr;\n        } else {\n          auto result = kj::heapArrayBuilder<kj::Array<Orphan<Token>>>(rest.size() + 1);\n          result.add(kj::mv(first));\n          for (auto& item: rest) {\n            result.add(kj::mv(item));\n          }\n          return result.finish();\n        }\n      }));\n\n  auto& token = arena.copy(p::oneOf(\n      p::transformWithLocation(p::identifier,\n          [this](Location loc, kj::String name) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setIdentifier(name);\n            return t;\n          }),\n      p::transformWithLocation(p::doubleQuotedString,\n          [this](Location loc, kj::String text) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setStringLiteral(text);\n            return t;\n          }),\n      p::transformWithLocation(p::doubleQuotedHexBinary,\n          [this](Location loc, kj::Array<byte> data) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setBinaryLiteral(data);\n            return t;\n          }),\n      p::transformWithLocation(p::integer,\n          [this](Location loc, uint64_t i) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setIntegerLiteral(i);\n            return t;\n          }),\n      p::transformWithLocation(p::number,\n          [this](Location loc, double x) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setFloatLiteral(x);\n            return t;\n          }),\n      p::transformWithLocation(\n          p::charsToString(p::oneOrMore(p::anyOfChars(\"!$%&*+-./:<=>?@^|~\"))),\n          [this](Location loc, kj::String text) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setOperator(text);\n            return t;\n          }),\n      p::transformWithLocation(\n          sequence(p::exactChar<'('>(), commaDelimitedList, p::exactChar<')'>()),\n          [this](Location loc, kj::Array<kj::Array<Orphan<Token>>>&& items) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            buildTokenSequenceList(\n                initTok(t, loc).initParenthesizedList(items.size()), kj::mv(items));\n            return t;\n          }),\n      p::transformWithLocation(\n          sequence(p::exactChar<'['>(), commaDelimitedList, p::exactChar<']'>()),\n          [this](Location loc, kj::Array<kj::Array<Orphan<Token>>>&& items) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            buildTokenSequenceList(\n                initTok(t, loc).initBracketedList(items.size()), kj::mv(items));\n            return t;\n          }),\n      p::transformOrReject(p::transformWithLocation(\n          p::oneOf(sequence(p::exactChar<'\\xff'>(), p::exactChar<'\\xfe'>()),\n                   sequence(p::exactChar<'\\xfe'>(), p::exactChar<'\\xff'>()),\n                   sequence(p::exactChar<'\\x00'>())),\n          [this, &errorReporter](Location loc) -> kj::Maybe<Orphan<Token>> {\n            errorReporter.addError(loc.begin(), loc.end(),\n                \"Non-UTF-8 input detected. Cap'n Proto schema files must be UTF-8 text.\");\n            return nullptr;\n          }), [](kj::Maybe<Orphan<Token>> param) { return param; })));\n  parsers.tokenSequence = arena.copy(p::sequence(\n      commentsAndWhitespace, p::many(p::sequence(token, commentsAndWhitespace))));\n\n  auto& statementSequence = parsers.statementSequence;\n\n  auto& statementEnd = arena.copy(p::oneOf(\n      transform(p::sequence(p::exactChar<';'>(), docComment),\n          [this](kj::Maybe<kj::Array<kj::String>>&& comment) -> Orphan<Statement> {\n            auto result = orphanage.newOrphan<Statement>();\n            auto builder = result.get();\n            KJ_IF_MAYBE(c, comment) {\n              attachDocComment(builder, kj::mv(*c));\n            }\n            builder.setLine();\n            return result;\n          }),\n      transform(\n          p::sequence(p::exactChar<'{'>(), docComment, statementSequence, p::exactChar<'}'>(),\n                      docComment),\n          [this](kj::Maybe<kj::Array<kj::String>>&& comment,\n                 kj::Array<Orphan<Statement>>&& statements,\n                 kj::Maybe<kj::Array<kj::String>>&& lateComment)\n              -> Orphan<Statement> {\n            auto result = orphanage.newOrphan<Statement>();\n            auto builder = result.get();\n            KJ_IF_MAYBE(c, comment) {\n              attachDocComment(builder, kj::mv(*c));\n            } else KJ_IF_MAYBE(c, lateComment) {\n              attachDocComment(builder, kj::mv(*c));\n            }\n            auto list = builder.initBlock(statements.size());\n            for (uint i = 0; i < statements.size(); i++) {\n              list.adoptWithCaveats(i, kj::mv(statements[i]));\n            }\n            return result;\n          })\n      ));\n\n  auto& statement = arena.copy(p::transformWithLocation(p::sequence(tokenSequence, statementEnd),\n      [this](Location loc, kj::Array<Orphan<Token>>&& tokens, Orphan<Statement>&& statement) {\n        auto builder = statement.get();\n        auto tokensBuilder = builder.initTokens(tokens.size());\n        for (uint i = 0; i < tokens.size(); i++) {\n          tokensBuilder.adoptWithCaveats(i, kj::mv(tokens[i]));\n        }\n        builder.setStartByte(loc.begin());\n        builder.setEndByte(loc.end());\n        return kj::mv(statement);\n      }));\n\n  parsers.statementSequence = arena.copy(sequence(\n      commentsAndWhitespace, many(sequence(statement, commentsAndWhitespace))));\n\n  parsers.token = token;\n  parsers.statement = statement;\n  parsers.emptySpace = commentsAndWhitespace;\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include <kj/parse/char.h>",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arena.copy",
          "args": [
            "sequence(\n      commentsAndWhitespace, many(sequence(statement, commentsAndWhitespace)))"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sequence",
          "args": [
            "commentsAndWhitespace",
            "many(sequence(statement, commentsAndWhitespace))"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "many",
          "args": [
            "sequence(statement, commentsAndWhitespace)"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "432-436",
          "snippet": "constexpr Many_<SubParser, false> many(SubParser&& subParser) {\n  // Constructs a parser that repeatedly executes the given parser until it fails, returning an\n  // Array of the results (or a uint count if `subParser` returns an empty tuple).\n  return Many_<SubParser, false>(kj::fwd<SubParser>(subParser));\n}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr Many_<SubParser, false> many(SubParser&& subParser) {\n  // Constructs a parser that repeatedly executes the given parser until it fails, returning an\n  // Array of the results (or a uint count if `subParser` returns an empty tuple).\n  return Many_<SubParser, false>(kj::fwd<SubParser>(subParser));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sequence",
          "args": [
            "statement",
            "commentsAndWhitespace"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.copy",
          "args": [
            "p::transformWithLocation(p::sequence(tokenSequence, statementEnd),\n      [this](Location loc, kj::Array<Orphan<Token>>&& tokens, Orphan<Statement>&& statement) {\n        auto builder = statement.get();\n        auto tokensBuilder = builder.initTokens(tokens.size());\n        for (uint i = 0; i < tokens.size(); i++) {\n          tokensBuilder.adoptWithCaveats(i, kj::mv(tokens[i]));\n        }\n        builder.setStartByte(loc.begin());\n        builder.setEndByte(loc.end());\n        return kj::mv(statement);\n      })"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::transformWithLocation",
          "args": [
            "p::sequence(tokenSequence, statementEnd)",
            "[this](Location loc, kj::Array<Orphan<Token>>&& tokens, Orphan<Statement>&& statement) {\n        auto builder = statement.get();\n        auto tokensBuilder = builder.initTokens(tokens.size());\n        for (uint i = 0; i < tokens.size(); i++) {\n          tokensBuilder.adoptWithCaveats(i, kj::mv(tokens[i]));\n        }\n        builder.setStartByte(loc.begin());\n        builder.setEndByte(loc.end());\n        return kj::mv(statement);\n      }"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "transformWithLocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "718-725",
          "snippet": "constexpr TransformWithLocation_<SubParser, TransformFunc> transformWithLocation(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Like `transform` except that `functor` also takes a `Span` as its first parameter specifying\n  // the location of the parsed content.  The span's position type is whatever the parser input's\n  // getPosition() returns.\n  return TransformWithLocation_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr TransformWithLocation_<SubParser, TransformFunc> transformWithLocation(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Like `transform` except that `functor` also takes a `Span` as its first parameter specifying\n  // the location of the parsed content.  The span's position type is whatever the parser input's\n  // getPosition() returns.\n  return TransformWithLocation_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "statement"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setEndByte",
          "args": [
            "loc.end()"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loc.end",
          "args": [],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "77-77",
          "snippet": "inline Iterator end() const { return Iterator(amount); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator end() const { return Iterator(amount); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.setStartByte",
          "args": [
            "loc.begin()"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loc.begin",
          "args": [],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "76-76",
          "snippet": "inline Iterator begin() const { return Iterator(0); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tokensBuilder.adoptWithCaveats",
          "args": [
            "i",
            "kj::mv(tokens[i])"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "adoptWithCaveats",
          "container": "Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/list.h",
          "lines": "251-268",
          "snippet": "inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n      // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n      // the fact that structs in a struct list are allocated inline rather than by pointer:\n      // * This actually performs a shallow copy, effectively adopting each of the orphan's\n      //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n      //   possibly wasting space in the message object.\n      // * If the orphan is larger than the target struct -- say, because the orphan was built\n      //   using a newer version of the schema that has additional fields -- it will be truncated,\n      //   losing data.\n\n      KJ_IREQUIRE(index < size());\n\n      // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n      // expanded under any circumstances.  We're just going to throw it away anyway, and\n      // transferContentFrom() already carefully compares the struct sizes before transferring.\n      builder.getStructElement(index * ELEMENTS).transferContentFrom(\n          orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n    }",
          "includes": [
            "#include <iterator>",
            "#include <initializer_list>",
            "#include \"orphan.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <initializer_list>\n#include \"orphan.h\"\n#include \"layout.h\"\n\nBuilder {\n  inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n        // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n        // the fact that structs in a struct list are allocated inline rather than by pointer:\n        // * This actually performs a shallow copy, effectively adopting each of the orphan's\n        //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n        //   possibly wasting space in the message object.\n        // * If the orphan is larger than the target struct -- say, because the orphan was built\n        //   using a newer version of the schema that has additional fields -- it will be truncated,\n        //   losing data.\n  \n        KJ_IREQUIRE(index < size());\n  \n        // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n        // expanded under any circumstances.  We're just going to throw it away anyway, and\n        // transferContentFrom() already carefully compares the struct sizes before transferring.\n        builder.getStructElement(index * ELEMENTS).transferContentFrom(\n            orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "tokens[i]"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tokens.size",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.initTokens",
          "args": [
            "tokens.size()"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statement.get",
          "args": [],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "tokenSequence",
            "statementEnd"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.copy",
          "args": [
            "p::oneOf(\n      transform(p::sequence(p::exactChar<';'>(), docComment),\n          [this](kj::Maybe<kj::Array<kj::String>>&& comment) -> Orphan<Statement> {\n            auto result = orphanage.newOrphan<Statement>();\n            auto builder = result.get();\n            KJ_IF_MAYBE(c, comment) {\n              attachDocComment(builder, kj::mv(*c));\n            }\n            builder.setLine();\n            return result;\n          }),\n      transform(\n          p::sequence(p::exactChar<'{'>(), docComment, statementSequence, p::exactChar<'}'>(),\n                      docComment),\n          [this](kj::Maybe<kj::Array<kj::String>>&& comment,\n                 kj::Array<Orphan<Statement>>&& statements,\n                 kj::Maybe<kj::Array<kj::String>>&& lateComment)\n              -> Orphan<Statement> {\n            auto result = orphanage.newOrphan<Statement>();\n            auto builder = result.get();\n            KJ_IF_MAYBE(c, comment) {\n              attachDocComment(builder, kj::mv(*c));\n            } else KJ_IF_MAYBE(c, lateComment) {\n              attachDocComment(builder, kj::mv(*c));\n            }\n            auto list = builder.initBlock(statements.size());\n            for (uint i = 0; i < statements.size(); i++) {\n              list.adoptWithCaveats(i, kj::mv(statements[i]));\n            }\n            return result;\n          })\n      )"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::oneOf",
          "args": [
            "transform(p::sequence(p::exactChar<';'>(), docComment),\n          [this](kj::Maybe<kj::Array<kj::String>>&& comment) -> Orphan<Statement> {\n            auto result = orphanage.newOrphan<Statement>();\n            auto builder = result.get();\n            KJ_IF_MAYBE(c, comment) {\n              attachDocComment(builder, kj::mv(*c));\n            }\n            builder.setLine();\n            return result;\n          })",
            "transform(\n          p::sequence(p::exactChar<'{'>(), docComment, statementSequence, p::exactChar<'}'>(),\n                      docComment),\n          [this](kj::Maybe<kj::Array<kj::String>>&& comment,\n                 kj::Array<Orphan<Statement>>&& statements,\n                 kj::Maybe<kj::Array<kj::String>>&& lateComment)\n              -> Orphan<Statement> {\n            auto result = orphanage.newOrphan<Statement>();\n            auto builder = result.get();\n            KJ_IF_MAYBE(c, comment) {\n              attachDocComment(builder, kj::mv(*c));\n            } else KJ_IF_MAYBE(c, lateComment) {\n              attachDocComment(builder, kj::mv(*c));\n            }\n            auto list = builder.initBlock(statements.size());\n            for (uint i = 0; i < statements.size(); i++) {\n              list.adoptWithCaveats(i, kj::mv(statements[i]));\n            }\n            return result;\n          })"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "transform",
          "args": [
            "p::sequence(p::exactChar<'{'>(), docComment, statementSequence, p::exactChar<'}'>(),\n                      docComment)",
            "[this](kj::Maybe<kj::Array<kj::String>>&& comment,\n                 kj::Array<Orphan<Statement>>&& statements,\n                 kj::Maybe<kj::Array<kj::String>>&& lateComment)\n              -> Orphan<Statement> {\n            auto result = orphanage.newOrphan<Statement>();\n            auto builder = result.get();\n            KJ_IF_MAYBE(c, comment) {\n              attachDocComment(builder, kj::mv(*c));\n            } else KJ_IF_MAYBE(c, lateComment) {\n              attachDocComment(builder, kj::mv(*c));\n            }\n            auto list = builder.initBlock(statements.size());\n            for (uint i = 0; i < statements.size(); i++) {\n              list.adoptWithCaveats(i, kj::mv(statements[i]));\n            }\n            return result;\n          }"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "699-706",
          "snippet": "constexpr Transform_<SubParser, TransformFunc> transform(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Constructs a parser which executes some other parser and then transforms the result by invoking\n  // `functor` on it.  Typically `functor` is a lambda.  It is invoked using `kj::apply`,\n  // meaning tuples will be unpacked as arguments.\n  return Transform_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr Transform_<SubParser, TransformFunc> transform(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Constructs a parser which executes some other parser and then transforms the result by invoking\n  // `functor` on it.  Typically `functor` is a lambda.  It is invoked using `kj::apply`,\n  // meaning tuples will be unpacked as arguments.\n  return Transform_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "statements[i]"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initBlock",
          "args": [
            "statements.size()"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attachDocComment",
          "args": [
            "builder",
            "kj::mv(*c)"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "attachDocComment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer.c++",
          "lines": "97-110",
          "snippet": "void attachDocComment(Statement::Builder statement, kj::Array<kj::String>&& comment) {\n  size_t size = 0;\n  for (auto& line: comment) {\n    size += line.size() + 1;  // include newline\n  }\n  Text::Builder builder = statement.initDocComment(size);\n  char* pos = builder.begin();\n  for (auto& line: comment) {\n    memcpy(pos, line.begin(), line.size());\n    pos += line.size();\n    *pos++ = '\\n';\n  }\n  KJ_ASSERT(pos == builder.end());\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include <kj/parse/char.h>",
            "#include \"lexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include <kj/parse/char.h>\n#include \"lexer.h\"\n\nvoid attachDocComment(Statement::Builder statement, kj::Array<kj::String>&& comment) {\n  size_t size = 0;\n  for (auto& line: comment) {\n    size += line.size() + 1;  // include newline\n  }\n  Text::Builder builder = statement.initDocComment(size);\n  char* pos = builder.begin();\n  for (auto& line: comment) {\n    memcpy(pos, line.begin(), line.size());\n    pos += line.size();\n    *pos++ = '\\n';\n  }\n  KJ_ASSERT(pos == builder.end());\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*c"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*c"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Statement>",
          "args": [],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "p::exactChar<'{'>()",
            "docComment",
            "statementSequence",
            "p::exactChar<'}'>()",
            "docComment"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::exactChar<'}'>",
          "args": [],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "exactChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/char.h",
          "lines": "68-72",
          "snippet": "constexpr ExactlyConst_<char, c> exactChar() {\n  // Returns a parser that matches exactly the character given by the template argument (returning\n  // no result).\n  return ExactlyConst_<char, c>();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include \"../string.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include \"../string.h\"\n#include \"common.h\"\n\nconstexpr ExactlyConst_<char, c> exactChar() {\n  // Returns a parser that matches exactly the character given by the template argument (returning\n  // no result).\n  return ExactlyConst_<char, c>();\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.setLine",
          "args": [],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*c"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Statement>",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "p::exactChar<';'>()",
            "docComment"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.copy",
          "args": [
            "p::sequence(\n      commentsAndWhitespace, p::many(p::sequence(token, commentsAndWhitespace)))"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "commentsAndWhitespace",
            "p::many(p::sequence(token, commentsAndWhitespace))"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "token",
            "commentsAndWhitespace"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.copy",
          "args": [
            "p::oneOf(\n      p::transformWithLocation(p::identifier,\n          [this](Location loc, kj::String name) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setIdentifier(name);\n            return t;\n          }),\n      p::transformWithLocation(p::doubleQuotedString,\n          [this](Location loc, kj::String text) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setStringLiteral(text);\n            return t;\n          }),\n      p::transformWithLocation(p::doubleQuotedHexBinary,\n          [this](Location loc, kj::Array<byte> data) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setBinaryLiteral(data);\n            return t;\n          }),\n      p::transformWithLocation(p::integer,\n          [this](Location loc, uint64_t i) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setIntegerLiteral(i);\n            return t;\n          }),\n      p::transformWithLocation(p::number,\n          [this](Location loc, double x) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setFloatLiteral(x);\n            return t;\n          }),\n      p::transformWithLocation(\n          p::charsToString(p::oneOrMore(p::anyOfChars(\"!$%&*+-./:<=>?@^|~\"))),\n          [this](Location loc, kj::String text) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setOperator(text);\n            return t;\n          }),\n      p::transformWithLocation(\n          sequence(p::exactChar<'('>(), commaDelimitedList, p::exactChar<')'>()),\n          [this](Location loc, kj::Array<kj::Array<Orphan<Token>>>&& items) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            buildTokenSequenceList(\n                initTok(t, loc).initParenthesizedList(items.size()), kj::mv(items));\n            return t;\n          }),\n      p::transformWithLocation(\n          sequence(p::exactChar<'['>(), commaDelimitedList, p::exactChar<']'>()),\n          [this](Location loc, kj::Array<kj::Array<Orphan<Token>>>&& items) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            buildTokenSequenceList(\n                initTok(t, loc).initBracketedList(items.size()), kj::mv(items));\n            return t;\n          }),\n      p::transformOrReject(p::transformWithLocation(\n          p::oneOf(sequence(p::exactChar<'\\xff'>(), p::exactChar<'\\xfe'>()),\n                   sequence(p::exactChar<'\\xfe'>(), p::exactChar<'\\xff'>()),\n                   sequence(p::exactChar<'\\x00'>())),\n          [this, &errorReporter](Location loc) -> kj::Maybe<Orphan<Token>> {\n            errorReporter.addError(loc.begin(), loc.end(),\n                \"Non-UTF-8 input detected. Cap'n Proto schema files must be UTF-8 text.\");\n            return nullptr;\n          }), [](kj::Maybe<Orphan<Token>> param) { return param; }))"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::oneOf",
          "args": [
            "p::transformWithLocation(p::identifier,\n          [this](Location loc, kj::String name) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setIdentifier(name);\n            return t;\n          })",
            "p::transformWithLocation(p::doubleQuotedString,\n          [this](Location loc, kj::String text) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setStringLiteral(text);\n            return t;\n          })",
            "p::transformWithLocation(p::doubleQuotedHexBinary,\n          [this](Location loc, kj::Array<byte> data) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setBinaryLiteral(data);\n            return t;\n          })",
            "p::transformWithLocation(p::integer,\n          [this](Location loc, uint64_t i) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setIntegerLiteral(i);\n            return t;\n          })",
            "p::transformWithLocation(p::number,\n          [this](Location loc, double x) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setFloatLiteral(x);\n            return t;\n          })",
            "p::transformWithLocation(\n          p::charsToString(p::oneOrMore(p::anyOfChars(\"!$%&*+-./:<=>?@^|~\"))),\n          [this](Location loc, kj::String text) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setOperator(text);\n            return t;\n          })",
            "p::transformWithLocation(\n          sequence(p::exactChar<'('>(), commaDelimitedList, p::exactChar<')'>()),\n          [this](Location loc, kj::Array<kj::Array<Orphan<Token>>>&& items) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            buildTokenSequenceList(\n                initTok(t, loc).initParenthesizedList(items.size()), kj::mv(items));\n            return t;\n          })",
            "p::transformWithLocation(\n          sequence(p::exactChar<'['>(), commaDelimitedList, p::exactChar<']'>()),\n          [this](Location loc, kj::Array<kj::Array<Orphan<Token>>>&& items) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            buildTokenSequenceList(\n                initTok(t, loc).initBracketedList(items.size()), kj::mv(items));\n            return t;\n          })",
            "p::transformOrReject(p::transformWithLocation(\n          p::oneOf(sequence(p::exactChar<'\\xff'>(), p::exactChar<'\\xfe'>()),\n                   sequence(p::exactChar<'\\xfe'>(), p::exactChar<'\\xff'>()),\n                   sequence(p::exactChar<'\\x00'>())),\n          [this, &errorReporter](Location loc) -> kj::Maybe<Orphan<Token>> {\n            errorReporter.addError(loc.begin(), loc.end(),\n                \"Non-UTF-8 input detected. Cap'n Proto schema files must be UTF-8 text.\");\n            return nullptr;\n          }), [](kj::Maybe<Orphan<Token>> param) { return param; })"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::transformOrReject",
          "args": [
            "p::transformWithLocation(\n          p::oneOf(sequence(p::exactChar<'\\xff'>(), p::exactChar<'\\xfe'>()),\n                   sequence(p::exactChar<'\\xfe'>(), p::exactChar<'\\xff'>()),\n                   sequence(p::exactChar<'\\x00'>())),\n          [this, &errorReporter](Location loc) -> kj::Maybe<Orphan<Token>> {\n            errorReporter.addError(loc.begin(), loc.end(),\n                \"Non-UTF-8 input detected. Cap'n Proto schema files must be UTF-8 text.\");\n            return nullptr;\n          })",
            "[](kj::Maybe<Orphan<Token>> param) { return param; }"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "transformOrReject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "709-715",
          "snippet": "constexpr TransformOrReject_<SubParser, TransformFunc> transformOrReject(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Like `transform()` except that `functor` returns a `Maybe`.  If it returns null, parsing fails,\n  // otherwise the parser's result is the content of the `Maybe`.\n  return TransformOrReject_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr TransformOrReject_<SubParser, TransformFunc> transformOrReject(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Like `transform()` except that `functor` returns a `Maybe`.  If it returns null, parsing fails,\n  // otherwise the parser's result is the content of the `Maybe`.\n  return TransformOrReject_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}"
        }
      },
      {
        "call_info": {
          "callee": "errorReporter.addError",
          "args": [
            "loc.begin()",
            "loc.end()",
            "\"Non-UTF-8 input detected. Cap'n Proto schema files must be UTF-8 text.\""
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "addError",
          "container": "TestFailingErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer-test.c++",
          "lines": "32-34",
          "snippet": "void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n    KJ_FAIL_EXPECT(\"Parse failed.\", startByte, endByte, message);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"../message.h\"",
            "#include \"lexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"../message.h\"\n#include \"lexer.h\"\n\nTestFailingErrorReporter {\n  void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n      KJ_FAIL_EXPECT(\"Parse failed.\", startByte, endByte, message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "p::oneOf",
          "args": [
            "sequence(p::exactChar<'\\xff'>(), p::exactChar<'\\xfe'>())",
            "sequence(p::exactChar<'\\xfe'>(), p::exactChar<'\\xff'>())",
            "sequence(p::exactChar<'\\x00'>())"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sequence",
          "args": [
            "p::exactChar<'\\x00'>()"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sequence",
          "args": [
            "p::exactChar<'\\xfe'>()",
            "p::exactChar<'\\xff'>()"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sequence",
          "args": [
            "p::exactChar<'\\xff'>()",
            "p::exactChar<'\\xfe'>()"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buildTokenSequenceList",
          "args": [
            "initTok(t, loc).initBracketedList(items.size())",
            "kj::mv(items)"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "buildTokenSequenceList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer.c++",
          "lines": "86-95",
          "snippet": "void buildTokenSequenceList(List<List<Token>>::Builder builder,\n                            kj::Array<kj::Array<Orphan<Token>>>&& items) {\n  for (uint i = 0; i < items.size(); i++) {\n    auto& item = items[i];\n    auto itemBuilder = builder.init(i, item.size());\n    for (uint j = 0; j < item.size(); j++) {\n      itemBuilder.adoptWithCaveats(j, kj::mv(item[j]));\n    }\n  }\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include <kj/parse/char.h>",
            "#include \"lexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include <kj/parse/char.h>\n#include \"lexer.h\"\n\nvoid buildTokenSequenceList(List<List<Token>>::Builder builder,\n                            kj::Array<kj::Array<Orphan<Token>>>&& items) {\n  for (uint i = 0; i < items.size(); i++) {\n    auto& item = items[i];\n    auto itemBuilder = builder.init(i, item.size());\n    for (uint j = 0; j < item.size(); j++) {\n      itemBuilder.adoptWithCaveats(j, kj::mv(item[j]));\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "items"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initTok",
          "args": [
            "items.size()"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initTok",
          "args": [
            "t",
            "loc"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "initTok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer.c++",
          "lines": "79-84",
          "snippet": "Token::Builder initTok(Orphan<Token>& t, const Location& loc) {\n  auto builder = t.get();\n  builder.setStartByte(loc.begin());\n  builder.setEndByte(loc.end());\n  return builder;\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include <kj/parse/char.h>",
            "#include \"lexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include <kj/parse/char.h>\n#include \"lexer.h\"\n\nToken::Builder initTok(Orphan<Token>& t, const Location& loc) {\n  auto builder = t.get();\n  builder.setStartByte(loc.begin());\n  builder.setEndByte(loc.end());\n  return builder;\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Token>",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sequence",
          "args": [
            "p::exactChar<'['>()",
            "commaDelimitedList",
            "p::exactChar<']'>()"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "items"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initTok",
          "args": [
            "items.size()"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Token>",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sequence",
          "args": [
            "p::exactChar<'('>()",
            "commaDelimitedList",
            "p::exactChar<')'>()"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initTok",
          "args": [
            "text"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Token>",
          "args": [],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::charsToString",
          "args": [
            "p::oneOrMore(p::anyOfChars(\"!$%&*+-./:<=>?@^|~\"))"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "charsToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/char.h",
          "lines": "172-176",
          "snippet": "constexpr inline auto charsToString(SubParser&& subParser)\n    -> decltype(transform(kj::fwd<SubParser>(subParser), _::ArrayToString())) {\n  // Wraps a parser that returns Array<char> such that it returns String instead.\n  return parse::transform(kj::fwd<SubParser>(subParser), _::ArrayToString());\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include \"../string.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include \"../string.h\"\n#include \"common.h\"\n\nconstexpr inline auto charsToString(SubParser&& subParser)\n    -> decltype(transform(kj::fwd<SubParser>(subParser), _::ArrayToString())) {\n  // Wraps a parser that returns Array<char> such that it returns String instead.\n  return parse::transform(kj::fwd<SubParser>(subParser), _::ArrayToString());\n}"
        }
      },
      {
        "call_info": {
          "callee": "p::oneOrMore",
          "args": [
            "p::anyOfChars(\"!$%&*+-./:<=>?@^|~\")"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "oneOrMore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "439-442",
          "snippet": "constexpr Many_<SubParser, true> oneOrMore(SubParser&& subParser) {\n  // Like `many()` but the parser must parse at least one item to be successful.\n  return Many_<SubParser, true>(kj::fwd<SubParser>(subParser));\n}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr Many_<SubParser, true> oneOrMore(SubParser&& subParser) {\n  // Like `many()` but the parser must parse at least one item to be successful.\n  return Many_<SubParser, true>(kj::fwd<SubParser>(subParser));\n}"
        }
      },
      {
        "call_info": {
          "callee": "p::anyOfChars",
          "args": [
            "\"!$%&*+-./:<=>?@^|~\""
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "anyOfChars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/char.h",
          "lines": "151-157",
          "snippet": "constexpr inline CharGroup_ anyOfChars(const char* chars) {\n  // Returns a parser that accepts any of the characters in the given string (which should usually\n  // be a literal).  The returned parser is of the same type as returned by `charRange()` -- see\n  // that function for more info.\n\n  return CharGroup_().orAny(chars);\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include \"../string.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include \"../string.h\"\n#include \"common.h\"\n\nconstexpr inline CharGroup_ anyOfChars(const char* chars) {\n  // Returns a parser that accepts any of the characters in the given string (which should usually\n  // be a literal).  The returned parser is of the same type as returned by `charRange()` -- see\n  // that function for more info.\n\n  return CharGroup_().orAny(chars);\n}"
        }
      },
      {
        "call_info": {
          "callee": "initTok",
          "args": [
            "x"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Token>",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initTok",
          "args": [
            "i"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Token>",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initTok",
          "args": [
            "data"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Token>",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initTok",
          "args": [
            "text"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Token>",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initTok",
          "args": [
            "name"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<Token>",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.copy",
          "args": [
            "p::transform(\n      p::sequence(tokenSequence, p::many(p::sequence(p::exactChar<','>(), tokenSequence))),\n      [this](kj::Array<Orphan<Token>>&& first, kj::Array<kj::Array<Orphan<Token>>>&& rest)\n          -> kj::Array<kj::Array<Orphan<Token>>> {\n        if (first == nullptr && rest == nullptr) {\n          // Completely empty list.\n          return nullptr;\n        } else {\n          auto result = kj::heapArrayBuilder<kj::Array<Orphan<Token>>>(rest.size() + 1);\n          result.add(kj::mv(first));\n          for (auto& item: rest) {\n            result.add(kj::mv(item));\n          }\n          return result.finish();\n        }\n      })"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.finish",
          "args": [],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.add",
          "args": [
            "kj::mv(item)"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "item"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "first"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArrayBuilder<kj::Array<Orphan<Token>>>",
          "args": [
            "rest.size() + 1"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "tokenSequence",
            "p::many(p::sequence(p::exactChar<','>(), tokenSequence))"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "p::exactChar<','>()",
            "tokenSequence"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include <kj/parse/char.h>\n#include \"lexer.h\"\n\nLexer::Lexer(Orphanage orphanageParam, ErrorReporter& errorReporter)\n    : orphanage(orphanageParam) {\n\n  // Note that because passing an lvalue to a parser constructor uses it by-referencee, it's safe\n  // for us to use parsers.tokenSequence even though we haven't yet constructed it.\n  auto& tokenSequence = parsers.tokenSequence;\n\n  auto& commaDelimitedList = arena.copy(p::transform(\n      p::sequence(tokenSequence, p::many(p::sequence(p::exactChar<','>(), tokenSequence))),\n      [this](kj::Array<Orphan<Token>>&& first, kj::Array<kj::Array<Orphan<Token>>>&& rest)\n          -> kj::Array<kj::Array<Orphan<Token>>> {\n        if (first == nullptr && rest == nullptr) {\n          // Completely empty list.\n          return nullptr;\n        } else {\n          auto result = kj::heapArrayBuilder<kj::Array<Orphan<Token>>>(rest.size() + 1);\n          result.add(kj::mv(first));\n          for (auto& item: rest) {\n            result.add(kj::mv(item));\n          }\n          return result.finish();\n        }\n      }));\n\n  auto& token = arena.copy(p::oneOf(\n      p::transformWithLocation(p::identifier,\n          [this](Location loc, kj::String name) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setIdentifier(name);\n            return t;\n          }),\n      p::transformWithLocation(p::doubleQuotedString,\n          [this](Location loc, kj::String text) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setStringLiteral(text);\n            return t;\n          }),\n      p::transformWithLocation(p::doubleQuotedHexBinary,\n          [this](Location loc, kj::Array<byte> data) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setBinaryLiteral(data);\n            return t;\n          }),\n      p::transformWithLocation(p::integer,\n          [this](Location loc, uint64_t i) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setIntegerLiteral(i);\n            return t;\n          }),\n      p::transformWithLocation(p::number,\n          [this](Location loc, double x) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setFloatLiteral(x);\n            return t;\n          }),\n      p::transformWithLocation(\n          p::charsToString(p::oneOrMore(p::anyOfChars(\"!$%&*+-./:<=>?@^|~\"))),\n          [this](Location loc, kj::String text) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            initTok(t, loc).setOperator(text);\n            return t;\n          }),\n      p::transformWithLocation(\n          sequence(p::exactChar<'('>(), commaDelimitedList, p::exactChar<')'>()),\n          [this](Location loc, kj::Array<kj::Array<Orphan<Token>>>&& items) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            buildTokenSequenceList(\n                initTok(t, loc).initParenthesizedList(items.size()), kj::mv(items));\n            return t;\n          }),\n      p::transformWithLocation(\n          sequence(p::exactChar<'['>(), commaDelimitedList, p::exactChar<']'>()),\n          [this](Location loc, kj::Array<kj::Array<Orphan<Token>>>&& items) -> Orphan<Token> {\n            auto t = orphanage.newOrphan<Token>();\n            buildTokenSequenceList(\n                initTok(t, loc).initBracketedList(items.size()), kj::mv(items));\n            return t;\n          }),\n      p::transformOrReject(p::transformWithLocation(\n          p::oneOf(sequence(p::exactChar<'\\xff'>(), p::exactChar<'\\xfe'>()),\n                   sequence(p::exactChar<'\\xfe'>(), p::exactChar<'\\xff'>()),\n                   sequence(p::exactChar<'\\x00'>())),\n          [this, &errorReporter](Location loc) -> kj::Maybe<Orphan<Token>> {\n            errorReporter.addError(loc.begin(), loc.end(),\n                \"Non-UTF-8 input detected. Cap'n Proto schema files must be UTF-8 text.\");\n            return nullptr;\n          }), [](kj::Maybe<Orphan<Token>> param) { return param; })));\n  parsers.tokenSequence = arena.copy(p::sequence(\n      commentsAndWhitespace, p::many(p::sequence(token, commentsAndWhitespace))));\n\n  auto& statementSequence = parsers.statementSequence;\n\n  auto& statementEnd = arena.copy(p::oneOf(\n      transform(p::sequence(p::exactChar<';'>(), docComment),\n          [this](kj::Maybe<kj::Array<kj::String>>&& comment) -> Orphan<Statement> {\n            auto result = orphanage.newOrphan<Statement>();\n            auto builder = result.get();\n            KJ_IF_MAYBE(c, comment) {\n              attachDocComment(builder, kj::mv(*c));\n            }\n            builder.setLine();\n            return result;\n          }),\n      transform(\n          p::sequence(p::exactChar<'{'>(), docComment, statementSequence, p::exactChar<'}'>(),\n                      docComment),\n          [this](kj::Maybe<kj::Array<kj::String>>&& comment,\n                 kj::Array<Orphan<Statement>>&& statements,\n                 kj::Maybe<kj::Array<kj::String>>&& lateComment)\n              -> Orphan<Statement> {\n            auto result = orphanage.newOrphan<Statement>();\n            auto builder = result.get();\n            KJ_IF_MAYBE(c, comment) {\n              attachDocComment(builder, kj::mv(*c));\n            } else KJ_IF_MAYBE(c, lateComment) {\n              attachDocComment(builder, kj::mv(*c));\n            }\n            auto list = builder.initBlock(statements.size());\n            for (uint i = 0; i < statements.size(); i++) {\n              list.adoptWithCaveats(i, kj::mv(statements[i]));\n            }\n            return result;\n          })\n      ));\n\n  auto& statement = arena.copy(p::transformWithLocation(p::sequence(tokenSequence, statementEnd),\n      [this](Location loc, kj::Array<Orphan<Token>>&& tokens, Orphan<Statement>&& statement) {\n        auto builder = statement.get();\n        auto tokensBuilder = builder.initTokens(tokens.size());\n        for (uint i = 0; i < tokens.size(); i++) {\n          tokensBuilder.adoptWithCaveats(i, kj::mv(tokens[i]));\n        }\n        builder.setStartByte(loc.begin());\n        builder.setEndByte(loc.end());\n        return kj::mv(statement);\n      }));\n\n  parsers.statementSequence = arena.copy(sequence(\n      commentsAndWhitespace, many(sequence(statement, commentsAndWhitespace))));\n\n  parsers.token = token;\n  parsers.statement = statement;\n  parsers.emptySpace = commentsAndWhitespace;\n}"
  },
  {
    "function_name": "attachDocComment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer.c++",
    "lines": "97-110",
    "snippet": "void attachDocComment(Statement::Builder statement, kj::Array<kj::String>&& comment) {\n  size_t size = 0;\n  for (auto& line: comment) {\n    size += line.size() + 1;  // include newline\n  }\n  Text::Builder builder = statement.initDocComment(size);\n  char* pos = builder.begin();\n  for (auto& line: comment) {\n    memcpy(pos, line.begin(), line.size());\n    pos += line.size();\n    *pos++ = '\\n';\n  }\n  KJ_ASSERT(pos == builder.end());\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include <kj/parse/char.h>",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "pos == builder.end()"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.end",
          "args": [],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "77-77",
          "snippet": "inline Iterator end() const { return Iterator(amount); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator end() const { return Iterator(amount); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "line.size",
          "args": [],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pos",
            "line.begin()",
            "line.size()"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.begin",
          "args": [],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "76-76",
          "snippet": "inline Iterator begin() const { return Iterator(0); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "statement.initDocComment",
          "args": [
            "size"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include <kj/parse/char.h>\n#include \"lexer.h\"\n\nvoid attachDocComment(Statement::Builder statement, kj::Array<kj::String>&& comment) {\n  size_t size = 0;\n  for (auto& line: comment) {\n    size += line.size() + 1;  // include newline\n  }\n  Text::Builder builder = statement.initDocComment(size);\n  char* pos = builder.begin();\n  for (auto& line: comment) {\n    memcpy(pos, line.begin(), line.size());\n    pos += line.size();\n    *pos++ = '\\n';\n  }\n  KJ_ASSERT(pos == builder.end());\n}"
  },
  {
    "function_name": "buildTokenSequenceList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer.c++",
    "lines": "86-95",
    "snippet": "void buildTokenSequenceList(List<List<Token>>::Builder builder,\n                            kj::Array<kj::Array<Orphan<Token>>>&& items) {\n  for (uint i = 0; i < items.size(); i++) {\n    auto& item = items[i];\n    auto itemBuilder = builder.init(i, item.size());\n    for (uint j = 0; j < item.size(); j++) {\n      itemBuilder.adoptWithCaveats(j, kj::mv(item[j]));\n    }\n  }\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include <kj/parse/char.h>",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "itemBuilder.adoptWithCaveats",
          "args": [
            "j",
            "kj::mv(item[j])"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "adoptWithCaveats",
          "container": "Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/list.h",
          "lines": "251-268",
          "snippet": "inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n      // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n      // the fact that structs in a struct list are allocated inline rather than by pointer:\n      // * This actually performs a shallow copy, effectively adopting each of the orphan's\n      //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n      //   possibly wasting space in the message object.\n      // * If the orphan is larger than the target struct -- say, because the orphan was built\n      //   using a newer version of the schema that has additional fields -- it will be truncated,\n      //   losing data.\n\n      KJ_IREQUIRE(index < size());\n\n      // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n      // expanded under any circumstances.  We're just going to throw it away anyway, and\n      // transferContentFrom() already carefully compares the struct sizes before transferring.\n      builder.getStructElement(index * ELEMENTS).transferContentFrom(\n          orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n    }",
          "includes": [
            "#include <iterator>",
            "#include <initializer_list>",
            "#include \"orphan.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <initializer_list>\n#include \"orphan.h\"\n#include \"layout.h\"\n\nBuilder {\n  inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n        // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n        // the fact that structs in a struct list are allocated inline rather than by pointer:\n        // * This actually performs a shallow copy, effectively adopting each of the orphan's\n        //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n        //   possibly wasting space in the message object.\n        // * If the orphan is larger than the target struct -- say, because the orphan was built\n        //   using a newer version of the schema that has additional fields -- it will be truncated,\n        //   losing data.\n  \n        KJ_IREQUIRE(index < size());\n  \n        // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n        // expanded under any circumstances.  We're just going to throw it away anyway, and\n        // transferContentFrom() already carefully compares the struct sizes before transferring.\n        builder.getStructElement(index * ELEMENTS).transferContentFrom(\n            orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "item[j]"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item.size",
          "args": [],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.init",
          "args": [
            "i",
            "item.size()"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/pointer-helpers.h",
          "lines": "120-122",
          "snippet": "static inline typename T::Builder init(PointerBuilder builder, uint size) {\n    return builder.initBlob<T>(size * BYTES);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"layout.h\"\n\nstatic inline typename T::Builder init(PointerBuilder builder, uint size) {\n    return builder.initBlob<T>(size * BYTES);\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include <kj/parse/char.h>\n#include \"lexer.h\"\n\nvoid buildTokenSequenceList(List<List<Token>>::Builder builder,\n                            kj::Array<kj::Array<Orphan<Token>>>&& items) {\n  for (uint i = 0; i < items.size(); i++) {\n    auto& item = items[i];\n    auto itemBuilder = builder.init(i, item.size());\n    for (uint j = 0; j < item.size(); j++) {\n      itemBuilder.adoptWithCaveats(j, kj::mv(item[j]));\n    }\n  }\n}"
  },
  {
    "function_name": "initTok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer.c++",
    "lines": "79-84",
    "snippet": "Token::Builder initTok(Orphan<Token>& t, const Location& loc) {\n  auto builder = t.get();\n  builder.setStartByte(loc.begin());\n  builder.setEndByte(loc.end());\n  return builder;\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include <kj/parse/char.h>",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.setEndByte",
          "args": [
            "loc.end()"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loc.end",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "77-77",
          "snippet": "inline Iterator end() const { return Iterator(amount); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator end() const { return Iterator(amount); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.setStartByte",
          "args": [
            "loc.begin()"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loc.begin",
          "args": [],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "76-76",
          "snippet": "inline Iterator begin() const { return Iterator(0); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t.get",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "getPosition",
          "container": "Lexer::ParserInput",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer.h",
          "lines": "72-74",
          "snippet": "inline uint32_t getPosition() {\n      return IteratorInput<char, const char*>::getPosition() - begin;\n    }",
          "includes": [
            "#include \"error-reporter.h\"",
            "#include <kj/arena.h>",
            "#include <kj/parse/common.h>",
            "#include <capnp/compiler/lexer.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"error-reporter.h\"\n#include <kj/arena.h>\n#include <kj/parse/common.h>\n#include <capnp/compiler/lexer.capnp.h>\n\nLexer {\n  ParserInput {\n    inline uint32_t getPosition() {\n          return IteratorInput<char, const char*>::getPosition() - begin;\n        }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include <kj/parse/char.h>\n#include \"lexer.h\"\n\nToken::Builder initTok(Orphan<Token>& t, const Location& loc) {\n  auto builder = t.get();\n  builder.setStartByte(loc.begin());\n  builder.setEndByte(loc.end());\n  return builder;\n}"
  },
  {
    "function_name": "lex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer.c++",
    "lines": "53-72",
    "snippet": "bool lex(kj::ArrayPtr<const char> input, LexedTokens::Builder result,\n         ErrorReporter& errorReporter) {\n  Lexer lexer(Orphanage::getForMessageContaining(result), errorReporter);\n\n  auto parser = p::sequence(lexer.getParsers().tokenSequence, p::endOfInput);\n\n  Lexer::ParserInput parserInput(input.begin(), input.end());\n  kj::Maybe<kj::Array<Orphan<Token>>> parseOutput = parser(parserInput);\n\n  KJ_IF_MAYBE(output, parseOutput) {\n    auto l = result.initTokens(output->size());\n    for (uint i = 0; i < output->size(); i++) {\n      l.adoptWithCaveats(i, kj::mv((*output)[i]));\n    }\n    return true;\n  } else {\n    uint32_t best = parserInput.getBest();\n    errorReporter.addError(best, best, kj::str(\"Parse error.\"));\n    return false;\n  }",
    "includes": [
      "#include <kj/debug.h>",
      "#include <kj/parse/char.h>",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "errorReporter.addError",
          "args": [
            "best",
            "best",
            "kj::str(\"Parse error.\")"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "addError",
          "container": "TestFailingErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer-test.c++",
          "lines": "32-34",
          "snippet": "void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n    KJ_FAIL_EXPECT(\"Parse failed.\", startByte, endByte, message);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"../message.h\"",
            "#include \"lexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"../message.h\"\n#include \"lexer.h\"\n\nTestFailingErrorReporter {\n  void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n      KJ_FAIL_EXPECT(\"Parse failed.\", startByte, endByte, message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Parse error.\""
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "341-341",
          "snippet": "inline String str(String&& s) { return mv(s); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
        }
      },
      {
        "call_info": {
          "callee": "parserInput.getBest",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "getBest",
          "container": "Lexer::ParserInput",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer.h",
          "lines": "69-71",
          "snippet": "inline uint32_t getBest() {\n      return IteratorInput<char, const char*>::getBest() - begin;\n    }",
          "includes": [
            "#include \"error-reporter.h\"",
            "#include <kj/arena.h>",
            "#include <kj/parse/common.h>",
            "#include <capnp/compiler/lexer.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"error-reporter.h\"\n#include <kj/arena.h>\n#include <kj/parse/common.h>\n#include <capnp/compiler/lexer.capnp.h>\n\nLexer {\n  ParserInput {\n    inline uint32_t getBest() {\n          return IteratorInput<char, const char*>::getBest() - begin;\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "l.adoptWithCaveats",
          "args": [
            "i",
            "kj::mv((*output)[i])"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "adoptWithCaveats",
          "container": "Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/list.h",
          "lines": "251-268",
          "snippet": "inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n      // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n      // the fact that structs in a struct list are allocated inline rather than by pointer:\n      // * This actually performs a shallow copy, effectively adopting each of the orphan's\n      //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n      //   possibly wasting space in the message object.\n      // * If the orphan is larger than the target struct -- say, because the orphan was built\n      //   using a newer version of the schema that has additional fields -- it will be truncated,\n      //   losing data.\n\n      KJ_IREQUIRE(index < size());\n\n      // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n      // expanded under any circumstances.  We're just going to throw it away anyway, and\n      // transferContentFrom() already carefully compares the struct sizes before transferring.\n      builder.getStructElement(index * ELEMENTS).transferContentFrom(\n          orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n    }",
          "includes": [
            "#include <iterator>",
            "#include <initializer_list>",
            "#include \"orphan.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <initializer_list>\n#include \"orphan.h\"\n#include \"layout.h\"\n\nBuilder {\n  inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n        // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n        // the fact that structs in a struct list are allocated inline rather than by pointer:\n        // * This actually performs a shallow copy, effectively adopting each of the orphan's\n        //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n        //   possibly wasting space in the message object.\n        // * If the orphan is larger than the target struct -- say, because the orphan was built\n        //   using a newer version of the schema that has additional fields -- it will be truncated,\n        //   losing data.\n  \n        KJ_IREQUIRE(index < size());\n  \n        // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n        // expanded under any circumstances.  We're just going to throw it away anyway, and\n        // transferContentFrom() already carefully compares the struct sizes before transferring.\n        builder.getStructElement(index * ELEMENTS).transferContentFrom(\n            orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "(*output)[i]"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output->size",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.initTokens",
          "args": [
            "output->size()"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser",
          "args": [
            "parserInput"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.end",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "77-77",
          "snippet": "inline Iterator end() const { return Iterator(amount); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator end() const { return Iterator(amount); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input.begin",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "76-76",
          "snippet": "inline Iterator begin() const { return Iterator(0); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "lexer.getParsers().tokenSequence",
            "p::endOfInput"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lexer.getParsers",
          "args": [],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include <kj/parse/char.h>\n#include \"lexer.h\"\n\nbool lex(kj::ArrayPtr<const char> input, LexedTokens::Builder result,\n         ErrorReporter& errorReporter) {\n  Lexer lexer(Orphanage::getForMessageContaining(result), errorReporter);\n\n  auto parser = p::sequence(lexer.getParsers().tokenSequence, p::endOfInput);\n\n  Lexer::ParserInput parserInput(input.begin(), input.end());\n  kj::Maybe<kj::Array<Orphan<Token>>> parseOutput = parser(parserInput);\n\n  KJ_IF_MAYBE(output, parseOutput) {\n    auto l = result.initTokens(output->size());\n    for (uint i = 0; i < output->size(); i++) {\n      l.adoptWithCaveats(i, kj::mv((*output)[i]));\n    }\n    return true;\n  } else {\n    uint32_t best = parserInput.getBest();\n    errorReporter.addError(best, best, kj::str(\"Parse error.\"));\n    return false;\n  }"
  },
  {
    "function_name": "lex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer.c++",
    "lines": "31-50",
    "snippet": "bool lex(kj::ArrayPtr<const char> input, LexedStatements::Builder result,\n         ErrorReporter& errorReporter) {\n  Lexer lexer(Orphanage::getForMessageContaining(result), errorReporter);\n\n  auto parser = p::sequence(lexer.getParsers().statementSequence, p::endOfInput);\n\n  Lexer::ParserInput parserInput(input.begin(), input.end());\n  kj::Maybe<kj::Array<Orphan<Statement>>> parseOutput = parser(parserInput);\n\n  KJ_IF_MAYBE(output, parseOutput) {\n    auto l = result.initStatements(output->size());\n    for (uint i = 0; i < output->size(); i++) {\n      l.adoptWithCaveats(i, kj::mv((*output)[i]));\n    }\n    return true;\n  } else {\n    uint32_t best = parserInput.getBest();\n    errorReporter.addError(best, best, kj::str(\"Parse error.\"));\n    return false;\n  }",
    "includes": [
      "#include <kj/debug.h>",
      "#include <kj/parse/char.h>",
      "#include \"lexer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "errorReporter.addError",
          "args": [
            "best",
            "best",
            "kj::str(\"Parse error.\")"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "addError",
          "container": "TestFailingErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer-test.c++",
          "lines": "32-34",
          "snippet": "void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n    KJ_FAIL_EXPECT(\"Parse failed.\", startByte, endByte, message);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"../message.h\"",
            "#include \"lexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"../message.h\"\n#include \"lexer.h\"\n\nTestFailingErrorReporter {\n  void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n      KJ_FAIL_EXPECT(\"Parse failed.\", startByte, endByte, message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Parse error.\""
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "341-341",
          "snippet": "inline String str(String&& s) { return mv(s); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
        }
      },
      {
        "call_info": {
          "callee": "parserInput.getBest",
          "args": [],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "getBest",
          "container": "Lexer::ParserInput",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer.h",
          "lines": "69-71",
          "snippet": "inline uint32_t getBest() {\n      return IteratorInput<char, const char*>::getBest() - begin;\n    }",
          "includes": [
            "#include \"error-reporter.h\"",
            "#include <kj/arena.h>",
            "#include <kj/parse/common.h>",
            "#include <capnp/compiler/lexer.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"error-reporter.h\"\n#include <kj/arena.h>\n#include <kj/parse/common.h>\n#include <capnp/compiler/lexer.capnp.h>\n\nLexer {\n  ParserInput {\n    inline uint32_t getBest() {\n          return IteratorInput<char, const char*>::getBest() - begin;\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "l.adoptWithCaveats",
          "args": [
            "i",
            "kj::mv((*output)[i])"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "adoptWithCaveats",
          "container": "Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/list.h",
          "lines": "251-268",
          "snippet": "inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n      // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n      // the fact that structs in a struct list are allocated inline rather than by pointer:\n      // * This actually performs a shallow copy, effectively adopting each of the orphan's\n      //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n      //   possibly wasting space in the message object.\n      // * If the orphan is larger than the target struct -- say, because the orphan was built\n      //   using a newer version of the schema that has additional fields -- it will be truncated,\n      //   losing data.\n\n      KJ_IREQUIRE(index < size());\n\n      // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n      // expanded under any circumstances.  We're just going to throw it away anyway, and\n      // transferContentFrom() already carefully compares the struct sizes before transferring.\n      builder.getStructElement(index * ELEMENTS).transferContentFrom(\n          orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n    }",
          "includes": [
            "#include <iterator>",
            "#include <initializer_list>",
            "#include \"orphan.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <initializer_list>\n#include \"orphan.h\"\n#include \"layout.h\"\n\nBuilder {\n  inline void adoptWithCaveats(uint index, Orphan<T>&& orphan) {\n        // Mostly behaves like you'd expect `adopt` to behave, but with two caveats originating from\n        // the fact that structs in a struct list are allocated inline rather than by pointer:\n        // * This actually performs a shallow copy, effectively adopting each of the orphan's\n        //   children rather than adopting the orphan itself.  The orphan ends up being discarded,\n        //   possibly wasting space in the message object.\n        // * If the orphan is larger than the target struct -- say, because the orphan was built\n        //   using a newer version of the schema that has additional fields -- it will be truncated,\n        //   losing data.\n  \n        KJ_IREQUIRE(index < size());\n  \n        // We pass a zero-valued StructSize to asStruct() because we do not want the struct to be\n        // expanded under any circumstances.  We're just going to throw it away anyway, and\n        // transferContentFrom() already carefully compares the struct sizes before transferring.\n        builder.getStructElement(index * ELEMENTS).transferContentFrom(\n            orphan.builder.asStruct(_::StructSize(0 * WORDS, 0 * POINTERS)));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "(*output)[i]"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output->size",
          "args": [],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.initStatements",
          "args": [
            "output->size()"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser",
          "args": [
            "parserInput"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.end",
          "args": [],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "77-77",
          "snippet": "inline Iterator end() const { return Iterator(amount); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator end() const { return Iterator(amount); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input.begin",
          "args": [],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "76-76",
          "snippet": "inline Iterator begin() const { return Iterator(0); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "p::sequence",
          "args": [
            "lexer.getParsers().statementSequence",
            "p::endOfInput"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lexer.getParsers",
          "args": [],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include <kj/parse/char.h>\n#include \"lexer.h\"\n\nbool lex(kj::ArrayPtr<const char> input, LexedStatements::Builder result,\n         ErrorReporter& errorReporter) {\n  Lexer lexer(Orphanage::getForMessageContaining(result), errorReporter);\n\n  auto parser = p::sequence(lexer.getParsers().statementSequence, p::endOfInput);\n\n  Lexer::ParserInput parserInput(input.begin(), input.end());\n  kj::Maybe<kj::Array<Orphan<Statement>>> parseOutput = parser(parserInput);\n\n  KJ_IF_MAYBE(output, parseOutput) {\n    auto l = result.initStatements(output->size());\n    for (uint i = 0; i < output->size(); i++) {\n      l.adoptWithCaveats(i, kj::mv((*output)[i]));\n    }\n    return true;\n  } else {\n    uint32_t best = parserInput.getBest();\n    errorReporter.addError(best, best, kj::str(\"Parse error.\"));\n    return false;\n  }"
  }
]