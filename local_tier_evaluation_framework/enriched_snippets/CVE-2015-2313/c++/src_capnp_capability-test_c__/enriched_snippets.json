[
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "802-824",
    "snippet": "TEST(Capability, ImplicitParams) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  typedef test::TestImplicitMethodParams Interface;\n  Interface::Client client = nullptr;\n\n  capnp::Request<Interface::CallParams<Text, TestAllTypes>,\n                 test::TestGenerics<Text, TestAllTypes>> request =\n      client.callRequest<Text, TestAllTypes>();\n  request.setFoo(\"hello\");\n  initTestMessage(request.initBar());\n\n  auto promise = request.send()\n      .then([](capnp::Response<test::TestGenerics<Text, TestAllTypes>>&& response) {\n    // This doesn't actually execute; we're just checking that it compiles.\n    Text::Reader text = response.getFoo();\n    text.size();\n    checkTestMessage(response.getRev().getFoo());\n  }, [](kj::Exception&& e) {});\n\n  promise.wait(waitScope);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [
            "[](capnp::Response<test::TestGenerics<Text, TestAllTypes>>&& response) {\n    // This doesn't actually execute; we're just checking that it compiles.\n    Text::Reader text = response.getFoo();\n    text.size();\n    checkTestMessage(response.getRev().getFoo());\n  }",
            "[](kj::Exception&& e) {}"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "LocalRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "207-241",
          "snippet": "RemotePromise<AnyPointer> send() override {\n    KJ_REQUIRE(message.get() != nullptr, \"Already called send() on this request.\");\n\n    // For the lambda capture.\n    uint64_t interfaceId = this->interfaceId;\n    uint16_t methodId = this->methodId;\n\n    auto cancelPaf = kj::newPromiseAndFulfiller<void>();\n\n    auto context = kj::refcounted<LocalCallContext>(\n        kj::mv(message), client->addRef(), kj::mv(cancelPaf.fulfiller));\n    auto promiseAndPipeline = client->call(interfaceId, methodId, kj::addRef(*context));\n\n    // We have to make sure the call is not canceled unless permitted.  We need to fork the promise\n    // so that if the client drops their copy, the promise isn't necessarily canceled.\n    auto forked = promiseAndPipeline.promise.fork();\n\n    // We daemonize one branch, but only after joining it with the promise that fires if\n    // cancellation is allowed.\n    forked.addBranch()\n        .attach(kj::addRef(*context))\n        .exclusiveJoin(kj::mv(cancelPaf.promise))\n        .detach([](kj::Exception&&) {});  // ignore exceptions\n\n    // Now the other branch returns the response from the context.\n    auto promise = forked.addBranch().then(kj::mvCapture(context,\n        [](kj::Own<LocalCallContext>&& context) {\n      context->getResults(MessageSize { 0, 0 });  // force response allocation\n      return kj::mv(KJ_ASSERT_NONNULL(context->response));\n    }));\n\n    // We return the other branch.\n    return RemotePromise<AnyPointer>(\n        kj::mv(promise), AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline)));\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<MallocMessageBuilder>> request;",
            "kj::Maybe<Response<AnyPointer>> response;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<kj::Own<MallocMessageBuilder>> request;\nkj::Maybe<Response<AnyPointer>> response;\n\nLocalRequest {\n  RemotePromise<AnyPointer> send() override {\n      KJ_REQUIRE(message.get() != nullptr, \"Already called send() on this request.\");\n  \n      // For the lambda capture.\n      uint64_t interfaceId = this->interfaceId;\n      uint16_t methodId = this->methodId;\n  \n      auto cancelPaf = kj::newPromiseAndFulfiller<void>();\n  \n      auto context = kj::refcounted<LocalCallContext>(\n          kj::mv(message), client->addRef(), kj::mv(cancelPaf.fulfiller));\n      auto promiseAndPipeline = client->call(interfaceId, methodId, kj::addRef(*context));\n  \n      // We have to make sure the call is not canceled unless permitted.  We need to fork the promise\n      // so that if the client drops their copy, the promise isn't necessarily canceled.\n      auto forked = promiseAndPipeline.promise.fork();\n  \n      // We daemonize one branch, but only after joining it with the promise that fires if\n      // cancellation is allowed.\n      forked.addBranch()\n          .attach(kj::addRef(*context))\n          .exclusiveJoin(kj::mv(cancelPaf.promise))\n          .detach([](kj::Exception&&) {});  // ignore exceptions\n  \n      // Now the other branch returns the response from the context.\n      auto promise = forked.addBranch().then(kj::mvCapture(context,\n          [](kj::Own<LocalCallContext>&& context) {\n        context->getResults(MessageSize { 0, 0 });  // force response allocation\n        return kj::mv(KJ_ASSERT_NONNULL(context->response));\n      }));\n  \n      // We return the other branch.\n      return RemotePromise<AnyPointer>(\n          kj::mv(promise), AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkTestMessage",
          "args": [
            "response.getRev().getFoo()"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "checkTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "844-844",
          "snippet": "void checkTestMessage(TestListDefaults::Reader reader) { genericCheckListDefaults(reader); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid checkTestMessage(TestListDefaults::Reader reader) { genericCheckListDefaults(reader); }"
        }
      },
      {
        "call_info": {
          "callee": "response.getRev",
          "args": [],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getRev",
          "args": [],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text.size",
          "args": [],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "response.getFoo",
          "args": [],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "initTestMessage",
          "args": [
            "request.initBar()"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "initTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "836-836",
          "snippet": "void initTestMessage(TestListDefaults::Builder builder) { genericInitListDefaults(builder); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid initTestMessage(TestListDefaults::Builder builder) { genericInitListDefaults(builder); }"
        }
      },
      {
        "call_info": {
          "callee": "request.initBar",
          "args": [],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setFoo",
          "args": [
            "\"hello\""
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.callRequest<Text, TestAllTypes>",
          "args": [],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTEST(Capability, ImplicitParams) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  typedef test::TestImplicitMethodParams Interface;\n  Interface::Client client = nullptr;\n\n  capnp::Request<Interface::CallParams<Text, TestAllTypes>,\n                 test::TestGenerics<Text, TestAllTypes>> request =\n      client.callRequest<Text, TestAllTypes>();\n  request.setFoo(\"hello\");\n  initTestMessage(request.initBar());\n\n  auto promise = request.send()\n      .then([](capnp::Response<test::TestGenerics<Text, TestAllTypes>>&& response) {\n    // This doesn't actually execute; we're just checking that it compiles.\n    Text::Reader text = response.getFoo();\n    text.size();\n    checkTestMessage(response.getRev().getFoo());\n  }, [](kj::Exception&& e) {});\n\n  promise.wait(waitScope);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "795-800",
    "snippet": "TEST(Capability, Generics2) {\n  MallocMessageBuilder builder;\n  auto root = builder.getRoot<test::TestUseGenerics>();\n\n  root.initCap().setFoo(test::TestInterface::Client(nullptr));\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "root.initCap",
          "args": [
            "test::TestInterface::Client(nullptr)"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test::TestInterface::Client",
          "args": [
            "nullptr"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "root.initCap",
          "args": [],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getRoot<test::TestUseGenerics>",
          "args": [],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTEST(Capability, Generics2) {\n  MallocMessageBuilder builder;\n  auto root = builder.getRoot<test::TestUseGenerics>();\n\n  root.initCap().setFoo(test::TestInterface::Client(nullptr));\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "773-793",
    "snippet": "TEST(Capability, Generics) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  typedef test::TestGenerics<TestAllTypes>::Interface<List<uint32_t>> Interface;\n  Interface::Client client = nullptr;\n\n  auto request = client.callRequest();\n  request.setBaz(\"hello\");\n  initTestMessage(request.initInnerBound().initFoo());\n  initTestMessage(request.initInnerUnbound().getFoo().initAs<TestAllTypes>());\n\n  auto promise = request.send().then([](capnp::Response<Interface::CallResults>&& response) {\n    // This doesn't actually execute; we're just checking that it compiles.\n    List<uint32_t>::Reader qux = response.getQux();\n    qux.size();\n    checkTestMessage(response.getGen().getFoo());\n  }, [](kj::Exception&& e) {});\n\n  promise.wait(waitScope);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [
            "[](capnp::Response<Interface::CallResults>&& response) {\n    // This doesn't actually execute; we're just checking that it compiles.\n    List<uint32_t>::Reader qux = response.getQux();\n    qux.size();\n    checkTestMessage(response.getGen().getFoo());\n  }",
            "[](kj::Exception&& e) {}"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "LocalRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "207-241",
          "snippet": "RemotePromise<AnyPointer> send() override {\n    KJ_REQUIRE(message.get() != nullptr, \"Already called send() on this request.\");\n\n    // For the lambda capture.\n    uint64_t interfaceId = this->interfaceId;\n    uint16_t methodId = this->methodId;\n\n    auto cancelPaf = kj::newPromiseAndFulfiller<void>();\n\n    auto context = kj::refcounted<LocalCallContext>(\n        kj::mv(message), client->addRef(), kj::mv(cancelPaf.fulfiller));\n    auto promiseAndPipeline = client->call(interfaceId, methodId, kj::addRef(*context));\n\n    // We have to make sure the call is not canceled unless permitted.  We need to fork the promise\n    // so that if the client drops their copy, the promise isn't necessarily canceled.\n    auto forked = promiseAndPipeline.promise.fork();\n\n    // We daemonize one branch, but only after joining it with the promise that fires if\n    // cancellation is allowed.\n    forked.addBranch()\n        .attach(kj::addRef(*context))\n        .exclusiveJoin(kj::mv(cancelPaf.promise))\n        .detach([](kj::Exception&&) {});  // ignore exceptions\n\n    // Now the other branch returns the response from the context.\n    auto promise = forked.addBranch().then(kj::mvCapture(context,\n        [](kj::Own<LocalCallContext>&& context) {\n      context->getResults(MessageSize { 0, 0 });  // force response allocation\n      return kj::mv(KJ_ASSERT_NONNULL(context->response));\n    }));\n\n    // We return the other branch.\n    return RemotePromise<AnyPointer>(\n        kj::mv(promise), AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline)));\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<MallocMessageBuilder>> request;",
            "kj::Maybe<Response<AnyPointer>> response;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<kj::Own<MallocMessageBuilder>> request;\nkj::Maybe<Response<AnyPointer>> response;\n\nLocalRequest {\n  RemotePromise<AnyPointer> send() override {\n      KJ_REQUIRE(message.get() != nullptr, \"Already called send() on this request.\");\n  \n      // For the lambda capture.\n      uint64_t interfaceId = this->interfaceId;\n      uint16_t methodId = this->methodId;\n  \n      auto cancelPaf = kj::newPromiseAndFulfiller<void>();\n  \n      auto context = kj::refcounted<LocalCallContext>(\n          kj::mv(message), client->addRef(), kj::mv(cancelPaf.fulfiller));\n      auto promiseAndPipeline = client->call(interfaceId, methodId, kj::addRef(*context));\n  \n      // We have to make sure the call is not canceled unless permitted.  We need to fork the promise\n      // so that if the client drops their copy, the promise isn't necessarily canceled.\n      auto forked = promiseAndPipeline.promise.fork();\n  \n      // We daemonize one branch, but only after joining it with the promise that fires if\n      // cancellation is allowed.\n      forked.addBranch()\n          .attach(kj::addRef(*context))\n          .exclusiveJoin(kj::mv(cancelPaf.promise))\n          .detach([](kj::Exception&&) {});  // ignore exceptions\n  \n      // Now the other branch returns the response from the context.\n      auto promise = forked.addBranch().then(kj::mvCapture(context,\n          [](kj::Own<LocalCallContext>&& context) {\n        context->getResults(MessageSize { 0, 0 });  // force response allocation\n        return kj::mv(KJ_ASSERT_NONNULL(context->response));\n      }));\n  \n      // We return the other branch.\n      return RemotePromise<AnyPointer>(\n          kj::mv(promise), AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkTestMessage",
          "args": [
            "response.getGen().getFoo()"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "checkTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "844-844",
          "snippet": "void checkTestMessage(TestListDefaults::Reader reader) { genericCheckListDefaults(reader); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid checkTestMessage(TestListDefaults::Reader reader) { genericCheckListDefaults(reader); }"
        }
      },
      {
        "call_info": {
          "callee": "response.getGen",
          "args": [],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getGen",
          "args": [],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qux.size",
          "args": [],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "response.getQux",
          "args": [],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "initTestMessage",
          "args": [
            "request.initInnerUnbound().getFoo().initAs<TestAllTypes>()"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "initTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "836-836",
          "snippet": "void initTestMessage(TestListDefaults::Builder builder) { genericInitListDefaults(builder); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid initTestMessage(TestListDefaults::Builder builder) { genericInitListDefaults(builder); }"
        }
      },
      {
        "call_info": {
          "callee": "request.initInnerUnbound",
          "args": [],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.initInnerUnbound",
          "args": [],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.initInnerUnbound",
          "args": [],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.initInnerBound",
          "args": [],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.initInnerBound",
          "args": [],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setBaz",
          "args": [
            "\"hello\""
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.callRequest",
          "args": [],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTEST(Capability, Generics) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  typedef test::TestGenerics<TestAllTypes>::Interface<List<uint32_t>> Interface;\n  Interface::Client client = nullptr;\n\n  auto request = client.callRequest();\n  request.setBaz(\"hello\");\n  initTestMessage(request.initInnerBound().initFoo());\n  initTestMessage(request.initInnerUnbound().getFoo().initAs<TestAllTypes>());\n\n  auto promise = request.send().then([](capnp::Response<Interface::CallResults>&& response) {\n    // This doesn't actually execute; we're just checking that it compiles.\n    List<uint32_t>::Reader qux = response.getQux();\n    qux.size();\n    checkTestMessage(response.getGen().getFoo());\n  }, [](kj::Exception&& e) {});\n\n  promise.wait(waitScope);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "747-771",
    "snippet": "TEST(Capability, KeywordMethods) {\n  // Verify that keywords are only munged where necessary.\n\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n  bool called = false;\n\n  class TestKeywordMethodsImpl final: public test::TestKeywordMethods::Server {\n  public:\n    TestKeywordMethodsImpl(bool& called): called(called) {}\n\n    kj::Promise<void> delete_(DeleteContext context) override {\n      called = true;\n      return kj::READY_NOW;\n    }\n\n  private:\n    bool& called;\n  };\n\n  test::TestKeywordMethods::Client client = kj::heap<TestKeywordMethodsImpl>(called);\n  client.deleteRequest().send().wait(waitScope);\n\n  EXPECT_TRUE(called);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "called"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.deleteRequest",
          "args": [
            "waitScope"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.deleteRequest",
          "args": [],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.deleteRequest",
          "args": [],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestKeywordMethodsImpl>",
          "args": [
            "called"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTEST(Capability, KeywordMethods) {\n  // Verify that keywords are only munged where necessary.\n\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n  bool called = false;\n\n  class TestKeywordMethodsImpl final: public test::TestKeywordMethods::Server {\n  public:\n    TestKeywordMethodsImpl(bool& called): called(called) {}\n\n    kj::Promise<void> delete_(DeleteContext context) override {\n      called = true;\n      return kj::READY_NOW;\n    }\n\n  private:\n    bool& called;\n  };\n\n  test::TestKeywordMethods::Client client = kj::heap<TestKeywordMethodsImpl>(called);\n  client.deleteRequest().send().wait(waitScope);\n\n  EXPECT_TRUE(called);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "708-745",
    "snippet": "TEST(Capability, Lists) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount1 = 0;\n  int callCount2 = 0;\n  int callCount3 = 0;\n  test::TestPipeline::Client baseClient(kj::heap<TestPipelineImpl>(callCount1));\n  test::TestInterface::Client client1(kj::heap<TestInterfaceImpl>(callCount1));\n  test::TestInterface::Client client2(kj::heap<TestInterfaceImpl>(callCount2));\n  test::TestInterface::Client client3(kj::heap<TestInterfaceImpl>(callCount3));\n\n  auto request = baseClient.testPointersRequest();\n\n  auto list = request.initList(3);\n  list.set(0, client1);\n  list.set(1, client2);\n  list.set(2, client3);\n\n  verifyClient(list[0], callCount1, waitScope);\n  verifyClient(list[1], callCount2, waitScope);\n  verifyClient(list[2], callCount3, waitScope);\n\n  auto listReader = request.asReader().getList();\n  verifyClient(listReader[0], callCount1, waitScope);\n  verifyClient(listReader[1], callCount2, waitScope);\n  verifyClient(listReader[2], callCount3, waitScope);\n\n  auto dynamicList = toDynamic(list);\n  verifyClient(dynamicList[0].as<DynamicCapability>(), callCount1, waitScope);\n  verifyClient(dynamicList[1].as<DynamicCapability>(), callCount2, waitScope);\n  verifyClient(dynamicList[2].as<DynamicCapability>(), callCount3, waitScope);\n\n  auto dynamicListReader = toDynamic(listReader);\n  verifyClient(dynamicListReader[0].as<DynamicCapability>(), callCount1, waitScope);\n  verifyClient(dynamicListReader[1].as<DynamicCapability>(), callCount2, waitScope);\n  verifyClient(dynamicListReader[2].as<DynamicCapability>(), callCount3, waitScope);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verifyClient",
          "args": [
            "dynamicListReader[2].as<DynamicCapability>()",
            "callCount3",
            "waitScope"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "verifyClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
          "lines": "633-642",
          "snippet": "void verifyClient(DynamicCapability::Client client, const int& callCount,\n                  kj::WaitScope& waitScope) {\n  int origCount = callCount;\n  auto request = client.newRequest(\"foo\");\n  request.set(\"i\", 123);\n  request.set(\"j\", true);\n  auto response = request.send().wait(waitScope);\n  EXPECT_EQ(\"foo\", response.get(\"x\").as<Text>());\n  EXPECT_EQ(origCount + 1, callCount);\n}",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\"",
            "#include \"capability.h\"",
            "#include <capnp/test.capnp.h>",
            "#include \"schema.capnp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nvoid verifyClient(DynamicCapability::Client client, const int& callCount,\n                  kj::WaitScope& waitScope) {\n  int origCount = callCount;\n  auto request = client.newRequest(\"foo\");\n  request.set(\"i\", 123);\n  request.set(\"j\", true);\n  auto response = request.send().wait(waitScope);\n  EXPECT_EQ(\"foo\", response.get(\"x\").as<Text>());\n  EXPECT_EQ(origCount + 1, callCount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dynamicListReader[2].as<DynamicCapability>",
          "args": [],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "as",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "601-604",
          "snippet": "BuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nBuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "toDynamic",
          "args": [
            "listReader"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "toDynamic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "1246-1248",
          "snippet": "typename DynamicTypeFor<FromServer<T>>::Client toDynamic(kj::Own<T>&& value) {\n  return typename FromServer<T>::Client(kj::mv(value));\n}",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ntypename DynamicTypeFor<FromServer<T>>::Client toDynamic(kj::Own<T>&& value) {\n  return typename FromServer<T>::Client(kj::mv(value));\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.asReader",
          "args": [],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "asReader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "607-607",
          "snippet": "inline Reader asReader() const { return Reader(_builder.asReader()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Reader asReader() const { return Reader(_builder.asReader()); }"
        }
      },
      {
        "call_info": {
          "callee": "list.set",
          "args": [
            "2",
            "client3"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "872-874",
          "snippet": "static inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "request.initList",
          "args": [
            "3"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "baseClient.testPointersRequest",
          "args": [],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTEST(Capability, Lists) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount1 = 0;\n  int callCount2 = 0;\n  int callCount3 = 0;\n  test::TestPipeline::Client baseClient(kj::heap<TestPipelineImpl>(callCount1));\n  test::TestInterface::Client client1(kj::heap<TestInterfaceImpl>(callCount1));\n  test::TestInterface::Client client2(kj::heap<TestInterfaceImpl>(callCount2));\n  test::TestInterface::Client client3(kj::heap<TestInterfaceImpl>(callCount3));\n\n  auto request = baseClient.testPointersRequest();\n\n  auto list = request.initList(3);\n  list.set(0, client1);\n  list.set(1, client2);\n  list.set(2, client3);\n\n  verifyClient(list[0], callCount1, waitScope);\n  verifyClient(list[1], callCount2, waitScope);\n  verifyClient(list[2], callCount3, waitScope);\n\n  auto listReader = request.asReader().getList();\n  verifyClient(listReader[0], callCount1, waitScope);\n  verifyClient(listReader[1], callCount2, waitScope);\n  verifyClient(listReader[2], callCount3, waitScope);\n\n  auto dynamicList = toDynamic(list);\n  verifyClient(dynamicList[0].as<DynamicCapability>(), callCount1, waitScope);\n  verifyClient(dynamicList[1].as<DynamicCapability>(), callCount2, waitScope);\n  verifyClient(dynamicList[2].as<DynamicCapability>(), callCount3, waitScope);\n\n  auto dynamicListReader = toDynamic(listReader);\n  verifyClient(dynamicListReader[0].as<DynamicCapability>(), callCount1, waitScope);\n  verifyClient(dynamicListReader[1].as<DynamicCapability>(), callCount2, waitScope);\n  verifyClient(dynamicListReader[2].as<DynamicCapability>(), callCount3, waitScope);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "644-706",
    "snippet": "TEST(Capability, AnyPointersAndOrphans) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount1 = 0;\n  int callCount2 = 0;\n\n  // We use a TestPipeline instance here merely as a way to conveniently obtain an imbued message\n  // instance.\n  test::TestPipeline::Client baseClient(nullptr);\n  test::TestInterface::Client client1(kj::heap<TestInterfaceImpl>(callCount1));\n  test::TestInterface::Client client2(kj::heap<TestInterfaceImpl>(callCount2));\n\n  auto request = baseClient.testPointersRequest();\n  request.setCap(client1);\n\n  EXPECT_TRUE(request.hasCap());\n\n  Orphan<test::TestInterface> orphan = request.disownCap();\n  EXPECT_FALSE(orphan == nullptr);\n\n  EXPECT_FALSE(request.hasCap());\n\n  verifyClient(orphan.get(), callCount1, waitScope);\n  verifyClient(orphan.getReader(), callCount1, waitScope);\n\n  request.getObj().adopt(kj::mv(orphan));\n  EXPECT_TRUE(orphan == nullptr);\n\n  verifyClient(request.getObj().getAs<test::TestInterface>(), callCount1, waitScope);\n  verifyClient(request.asReader().getObj().getAs<test::TestInterface>(), callCount1, waitScope);\n  verifyClient(request.getObj().getAs<DynamicCapability>(\n      Schema::from<test::TestInterface>()), callCount1, waitScope);\n  verifyClient(request.asReader().getObj().getAs<DynamicCapability>(\n      Schema::from<test::TestInterface>()), callCount1, waitScope);\n\n  request.getObj().clear();\n  EXPECT_FALSE(request.hasObj());\n\n  request.getObj().setAs<test::TestInterface>(client2);\n  verifyClient(request.getObj().getAs<test::TestInterface>(), callCount2, waitScope);\n\n  Orphan<DynamicCapability> dynamicOrphan = request.getObj().disownAs<DynamicCapability>(\n      Schema::from<test::TestInterface>());\n  verifyClient(dynamicOrphan.get(), callCount2, waitScope);\n  verifyClient(dynamicOrphan.getReader(), callCount2, waitScope);\n\n  Orphan<DynamicValue> dynamicValueOrphan = kj::mv(dynamicOrphan);\n  verifyClient(dynamicValueOrphan.get().as<DynamicCapability>(), callCount2, waitScope);\n\n  orphan = dynamicValueOrphan.releaseAs<test::TestInterface>();\n  EXPECT_FALSE(orphan == nullptr);\n  verifyClient(orphan.get(), callCount2, waitScope);\n\n  request.adoptCap(kj::mv(orphan));\n  EXPECT_TRUE(orphan == nullptr);\n\n  verifyClient(request.getCap(), callCount2, waitScope);\n\n  Orphan<DynamicCapability> dynamicOrphan2 = request.disownCap();\n  verifyClient(dynamicOrphan2.get(), callCount2, waitScope);\n  verifyClient(dynamicOrphan2.getReader(), callCount2, waitScope);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verifyClient",
          "args": [
            "dynamicOrphan2.getReader()",
            "callCount2",
            "waitScope"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "verifyClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
          "lines": "633-642",
          "snippet": "void verifyClient(DynamicCapability::Client client, const int& callCount,\n                  kj::WaitScope& waitScope) {\n  int origCount = callCount;\n  auto request = client.newRequest(\"foo\");\n  request.set(\"i\", 123);\n  request.set(\"j\", true);\n  auto response = request.send().wait(waitScope);\n  EXPECT_EQ(\"foo\", response.get(\"x\").as<Text>());\n  EXPECT_EQ(origCount + 1, callCount);\n}",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\"",
            "#include \"capability.h\"",
            "#include <capnp/test.capnp.h>",
            "#include \"schema.capnp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nvoid verifyClient(DynamicCapability::Client client, const int& callCount,\n                  kj::WaitScope& waitScope) {\n  int origCount = callCount;\n  auto request = client.newRequest(\"foo\");\n  request.set(\"i\", 123);\n  request.set(\"j\", true);\n  auto response = request.send().wait(waitScope);\n  EXPECT_EQ(\"foo\", response.get(\"x\").as<Text>());\n  EXPECT_EQ(origCount + 1, callCount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dynamicOrphan2.getReader",
          "args": [],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dynamicOrphan2.get",
          "args": [],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.disownCap",
          "args": [],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getCap",
          "args": [],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "orphan == nullptr"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.adoptCap",
          "args": [
            "kj::mv(orphan)"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "orphan"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "orphan == nullptr"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dynamicValueOrphan.releaseAs<test::TestInterface>",
          "args": [],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "releaseAs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "770-770",
          "snippet": "inline PipelineFor<T> releaseAs() { return AsImpl<T>::apply(*this); }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline PipelineFor<T> releaseAs() { return AsImpl<T>::apply(*this); }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "dynamicOrphan"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dynamicOrphan.getReader",
          "args": [],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getObj",
          "args": [
            "Schema::from<test::TestInterface>()"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Schema::from<test::TestInterface>",
          "args": [],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "fromImpl",
          "container": "InterfaceSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "466-468",
          "snippet": "static inline InterfaceSchema fromImpl() {\n    return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n  }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nInterfaceSchema {\n  static inline InterfaceSchema fromImpl() {\n      return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.getObj",
          "args": [],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getObj",
          "args": [],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getObj",
          "args": [],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getObj",
          "args": [
            "client2"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getObj",
          "args": [],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "request.hasObj()"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.hasObj",
          "args": [],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getObj",
          "args": [],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getObj",
          "args": [],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.asReader",
          "args": [
            "Schema::from<test::TestInterface>()"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.asReader",
          "args": [],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "asReader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "607-607",
          "snippet": "inline Reader asReader() const { return Reader(_builder.asReader()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Reader asReader() const { return Reader(_builder.asReader()); }"
        }
      },
      {
        "call_info": {
          "callee": "request.getObj",
          "args": [
            "Schema::from<test::TestInterface>()"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getObj",
          "args": [],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getObj",
          "args": [],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getObj",
          "args": [],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "orphan == nullptr"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getObj",
          "args": [
            "kj::mv(orphan)"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "orphan"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getObj",
          "args": [],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphan.getReader",
          "args": [],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "request.hasCap()"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.hasCap",
          "args": [],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "orphan == nullptr"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.disownCap",
          "args": [],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "request.hasCap()"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.hasCap",
          "args": [],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setCap",
          "args": [
            "client1"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "baseClient.testPointersRequest",
          "args": [],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTEST(Capability, AnyPointersAndOrphans) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount1 = 0;\n  int callCount2 = 0;\n\n  // We use a TestPipeline instance here merely as a way to conveniently obtain an imbued message\n  // instance.\n  test::TestPipeline::Client baseClient(nullptr);\n  test::TestInterface::Client client1(kj::heap<TestInterfaceImpl>(callCount1));\n  test::TestInterface::Client client2(kj::heap<TestInterfaceImpl>(callCount2));\n\n  auto request = baseClient.testPointersRequest();\n  request.setCap(client1);\n\n  EXPECT_TRUE(request.hasCap());\n\n  Orphan<test::TestInterface> orphan = request.disownCap();\n  EXPECT_FALSE(orphan == nullptr);\n\n  EXPECT_FALSE(request.hasCap());\n\n  verifyClient(orphan.get(), callCount1, waitScope);\n  verifyClient(orphan.getReader(), callCount1, waitScope);\n\n  request.getObj().adopt(kj::mv(orphan));\n  EXPECT_TRUE(orphan == nullptr);\n\n  verifyClient(request.getObj().getAs<test::TestInterface>(), callCount1, waitScope);\n  verifyClient(request.asReader().getObj().getAs<test::TestInterface>(), callCount1, waitScope);\n  verifyClient(request.getObj().getAs<DynamicCapability>(\n      Schema::from<test::TestInterface>()), callCount1, waitScope);\n  verifyClient(request.asReader().getObj().getAs<DynamicCapability>(\n      Schema::from<test::TestInterface>()), callCount1, waitScope);\n\n  request.getObj().clear();\n  EXPECT_FALSE(request.hasObj());\n\n  request.getObj().setAs<test::TestInterface>(client2);\n  verifyClient(request.getObj().getAs<test::TestInterface>(), callCount2, waitScope);\n\n  Orphan<DynamicCapability> dynamicOrphan = request.getObj().disownAs<DynamicCapability>(\n      Schema::from<test::TestInterface>());\n  verifyClient(dynamicOrphan.get(), callCount2, waitScope);\n  verifyClient(dynamicOrphan.getReader(), callCount2, waitScope);\n\n  Orphan<DynamicValue> dynamicValueOrphan = kj::mv(dynamicOrphan);\n  verifyClient(dynamicValueOrphan.get().as<DynamicCapability>(), callCount2, waitScope);\n\n  orphan = dynamicValueOrphan.releaseAs<test::TestInterface>();\n  EXPECT_FALSE(orphan == nullptr);\n  verifyClient(orphan.get(), callCount2, waitScope);\n\n  request.adoptCap(kj::mv(orphan));\n  EXPECT_TRUE(orphan == nullptr);\n\n  verifyClient(request.getCap(), callCount2, waitScope);\n\n  Orphan<DynamicCapability> dynamicOrphan2 = request.disownCap();\n  verifyClient(dynamicOrphan2.get(), callCount2, waitScope);\n  verifyClient(dynamicOrphan2.getReader(), callCount2, waitScope);\n}"
  },
  {
    "function_name": "verifyClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "633-642",
    "snippet": "void verifyClient(DynamicCapability::Client client, const int& callCount,\n                  kj::WaitScope& waitScope) {\n  int origCount = callCount;\n  auto request = client.newRequest(\"foo\");\n  request.set(\"i\", 123);\n  request.set(\"j\", true);\n  auto response = request.send().wait(waitScope);\n  EXPECT_EQ(\"foo\", response.get(\"x\").as<Text>());\n  EXPECT_EQ(origCount + 1, callCount);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "origCount + 1",
            "callCount"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "response.get(\"x\").as<Text>()"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.get",
          "args": [],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "response.get",
          "args": [
            "\"x\""
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [
            "waitScope"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1329-1364",
          "snippet": "RemotePromise<AnyPointer> send() override {\n      if (!connectionState->connection.is<Connected>()) {\n        // Connection is broken.\n        const kj::Exception& e = connectionState->connection.get<Disconnected>();\n        return RemotePromise<AnyPointer>(\n            kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n            AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n      }\n\n      KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n        // Whoops, this capability has been redirected while we were building the request!\n        // We'll have to make a new request and do a copy.  Ick.\n\n        auto replacement = redirect->get()->newCall(\n            callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n        replacement.set(paramsBuilder);\n        return replacement.send();\n      } else {\n        auto sendResult = sendInternal(false);\n\n        auto forkedPromise = sendResult.promise.fork();\n\n        // The pipeline must get notified of resolution before the app does to maintain ordering.\n        auto pipeline = kj::refcounted<RpcPipeline>(\n            *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n\n        auto appPromise = forkedPromise.addBranch().then(\n            [=](kj::Own<RpcResponse>&& response) {\n              auto reader = response->getResults();\n              return Response<AnyPointer>(reader, kj::mv(response));\n            });\n\n        return RemotePromise<AnyPointer>(\n            kj::mv(appPromise),\n            AnyPointer::Pipeline(kj::mv(pipeline)));\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
            "kj::Maybe<kj::Own<RpcServerResponse>> response;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nkj::Maybe<kj::Own<RpcServerResponse>> response;\n\nRpcRequest {\n  RemotePromise<AnyPointer> send() override {\n        if (!connectionState->connection.is<Connected>()) {\n          // Connection is broken.\n          const kj::Exception& e = connectionState->connection.get<Disconnected>();\n          return RemotePromise<AnyPointer>(\n              kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n              AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n        }\n  \n        KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n          // Whoops, this capability has been redirected while we were building the request!\n          // We'll have to make a new request and do a copy.  Ick.\n  \n          auto replacement = redirect->get()->newCall(\n              callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n          replacement.set(paramsBuilder);\n          return replacement.send();\n        } else {\n          auto sendResult = sendInternal(false);\n  \n          auto forkedPromise = sendResult.promise.fork();\n  \n          // The pipeline must get notified of resolution before the app does to maintain ordering.\n          auto pipeline = kj::refcounted<RpcPipeline>(\n              *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n  \n          auto appPromise = forkedPromise.addBranch().then(\n              [=](kj::Own<RpcResponse>&& response) {\n                auto reader = response->getResults();\n                return Response<AnyPointer>(reader, kj::mv(response));\n              });\n  \n          return RemotePromise<AnyPointer>(\n              kj::mv(appPromise),\n              AnyPointer::Pipeline(kj::mv(pipeline)));\n        }\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "request.set",
          "args": [
            "\"j\"",
            "true"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "872-874",
          "snippet": "static inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "client.newRequest",
          "args": [
            "\"foo\""
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nvoid verifyClient(DynamicCapability::Client client, const int& callCount,\n                  kj::WaitScope& waitScope) {\n  int origCount = callCount;\n  auto request = client.newRequest(\"foo\");\n  request.set(\"i\", 123);\n  request.set(\"j\", true);\n  auto response = request.send().wait(waitScope);\n  EXPECT_EQ(\"foo\", response.get(\"x\").as<Text>());\n  EXPECT_EQ(origCount + 1, callCount);\n}"
  },
  {
    "function_name": "verifyClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "622-631",
    "snippet": "void verifyClient(test::TestInterface::Client client, const int& callCount,\n                  kj::WaitScope& waitScope) {\n  int origCount = callCount;\n  auto request = client.fooRequest();\n  request.setI(123);\n  request.setJ(true);\n  auto response = request.send().wait(waitScope);\n  EXPECT_EQ(\"foo\", response.getX());\n  EXPECT_EQ(origCount + 1, callCount);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "origCount + 1",
            "callCount"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "response.getX()"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getX",
          "args": [],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [
            "waitScope"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1329-1364",
          "snippet": "RemotePromise<AnyPointer> send() override {\n      if (!connectionState->connection.is<Connected>()) {\n        // Connection is broken.\n        const kj::Exception& e = connectionState->connection.get<Disconnected>();\n        return RemotePromise<AnyPointer>(\n            kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n            AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n      }\n\n      KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n        // Whoops, this capability has been redirected while we were building the request!\n        // We'll have to make a new request and do a copy.  Ick.\n\n        auto replacement = redirect->get()->newCall(\n            callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n        replacement.set(paramsBuilder);\n        return replacement.send();\n      } else {\n        auto sendResult = sendInternal(false);\n\n        auto forkedPromise = sendResult.promise.fork();\n\n        // The pipeline must get notified of resolution before the app does to maintain ordering.\n        auto pipeline = kj::refcounted<RpcPipeline>(\n            *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n\n        auto appPromise = forkedPromise.addBranch().then(\n            [=](kj::Own<RpcResponse>&& response) {\n              auto reader = response->getResults();\n              return Response<AnyPointer>(reader, kj::mv(response));\n            });\n\n        return RemotePromise<AnyPointer>(\n            kj::mv(appPromise),\n            AnyPointer::Pipeline(kj::mv(pipeline)));\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
            "kj::Maybe<kj::Own<RpcServerResponse>> response;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nkj::Maybe<kj::Own<RpcServerResponse>> response;\n\nRpcRequest {\n  RemotePromise<AnyPointer> send() override {\n        if (!connectionState->connection.is<Connected>()) {\n          // Connection is broken.\n          const kj::Exception& e = connectionState->connection.get<Disconnected>();\n          return RemotePromise<AnyPointer>(\n              kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n              AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n        }\n  \n        KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n          // Whoops, this capability has been redirected while we were building the request!\n          // We'll have to make a new request and do a copy.  Ick.\n  \n          auto replacement = redirect->get()->newCall(\n              callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n          replacement.set(paramsBuilder);\n          return replacement.send();\n        } else {\n          auto sendResult = sendInternal(false);\n  \n          auto forkedPromise = sendResult.promise.fork();\n  \n          // The pipeline must get notified of resolution before the app does to maintain ordering.\n          auto pipeline = kj::refcounted<RpcPipeline>(\n              *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n  \n          auto appPromise = forkedPromise.addBranch().then(\n              [=](kj::Own<RpcResponse>&& response) {\n                auto reader = response->getResults();\n                return Response<AnyPointer>(reader, kj::mv(response));\n              });\n  \n          return RemotePromise<AnyPointer>(\n              kj::mv(appPromise),\n              AnyPointer::Pipeline(kj::mv(pipeline)));\n        }\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "request.setJ",
          "args": [
            "true"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setI",
          "args": [
            "123"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.fooRequest",
          "args": [],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nvoid verifyClient(test::TestInterface::Client client, const int& callCount,\n                  kj::WaitScope& waitScope) {\n  int origCount = callCount;\n  auto request = client.fooRequest();\n  request.setI(123);\n  request.setJ(true);\n  auto response = request.send().wait(waitScope);\n  EXPECT_EQ(\"foo\", response.getX());\n  EXPECT_EQ(origCount + 1, callCount);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "584-618",
    "snippet": "TEST(Capability, DynamicServerTailCall) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int calleeCallCount = 0;\n  int callerCallCount = 0;\n\n  test::TestTailCallee::Client callee(kj::heap<TestTailCalleeImpl>(calleeCallCount));\n  test::TestTailCaller::Client caller =\n      DynamicCapability::Client(kj::heap<TestTailCallerDynamicImpl>(callerCallCount))\n          .castAs<test::TestTailCaller>();\n\n  auto request = caller.fooRequest();\n  request.setI(456);\n  request.setCallee(callee);\n\n  auto promise = request.send();\n\n  auto dependentCall0 = promise.getC().getCallSequenceRequest().send();\n\n  auto response = promise.wait(waitScope);\n  EXPECT_EQ(456, response.getI());\n  EXPECT_EQ(456, response.getI());\n\n  auto dependentCall1 = promise.getC().getCallSequenceRequest().send();\n\n  auto dependentCall2 = response.getC().getCallSequenceRequest().send();\n\n  EXPECT_EQ(0, dependentCall0.wait(waitScope).getN());\n  EXPECT_EQ(1, dependentCall1.wait(waitScope).getN());\n  EXPECT_EQ(2, dependentCall2.wait(waitScope).getN());\n\n  EXPECT_EQ(1, calleeCallCount);\n  EXPECT_EQ(1, callerCallCount);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "callerCallCount"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "calleeCallCount"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "dependentCall2.wait(waitScope).getN()"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dependentCall2.wait",
          "args": [],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "wait",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "666-666",
          "snippet": "bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dependentCall2.wait",
          "args": [
            "waitScope"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "dependentCall1.wait(waitScope).getN()"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dependentCall1.wait",
          "args": [
            "waitScope"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "dependentCall0.wait(waitScope).getN()"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dependentCall0.wait",
          "args": [
            "waitScope"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getC",
          "args": [],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getC",
          "args": [],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getC",
          "args": [],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getC",
          "args": [],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getC",
          "args": [],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getC",
          "args": [],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "456",
            "response.getI()"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getI",
          "args": [],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "456",
            "response.getI()"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getI",
          "args": [],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getC",
          "args": [],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getC",
          "args": [],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getC",
          "args": [],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "request.setCallee",
          "args": [
            "callee"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setI",
          "args": [
            "456"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "caller.fooRequest",
          "args": [],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DynamicCapability::Client",
          "args": [],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DynamicCapability::Client",
          "args": [
            "kj::heap<TestTailCallerDynamicImpl>(callerCallCount)"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestTailCallerDynamicImpl>",
          "args": [
            "callerCallCount"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTEST(Capability, DynamicServerTailCall) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int calleeCallCount = 0;\n  int callerCallCount = 0;\n\n  test::TestTailCallee::Client callee(kj::heap<TestTailCalleeImpl>(calleeCallCount));\n  test::TestTailCaller::Client caller =\n      DynamicCapability::Client(kj::heap<TestTailCallerDynamicImpl>(callerCallCount))\n          .castAs<test::TestTailCaller>();\n\n  auto request = caller.fooRequest();\n  request.setI(456);\n  request.setCallee(callee);\n\n  auto promise = request.send();\n\n  auto dependentCall0 = promise.getC().getCallSequenceRequest().send();\n\n  auto response = promise.wait(waitScope);\n  EXPECT_EQ(456, response.getI());\n  EXPECT_EQ(456, response.getI());\n\n  auto dependentCall1 = promise.getC().getCallSequenceRequest().send();\n\n  auto dependentCall2 = response.getC().getCallSequenceRequest().send();\n\n  EXPECT_EQ(0, dependentCall0.wait(waitScope).getN());\n  EXPECT_EQ(1, dependentCall1.wait(waitScope).getN());\n  EXPECT_EQ(2, dependentCall2.wait(waitScope).getN());\n\n  EXPECT_EQ(1, calleeCallCount);\n  EXPECT_EQ(1, callerCallCount);\n}"
  },
  {
    "function_name": "call",
    "container": "TestTailCallerDynamicImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "567-581",
    "snippet": "kj::Promise<void> call(InterfaceSchema::Method method,\n                         CallContext<DynamicStruct, DynamicStruct> context) {\n    auto methodName = method.getProto().getName();\n    if (methodName == \"foo\") {\n      ++callCount;\n\n      auto params = context.getParams();\n      auto tailRequest = params.get(\"callee\").as<DynamicCapability>().newRequest(\"foo\");\n      tailRequest.set(\"i\", params.get(\"i\"));\n      tailRequest.set(\"t\", \"from TestTailCaller\");\n      return context.tailCall(kj::mv(tailRequest));\n    } else {\n      KJ_FAIL_ASSERT(\"Method not implemented\", methodName);\n    }\n  }",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Method not implemented\"",
            "methodName"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.tailCall",
          "args": [
            "kj::mv(tailRequest)"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "tailRequest"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tailRequest.set",
          "args": [
            "\"t\"",
            "\"from TestTailCaller\""
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "872-874",
          "snippet": "static inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "params.get",
          "args": [
            "\"i\""
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "params.get",
          "args": [],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getProto",
          "args": [],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTestTailCallerDynamicImpl {\n  kj::Promise<void> call(InterfaceSchema::Method method,\n                           CallContext<DynamicStruct, DynamicStruct> context) {\n      auto methodName = method.getProto().getName();\n      if (methodName == \"foo\") {\n        ++callCount;\n  \n        auto params = context.getParams();\n        auto tailRequest = params.get(\"callee\").as<DynamicCapability>().newRequest(\"foo\");\n        tailRequest.set(\"i\", params.get(\"i\"));\n        tailRequest.set(\"t\", \"from TestTailCaller\");\n        return context.tailCall(kj::mv(tailRequest));\n      } else {\n        KJ_FAIL_ASSERT(\"Method not implemented\", methodName);\n      }\n    }\n}"
  },
  {
    "function_name": "TestTailCallerDynamicImpl",
    "container": "TestTailCallerDynamicImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "561-563",
    "snippet": "TestTailCallerDynamicImpl(int& callCount)\n      : DynamicCapability::Server(Schema::from<test::TestTailCaller>()),\n        callCount(callCount) {}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Schema::from<test::TestTailCaller>",
          "args": [],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "fromImpl",
          "container": "InterfaceSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "466-468",
          "snippet": "static inline InterfaceSchema fromImpl() {\n    return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n  }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nInterfaceSchema {\n  static inline InterfaceSchema fromImpl() {\n      return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTestTailCallerDynamicImpl {\n  TestTailCallerDynamicImpl(int& callCount)\n        : DynamicCapability::Server(Schema::from<test::TestTailCaller>()),\n          callCount(callCount) {}\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "521-557",
    "snippet": "TEST(Capability, DynamicServerPipelining) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount = 0;\n  int chainedCallCount = 0;\n  test::TestPipeline::Client client =\n      DynamicCapability::Client(kj::heap<TestPipelineDynamicImpl>(callCount))\n          .castAs<test::TestPipeline>();\n\n  auto request = client.getCapRequest();\n  request.setN(234);\n  request.setInCap(test::TestInterface::Client(kj::heap<TestInterfaceImpl>(chainedCallCount)));\n\n  auto promise = request.send();\n\n  auto pipelineRequest = promise.getOutBox().getCap().fooRequest();\n  pipelineRequest.setI(321);\n  auto pipelinePromise = pipelineRequest.send();\n\n  auto pipelineRequest2 = promise.getOutBox().getCap().castAs<test::TestExtends>().graultRequest();\n  auto pipelinePromise2 = pipelineRequest2.send();\n\n  promise = nullptr;  // Just to be annoying, drop the original promise.\n\n  EXPECT_EQ(0, callCount);\n  EXPECT_EQ(0, chainedCallCount);\n\n  auto response = pipelinePromise.wait(waitScope);\n  EXPECT_EQ(\"bar\", response.getX());\n\n  auto response2 = pipelinePromise2.wait(waitScope);\n  checkTestMessage(response2);\n\n  EXPECT_EQ(3, callCount);\n  EXPECT_EQ(1, chainedCallCount);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "chainedCallCount"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "callCount"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkTestMessage",
          "args": [
            "response2"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "checkTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "844-844",
          "snippet": "void checkTestMessage(TestListDefaults::Reader reader) { genericCheckListDefaults(reader); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid checkTestMessage(TestListDefaults::Reader reader) { genericCheckListDefaults(reader); }"
        }
      },
      {
        "call_info": {
          "callee": "pipelinePromise2.wait",
          "args": [
            "waitScope"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "response.getX()"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getX",
          "args": [],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipelinePromise.wait",
          "args": [
            "waitScope"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "chainedCallCount"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "callCount"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipelineRequest2.send",
          "args": [],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipelineRequest.setI",
          "args": [
            "321"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setInCap",
          "args": [
            "test::TestInterface::Client(kj::heap<TestInterfaceImpl>(chainedCallCount))"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test::TestInterface::Client",
          "args": [
            "kj::heap<TestInterfaceImpl>(chainedCallCount)"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestInterfaceImpl>",
          "args": [
            "chainedCallCount"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.setN",
          "args": [
            "234"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCapRequest",
          "args": [],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DynamicCapability::Client",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DynamicCapability::Client",
          "args": [
            "kj::heap<TestPipelineDynamicImpl>(callCount)"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTEST(Capability, DynamicServerPipelining) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount = 0;\n  int chainedCallCount = 0;\n  test::TestPipeline::Client client =\n      DynamicCapability::Client(kj::heap<TestPipelineDynamicImpl>(callCount))\n          .castAs<test::TestPipeline>();\n\n  auto request = client.getCapRequest();\n  request.setN(234);\n  request.setInCap(test::TestInterface::Client(kj::heap<TestInterfaceImpl>(chainedCallCount)));\n\n  auto promise = request.send();\n\n  auto pipelineRequest = promise.getOutBox().getCap().fooRequest();\n  pipelineRequest.setI(321);\n  auto pipelinePromise = pipelineRequest.send();\n\n  auto pipelineRequest2 = promise.getOutBox().getCap().castAs<test::TestExtends>().graultRequest();\n  auto pipelinePromise2 = pipelineRequest2.send();\n\n  promise = nullptr;  // Just to be annoying, drop the original promise.\n\n  EXPECT_EQ(0, callCount);\n  EXPECT_EQ(0, chainedCallCount);\n\n  auto response = pipelinePromise.wait(waitScope);\n  EXPECT_EQ(\"bar\", response.getX());\n\n  auto response2 = pipelinePromise2.wait(waitScope);\n  checkTestMessage(response2);\n\n  EXPECT_EQ(3, callCount);\n  EXPECT_EQ(1, chainedCallCount);\n}"
  },
  {
    "function_name": "call",
    "container": "TestPipelineDynamicImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "485-518",
    "snippet": "kj::Promise<void> call(InterfaceSchema::Method method,\n                         CallContext<DynamicStruct, DynamicStruct> context) {\n    auto methodName = method.getProto().getName();\n    if (methodName == \"getCap\") {\n      ++callCount;\n\n      auto params = context.getParams();\n      EXPECT_EQ(234, params.get(\"n\").as<uint32_t>());\n\n      auto cap = params.get(\"inCap\").as<DynamicCapability>();\n      context.releaseParams();\n\n      auto request = cap.newRequest(\"foo\");\n      request.set(\"i\", 123);\n      request.set(\"j\", true);\n\n      return request.send().then(\n          [this,context](capnp::Response<DynamicStruct>&& response) mutable {\n            EXPECT_EQ(\"foo\", response.get(\"x\").as<Text>());\n\n            auto result = context.getResults();\n            result.set(\"s\", \"bar\");\n\n            auto box = result.init(\"outBox\").as<DynamicStruct>();\n\n            // Too lazy to write a whole separate test for each of these cases...  so just make\n            // sure they both compile here, and only actually test the latter.\n            box.set(\"cap\", kj::heap<TestExtendsDynamicImpl>(callCount));\n            box.set(\"cap\", kj::heap<TestExtendsImpl>(callCount));\n          });\n    } else {\n      KJ_FAIL_ASSERT(\"Method not implemented\", methodName);\n    }\n  }",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Method not implemented\"",
            "methodName"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [
            "[this,context](capnp::Response<DynamicStruct>&& response) mutable {\n            EXPECT_EQ(\"foo\", response.get(\"x\").as<Text>());\n\n            auto result = context.getResults();\n            result.set(\"s\", \"bar\");\n\n            auto box = result.init(\"outBox\").as<DynamicStruct>();\n\n            // Too lazy to write a whole separate test for each of these cases...  so just make\n            // sure they both compile here, and only actually test the latter.\n            box.set(\"cap\", kj::heap<TestExtendsDynamicImpl>(callCount));\n            box.set(\"cap\", kj::heap<TestExtendsImpl>(callCount));\n          }"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1329-1364",
          "snippet": "RemotePromise<AnyPointer> send() override {\n      if (!connectionState->connection.is<Connected>()) {\n        // Connection is broken.\n        const kj::Exception& e = connectionState->connection.get<Disconnected>();\n        return RemotePromise<AnyPointer>(\n            kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n            AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n      }\n\n      KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n        // Whoops, this capability has been redirected while we were building the request!\n        // We'll have to make a new request and do a copy.  Ick.\n\n        auto replacement = redirect->get()->newCall(\n            callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n        replacement.set(paramsBuilder);\n        return replacement.send();\n      } else {\n        auto sendResult = sendInternal(false);\n\n        auto forkedPromise = sendResult.promise.fork();\n\n        // The pipeline must get notified of resolution before the app does to maintain ordering.\n        auto pipeline = kj::refcounted<RpcPipeline>(\n            *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n\n        auto appPromise = forkedPromise.addBranch().then(\n            [=](kj::Own<RpcResponse>&& response) {\n              auto reader = response->getResults();\n              return Response<AnyPointer>(reader, kj::mv(response));\n            });\n\n        return RemotePromise<AnyPointer>(\n            kj::mv(appPromise),\n            AnyPointer::Pipeline(kj::mv(pipeline)));\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
            "kj::Maybe<kj::Own<RpcServerResponse>> response;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nkj::Maybe<kj::Own<RpcServerResponse>> response;\n\nRpcRequest {\n  RemotePromise<AnyPointer> send() override {\n        if (!connectionState->connection.is<Connected>()) {\n          // Connection is broken.\n          const kj::Exception& e = connectionState->connection.get<Disconnected>();\n          return RemotePromise<AnyPointer>(\n              kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n              AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n        }\n  \n        KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n          // Whoops, this capability has been redirected while we were building the request!\n          // We'll have to make a new request and do a copy.  Ick.\n  \n          auto replacement = redirect->get()->newCall(\n              callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n          replacement.set(paramsBuilder);\n          return replacement.send();\n        } else {\n          auto sendResult = sendInternal(false);\n  \n          auto forkedPromise = sendResult.promise.fork();\n  \n          // The pipeline must get notified of resolution before the app does to maintain ordering.\n          auto pipeline = kj::refcounted<RpcPipeline>(\n              *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n  \n          auto appPromise = forkedPromise.addBranch().then(\n              [=](kj::Own<RpcResponse>&& response) {\n                auto reader = response->getResults();\n                return Response<AnyPointer>(reader, kj::mv(response));\n              });\n  \n          return RemotePromise<AnyPointer>(\n              kj::mv(appPromise),\n              AnyPointer::Pipeline(kj::mv(pipeline)));\n        }\n}"
        }
      },
      {
        "call_info": {
          "callee": "box.set",
          "args": [
            "\"cap\"",
            "kj::heap<TestExtendsImpl>(callCount)"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "872-874",
          "snippet": "static inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<TestExtendsImpl>",
          "args": [
            "callCount"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.init",
          "args": [],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "77-81",
          "snippet": "void init(Params&&... params) {\n    if (tag != 0) destroy();\n    ctor(*reinterpret_cast<T*>(space), kj::fwd<Params>(params)...);\n    tag = typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  void init(Params&&... params) {\n      if (tag != 0) destroy();\n      ctor(*reinterpret_cast<T*>(space), kj::fwd<Params>(params)...);\n      tag = typeIndex<T>();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.init",
          "args": [
            "\"outBox\""
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/pointer-helpers.h",
          "lines": "51-53",
          "snippet": "static inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"layout.h\"\n\nstatic inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1644-1646",
          "snippet": "AnyPointer::Reader getResults() override {\n      return message.getRoot<AnyPointer>();\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  AnyPointer::Reader getResults() override {\n        return message.getRoot<AnyPointer>();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "response.get(\"x\").as<Text>()"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.get",
          "args": [],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "response.get",
          "args": [
            "\"x\""
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "cap.newRequest",
          "args": [
            "\"foo\""
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "234",
            "params.get(\"n\").as<uint32_t>()"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getProto",
          "args": [],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTestPipelineDynamicImpl {\n  kj::Promise<void> call(InterfaceSchema::Method method,\n                           CallContext<DynamicStruct, DynamicStruct> context) {\n      auto methodName = method.getProto().getName();\n      if (methodName == \"getCap\") {\n        ++callCount;\n  \n        auto params = context.getParams();\n        EXPECT_EQ(234, params.get(\"n\").as<uint32_t>());\n  \n        auto cap = params.get(\"inCap\").as<DynamicCapability>();\n        context.releaseParams();\n  \n        auto request = cap.newRequest(\"foo\");\n        request.set(\"i\", 123);\n        request.set(\"j\", true);\n  \n        return request.send().then(\n            [this,context](capnp::Response<DynamicStruct>&& response) mutable {\n              EXPECT_EQ(\"foo\", response.get(\"x\").as<Text>());\n  \n              auto result = context.getResults();\n              result.set(\"s\", \"bar\");\n  \n              auto box = result.init(\"outBox\").as<DynamicStruct>();\n  \n              // Too lazy to write a whole separate test for each of these cases...  so just make\n              // sure they both compile here, and only actually test the latter.\n              box.set(\"cap\", kj::heap<TestExtendsDynamicImpl>(callCount));\n              box.set(\"cap\", kj::heap<TestExtendsImpl>(callCount));\n            });\n      } else {\n        KJ_FAIL_ASSERT(\"Method not implemented\", methodName);\n      }\n    }\n}"
  },
  {
    "function_name": "TestPipelineDynamicImpl",
    "container": "TestPipelineDynamicImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "479-481",
    "snippet": "TestPipelineDynamicImpl(int& callCount)\n      : DynamicCapability::Server(Schema::from<test::TestPipeline>()),\n        callCount(callCount) {}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Schema::from<test::TestPipeline>",
          "args": [],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "fromImpl",
          "container": "InterfaceSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "466-468",
          "snippet": "static inline InterfaceSchema fromImpl() {\n    return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n  }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nInterfaceSchema {\n  static inline InterfaceSchema fromImpl() {\n      return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTestPipelineDynamicImpl {\n  TestPipelineDynamicImpl(int& callCount)\n        : DynamicCapability::Server(Schema::from<test::TestPipeline>()),\n          callCount(callCount) {}\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "446-475",
    "snippet": "TEST(Capability, DynamicServerInheritance) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount = 0;\n  test::TestExtends::Client client1 =\n      DynamicCapability::Client(kj::heap<TestExtendsDynamicImpl>(callCount))\n          .castAs<test::TestExtends>();\n  test::TestInterface::Client client2 = client1;\n  auto client = client2.castAs<test::TestExtends>();\n\n  auto request1 = client.fooRequest();\n  request1.setI(321);\n  auto promise1 = request1.send();\n\n  auto request2 = client.graultRequest();\n  auto promise2 = request2.send();\n\n  EXPECT_EQ(0, callCount);\n\n  auto response2 = promise2.wait(waitScope);\n\n  checkTestMessage(response2);\n\n  auto response1 = promise1.wait(waitScope);\n\n  EXPECT_EQ(\"bar\", response1.getX());\n\n  EXPECT_EQ(2, callCount);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "callCount"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "response1.getX()"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response1.getX",
          "args": [],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise1.wait",
          "args": [
            "waitScope"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkTestMessage",
          "args": [
            "response2"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "checkTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "844-844",
          "snippet": "void checkTestMessage(TestListDefaults::Reader reader) { genericCheckListDefaults(reader); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid checkTestMessage(TestListDefaults::Reader reader) { genericCheckListDefaults(reader); }"
        }
      },
      {
        "call_info": {
          "callee": "promise2.wait",
          "args": [
            "waitScope"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "callCount"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request2.send",
          "args": [],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "client.graultRequest",
          "args": [],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request1.setI",
          "args": [
            "321"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.fooRequest",
          "args": [],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client2.castAs<test::TestExtends>",
          "args": [],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DynamicCapability::Client",
          "args": [],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DynamicCapability::Client",
          "args": [
            "kj::heap<TestExtendsDynamicImpl>(callCount)"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestExtendsDynamicImpl>",
          "args": [
            "callCount"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTEST(Capability, DynamicServerInheritance) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount = 0;\n  test::TestExtends::Client client1 =\n      DynamicCapability::Client(kj::heap<TestExtendsDynamicImpl>(callCount))\n          .castAs<test::TestExtends>();\n  test::TestInterface::Client client2 = client1;\n  auto client = client2.castAs<test::TestExtends>();\n\n  auto request1 = client.fooRequest();\n  request1.setI(321);\n  auto promise1 = request1.send();\n\n  auto request2 = client.graultRequest();\n  auto promise2 = request2.send();\n\n  EXPECT_EQ(0, callCount);\n\n  auto response2 = promise2.wait(waitScope);\n\n  checkTestMessage(response2);\n\n  auto response1 = promise1.wait(waitScope);\n\n  EXPECT_EQ(\"bar\", response1.getX());\n\n  EXPECT_EQ(2, callCount);\n}"
  },
  {
    "function_name": "call",
    "container": "TestExtendsDynamicImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "425-443",
    "snippet": "kj::Promise<void> call(InterfaceSchema::Method method,\n                         CallContext<DynamicStruct, DynamicStruct> context) {\n    auto methodName = method.getProto().getName();\n    if (methodName == \"foo\") {\n      ++callCount;\n      auto params = context.getParams();\n      EXPECT_EQ(321, params.get(\"i\").as<int>());\n      EXPECT_FALSE(params.get(\"j\").as<bool>());\n      context.getResults().set(\"x\", \"bar\");\n      return kj::READY_NOW;\n    } else if (methodName == \"grault\") {\n      ++callCount;\n      context.releaseParams();\n      initDynamicTestMessage(context.getResults());\n      return kj::READY_NOW;\n    } else {\n      KJ_FAIL_ASSERT(\"Method not implemented\", methodName);\n    }\n  }",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Method not implemented\"",
            "methodName"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initDynamicTestMessage",
          "args": [
            "context.getResults()"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "initDynamicTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "855-857",
          "snippet": "void initDynamicTestMessage(DynamicStruct::Builder builder) {\n  dynamicInitTestMessage(builder);\n}",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid initDynamicTestMessage(DynamicStruct::Builder builder) {\n  dynamicInitTestMessage(builder);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1644-1646",
          "snippet": "AnyPointer::Reader getResults() override {\n      return message.getRoot<AnyPointer>();\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  AnyPointer::Reader getResults() override {\n        return message.getRoot<AnyPointer>();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "\"x\"",
            "\"bar\""
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "params.get(\"j\").as<bool>()"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.get",
          "args": [],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.get",
          "args": [
            "\"j\""
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "321",
            "params.get(\"i\").as<int>()"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getProto",
          "args": [],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTestExtendsDynamicImpl {\n  kj::Promise<void> call(InterfaceSchema::Method method,\n                           CallContext<DynamicStruct, DynamicStruct> context) {\n      auto methodName = method.getProto().getName();\n      if (methodName == \"foo\") {\n        ++callCount;\n        auto params = context.getParams();\n        EXPECT_EQ(321, params.get(\"i\").as<int>());\n        EXPECT_FALSE(params.get(\"j\").as<bool>());\n        context.getResults().set(\"x\", \"bar\");\n        return kj::READY_NOW;\n      } else if (methodName == \"grault\") {\n        ++callCount;\n        context.releaseParams();\n        initDynamicTestMessage(context.getResults());\n        return kj::READY_NOW;\n      } else {\n        KJ_FAIL_ASSERT(\"Method not implemented\", methodName);\n      }\n    }\n}"
  },
  {
    "function_name": "TestExtendsDynamicImpl",
    "container": "TestExtendsDynamicImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "419-421",
    "snippet": "TestExtendsDynamicImpl(int& callCount)\n      : DynamicCapability::Server(Schema::from<test::TestExtends>()),\n        callCount(callCount) {}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Schema::from<test::TestExtends>",
          "args": [],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "fromImpl",
          "container": "InterfaceSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "466-468",
          "snippet": "static inline InterfaceSchema fromImpl() {\n    return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n  }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nInterfaceSchema {\n  static inline InterfaceSchema fromImpl() {\n      return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTestExtendsDynamicImpl {\n  TestExtendsDynamicImpl(int& callCount)\n        : DynamicCapability::Server(Schema::from<test::TestExtends>()),\n          callCount(callCount) {}\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "375-415",
    "snippet": "TEST(Capability, DynamicServer) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount = 0;\n  test::TestInterface::Client client =\n      DynamicCapability::Client(kj::heap<TestInterfaceDynamicImpl>(callCount))\n          .castAs<test::TestInterface>();\n\n  auto request1 = client.fooRequest();\n  request1.setI(123);\n  request1.setJ(true);\n  auto promise1 = request1.send();\n\n  auto request2 = client.bazRequest();\n  initTestMessage(request2.initS());\n  auto promise2 = request2.send();\n\n  bool barFailed = false;\n  auto request3 = client.barRequest();\n  auto promise3 = request3.send().then(\n      [](Response<test::TestInterface::BarResults>&& response) {\n        ADD_FAILURE() << \"Expected bar() call to fail.\";\n      }, [&](kj::Exception&& e) {\n        EXPECT_EQ(kj::Exception::Type::UNIMPLEMENTED, e.getType());\n        barFailed = true;\n      });\n\n  EXPECT_EQ(0, callCount);\n\n  auto response1 = promise1.wait(waitScope);\n\n  EXPECT_EQ(\"foo\", response1.getX());\n\n  auto response2 = promise2.wait(waitScope);\n\n  promise3.wait(waitScope);\n\n  EXPECT_EQ(2, callCount);\n  EXPECT_TRUE(barFailed);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "barFailed"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "callCount"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise3.wait",
          "args": [
            "waitScope"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise2.wait",
          "args": [
            "waitScope"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "response1.getX()"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response1.getX",
          "args": [],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise1.wait",
          "args": [
            "waitScope"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "callCount"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request3.send",
          "args": [
            "[](Response<test::TestInterface::BarResults>&& response) {\n        ADD_FAILURE() << \"Expected bar() call to fail.\";\n      }",
            "[&](kj::Exception&& e) {\n        EXPECT_EQ(kj::Exception::Type::UNIMPLEMENTED, e.getType());\n        barFailed = true;\n      }"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "LocalRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "207-241",
          "snippet": "RemotePromise<AnyPointer> send() override {\n    KJ_REQUIRE(message.get() != nullptr, \"Already called send() on this request.\");\n\n    // For the lambda capture.\n    uint64_t interfaceId = this->interfaceId;\n    uint16_t methodId = this->methodId;\n\n    auto cancelPaf = kj::newPromiseAndFulfiller<void>();\n\n    auto context = kj::refcounted<LocalCallContext>(\n        kj::mv(message), client->addRef(), kj::mv(cancelPaf.fulfiller));\n    auto promiseAndPipeline = client->call(interfaceId, methodId, kj::addRef(*context));\n\n    // We have to make sure the call is not canceled unless permitted.  We need to fork the promise\n    // so that if the client drops their copy, the promise isn't necessarily canceled.\n    auto forked = promiseAndPipeline.promise.fork();\n\n    // We daemonize one branch, but only after joining it with the promise that fires if\n    // cancellation is allowed.\n    forked.addBranch()\n        .attach(kj::addRef(*context))\n        .exclusiveJoin(kj::mv(cancelPaf.promise))\n        .detach([](kj::Exception&&) {});  // ignore exceptions\n\n    // Now the other branch returns the response from the context.\n    auto promise = forked.addBranch().then(kj::mvCapture(context,\n        [](kj::Own<LocalCallContext>&& context) {\n      context->getResults(MessageSize { 0, 0 });  // force response allocation\n      return kj::mv(KJ_ASSERT_NONNULL(context->response));\n    }));\n\n    // We return the other branch.\n    return RemotePromise<AnyPointer>(\n        kj::mv(promise), AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline)));\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<MallocMessageBuilder>> request;",
            "kj::Maybe<Response<AnyPointer>> response;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<kj::Own<MallocMessageBuilder>> request;\nkj::Maybe<Response<AnyPointer>> response;\n\nLocalRequest {\n  RemotePromise<AnyPointer> send() override {\n      KJ_REQUIRE(message.get() != nullptr, \"Already called send() on this request.\");\n  \n      // For the lambda capture.\n      uint64_t interfaceId = this->interfaceId;\n      uint16_t methodId = this->methodId;\n  \n      auto cancelPaf = kj::newPromiseAndFulfiller<void>();\n  \n      auto context = kj::refcounted<LocalCallContext>(\n          kj::mv(message), client->addRef(), kj::mv(cancelPaf.fulfiller));\n      auto promiseAndPipeline = client->call(interfaceId, methodId, kj::addRef(*context));\n  \n      // We have to make sure the call is not canceled unless permitted.  We need to fork the promise\n      // so that if the client drops their copy, the promise isn't necessarily canceled.\n      auto forked = promiseAndPipeline.promise.fork();\n  \n      // We daemonize one branch, but only after joining it with the promise that fires if\n      // cancellation is allowed.\n      forked.addBranch()\n          .attach(kj::addRef(*context))\n          .exclusiveJoin(kj::mv(cancelPaf.promise))\n          .detach([](kj::Exception&&) {});  // ignore exceptions\n  \n      // Now the other branch returns the response from the context.\n      auto promise = forked.addBranch().then(kj::mvCapture(context,\n          [](kj::Own<LocalCallContext>&& context) {\n        context->getResults(MessageSize { 0, 0 });  // force response allocation\n        return kj::mv(KJ_ASSERT_NONNULL(context->response));\n      }));\n  \n      // We return the other branch.\n      return RemotePromise<AnyPointer>(\n          kj::mv(promise), AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "kj::Exception::Type::UNIMPLEMENTED",
            "e.getType()"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getType",
          "args": [],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "80-80",
          "snippet": "Type getType() const { return type; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  Type getType() const { return type; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADD_FAILURE",
          "args": [],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request3.send",
          "args": [],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "client.barRequest",
          "args": [],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initTestMessage",
          "args": [
            "request2.initS()"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "initTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "836-836",
          "snippet": "void initTestMessage(TestListDefaults::Builder builder) { genericInitListDefaults(builder); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid initTestMessage(TestListDefaults::Builder builder) { genericInitListDefaults(builder); }"
        }
      },
      {
        "call_info": {
          "callee": "request2.initS",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.bazRequest",
          "args": [],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request1.setJ",
          "args": [
            "true"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request1.setI",
          "args": [
            "123"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.fooRequest",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DynamicCapability::Client",
          "args": [],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DynamicCapability::Client",
          "args": [
            "kj::heap<TestInterfaceDynamicImpl>(callCount)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestInterfaceDynamicImpl>",
          "args": [
            "callCount"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTEST(Capability, DynamicServer) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount = 0;\n  test::TestInterface::Client client =\n      DynamicCapability::Client(kj::heap<TestInterfaceDynamicImpl>(callCount))\n          .castAs<test::TestInterface>();\n\n  auto request1 = client.fooRequest();\n  request1.setI(123);\n  request1.setJ(true);\n  auto promise1 = request1.send();\n\n  auto request2 = client.bazRequest();\n  initTestMessage(request2.initS());\n  auto promise2 = request2.send();\n\n  bool barFailed = false;\n  auto request3 = client.barRequest();\n  auto promise3 = request3.send().then(\n      [](Response<test::TestInterface::BarResults>&& response) {\n        ADD_FAILURE() << \"Expected bar() call to fail.\";\n      }, [&](kj::Exception&& e) {\n        EXPECT_EQ(kj::Exception::Type::UNIMPLEMENTED, e.getType());\n        barFailed = true;\n      });\n\n  EXPECT_EQ(0, callCount);\n\n  auto response1 = promise1.wait(waitScope);\n\n  EXPECT_EQ(\"foo\", response1.getX());\n\n  auto response2 = promise2.wait(waitScope);\n\n  promise3.wait(waitScope);\n\n  EXPECT_EQ(2, callCount);\n  EXPECT_TRUE(barFailed);\n}"
  },
  {
    "function_name": "call",
    "container": "TestInterfaceDynamicImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "351-372",
    "snippet": "kj::Promise<void> call(InterfaceSchema::Method method,\n                         CallContext<DynamicStruct, DynamicStruct> context) {\n    auto methodName = method.getProto().getName();\n    if (methodName == \"foo\") {\n      ++callCount;\n      auto params = context.getParams();\n      EXPECT_EQ(123, params.get(\"i\").as<int>());\n      EXPECT_TRUE(params.get(\"j\").as<bool>());\n      context.getResults().set(\"x\", \"foo\");\n      return kj::READY_NOW;\n    } else if (methodName == \"baz\") {\n      ++callCount;\n      auto params = context.getParams();\n      checkDynamicTestMessage(params.get(\"s\").as<DynamicStruct>());\n      context.releaseParams();\n      EXPECT_ANY_THROW(context.getParams());\n      return kj::READY_NOW;\n    } else {\n      KJ_UNIMPLEMENTED(\"Method not implemented\", methodName) { break; }\n      return kj::READY_NOW;\n    }\n  }",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_UNIMPLEMENTED",
          "args": [
            "\"Method not implemented\"",
            "methodName"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_ANY_THROW",
          "args": [
            "context.getParams()"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkDynamicTestMessage",
          "args": [
            "params.get(\"s\").as<DynamicStruct>()"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "checkDynamicTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "867-869",
          "snippet": "void checkDynamicTestMessage(DynamicStruct::Reader reader) {\n  dynamicCheckTestMessage(reader);\n}",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid checkDynamicTestMessage(DynamicStruct::Reader reader) {\n  dynamicCheckTestMessage(reader);\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.get",
          "args": [],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.get",
          "args": [
            "\"s\""
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "\"x\"",
            "\"foo\""
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1644-1646",
          "snippet": "AnyPointer::Reader getResults() override {\n      return message.getRoot<AnyPointer>();\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  AnyPointer::Reader getResults() override {\n        return message.getRoot<AnyPointer>();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "params.get(\"j\").as<bool>()"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "params.get(\"i\").as<int>()"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getProto",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTestInterfaceDynamicImpl {\n  kj::Promise<void> call(InterfaceSchema::Method method,\n                           CallContext<DynamicStruct, DynamicStruct> context) {\n      auto methodName = method.getProto().getName();\n      if (methodName == \"foo\") {\n        ++callCount;\n        auto params = context.getParams();\n        EXPECT_EQ(123, params.get(\"i\").as<int>());\n        EXPECT_TRUE(params.get(\"j\").as<bool>());\n        context.getResults().set(\"x\", \"foo\");\n        return kj::READY_NOW;\n      } else if (methodName == \"baz\") {\n        ++callCount;\n        auto params = context.getParams();\n        checkDynamicTestMessage(params.get(\"s\").as<DynamicStruct>());\n        context.releaseParams();\n        EXPECT_ANY_THROW(context.getParams());\n        return kj::READY_NOW;\n      } else {\n        KJ_UNIMPLEMENTED(\"Method not implemented\", methodName) { break; }\n        return kj::READY_NOW;\n      }\n    }\n}"
  },
  {
    "function_name": "TestInterfaceDynamicImpl",
    "container": "TestInterfaceDynamicImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "345-347",
    "snippet": "TestInterfaceDynamicImpl(int& callCount)\n      : DynamicCapability::Server(Schema::from<test::TestInterface>()),\n        callCount(callCount) {}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Schema::from<test::TestInterface>",
          "args": [],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "fromImpl",
          "container": "InterfaceSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "466-468",
          "snippet": "static inline InterfaceSchema fromImpl() {\n    return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n  }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nInterfaceSchema {\n  static inline InterfaceSchema fromImpl() {\n      return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTestInterfaceDynamicImpl {\n  TestInterfaceDynamicImpl(int& callCount)\n        : DynamicCapability::Server(Schema::from<test::TestInterface>()),\n          callCount(callCount) {}\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "302-339",
    "snippet": "TEST(Capability, DynamicClientPipelining) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount = 0;\n  int chainedCallCount = 0;\n  DynamicCapability::Client client =\n      test::TestPipeline::Client(kj::heap<TestPipelineImpl>(callCount));\n\n  auto request = client.newRequest(\"getCap\");\n  request.set(\"n\", 234);\n  request.set(\"inCap\", test::TestInterface::Client(kj::heap<TestInterfaceImpl>(chainedCallCount)));\n\n  auto promise = request.send();\n\n  auto outCap = promise.get(\"outBox\").releaseAs<DynamicStruct>()\n                       .get(\"cap\").releaseAs<DynamicCapability>();\n  auto pipelineRequest = outCap.newRequest(\"foo\");\n  pipelineRequest.set(\"i\", 321);\n  auto pipelinePromise = pipelineRequest.send();\n\n  auto pipelineRequest2 = outCap.castAs<test::TestExtends>().graultRequest();\n  auto pipelinePromise2 = pipelineRequest2.send();\n\n  promise = nullptr;  // Just to be annoying, drop the original promise.\n\n  EXPECT_EQ(0, callCount);\n  EXPECT_EQ(0, chainedCallCount);\n\n  auto response = pipelinePromise.wait(waitScope);\n  EXPECT_EQ(\"bar\", response.get(\"x\").as<Text>());\n\n  auto response2 = pipelinePromise2.wait(waitScope);\n  checkTestMessage(response2);\n\n  EXPECT_EQ(3, callCount);\n  EXPECT_EQ(1, chainedCallCount);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "chainedCallCount"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "callCount"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkTestMessage",
          "args": [
            "response2"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "checkTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "844-844",
          "snippet": "void checkTestMessage(TestListDefaults::Reader reader) { genericCheckListDefaults(reader); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid checkTestMessage(TestListDefaults::Reader reader) { genericCheckListDefaults(reader); }"
        }
      },
      {
        "call_info": {
          "callee": "pipelinePromise2.wait",
          "args": [
            "waitScope"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "response.get(\"x\").as<Text>()"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.get",
          "args": [],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "response.get",
          "args": [
            "\"x\""
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "pipelinePromise.wait",
          "args": [
            "waitScope"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "chainedCallCount"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "callCount"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipelineRequest2.send",
          "args": [],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "outCap.castAs<test::TestExtends>",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outCap.castAs<test::TestExtends>",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipelineRequest.set",
          "args": [
            "\"i\"",
            "321"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "872-874",
          "snippet": "static inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "outCap.newRequest",
          "args": [
            "\"foo\""
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test::TestInterface::Client",
          "args": [
            "kj::heap<TestInterfaceImpl>(chainedCallCount)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestInterfaceImpl>",
          "args": [
            "chainedCallCount"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "client.newRequest",
          "args": [
            "\"getCap\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test::TestPipeline::Client",
          "args": [
            "kj::heap<TestPipelineImpl>(callCount)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTEST(Capability, DynamicClientPipelining) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount = 0;\n  int chainedCallCount = 0;\n  DynamicCapability::Client client =\n      test::TestPipeline::Client(kj::heap<TestPipelineImpl>(callCount));\n\n  auto request = client.newRequest(\"getCap\");\n  request.set(\"n\", 234);\n  request.set(\"inCap\", test::TestInterface::Client(kj::heap<TestInterfaceImpl>(chainedCallCount)));\n\n  auto promise = request.send();\n\n  auto outCap = promise.get(\"outBox\").releaseAs<DynamicStruct>()\n                       .get(\"cap\").releaseAs<DynamicCapability>();\n  auto pipelineRequest = outCap.newRequest(\"foo\");\n  pipelineRequest.set(\"i\", 321);\n  auto pipelinePromise = pipelineRequest.send();\n\n  auto pipelineRequest2 = outCap.castAs<test::TestExtends>().graultRequest();\n  auto pipelinePromise2 = pipelineRequest2.send();\n\n  promise = nullptr;  // Just to be annoying, drop the original promise.\n\n  EXPECT_EQ(0, callCount);\n  EXPECT_EQ(0, chainedCallCount);\n\n  auto response = pipelinePromise.wait(waitScope);\n  EXPECT_EQ(\"bar\", response.get(\"x\").as<Text>());\n\n  auto response2 = pipelinePromise2.wait(waitScope);\n  checkTestMessage(response2);\n\n  EXPECT_EQ(3, callCount);\n  EXPECT_EQ(1, chainedCallCount);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "265-300",
    "snippet": "TEST(Capability, DynamicClientInheritance) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount = 0;\n\n  DynamicCapability::Client client1 =\n      test::TestExtends::Client(kj::heap<TestExtendsImpl>(callCount));\n  EXPECT_EQ(Schema::from<test::TestExtends>(), client1.getSchema());\n  EXPECT_NE(Schema::from<test::TestInterface>(), client1.getSchema());\n\n  DynamicCapability::Client client2 = client1.upcast(Schema::from<test::TestInterface>());\n  EXPECT_EQ(Schema::from<test::TestInterface>(), client2.getSchema());\n\n  EXPECT_ANY_THROW(client2.upcast(Schema::from<test::TestExtends>()));\n  auto client = client2.castAs<DynamicCapability>(Schema::from<test::TestExtends>());\n\n  auto request1 = client.newRequest(\"foo\");\n  request1.set(\"i\", 321);\n  auto promise1 = request1.send();\n\n  auto request2 = client.newRequest(\"grault\");\n  auto promise2 = request2.send();\n\n  EXPECT_EQ(0, callCount);\n\n  auto response2 = promise2.wait(waitScope);\n\n  checkDynamicTestMessage(response2.as<DynamicStruct>());\n\n  auto response1 = promise1.wait(waitScope);\n\n  EXPECT_EQ(\"bar\", response1.get(\"x\").as<Text>());\n\n  EXPECT_EQ(2, callCount);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "callCount"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "response1.get(\"x\").as<Text>()"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response1.get",
          "args": [],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "response1.get",
          "args": [
            "\"x\""
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "promise1.wait",
          "args": [
            "waitScope"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkDynamicTestMessage",
          "args": [
            "response2.as<DynamicStruct>()"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "checkDynamicTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "867-869",
          "snippet": "void checkDynamicTestMessage(DynamicStruct::Reader reader) {\n  dynamicCheckTestMessage(reader);\n}",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid checkDynamicTestMessage(DynamicStruct::Reader reader) {\n  dynamicCheckTestMessage(reader);\n}"
        }
      },
      {
        "call_info": {
          "callee": "response2.as<DynamicStruct>",
          "args": [],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "as",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "601-604",
          "snippet": "BuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nBuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "promise2.wait",
          "args": [
            "waitScope"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "callCount"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request2.send",
          "args": [],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "client.newRequest",
          "args": [
            "\"grault\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request1.set",
          "args": [
            "\"i\"",
            "321"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "872-874",
          "snippet": "static inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "client.newRequest",
          "args": [
            "\"foo\""
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client2.castAs<DynamicCapability>",
          "args": [
            "Schema::from<test::TestExtends>()"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Schema::from<test::TestExtends>",
          "args": [],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "fromImpl",
          "container": "InterfaceSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "466-468",
          "snippet": "static inline InterfaceSchema fromImpl() {\n    return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n  }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nInterfaceSchema {\n  static inline InterfaceSchema fromImpl() {\n      return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_ANY_THROW",
          "args": [
            "client2.upcast(Schema::from<test::TestExtends>())"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client2.upcast",
          "args": [
            "Schema::from<test::TestExtends>()"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "Schema::from<test::TestInterface>()",
            "client2.getSchema()"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client2.getSchema",
          "args": [],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "getSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "505-505",
          "snippet": "inline InterfaceSchema getSchema() const { return schema; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline InterfaceSchema getSchema() const { return schema; }"
        }
      },
      {
        "call_info": {
          "callee": "client1.upcast",
          "args": [
            "Schema::from<test::TestInterface>()"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_NE",
          "args": [
            "Schema::from<test::TestInterface>()",
            "client1.getSchema()"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "Schema::from<test::TestExtends>()",
            "client1.getSchema()"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test::TestExtends::Client",
          "args": [
            "kj::heap<TestExtendsImpl>(callCount)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestExtendsImpl>",
          "args": [
            "callCount"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTEST(Capability, DynamicClientInheritance) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount = 0;\n\n  DynamicCapability::Client client1 =\n      test::TestExtends::Client(kj::heap<TestExtendsImpl>(callCount));\n  EXPECT_EQ(Schema::from<test::TestExtends>(), client1.getSchema());\n  EXPECT_NE(Schema::from<test::TestInterface>(), client1.getSchema());\n\n  DynamicCapability::Client client2 = client1.upcast(Schema::from<test::TestInterface>());\n  EXPECT_EQ(Schema::from<test::TestInterface>(), client2.getSchema());\n\n  EXPECT_ANY_THROW(client2.upcast(Schema::from<test::TestExtends>()));\n  auto client = client2.castAs<DynamicCapability>(Schema::from<test::TestExtends>());\n\n  auto request1 = client.newRequest(\"foo\");\n  request1.set(\"i\", 321);\n  auto promise1 = request1.send();\n\n  auto request2 = client.newRequest(\"grault\");\n  auto promise2 = request2.send();\n\n  EXPECT_EQ(0, callCount);\n\n  auto response2 = promise2.wait(waitScope);\n\n  checkDynamicTestMessage(response2.as<DynamicStruct>());\n\n  auto response1 = promise1.wait(waitScope);\n\n  EXPECT_EQ(\"bar\", response1.get(\"x\").as<Text>());\n\n  EXPECT_EQ(2, callCount);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "224-263",
    "snippet": "TEST(Capability, DynamicClient) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount = 0;\n  DynamicCapability::Client client =\n      test::TestInterface::Client(kj::heap<TestInterfaceImpl>(callCount));\n\n  auto request1 = client.newRequest(\"foo\");\n  request1.set(\"i\", 123);\n  request1.set(\"j\", true);\n  auto promise1 = request1.send();\n\n  auto request2 = client.newRequest(\"baz\");\n  initDynamicTestMessage(request2.init(\"s\").as<DynamicStruct>());\n  auto promise2 = request2.send();\n\n  bool barFailed = false;\n  auto request3 = client.newRequest(\"bar\");\n  auto promise3 = request3.send().then(\n      [](Response<DynamicStruct>&& response) {\n        ADD_FAILURE() << \"Expected bar() call to fail.\";\n      }, [&](kj::Exception&& e) {\n        EXPECT_EQ(kj::Exception::Type::UNIMPLEMENTED, e.getType());\n        barFailed = true;\n      });\n\n  EXPECT_EQ(0, callCount);\n\n  auto response1 = promise1.wait(waitScope);\n\n  EXPECT_EQ(\"foo\", response1.get(\"x\").as<Text>());\n\n  auto response2 = promise2.wait(waitScope);\n\n  promise3.wait(waitScope);\n\n  EXPECT_EQ(2, callCount);\n  EXPECT_TRUE(barFailed);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "barFailed"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "callCount"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise3.wait",
          "args": [
            "waitScope"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise2.wait",
          "args": [
            "waitScope"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "response1.get(\"x\").as<Text>()"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response1.get",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "response1.get",
          "args": [
            "\"x\""
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "promise1.wait",
          "args": [
            "waitScope"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "callCount"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request3.send",
          "args": [
            "[](Response<DynamicStruct>&& response) {\n        ADD_FAILURE() << \"Expected bar() call to fail.\";\n      }",
            "[&](kj::Exception&& e) {\n        EXPECT_EQ(kj::Exception::Type::UNIMPLEMENTED, e.getType());\n        barFailed = true;\n      }"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "LocalRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "207-241",
          "snippet": "RemotePromise<AnyPointer> send() override {\n    KJ_REQUIRE(message.get() != nullptr, \"Already called send() on this request.\");\n\n    // For the lambda capture.\n    uint64_t interfaceId = this->interfaceId;\n    uint16_t methodId = this->methodId;\n\n    auto cancelPaf = kj::newPromiseAndFulfiller<void>();\n\n    auto context = kj::refcounted<LocalCallContext>(\n        kj::mv(message), client->addRef(), kj::mv(cancelPaf.fulfiller));\n    auto promiseAndPipeline = client->call(interfaceId, methodId, kj::addRef(*context));\n\n    // We have to make sure the call is not canceled unless permitted.  We need to fork the promise\n    // so that if the client drops their copy, the promise isn't necessarily canceled.\n    auto forked = promiseAndPipeline.promise.fork();\n\n    // We daemonize one branch, but only after joining it with the promise that fires if\n    // cancellation is allowed.\n    forked.addBranch()\n        .attach(kj::addRef(*context))\n        .exclusiveJoin(kj::mv(cancelPaf.promise))\n        .detach([](kj::Exception&&) {});  // ignore exceptions\n\n    // Now the other branch returns the response from the context.\n    auto promise = forked.addBranch().then(kj::mvCapture(context,\n        [](kj::Own<LocalCallContext>&& context) {\n      context->getResults(MessageSize { 0, 0 });  // force response allocation\n      return kj::mv(KJ_ASSERT_NONNULL(context->response));\n    }));\n\n    // We return the other branch.\n    return RemotePromise<AnyPointer>(\n        kj::mv(promise), AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline)));\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<MallocMessageBuilder>> request;",
            "kj::Maybe<Response<AnyPointer>> response;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<kj::Own<MallocMessageBuilder>> request;\nkj::Maybe<Response<AnyPointer>> response;\n\nLocalRequest {\n  RemotePromise<AnyPointer> send() override {\n      KJ_REQUIRE(message.get() != nullptr, \"Already called send() on this request.\");\n  \n      // For the lambda capture.\n      uint64_t interfaceId = this->interfaceId;\n      uint16_t methodId = this->methodId;\n  \n      auto cancelPaf = kj::newPromiseAndFulfiller<void>();\n  \n      auto context = kj::refcounted<LocalCallContext>(\n          kj::mv(message), client->addRef(), kj::mv(cancelPaf.fulfiller));\n      auto promiseAndPipeline = client->call(interfaceId, methodId, kj::addRef(*context));\n  \n      // We have to make sure the call is not canceled unless permitted.  We need to fork the promise\n      // so that if the client drops their copy, the promise isn't necessarily canceled.\n      auto forked = promiseAndPipeline.promise.fork();\n  \n      // We daemonize one branch, but only after joining it with the promise that fires if\n      // cancellation is allowed.\n      forked.addBranch()\n          .attach(kj::addRef(*context))\n          .exclusiveJoin(kj::mv(cancelPaf.promise))\n          .detach([](kj::Exception&&) {});  // ignore exceptions\n  \n      // Now the other branch returns the response from the context.\n      auto promise = forked.addBranch().then(kj::mvCapture(context,\n          [](kj::Own<LocalCallContext>&& context) {\n        context->getResults(MessageSize { 0, 0 });  // force response allocation\n        return kj::mv(KJ_ASSERT_NONNULL(context->response));\n      }));\n  \n      // We return the other branch.\n      return RemotePromise<AnyPointer>(\n          kj::mv(promise), AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "kj::Exception::Type::UNIMPLEMENTED",
            "e.getType()"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getType",
          "args": [],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "80-80",
          "snippet": "Type getType() const { return type; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  Type getType() const { return type; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADD_FAILURE",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request3.send",
          "args": [],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "client.newRequest",
          "args": [
            "\"bar\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initDynamicTestMessage",
          "args": [
            "request2.init(\"s\").as<DynamicStruct>()"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "initDynamicTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "855-857",
          "snippet": "void initDynamicTestMessage(DynamicStruct::Builder builder) {\n  dynamicInitTestMessage(builder);\n}",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid initDynamicTestMessage(DynamicStruct::Builder builder) {\n  dynamicInitTestMessage(builder);\n}"
        }
      },
      {
        "call_info": {
          "callee": "request2.init",
          "args": [],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "77-81",
          "snippet": "void init(Params&&... params) {\n    if (tag != 0) destroy();\n    ctor(*reinterpret_cast<T*>(space), kj::fwd<Params>(params)...);\n    tag = typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  void init(Params&&... params) {\n      if (tag != 0) destroy();\n      ctor(*reinterpret_cast<T*>(space), kj::fwd<Params>(params)...);\n      tag = typeIndex<T>();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "request2.init",
          "args": [
            "\"s\""
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/pointer-helpers.h",
          "lines": "51-53",
          "snippet": "static inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"layout.h\"\n\nstatic inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "client.newRequest",
          "args": [
            "\"baz\""
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request1.set",
          "args": [
            "\"j\"",
            "true"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "872-874",
          "snippet": "static inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "client.newRequest",
          "args": [
            "\"foo\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test::TestInterface::Client",
          "args": [
            "kj::heap<TestInterfaceImpl>(callCount)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestInterfaceImpl>",
          "args": [
            "callCount"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTEST(Capability, DynamicClient) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount = 0;\n  DynamicCapability::Client client =\n      test::TestInterface::Client(kj::heap<TestInterfaceImpl>(callCount));\n\n  auto request1 = client.newRequest(\"foo\");\n  request1.set(\"i\", 123);\n  request1.set(\"j\", true);\n  auto promise1 = request1.send();\n\n  auto request2 = client.newRequest(\"baz\");\n  initDynamicTestMessage(request2.init(\"s\").as<DynamicStruct>());\n  auto promise2 = request2.send();\n\n  bool barFailed = false;\n  auto request3 = client.newRequest(\"bar\");\n  auto promise3 = request3.send().then(\n      [](Response<DynamicStruct>&& response) {\n        ADD_FAILURE() << \"Expected bar() call to fail.\";\n      }, [&](kj::Exception&& e) {\n        EXPECT_EQ(kj::Exception::Type::UNIMPLEMENTED, e.getType());\n        barFailed = true;\n      });\n\n  EXPECT_EQ(0, callCount);\n\n  auto response1 = promise1.wait(waitScope);\n\n  EXPECT_EQ(\"foo\", response1.get(\"x\").as<Text>());\n\n  auto response2 = promise2.wait(waitScope);\n\n  promise3.wait(waitScope);\n\n  EXPECT_EQ(2, callCount);\n  EXPECT_TRUE(barFailed);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "182-220",
    "snippet": "TEST(Capability, AsyncCancelation) {\n  // Tests allowCancellation().\n\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  auto paf = kj::newPromiseAndFulfiller<void>();\n  bool destroyed = false;\n  auto destructionPromise = paf.promise.then([&]() { destroyed = true; }).eagerlyEvaluate(nullptr);\n\n  int callCount = 0;\n  int handleCount = 0;\n\n  test::TestMoreStuff::Client client(kj::heap<TestMoreStuffImpl>(callCount, handleCount));\n\n  kj::Promise<void> promise = nullptr;\n\n  bool returned = false;\n  {\n    auto request = client.expectCancelRequest();\n    request.setCap(test::TestInterface::Client(kj::heap<TestCapDestructor>(kj::mv(paf.fulfiller))));\n    promise = request.send().then(\n        [&](Response<test::TestMoreStuff::ExpectCancelResults>&& response) {\n      returned = true;\n    }).eagerlyEvaluate(nullptr);\n  }\n  kj::evalLater([]() {}).wait(waitScope);\n  kj::evalLater([]() {}).wait(waitScope);\n\n  // We can detect that the method was canceled because it will drop the cap.\n  EXPECT_FALSE(destroyed);\n  EXPECT_FALSE(returned);\n\n  promise = nullptr;  // request cancellation\n  destructionPromise.wait(waitScope);\n\n  EXPECT_TRUE(destroyed);\n  EXPECT_FALSE(returned);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "returned"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "destroyed"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destructionPromise.wait",
          "args": [
            "waitScope"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "returned"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "destroyed"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::evalLater",
          "args": [
            "waitScope"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [
            "nullptr"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1329-1364",
          "snippet": "RemotePromise<AnyPointer> send() override {\n      if (!connectionState->connection.is<Connected>()) {\n        // Connection is broken.\n        const kj::Exception& e = connectionState->connection.get<Disconnected>();\n        return RemotePromise<AnyPointer>(\n            kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n            AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n      }\n\n      KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n        // Whoops, this capability has been redirected while we were building the request!\n        // We'll have to make a new request and do a copy.  Ick.\n\n        auto replacement = redirect->get()->newCall(\n            callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n        replacement.set(paramsBuilder);\n        return replacement.send();\n      } else {\n        auto sendResult = sendInternal(false);\n\n        auto forkedPromise = sendResult.promise.fork();\n\n        // The pipeline must get notified of resolution before the app does to maintain ordering.\n        auto pipeline = kj::refcounted<RpcPipeline>(\n            *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n\n        auto appPromise = forkedPromise.addBranch().then(\n            [=](kj::Own<RpcResponse>&& response) {\n              auto reader = response->getResults();\n              return Response<AnyPointer>(reader, kj::mv(response));\n            });\n\n        return RemotePromise<AnyPointer>(\n            kj::mv(appPromise),\n            AnyPointer::Pipeline(kj::mv(pipeline)));\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
            "kj::Maybe<kj::Own<RpcServerResponse>> response;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nkj::Maybe<kj::Own<RpcServerResponse>> response;\n\nRpcRequest {\n  RemotePromise<AnyPointer> send() override {\n        if (!connectionState->connection.is<Connected>()) {\n          // Connection is broken.\n          const kj::Exception& e = connectionState->connection.get<Disconnected>();\n          return RemotePromise<AnyPointer>(\n              kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n              AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n        }\n  \n        KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n          // Whoops, this capability has been redirected while we were building the request!\n          // We'll have to make a new request and do a copy.  Ick.\n  \n          auto replacement = redirect->get()->newCall(\n              callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n          replacement.set(paramsBuilder);\n          return replacement.send();\n        } else {\n          auto sendResult = sendInternal(false);\n  \n          auto forkedPromise = sendResult.promise.fork();\n  \n          // The pipeline must get notified of resolution before the app does to maintain ordering.\n          auto pipeline = kj::refcounted<RpcPipeline>(\n              *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n  \n          auto appPromise = forkedPromise.addBranch().then(\n              [=](kj::Own<RpcResponse>&& response) {\n                auto reader = response->getResults();\n                return Response<AnyPointer>(reader, kj::mv(response));\n              });\n  \n          return RemotePromise<AnyPointer>(\n              kj::mv(appPromise),\n              AnyPointer::Pipeline(kj::mv(pipeline)));\n        }\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "request.setCap",
          "args": [
            "test::TestInterface::Client(kj::heap<TestCapDestructor>(kj::mv(paf.fulfiller)))"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test::TestInterface::Client",
          "args": [
            "kj::heap<TestCapDestructor>(kj::mv(paf.fulfiller))"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestCapDestructor>",
          "args": [
            "kj::mv(paf.fulfiller)"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.expectCancelRequest",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "nullptr"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "[&]() { destroyed = true; }"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<void>",
          "args": [],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTEST(Capability, AsyncCancelation) {\n  // Tests allowCancellation().\n\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  auto paf = kj::newPromiseAndFulfiller<void>();\n  bool destroyed = false;\n  auto destructionPromise = paf.promise.then([&]() { destroyed = true; }).eagerlyEvaluate(nullptr);\n\n  int callCount = 0;\n  int handleCount = 0;\n\n  test::TestMoreStuff::Client client(kj::heap<TestMoreStuffImpl>(callCount, handleCount));\n\n  kj::Promise<void> promise = nullptr;\n\n  bool returned = false;\n  {\n    auto request = client.expectCancelRequest();\n    request.setCap(test::TestInterface::Client(kj::heap<TestCapDestructor>(kj::mv(paf.fulfiller))));\n    promise = request.send().then(\n        [&](Response<test::TestMoreStuff::ExpectCancelResults>&& response) {\n      returned = true;\n    }).eagerlyEvaluate(nullptr);\n  }\n  kj::evalLater([]() {}).wait(waitScope);\n  kj::evalLater([]() {}).wait(waitScope);\n\n  // We can detect that the method was canceled because it will drop the cap.\n  EXPECT_FALSE(destroyed);\n  EXPECT_FALSE(returned);\n\n  promise = nullptr;  // request cancellation\n  destructionPromise.wait(waitScope);\n\n  EXPECT_TRUE(destroyed);\n  EXPECT_FALSE(returned);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "148-180",
    "snippet": "TEST(Capability, TailCall) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int calleeCallCount = 0;\n  int callerCallCount = 0;\n\n  test::TestTailCallee::Client callee(kj::heap<TestTailCalleeImpl>(calleeCallCount));\n  test::TestTailCaller::Client caller(kj::heap<TestTailCallerImpl>(callerCallCount));\n\n  auto request = caller.fooRequest();\n  request.setI(456);\n  request.setCallee(callee);\n\n  auto promise = request.send();\n\n  auto dependentCall0 = promise.getC().getCallSequenceRequest().send();\n\n  auto response = promise.wait(waitScope);\n  EXPECT_EQ(456, response.getI());\n  EXPECT_EQ(456, response.getI());\n\n  auto dependentCall1 = promise.getC().getCallSequenceRequest().send();\n\n  auto dependentCall2 = response.getC().getCallSequenceRequest().send();\n\n  EXPECT_EQ(0, dependentCall0.wait(waitScope).getN());\n  EXPECT_EQ(1, dependentCall1.wait(waitScope).getN());\n  EXPECT_EQ(2, dependentCall2.wait(waitScope).getN());\n\n  EXPECT_EQ(1, calleeCallCount);\n  EXPECT_EQ(1, callerCallCount);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "callerCallCount"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "calleeCallCount"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "dependentCall2.wait(waitScope).getN()"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dependentCall2.wait",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "wait",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "666-666",
          "snippet": "bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dependentCall2.wait",
          "args": [
            "waitScope"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "dependentCall1.wait(waitScope).getN()"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dependentCall1.wait",
          "args": [
            "waitScope"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "dependentCall0.wait(waitScope).getN()"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dependentCall0.wait",
          "args": [
            "waitScope"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getC",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getC",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getC",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getC",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getC",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getC",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "456",
            "response.getI()"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getI",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "456",
            "response.getI()"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getI",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getC",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getC",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getC",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "request.setCallee",
          "args": [
            "callee"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setI",
          "args": [
            "456"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "caller.fooRequest",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTEST(Capability, TailCall) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int calleeCallCount = 0;\n  int callerCallCount = 0;\n\n  test::TestTailCallee::Client callee(kj::heap<TestTailCalleeImpl>(calleeCallCount));\n  test::TestTailCaller::Client caller(kj::heap<TestTailCallerImpl>(callerCallCount));\n\n  auto request = caller.fooRequest();\n  request.setI(456);\n  request.setCallee(callee);\n\n  auto promise = request.send();\n\n  auto dependentCall0 = promise.getC().getCallSequenceRequest().send();\n\n  auto response = promise.wait(waitScope);\n  EXPECT_EQ(456, response.getI());\n  EXPECT_EQ(456, response.getI());\n\n  auto dependentCall1 = promise.getC().getCallSequenceRequest().send();\n\n  auto dependentCall2 = response.getC().getCallSequenceRequest().send();\n\n  EXPECT_EQ(0, dependentCall0.wait(waitScope).getN());\n  EXPECT_EQ(1, dependentCall1.wait(waitScope).getN());\n  EXPECT_EQ(2, dependentCall2.wait(waitScope).getN());\n\n  EXPECT_EQ(1, calleeCallCount);\n  EXPECT_EQ(1, callerCallCount);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "112-146",
    "snippet": "TEST(Capability, Pipelining) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount = 0;\n  int chainedCallCount = 0;\n  test::TestPipeline::Client client(kj::heap<TestPipelineImpl>(callCount));\n\n  auto request = client.getCapRequest();\n  request.setN(234);\n  request.setInCap(test::TestInterface::Client(kj::heap<TestInterfaceImpl>(chainedCallCount)));\n\n  auto promise = request.send();\n\n  auto pipelineRequest = promise.getOutBox().getCap().fooRequest();\n  pipelineRequest.setI(321);\n  auto pipelinePromise = pipelineRequest.send();\n\n  auto pipelineRequest2 = promise.getOutBox().getCap().castAs<test::TestExtends>().graultRequest();\n  auto pipelinePromise2 = pipelineRequest2.send();\n\n  promise = nullptr;  // Just to be annoying, drop the original promise.\n\n  EXPECT_EQ(0, callCount);\n  EXPECT_EQ(0, chainedCallCount);\n\n  auto response = pipelinePromise.wait(waitScope);\n  EXPECT_EQ(\"bar\", response.getX());\n\n  auto response2 = pipelinePromise2.wait(waitScope);\n  checkTestMessage(response2);\n\n  EXPECT_EQ(3, callCount);\n  EXPECT_EQ(1, chainedCallCount);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "chainedCallCount"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "callCount"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkTestMessage",
          "args": [
            "response2"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "checkTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "844-844",
          "snippet": "void checkTestMessage(TestListDefaults::Reader reader) { genericCheckListDefaults(reader); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid checkTestMessage(TestListDefaults::Reader reader) { genericCheckListDefaults(reader); }"
        }
      },
      {
        "call_info": {
          "callee": "pipelinePromise2.wait",
          "args": [
            "waitScope"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "response.getX()"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getX",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipelinePromise.wait",
          "args": [
            "waitScope"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "chainedCallCount"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "callCount"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipelineRequest2.send",
          "args": [],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipelineRequest.setI",
          "args": [
            "321"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setInCap",
          "args": [
            "test::TestInterface::Client(kj::heap<TestInterfaceImpl>(chainedCallCount))"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test::TestInterface::Client",
          "args": [
            "kj::heap<TestInterfaceImpl>(chainedCallCount)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestInterfaceImpl>",
          "args": [
            "chainedCallCount"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.setN",
          "args": [
            "234"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCapRequest",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTEST(Capability, Pipelining) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount = 0;\n  int chainedCallCount = 0;\n  test::TestPipeline::Client client(kj::heap<TestPipelineImpl>(callCount));\n\n  auto request = client.getCapRequest();\n  request.setN(234);\n  request.setInCap(test::TestInterface::Client(kj::heap<TestInterfaceImpl>(chainedCallCount)));\n\n  auto promise = request.send();\n\n  auto pipelineRequest = promise.getOutBox().getCap().fooRequest();\n  pipelineRequest.setI(321);\n  auto pipelinePromise = pipelineRequest.send();\n\n  auto pipelineRequest2 = promise.getOutBox().getCap().castAs<test::TestExtends>().graultRequest();\n  auto pipelinePromise2 = pipelineRequest2.send();\n\n  promise = nullptr;  // Just to be annoying, drop the original promise.\n\n  EXPECT_EQ(0, callCount);\n  EXPECT_EQ(0, chainedCallCount);\n\n  auto response = pipelinePromise.wait(waitScope);\n  EXPECT_EQ(\"bar\", response.getX());\n\n  auto response2 = pipelinePromise2.wait(waitScope);\n  checkTestMessage(response2);\n\n  EXPECT_EQ(3, callCount);\n  EXPECT_EQ(1, chainedCallCount);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "83-110",
    "snippet": "TEST(Capability, Inheritance) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount = 0;\n  test::TestExtends::Client client1(kj::heap<TestExtendsImpl>(callCount));\n  test::TestInterface::Client client2 = client1;\n  auto client = client2.castAs<test::TestExtends>();\n\n  auto request1 = client.fooRequest();\n  request1.setI(321);\n  auto promise1 = request1.send();\n\n  auto request2 = client.graultRequest();\n  auto promise2 = request2.send();\n\n  EXPECT_EQ(0, callCount);\n\n  auto response2 = promise2.wait(waitScope);\n\n  checkTestMessage(response2);\n\n  auto response1 = promise1.wait(waitScope);\n\n  EXPECT_EQ(\"bar\", response1.getX());\n\n  EXPECT_EQ(2, callCount);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "callCount"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "response1.getX()"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response1.getX",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise1.wait",
          "args": [
            "waitScope"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkTestMessage",
          "args": [
            "response2"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "checkTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "844-844",
          "snippet": "void checkTestMessage(TestListDefaults::Reader reader) { genericCheckListDefaults(reader); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid checkTestMessage(TestListDefaults::Reader reader) { genericCheckListDefaults(reader); }"
        }
      },
      {
        "call_info": {
          "callee": "promise2.wait",
          "args": [
            "waitScope"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "callCount"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request2.send",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "client.graultRequest",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request1.setI",
          "args": [
            "321"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.fooRequest",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client2.castAs<test::TestExtends>",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTEST(Capability, Inheritance) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount = 0;\n  test::TestExtends::Client client1(kj::heap<TestExtendsImpl>(callCount));\n  test::TestInterface::Client client2 = client1;\n  auto client = client2.castAs<test::TestExtends>();\n\n  auto request1 = client.fooRequest();\n  request1.setI(321);\n  auto promise1 = request1.send();\n\n  auto request2 = client.graultRequest();\n  auto promise2 = request2.send();\n\n  EXPECT_EQ(0, callCount);\n\n  auto response2 = promise2.wait(waitScope);\n\n  checkTestMessage(response2);\n\n  auto response1 = promise1.wait(waitScope);\n\n  EXPECT_EQ(\"bar\", response1.getX());\n\n  EXPECT_EQ(2, callCount);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability-test.c++",
    "lines": "43-81",
    "snippet": "TEST(Capability, Basic) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount = 0;\n  test::TestInterface::Client client(kj::heap<TestInterfaceImpl>(callCount));\n\n  auto request1 = client.fooRequest();\n  request1.setI(123);\n  request1.setJ(true);\n  auto promise1 = request1.send();\n\n  auto request2 = client.bazRequest();\n  initTestMessage(request2.initS());\n  auto promise2 = request2.send();\n\n  bool barFailed = false;\n  auto request3 = client.barRequest();\n  auto promise3 = request3.send().then(\n      [](Response<test::TestInterface::BarResults>&& response) {\n        ADD_FAILURE() << \"Expected bar() call to fail.\";\n      }, [&](kj::Exception&& e) {\n        EXPECT_EQ(kj::Exception::Type::UNIMPLEMENTED, e.getType());\n        barFailed = true;\n      });\n\n  EXPECT_EQ(0, callCount);\n\n  auto response1 = promise1.wait(waitScope);\n\n  EXPECT_EQ(\"foo\", response1.getX());\n\n  auto response2 = promise2.wait(waitScope);\n\n  promise3.wait(waitScope);\n\n  EXPECT_EQ(2, callCount);\n  EXPECT_TRUE(barFailed);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include \"capability.h\"",
      "#include <capnp/test.capnp.h>",
      "#include \"schema.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "barFailed"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "callCount"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise3.wait",
          "args": [
            "waitScope"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise2.wait",
          "args": [
            "waitScope"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "response1.getX()"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response1.getX",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise1.wait",
          "args": [
            "waitScope"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "callCount"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request3.send",
          "args": [
            "[](Response<test::TestInterface::BarResults>&& response) {\n        ADD_FAILURE() << \"Expected bar() call to fail.\";\n      }",
            "[&](kj::Exception&& e) {\n        EXPECT_EQ(kj::Exception::Type::UNIMPLEMENTED, e.getType());\n        barFailed = true;\n      }"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "LocalRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "207-241",
          "snippet": "RemotePromise<AnyPointer> send() override {\n    KJ_REQUIRE(message.get() != nullptr, \"Already called send() on this request.\");\n\n    // For the lambda capture.\n    uint64_t interfaceId = this->interfaceId;\n    uint16_t methodId = this->methodId;\n\n    auto cancelPaf = kj::newPromiseAndFulfiller<void>();\n\n    auto context = kj::refcounted<LocalCallContext>(\n        kj::mv(message), client->addRef(), kj::mv(cancelPaf.fulfiller));\n    auto promiseAndPipeline = client->call(interfaceId, methodId, kj::addRef(*context));\n\n    // We have to make sure the call is not canceled unless permitted.  We need to fork the promise\n    // so that if the client drops their copy, the promise isn't necessarily canceled.\n    auto forked = promiseAndPipeline.promise.fork();\n\n    // We daemonize one branch, but only after joining it with the promise that fires if\n    // cancellation is allowed.\n    forked.addBranch()\n        .attach(kj::addRef(*context))\n        .exclusiveJoin(kj::mv(cancelPaf.promise))\n        .detach([](kj::Exception&&) {});  // ignore exceptions\n\n    // Now the other branch returns the response from the context.\n    auto promise = forked.addBranch().then(kj::mvCapture(context,\n        [](kj::Own<LocalCallContext>&& context) {\n      context->getResults(MessageSize { 0, 0 });  // force response allocation\n      return kj::mv(KJ_ASSERT_NONNULL(context->response));\n    }));\n\n    // We return the other branch.\n    return RemotePromise<AnyPointer>(\n        kj::mv(promise), AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline)));\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<MallocMessageBuilder>> request;",
            "kj::Maybe<Response<AnyPointer>> response;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<kj::Own<MallocMessageBuilder>> request;\nkj::Maybe<Response<AnyPointer>> response;\n\nLocalRequest {\n  RemotePromise<AnyPointer> send() override {\n      KJ_REQUIRE(message.get() != nullptr, \"Already called send() on this request.\");\n  \n      // For the lambda capture.\n      uint64_t interfaceId = this->interfaceId;\n      uint16_t methodId = this->methodId;\n  \n      auto cancelPaf = kj::newPromiseAndFulfiller<void>();\n  \n      auto context = kj::refcounted<LocalCallContext>(\n          kj::mv(message), client->addRef(), kj::mv(cancelPaf.fulfiller));\n      auto promiseAndPipeline = client->call(interfaceId, methodId, kj::addRef(*context));\n  \n      // We have to make sure the call is not canceled unless permitted.  We need to fork the promise\n      // so that if the client drops their copy, the promise isn't necessarily canceled.\n      auto forked = promiseAndPipeline.promise.fork();\n  \n      // We daemonize one branch, but only after joining it with the promise that fires if\n      // cancellation is allowed.\n      forked.addBranch()\n          .attach(kj::addRef(*context))\n          .exclusiveJoin(kj::mv(cancelPaf.promise))\n          .detach([](kj::Exception&&) {});  // ignore exceptions\n  \n      // Now the other branch returns the response from the context.\n      auto promise = forked.addBranch().then(kj::mvCapture(context,\n          [](kj::Own<LocalCallContext>&& context) {\n        context->getResults(MessageSize { 0, 0 });  // force response allocation\n        return kj::mv(KJ_ASSERT_NONNULL(context->response));\n      }));\n  \n      // We return the other branch.\n      return RemotePromise<AnyPointer>(\n          kj::mv(promise), AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "kj::Exception::Type::UNIMPLEMENTED",
            "e.getType()"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getType",
          "args": [],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "80-80",
          "snippet": "Type getType() const { return type; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  Type getType() const { return type; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADD_FAILURE",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request3.send",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "client.barRequest",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initTestMessage",
          "args": [
            "request2.initS()"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "initTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "836-836",
          "snippet": "void initTestMessage(TestListDefaults::Builder builder) { genericInitListDefaults(builder); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid initTestMessage(TestListDefaults::Builder builder) { genericInitListDefaults(builder); }"
        }
      },
      {
        "call_info": {
          "callee": "request2.initS",
          "args": [],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.bazRequest",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request1.setJ",
          "args": [
            "true"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request1.setI",
          "args": [
            "123"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.fooRequest",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include \"capability.h\"\n#include <capnp/test.capnp.h>\n#include \"schema.capnp.h\"\n\nTEST(Capability, Basic) {\n  kj::EventLoop loop;\n  kj::WaitScope waitScope(loop);\n\n  int callCount = 0;\n  test::TestInterface::Client client(kj::heap<TestInterfaceImpl>(callCount));\n\n  auto request1 = client.fooRequest();\n  request1.setI(123);\n  request1.setJ(true);\n  auto promise1 = request1.send();\n\n  auto request2 = client.bazRequest();\n  initTestMessage(request2.initS());\n  auto promise2 = request2.send();\n\n  bool barFailed = false;\n  auto request3 = client.barRequest();\n  auto promise3 = request3.send().then(\n      [](Response<test::TestInterface::BarResults>&& response) {\n        ADD_FAILURE() << \"Expected bar() call to fail.\";\n      }, [&](kj::Exception&& e) {\n        EXPECT_EQ(kj::Exception::Type::UNIMPLEMENTED, e.getType());\n        barFailed = true;\n      });\n\n  EXPECT_EQ(0, callCount);\n\n  auto response1 = promise1.wait(waitScope);\n\n  EXPECT_EQ(\"foo\", response1.getX());\n\n  auto response2 = promise2.wait(waitScope);\n\n  promise3.wait(waitScope);\n\n  EXPECT_EQ(2, callCount);\n  EXPECT_TRUE(barFailed);\n}"
  }
]