[
  {
    "function_name": "writeMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
    "lines": "188-218",
    "snippet": "kj::Promise<void> writeMessage(kj::AsyncOutputStream& output,\n                               kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  KJ_REQUIRE(segments.size() > 0, \"Tried to serialize uninitialized message.\");\n\n  WriteArrays arrays;\n  arrays.table = kj::heapArray<_::WireValue<uint32_t>>((segments.size() + 2) & ~size_t(1));\n\n  // We write the segment count - 1 because this makes the first word zero for single-segment\n  // messages, improving compression.  We don't bother doing this with segment sizes because\n  // one-word segments are rare anyway.\n  arrays.table[0].set(segments.size() - 1);\n  for (uint i = 0; i < segments.size(); i++) {\n    arrays.table[i + 1].set(segments[i].size());\n  }\n  if (segments.size() % 2 == 0) {\n    // Set padding byte.\n    arrays.table[segments.size() + 1].set(0);\n  }\n\n  arrays.pieces = kj::heapArray<kj::ArrayPtr<const byte>>(segments.size() + 1);\n  arrays.pieces[0] = arrays.table.asBytes();\n\n  for (uint i = 0; i < segments.size(); i++) {\n    arrays.pieces[i + 1] = segments[i].asBytes();\n  }\n\n  auto promise = output.write(arrays.pieces);\n\n  // Make sure the arrays aren't freed until the write completes.\n  return promise.then(kj::mvCapture(arrays, [](WriteArrays&&) {}));\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "kj::mvCapture(arrays, [](WriteArrays&&) {})"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mvCapture",
          "args": [
            "arrays",
            "[](WriteArrays&&) {}"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "output.write",
          "args": [
            "arrays.pieces"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "CountingOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-common.h",
          "lines": "53-58",
          "snippet": "void write(kj::ArrayPtr<const kj::ArrayPtr<const byte>> pieces) override {\n    FdOutputStream::write(pieces);\n    for (auto& piece: pieces) {\n      throughput += piece.size();\n    }\n  }",
          "includes": [
            "#include <thread>",
            "#include <capnp/serialize-snappy.h>",
            "#include <kj/debug.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <thread>\n#include <capnp/serialize-snappy.h>\n#include <kj/debug.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include \"common.h\"\n\nCountingOutputStream {\n  void write(kj::ArrayPtr<const kj::ArrayPtr<const byte>> pieces) override {\n      FdOutputStream::write(pieces);\n      for (auto& piece: pieces) {\n        throughput += piece.size();\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "segments[i].asBytes",
          "args": [],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "asBytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/blob.h",
          "lines": "128-128",
          "snippet": "inline kj::ArrayPtr<const byte> asBytes() const { return asArray().asBytes(); }",
          "includes": [
            "#include <string.h>",
            "#include \"common.h\"",
            "#include <kj/string.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"common.h\"\n#include <kj/string.h>\n#include <kj/common.h>\n\ninline kj::ArrayPtr<const byte> asBytes() const { return asArray().asBytes(); }"
        }
      },
      {
        "call_info": {
          "callee": "segments.size",
          "args": [],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapArray<kj::ArrayPtr<const byte>>",
          "args": [
            "segments.size() + 1"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arrays.table[segments.size",
          "args": [
            "0"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "493-493",
          "snippet": "inline constexpr size_t size(T&& arr) { return arr.size(); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr size_t size(T&& arr) { return arr.size(); }"
        }
      },
      {
        "call_info": {
          "callee": "arrays.table[i + 1].set",
          "args": [
            "segments[i].size()"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapArray<_::WireValue<uint32_t>>",
          "args": [
            "(segments.size() + 2) & ~size_t(1)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "1"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "segments.size() > 0",
            "\"Tried to serialize uninitialized message.\""
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nkj::Promise<void> writeMessage(kj::AsyncOutputStream& output,\n                               kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  KJ_REQUIRE(segments.size() > 0, \"Tried to serialize uninitialized message.\");\n\n  WriteArrays arrays;\n  arrays.table = kj::heapArray<_::WireValue<uint32_t>>((segments.size() + 2) & ~size_t(1));\n\n  // We write the segment count - 1 because this makes the first word zero for single-segment\n  // messages, improving compression.  We don't bother doing this with segment sizes because\n  // one-word segments are rare anyway.\n  arrays.table[0].set(segments.size() - 1);\n  for (uint i = 0; i < segments.size(); i++) {\n    arrays.table[i + 1].set(segments[i].size());\n  }\n  if (segments.size() % 2 == 0) {\n    // Set padding byte.\n    arrays.table[segments.size() + 1].set(0);\n  }\n\n  arrays.pieces = kj::heapArray<kj::ArrayPtr<const byte>>(segments.size() + 1);\n  arrays.pieces[0] = arrays.table.asBytes();\n\n  for (uint i = 0; i < segments.size(); i++) {\n    arrays.pieces[i + 1] = segments[i].asBytes();\n  }\n\n  auto promise = output.write(arrays.pieces);\n\n  // Make sure the arrays aren't freed until the write completes.\n  return promise.then(kj::mvCapture(arrays, [](WriteArrays&&) {}));\n}"
  },
  {
    "function_name": "tryReadMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
    "lines": "161-173",
    "snippet": "kj::Promise<kj::Maybe<kj::Own<MessageReader>>> tryReadMessage(\n    kj::AsyncInputStream& input, ReaderOptions options, kj::ArrayPtr<word> scratchSpace) {\n  auto reader = kj::heap<AsyncMessageReader>(options);\n  auto promise = reader->read(input, scratchSpace);\n  return promise.then(kj::mvCapture(reader,\n        [](kj::Own<MessageReader>&& reader, bool success) -> kj::Maybe<kj::Own<MessageReader>> {\n    if (success) {\n      return kj::mv(reader);\n    } else {\n      return nullptr;\n    }\n  }));\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "kj::mvCapture(reader,\n        [](kj::Own<MessageReader>&& reader, bool success) -> kj::Maybe<kj::Own<MessageReader>> {\n    if (success) {\n      return kj::mv(reader);\n    } else {\n      return nullptr;\n    }\n  })"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mvCapture",
          "args": [
            "reader",
            "[](kj::Own<MessageReader>&& reader, bool success) -> kj::Maybe<kj::Own<MessageReader>> {\n    if (success) {\n      return kj::mv(reader);\n    } else {\n      return nullptr;\n    }\n  }"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "reader"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader->read",
          "args": [
            "input",
            "scratchSpace"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "SnappyCompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "149-159",
          "snippet": "static void read(int* input, google::protobuf::MessageLite* message) {\n    uint32_t size;\n    readAll(*input, &size, sizeof(size));\n    readAll(*input, scratch, size);\n\n    size_t uncompressedSize;\n    GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n    GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n\n    GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSnappyCompressed {\n  static void read(int* input, google::protobuf::MessageLite* message) {\n      uint32_t size;\n      readAll(*input, &size, sizeof(size));\n      readAll(*input, scratch, size);\n  \n      size_t uncompressedSize;\n      GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n      GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n  \n      GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<AsyncMessageReader>",
          "args": [
            "options"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nkj::Promise<kj::Maybe<kj::Own<MessageReader>>> tryReadMessage(\n    kj::AsyncInputStream& input, ReaderOptions options, kj::ArrayPtr<word> scratchSpace) {\n  auto reader = kj::heap<AsyncMessageReader>(options);\n  auto promise = reader->read(input, scratchSpace);\n  return promise.then(kj::mvCapture(reader,\n        [](kj::Own<MessageReader>&& reader, bool success) -> kj::Maybe<kj::Own<MessageReader>> {\n    if (success) {\n      return kj::mv(reader);\n    } else {\n      return nullptr;\n    }\n  }));\n}"
  },
  {
    "function_name": "readMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
    "lines": "151-159",
    "snippet": "kj::Promise<kj::Own<MessageReader>> readMessage(\n    kj::AsyncInputStream& input, ReaderOptions options, kj::ArrayPtr<word> scratchSpace) {\n  auto reader = kj::heap<AsyncMessageReader>(options);\n  auto promise = reader->read(input, scratchSpace);\n  return promise.then(kj::mvCapture(reader, [](kj::Own<MessageReader>&& reader, bool success) {\n    KJ_REQUIRE(success, \"Premature EOF.\") { break; }\n    return kj::mv(reader);\n  }));\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "kj::mvCapture(reader, [](kj::Own<MessageReader>&& reader, bool success) {\n    KJ_REQUIRE(success, \"Premature EOF.\") { break; }\n    return kj::mv(reader);\n  })"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mvCapture",
          "args": [
            "reader",
            "[](kj::Own<MessageReader>&& reader, bool success) {\n    KJ_REQUIRE(success, \"Premature EOF.\") { break; }\n    return kj::mv(reader);\n  }"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "reader"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "success",
            "\"Premature EOF.\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader->read",
          "args": [
            "input",
            "scratchSpace"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "SnappyCompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "149-159",
          "snippet": "static void read(int* input, google::protobuf::MessageLite* message) {\n    uint32_t size;\n    readAll(*input, &size, sizeof(size));\n    readAll(*input, scratch, size);\n\n    size_t uncompressedSize;\n    GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n    GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n\n    GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSnappyCompressed {\n  static void read(int* input, google::protobuf::MessageLite* message) {\n      uint32_t size;\n      readAll(*input, &size, sizeof(size));\n      readAll(*input, scratch, size);\n  \n      size_t uncompressedSize;\n      GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n      GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n  \n      GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<AsyncMessageReader>",
          "args": [
            "options"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nkj::Promise<kj::Own<MessageReader>> readMessage(\n    kj::AsyncInputStream& input, ReaderOptions options, kj::ArrayPtr<word> scratchSpace) {\n  auto reader = kj::heap<AsyncMessageReader>(options);\n  auto promise = reader->read(input, scratchSpace);\n  return promise.then(kj::mvCapture(reader, [](kj::Own<MessageReader>&& reader, bool success) {\n    KJ_REQUIRE(success, \"Premature EOF.\") { break; }\n    return kj::mv(reader);\n  }));\n}"
  },
  {
    "function_name": "AsyncMessageReader::readSegments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
    "lines": "106-146",
    "snippet": "kj::Promise<void> AsyncMessageReader::readSegments(kj::AsyncInputStream& inputStream,\n                                                   kj::ArrayPtr<word> scratchSpace) {\n  size_t totalWords = segment0Size();\n\n  if (segmentCount() > 1) {\n    for (uint i = 0; i < segmentCount() - 1; i++) {\n      totalWords += moreSizes[i].get();\n    }\n  }\n\n  // Don't accept a message which the receiver couldn't possibly traverse without hitting the\n  // traversal limit.  Without this check, a malicious client could transmit a very large segment\n  // size to make the receiver allocate excessive space and possibly crash.\n  KJ_REQUIRE(totalWords <= getOptions().traversalLimitInWords,\n             \"Message is too large.  To increase the limit on the receiving end, see \"\n             \"capnp::ReaderOptions.\") {\n    return kj::READY_NOW;  // exception will be propagated\n  }\n\n  if (scratchSpace.size() < totalWords) {\n    // TODO(perf):  Consider allocating each segment as a separate chunk to reduce memory\n    //   fragmentation.\n    ownedSpace = kj::heapArray<word>(totalWords);\n    scratchSpace = ownedSpace;\n  }\n\n  segmentStarts = kj::heapArray<const word*>(segmentCount());\n\n  segmentStarts[0] = scratchSpace.begin();\n\n  if (segmentCount() > 1) {\n    size_t offset = segment0Size();\n\n    for (uint i = 1; i < segmentCount(); i++) {\n      segmentStarts[i] = scratchSpace.begin() + offset;\n      offset += moreSizes[i-1].get();\n    }\n  }\n\n  return inputStream.read(scratchSpace.begin(), totalWords * sizeof(word));\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inputStream.read",
          "args": [
            "scratchSpace.begin()",
            "totalWords * sizeof(word)"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "SnappyCompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "149-159",
          "snippet": "static void read(int* input, google::protobuf::MessageLite* message) {\n    uint32_t size;\n    readAll(*input, &size, sizeof(size));\n    readAll(*input, scratch, size);\n\n    size_t uncompressedSize;\n    GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n    GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n\n    GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSnappyCompressed {\n  static void read(int* input, google::protobuf::MessageLite* message) {\n      uint32_t size;\n      readAll(*input, &size, sizeof(size));\n      readAll(*input, scratch, size);\n  \n      size_t uncompressedSize;\n      GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n      GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n  \n      GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "scratchSpace.begin",
          "args": [],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "moreSizes[i-1].get",
          "args": [],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "segmentCount",
          "args": [],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "segmentCount",
          "container": "AsyncMessageReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
          "lines": "57-57",
          "snippet": "inline uint segmentCount() { return firstWord[0].get() + 1; }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nAsyncMessageReader {\n  inline uint segmentCount() { return firstWord[0].get() + 1; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "segment0Size",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "segment0Size",
          "container": "AsyncMessageReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
          "lines": "58-58",
          "snippet": "inline uint segment0Size() { return firstWord[1].get(); }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nAsyncMessageReader {\n  inline uint segment0Size() { return firstWord[1].get(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapArray<const word*>",
          "args": [
            "segmentCount()"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "696-698",
          "snippet": "inline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}"
        }
      },
      {
        "call_info": {
          "callee": "scratchSpace.size",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "totalWords <= getOptions().traversalLimitInWords",
            "\"Message is too large.  To increase the limit on the receiving end, see \"\n             \"capnp::ReaderOptions.\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getOptions",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nkj::Promise<void> AsyncMessageReader::readSegments(kj::AsyncInputStream& inputStream,\n                                                   kj::ArrayPtr<word> scratchSpace) {\n  size_t totalWords = segment0Size();\n\n  if (segmentCount() > 1) {\n    for (uint i = 0; i < segmentCount() - 1; i++) {\n      totalWords += moreSizes[i].get();\n    }\n  }\n\n  // Don't accept a message which the receiver couldn't possibly traverse without hitting the\n  // traversal limit.  Without this check, a malicious client could transmit a very large segment\n  // size to make the receiver allocate excessive space and possibly crash.\n  KJ_REQUIRE(totalWords <= getOptions().traversalLimitInWords,\n             \"Message is too large.  To increase the limit on the receiving end, see \"\n             \"capnp::ReaderOptions.\") {\n    return kj::READY_NOW;  // exception will be propagated\n  }\n\n  if (scratchSpace.size() < totalWords) {\n    // TODO(perf):  Consider allocating each segment as a separate chunk to reduce memory\n    //   fragmentation.\n    ownedSpace = kj::heapArray<word>(totalWords);\n    scratchSpace = ownedSpace;\n  }\n\n  segmentStarts = kj::heapArray<const word*>(segmentCount());\n\n  segmentStarts[0] = scratchSpace.begin();\n\n  if (segmentCount() > 1) {\n    size_t offset = segment0Size();\n\n    for (uint i = 1; i < segmentCount(); i++) {\n      segmentStarts[i] = scratchSpace.begin() + offset;\n      offset += moreSizes[i-1].get();\n    }\n  }\n\n  return inputStream.read(scratchSpace.begin(), totalWords * sizeof(word));\n}"
  },
  {
    "function_name": "AsyncMessageReader::readAfterFirstWord",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
    "lines": "83-104",
    "snippet": "kj::Promise<void> AsyncMessageReader::readAfterFirstWord(kj::AsyncInputStream& inputStream,\n                                                         kj::ArrayPtr<word> scratchSpace) {\n  if (segmentCount() == 0) {\n    firstWord[1].set(0);\n  }\n\n  // Reject messages with too many segments for security reasons.\n  KJ_REQUIRE(segmentCount() < 512, \"Message has too many segments.\") {\n    return kj::READY_NOW;  // exception will be propagated\n  }\n\n  if (segmentCount() > 1) {\n    // Read sizes for all segments except the first.  Include padding if necessary.\n    moreSizes = kj::heapArray<_::WireValue<uint32_t>>(segmentCount() & ~1);\n    return inputStream.read(moreSizes.begin(), moreSizes.size() * sizeof(moreSizes[0]))\n        .then([this,&inputStream,scratchSpace]() mutable {\n          return readSegments(inputStream, scratchSpace);\n        });\n  } else {\n    return readSegments(inputStream, scratchSpace);\n  }\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readSegments",
          "args": [
            "inputStream",
            "scratchSpace"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "AsyncMessageReader::readSegments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
          "lines": "106-146",
          "snippet": "kj::Promise<void> AsyncMessageReader::readSegments(kj::AsyncInputStream& inputStream,\n                                                   kj::ArrayPtr<word> scratchSpace) {\n  size_t totalWords = segment0Size();\n\n  if (segmentCount() > 1) {\n    for (uint i = 0; i < segmentCount() - 1; i++) {\n      totalWords += moreSizes[i].get();\n    }\n  }\n\n  // Don't accept a message which the receiver couldn't possibly traverse without hitting the\n  // traversal limit.  Without this check, a malicious client could transmit a very large segment\n  // size to make the receiver allocate excessive space and possibly crash.\n  KJ_REQUIRE(totalWords <= getOptions().traversalLimitInWords,\n             \"Message is too large.  To increase the limit on the receiving end, see \"\n             \"capnp::ReaderOptions.\") {\n    return kj::READY_NOW;  // exception will be propagated\n  }\n\n  if (scratchSpace.size() < totalWords) {\n    // TODO(perf):  Consider allocating each segment as a separate chunk to reduce memory\n    //   fragmentation.\n    ownedSpace = kj::heapArray<word>(totalWords);\n    scratchSpace = ownedSpace;\n  }\n\n  segmentStarts = kj::heapArray<const word*>(segmentCount());\n\n  segmentStarts[0] = scratchSpace.begin();\n\n  if (segmentCount() > 1) {\n    size_t offset = segment0Size();\n\n    for (uint i = 1; i < segmentCount(); i++) {\n      segmentStarts[i] = scratchSpace.begin() + offset;\n      offset += moreSizes[i-1].get();\n    }\n  }\n\n  return inputStream.read(scratchSpace.begin(), totalWords * sizeof(word));\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nkj::Promise<void> AsyncMessageReader::readSegments(kj::AsyncInputStream& inputStream,\n                                                   kj::ArrayPtr<word> scratchSpace) {\n  size_t totalWords = segment0Size();\n\n  if (segmentCount() > 1) {\n    for (uint i = 0; i < segmentCount() - 1; i++) {\n      totalWords += moreSizes[i].get();\n    }\n  }\n\n  // Don't accept a message which the receiver couldn't possibly traverse without hitting the\n  // traversal limit.  Without this check, a malicious client could transmit a very large segment\n  // size to make the receiver allocate excessive space and possibly crash.\n  KJ_REQUIRE(totalWords <= getOptions().traversalLimitInWords,\n             \"Message is too large.  To increase the limit on the receiving end, see \"\n             \"capnp::ReaderOptions.\") {\n    return kj::READY_NOW;  // exception will be propagated\n  }\n\n  if (scratchSpace.size() < totalWords) {\n    // TODO(perf):  Consider allocating each segment as a separate chunk to reduce memory\n    //   fragmentation.\n    ownedSpace = kj::heapArray<word>(totalWords);\n    scratchSpace = ownedSpace;\n  }\n\n  segmentStarts = kj::heapArray<const word*>(segmentCount());\n\n  segmentStarts[0] = scratchSpace.begin();\n\n  if (segmentCount() > 1) {\n    size_t offset = segment0Size();\n\n    for (uint i = 1; i < segmentCount(); i++) {\n      segmentStarts[i] = scratchSpace.begin() + offset;\n      offset += moreSizes[i-1].get();\n    }\n  }\n\n  return inputStream.read(scratchSpace.begin(), totalWords * sizeof(word));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inputStream.read",
          "args": [
            "[this,&inputStream,scratchSpace]() mutable {\n          return readSegments(inputStream, scratchSpace);\n        }"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "FakeFileReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser-test.c++",
          "lines": "41-47",
          "snippet": "kj::Array<const char> read(kj::StringPtr path) const override {\n    auto iter = files.find(path);\n    KJ_ASSERT(iter != files.end(), \"FakeFileReader has no such file.\", path);\n    auto result = kj::heapArray<char>(iter->second.size());\n    memcpy(result.begin(), iter->second.begin(), iter->second.size());\n    return kj::mv(result);\n  }",
          "includes": [
            "#include <map>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\"",
            "#include <kj/compat/gtest.h>",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include <kj/compat/gtest.h>\n#include \"schema-parser.h\"\n\nFakeFileReader {\n  kj::Array<const char> read(kj::StringPtr path) const override {\n      auto iter = files.find(path);\n      KJ_ASSERT(iter != files.end(), \"FakeFileReader has no such file.\", path);\n      auto result = kj::heapArray<char>(iter->second.size());\n      memcpy(result.begin(), iter->second.begin(), iter->second.size());\n      return kj::mv(result);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "inputStream.read",
          "args": [
            "moreSizes.begin()",
            "moreSizes.size() * sizeof(moreSizes[0])"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "SnappyCompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "149-159",
          "snippet": "static void read(int* input, google::protobuf::MessageLite* message) {\n    uint32_t size;\n    readAll(*input, &size, sizeof(size));\n    readAll(*input, scratch, size);\n\n    size_t uncompressedSize;\n    GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n    GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n\n    GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSnappyCompressed {\n  static void read(int* input, google::protobuf::MessageLite* message) {\n      uint32_t size;\n      readAll(*input, &size, sizeof(size));\n      readAll(*input, scratch, size);\n  \n      size_t uncompressedSize;\n      GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n      GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n  \n      GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "moreSizes.size",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "moreSizes.begin",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapArray<_::WireValue<uint32_t>>",
          "args": [
            "segmentCount() & ~1"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segmentCount",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "segmentCount",
          "container": "AsyncMessageReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
          "lines": "57-57",
          "snippet": "inline uint segmentCount() { return firstWord[0].get() + 1; }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nAsyncMessageReader {\n  inline uint segmentCount() { return firstWord[0].get() + 1; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "segmentCount() < 512",
            "\"Message has too many segments.\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "firstWord[1].set",
          "args": [
            "0"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nkj::Promise<void> AsyncMessageReader::readAfterFirstWord(kj::AsyncInputStream& inputStream,\n                                                         kj::ArrayPtr<word> scratchSpace) {\n  if (segmentCount() == 0) {\n    firstWord[1].set(0);\n  }\n\n  // Reject messages with too many segments for security reasons.\n  KJ_REQUIRE(segmentCount() < 512, \"Message has too many segments.\") {\n    return kj::READY_NOW;  // exception will be propagated\n  }\n\n  if (segmentCount() > 1) {\n    // Read sizes for all segments except the first.  Include padding if necessary.\n    moreSizes = kj::heapArray<_::WireValue<uint32_t>>(segmentCount() & ~1);\n    return inputStream.read(moreSizes.begin(), moreSizes.size() * sizeof(moreSizes[0]))\n        .then([this,&inputStream,scratchSpace]() mutable {\n          return readSegments(inputStream, scratchSpace);\n        });\n  } else {\n    return readSegments(inputStream, scratchSpace);\n  }\n}"
  },
  {
    "function_name": "AsyncMessageReader::read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
    "lines": "66-81",
    "snippet": "kj::Promise<bool> AsyncMessageReader::read(kj::AsyncInputStream& inputStream,\n                                           kj::ArrayPtr<word> scratchSpace) {\n  return inputStream.tryRead(firstWord, sizeof(firstWord), sizeof(firstWord))\n      .then([this,&inputStream,scratchSpace](size_t n) mutable -> kj::Promise<bool> {\n    if (n == 0) {\n      return false;\n    } else if (n < sizeof(firstWord)) {\n      // EOF in first word.\n      KJ_FAIL_REQUIRE(\"Premature EOF.\") {\n        return false;\n      }\n    }\n\n    return readAfterFirstWord(inputStream, scratchSpace).then([]() { return true; });\n  });\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inputStream.tryRead",
          "args": [
            "[this,&inputStream,scratchSpace](size_t n) mutable -> kj::Promise<bool> {\n    if (n == 0) {\n      return false;\n    } else if (n < sizeof(firstWord)) {\n      // EOF in first word.\n      KJ_FAIL_REQUIRE(\"Premature EOF.\") {\n        return false;\n      }\n    }\n\n    return readAfterFirstWord(inputStream, scratchSpace).then([]() { return true; });\n  }"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readAfterFirstWord",
          "args": [
            "[]() { return true; }"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readAfterFirstWord",
          "args": [
            "inputStream",
            "scratchSpace"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "AsyncMessageReader::readAfterFirstWord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
          "lines": "83-104",
          "snippet": "kj::Promise<void> AsyncMessageReader::readAfterFirstWord(kj::AsyncInputStream& inputStream,\n                                                         kj::ArrayPtr<word> scratchSpace) {\n  if (segmentCount() == 0) {\n    firstWord[1].set(0);\n  }\n\n  // Reject messages with too many segments for security reasons.\n  KJ_REQUIRE(segmentCount() < 512, \"Message has too many segments.\") {\n    return kj::READY_NOW;  // exception will be propagated\n  }\n\n  if (segmentCount() > 1) {\n    // Read sizes for all segments except the first.  Include padding if necessary.\n    moreSizes = kj::heapArray<_::WireValue<uint32_t>>(segmentCount() & ~1);\n    return inputStream.read(moreSizes.begin(), moreSizes.size() * sizeof(moreSizes[0]))\n        .then([this,&inputStream,scratchSpace]() mutable {\n          return readSegments(inputStream, scratchSpace);\n        });\n  } else {\n    return readSegments(inputStream, scratchSpace);\n  }\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nkj::Promise<void> AsyncMessageReader::readAfterFirstWord(kj::AsyncInputStream& inputStream,\n                                                         kj::ArrayPtr<word> scratchSpace) {\n  if (segmentCount() == 0) {\n    firstWord[1].set(0);\n  }\n\n  // Reject messages with too many segments for security reasons.\n  KJ_REQUIRE(segmentCount() < 512, \"Message has too many segments.\") {\n    return kj::READY_NOW;  // exception will be propagated\n  }\n\n  if (segmentCount() > 1) {\n    // Read sizes for all segments except the first.  Include padding if necessary.\n    moreSizes = kj::heapArray<_::WireValue<uint32_t>>(segmentCount() & ~1);\n    return inputStream.read(moreSizes.begin(), moreSizes.size() * sizeof(moreSizes[0]))\n        .then([this,&inputStream,scratchSpace]() mutable {\n          return readSegments(inputStream, scratchSpace);\n        });\n  } else {\n    return readSegments(inputStream, scratchSpace);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Premature EOF.\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inputStream.tryRead",
          "args": [
            "firstWord",
            "sizeof(firstWord)",
            "sizeof(firstWord)"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "TestInputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-test.c++",
          "lines": "156-162",
          "snippet": "size_t tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    KJ_ASSERT(maxBytes <= size_t(end - pos), \"Overran end of stream.\");\n    size_t amount = lazy ? minBytes : maxBytes;\n    memcpy(buffer, pos, amount);\n    pos += amount;\n    return amount;\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <string>",
            "#include <kj/miniposix.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string>\n#include <kj/miniposix.h>\n#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n\nTestInputStream {\n  size_t tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      KJ_ASSERT(maxBytes <= size_t(end - pos), \"Overran end of stream.\");\n      size_t amount = lazy ? minBytes : maxBytes;\n      memcpy(buffer, pos, amount);\n      pos += amount;\n      return amount;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nkj::Promise<bool> AsyncMessageReader::read(kj::AsyncInputStream& inputStream,\n                                           kj::ArrayPtr<word> scratchSpace) {\n  return inputStream.tryRead(firstWord, sizeof(firstWord), sizeof(firstWord))\n      .then([this,&inputStream,scratchSpace](size_t n) mutable -> kj::Promise<bool> {\n    if (n == 0) {\n      return false;\n    } else if (n < sizeof(firstWord)) {\n      // EOF in first word.\n      KJ_FAIL_REQUIRE(\"Premature EOF.\") {\n        return false;\n      }\n    }\n\n    return readAfterFirstWord(inputStream, scratchSpace).then([]() { return true; });\n  });\n}"
  },
  {
    "function_name": "segment0Size",
    "container": "AsyncMessageReader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
    "lines": "58-58",
    "snippet": "inline uint segment0Size() { return firstWord[1].get(); }",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "firstWord[1].get",
          "args": [],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nAsyncMessageReader {\n  inline uint segment0Size() { return firstWord[1].get(); }\n}"
  },
  {
    "function_name": "segmentCount",
    "container": "AsyncMessageReader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
    "lines": "57-57",
    "snippet": "inline uint segmentCount() { return firstWord[0].get() + 1; }",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "firstWord[0].get",
          "args": [],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nAsyncMessageReader {\n  inline uint segmentCount() { return firstWord[0].get() + 1; }\n}"
  },
  {
    "function_name": "getSegment",
    "container": "AsyncMessageReader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
    "lines": "40-47",
    "snippet": "kj::ArrayPtr<const word> getSegment(uint id) override {\n    if (id >= segmentCount()) {\n      return nullptr;\n    } else {\n      uint32_t size = id == 0 ? segment0Size() : moreSizes[id - 1].get();\n      return kj::arrayPtr(segmentStarts[id], size);\n    }\n  }",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "segmentStarts[id]",
            "size"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "moreSizes[id - 1].get",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "segment0Size",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "segment0Size",
          "container": "AsyncMessageReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
          "lines": "58-58",
          "snippet": "inline uint segment0Size() { return firstWord[1].get(); }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nAsyncMessageReader {\n  inline uint segment0Size() { return firstWord[1].get(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "segmentCount",
          "args": [],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "segmentCount",
          "container": "AsyncMessageReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
          "lines": "57-57",
          "snippet": "inline uint segmentCount() { return firstWord[0].get() + 1; }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nAsyncMessageReader {\n  inline uint segmentCount() { return firstWord[0].get() + 1; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nAsyncMessageReader {\n  kj::ArrayPtr<const word> getSegment(uint id) override {\n      if (id >= segmentCount()) {\n        return nullptr;\n      } else {\n        uint32_t size = id == 0 ? segment0Size() : moreSizes[id - 1].get();\n        return kj::arrayPtr(segmentStarts[id], size);\n      }\n    }\n}"
  },
  {
    "function_name": "AsyncMessageReader",
    "container": "AsyncMessageReader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
    "lines": "31-33",
    "snippet": "inline AsyncMessageReader(ReaderOptions options): MessageReader(options) {\n    memset(firstWord, 0, sizeof(firstWord));\n  }",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "firstWord",
            "0",
            "sizeof(firstWord)"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nAsyncMessageReader {\n  inline AsyncMessageReader(ReaderOptions options): MessageReader(options) {\n      memset(firstWord, 0, sizeof(firstWord));\n    }\n}"
  }
]