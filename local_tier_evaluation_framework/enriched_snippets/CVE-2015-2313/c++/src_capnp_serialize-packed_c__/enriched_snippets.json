[
  {
    "function_name": "writePackedMessageToFd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed.c++",
    "lines": "474-477",
    "snippet": "void writePackedMessageToFd(int fd, kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  kj::FdOutputStream output(fd);\n  writePackedMessage(output, segments);\n}",
    "includes": [
      "#include <vector>",
      "#include \"layout.h\"",
      "#include <kj/debug.h>",
      "#include \"serialize-packed.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writePackedMessage",
          "args": [
            "output",
            "segments"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "writePackedMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed.h",
          "lines": "116-118",
          "snippet": "inline void writePackedMessage(kj::OutputStream& output, MessageBuilder& builder) {\n  writePackedMessage(output, builder.getSegmentsForOutput());\n}",
          "includes": [
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"serialize.h\"\n\ninline void writePackedMessage(kj::OutputStream& output, MessageBuilder& builder) {\n  writePackedMessage(output, builder.getSegmentsForOutput());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"layout.h\"\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nvoid writePackedMessageToFd(int fd, kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  kj::FdOutputStream output(fd);\n  writePackedMessage(output, segments);\n}"
  },
  {
    "function_name": "writePackedMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed.c++",
    "lines": "463-471",
    "snippet": "void writePackedMessage(kj::OutputStream& output,\n                        kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  KJ_IF_MAYBE(bufferedOutputPtr, kj::dynamicDowncastIfAvailable<kj::BufferedOutputStream>(output)) {\n    writePackedMessage(*bufferedOutputPtr, segments);\n  } else {\n    byte buffer[8192];\n    kj::BufferedOutputStreamWrapper bufferedOutput(output, kj::arrayPtr(buffer, sizeof(buffer)));\n    writePackedMessage(bufferedOutput, segments);\n  }",
    "includes": [
      "#include <vector>",
      "#include \"layout.h\"",
      "#include <kj/debug.h>",
      "#include \"serialize-packed.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writePackedMessage",
          "args": [
            "bufferedOutput",
            "segments"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "writePackedMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed.h",
          "lines": "116-118",
          "snippet": "inline void writePackedMessage(kj::OutputStream& output, MessageBuilder& builder) {\n  writePackedMessage(output, builder.getSegmentsForOutput());\n}",
          "includes": [
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"serialize.h\"\n\ninline void writePackedMessage(kj::OutputStream& output, MessageBuilder& builder) {\n  writePackedMessage(output, builder.getSegmentsForOutput());\n}"
        }
      },
      {
        "call_info": {
          "callee": "bufferedOutput",
          "args": [
            "output",
            "kj::arrayPtr(buffer, sizeof(buffer))"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"layout.h\"\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nvoid writePackedMessage(kj::OutputStream& output,\n                        kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  KJ_IF_MAYBE(bufferedOutputPtr, kj::dynamicDowncastIfAvailable<kj::BufferedOutputStream>(output)) {\n    writePackedMessage(*bufferedOutputPtr, segments);\n  } else {\n    byte buffer[8192];\n    kj::BufferedOutputStreamWrapper bufferedOutput(output, kj::arrayPtr(buffer, sizeof(buffer)));\n    writePackedMessage(bufferedOutput, segments);\n  }"
  },
  {
    "function_name": "writePackedMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed.c++",
    "lines": "457-461",
    "snippet": "void writePackedMessage(kj::BufferedOutputStream& output,\n                        kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  _::PackedOutputStream packedOutput(output);\n  writeMessage(packedOutput, segments);\n}",
    "includes": [
      "#include <vector>",
      "#include \"layout.h\"",
      "#include <kj/debug.h>",
      "#include \"serialize-packed.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeMessage",
          "args": [
            "packedOutput",
            "segments"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "writeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.h",
          "lines": "58-60",
          "snippet": "inline kj::Promise<void> writeMessage(kj::AsyncOutputStream& output, MessageBuilder& builder) {\n  return writeMessage(output, builder.getSegmentsForOutput());\n}",
          "includes": [
            "#include \"message.h\"",
            "#include <kj/async-io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"message.h\"\n#include <kj/async-io.h>\n\ninline kj::Promise<void> writeMessage(kj::AsyncOutputStream& output, MessageBuilder& builder) {\n  return writeMessage(output, builder.getSegmentsForOutput());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"layout.h\"\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nvoid writePackedMessage(kj::BufferedOutputStream& output,\n                        kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  _::PackedOutputStream packedOutput(output);\n  writeMessage(packedOutput, segments);\n}"
  },
  {
    "function_name": "PackedFdMessageReader::~PackedFdMessageReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed.c++",
    "lines": "455-455",
    "snippet": "PackedFdMessageReader::~PackedFdMessageReader() noexcept(false) {}",
    "includes": [
      "#include <vector>",
      "#include \"layout.h\"",
      "#include <kj/debug.h>",
      "#include \"serialize-packed.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <vector>\n#include \"layout.h\"\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nPackedFdMessageReader::~PackedFdMessageReader() noexcept(false) {}"
  },
  {
    "function_name": "PackedFdMessageReader::PackedFdMessageReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed.c++",
    "lines": "448-453",
    "snippet": "PackedFdMessageReader::PackedFdMessageReader(\n    kj::AutoCloseFd fd, ReaderOptions options, kj::ArrayPtr<word> scratchSpace)\n    : FdInputStream(kj::mv(fd)),\n      BufferedInputStreamWrapper(static_cast<FdInputStream&>(*this)),\n      PackedMessageReader(static_cast<BufferedInputStreamWrapper&>(*this),\n                          options, scratchSpace) {}",
    "includes": [
      "#include <vector>",
      "#include \"layout.h\"",
      "#include <kj/debug.h>",
      "#include \"serialize-packed.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<BufferedInputStreamWrapper&>",
          "args": [
            "*this"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<FdInputStream&>",
          "args": [
            "*this"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "fd"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"layout.h\"\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nPackedFdMessageReader::PackedFdMessageReader(\n    kj::AutoCloseFd fd, ReaderOptions options, kj::ArrayPtr<word> scratchSpace)\n    : FdInputStream(kj::mv(fd)),\n      BufferedInputStreamWrapper(static_cast<FdInputStream&>(*this)),\n      PackedMessageReader(static_cast<BufferedInputStreamWrapper&>(*this),\n                          options, scratchSpace) {}"
  },
  {
    "function_name": "PackedFdMessageReader::PackedFdMessageReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed.c++",
    "lines": "441-446",
    "snippet": "PackedFdMessageReader::PackedFdMessageReader(\n    int fd, ReaderOptions options, kj::ArrayPtr<word> scratchSpace)\n    : FdInputStream(fd),\n      BufferedInputStreamWrapper(static_cast<FdInputStream&>(*this)),\n      PackedMessageReader(static_cast<BufferedInputStreamWrapper&>(*this),\n                          options, scratchSpace) {}",
    "includes": [
      "#include <vector>",
      "#include \"layout.h\"",
      "#include <kj/debug.h>",
      "#include \"serialize-packed.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<BufferedInputStreamWrapper&>",
          "args": [
            "*this"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<FdInputStream&>",
          "args": [
            "*this"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"layout.h\"\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nPackedFdMessageReader::PackedFdMessageReader(\n    int fd, ReaderOptions options, kj::ArrayPtr<word> scratchSpace)\n    : FdInputStream(fd),\n      BufferedInputStreamWrapper(static_cast<FdInputStream&>(*this)),\n      PackedMessageReader(static_cast<BufferedInputStreamWrapper&>(*this),\n                          options, scratchSpace) {}"
  },
  {
    "function_name": "PackedMessageReader::~PackedMessageReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed.c++",
    "lines": "439-439",
    "snippet": "PackedMessageReader::~PackedMessageReader() noexcept(false) {}",
    "includes": [
      "#include <vector>",
      "#include \"layout.h\"",
      "#include <kj/debug.h>",
      "#include \"serialize-packed.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <vector>\n#include \"layout.h\"\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nPackedMessageReader::~PackedMessageReader() noexcept(false) {}"
  },
  {
    "function_name": "PackedMessageReader::PackedMessageReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed.c++",
    "lines": "434-437",
    "snippet": "PackedMessageReader::PackedMessageReader(\n    kj::BufferedInputStream& inputStream, ReaderOptions options, kj::ArrayPtr<word> scratchSpace)\n    : PackedInputStream(inputStream),\n      InputStreamMessageReader(static_cast<PackedInputStream&>(*this), options, scratchSpace) {}",
    "includes": [
      "#include <vector>",
      "#include \"layout.h\"",
      "#include <kj/debug.h>",
      "#include \"serialize-packed.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<PackedInputStream&>",
          "args": [
            "*this"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"layout.h\"\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nPackedMessageReader::PackedMessageReader(\n    kj::BufferedInputStream& inputStream, ReaderOptions options, kj::ArrayPtr<word> scratchSpace)\n    : PackedInputStream(inputStream),\n      InputStreamMessageReader(static_cast<PackedInputStream&>(*this), options, scratchSpace) {}"
  },
  {
    "function_name": "PackedOutputStream::write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed.c++",
    "lines": "305-428",
    "snippet": "void PackedOutputStream::write(const void* src, size_t size) {\n  kj::ArrayPtr<byte> buffer = inner.getWriteBuffer();\n  byte slowBuffer[20];\n\n  uint8_t* __restrict__ out = reinterpret_cast<uint8_t*>(buffer.begin());\n\n  const uint8_t* __restrict__ in = reinterpret_cast<const uint8_t*>(src);\n  const uint8_t* const inEnd = reinterpret_cast<const uint8_t*>(src) + size;\n\n  while (in < inEnd) {\n    if (reinterpret_cast<uint8_t*>(buffer.end()) - out < 10) {\n      // Oops, we're out of space.  We need at least 10 bytes for the fast path, since we don't\n      // bounds-check on every byte.\n\n      // Write what we have so far.\n      inner.write(buffer.begin(), out - reinterpret_cast<uint8_t*>(buffer.begin()));\n\n      // Use a slow buffer into which we'll encode 10 to 20 bytes.  This should get us past the\n      // output stream's buffer boundary.\n      buffer = kj::arrayPtr(slowBuffer, sizeof(slowBuffer));\n      out = reinterpret_cast<uint8_t*>(buffer.begin());\n    }\n\n    uint8_t* tagPos = out++;\n\n#define HANDLE_BYTE(n) \\\n    uint8_t bit##n = *in != 0; \\\n    *out = *in; \\\n    out += bit##n; /* out only advances if the byte was non-zero */ \\\n    ++in\n\n    HANDLE_BYTE(0);\n    HANDLE_BYTE(1);\n    HANDLE_BYTE(2);\n    HANDLE_BYTE(3);\n    HANDLE_BYTE(4);\n    HANDLE_BYTE(5);\n    HANDLE_BYTE(6);\n    HANDLE_BYTE(7);\n#undef HANDLE_BYTE\n\n    uint8_t tag = (bit0 << 0) | (bit1 << 1) | (bit2 << 2) | (bit3 << 3)\n                | (bit4 << 4) | (bit5 << 5) | (bit6 << 6) | (bit7 << 7);\n    *tagPos = tag;\n\n    if (tag == 0) {\n      // An all-zero word is followed by a count of consecutive zero words (not including the\n      // first one).\n\n      // We can check a whole word at a time.\n      const uint64_t* inWord = reinterpret_cast<const uint64_t*>(in);\n\n      // The count must fit it 1 byte, so limit to 255 words.\n      const uint64_t* limit = reinterpret_cast<const uint64_t*>(inEnd);\n      if (limit - inWord > 255) {\n        limit = inWord + 255;\n      }\n\n      while (inWord < limit && *inWord == 0) {\n        ++inWord;\n      }\n\n      // Write the count.\n      *out++ = inWord - reinterpret_cast<const uint64_t*>(in);\n\n      // Advance input.\n      in = reinterpret_cast<const uint8_t*>(inWord);\n\n    } else if (tag == 0xffu) {\n      // An all-nonzero word is followed by a count of consecutive uncompressed words, followed\n      // by the uncompressed words themselves.\n\n      // Count the number of consecutive words in the input which have no more than a single\n      // zero-byte.  We look for at least two zeros because that's the point where our compression\n      // scheme becomes a net win.\n      // TODO(perf):  Maybe look for three zeros?  Compressing a two-zero word is a loss if the\n      //   following word has no zeros.\n      const uint8_t* runStart = in;\n\n      const uint8_t* limit = inEnd;\n      if ((size_t)(limit - in) > 255 * sizeof(word)) {\n        limit = in + 255 * sizeof(word);\n      }\n\n      while (in < limit) {\n        // Check eight input bytes for zeros.\n        uint c = *in++ == 0;\n        c += *in++ == 0;\n        c += *in++ == 0;\n        c += *in++ == 0;\n        c += *in++ == 0;\n        c += *in++ == 0;\n        c += *in++ == 0;\n        c += *in++ == 0;\n\n        if (c >= 2) {\n          // Un-read the word with multiple zeros, since we'll want to compress that one.\n          in -= 8;\n          break;\n        }\n      }\n\n      // Write the count.\n      uint count = in - runStart;\n      *out++ = count / sizeof(word);\n\n      if (count <= reinterpret_cast<uint8_t*>(buffer.end()) - out) {\n        // There's enough space to memcpy.\n        memcpy(out, runStart, count);\n        out += count;\n      } else {\n        // Input overruns the output buffer.  We'll give it to the output stream in one chunk\n        // and let it decide what to do.\n        inner.write(buffer.begin(), reinterpret_cast<byte*>(out) - buffer.begin());\n        inner.write(runStart, in - runStart);\n        buffer = inner.getWriteBuffer();\n        out = reinterpret_cast<uint8_t*>(buffer.begin());\n      }\n    }\n  }\n\n  // Write whatever is left.\n  inner.write(buffer.begin(), reinterpret_cast<byte*>(out) - buffer.begin());\n}",
    "includes": [
      "#include <vector>",
      "#include \"layout.h\"",
      "#include <kj/debug.h>",
      "#include \"serialize-packed.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inner.write",
          "args": [
            "buffer.begin()",
            "reinterpret_cast<byte*>(out) - buffer.begin()"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FragmentingOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async-test.c++",
          "lines": "42-50",
          "snippet": "void write(const void* buffer, size_t size) override {\n    while (size > 0) {\n      usleep(5000);\n      size_t n = rand() % size + 1;\n      inner.write(buffer, n);\n      buffer = reinterpret_cast<const byte*>(buffer) + n;\n      size -= n;\n    }\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"test-util.h\"",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <kj/thread.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"test-util.h\"\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"serialize-async.h\"\n\nFragmentingOutputStream {\n  void write(const void* buffer, size_t size) override {\n      while (size > 0) {\n        usleep(5000);\n        size_t n = rand() % size + 1;\n        inner.write(buffer, n);\n        buffer = reinterpret_cast<const byte*>(buffer) + n;\n        size -= n;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer.begin",
          "args": [],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "out"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<uint8_t*>",
          "args": [
            "buffer.begin()"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inner.getWriteBuffer",
          "args": [],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "out"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "out",
            "runStart",
            "count"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<uint8_t*>",
          "args": [
            "buffer.end()"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer.end",
          "args": [],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const uint8_t*>",
          "args": [
            "inWord"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const uint64_t*>",
          "args": [
            "in"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const uint64_t*>",
          "args": [
            "inEnd"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const uint64_t*>",
          "args": [
            "in"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "7"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "6"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "5"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "4"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "3"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "2"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "1"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "0"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<uint8_t*>",
          "args": [
            "buffer.begin()"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "slowBuffer",
            "sizeof(slowBuffer)"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<uint8_t*>",
          "args": [
            "buffer.begin()"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<uint8_t*>",
          "args": [
            "buffer.end()"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const uint8_t*>",
          "args": [
            "src"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const uint8_t*>",
          "args": [
            "src"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<uint8_t*>",
          "args": [
            "buffer.begin()"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inner.getWriteBuffer",
          "args": [],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"layout.h\"\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nvoid PackedOutputStream::write(const void* src, size_t size) {\n  kj::ArrayPtr<byte> buffer = inner.getWriteBuffer();\n  byte slowBuffer[20];\n\n  uint8_t* __restrict__ out = reinterpret_cast<uint8_t*>(buffer.begin());\n\n  const uint8_t* __restrict__ in = reinterpret_cast<const uint8_t*>(src);\n  const uint8_t* const inEnd = reinterpret_cast<const uint8_t*>(src) + size;\n\n  while (in < inEnd) {\n    if (reinterpret_cast<uint8_t*>(buffer.end()) - out < 10) {\n      // Oops, we're out of space.  We need at least 10 bytes for the fast path, since we don't\n      // bounds-check on every byte.\n\n      // Write what we have so far.\n      inner.write(buffer.begin(), out - reinterpret_cast<uint8_t*>(buffer.begin()));\n\n      // Use a slow buffer into which we'll encode 10 to 20 bytes.  This should get us past the\n      // output stream's buffer boundary.\n      buffer = kj::arrayPtr(slowBuffer, sizeof(slowBuffer));\n      out = reinterpret_cast<uint8_t*>(buffer.begin());\n    }\n\n    uint8_t* tagPos = out++;\n\n#define HANDLE_BYTE(n) \\\n    uint8_t bit##n = *in != 0; \\\n    *out = *in; \\\n    out += bit##n; /* out only advances if the byte was non-zero */ \\\n    ++in\n\n    HANDLE_BYTE(0);\n    HANDLE_BYTE(1);\n    HANDLE_BYTE(2);\n    HANDLE_BYTE(3);\n    HANDLE_BYTE(4);\n    HANDLE_BYTE(5);\n    HANDLE_BYTE(6);\n    HANDLE_BYTE(7);\n#undef HANDLE_BYTE\n\n    uint8_t tag = (bit0 << 0) | (bit1 << 1) | (bit2 << 2) | (bit3 << 3)\n                | (bit4 << 4) | (bit5 << 5) | (bit6 << 6) | (bit7 << 7);\n    *tagPos = tag;\n\n    if (tag == 0) {\n      // An all-zero word is followed by a count of consecutive zero words (not including the\n      // first one).\n\n      // We can check a whole word at a time.\n      const uint64_t* inWord = reinterpret_cast<const uint64_t*>(in);\n\n      // The count must fit it 1 byte, so limit to 255 words.\n      const uint64_t* limit = reinterpret_cast<const uint64_t*>(inEnd);\n      if (limit - inWord > 255) {\n        limit = inWord + 255;\n      }\n\n      while (inWord < limit && *inWord == 0) {\n        ++inWord;\n      }\n\n      // Write the count.\n      *out++ = inWord - reinterpret_cast<const uint64_t*>(in);\n\n      // Advance input.\n      in = reinterpret_cast<const uint8_t*>(inWord);\n\n    } else if (tag == 0xffu) {\n      // An all-nonzero word is followed by a count of consecutive uncompressed words, followed\n      // by the uncompressed words themselves.\n\n      // Count the number of consecutive words in the input which have no more than a single\n      // zero-byte.  We look for at least two zeros because that's the point where our compression\n      // scheme becomes a net win.\n      // TODO(perf):  Maybe look for three zeros?  Compressing a two-zero word is a loss if the\n      //   following word has no zeros.\n      const uint8_t* runStart = in;\n\n      const uint8_t* limit = inEnd;\n      if ((size_t)(limit - in) > 255 * sizeof(word)) {\n        limit = in + 255 * sizeof(word);\n      }\n\n      while (in < limit) {\n        // Check eight input bytes for zeros.\n        uint c = *in++ == 0;\n        c += *in++ == 0;\n        c += *in++ == 0;\n        c += *in++ == 0;\n        c += *in++ == 0;\n        c += *in++ == 0;\n        c += *in++ == 0;\n        c += *in++ == 0;\n\n        if (c >= 2) {\n          // Un-read the word with multiple zeros, since we'll want to compress that one.\n          in -= 8;\n          break;\n        }\n      }\n\n      // Write the count.\n      uint count = in - runStart;\n      *out++ = count / sizeof(word);\n\n      if (count <= reinterpret_cast<uint8_t*>(buffer.end()) - out) {\n        // There's enough space to memcpy.\n        memcpy(out, runStart, count);\n        out += count;\n      } else {\n        // Input overruns the output buffer.  We'll give it to the output stream in one chunk\n        // and let it decide what to do.\n        inner.write(buffer.begin(), reinterpret_cast<byte*>(out) - buffer.begin());\n        inner.write(runStart, in - runStart);\n        buffer = inner.getWriteBuffer();\n        out = reinterpret_cast<uint8_t*>(buffer.begin());\n      }\n    }\n  }\n\n  // Write whatever is left.\n  inner.write(buffer.begin(), reinterpret_cast<byte*>(out) - buffer.begin());\n}"
  },
  {
    "function_name": "PackedOutputStream::~PackedOutputStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed.c++",
    "lines": "303-303",
    "snippet": "PackedOutputStream::~PackedOutputStream() noexcept(false) {}",
    "includes": [
      "#include <vector>",
      "#include \"layout.h\"",
      "#include <kj/debug.h>",
      "#include \"serialize-packed.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <vector>\n#include \"layout.h\"\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nPackedOutputStream::~PackedOutputStream() noexcept(false) {}"
  },
  {
    "function_name": "PackedOutputStream::PackedOutputStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed.c++",
    "lines": "301-302",
    "snippet": "PackedOutputStream::PackedOutputStream(kj::BufferedOutputStream& inner)\n    : inner(inner) {}",
    "includes": [
      "#include <vector>",
      "#include \"layout.h\"",
      "#include <kj/debug.h>",
      "#include \"serialize-packed.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <vector>\n#include \"layout.h\"\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nPackedOutputStream::PackedOutputStream(kj::BufferedOutputStream& inner)\n    : inner(inner) {}"
  },
  {
    "function_name": "PackedInputStream::skip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed.c++",
    "lines": "183-297",
    "snippet": "void PackedInputStream::skip(size_t bytes) {\n  // We can't just read into buffers because buffers must end on block boundaries.\n\n  if (bytes == 0) {\n    return;\n  }\n\n  KJ_DREQUIRE(bytes % sizeof(word) == 0, \"PackedInputStream reads must be word-aligned.\");\n\n  kj::ArrayPtr<const byte> buffer = inner.getReadBuffer();\n  const uint8_t* __restrict__ in = reinterpret_cast<const uint8_t*>(buffer.begin());\n\n#define REFRESH_BUFFER() \\\n  inner.skip(buffer.size()); \\\n  buffer = inner.getReadBuffer(); \\\n  KJ_REQUIRE(buffer.size() > 0, \"Premature end of packed input.\") { return; } \\\n  in = reinterpret_cast<const uint8_t*>(buffer.begin())\n\n  for (;;) {\n    uint8_t tag;\n\n    if (BUFFER_REMAINING < 10) {\n      if (BUFFER_REMAINING == 0) {\n        REFRESH_BUFFER();\n        continue;\n      }\n\n      // We have at least 1, but not 10, bytes available.  We need to read slowly, doing a bounds\n      // check on each byte.\n\n      tag = *in++;\n\n      for (uint i = 0; i < 8; i++) {\n        if (tag & (1u << i)) {\n          if (BUFFER_REMAINING == 0) {\n            REFRESH_BUFFER();\n          }\n          in++;\n        }\n      }\n      bytes -= 8;\n\n      if (BUFFER_REMAINING == 0 && (tag == 0 || tag == 0xffu)) {\n        REFRESH_BUFFER();\n      }\n    } else {\n      tag = *in++;\n\n#define HANDLE_BYTE(n) \\\n      in += (tag & (1u << n)) != 0\n\n      HANDLE_BYTE(0);\n      HANDLE_BYTE(1);\n      HANDLE_BYTE(2);\n      HANDLE_BYTE(3);\n      HANDLE_BYTE(4);\n      HANDLE_BYTE(5);\n      HANDLE_BYTE(6);\n      HANDLE_BYTE(7);\n#undef HANDLE_BYTE\n\n      bytes -= 8;\n    }\n\n    if (tag == 0) {\n      KJ_DASSERT(BUFFER_REMAINING > 0, \"Should always have non-empty buffer here.\");\n\n      uint runLength = *in++ * sizeof(word);\n\n      KJ_REQUIRE(runLength <= bytes, \"Packed input did not end cleanly on a segment boundary.\") {\n        return;\n      }\n\n      bytes -= runLength;\n\n    } else if (tag == 0xffu) {\n      KJ_DASSERT(BUFFER_REMAINING > 0, \"Should always have non-empty buffer here.\");\n\n      uint runLength = *in++ * sizeof(word);\n\n      KJ_REQUIRE(runLength <= bytes, \"Packed input did not end cleanly on a segment boundary.\") {\n        return;\n      }\n\n      bytes -= runLength;\n\n      uint inRemaining = BUFFER_REMAINING;\n      if (inRemaining > runLength) {\n        // Fast path.\n        in += runLength;\n      } else {\n        // Forward skip to the underlying stream.\n        runLength -= inRemaining;\n        inner.skip(buffer.size() + runLength);\n\n        if (bytes == 0) {\n          return;\n        } else {\n          buffer = inner.getReadBuffer();\n          in = reinterpret_cast<const uint8_t*>(buffer.begin());\n\n          // Skip the bounds check below since we just did the same check above.\n          continue;\n        }\n      }\n    }\n\n    if (bytes == 0) {\n      inner.skip(in - reinterpret_cast<const uint8_t*>(buffer.begin()));\n      return;\n    }\n  }\n\n  KJ_FAIL_ASSERT(\"Can't get here.\");\n}",
    "includes": [
      "#include <vector>",
      "#include \"layout.h\"",
      "#include <kj/debug.h>",
      "#include \"serialize-packed.h\""
    ],
    "macros_used": [
      "#define BUFFER_REMAINING ((size_t)(BUFFER_END - in))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Can't get here.\""
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inner.skip",
          "args": [
            "in - reinterpret_cast<const uint8_t*>(buffer.begin())"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "skip",
          "container": "TestPipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed-test.c++",
          "lines": "68-71",
          "snippet": "void skip(size_t bytes) override {\n    KJ_ASSERT(bytes <= data.size() - readPos, \"Overran end of stream.\");\n    readPos += bytes;\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <stdlib.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"serialize-packed.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <stdlib.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nTestPipe {\n  void skip(size_t bytes) override {\n      KJ_ASSERT(bytes <= data.size() - readPos, \"Overran end of stream.\");\n      readPos += bytes;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const uint8_t*>",
          "args": [
            "buffer.begin()"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer.begin",
          "args": [],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const uint8_t*>",
          "args": [
            "buffer.begin()"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inner.getReadBuffer",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer.size",
          "args": [],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "runLength <= bytes",
            "\"Packed input did not end cleanly on a segment boundary.\""
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "BUFFER_REMAINING > 0",
            "\"Should always have non-empty buffer here.\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "runLength <= bytes",
            "\"Packed input did not end cleanly on a segment boundary.\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "BUFFER_REMAINING > 0",
            "\"Should always have non-empty buffer here.\""
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "7"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "6"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "5"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "4"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "3"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "2"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "1"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "0"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REFRESH_BUFFER",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REFRESH_BUFFER",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REFRESH_BUFFER",
          "args": [],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const uint8_t*>",
          "args": [
            "buffer.begin()"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inner.getReadBuffer",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "bytes % sizeof(word) == 0",
            "\"PackedInputStream reads must be word-aligned.\""
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"layout.h\"\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\n#define BUFFER_REMAINING ((size_t)(BUFFER_END - in))\n\nvoid PackedInputStream::skip(size_t bytes) {\n  // We can't just read into buffers because buffers must end on block boundaries.\n\n  if (bytes == 0) {\n    return;\n  }\n\n  KJ_DREQUIRE(bytes % sizeof(word) == 0, \"PackedInputStream reads must be word-aligned.\");\n\n  kj::ArrayPtr<const byte> buffer = inner.getReadBuffer();\n  const uint8_t* __restrict__ in = reinterpret_cast<const uint8_t*>(buffer.begin());\n\n#define REFRESH_BUFFER() \\\n  inner.skip(buffer.size()); \\\n  buffer = inner.getReadBuffer(); \\\n  KJ_REQUIRE(buffer.size() > 0, \"Premature end of packed input.\") { return; } \\\n  in = reinterpret_cast<const uint8_t*>(buffer.begin())\n\n  for (;;) {\n    uint8_t tag;\n\n    if (BUFFER_REMAINING < 10) {\n      if (BUFFER_REMAINING == 0) {\n        REFRESH_BUFFER();\n        continue;\n      }\n\n      // We have at least 1, but not 10, bytes available.  We need to read slowly, doing a bounds\n      // check on each byte.\n\n      tag = *in++;\n\n      for (uint i = 0; i < 8; i++) {\n        if (tag & (1u << i)) {\n          if (BUFFER_REMAINING == 0) {\n            REFRESH_BUFFER();\n          }\n          in++;\n        }\n      }\n      bytes -= 8;\n\n      if (BUFFER_REMAINING == 0 && (tag == 0 || tag == 0xffu)) {\n        REFRESH_BUFFER();\n      }\n    } else {\n      tag = *in++;\n\n#define HANDLE_BYTE(n) \\\n      in += (tag & (1u << n)) != 0\n\n      HANDLE_BYTE(0);\n      HANDLE_BYTE(1);\n      HANDLE_BYTE(2);\n      HANDLE_BYTE(3);\n      HANDLE_BYTE(4);\n      HANDLE_BYTE(5);\n      HANDLE_BYTE(6);\n      HANDLE_BYTE(7);\n#undef HANDLE_BYTE\n\n      bytes -= 8;\n    }\n\n    if (tag == 0) {\n      KJ_DASSERT(BUFFER_REMAINING > 0, \"Should always have non-empty buffer here.\");\n\n      uint runLength = *in++ * sizeof(word);\n\n      KJ_REQUIRE(runLength <= bytes, \"Packed input did not end cleanly on a segment boundary.\") {\n        return;\n      }\n\n      bytes -= runLength;\n\n    } else if (tag == 0xffu) {\n      KJ_DASSERT(BUFFER_REMAINING > 0, \"Should always have non-empty buffer here.\");\n\n      uint runLength = *in++ * sizeof(word);\n\n      KJ_REQUIRE(runLength <= bytes, \"Packed input did not end cleanly on a segment boundary.\") {\n        return;\n      }\n\n      bytes -= runLength;\n\n      uint inRemaining = BUFFER_REMAINING;\n      if (inRemaining > runLength) {\n        // Fast path.\n        in += runLength;\n      } else {\n        // Forward skip to the underlying stream.\n        runLength -= inRemaining;\n        inner.skip(buffer.size() + runLength);\n\n        if (bytes == 0) {\n          return;\n        } else {\n          buffer = inner.getReadBuffer();\n          in = reinterpret_cast<const uint8_t*>(buffer.begin());\n\n          // Skip the bounds check below since we just did the same check above.\n          continue;\n        }\n      }\n    }\n\n    if (bytes == 0) {\n      inner.skip(in - reinterpret_cast<const uint8_t*>(buffer.begin()));\n      return;\n    }\n  }\n\n  KJ_FAIL_ASSERT(\"Can't get here.\");\n}"
  },
  {
    "function_name": "PackedInputStream::tryRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed.c++",
    "lines": "34-181",
    "snippet": "size_t PackedInputStream::tryRead(void* dst, size_t minBytes, size_t maxBytes) {\n  if (maxBytes == 0) {\n    return 0;\n  }\n\n  KJ_DREQUIRE(minBytes % sizeof(word) == 0, \"PackedInputStream reads must be word-aligned.\");\n  KJ_DREQUIRE(maxBytes % sizeof(word) == 0, \"PackedInputStream reads must be word-aligned.\");\n\n  uint8_t* __restrict__ out = reinterpret_cast<uint8_t*>(dst);\n  uint8_t* const outEnd = reinterpret_cast<uint8_t*>(dst) + maxBytes;\n  uint8_t* const outMin = reinterpret_cast<uint8_t*>(dst) + minBytes;\n\n  kj::ArrayPtr<const byte> buffer = inner.getReadBuffer();\n  if (buffer.size() == 0) {\n    return 0;\n  }\n  const uint8_t* __restrict__ in = reinterpret_cast<const uint8_t*>(buffer.begin());\n\n#define REFRESH_BUFFER() \\\n  inner.skip(buffer.size()); \\\n  buffer = inner.getReadBuffer(); \\\n  KJ_REQUIRE(buffer.size() > 0, \"Premature end of packed input.\") { \\\n    return out - reinterpret_cast<uint8_t*>(dst); \\\n  } \\\n  in = reinterpret_cast<const uint8_t*>(buffer.begin())\n\n#define BUFFER_END (reinterpret_cast<const uint8_t*>(buffer.end()))\n#define BUFFER_REMAINING ((size_t)(BUFFER_END - in))\n\n  for (;;) {\n    uint8_t tag;\n\n    KJ_DASSERT((out - reinterpret_cast<uint8_t*>(dst)) % sizeof(word) == 0,\n           \"Output pointer should always be aligned here.\");\n\n    if (BUFFER_REMAINING < 10) {\n      if (out >= outMin) {\n        // We read at least the minimum amount, so go ahead and return.\n        inner.skip(in - reinterpret_cast<const uint8_t*>(buffer.begin()));\n        return out - reinterpret_cast<uint8_t*>(dst);\n      }\n\n      if (BUFFER_REMAINING == 0) {\n        REFRESH_BUFFER();\n        continue;\n      }\n\n      // We have at least 1, but not 10, bytes available.  We need to read slowly, doing a bounds\n      // check on each byte.\n\n      tag = *in++;\n\n      for (uint i = 0; i < 8; i++) {\n        if (tag & (1u << i)) {\n          if (BUFFER_REMAINING == 0) {\n            REFRESH_BUFFER();\n          }\n          *out++ = *in++;\n        } else {\n          *out++ = 0;\n        }\n      }\n\n      if (BUFFER_REMAINING == 0 && (tag == 0 || tag == 0xffu)) {\n        REFRESH_BUFFER();\n      }\n    } else {\n      tag = *in++;\n\n#define HANDLE_BYTE(n) \\\n      { \\\n         bool isNonzero = (tag & (1u << n)) != 0; \\\n         *out++ = *in & (-(int8_t)isNonzero); \\\n         in += isNonzero; \\\n      }\n\n      HANDLE_BYTE(0);\n      HANDLE_BYTE(1);\n      HANDLE_BYTE(2);\n      HANDLE_BYTE(3);\n      HANDLE_BYTE(4);\n      HANDLE_BYTE(5);\n      HANDLE_BYTE(6);\n      HANDLE_BYTE(7);\n#undef HANDLE_BYTE\n    }\n\n    if (tag == 0) {\n      KJ_DASSERT(BUFFER_REMAINING > 0, \"Should always have non-empty buffer here.\");\n\n      uint runLength = *in++ * sizeof(word);\n\n      KJ_REQUIRE(runLength <= outEnd - out,\n                 \"Packed input did not end cleanly on a segment boundary.\") {\n        return out - reinterpret_cast<uint8_t*>(dst);\n      }\n      memset(out, 0, runLength);\n      out += runLength;\n\n    } else if (tag == 0xffu) {\n      KJ_DASSERT(BUFFER_REMAINING > 0, \"Should always have non-empty buffer here.\");\n\n      uint runLength = *in++ * sizeof(word);\n\n      KJ_REQUIRE(runLength <= outEnd - out,\n                 \"Packed input did not end cleanly on a segment boundary.\") {\n        return out - reinterpret_cast<uint8_t*>(dst);\n      }\n\n      uint inRemaining = BUFFER_REMAINING;\n      if (inRemaining >= runLength) {\n        // Fast path.\n        memcpy(out, in, runLength);\n        out += runLength;\n        in += runLength;\n      } else {\n        // Copy over the first buffer, then do one big read for the rest.\n        memcpy(out, in, inRemaining);\n        out += inRemaining;\n        runLength -= inRemaining;\n\n        inner.skip(buffer.size());\n        inner.read(out, runLength);\n        out += runLength;\n\n        if (out == outEnd) {\n          return maxBytes;\n        } else {\n          buffer = inner.getReadBuffer();\n          in = reinterpret_cast<const uint8_t*>(buffer.begin());\n\n          // Skip the bounds check below since we just did the same check above.\n          continue;\n        }\n      }\n    }\n\n    if (out == outEnd) {\n      inner.skip(in - reinterpret_cast<const uint8_t*>(buffer.begin()));\n      return maxBytes;\n    }\n  }\n\n  KJ_FAIL_ASSERT(\"Can't get here.\");\n  return 0;  // GCC knows KJ_FAIL_ASSERT doesn't return, but Eclipse CDT still warns...\n\n#undef REFRESH_BUFFER\n}",
    "includes": [
      "#include <vector>",
      "#include \"layout.h\"",
      "#include <kj/debug.h>",
      "#include \"serialize-packed.h\""
    ],
    "macros_used": [
      "#define BUFFER_REMAINING ((size_t)(BUFFER_END - in))",
      "#define BUFFER_END (reinterpret_cast<const uint8_t*>(buffer.end()))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Can't get here.\""
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inner.skip",
          "args": [
            "in - reinterpret_cast<const uint8_t*>(buffer.begin())"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "skip",
          "container": "TestPipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed-test.c++",
          "lines": "68-71",
          "snippet": "void skip(size_t bytes) override {\n    KJ_ASSERT(bytes <= data.size() - readPos, \"Overran end of stream.\");\n    readPos += bytes;\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <stdlib.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"serialize-packed.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <stdlib.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nTestPipe {\n  void skip(size_t bytes) override {\n      KJ_ASSERT(bytes <= data.size() - readPos, \"Overran end of stream.\");\n      readPos += bytes;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const uint8_t*>",
          "args": [
            "buffer.begin()"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer.begin",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const uint8_t*>",
          "args": [
            "buffer.begin()"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inner.getReadBuffer",
          "args": [],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inner.read",
          "args": [
            "out",
            "runLength"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "SnappyCompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "149-159",
          "snippet": "static void read(int* input, google::protobuf::MessageLite* message) {\n    uint32_t size;\n    readAll(*input, &size, sizeof(size));\n    readAll(*input, scratch, size);\n\n    size_t uncompressedSize;\n    GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n    GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n\n    GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSnappyCompressed {\n  static void read(int* input, google::protobuf::MessageLite* message) {\n      uint32_t size;\n      readAll(*input, &size, sizeof(size));\n      readAll(*input, scratch, size);\n  \n      size_t uncompressedSize;\n      GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n      GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n  \n      GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer.size",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "out",
            "in",
            "inRemaining"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "out",
            "in",
            "runLength"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<uint8_t*>",
          "args": [
            "dst"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "runLength <= outEnd - out",
            "\"Packed input did not end cleanly on a segment boundary.\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "BUFFER_REMAINING > 0",
            "\"Should always have non-empty buffer here.\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "out",
            "0",
            "runLength"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<uint8_t*>",
          "args": [
            "dst"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "runLength <= outEnd - out",
            "\"Packed input did not end cleanly on a segment boundary.\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "BUFFER_REMAINING > 0",
            "\"Should always have non-empty buffer here.\""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "7"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "6"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "5"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "4"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "3"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "2"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "1"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HANDLE_BYTE",
          "args": [
            "0"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REFRESH_BUFFER",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REFRESH_BUFFER",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REFRESH_BUFFER",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<uint8_t*>",
          "args": [
            "dst"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const uint8_t*>",
          "args": [
            "buffer.begin()"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "(out - reinterpret_cast<uint8_t*>(dst)) % sizeof(word) == 0",
            "\"Output pointer should always be aligned here.\""
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<uint8_t*>",
          "args": [
            "dst"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const uint8_t*>",
          "args": [
            "buffer.begin()"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inner.getReadBuffer",
          "args": [],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<uint8_t*>",
          "args": [
            "dst"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<uint8_t*>",
          "args": [
            "dst"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<uint8_t*>",
          "args": [
            "dst"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "maxBytes % sizeof(word) == 0",
            "\"PackedInputStream reads must be word-aligned.\""
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "minBytes % sizeof(word) == 0",
            "\"PackedInputStream reads must be word-aligned.\""
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"layout.h\"\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\n#define BUFFER_REMAINING ((size_t)(BUFFER_END - in))\n#define BUFFER_END (reinterpret_cast<const uint8_t*>(buffer.end()))\n\nsize_t PackedInputStream::tryRead(void* dst, size_t minBytes, size_t maxBytes) {\n  if (maxBytes == 0) {\n    return 0;\n  }\n\n  KJ_DREQUIRE(minBytes % sizeof(word) == 0, \"PackedInputStream reads must be word-aligned.\");\n  KJ_DREQUIRE(maxBytes % sizeof(word) == 0, \"PackedInputStream reads must be word-aligned.\");\n\n  uint8_t* __restrict__ out = reinterpret_cast<uint8_t*>(dst);\n  uint8_t* const outEnd = reinterpret_cast<uint8_t*>(dst) + maxBytes;\n  uint8_t* const outMin = reinterpret_cast<uint8_t*>(dst) + minBytes;\n\n  kj::ArrayPtr<const byte> buffer = inner.getReadBuffer();\n  if (buffer.size() == 0) {\n    return 0;\n  }\n  const uint8_t* __restrict__ in = reinterpret_cast<const uint8_t*>(buffer.begin());\n\n#define REFRESH_BUFFER() \\\n  inner.skip(buffer.size()); \\\n  buffer = inner.getReadBuffer(); \\\n  KJ_REQUIRE(buffer.size() > 0, \"Premature end of packed input.\") { \\\n    return out - reinterpret_cast<uint8_t*>(dst); \\\n  } \\\n  in = reinterpret_cast<const uint8_t*>(buffer.begin())\n\n#define BUFFER_END (reinterpret_cast<const uint8_t*>(buffer.end()))\n#define BUFFER_REMAINING ((size_t)(BUFFER_END - in))\n\n  for (;;) {\n    uint8_t tag;\n\n    KJ_DASSERT((out - reinterpret_cast<uint8_t*>(dst)) % sizeof(word) == 0,\n           \"Output pointer should always be aligned here.\");\n\n    if (BUFFER_REMAINING < 10) {\n      if (out >= outMin) {\n        // We read at least the minimum amount, so go ahead and return.\n        inner.skip(in - reinterpret_cast<const uint8_t*>(buffer.begin()));\n        return out - reinterpret_cast<uint8_t*>(dst);\n      }\n\n      if (BUFFER_REMAINING == 0) {\n        REFRESH_BUFFER();\n        continue;\n      }\n\n      // We have at least 1, but not 10, bytes available.  We need to read slowly, doing a bounds\n      // check on each byte.\n\n      tag = *in++;\n\n      for (uint i = 0; i < 8; i++) {\n        if (tag & (1u << i)) {\n          if (BUFFER_REMAINING == 0) {\n            REFRESH_BUFFER();\n          }\n          *out++ = *in++;\n        } else {\n          *out++ = 0;\n        }\n      }\n\n      if (BUFFER_REMAINING == 0 && (tag == 0 || tag == 0xffu)) {\n        REFRESH_BUFFER();\n      }\n    } else {\n      tag = *in++;\n\n#define HANDLE_BYTE(n) \\\n      { \\\n         bool isNonzero = (tag & (1u << n)) != 0; \\\n         *out++ = *in & (-(int8_t)isNonzero); \\\n         in += isNonzero; \\\n      }\n\n      HANDLE_BYTE(0);\n      HANDLE_BYTE(1);\n      HANDLE_BYTE(2);\n      HANDLE_BYTE(3);\n      HANDLE_BYTE(4);\n      HANDLE_BYTE(5);\n      HANDLE_BYTE(6);\n      HANDLE_BYTE(7);\n#undef HANDLE_BYTE\n    }\n\n    if (tag == 0) {\n      KJ_DASSERT(BUFFER_REMAINING > 0, \"Should always have non-empty buffer here.\");\n\n      uint runLength = *in++ * sizeof(word);\n\n      KJ_REQUIRE(runLength <= outEnd - out,\n                 \"Packed input did not end cleanly on a segment boundary.\") {\n        return out - reinterpret_cast<uint8_t*>(dst);\n      }\n      memset(out, 0, runLength);\n      out += runLength;\n\n    } else if (tag == 0xffu) {\n      KJ_DASSERT(BUFFER_REMAINING > 0, \"Should always have non-empty buffer here.\");\n\n      uint runLength = *in++ * sizeof(word);\n\n      KJ_REQUIRE(runLength <= outEnd - out,\n                 \"Packed input did not end cleanly on a segment boundary.\") {\n        return out - reinterpret_cast<uint8_t*>(dst);\n      }\n\n      uint inRemaining = BUFFER_REMAINING;\n      if (inRemaining >= runLength) {\n        // Fast path.\n        memcpy(out, in, runLength);\n        out += runLength;\n        in += runLength;\n      } else {\n        // Copy over the first buffer, then do one big read for the rest.\n        memcpy(out, in, inRemaining);\n        out += inRemaining;\n        runLength -= inRemaining;\n\n        inner.skip(buffer.size());\n        inner.read(out, runLength);\n        out += runLength;\n\n        if (out == outEnd) {\n          return maxBytes;\n        } else {\n          buffer = inner.getReadBuffer();\n          in = reinterpret_cast<const uint8_t*>(buffer.begin());\n\n          // Skip the bounds check below since we just did the same check above.\n          continue;\n        }\n      }\n    }\n\n    if (out == outEnd) {\n      inner.skip(in - reinterpret_cast<const uint8_t*>(buffer.begin()));\n      return maxBytes;\n    }\n  }\n\n  KJ_FAIL_ASSERT(\"Can't get here.\");\n  return 0;  // GCC knows KJ_FAIL_ASSERT doesn't return, but Eclipse CDT still warns...\n\n#undef REFRESH_BUFFER\n}"
  },
  {
    "function_name": "PackedInputStream::~PackedInputStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed.c++",
    "lines": "32-32",
    "snippet": "PackedInputStream::~PackedInputStream() noexcept(false) {}",
    "includes": [
      "#include <vector>",
      "#include \"layout.h\"",
      "#include <kj/debug.h>",
      "#include \"serialize-packed.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <vector>\n#include \"layout.h\"\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nPackedInputStream::~PackedInputStream() noexcept(false) {}"
  },
  {
    "function_name": "PackedInputStream::PackedInputStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed.c++",
    "lines": "31-31",
    "snippet": "PackedInputStream::PackedInputStream(kj::BufferedInputStream& inner): inner(inner) {}",
    "includes": [
      "#include <vector>",
      "#include \"layout.h\"",
      "#include <kj/debug.h>",
      "#include \"serialize-packed.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <vector>\n#include \"layout.h\"\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nPackedInputStream::PackedInputStream(kj::BufferedInputStream& inner): inner(inner) {}"
  }
]