[
  {
    "function_name": "Thread::detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/thread.c++",
    "lines": "99-105",
    "snippet": "void Thread::detach() {\n  int pthreadResult = pthread_detach(*reinterpret_cast<pthread_t*>(&threadId));\n  if (pthreadResult != 0) {\n    KJ_FAIL_SYSCALL(\"pthread_detach\", pthreadResult) { break; }\n  }\n  detached = true;\n}",
    "includes": [
      "#include <signal.h>",
      "#include <pthread.h>",
      "#include <windows.h>",
      "#include \"debug.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"pthread_detach\"",
            "pthreadResult"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_detach",
          "args": [
            "*reinterpret_cast<pthread_t*>(&threadId)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<pthread_t*>",
          "args": [
            "&threadId"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <pthread.h>\n#include <windows.h>\n#include \"debug.h\"\n#include \"thread.h\"\n\nvoid Thread::detach() {\n  int pthreadResult = pthread_detach(*reinterpret_cast<pthread_t*>(&threadId));\n  if (pthreadResult != 0) {\n    KJ_FAIL_SYSCALL(\"pthread_detach\", pthreadResult) { break; }\n  }\n  detached = true;\n}"
  },
  {
    "function_name": "Thread::sendSignal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/thread.c++",
    "lines": "92-97",
    "snippet": "void Thread::sendSignal(int signo) {\n  int pthreadResult = pthread_kill(*reinterpret_cast<pthread_t*>(&threadId), signo);\n  if (pthreadResult != 0) {\n    KJ_FAIL_SYSCALL(\"pthread_kill\", pthreadResult) { break; }\n  }\n}",
    "includes": [
      "#include <signal.h>",
      "#include <pthread.h>",
      "#include <windows.h>",
      "#include \"debug.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"pthread_kill\"",
            "pthreadResult"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_kill",
          "args": [
            "*reinterpret_cast<pthread_t*>(&threadId)",
            "signo"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<pthread_t*>",
          "args": [
            "&threadId"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <pthread.h>\n#include <windows.h>\n#include \"debug.h\"\n#include \"thread.h\"\n\nvoid Thread::sendSignal(int signo) {\n  int pthreadResult = pthread_kill(*reinterpret_cast<pthread_t*>(&threadId), signo);\n  if (pthreadResult != 0) {\n    KJ_FAIL_SYSCALL(\"pthread_kill\", pthreadResult) { break; }\n  }\n}"
  },
  {
    "function_name": "Thread::~Thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/thread.c++",
    "lines": "79-90",
    "snippet": "Thread::~Thread() noexcept(false) {\n  if (!detached) {\n    int pthreadResult = pthread_join(*reinterpret_cast<pthread_t*>(&threadId), nullptr);\n    if (pthreadResult != 0) {\n      KJ_FAIL_SYSCALL(\"pthread_join\", pthreadResult) { break; }\n    }\n\n    KJ_IF_MAYBE(e, exception) {\n      kj::throwRecoverableException(kj::mv(*e));\n    }\n  }\n}",
    "includes": [
      "#include <signal.h>",
      "#include <pthread.h>",
      "#include <windows.h>",
      "#include \"debug.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::throwRecoverableException",
          "args": [
            "kj::mv(*e)"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "throwRecoverableException",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "353-355",
          "snippet": "void throwRecoverableException(kj::Exception&& exception) {\n  getExceptionCallback().onRecoverableException(kj::mv(exception));\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid throwRecoverableException(kj::Exception&& exception) {\n  getExceptionCallback().onRecoverableException(kj::mv(exception));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*e"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"pthread_join\"",
            "pthreadResult"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_join",
          "args": [
            "*reinterpret_cast<pthread_t*>(&threadId)",
            "nullptr"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<pthread_t*>",
          "args": [
            "&threadId"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <pthread.h>\n#include <windows.h>\n#include \"debug.h\"\n#include \"thread.h\"\n\nThread::~Thread() noexcept(false) {\n  if (!detached) {\n    int pthreadResult = pthread_join(*reinterpret_cast<pthread_t*>(&threadId), nullptr);\n    if (pthreadResult != 0) {\n      KJ_FAIL_SYSCALL(\"pthread_join\", pthreadResult) { break; }\n    }\n\n    KJ_IF_MAYBE(e, exception) {\n      kj::throwRecoverableException(kj::mv(*e));\n    }\n  }\n}"
  },
  {
    "function_name": "Thread::Thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/thread.c++",
    "lines": "68-77",
    "snippet": "Thread::Thread(Function<void()> func): func(kj::mv(func)) {\n  static_assert(sizeof(threadId) >= sizeof(pthread_t),\n                \"pthread_t is larger than a long long on your platform.  Please port.\");\n\n  int pthreadResult = pthread_create(reinterpret_cast<pthread_t*>(&threadId),\n                                     nullptr, &runThread, this);\n  if (pthreadResult != 0) {\n    KJ_FAIL_SYSCALL(\"pthread_create\", pthreadResult);\n  }\n}",
    "includes": [
      "#include <signal.h>",
      "#include <pthread.h>",
      "#include <windows.h>",
      "#include \"debug.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"pthread_create\"",
            "pthreadResult"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_create",
          "args": [
            "reinterpret_cast<pthread_t*>(&threadId)",
            "nullptr",
            "&runThread",
            "this"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<pthread_t*>",
          "args": [
            "&threadId"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "func"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "void",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <pthread.h>\n#include <windows.h>\n#include \"debug.h\"\n#include \"thread.h\"\n\nThread::Thread(Function<void()> func): func(kj::mv(func)) {\n  static_assert(sizeof(threadId) >= sizeof(pthread_t),\n                \"pthread_t is larger than a long long on your platform.  Please port.\");\n\n  int pthreadResult = pthread_create(reinterpret_cast<pthread_t*>(&threadId),\n                                     nullptr, &runThread, this);\n  if (pthreadResult != 0) {\n    KJ_FAIL_SYSCALL(\"pthread_create\", pthreadResult);\n  }\n}"
  },
  {
    "function_name": "Thread::runThread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/thread.c++",
    "lines": "56-64",
    "snippet": "DWORD Thread::runThread(void* ptr) {\n  Thread* thread = reinterpret_cast<Thread*>(ptr);\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n    thread->func();\n  })) {\n    thread->exception = kj::mv(*exception);\n  }\n  return 0;\n}",
    "includes": [
      "#include <signal.h>",
      "#include <pthread.h>",
      "#include <windows.h>",
      "#include \"debug.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*exception"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exception",
            "kj::runCatchingExceptions([&]() {\n    thread->func();\n  })"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() {\n    thread->func();\n  }"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread->func",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<Thread*>",
          "args": [
            "ptr"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <pthread.h>\n#include <windows.h>\n#include \"debug.h\"\n#include \"thread.h\"\n\nDWORD Thread::runThread(void* ptr) {\n  Thread* thread = reinterpret_cast<Thread*>(ptr);\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n    thread->func();\n  })) {\n    thread->exception = kj::mv(*exception);\n  }\n  return 0;\n}"
  },
  {
    "function_name": "Thread::detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/thread.c++",
    "lines": "51-54",
    "snippet": "void Thread::detach() {\n  KJ_ASSERT(CloseHandle(threadHandle));\n  detached = true;\n}",
    "includes": [
      "#include <signal.h>",
      "#include <pthread.h>",
      "#include <windows.h>",
      "#include \"debug.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "CloseHandle(threadHandle)"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CloseHandle",
          "args": [
            "threadHandle"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <pthread.h>\n#include <windows.h>\n#include \"debug.h\"\n#include \"thread.h\"\n\nvoid Thread::detach() {\n  KJ_ASSERT(CloseHandle(threadHandle));\n  detached = true;\n}"
  },
  {
    "function_name": "Thread::~Thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/thread.c++",
    "lines": "41-49",
    "snippet": "Thread::~Thread() noexcept(false) {\n  if (!detached) {\n    KJ_ASSERT(WaitForSingleObject(threadHandle, INFINITE) != WAIT_FAILED);\n\n    KJ_IF_MAYBE(e, exception) {\n      kj::throwRecoverableException(kj::mv(*e));\n    }\n  }\n}",
    "includes": [
      "#include <signal.h>",
      "#include <pthread.h>",
      "#include <windows.h>",
      "#include \"debug.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::throwRecoverableException",
          "args": [
            "kj::mv(*e)"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "throwRecoverableException",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "353-355",
          "snippet": "void throwRecoverableException(kj::Exception&& exception) {\n  getExceptionCallback().onRecoverableException(kj::mv(exception));\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid throwRecoverableException(kj::Exception&& exception) {\n  getExceptionCallback().onRecoverableException(kj::mv(exception));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*e"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "WaitForSingleObject(threadHandle, INFINITE) != WAIT_FAILED"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WaitForSingleObject",
          "args": [
            "threadHandle",
            "INFINITE"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <pthread.h>\n#include <windows.h>\n#include \"debug.h\"\n#include \"thread.h\"\n\nThread::~Thread() noexcept(false) {\n  if (!detached) {\n    KJ_ASSERT(WaitForSingleObject(threadHandle, INFINITE) != WAIT_FAILED);\n\n    KJ_IF_MAYBE(e, exception) {\n      kj::throwRecoverableException(kj::mv(*e));\n    }\n  }\n}"
  },
  {
    "function_name": "Thread::Thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/thread.c++",
    "lines": "36-39",
    "snippet": "Thread::Thread(Function<void()> func): func(kj::mv(func)) {\n  threadHandle = CreateThread(nullptr, 0, &runThread, this, 0, nullptr);\n  KJ_ASSERT(threadHandle != nullptr, \"CreateThread failed.\");\n}",
    "includes": [
      "#include <signal.h>",
      "#include <pthread.h>",
      "#include <windows.h>",
      "#include \"debug.h\"",
      "#include \"thread.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "threadHandle != nullptr",
            "\"CreateThread failed.\""
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateThread",
          "args": [
            "nullptr",
            "0",
            "&runThread",
            "this",
            "0",
            "nullptr"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "func"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "void",
          "args": [],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <pthread.h>\n#include <windows.h>\n#include \"debug.h\"\n#include \"thread.h\"\n\nThread::Thread(Function<void()> func): func(kj::mv(func)) {\n  threadHandle = CreateThread(nullptr, 0, &runThread, this, 0, nullptr);\n  KJ_ASSERT(threadHandle != nullptr, \"CreateThread failed.\");\n}"
  }
]