[
  {
    "function_name": "Request<DynamicStruct, DynamicStruct>::send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic-capability.c++",
    "lines": "73-91",
    "snippet": "RemotePromise<DynamicStruct> Request<DynamicStruct, DynamicStruct>::send() {\n  auto typelessPromise = hook->send();\n  auto resultSchemaCopy = resultSchema;\n\n  // Convert the Promise to return the correct response type.\n  // Explicitly upcast to kj::Promise to make clear that calling .then() doesn't invalidate the\n  // Pipeline part of the RemotePromise.\n  auto typedPromise = kj::implicitCast<kj::Promise<Response<AnyPointer>>&>(typelessPromise)\n      .then([=](Response<AnyPointer>&& response) -> Response<DynamicStruct> {\n        return Response<DynamicStruct>(response.getAs<DynamicStruct>(resultSchemaCopy),\n                                       kj::mv(response.hook));\n      });\n\n  // Wrap the typeless pipeline in a typed wrapper.\n  DynamicStruct::Pipeline typedPipeline(resultSchema,\n      kj::mv(kj::implicitCast<AnyPointer::Pipeline&>(typelessPromise)));\n\n  return RemotePromise<DynamicStruct>(kj::mv(typedPromise), kj::mv(typedPipeline));\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"dynamic.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RemotePromise<DynamicStruct>",
          "args": [
            "kj::mv(typedPromise)",
            "kj::mv(typedPipeline)"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "RemotePromise",
          "container": "RemotePromise",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.h",
          "lines": "53-55",
          "snippet": "inline RemotePromise(kj::Promise<Response<T>>&& promise, typename T::Pipeline&& pipeline)\n      : kj::Promise<Response<T>>(kj::mv(promise)),\n        T::Pipeline(kj::mv(pipeline)) {}",
          "includes": [
            "#include \"pointer-helpers.h\"",
            "#include \"any.h\"",
            "#include <kj/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pointer-helpers.h\"\n#include \"any.h\"\n#include <kj/async.h>\n\nRemotePromise {\n  inline RemotePromise(kj::Promise<Response<T>>&& promise, typename T::Pipeline&& pipeline)\n        : kj::Promise<Response<T>>(kj::mv(promise)),\n          T::Pipeline(kj::mv(pipeline)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "typedPipeline"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "typedPromise"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::implicitCast<kj::Promise<Response<AnyPointer>>&>",
          "args": [
            "[=](Response<AnyPointer>&& response) -> Response<DynamicStruct> {\n        return Response<DynamicStruct>(response.getAs<DynamicStruct>(resultSchemaCopy),\n                                       kj::mv(response.hook));\n      }"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Response<DynamicStruct>",
          "args": [
            "response.getAs<DynamicStruct>(resultSchemaCopy)",
            "kj::mv(response.hook)"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "LocallyRedirectedRpcResponse",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1636-1638",
          "snippet": "LocallyRedirectedRpcResponse(kj::Maybe<MessageSize> sizeHint)\n        : message(sizeHint.map([](MessageSize size) { return size.wordCount; })\n                          .orDefault(SUGGESTED_FIRST_SEGMENT_WORDS)) {}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  LocallyRedirectedRpcResponse(kj::Maybe<MessageSize> sizeHint)\n          : message(sizeHint.map([](MessageSize size) { return size.wordCount; })\n                            .orDefault(SUGGESTED_FIRST_SEGMENT_WORDS)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "response.hook"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getAs<DynamicStruct>",
          "args": [
            "resultSchemaCopy"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::implicitCast<kj::Promise<Response<AnyPointer>>&>",
          "args": [
            "typelessPromise"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook->send",
          "args": [],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"dynamic.h\"\n\nRemotePromise<DynamicStruct> Request<DynamicStruct, DynamicStruct>::send() {\n  auto typelessPromise = hook->send();\n  auto resultSchemaCopy = resultSchema;\n\n  // Convert the Promise to return the correct response type.\n  // Explicitly upcast to kj::Promise to make clear that calling .then() doesn't invalidate the\n  // Pipeline part of the RemotePromise.\n  auto typedPromise = kj::implicitCast<kj::Promise<Response<AnyPointer>>&>(typelessPromise)\n      .then([=](Response<AnyPointer>&& response) -> Response<DynamicStruct> {\n        return Response<DynamicStruct>(response.getAs<DynamicStruct>(resultSchemaCopy),\n                                       kj::mv(response.hook));\n      });\n\n  // Wrap the typeless pipeline in a typed wrapper.\n  DynamicStruct::Pipeline typedPipeline(resultSchema,\n      kj::mv(kj::implicitCast<AnyPointer::Pipeline&>(typelessPromise)));\n\n  return RemotePromise<DynamicStruct>(kj::mv(typedPromise), kj::mv(typedPipeline));\n}"
  },
  {
    "function_name": "DynamicCapability::Server::dispatchCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic-capability.c++",
    "lines": "55-70",
    "snippet": "kj::Promise<void> DynamicCapability::Server::dispatchCall(\n    uint64_t interfaceId, uint16_t methodId,\n    CallContext<AnyPointer, AnyPointer> context) {\n  KJ_IF_MAYBE(interface, schema.findSuperclass(interfaceId)) {\n    auto methods = interface->getMethods();\n    if (methodId < methods.size()) {\n      auto method = methods[methodId];\n      return call(method, CallContext<DynamicStruct, DynamicStruct>(*context.hook,\n          method.getParamType(), method.getResultType()));\n    } else {\n      return internalUnimplemented(\n          interface->getProto().getDisplayName().cStr(), interfaceId, methodId);\n    }\n  } else {\n    return internalUnimplemented(schema.getProto().getDisplayName().cStr(), interfaceId);\n  }",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"dynamic.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "internalUnimplemented",
          "args": [
            "schema.getProto().getDisplayName().cStr()",
            "interfaceId"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "Capability::Server::internalUnimplemented",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "75-87",
          "snippet": "kj::Promise<void> Capability::Server::internalUnimplemented(\n    const char* actualInterfaceName, uint64_t requestedTypeId) {\n  KJ_UNIMPLEMENTED(\"Requested interface not implemented.\", actualInterfaceName, requestedTypeId) {\n    // Recoverable exception will be caught by promise framework.\n\n    // We can't \"return kj::READY_NOW;\" inside this block because it causes a memory leak due to\n    // a bug that exists in both Clang and GCC:\n    //   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=33799\n    //   http://llvm.org/bugs/show_bug.cgi?id=12286\n    break;\n  }\n  return kj::READY_NOW;\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Promise<void> Capability::Server::internalUnimplemented(\n    const char* actualInterfaceName, uint64_t requestedTypeId) {\n  KJ_UNIMPLEMENTED(\"Requested interface not implemented.\", actualInterfaceName, requestedTypeId) {\n    // Recoverable exception will be caught by promise framework.\n\n    // We can't \"return kj::READY_NOW;\" inside this block because it causes a memory leak due to\n    // a bug that exists in both Clang and GCC:\n    //   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=33799\n    //   http://llvm.org/bugs/show_bug.cgi?id=12286\n    break;\n  }\n  return kj::READY_NOW;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schema.getProto",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "call",
          "args": [
            "method",
            "CallContext<DynamicStruct, DynamicStruct>(*context.hook,\n          method.getParamType(), method.getResultType())"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "LocallyRedirectedRpcResponse",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1636-1638",
          "snippet": "LocallyRedirectedRpcResponse(kj::Maybe<MessageSize> sizeHint)\n        : message(sizeHint.map([](MessageSize size) { return size.wordCount; })\n                          .orDefault(SUGGESTED_FIRST_SEGMENT_WORDS)) {}",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  LocallyRedirectedRpcResponse(kj::Maybe<MessageSize> sizeHint)\n          : message(sizeHint.map([](MessageSize size) { return size.wordCount; })\n                            .orDefault(SUGGESTED_FIRST_SEGMENT_WORDS)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CallContext<DynamicStruct, DynamicStruct>",
          "args": [
            "*context.hook",
            "method.getParamType()",
            "method.getResultType()"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "CallContext<DynamicStruct, DynamicStruct>::CallContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "1533-1535",
          "snippet": "inline CallContext<DynamicStruct, DynamicStruct>::CallContext(\n    CallContextHook& hook, StructSchema paramType, StructSchema resultType)\n    : hook(&hook), paramType(paramType), resultType(resultType) {}",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline CallContext<DynamicStruct, DynamicStruct>::CallContext(\n    CallContextHook& hook, StructSchema paramType, StructSchema resultType)\n    : hook(&hook), paramType(paramType), resultType(resultType) {}"
        }
      },
      {
        "call_info": {
          "callee": "method.getResultType",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getParamType",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "methods.size",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "interface->getMethods",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "interface",
            "schema.findSuperclass(interfaceId)"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "schema.findSuperclass",
          "args": [
            "interfaceId"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"dynamic.h\"\n\nkj::Promise<void> DynamicCapability::Server::dispatchCall(\n    uint64_t interfaceId, uint16_t methodId,\n    CallContext<AnyPointer, AnyPointer> context) {\n  KJ_IF_MAYBE(interface, schema.findSuperclass(interfaceId)) {\n    auto methods = interface->getMethods();\n    if (methodId < methods.size()) {\n      auto method = methods[methodId];\n      return call(method, CallContext<DynamicStruct, DynamicStruct>(*context.hook,\n          method.getParamType(), method.getResultType()));\n    } else {\n      return internalUnimplemented(\n          interface->getProto().getDisplayName().cStr(), interfaceId, methodId);\n    }\n  } else {\n    return internalUnimplemented(schema.getProto().getDisplayName().cStr(), interfaceId);\n  }"
  },
  {
    "function_name": "DynamicCapability::Client::newRequest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic-capability.c++",
    "lines": "50-53",
    "snippet": "Request<DynamicStruct, DynamicStruct> DynamicCapability::Client::newRequest(\n    kj::StringPtr methodName, kj::Maybe<MessageSize> sizeHint) {\n  return newRequest(schema.getMethodByName(methodName), sizeHint);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"dynamic.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schema.getMethodByName",
          "args": [
            "methodName"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"dynamic.h\"\n\nRequest<DynamicStruct, DynamicStruct> DynamicCapability::Client::newRequest(\n    kj::StringPtr methodName, kj::Maybe<MessageSize> sizeHint) {\n  return newRequest(schema.getMethodByName(methodName), sizeHint);\n}"
  },
  {
    "function_name": "DynamicCapability::Client::newRequest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic-capability.c++",
    "lines": "34-48",
    "snippet": "Request<DynamicStruct, DynamicStruct> DynamicCapability::Client::newRequest(\n    InterfaceSchema::Method method, kj::Maybe<MessageSize> sizeHint) {\n  auto methodInterface = method.getContainingInterface();\n\n  KJ_REQUIRE(schema.extends(methodInterface), \"Interface does not implement this method.\");\n\n  auto paramType = method.getParamType();\n  auto resultType = method.getResultType();\n\n  auto typeless = hook->newCall(\n      methodInterface.getProto().getId(), method.getIndex(), sizeHint);\n\n  return Request<DynamicStruct, DynamicStruct>(\n      typeless.getAs<DynamicStruct>(paramType), kj::mv(typeless.hook), resultType);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"dynamic.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Request<DynamicStruct, DynamicStruct>",
          "args": [
            "typeless.getAs<DynamicStruct>(paramType)",
            "kj::mv(typeless.hook)",
            "resultType"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "Request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "516-518",
          "snippet": "inline Request(DynamicStruct::Builder builder, kj::Own<RequestHook>&& hook,\n                 StructSchema resultSchema)\n      : DynamicStruct::Builder(builder), hook(kj::mv(hook)), resultSchema(resultSchema) {}",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline Request(DynamicStruct::Builder builder, kj::Own<RequestHook>&& hook,\n                 StructSchema resultSchema)\n      : DynamicStruct::Builder(builder), hook(kj::mv(hook)), resultSchema(resultSchema) {}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "typeless.hook"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeless.getAs<DynamicStruct>",
          "args": [
            "paramType"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook->newCall",
          "args": [
            "methodInterface.getProto().getId()",
            "method.getIndex()",
            "sizeHint"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "newCall",
          "container": "BrokenClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "580-583",
          "snippet": "Request<AnyPointer, AnyPointer> newCall(\n      uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) override {\n    return newBrokenRequest(kj::cp(exception), sizeHint);\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenClient {\n  Request<AnyPointer, AnyPointer> newCall(\n        uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) override {\n      return newBrokenRequest(kj::cp(exception), sizeHint);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "method.getIndex",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "getIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "487-487",
          "snippet": "inline uint getIndex() const { return ordinal; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline uint getIndex() const { return ordinal; }"
        }
      },
      {
        "call_info": {
          "callee": "methodInterface.getProto",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "method.getResultType",
          "args": [],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getParamType",
          "args": [],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "schema.extends(methodInterface)",
            "\"Interface does not implement this method.\""
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.extends",
          "args": [
            "methodInterface"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getContainingInterface",
          "args": [],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "getContainingInterface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "484-484",
          "snippet": "inline InterfaceSchema getContainingInterface() const { return parent; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline InterfaceSchema getContainingInterface() const { return parent; }"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"dynamic.h\"\n\nRequest<DynamicStruct, DynamicStruct> DynamicCapability::Client::newRequest(\n    InterfaceSchema::Method method, kj::Maybe<MessageSize> sizeHint) {\n  auto methodInterface = method.getContainingInterface();\n\n  KJ_REQUIRE(schema.extends(methodInterface), \"Interface does not implement this method.\");\n\n  auto paramType = method.getParamType();\n  auto resultType = method.getResultType();\n\n  auto typeless = hook->newCall(\n      methodInterface.getProto().getId(), method.getIndex(), sizeHint);\n\n  return Request<DynamicStruct, DynamicStruct>(\n      typeless.getAs<DynamicStruct>(paramType), kj::mv(typeless.hook), resultType);\n}"
  },
  {
    "function_name": "DynamicCapability::Client::upcast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic-capability.c++",
    "lines": "29-32",
    "snippet": "DynamicCapability::Client DynamicCapability::Client::upcast(InterfaceSchema requestedSchema) {\n  KJ_REQUIRE(schema.extends(requestedSchema), \"Can't upcast to non-superclass.\") {}\n  return DynamicCapability::Client(requestedSchema, hook->addRef());\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"dynamic.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DynamicCapability::Client",
          "args": [
            "requestedSchema",
            "hook->addRef()"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "Client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "476-477",
          "snippet": "Client(InterfaceSchema schema, kj::Own<ClientHook>&& hook)\n      : Capability::Client(kj::mv(hook)), schema(schema) {}",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\nClient(InterfaceSchema schema, kj::Own<ClientHook>&& hook)\n      : Capability::Client(kj::mv(hook)), schema(schema) {}"
        }
      },
      {
        "call_info": {
          "callee": "hook->addRef",
          "args": [],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": "BrokenClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "598-600",
          "snippet": "kj::Own<ClientHook> addRef() override {\n    return kj::addRef(*this);\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenClient {\n  kj::Own<ClientHook> addRef() override {\n      return kj::addRef(*this);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "schema.extends(requestedSchema)",
            "\"Can't upcast to non-superclass.\""
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.extends",
          "args": [
            "requestedSchema"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"dynamic.h\"\n\nDynamicCapability::Client DynamicCapability::Client::upcast(InterfaceSchema requestedSchema) {\n  KJ_REQUIRE(schema.extends(requestedSchema), \"Can't upcast to non-superclass.\") {}\n  return DynamicCapability::Client(requestedSchema, hook->addRef());\n}"
  }
]