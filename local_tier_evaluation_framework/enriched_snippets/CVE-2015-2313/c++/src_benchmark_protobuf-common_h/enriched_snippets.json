[
  {
    "function_name": "passByBytes",
    "container": "BenchmarkMethods",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
    "lines": "299-339",
    "snippet": "static uint64_t passByBytes(uint64_t iters) {\n    uint64_t throughput = 0;\n\n    REUSABLE(Request) reusableClientRequest;\n    REUSABLE(Request) reusableServerRequest;\n    REUSABLE(Response) reusableServerResponse;\n    REUSABLE(Response) reusableClientResponse;\n    typename ReuseStrategy::ReusableString reusableRequestString, reusableResponseString;\n\n    for (; iters > 0; --iters) {\n      SINGLE_USE(Request) clientRequest(reusableClientRequest);\n      typename TestCase::Expectation expected = TestCase::setupRequest(&clientRequest);\n\n      typename ReuseStrategy::SingleUseString requestString(reusableRequestString);\n      clientRequest.SerializePartialToString(&requestString);\n      throughput += requestString.size();\n      ReuseStrategy::doneWith(clientRequest);\n\n      SINGLE_USE(Request) serverRequest(reusableServerRequest);\n      serverRequest.ParsePartialFromString(requestString);\n\n      SINGLE_USE(Response) serverResponse(reusableServerResponse);\n      TestCase::handleRequest(serverRequest, &serverResponse);\n      ReuseStrategy::doneWith(serverRequest);\n\n      typename ReuseStrategy::SingleUseString responseString(reusableResponseString);\n      serverResponse.SerializePartialToString(&responseString);\n      throughput += responseString.size();\n      ReuseStrategy::doneWith(serverResponse);\n\n      SINGLE_USE(Response) clientResponse(reusableClientResponse);\n      clientResponse.ParsePartialFromString(responseString);\n\n      if (!TestCase::checkResponse(clientResponse, expected)) {\n        throw std::logic_error(\"Incorrect response.\");\n      }\n      ReuseStrategy::doneWith(clientResponse);\n    }\n\n    return throughput;\n  }",
    "includes": [
      "#include <snappy/snappy-sinksource.h>",
      "#include <snappy/snappy.h>",
      "#include <thread>",
      "#include <google/protobuf/io/coded_stream.h>",
      "#include <google/protobuf/io/zero_copy_stream_impl.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReuseStrategy::doneWith",
          "args": [
            "clientResponse"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "doneWith",
          "container": "ReusableMessages",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "68-70",
          "snippet": "static inline void doneWith(MessageType& message) {\n    message.Clear();\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nReusableMessages {\n  static inline void doneWith(MessageType& message) {\n      message.Clear();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::logic_error",
          "args": [
            "\"Incorrect response.\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestCase::checkResponse",
          "args": [
            "clientResponse",
            "expected"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "checkResponse",
          "container": "CatRankTestCase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-catrank.c++",
          "lines": "119-130",
          "snippet": "static bool checkResponse(SearchResultList::Reader response, int expectedGoodCount) {\n    int goodCount = 0;\n    for (auto result: response.getResults()) {\n      if (result.getScore() > 1001) {\n        ++goodCount;\n      } else {\n        break;\n      }\n    }\n\n    return goodCount == expectedGoodCount;\n  }",
          "includes": [
            "#include \"capnproto-common.h\"",
            "#include \"catrank.capnp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"catrank.capnp.h\"\n\nCatRankTestCase {\n  static bool checkResponse(SearchResultList::Reader response, int expectedGoodCount) {\n      int goodCount = 0;\n      for (auto result: response.getResults()) {\n        if (result.getScore() > 1001) {\n          ++goodCount;\n        } else {\n          break;\n        }\n      }\n  \n      return goodCount == expectedGoodCount;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "clientResponse.ParsePartialFromString",
          "args": [
            "responseString"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clientResponse",
          "args": [
            "reusableClientResponse"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SINGLE_USE",
          "args": [
            "Response"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "responseString.size",
          "args": [],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "serverResponse.SerializePartialToString",
          "args": [
            "&responseString"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestCase::handleRequest",
          "args": [
            "serverRequest",
            "&serverResponse"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "handleRequest",
          "container": "CatRankTestCase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-catrank.c++",
          "lines": "93-117",
          "snippet": "static void handleRequest(SearchResultList::Reader request, SearchResultList::Builder response) {\n    std::vector<ScoredResult> scoredResults;\n\n    for (auto result: request.getResults()) {\n      double score = result.getScore();\n      if (strstr(result.getSnippet().cStr(), \" cat \") != nullptr) {\n        score *= 10000;\n      }\n      if (strstr(result.getSnippet().cStr(), \" dog \") != nullptr) {\n        score /= 10000;\n      }\n      scoredResults.emplace_back(score, result);\n    }\n\n    std::sort(scoredResults.begin(), scoredResults.end());\n\n    auto list = response.initResults(scoredResults.size());\n    auto iter = list.begin();\n    for (auto result: scoredResults) {\n      iter->setScore(result.score);\n      iter->setUrl(result.result.getUrl());\n      iter->setSnippet(result.result.getSnippet());\n      ++iter;\n    }\n  }",
          "includes": [
            "#include \"capnproto-common.h\"",
            "#include \"catrank.capnp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"catrank.capnp.h\"\n\nCatRankTestCase {\n  static void handleRequest(SearchResultList::Reader request, SearchResultList::Builder response) {\n      std::vector<ScoredResult> scoredResults;\n  \n      for (auto result: request.getResults()) {\n        double score = result.getScore();\n        if (strstr(result.getSnippet().cStr(), \" cat \") != nullptr) {\n          score *= 10000;\n        }\n        if (strstr(result.getSnippet().cStr(), \" dog \") != nullptr) {\n          score /= 10000;\n        }\n        scoredResults.emplace_back(score, result);\n      }\n  \n      std::sort(scoredResults.begin(), scoredResults.end());\n  \n      auto list = response.initResults(scoredResults.size());\n      auto iter = list.begin();\n      for (auto result: scoredResults) {\n        iter->setScore(result.score);\n        iter->setUrl(result.result.getUrl());\n        iter->setSnippet(result.result.getSnippet());\n        ++iter;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "serverResponse",
          "args": [
            "reusableServerResponse"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SINGLE_USE",
          "args": [
            "Response"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "serverRequest.ParsePartialFromString",
          "args": [
            "requestString"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "serverRequest",
          "args": [
            "reusableServerRequest"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SINGLE_USE",
          "args": [
            "Request"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clientRequest.SerializePartialToString",
          "args": [
            "&requestString"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestCase::setupRequest",
          "args": [
            "&clientRequest"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "setupRequest",
          "container": "CatRankTestCase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-catrank.c++",
          "lines": "45-91",
          "snippet": "static int setupRequest(SearchResultList::Builder request) {\n    int count = fastRand(1000);\n    int goodCount = 0;\n\n    auto list = request.initResults(count);\n\n    for (int i = 0; i < count; i++) {\n      SearchResult::Builder result = list[i];\n      result.setScore(1000 - i);\n      int urlSize = fastRand(100);\n\n      static const char URL_PREFIX[] = \"http://example.com/\";\n      size_t urlPrefixLength = strlen(URL_PREFIX);\n      auto url = result.initUrl(urlSize + urlPrefixLength);\n\n      strcpy(url.begin(), URL_PREFIX);\n      char* pos = url.begin() + urlPrefixLength;\n      for (int j = 0; j < urlSize; j++) {\n        *pos++ = 'a' + fastRand(26);\n      }\n\n      bool isCat = fastRand(8) == 0;\n      bool isDog = fastRand(8) == 0;\n      goodCount += isCat && !isDog;\n\n      static std::string snippet;\n      snippet.clear();\n      snippet.push_back(' ');\n\n      int prefix = fastRand(20);\n      for (int j = 0; j < prefix; j++) {\n        snippet.append(WORDS[fastRand(WORDS_COUNT)]);\n      }\n\n      if (isCat) snippet.append(\"cat \");\n      if (isDog) snippet.append(\"dog \");\n\n      int suffix = fastRand(20);\n      for (int j = 0; j < suffix; j++) {\n        snippet.append(WORDS[fastRand(WORDS_COUNT)]);\n      }\n\n      result.setSnippet(Text::Reader(snippet.c_str(), snippet.size()));\n    }\n\n    return goodCount;\n  }",
          "includes": [
            "#include \"capnproto-common.h\"",
            "#include \"catrank.capnp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"catrank.capnp.h\"\n\nCatRankTestCase {\n  static int setupRequest(SearchResultList::Builder request) {\n      int count = fastRand(1000);\n      int goodCount = 0;\n  \n      auto list = request.initResults(count);\n  \n      for (int i = 0; i < count; i++) {\n        SearchResult::Builder result = list[i];\n        result.setScore(1000 - i);\n        int urlSize = fastRand(100);\n  \n        static const char URL_PREFIX[] = \"http://example.com/\";\n        size_t urlPrefixLength = strlen(URL_PREFIX);\n        auto url = result.initUrl(urlSize + urlPrefixLength);\n  \n        strcpy(url.begin(), URL_PREFIX);\n        char* pos = url.begin() + urlPrefixLength;\n        for (int j = 0; j < urlSize; j++) {\n          *pos++ = 'a' + fastRand(26);\n        }\n  \n        bool isCat = fastRand(8) == 0;\n        bool isDog = fastRand(8) == 0;\n        goodCount += isCat && !isDog;\n  \n        static std::string snippet;\n        snippet.clear();\n        snippet.push_back(' ');\n  \n        int prefix = fastRand(20);\n        for (int j = 0; j < prefix; j++) {\n          snippet.append(WORDS[fastRand(WORDS_COUNT)]);\n        }\n  \n        if (isCat) snippet.append(\"cat \");\n        if (isDog) snippet.append(\"dog \");\n  \n        int suffix = fastRand(20);\n        for (int j = 0; j < suffix; j++) {\n          snippet.append(WORDS[fastRand(WORDS_COUNT)]);\n        }\n  \n        result.setSnippet(Text::Reader(snippet.c_str(), snippet.size()));\n      }\n  \n      return goodCount;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "clientRequest",
          "args": [
            "reusableClientRequest"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SINGLE_USE",
          "args": [
            "Request"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REUSABLE",
          "args": [
            "Response"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REUSABLE",
          "args": [
            "Response"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REUSABLE",
          "args": [
            "Request"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REUSABLE",
          "args": [
            "Request"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nBenchmarkMethods {\n  static uint64_t passByBytes(uint64_t iters) {\n      uint64_t throughput = 0;\n  \n      REUSABLE(Request) reusableClientRequest;\n      REUSABLE(Request) reusableServerRequest;\n      REUSABLE(Response) reusableServerResponse;\n      REUSABLE(Response) reusableClientResponse;\n      typename ReuseStrategy::ReusableString reusableRequestString, reusableResponseString;\n  \n      for (; iters > 0; --iters) {\n        SINGLE_USE(Request) clientRequest(reusableClientRequest);\n        typename TestCase::Expectation expected = TestCase::setupRequest(&clientRequest);\n  \n        typename ReuseStrategy::SingleUseString requestString(reusableRequestString);\n        clientRequest.SerializePartialToString(&requestString);\n        throughput += requestString.size();\n        ReuseStrategy::doneWith(clientRequest);\n  \n        SINGLE_USE(Request) serverRequest(reusableServerRequest);\n        serverRequest.ParsePartialFromString(requestString);\n  \n        SINGLE_USE(Response) serverResponse(reusableServerResponse);\n        TestCase::handleRequest(serverRequest, &serverResponse);\n        ReuseStrategy::doneWith(serverRequest);\n  \n        typename ReuseStrategy::SingleUseString responseString(reusableResponseString);\n        serverResponse.SerializePartialToString(&responseString);\n        throughput += responseString.size();\n        ReuseStrategy::doneWith(serverResponse);\n  \n        SINGLE_USE(Response) clientResponse(reusableClientResponse);\n        clientResponse.ParsePartialFromString(responseString);\n  \n        if (!TestCase::checkResponse(clientResponse, expected)) {\n          throw std::logic_error(\"Incorrect response.\");\n        }\n        ReuseStrategy::doneWith(clientResponse);\n      }\n  \n      return throughput;\n    }\n}"
  },
  {
    "function_name": "passByObject",
    "container": "BenchmarkMethods",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
    "lines": "272-297",
    "snippet": "static uint64_t passByObject(uint64_t iters, bool countObjectSize) {\n    uint64_t throughput = 0;\n\n    REUSABLE(Request) reusableRequest;\n    REUSABLE(Response) reusableResponse;\n\n    for (; iters > 0; --iters) {\n      SINGLE_USE(Request) request(reusableRequest);\n      typename TestCase::Expectation expected = TestCase::setupRequest(&request);\n\n      SINGLE_USE(Response) response(reusableResponse);\n      TestCase::handleRequest(request, &response);\n      ReuseStrategy::doneWith(request);\n      if (!TestCase::checkResponse(response, expected)) {\n        throw std::logic_error(\"Incorrect response.\");\n      }\n      ReuseStrategy::doneWith(response);\n\n      if (countObjectSize) {\n        throughput += request.SpaceUsed();\n        throughput += response.SpaceUsed();\n      }\n    }\n\n    return throughput;\n  }",
    "includes": [
      "#include <snappy/snappy-sinksource.h>",
      "#include <snappy/snappy.h>",
      "#include <thread>",
      "#include <google/protobuf/io/coded_stream.h>",
      "#include <google/protobuf/io/zero_copy_stream_impl.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "response.SpaceUsed",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.SpaceUsed",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReuseStrategy::doneWith",
          "args": [
            "response"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "doneWith",
          "container": "ReusableMessages",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "68-70",
          "snippet": "static inline void doneWith(MessageType& message) {\n    message.Clear();\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nReusableMessages {\n  static inline void doneWith(MessageType& message) {\n      message.Clear();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::logic_error",
          "args": [
            "\"Incorrect response.\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestCase::checkResponse",
          "args": [
            "response",
            "expected"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "checkResponse",
          "container": "CatRankTestCase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-catrank.c++",
          "lines": "119-130",
          "snippet": "static bool checkResponse(SearchResultList::Reader response, int expectedGoodCount) {\n    int goodCount = 0;\n    for (auto result: response.getResults()) {\n      if (result.getScore() > 1001) {\n        ++goodCount;\n      } else {\n        break;\n      }\n    }\n\n    return goodCount == expectedGoodCount;\n  }",
          "includes": [
            "#include \"capnproto-common.h\"",
            "#include \"catrank.capnp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"catrank.capnp.h\"\n\nCatRankTestCase {\n  static bool checkResponse(SearchResultList::Reader response, int expectedGoodCount) {\n      int goodCount = 0;\n      for (auto result: response.getResults()) {\n        if (result.getScore() > 1001) {\n          ++goodCount;\n        } else {\n          break;\n        }\n      }\n  \n      return goodCount == expectedGoodCount;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestCase::handleRequest",
          "args": [
            "request",
            "&response"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "handleRequest",
          "container": "CatRankTestCase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-catrank.c++",
          "lines": "93-117",
          "snippet": "static void handleRequest(SearchResultList::Reader request, SearchResultList::Builder response) {\n    std::vector<ScoredResult> scoredResults;\n\n    for (auto result: request.getResults()) {\n      double score = result.getScore();\n      if (strstr(result.getSnippet().cStr(), \" cat \") != nullptr) {\n        score *= 10000;\n      }\n      if (strstr(result.getSnippet().cStr(), \" dog \") != nullptr) {\n        score /= 10000;\n      }\n      scoredResults.emplace_back(score, result);\n    }\n\n    std::sort(scoredResults.begin(), scoredResults.end());\n\n    auto list = response.initResults(scoredResults.size());\n    auto iter = list.begin();\n    for (auto result: scoredResults) {\n      iter->setScore(result.score);\n      iter->setUrl(result.result.getUrl());\n      iter->setSnippet(result.result.getSnippet());\n      ++iter;\n    }\n  }",
          "includes": [
            "#include \"capnproto-common.h\"",
            "#include \"catrank.capnp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"catrank.capnp.h\"\n\nCatRankTestCase {\n  static void handleRequest(SearchResultList::Reader request, SearchResultList::Builder response) {\n      std::vector<ScoredResult> scoredResults;\n  \n      for (auto result: request.getResults()) {\n        double score = result.getScore();\n        if (strstr(result.getSnippet().cStr(), \" cat \") != nullptr) {\n          score *= 10000;\n        }\n        if (strstr(result.getSnippet().cStr(), \" dog \") != nullptr) {\n          score /= 10000;\n        }\n        scoredResults.emplace_back(score, result);\n      }\n  \n      std::sort(scoredResults.begin(), scoredResults.end());\n  \n      auto list = response.initResults(scoredResults.size());\n      auto iter = list.begin();\n      for (auto result: scoredResults) {\n        iter->setScore(result.score);\n        iter->setUrl(result.result.getUrl());\n        iter->setSnippet(result.result.getSnippet());\n        ++iter;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "response",
          "args": [
            "reusableResponse"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SINGLE_USE",
          "args": [
            "Response"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestCase::setupRequest",
          "args": [
            "&request"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "setupRequest",
          "container": "CatRankTestCase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-catrank.c++",
          "lines": "45-91",
          "snippet": "static int setupRequest(SearchResultList::Builder request) {\n    int count = fastRand(1000);\n    int goodCount = 0;\n\n    auto list = request.initResults(count);\n\n    for (int i = 0; i < count; i++) {\n      SearchResult::Builder result = list[i];\n      result.setScore(1000 - i);\n      int urlSize = fastRand(100);\n\n      static const char URL_PREFIX[] = \"http://example.com/\";\n      size_t urlPrefixLength = strlen(URL_PREFIX);\n      auto url = result.initUrl(urlSize + urlPrefixLength);\n\n      strcpy(url.begin(), URL_PREFIX);\n      char* pos = url.begin() + urlPrefixLength;\n      for (int j = 0; j < urlSize; j++) {\n        *pos++ = 'a' + fastRand(26);\n      }\n\n      bool isCat = fastRand(8) == 0;\n      bool isDog = fastRand(8) == 0;\n      goodCount += isCat && !isDog;\n\n      static std::string snippet;\n      snippet.clear();\n      snippet.push_back(' ');\n\n      int prefix = fastRand(20);\n      for (int j = 0; j < prefix; j++) {\n        snippet.append(WORDS[fastRand(WORDS_COUNT)]);\n      }\n\n      if (isCat) snippet.append(\"cat \");\n      if (isDog) snippet.append(\"dog \");\n\n      int suffix = fastRand(20);\n      for (int j = 0; j < suffix; j++) {\n        snippet.append(WORDS[fastRand(WORDS_COUNT)]);\n      }\n\n      result.setSnippet(Text::Reader(snippet.c_str(), snippet.size()));\n    }\n\n    return goodCount;\n  }",
          "includes": [
            "#include \"capnproto-common.h\"",
            "#include \"catrank.capnp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"catrank.capnp.h\"\n\nCatRankTestCase {\n  static int setupRequest(SearchResultList::Builder request) {\n      int count = fastRand(1000);\n      int goodCount = 0;\n  \n      auto list = request.initResults(count);\n  \n      for (int i = 0; i < count; i++) {\n        SearchResult::Builder result = list[i];\n        result.setScore(1000 - i);\n        int urlSize = fastRand(100);\n  \n        static const char URL_PREFIX[] = \"http://example.com/\";\n        size_t urlPrefixLength = strlen(URL_PREFIX);\n        auto url = result.initUrl(urlSize + urlPrefixLength);\n  \n        strcpy(url.begin(), URL_PREFIX);\n        char* pos = url.begin() + urlPrefixLength;\n        for (int j = 0; j < urlSize; j++) {\n          *pos++ = 'a' + fastRand(26);\n        }\n  \n        bool isCat = fastRand(8) == 0;\n        bool isDog = fastRand(8) == 0;\n        goodCount += isCat && !isDog;\n  \n        static std::string snippet;\n        snippet.clear();\n        snippet.push_back(' ');\n  \n        int prefix = fastRand(20);\n        for (int j = 0; j < prefix; j++) {\n          snippet.append(WORDS[fastRand(WORDS_COUNT)]);\n        }\n  \n        if (isCat) snippet.append(\"cat \");\n        if (isDog) snippet.append(\"dog \");\n  \n        int suffix = fastRand(20);\n        for (int j = 0; j < suffix; j++) {\n          snippet.append(WORDS[fastRand(WORDS_COUNT)]);\n        }\n  \n        result.setSnippet(Text::Reader(snippet.c_str(), snippet.size()));\n      }\n  \n      return goodCount;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "request",
          "args": [
            "reusableRequest"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SINGLE_USE",
          "args": [
            "Request"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REUSABLE",
          "args": [
            "Response"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REUSABLE",
          "args": [
            "Request"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nBenchmarkMethods {\n  static uint64_t passByObject(uint64_t iters, bool countObjectSize) {\n      uint64_t throughput = 0;\n  \n      REUSABLE(Request) reusableRequest;\n      REUSABLE(Response) reusableResponse;\n  \n      for (; iters > 0; --iters) {\n        SINGLE_USE(Request) request(reusableRequest);\n        typename TestCase::Expectation expected = TestCase::setupRequest(&request);\n  \n        SINGLE_USE(Response) response(reusableResponse);\n        TestCase::handleRequest(request, &response);\n        ReuseStrategy::doneWith(request);\n        if (!TestCase::checkResponse(response, expected)) {\n          throw std::logic_error(\"Incorrect response.\");\n        }\n        ReuseStrategy::doneWith(response);\n  \n        if (countObjectSize) {\n          throughput += request.SpaceUsed();\n          throughput += response.SpaceUsed();\n        }\n      }\n  \n      return throughput;\n    }\n}"
  },
  {
    "function_name": "server",
    "container": "BenchmarkMethods",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
    "lines": "247-270",
    "snippet": "static uint64_t server(int inputFd, int outputFd, uint64_t iters) {\n    uint64_t throughput = 0;\n\n    typename Compression::OutputStream output(outputFd);\n    typename Compression::InputStream input(inputFd);\n\n    REUSABLE(Request) reusableRequest;\n    REUSABLE(Response) reusableResponse;\n\n    for (; iters > 0; --iters) {\n      SINGLE_USE(Request) request(reusableRequest);\n      Compression::read(&input, &request);\n\n      SINGLE_USE(Response) response(reusableResponse);\n      TestCase::handleRequest(request, &response);\n      ReuseStrategy::doneWith(request);\n\n      throughput += Compression::write(response, &output);\n      Compression::flush(&output);\n      ReuseStrategy::doneWith(response);\n    }\n\n    return throughput;\n  }",
    "includes": [
      "#include <snappy/snappy-sinksource.h>",
      "#include <snappy/snappy.h>",
      "#include <thread>",
      "#include <google/protobuf/io/coded_stream.h>",
      "#include <google/protobuf/io/zero_copy_stream_impl.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReuseStrategy::doneWith",
          "args": [
            "response"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "doneWith",
          "container": "ReusableMessages",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "68-70",
          "snippet": "static inline void doneWith(MessageType& message) {\n    message.Clear();\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nReusableMessages {\n  static inline void doneWith(MessageType& message) {\n      message.Clear();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Compression::flush",
          "args": [
            "&output"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "flush",
          "container": "SnappyCompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "161-161",
          "snippet": "static void flush(OutputStream*) {}",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSnappyCompressed {\n  static void flush(OutputStream*) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Compression::write",
          "args": [
            "response",
            "&output"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "SnappyCompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "134-147",
          "snippet": "static uint64_t write(const google::protobuf::MessageLite& message, int* output) {\n    size_t size = message.ByteSize();\n    GOOGLE_CHECK_LE(size, sizeof(scratch));\n\n    message.SerializeWithCachedSizesToArray(reinterpret_cast<uint8_t*>(scratch));\n\n    size_t compressedSize = 0;\n    snappy::RawCompress(scratch, size, scratch2 + sizeof(uint32_t), &compressedSize);\n    uint32_t tag = compressedSize;\n    memcpy(scratch2, &tag, sizeof(tag));\n\n    writeAll(*output, scratch2, compressedSize + sizeof(tag));\n    return compressedSize + sizeof(tag);\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSnappyCompressed {\n  static uint64_t write(const google::protobuf::MessageLite& message, int* output) {\n      size_t size = message.ByteSize();\n      GOOGLE_CHECK_LE(size, sizeof(scratch));\n  \n      message.SerializeWithCachedSizesToArray(reinterpret_cast<uint8_t*>(scratch));\n  \n      size_t compressedSize = 0;\n      snappy::RawCompress(scratch, size, scratch2 + sizeof(uint32_t), &compressedSize);\n      uint32_t tag = compressedSize;\n      memcpy(scratch2, &tag, sizeof(tag));\n  \n      writeAll(*output, scratch2, compressedSize + sizeof(tag));\n      return compressedSize + sizeof(tag);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestCase::handleRequest",
          "args": [
            "request",
            "&response"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "handleRequest",
          "container": "CatRankTestCase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-catrank.c++",
          "lines": "93-117",
          "snippet": "static void handleRequest(SearchResultList::Reader request, SearchResultList::Builder response) {\n    std::vector<ScoredResult> scoredResults;\n\n    for (auto result: request.getResults()) {\n      double score = result.getScore();\n      if (strstr(result.getSnippet().cStr(), \" cat \") != nullptr) {\n        score *= 10000;\n      }\n      if (strstr(result.getSnippet().cStr(), \" dog \") != nullptr) {\n        score /= 10000;\n      }\n      scoredResults.emplace_back(score, result);\n    }\n\n    std::sort(scoredResults.begin(), scoredResults.end());\n\n    auto list = response.initResults(scoredResults.size());\n    auto iter = list.begin();\n    for (auto result: scoredResults) {\n      iter->setScore(result.score);\n      iter->setUrl(result.result.getUrl());\n      iter->setSnippet(result.result.getSnippet());\n      ++iter;\n    }\n  }",
          "includes": [
            "#include \"capnproto-common.h\"",
            "#include \"catrank.capnp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"catrank.capnp.h\"\n\nCatRankTestCase {\n  static void handleRequest(SearchResultList::Reader request, SearchResultList::Builder response) {\n      std::vector<ScoredResult> scoredResults;\n  \n      for (auto result: request.getResults()) {\n        double score = result.getScore();\n        if (strstr(result.getSnippet().cStr(), \" cat \") != nullptr) {\n          score *= 10000;\n        }\n        if (strstr(result.getSnippet().cStr(), \" dog \") != nullptr) {\n          score /= 10000;\n        }\n        scoredResults.emplace_back(score, result);\n      }\n  \n      std::sort(scoredResults.begin(), scoredResults.end());\n  \n      auto list = response.initResults(scoredResults.size());\n      auto iter = list.begin();\n      for (auto result: scoredResults) {\n        iter->setScore(result.score);\n        iter->setUrl(result.result.getUrl());\n        iter->setSnippet(result.result.getSnippet());\n        ++iter;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "response",
          "args": [
            "reusableResponse"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SINGLE_USE",
          "args": [
            "Response"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Compression::read",
          "args": [
            "&input",
            "&request"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "SnappyCompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "149-159",
          "snippet": "static void read(int* input, google::protobuf::MessageLite* message) {\n    uint32_t size;\n    readAll(*input, &size, sizeof(size));\n    readAll(*input, scratch, size);\n\n    size_t uncompressedSize;\n    GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n    GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n\n    GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSnappyCompressed {\n  static void read(int* input, google::protobuf::MessageLite* message) {\n      uint32_t size;\n      readAll(*input, &size, sizeof(size));\n      readAll(*input, scratch, size);\n  \n      size_t uncompressedSize;\n      GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n      GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n  \n      GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "request",
          "args": [
            "reusableRequest"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SINGLE_USE",
          "args": [
            "Request"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REUSABLE",
          "args": [
            "Response"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REUSABLE",
          "args": [
            "Request"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nBenchmarkMethods {\n  static uint64_t server(int inputFd, int outputFd, uint64_t iters) {\n      uint64_t throughput = 0;\n  \n      typename Compression::OutputStream output(outputFd);\n      typename Compression::InputStream input(inputFd);\n  \n      REUSABLE(Request) reusableRequest;\n      REUSABLE(Response) reusableResponse;\n  \n      for (; iters > 0; --iters) {\n        SINGLE_USE(Request) request(reusableRequest);\n        Compression::read(&input, &request);\n  \n        SINGLE_USE(Response) response(reusableResponse);\n        TestCase::handleRequest(request, &response);\n        ReuseStrategy::doneWith(request);\n  \n        throughput += Compression::write(response, &output);\n        Compression::flush(&output);\n        ReuseStrategy::doneWith(response);\n      }\n  \n      return throughput;\n    }\n}"
  },
  {
    "function_name": "asyncClient",
    "container": "BenchmarkMethods",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
    "lines": "238-245",
    "snippet": "static uint64_t asyncClient(int inputFd, int outputFd, uint64_t iters) {\n    ProducerConsumerQueue<typename TestCase::Expectation> expectations;\n    std::thread receiverThread(asyncClientReceiver, inputFd, &expectations, iters);\n    uint64_t throughput = asyncClientSender(outputFd, &expectations, iters);\n    receiverThread.join();\n\n    return throughput;\n  }",
    "includes": [
      "#include <snappy/snappy-sinksource.h>",
      "#include <snappy/snappy.h>",
      "#include <thread>",
      "#include <google/protobuf/io/coded_stream.h>",
      "#include <google/protobuf/io/zero_copy_stream_impl.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "receiverThread.join",
          "args": [],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asyncClientSender",
          "args": [
            "outputFd",
            "&expectations",
            "iters"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "asyncClientSender",
          "container": "BenchmarkMethods",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "107-112",
          "snippet": "static uint64_t asyncClientSender(\n      int outputFd, ProducerConsumerQueue<typename TestCase::Expectation>* expectations,\n      uint64_t iters) {\n    fprintf(stderr, \"Null benchmark doesn't do I/O.\\n\");\n    exit(1);\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nBenchmarkMethods {\n  static uint64_t asyncClientSender(\n        int outputFd, ProducerConsumerQueue<typename TestCase::Expectation>* expectations,\n        uint64_t iters) {\n      fprintf(stderr, \"Null benchmark doesn't do I/O.\\n\");\n      exit(1);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nBenchmarkMethods {\n  static uint64_t asyncClient(int inputFd, int outputFd, uint64_t iters) {\n      ProducerConsumerQueue<typename TestCase::Expectation> expectations;\n      std::thread receiverThread(asyncClientReceiver, inputFd, &expectations, iters);\n      uint64_t throughput = asyncClientSender(outputFd, &expectations, iters);\n      receiverThread.join();\n  \n      return throughput;\n    }\n}"
  },
  {
    "function_name": "asyncClientReceiver",
    "container": "BenchmarkMethods",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
    "lines": "221-236",
    "snippet": "static void asyncClientReceiver(\n      int inputFd, ProducerConsumerQueue<typename TestCase::Expectation>* expectations,\n      uint64_t iters) {\n    typename Compression::InputStream input(inputFd);\n    REUSABLE(Response) reusableResponse;\n\n    for (; iters > 0; --iters) {\n      typename TestCase::Expectation expected = expectations->next();\n      SINGLE_USE(Response) response(reusableResponse);\n      Compression::read(&input, &response);\n      if (!TestCase::checkResponse(response, expected)) {\n        throw std::logic_error(\"Incorrect response.\");\n      }\n      ReuseStrategy::doneWith(response);\n    }\n  }",
    "includes": [
      "#include <snappy/snappy-sinksource.h>",
      "#include <snappy/snappy.h>",
      "#include <thread>",
      "#include <google/protobuf/io/coded_stream.h>",
      "#include <google/protobuf/io/zero_copy_stream_impl.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReuseStrategy::doneWith",
          "args": [
            "response"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "doneWith",
          "container": "ReusableMessages",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "68-70",
          "snippet": "static inline void doneWith(MessageType& message) {\n    message.Clear();\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nReusableMessages {\n  static inline void doneWith(MessageType& message) {\n      message.Clear();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::logic_error",
          "args": [
            "\"Incorrect response.\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestCase::checkResponse",
          "args": [
            "response",
            "expected"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "checkResponse",
          "container": "CatRankTestCase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-catrank.c++",
          "lines": "119-130",
          "snippet": "static bool checkResponse(SearchResultList::Reader response, int expectedGoodCount) {\n    int goodCount = 0;\n    for (auto result: response.getResults()) {\n      if (result.getScore() > 1001) {\n        ++goodCount;\n      } else {\n        break;\n      }\n    }\n\n    return goodCount == expectedGoodCount;\n  }",
          "includes": [
            "#include \"capnproto-common.h\"",
            "#include \"catrank.capnp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"catrank.capnp.h\"\n\nCatRankTestCase {\n  static bool checkResponse(SearchResultList::Reader response, int expectedGoodCount) {\n      int goodCount = 0;\n      for (auto result: response.getResults()) {\n        if (result.getScore() > 1001) {\n          ++goodCount;\n        } else {\n          break;\n        }\n      }\n  \n      return goodCount == expectedGoodCount;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Compression::read",
          "args": [
            "&input",
            "&response"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "SnappyCompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "149-159",
          "snippet": "static void read(int* input, google::protobuf::MessageLite* message) {\n    uint32_t size;\n    readAll(*input, &size, sizeof(size));\n    readAll(*input, scratch, size);\n\n    size_t uncompressedSize;\n    GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n    GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n\n    GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSnappyCompressed {\n  static void read(int* input, google::protobuf::MessageLite* message) {\n      uint32_t size;\n      readAll(*input, &size, sizeof(size));\n      readAll(*input, scratch, size);\n  \n      size_t uncompressedSize;\n      GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n      GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n  \n      GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "response",
          "args": [
            "reusableResponse"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SINGLE_USE",
          "args": [
            "Response"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expectations->next",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "next",
          "container": "ProducerConsumerQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "120-126",
          "snippet": "T next() {\n    sem_wait(&semaphore);\n    Node* oldFront = front;\n    front = front->next;\n    delete oldFront;\n    return front->value;\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nProducerConsumerQueue {\n  T next() {\n      sem_wait(&semaphore);\n      Node* oldFront = front;\n      front = front->next;\n      delete oldFront;\n      return front->value;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "REUSABLE",
          "args": [
            "Response"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nBenchmarkMethods {\n  static void asyncClientReceiver(\n        int inputFd, ProducerConsumerQueue<typename TestCase::Expectation>* expectations,\n        uint64_t iters) {\n      typename Compression::InputStream input(inputFd);\n      REUSABLE(Response) reusableResponse;\n  \n      for (; iters > 0; --iters) {\n        typename TestCase::Expectation expected = expectations->next();\n        SINGLE_USE(Response) response(reusableResponse);\n        Compression::read(&input, &response);\n        if (!TestCase::checkResponse(response, expected)) {\n          throw std::logic_error(\"Incorrect response.\");\n        }\n        ReuseStrategy::doneWith(response);\n      }\n    }\n}"
  },
  {
    "function_name": "asyncClientSender",
    "container": "BenchmarkMethods",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
    "lines": "202-219",
    "snippet": "static uint64_t asyncClientSender(\n      int outputFd, ProducerConsumerQueue<typename TestCase::Expectation>* expectations,\n      uint64_t iters) {\n    uint64_t throughput = 0;\n\n    typename Compression::OutputStream output(outputFd);\n    REUSABLE(Request) reusableRequest;\n\n    for (; iters > 0; --iters) {\n      SINGLE_USE(Request) request(reusableRequest);\n      expectations->post(TestCase::setupRequest(&request));\n      throughput += Compression::write(request, &output);\n      Compression::flush(&output);\n      ReuseStrategy::doneWith(request);\n    }\n\n    return throughput;\n  }",
    "includes": [
      "#include <snappy/snappy-sinksource.h>",
      "#include <snappy/snappy.h>",
      "#include <thread>",
      "#include <google/protobuf/io/coded_stream.h>",
      "#include <google/protobuf/io/zero_copy_stream_impl.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReuseStrategy::doneWith",
          "args": [
            "request"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "doneWith",
          "container": "ReusableMessages",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "68-70",
          "snippet": "static inline void doneWith(MessageType& message) {\n    message.Clear();\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nReusableMessages {\n  static inline void doneWith(MessageType& message) {\n      message.Clear();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Compression::flush",
          "args": [
            "&output"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "flush",
          "container": "SnappyCompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "161-161",
          "snippet": "static void flush(OutputStream*) {}",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSnappyCompressed {\n  static void flush(OutputStream*) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Compression::write",
          "args": [
            "request",
            "&output"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "SnappyCompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "134-147",
          "snippet": "static uint64_t write(const google::protobuf::MessageLite& message, int* output) {\n    size_t size = message.ByteSize();\n    GOOGLE_CHECK_LE(size, sizeof(scratch));\n\n    message.SerializeWithCachedSizesToArray(reinterpret_cast<uint8_t*>(scratch));\n\n    size_t compressedSize = 0;\n    snappy::RawCompress(scratch, size, scratch2 + sizeof(uint32_t), &compressedSize);\n    uint32_t tag = compressedSize;\n    memcpy(scratch2, &tag, sizeof(tag));\n\n    writeAll(*output, scratch2, compressedSize + sizeof(tag));\n    return compressedSize + sizeof(tag);\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSnappyCompressed {\n  static uint64_t write(const google::protobuf::MessageLite& message, int* output) {\n      size_t size = message.ByteSize();\n      GOOGLE_CHECK_LE(size, sizeof(scratch));\n  \n      message.SerializeWithCachedSizesToArray(reinterpret_cast<uint8_t*>(scratch));\n  \n      size_t compressedSize = 0;\n      snappy::RawCompress(scratch, size, scratch2 + sizeof(uint32_t), &compressedSize);\n      uint32_t tag = compressedSize;\n      memcpy(scratch2, &tag, sizeof(tag));\n  \n      writeAll(*output, scratch2, compressedSize + sizeof(tag));\n      return compressedSize + sizeof(tag);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expectations->post",
          "args": [
            "TestCase::setupRequest(&request)"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "post",
          "container": "ProducerConsumerQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "114-118",
          "snippet": "void post(T t) {\n    back->next = new Node(t);\n    back = back->next;\n    sem_post(&semaphore);\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nProducerConsumerQueue {\n  void post(T t) {\n      back->next = new Node(t);\n      back = back->next;\n      sem_post(&semaphore);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestCase::setupRequest",
          "args": [
            "&request"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "setupRequest",
          "container": "CatRankTestCase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-catrank.c++",
          "lines": "45-91",
          "snippet": "static int setupRequest(SearchResultList::Builder request) {\n    int count = fastRand(1000);\n    int goodCount = 0;\n\n    auto list = request.initResults(count);\n\n    for (int i = 0; i < count; i++) {\n      SearchResult::Builder result = list[i];\n      result.setScore(1000 - i);\n      int urlSize = fastRand(100);\n\n      static const char URL_PREFIX[] = \"http://example.com/\";\n      size_t urlPrefixLength = strlen(URL_PREFIX);\n      auto url = result.initUrl(urlSize + urlPrefixLength);\n\n      strcpy(url.begin(), URL_PREFIX);\n      char* pos = url.begin() + urlPrefixLength;\n      for (int j = 0; j < urlSize; j++) {\n        *pos++ = 'a' + fastRand(26);\n      }\n\n      bool isCat = fastRand(8) == 0;\n      bool isDog = fastRand(8) == 0;\n      goodCount += isCat && !isDog;\n\n      static std::string snippet;\n      snippet.clear();\n      snippet.push_back(' ');\n\n      int prefix = fastRand(20);\n      for (int j = 0; j < prefix; j++) {\n        snippet.append(WORDS[fastRand(WORDS_COUNT)]);\n      }\n\n      if (isCat) snippet.append(\"cat \");\n      if (isDog) snippet.append(\"dog \");\n\n      int suffix = fastRand(20);\n      for (int j = 0; j < suffix; j++) {\n        snippet.append(WORDS[fastRand(WORDS_COUNT)]);\n      }\n\n      result.setSnippet(Text::Reader(snippet.c_str(), snippet.size()));\n    }\n\n    return goodCount;\n  }",
          "includes": [
            "#include \"capnproto-common.h\"",
            "#include \"catrank.capnp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"catrank.capnp.h\"\n\nCatRankTestCase {\n  static int setupRequest(SearchResultList::Builder request) {\n      int count = fastRand(1000);\n      int goodCount = 0;\n  \n      auto list = request.initResults(count);\n  \n      for (int i = 0; i < count; i++) {\n        SearchResult::Builder result = list[i];\n        result.setScore(1000 - i);\n        int urlSize = fastRand(100);\n  \n        static const char URL_PREFIX[] = \"http://example.com/\";\n        size_t urlPrefixLength = strlen(URL_PREFIX);\n        auto url = result.initUrl(urlSize + urlPrefixLength);\n  \n        strcpy(url.begin(), URL_PREFIX);\n        char* pos = url.begin() + urlPrefixLength;\n        for (int j = 0; j < urlSize; j++) {\n          *pos++ = 'a' + fastRand(26);\n        }\n  \n        bool isCat = fastRand(8) == 0;\n        bool isDog = fastRand(8) == 0;\n        goodCount += isCat && !isDog;\n  \n        static std::string snippet;\n        snippet.clear();\n        snippet.push_back(' ');\n  \n        int prefix = fastRand(20);\n        for (int j = 0; j < prefix; j++) {\n          snippet.append(WORDS[fastRand(WORDS_COUNT)]);\n        }\n  \n        if (isCat) snippet.append(\"cat \");\n        if (isDog) snippet.append(\"dog \");\n  \n        int suffix = fastRand(20);\n        for (int j = 0; j < suffix; j++) {\n          snippet.append(WORDS[fastRand(WORDS_COUNT)]);\n        }\n  \n        result.setSnippet(Text::Reader(snippet.c_str(), snippet.size()));\n      }\n  \n      return goodCount;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "request",
          "args": [
            "reusableRequest"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SINGLE_USE",
          "args": [
            "Request"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REUSABLE",
          "args": [
            "Request"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nBenchmarkMethods {\n  static uint64_t asyncClientSender(\n        int outputFd, ProducerConsumerQueue<typename TestCase::Expectation>* expectations,\n        uint64_t iters) {\n      uint64_t throughput = 0;\n  \n      typename Compression::OutputStream output(outputFd);\n      REUSABLE(Request) reusableRequest;\n  \n      for (; iters > 0; --iters) {\n        SINGLE_USE(Request) request(reusableRequest);\n        expectations->post(TestCase::setupRequest(&request));\n        throughput += Compression::write(request, &output);\n        Compression::flush(&output);\n        ReuseStrategy::doneWith(request);\n      }\n  \n      return throughput;\n    }\n}"
  },
  {
    "function_name": "syncClient",
    "container": "BenchmarkMethods",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
    "lines": "175-200",
    "snippet": "static uint64_t syncClient(int inputFd, int outputFd, uint64_t iters) {\n    uint64_t throughput = 0;\n\n    typename Compression::OutputStream output(outputFd);\n    typename Compression::InputStream input(inputFd);\n\n    REUSABLE(Request) reusableRequest;\n    REUSABLE(Response) reusableResponse;\n\n    for (; iters > 0; --iters) {\n      SINGLE_USE(Request) request(reusableRequest);\n      typename TestCase::Expectation expected = TestCase::setupRequest(&request);\n      throughput += Compression::write(request, &output);\n      Compression::flush(&output);\n      ReuseStrategy::doneWith(request);\n\n      SINGLE_USE(Response) response(reusableResponse);\n      Compression::read(&input, &response);\n      if (!TestCase::checkResponse(response, expected)) {\n        throw std::logic_error(\"Incorrect response.\");\n      }\n      ReuseStrategy::doneWith(response);\n    }\n\n    return throughput;\n  }",
    "includes": [
      "#include <snappy/snappy-sinksource.h>",
      "#include <snappy/snappy.h>",
      "#include <thread>",
      "#include <google/protobuf/io/coded_stream.h>",
      "#include <google/protobuf/io/zero_copy_stream_impl.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReuseStrategy::doneWith",
          "args": [
            "response"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "doneWith",
          "container": "ReusableMessages",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "68-70",
          "snippet": "static inline void doneWith(MessageType& message) {\n    message.Clear();\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nReusableMessages {\n  static inline void doneWith(MessageType& message) {\n      message.Clear();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::logic_error",
          "args": [
            "\"Incorrect response.\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestCase::checkResponse",
          "args": [
            "response",
            "expected"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "checkResponse",
          "container": "CatRankTestCase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-catrank.c++",
          "lines": "119-130",
          "snippet": "static bool checkResponse(SearchResultList::Reader response, int expectedGoodCount) {\n    int goodCount = 0;\n    for (auto result: response.getResults()) {\n      if (result.getScore() > 1001) {\n        ++goodCount;\n      } else {\n        break;\n      }\n    }\n\n    return goodCount == expectedGoodCount;\n  }",
          "includes": [
            "#include \"capnproto-common.h\"",
            "#include \"catrank.capnp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"catrank.capnp.h\"\n\nCatRankTestCase {\n  static bool checkResponse(SearchResultList::Reader response, int expectedGoodCount) {\n      int goodCount = 0;\n      for (auto result: response.getResults()) {\n        if (result.getScore() > 1001) {\n          ++goodCount;\n        } else {\n          break;\n        }\n      }\n  \n      return goodCount == expectedGoodCount;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Compression::read",
          "args": [
            "&input",
            "&response"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "SnappyCompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "149-159",
          "snippet": "static void read(int* input, google::protobuf::MessageLite* message) {\n    uint32_t size;\n    readAll(*input, &size, sizeof(size));\n    readAll(*input, scratch, size);\n\n    size_t uncompressedSize;\n    GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n    GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n\n    GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSnappyCompressed {\n  static void read(int* input, google::protobuf::MessageLite* message) {\n      uint32_t size;\n      readAll(*input, &size, sizeof(size));\n      readAll(*input, scratch, size);\n  \n      size_t uncompressedSize;\n      GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n      GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n  \n      GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "response",
          "args": [
            "reusableResponse"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SINGLE_USE",
          "args": [
            "Response"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Compression::flush",
          "args": [
            "&output"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "flush",
          "container": "SnappyCompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "161-161",
          "snippet": "static void flush(OutputStream*) {}",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSnappyCompressed {\n  static void flush(OutputStream*) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Compression::write",
          "args": [
            "request",
            "&output"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "SnappyCompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "134-147",
          "snippet": "static uint64_t write(const google::protobuf::MessageLite& message, int* output) {\n    size_t size = message.ByteSize();\n    GOOGLE_CHECK_LE(size, sizeof(scratch));\n\n    message.SerializeWithCachedSizesToArray(reinterpret_cast<uint8_t*>(scratch));\n\n    size_t compressedSize = 0;\n    snappy::RawCompress(scratch, size, scratch2 + sizeof(uint32_t), &compressedSize);\n    uint32_t tag = compressedSize;\n    memcpy(scratch2, &tag, sizeof(tag));\n\n    writeAll(*output, scratch2, compressedSize + sizeof(tag));\n    return compressedSize + sizeof(tag);\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSnappyCompressed {\n  static uint64_t write(const google::protobuf::MessageLite& message, int* output) {\n      size_t size = message.ByteSize();\n      GOOGLE_CHECK_LE(size, sizeof(scratch));\n  \n      message.SerializeWithCachedSizesToArray(reinterpret_cast<uint8_t*>(scratch));\n  \n      size_t compressedSize = 0;\n      snappy::RawCompress(scratch, size, scratch2 + sizeof(uint32_t), &compressedSize);\n      uint32_t tag = compressedSize;\n      memcpy(scratch2, &tag, sizeof(tag));\n  \n      writeAll(*output, scratch2, compressedSize + sizeof(tag));\n      return compressedSize + sizeof(tag);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestCase::setupRequest",
          "args": [
            "&request"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "setupRequest",
          "container": "CatRankTestCase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-catrank.c++",
          "lines": "45-91",
          "snippet": "static int setupRequest(SearchResultList::Builder request) {\n    int count = fastRand(1000);\n    int goodCount = 0;\n\n    auto list = request.initResults(count);\n\n    for (int i = 0; i < count; i++) {\n      SearchResult::Builder result = list[i];\n      result.setScore(1000 - i);\n      int urlSize = fastRand(100);\n\n      static const char URL_PREFIX[] = \"http://example.com/\";\n      size_t urlPrefixLength = strlen(URL_PREFIX);\n      auto url = result.initUrl(urlSize + urlPrefixLength);\n\n      strcpy(url.begin(), URL_PREFIX);\n      char* pos = url.begin() + urlPrefixLength;\n      for (int j = 0; j < urlSize; j++) {\n        *pos++ = 'a' + fastRand(26);\n      }\n\n      bool isCat = fastRand(8) == 0;\n      bool isDog = fastRand(8) == 0;\n      goodCount += isCat && !isDog;\n\n      static std::string snippet;\n      snippet.clear();\n      snippet.push_back(' ');\n\n      int prefix = fastRand(20);\n      for (int j = 0; j < prefix; j++) {\n        snippet.append(WORDS[fastRand(WORDS_COUNT)]);\n      }\n\n      if (isCat) snippet.append(\"cat \");\n      if (isDog) snippet.append(\"dog \");\n\n      int suffix = fastRand(20);\n      for (int j = 0; j < suffix; j++) {\n        snippet.append(WORDS[fastRand(WORDS_COUNT)]);\n      }\n\n      result.setSnippet(Text::Reader(snippet.c_str(), snippet.size()));\n    }\n\n    return goodCount;\n  }",
          "includes": [
            "#include \"capnproto-common.h\"",
            "#include \"catrank.capnp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"catrank.capnp.h\"\n\nCatRankTestCase {\n  static int setupRequest(SearchResultList::Builder request) {\n      int count = fastRand(1000);\n      int goodCount = 0;\n  \n      auto list = request.initResults(count);\n  \n      for (int i = 0; i < count; i++) {\n        SearchResult::Builder result = list[i];\n        result.setScore(1000 - i);\n        int urlSize = fastRand(100);\n  \n        static const char URL_PREFIX[] = \"http://example.com/\";\n        size_t urlPrefixLength = strlen(URL_PREFIX);\n        auto url = result.initUrl(urlSize + urlPrefixLength);\n  \n        strcpy(url.begin(), URL_PREFIX);\n        char* pos = url.begin() + urlPrefixLength;\n        for (int j = 0; j < urlSize; j++) {\n          *pos++ = 'a' + fastRand(26);\n        }\n  \n        bool isCat = fastRand(8) == 0;\n        bool isDog = fastRand(8) == 0;\n        goodCount += isCat && !isDog;\n  \n        static std::string snippet;\n        snippet.clear();\n        snippet.push_back(' ');\n  \n        int prefix = fastRand(20);\n        for (int j = 0; j < prefix; j++) {\n          snippet.append(WORDS[fastRand(WORDS_COUNT)]);\n        }\n  \n        if (isCat) snippet.append(\"cat \");\n        if (isDog) snippet.append(\"dog \");\n  \n        int suffix = fastRand(20);\n        for (int j = 0; j < suffix; j++) {\n          snippet.append(WORDS[fastRand(WORDS_COUNT)]);\n        }\n  \n        result.setSnippet(Text::Reader(snippet.c_str(), snippet.size()));\n      }\n  \n      return goodCount;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "request",
          "args": [
            "reusableRequest"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SINGLE_USE",
          "args": [
            "Request"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REUSABLE",
          "args": [
            "Response"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REUSABLE",
          "args": [
            "Request"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nBenchmarkMethods {\n  static uint64_t syncClient(int inputFd, int outputFd, uint64_t iters) {\n      uint64_t throughput = 0;\n  \n      typename Compression::OutputStream output(outputFd);\n      typename Compression::InputStream input(inputFd);\n  \n      REUSABLE(Request) reusableRequest;\n      REUSABLE(Response) reusableResponse;\n  \n      for (; iters > 0; --iters) {\n        SINGLE_USE(Request) request(reusableRequest);\n        typename TestCase::Expectation expected = TestCase::setupRequest(&request);\n        throughput += Compression::write(request, &output);\n        Compression::flush(&output);\n        ReuseStrategy::doneWith(request);\n  \n        SINGLE_USE(Response) response(reusableResponse);\n        Compression::read(&input, &response);\n        if (!TestCase::checkResponse(response, expected)) {\n          throw std::logic_error(\"Incorrect response.\");\n        }\n        ReuseStrategy::doneWith(response);\n      }\n  \n      return throughput;\n    }\n}"
  },
  {
    "function_name": "flush",
    "container": "SnappyCompressed",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
    "lines": "161-161",
    "snippet": "static void flush(OutputStream*) {}",
    "includes": [
      "#include <snappy/snappy-sinksource.h>",
      "#include <snappy/snappy.h>",
      "#include <thread>",
      "#include <google/protobuf/io/coded_stream.h>",
      "#include <google/protobuf/io/zero_copy_stream_impl.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSnappyCompressed {\n  static void flush(OutputStream*) {}\n}"
  },
  {
    "function_name": "read",
    "container": "SnappyCompressed",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
    "lines": "149-159",
    "snippet": "static void read(int* input, google::protobuf::MessageLite* message) {\n    uint32_t size;\n    readAll(*input, &size, sizeof(size));\n    readAll(*input, scratch, size);\n\n    size_t uncompressedSize;\n    GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n    GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n\n    GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n  }",
    "includes": [
      "#include <snappy/snappy-sinksource.h>",
      "#include <snappy/snappy.h>",
      "#include <thread>",
      "#include <google/protobuf/io/coded_stream.h>",
      "#include <google/protobuf/io/zero_copy_stream_impl.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GOOGLE_CHECK",
          "args": [
            "message->ParsePartialFromArray(scratch2, uncompressedSize)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message->ParsePartialFromArray",
          "args": [
            "scratch2",
            "uncompressedSize"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GOOGLE_CHECK",
          "args": [
            "snappy::RawUncompress(scratch, size, scratch2)"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snappy::RawUncompress",
          "args": [
            "scratch",
            "size",
            "scratch2"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GOOGLE_CHECK",
          "args": [
            "snappy::GetUncompressedLength(scratch, size, &uncompressedSize)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snappy::GetUncompressedLength",
          "args": [
            "scratch",
            "size",
            "&uncompressedSize"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readAll",
          "args": [
            "*input",
            "scratch",
            "size"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "readAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "168-178",
          "snippet": "static void readAll(int fd, void* buffer, size_t size) {\n  char* pos = reinterpret_cast<char*>(buffer);\n  while (size > 0) {\n    ssize_t n = read(fd, pos, size);\n    if (n <= 0) {\n      throw OsException(errno);\n    }\n    pos += n;\n    size -= n;\n  }\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nstatic void readAll(int fd, void* buffer, size_t size) {\n  char* pos = reinterpret_cast<char*>(buffer);\n  while (size > 0) {\n    ssize_t n = read(fd, pos, size);\n    if (n <= 0) {\n      throw OsException(errno);\n    }\n    pos += n;\n    size -= n;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSnappyCompressed {\n  static void read(int* input, google::protobuf::MessageLite* message) {\n      uint32_t size;\n      readAll(*input, &size, sizeof(size));\n      readAll(*input, scratch, size);\n  \n      size_t uncompressedSize;\n      GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n      GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n  \n      GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n    }\n}"
  },
  {
    "function_name": "write",
    "container": "SnappyCompressed",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
    "lines": "134-147",
    "snippet": "static uint64_t write(const google::protobuf::MessageLite& message, int* output) {\n    size_t size = message.ByteSize();\n    GOOGLE_CHECK_LE(size, sizeof(scratch));\n\n    message.SerializeWithCachedSizesToArray(reinterpret_cast<uint8_t*>(scratch));\n\n    size_t compressedSize = 0;\n    snappy::RawCompress(scratch, size, scratch2 + sizeof(uint32_t), &compressedSize);\n    uint32_t tag = compressedSize;\n    memcpy(scratch2, &tag, sizeof(tag));\n\n    writeAll(*output, scratch2, compressedSize + sizeof(tag));\n    return compressedSize + sizeof(tag);\n  }",
    "includes": [
      "#include <snappy/snappy-sinksource.h>",
      "#include <snappy/snappy.h>",
      "#include <thread>",
      "#include <google/protobuf/io/coded_stream.h>",
      "#include <google/protobuf/io/zero_copy_stream_impl.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeAll",
          "args": [
            "*output",
            "scratch2",
            "compressedSize + sizeof(tag)"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "writeAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "156-166",
          "snippet": "static void writeAll(int fd, const void* buffer, size_t size) {\n  const char* pos = reinterpret_cast<const char*>(buffer);\n  while (size > 0) {\n    ssize_t n = write(fd, pos, size);\n    if (n <= 0) {\n      throw OsException(errno);\n    }\n    pos += n;\n    size -= n;\n  }\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nstatic void writeAll(int fd, const void* buffer, size_t size) {\n  const char* pos = reinterpret_cast<const char*>(buffer);\n  while (size > 0) {\n    ssize_t n = write(fd, pos, size);\n    if (n <= 0) {\n      throw OsException(errno);\n    }\n    pos += n;\n    size -= n;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "scratch2",
            "&tag",
            "sizeof(tag)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snappy::RawCompress",
          "args": [
            "scratch",
            "size",
            "scratch2 + sizeof(uint32_t)",
            "&compressedSize"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.SerializeWithCachedSizesToArray",
          "args": [
            "reinterpret_cast<uint8_t*>(scratch)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<uint8_t*>",
          "args": [
            "scratch"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GOOGLE_CHECK_LE",
          "args": [
            "size",
            "sizeof(scratch)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.ByteSize",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSnappyCompressed {\n  static uint64_t write(const google::protobuf::MessageLite& message, int* output) {\n      size_t size = message.ByteSize();\n      GOOGLE_CHECK_LE(size, sizeof(scratch));\n  \n      message.SerializeWithCachedSizesToArray(reinterpret_cast<uint8_t*>(scratch));\n  \n      size_t compressedSize = 0;\n      snappy::RawCompress(scratch, size, scratch2 + sizeof(uint32_t), &compressedSize);\n      uint32_t tag = compressedSize;\n      memcpy(scratch2, &tag, sizeof(tag));\n  \n      writeAll(*output, scratch2, compressedSize + sizeof(tag));\n      return compressedSize + sizeof(tag);\n    }\n}"
  },
  {
    "function_name": "flush",
    "container": "Uncompressed",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
    "lines": "115-117",
    "snippet": "static void flush(google::protobuf::io::FileOutputStream* output) {\n    if (!output->Flush()) throw OsException(output->GetErrno());\n  }",
    "includes": [
      "#include <snappy/snappy-sinksource.h>",
      "#include <snappy/snappy.h>",
      "#include <thread>",
      "#include <google/protobuf/io/coded_stream.h>",
      "#include <google/protobuf/io/zero_copy_stream_impl.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OsException",
          "args": [
            "output->GetErrno()"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "OsException",
          "container": "OsException",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "145-145",
          "snippet": "OsException(int error): error(error) {}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nOsException {\n  OsException(int error): error(error) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "output->GetErrno",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output->Flush",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nUncompressed {\n  static void flush(google::protobuf::io::FileOutputStream* output) {\n      if (!output->Flush()) throw OsException(output->GetErrno());\n    }\n}"
  },
  {
    "function_name": "read",
    "container": "Uncompressed",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
    "lines": "101-113",
    "snippet": "static void read(google::protobuf::io::ZeroCopyInputStream* rawInput,\n                   google::protobuf::MessageLite* message) {\n    google::protobuf::io::CodedInputStream input(rawInput);\n    uint32_t size;\n    GOOGLE_CHECK(input.ReadVarint32(&size));\n\n    auto limit = input.PushLimit(size);\n\n    GOOGLE_CHECK(message->MergePartialFromCodedStream(&input) &&\n                 input.ConsumedEntireMessage());\n\n    input.PopLimit(limit);\n  }",
    "includes": [
      "#include <snappy/snappy-sinksource.h>",
      "#include <snappy/snappy.h>",
      "#include <thread>",
      "#include <google/protobuf/io/coded_stream.h>",
      "#include <google/protobuf/io/zero_copy_stream_impl.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "input.PopLimit",
          "args": [
            "limit"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GOOGLE_CHECK",
          "args": [
            "message->MergePartialFromCodedStream(&input) &&\n                 input.ConsumedEntireMessage()"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.ConsumedEntireMessage",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message->MergePartialFromCodedStream",
          "args": [
            "&input"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.PushLimit",
          "args": [
            "size"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GOOGLE_CHECK",
          "args": [
            "input.ReadVarint32(&size)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.ReadVarint32",
          "args": [
            "&size"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nUncompressed {\n  static void read(google::protobuf::io::ZeroCopyInputStream* rawInput,\n                     google::protobuf::MessageLite* message) {\n      google::protobuf::io::CodedInputStream input(rawInput);\n      uint32_t size;\n      GOOGLE_CHECK(input.ReadVarint32(&size));\n  \n      auto limit = input.PushLimit(size);\n  \n      GOOGLE_CHECK(message->MergePartialFromCodedStream(&input) &&\n                   input.ConsumedEntireMessage());\n  \n      input.PopLimit(limit);\n    }\n}"
  },
  {
    "function_name": "write",
    "container": "Uncompressed",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
    "lines": "83-99",
    "snippet": "static uint64_t write(const google::protobuf::MessageLite& message,\n                        google::protobuf::io::FileOutputStream* rawOutput) {\n    google::protobuf::io::CodedOutputStream output(rawOutput);\n    const int size = message.ByteSize();\n    output.WriteVarint32(size);\n    uint8_t* buffer = output.GetDirectBufferForNBytesAndAdvance(size);\n    if (buffer != NULL) {\n      message.SerializeWithCachedSizesToArray(buffer);\n    } else {\n      message.SerializeWithCachedSizes(&output);\n      if (output.HadError()) {\n        throw OsException(rawOutput->GetErrno());\n      }\n    }\n\n    return size;\n  }",
    "includes": [
      "#include <snappy/snappy-sinksource.h>",
      "#include <snappy/snappy.h>",
      "#include <thread>",
      "#include <google/protobuf/io/coded_stream.h>",
      "#include <google/protobuf/io/zero_copy_stream_impl.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OsException",
          "args": [
            "rawOutput->GetErrno()"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "OsException",
          "container": "OsException",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "145-145",
          "snippet": "OsException(int error): error(error) {}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nOsException {\n  OsException(int error): error(error) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rawOutput->GetErrno",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.HadError",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.SerializeWithCachedSizes",
          "args": [
            "&output"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.SerializeWithCachedSizesToArray",
          "args": [
            "buffer"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.GetDirectBufferForNBytesAndAdvance",
          "args": [
            "size"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.WriteVarint32",
          "args": [
            "size"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.ByteSize",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nUncompressed {\n  static uint64_t write(const google::protobuf::MessageLite& message,\n                          google::protobuf::io::FileOutputStream* rawOutput) {\n      google::protobuf::io::CodedOutputStream output(rawOutput);\n      const int size = message.ByteSize();\n      output.WriteVarint32(size);\n      uint8_t* buffer = output.GetDirectBufferForNBytesAndAdvance(size);\n      if (buffer != NULL) {\n        message.SerializeWithCachedSizesToArray(buffer);\n      } else {\n        message.SerializeWithCachedSizes(&output);\n        if (output.HadError()) {\n          throw OsException(rawOutput->GetErrno());\n        }\n      }\n  \n      return size;\n    }\n}"
  },
  {
    "function_name": "doneWith",
    "container": "ReusableMessages",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
    "lines": "68-70",
    "snippet": "static inline void doneWith(MessageType& message) {\n    message.Clear();\n  }",
    "includes": [
      "#include <snappy/snappy-sinksource.h>",
      "#include <snappy/snappy.h>",
      "#include <thread>",
      "#include <google/protobuf/io/coded_stream.h>",
      "#include <google/protobuf/io/zero_copy_stream_impl.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "message.Clear",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nReusableMessages {\n  static inline void doneWith(MessageType& message) {\n      message.Clear();\n    }\n}"
  },
  {
    "function_name": "doneWith",
    "container": "SingleUseMessages",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
    "lines": "52-54",
    "snippet": "static inline void doneWith(MessageType& message) {\n    // Don't clear -- single-use.\n  }",
    "includes": [
      "#include <snappy/snappy-sinksource.h>",
      "#include <snappy/snappy.h>",
      "#include <thread>",
      "#include <google/protobuf/io/coded_stream.h>",
      "#include <google/protobuf/io/zero_copy_stream_impl.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSingleUseMessages {\n  static inline void doneWith(MessageType& message) {\n      // Don't clear -- single-use.\n    }\n}"
  },
  {
    "function_name": "SingleUseString",
    "container": "SingleUseMessages::SingleUseString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
    "lines": "48-48",
    "snippet": "inline SingleUseString(ReusableString&) {}",
    "includes": [
      "#include <snappy/snappy-sinksource.h>",
      "#include <snappy/snappy.h>",
      "#include <thread>",
      "#include <google/protobuf/io/coded_stream.h>",
      "#include <google/protobuf/io/zero_copy_stream_impl.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSingleUseMessages {\n  SingleUseString {\n    inline SingleUseString(ReusableString&) {}\n  }\n}"
  },
  {
    "function_name": "SingleUse",
    "container": "SingleUseMessages::Message::SingleUse",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
    "lines": "42-42",
    "snippet": "inline SingleUse(Reusable&) {}",
    "includes": [
      "#include <snappy/snappy-sinksource.h>",
      "#include <snappy/snappy.h>",
      "#include <thread>",
      "#include <google/protobuf/io/coded_stream.h>",
      "#include <google/protobuf/io/zero_copy_stream_impl.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSingleUseMessages {\n  Message {\n    SingleUse {\n      inline SingleUse(Reusable&) {}\n    }\n  }\n}"
  }
]