[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-eval.c++",
    "lines": "151-155",
    "snippet": "int main(int argc, char* argv[]) {\n  return capnp::benchmark::benchmarkMain<\n      capnp::benchmark::null::BenchmarkTypes,\n      capnp::benchmark::null::ExpressionTestCase>(argc, argv);\n}",
    "includes": [
      "#include \"null-common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capnp::benchmark::benchmarkMain<\n      capnp::benchmark::null::BenchmarkTypes,\n      capnp::benchmark::null::ExpressionTestCase>",
          "args": [
            "argc",
            "argv"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "benchmarkMain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "281-292",
          "snippet": "int benchmarkMain(int argc, char* argv[]) {\n  if (argc != 5) {\n    fprintf(stderr, \"USAGE:  %s MODE REUSE COMPRESSION ITERATION_COUNT\\n\", argv[0]);\n    return 1;\n  }\n\n  uint64_t iters = strtoull(argv[4], nullptr, 0);\n  uint64_t throughput = doBenchmark3<BenchmarkTypes, TestCase>(argv[1], argv[2], argv[3], iters);\n  fprintf(stdout, \"%llu\\n\", (long long unsigned int)throughput);\n\n  return 0;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nint benchmarkMain(int argc, char* argv[]) {\n  if (argc != 5) {\n    fprintf(stderr, \"USAGE:  %s MODE REUSE COMPRESSION ITERATION_COUNT\\n\", argv[0]);\n    return 1;\n  }\n\n  uint64_t iters = strtoull(argv[4], nullptr, 0);\n  uint64_t throughput = doBenchmark3<BenchmarkTypes, TestCase>(argv[1], argv[2], argv[3], iters);\n  fprintf(stdout, \"%llu\\n\", (long long unsigned int)throughput);\n\n  return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"null-common.h\"\n\nint main(int argc, char* argv[]) {\n  return capnp::benchmark::benchmarkMain<\n      capnp::benchmark::null::BenchmarkTypes,\n      capnp::benchmark::null::ExpressionTestCase>(argc, argv);\n}"
  },
  {
    "function_name": "spaceUsed",
    "container": "ExpressionTestCase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-eval.c++",
    "lines": "140-144",
    "snippet": "static size_t spaceUsed(const Expression& expression) {\n    return sizeof(Expression) +\n        (expression.leftExpression == nullptr ? 0 : spaceUsed(*expression.leftExpression)) +\n        (expression.rightExpression == nullptr ? 0 : spaceUsed(*expression.rightExpression));\n  }",
    "includes": [
      "#include \"null-common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"null-common.h\"\n\nExpressionTestCase {\n  static size_t spaceUsed(const Expression& expression) {\n      return sizeof(Expression) +\n          (expression.leftExpression == nullptr ? 0 : spaceUsed(*expression.leftExpression)) +\n          (expression.rightExpression == nullptr ? 0 : spaceUsed(*expression.rightExpression));\n    }\n}"
  },
  {
    "function_name": "checkResponse",
    "container": "ExpressionTestCase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-eval.c++",
    "lines": "136-138",
    "snippet": "static inline bool checkResponse(int32_t response, int32_t expected) {\n    return response == expected;\n  }",
    "includes": [
      "#include \"null-common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"null-common.h\"\n\nExpressionTestCase {\n  static inline bool checkResponse(int32_t response, int32_t expected) {\n      return response == expected;\n    }\n}"
  },
  {
    "function_name": "handleRequest",
    "container": "ExpressionTestCase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-eval.c++",
    "lines": "133-135",
    "snippet": "static inline void handleRequest(const Expression& request, int32_t* response) {\n    *response = evaluateExpression(request);\n  }",
    "includes": [
      "#include \"null-common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "evaluateExpression",
          "args": [
            "request"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "evaluateExpression",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-eval.c++",
          "lines": "94-122",
          "snippet": "int32_t evaluateExpression(const Expression& exp) {\n  uint32_t left, right;\n\n  if (exp.leftIsValue) {\n    left = exp.leftValue;\n  } else {\n    left = evaluateExpression(*exp.leftExpression);\n  }\n\n  if (exp.rightIsValue) {\n    right = exp.rightValue;\n  } else {\n    right = evaluateExpression(*exp.rightExpression);\n  }\n\n  switch (exp.op) {\n    case Operation::ADD:\n      return left + right;\n    case Operation::SUBTRACT:\n      return left - right;\n    case Operation::MULTIPLY:\n      return left * right;\n    case Operation::DIVIDE:\n      return div(left, right);\n    case Operation::MODULUS:\n      return mod(left, right);\n  }\n  throw std::logic_error(\"Can't get here.\");\n}",
          "includes": [
            "#include \"null-common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"null-common.h\"\n\nint32_t evaluateExpression(const Expression& exp) {\n  uint32_t left, right;\n\n  if (exp.leftIsValue) {\n    left = exp.leftValue;\n  } else {\n    left = evaluateExpression(*exp.leftExpression);\n  }\n\n  if (exp.rightIsValue) {\n    right = exp.rightValue;\n  } else {\n    right = evaluateExpression(*exp.rightExpression);\n  }\n\n  switch (exp.op) {\n    case Operation::ADD:\n      return left + right;\n    case Operation::SUBTRACT:\n      return left - right;\n    case Operation::MULTIPLY:\n      return left * right;\n    case Operation::DIVIDE:\n      return div(left, right);\n    case Operation::MODULUS:\n      return mod(left, right);\n  }\n  throw std::logic_error(\"Can't get here.\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"null-common.h\"\n\nExpressionTestCase {\n  static inline void handleRequest(const Expression& request, int32_t* response) {\n      *response = evaluateExpression(request);\n    }\n}"
  },
  {
    "function_name": "setupRequest",
    "container": "ExpressionTestCase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-eval.c++",
    "lines": "130-132",
    "snippet": "static inline int32_t setupRequest(Expression* request) {\n    return makeExpression(request, 0);\n  }",
    "includes": [
      "#include \"null-common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeExpression",
          "args": [
            "request",
            "0"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "makeExpression",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-eval.c++",
          "lines": "54-92",
          "snippet": "int32_t makeExpression(Expression* exp, uint depth) {\n  exp->op = (Operation)(fastRand(OPERATION_RANGE));\n\n  int32_t left, right;\n\n  if (fastRand(8) < depth) {\n    exp->leftIsValue = true;\n    left = fastRand(128) + 1;\n    exp->leftValue = left;\n  } else {\n    exp->leftIsValue = false;\n    exp->leftExpression = allocate<Expression>();\n    left = makeExpression(exp->leftExpression, depth + 1);\n  }\n\n  if (fastRand(8) < depth) {\n    exp->rightIsValue = true;\n    right = fastRand(128) + 1;\n    exp->rightValue = right;\n  } else {\n    exp->rightIsValue = false;\n    exp->rightExpression = allocate<Expression>();\n    right = makeExpression(exp->rightExpression, depth + 1);\n  }\n\n  switch (exp->op) {\n    case Operation::ADD:\n      return left + right;\n    case Operation::SUBTRACT:\n      return left - right;\n    case Operation::MULTIPLY:\n      return left * right;\n    case Operation::DIVIDE:\n      return div(left, right);\n    case Operation::MODULUS:\n      return mod(left, right);\n  }\n  throw std::logic_error(\"Can't get here.\");\n}",
          "includes": [
            "#include \"null-common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"null-common.h\"\n\nint32_t makeExpression(Expression* exp, uint depth) {\n  exp->op = (Operation)(fastRand(OPERATION_RANGE));\n\n  int32_t left, right;\n\n  if (fastRand(8) < depth) {\n    exp->leftIsValue = true;\n    left = fastRand(128) + 1;\n    exp->leftValue = left;\n  } else {\n    exp->leftIsValue = false;\n    exp->leftExpression = allocate<Expression>();\n    left = makeExpression(exp->leftExpression, depth + 1);\n  }\n\n  if (fastRand(8) < depth) {\n    exp->rightIsValue = true;\n    right = fastRand(128) + 1;\n    exp->rightValue = right;\n  } else {\n    exp->rightIsValue = false;\n    exp->rightExpression = allocate<Expression>();\n    right = makeExpression(exp->rightExpression, depth + 1);\n  }\n\n  switch (exp->op) {\n    case Operation::ADD:\n      return left + right;\n    case Operation::SUBTRACT:\n      return left - right;\n    case Operation::MULTIPLY:\n      return left * right;\n    case Operation::DIVIDE:\n      return div(left, right);\n    case Operation::MODULUS:\n      return mod(left, right);\n  }\n  throw std::logic_error(\"Can't get here.\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"null-common.h\"\n\nExpressionTestCase {\n  static inline int32_t setupRequest(Expression* request) {\n      return makeExpression(request, 0);\n    }\n}"
  },
  {
    "function_name": "evaluateExpression",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-eval.c++",
    "lines": "94-122",
    "snippet": "int32_t evaluateExpression(const Expression& exp) {\n  uint32_t left, right;\n\n  if (exp.leftIsValue) {\n    left = exp.leftValue;\n  } else {\n    left = evaluateExpression(*exp.leftExpression);\n  }\n\n  if (exp.rightIsValue) {\n    right = exp.rightValue;\n  } else {\n    right = evaluateExpression(*exp.rightExpression);\n  }\n\n  switch (exp.op) {\n    case Operation::ADD:\n      return left + right;\n    case Operation::SUBTRACT:\n      return left - right;\n    case Operation::MULTIPLY:\n      return left * right;\n    case Operation::DIVIDE:\n      return div(left, right);\n    case Operation::MODULUS:\n      return mod(left, right);\n  }\n  throw std::logic_error(\"Can't get here.\");\n}",
    "includes": [
      "#include \"null-common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::logic_error",
          "args": [
            "\"Can't get here.\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod",
          "args": [
            "left",
            "right"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "81-88",
          "snippet": "inline int32_t mod(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN % -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a % b;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\ninline int32_t mod(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN % -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a % b;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div",
          "args": [
            "left",
            "right"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "div",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "72-79",
          "snippet": "inline int32_t div(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN / -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a / b;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\ninline int32_t div(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN / -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a / b;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"null-common.h\"\n\nint32_t evaluateExpression(const Expression& exp) {\n  uint32_t left, right;\n\n  if (exp.leftIsValue) {\n    left = exp.leftValue;\n  } else {\n    left = evaluateExpression(*exp.leftExpression);\n  }\n\n  if (exp.rightIsValue) {\n    right = exp.rightValue;\n  } else {\n    right = evaluateExpression(*exp.rightExpression);\n  }\n\n  switch (exp.op) {\n    case Operation::ADD:\n      return left + right;\n    case Operation::SUBTRACT:\n      return left - right;\n    case Operation::MULTIPLY:\n      return left * right;\n    case Operation::DIVIDE:\n      return div(left, right);\n    case Operation::MODULUS:\n      return mod(left, right);\n  }\n  throw std::logic_error(\"Can't get here.\");\n}"
  },
  {
    "function_name": "makeExpression",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-eval.c++",
    "lines": "54-92",
    "snippet": "int32_t makeExpression(Expression* exp, uint depth) {\n  exp->op = (Operation)(fastRand(OPERATION_RANGE));\n\n  int32_t left, right;\n\n  if (fastRand(8) < depth) {\n    exp->leftIsValue = true;\n    left = fastRand(128) + 1;\n    exp->leftValue = left;\n  } else {\n    exp->leftIsValue = false;\n    exp->leftExpression = allocate<Expression>();\n    left = makeExpression(exp->leftExpression, depth + 1);\n  }\n\n  if (fastRand(8) < depth) {\n    exp->rightIsValue = true;\n    right = fastRand(128) + 1;\n    exp->rightValue = right;\n  } else {\n    exp->rightIsValue = false;\n    exp->rightExpression = allocate<Expression>();\n    right = makeExpression(exp->rightExpression, depth + 1);\n  }\n\n  switch (exp->op) {\n    case Operation::ADD:\n      return left + right;\n    case Operation::SUBTRACT:\n      return left - right;\n    case Operation::MULTIPLY:\n      return left * right;\n    case Operation::DIVIDE:\n      return div(left, right);\n    case Operation::MODULUS:\n      return mod(left, right);\n  }\n  throw std::logic_error(\"Can't get here.\");\n}",
    "includes": [
      "#include \"null-common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::logic_error",
          "args": [
            "\"Can't get here.\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod",
          "args": [
            "left",
            "right"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "81-88",
          "snippet": "inline int32_t mod(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN % -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a % b;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\ninline int32_t mod(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN % -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a % b;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div",
          "args": [
            "left",
            "right"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "div",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "72-79",
          "snippet": "inline int32_t div(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN / -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a / b;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\ninline int32_t div(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN / -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a / b;\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate<Expression>",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fastRand",
          "args": [
            "128"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "fastRand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "64-66",
          "snippet": "static inline uint32_t fastRand(uint32_t range) {\n  return nextFastRand() % range;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nstatic inline uint32_t fastRand(uint32_t range) {\n  return nextFastRand() % range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate<Expression>",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "fastRand(OPERATION_RANGE)"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"null-common.h\"\n\nint32_t makeExpression(Expression* exp, uint depth) {\n  exp->op = (Operation)(fastRand(OPERATION_RANGE));\n\n  int32_t left, right;\n\n  if (fastRand(8) < depth) {\n    exp->leftIsValue = true;\n    left = fastRand(128) + 1;\n    exp->leftValue = left;\n  } else {\n    exp->leftIsValue = false;\n    exp->leftExpression = allocate<Expression>();\n    left = makeExpression(exp->leftExpression, depth + 1);\n  }\n\n  if (fastRand(8) < depth) {\n    exp->rightIsValue = true;\n    right = fastRand(128) + 1;\n    exp->rightValue = right;\n  } else {\n    exp->rightIsValue = false;\n    exp->rightExpression = allocate<Expression>();\n    right = makeExpression(exp->rightExpression, depth + 1);\n  }\n\n  switch (exp->op) {\n    case Operation::ADD:\n      return left + right;\n    case Operation::SUBTRACT:\n      return left - right;\n    case Operation::MULTIPLY:\n      return left * right;\n    case Operation::DIVIDE:\n      return div(left, right);\n    case Operation::MODULUS:\n      return mod(left, right);\n  }\n  throw std::logic_error(\"Can't get here.\");\n}"
  }
]