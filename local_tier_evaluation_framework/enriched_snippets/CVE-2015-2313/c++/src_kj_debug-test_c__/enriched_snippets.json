[
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
    "lines": "382-424",
    "snippet": "TEST(Debug, Context) {\n  MockExceptionCallback mockCallback;\n\n  {\n    KJ_CONTEXT(\"foo\"); int cline = __LINE__;\n\n    KJ_LOG(WARNING, \"blah\"); int line = __LINE__;\n    EXPECT_EQ(\"log message: \" + fileLine(__FILE__, cline) + \":+0: context: foo\\n\"\n              \"log message: \" + fileLine(__FILE__, line) + \":+1: warning: blah\\n\",\n              mockCallback.text);\n    mockCallback.text.clear();\n\n    EXPECT_FATAL(KJ_FAIL_ASSERT(\"bar\")); line = __LINE__;\n    EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, cline) + \": context: foo\\n\"\n              + fileLine(__FILE__, line) + \": failed: bar\\n\",\n              mockCallback.text);\n    mockCallback.text.clear();\n\n    {\n      int i = 123;\n      const char* str = \"qux\";\n      KJ_CONTEXT(\"baz\", i, \"corge\", str); int cline2 = __LINE__;\n      EXPECT_FATAL(KJ_FAIL_ASSERT(\"bar\")); line = __LINE__;\n\n      EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, cline) + \": context: foo\\n\"\n                + fileLine(__FILE__, cline2) + \": context: baz; i = 123; corge; str = qux\\n\"\n                + fileLine(__FILE__, line) + \": failed: bar\\n\",\n                mockCallback.text);\n      mockCallback.text.clear();\n    }\n\n    {\n      KJ_CONTEXT(\"grault\"); int cline2 = __LINE__;\n      EXPECT_FATAL(KJ_FAIL_ASSERT(\"bar\")); line = __LINE__;\n\n      EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, cline) + \": context: foo\\n\"\n                + fileLine(__FILE__, cline2) + \": context: grault\\n\"\n                + fileLine(__FILE__, line) + \": failed: bar\\n\",\n                mockCallback.text);\n      mockCallback.text.clear();\n    }\n  }\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include \"miniposix.h\"",
      "#include <exception>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdio.h>",
      "#include <string>",
      "#include <kj/compat/gtest.h>",
      "#include \"exception.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mockCallback.text.clear",
          "args": [],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "TestPipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed-test.c++",
          "lines": "51-54",
          "snippet": "void clear(size_t preferredReadSize = kj::maxValue) {\n    resetRead(preferredReadSize);\n    data.clear();\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <stdlib.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"serialize-packed.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <stdlib.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nTestPipe {\n  void clear(size_t preferredReadSize = kj::maxValue) {\n      resetRead(preferredReadSize);\n      data.clear();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"fatal exception: \" + fileLine(__FILE__, cline) + \": context: foo\\n\"\n                + fileLine(__FILE__, cline2) + \": context: grault\\n\"\n                + fileLine(__FILE__, line) + \": failed: bar\\n\"",
            "mockCallback.text"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileLine",
          "args": [
            "__FILE__",
            "line"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "fileLine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
          "lines": "184-190",
          "snippet": "std::string fileLine(std::string file, int line) {\n  file += ':';\n  char buffer[32];\n  sprintf(buffer, \"%d\", line);\n  file += buffer;\n  return file;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include \"miniposix.h\"",
            "#include <exception>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdio.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include \"exception.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nstd::string fileLine(std::string file, int line) {\n  file += ':';\n  char buffer[32];\n  sprintf(buffer, \"%d\", line);\n  file += buffer;\n  return file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_FATAL",
          "args": [
            "KJ_FAIL_ASSERT(\"bar\")"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"bar\""
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_CONTEXT",
          "args": [
            "\"grault\""
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"fatal exception: \" + fileLine(__FILE__, cline) + \": context: foo\\n\"\n                + fileLine(__FILE__, cline2) + \": context: baz; i = 123; corge; str = qux\\n\"\n                + fileLine(__FILE__, line) + \": failed: bar\\n\"",
            "mockCallback.text"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FATAL",
          "args": [
            "KJ_FAIL_ASSERT(\"bar\")"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"bar\""
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_CONTEXT",
          "args": [
            "\"baz\"",
            "i",
            "\"corge\"",
            "str"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"fatal exception: \" + fileLine(__FILE__, cline) + \": context: foo\\n\"\n              + fileLine(__FILE__, line) + \": failed: bar\\n\"",
            "mockCallback.text"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FATAL",
          "args": [
            "KJ_FAIL_ASSERT(\"bar\")"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"bar\""
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"log message: \" + fileLine(__FILE__, cline) + \":+0: context: foo\\n\"\n              \"log message: \" + fileLine(__FILE__, line) + \":+1: warning: blah\\n\"",
            "mockCallback.text"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "WARNING",
            "\"blah\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_CONTEXT",
          "args": [
            "\"foo\""
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nTEST(Debug, Context) {\n  MockExceptionCallback mockCallback;\n\n  {\n    KJ_CONTEXT(\"foo\"); int cline = __LINE__;\n\n    KJ_LOG(WARNING, \"blah\"); int line = __LINE__;\n    EXPECT_EQ(\"log message: \" + fileLine(__FILE__, cline) + \":+0: context: foo\\n\"\n              \"log message: \" + fileLine(__FILE__, line) + \":+1: warning: blah\\n\",\n              mockCallback.text);\n    mockCallback.text.clear();\n\n    EXPECT_FATAL(KJ_FAIL_ASSERT(\"bar\")); line = __LINE__;\n    EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, cline) + \": context: foo\\n\"\n              + fileLine(__FILE__, line) + \": failed: bar\\n\",\n              mockCallback.text);\n    mockCallback.text.clear();\n\n    {\n      int i = 123;\n      const char* str = \"qux\";\n      KJ_CONTEXT(\"baz\", i, \"corge\", str); int cline2 = __LINE__;\n      EXPECT_FATAL(KJ_FAIL_ASSERT(\"bar\")); line = __LINE__;\n\n      EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, cline) + \": context: foo\\n\"\n                + fileLine(__FILE__, cline2) + \": context: baz; i = 123; corge; str = qux\\n\"\n                + fileLine(__FILE__, line) + \": failed: bar\\n\",\n                mockCallback.text);\n      mockCallback.text.clear();\n    }\n\n    {\n      KJ_CONTEXT(\"grault\"); int cline2 = __LINE__;\n      EXPECT_FATAL(KJ_FAIL_ASSERT(\"bar\")); line = __LINE__;\n\n      EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, cline) + \": context: foo\\n\"\n                + fileLine(__FILE__, cline2) + \": context: grault\\n\"\n                + fileLine(__FILE__, line) + \": failed: bar\\n\",\n                mockCallback.text);\n      mockCallback.text.clear();\n    }\n  }\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
    "lines": "338-380",
    "snippet": "TEST(Debug, Syscall) {\n  MockExceptionCallback mockCallback;\n  int line;\n\n  int i = 123;\n  const char* str = \"foo\";\n\n  KJ_SYSCALL(mockSyscall(0));\n  KJ_SYSCALL(mockSyscall(1));\n\n  EXPECT_FATAL(KJ_SYSCALL(mockSyscall(-1, EBADF), i, \"bar\", str)); line = __LINE__;\n  EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, line) +\n            \": failed: mockSyscall(-1, EBADF): \" + strerror(EBADF) +\n            \"; i = 123; bar; str = foo\\n\", mockCallback.text);\n  mockCallback.text.clear();\n\n  EXPECT_FATAL(KJ_SYSCALL(mockSyscall(-1, ECONNRESET), i, \"bar\", str)); line = __LINE__;\n  EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, line) +\n            \": disconnected: mockSyscall(-1, ECONNRESET): \" + strerror(ECONNRESET) +\n            \"; i = 123; bar; str = foo\\n\", mockCallback.text);\n  mockCallback.text.clear();\n\n  EXPECT_FATAL(KJ_SYSCALL(mockSyscall(-1, ENOMEM), i, \"bar\", str)); line = __LINE__;\n  EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, line) +\n            \": overloaded: mockSyscall(-1, ENOMEM): \" + strerror(ENOMEM) +\n            \"; i = 123; bar; str = foo\\n\", mockCallback.text);\n  mockCallback.text.clear();\n\n  EXPECT_FATAL(KJ_SYSCALL(mockSyscall(-1, ENOSYS), i, \"bar\", str)); line = __LINE__;\n  EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, line) +\n            \": unimplemented: mockSyscall(-1, ENOSYS): \" + strerror(ENOSYS) +\n            \"; i = 123; bar; str = foo\\n\", mockCallback.text);\n  mockCallback.text.clear();\n\n  int result = 0;\n  bool recovered = false;\n  KJ_SYSCALL(result = mockSyscall(-2, EBADF), i, \"bar\", str) { recovered = true; break; } line = __LINE__;\n  EXPECT_EQ(\"recoverable exception: \" + fileLine(__FILE__, line) +\n            \": failed: mockSyscall(-2, EBADF): \" + strerror(EBADF) +\n            \"; i = 123; bar; str = foo\\n\", mockCallback.text);\n  EXPECT_EQ(-2, result);\n  EXPECT_TRUE(recovered);\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include \"miniposix.h\"",
      "#include <exception>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdio.h>",
      "#include <string>",
      "#include <kj/compat/gtest.h>",
      "#include \"exception.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "recovered"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "-2",
            "result"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"recoverable exception: \" + fileLine(__FILE__, line) +\n            \": failed: mockSyscall(-2, EBADF): \" + strerror(EBADF) +\n            \"; i = 123; bar; str = foo\\n\"",
            "mockCallback.text"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "EBADF"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileLine",
          "args": [
            "__FILE__",
            "line"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "fileLine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
          "lines": "184-190",
          "snippet": "std::string fileLine(std::string file, int line) {\n  file += ':';\n  char buffer[32];\n  sprintf(buffer, \"%d\", line);\n  file += buffer;\n  return file;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include \"miniposix.h\"",
            "#include <exception>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdio.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include \"exception.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nstd::string fileLine(std::string file, int line) {\n  file += ':';\n  char buffer[32];\n  sprintf(buffer, \"%d\", line);\n  file += buffer;\n  return file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "result = mockSyscall(-2, EBADF)",
            "i",
            "\"bar\"",
            "str"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mockSyscall",
          "args": [
            "-2",
            "EBADF"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mockCallback.text.clear",
          "args": [],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "TestPipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed-test.c++",
          "lines": "51-54",
          "snippet": "void clear(size_t preferredReadSize = kj::maxValue) {\n    resetRead(preferredReadSize);\n    data.clear();\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <stdlib.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"serialize-packed.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <stdlib.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nTestPipe {\n  void clear(size_t preferredReadSize = kj::maxValue) {\n      resetRead(preferredReadSize);\n      data.clear();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"fatal exception: \" + fileLine(__FILE__, line) +\n            \": unimplemented: mockSyscall(-1, ENOSYS): \" + strerror(ENOSYS) +\n            \"; i = 123; bar; str = foo\\n\"",
            "mockCallback.text"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "ENOSYS"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FATAL",
          "args": [
            "KJ_SYSCALL(mockSyscall(-1, ENOSYS), i, \"bar\", str)"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mockSyscall(-1, ENOSYS)",
            "i",
            "\"bar\"",
            "str"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mockSyscall",
          "args": [
            "-1",
            "ENOSYS"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"fatal exception: \" + fileLine(__FILE__, line) +\n            \": overloaded: mockSyscall(-1, ENOMEM): \" + strerror(ENOMEM) +\n            \"; i = 123; bar; str = foo\\n\"",
            "mockCallback.text"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "ENOMEM"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FATAL",
          "args": [
            "KJ_SYSCALL(mockSyscall(-1, ENOMEM), i, \"bar\", str)"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mockSyscall(-1, ENOMEM)",
            "i",
            "\"bar\"",
            "str"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mockSyscall",
          "args": [
            "-1",
            "ENOMEM"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"fatal exception: \" + fileLine(__FILE__, line) +\n            \": disconnected: mockSyscall(-1, ECONNRESET): \" + strerror(ECONNRESET) +\n            \"; i = 123; bar; str = foo\\n\"",
            "mockCallback.text"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "ECONNRESET"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FATAL",
          "args": [
            "KJ_SYSCALL(mockSyscall(-1, ECONNRESET), i, \"bar\", str)"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mockSyscall(-1, ECONNRESET)",
            "i",
            "\"bar\"",
            "str"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mockSyscall",
          "args": [
            "-1",
            "ECONNRESET"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"fatal exception: \" + fileLine(__FILE__, line) +\n            \": failed: mockSyscall(-1, EBADF): \" + strerror(EBADF) +\n            \"; i = 123; bar; str = foo\\n\"",
            "mockCallback.text"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "EBADF"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FATAL",
          "args": [
            "KJ_SYSCALL(mockSyscall(-1, EBADF), i, \"bar\", str)"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mockSyscall(-1, EBADF)",
            "i",
            "\"bar\"",
            "str"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mockSyscall",
          "args": [
            "-1",
            "EBADF"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mockSyscall(1)"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mockSyscall",
          "args": [
            "1"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "mockSyscall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
          "lines": "333-336",
          "snippet": "int mockSyscall(int i, int error = 0) {\n  errno = error;\n  return i;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include \"miniposix.h\"",
            "#include <exception>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdio.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include \"exception.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nint mockSyscall(int i, int error = 0) {\n  errno = error;\n  return i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "mockSyscall(0)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nTEST(Debug, Syscall) {\n  MockExceptionCallback mockCallback;\n  int line;\n\n  int i = 123;\n  const char* str = \"foo\";\n\n  KJ_SYSCALL(mockSyscall(0));\n  KJ_SYSCALL(mockSyscall(1));\n\n  EXPECT_FATAL(KJ_SYSCALL(mockSyscall(-1, EBADF), i, \"bar\", str)); line = __LINE__;\n  EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, line) +\n            \": failed: mockSyscall(-1, EBADF): \" + strerror(EBADF) +\n            \"; i = 123; bar; str = foo\\n\", mockCallback.text);\n  mockCallback.text.clear();\n\n  EXPECT_FATAL(KJ_SYSCALL(mockSyscall(-1, ECONNRESET), i, \"bar\", str)); line = __LINE__;\n  EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, line) +\n            \": disconnected: mockSyscall(-1, ECONNRESET): \" + strerror(ECONNRESET) +\n            \"; i = 123; bar; str = foo\\n\", mockCallback.text);\n  mockCallback.text.clear();\n\n  EXPECT_FATAL(KJ_SYSCALL(mockSyscall(-1, ENOMEM), i, \"bar\", str)); line = __LINE__;\n  EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, line) +\n            \": overloaded: mockSyscall(-1, ENOMEM): \" + strerror(ENOMEM) +\n            \"; i = 123; bar; str = foo\\n\", mockCallback.text);\n  mockCallback.text.clear();\n\n  EXPECT_FATAL(KJ_SYSCALL(mockSyscall(-1, ENOSYS), i, \"bar\", str)); line = __LINE__;\n  EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, line) +\n            \": unimplemented: mockSyscall(-1, ENOSYS): \" + strerror(ENOSYS) +\n            \"; i = 123; bar; str = foo\\n\", mockCallback.text);\n  mockCallback.text.clear();\n\n  int result = 0;\n  bool recovered = false;\n  KJ_SYSCALL(result = mockSyscall(-2, EBADF), i, \"bar\", str) { recovered = true; break; } line = __LINE__;\n  EXPECT_EQ(\"recoverable exception: \" + fileLine(__FILE__, line) +\n            \": failed: mockSyscall(-2, EBADF): \" + strerror(EBADF) +\n            \"; i = 123; bar; str = foo\\n\", mockCallback.text);\n  EXPECT_EQ(-2, result);\n  EXPECT_TRUE(recovered);\n}"
  },
  {
    "function_name": "mockSyscall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
    "lines": "333-336",
    "snippet": "int mockSyscall(int i, int error = 0) {\n  errno = error;\n  return i;\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include \"miniposix.h\"",
      "#include <exception>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdio.h>",
      "#include <string>",
      "#include <kj/compat/gtest.h>",
      "#include \"exception.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nint mockSyscall(int i, int error = 0) {\n  errno = error;\n  return i;\n}"
  },
  {
    "function_name": "KJ_IF_MAYBE",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
    "lines": "302-309",
    "snippet": "KJ_IF_MAYBE(e, exception) {\n      String what = str(*e);\n      KJ_IF_MAYBE(eol, what.findFirst('\\n')) {\n        what = kj::str(what.slice(0, *eol));\n      }\n      std::string text(what.cStr());\n      EXPECT_EQ(fileLine(__FILE__, line) + \": failed: foo\", text);\n    }",
    "includes": [
      "#include <sys/wait.h>",
      "#include \"miniposix.h\"",
      "#include <exception>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdio.h>",
      "#include <string>",
      "#include <kj/compat/gtest.h>",
      "#include \"exception.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "fileLine(__FILE__, line) + \": failed: foo\"",
            "text"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileLine",
          "args": [
            "__FILE__",
            "line"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "fileLine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
          "lines": "184-190",
          "snippet": "std::string fileLine(std::string file, int line) {\n  file += ':';\n  char buffer[32];\n  sprintf(buffer, \"%d\", line);\n  file += buffer;\n  return file;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include \"miniposix.h\"",
            "#include <exception>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdio.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include \"exception.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nstd::string fileLine(std::string file, int line) {\n  file += ':';\n  char buffer[32];\n  sprintf(buffer, \"%d\", line);\n  file += buffer;\n  return file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "what.cStr",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "what.slice(0, *eol)"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "341-341",
          "snippet": "inline String str(String&& s) { return mv(s); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
        }
      },
      {
        "call_info": {
          "callee": "what.slice",
          "args": [
            "0",
            "*eol"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "what.findFirst",
          "args": [
            "'\\n'"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "findFirst",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "182-182",
          "snippet": "inline Maybe<size_t> findFirst(char c) const { return StringPtr(*this).findFirst(c); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline Maybe<size_t> findFirst(char c) const { return StringPtr(*this).findFirst(c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "*e"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "destroyObject",
          "container": "Arena",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.h",
          "lines": "129-131",
          "snippet": "static void destroyObject(void* pointer) {\n    dtor(*reinterpret_cast<T*>(pointer));\n  }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nArena {\n  static void destroyObject(void* pointer) {\n      dtor(*reinterpret_cast<T*>(pointer));\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nKJ_IF_MAYBE(e, exception) {\n      String what = str(*e);\n      KJ_IF_MAYBE(eol, what.findFirst('\\n')) {\n        what = kj::str(what.slice(0, *eol));\n      }\n      std::string text(what.cStr());\n      EXPECT_EQ(fileLine(__FILE__, line) + \": failed: foo\", text);\n    }"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
    "lines": "274-293",
    "snippet": "TEST(Debug, Catch) {\n  int line;\n\n  {\n    // Catch recoverable as kj::Exception.\n    Maybe<Exception> exception = kj::runCatchingExceptions([&](){\n      line = __LINE__; KJ_FAIL_ASSERT(\"foo\") { break; }\n    });\n\n    KJ_IF_MAYBE(e, exception) {\n      String what = str(*e);\n      KJ_IF_MAYBE(eol, what.findFirst('\\n')) {\n        what = kj::str(what.slice(0, *eol));\n      }\n      std::string text(what.cStr());\n      EXPECT_EQ(fileLine(__FILE__, line) + \": failed: foo\", text);\n    } else {\n      ADD_FAILURE() << \"Expected exception.\";\n    }\n  }",
    "includes": [
      "#include <sys/wait.h>",
      "#include \"miniposix.h\"",
      "#include <exception>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdio.h>",
      "#include <string>",
      "#include <kj/compat/gtest.h>",
      "#include \"exception.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADD_FAILURE",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "fileLine(__FILE__, line) + \": failed: foo\"",
            "text"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileLine",
          "args": [
            "__FILE__",
            "line"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "fileLine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
          "lines": "184-190",
          "snippet": "std::string fileLine(std::string file, int line) {\n  file += ':';\n  char buffer[32];\n  sprintf(buffer, \"%d\", line);\n  file += buffer;\n  return file;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include \"miniposix.h\"",
            "#include <exception>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdio.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include \"exception.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nstd::string fileLine(std::string file, int line) {\n  file += ':';\n  char buffer[32];\n  sprintf(buffer, \"%d\", line);\n  file += buffer;\n  return file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "what.cStr",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "what.slice(0, *eol)"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "341-341",
          "snippet": "inline String str(String&& s) { return mv(s); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
        }
      },
      {
        "call_info": {
          "callee": "what.slice",
          "args": [
            "0",
            "*eol"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "eol",
            "what.findFirst('\\n')"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
          "lines": "302-309",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n      String what = str(*e);\n      KJ_IF_MAYBE(eol, what.findFirst('\\n')) {\n        what = kj::str(what.slice(0, *eol));\n      }\n      std::string text(what.cStr());\n      EXPECT_EQ(fileLine(__FILE__, line) + \": failed: foo\", text);\n    }",
          "includes": [
            "#include <sys/wait.h>",
            "#include \"miniposix.h\"",
            "#include <exception>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdio.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include \"exception.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nKJ_IF_MAYBE(e, exception) {\n      String what = str(*e);\n      KJ_IF_MAYBE(eol, what.findFirst('\\n')) {\n        what = kj::str(what.slice(0, *eol));\n      }\n      std::string text(what.cStr());\n      EXPECT_EQ(fileLine(__FILE__, line) + \": failed: foo\", text);\n    }"
        }
      },
      {
        "call_info": {
          "callee": "what.findFirst",
          "args": [
            "'\\n'"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "findFirst",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "182-182",
          "snippet": "inline Maybe<size_t> findFirst(char c) const { return StringPtr(*this).findFirst(c); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline Maybe<size_t> findFirst(char c) const { return StringPtr(*this).findFirst(c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "*e"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "destroyObject",
          "container": "Arena",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.h",
          "lines": "129-131",
          "snippet": "static void destroyObject(void* pointer) {\n    dtor(*reinterpret_cast<T*>(pointer));\n  }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nArena {\n  static void destroyObject(void* pointer) {\n      dtor(*reinterpret_cast<T*>(pointer));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&](){\n      line = __LINE__; KJ_FAIL_ASSERT(\"foo\") { break; }\n    }"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"foo\""
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nTEST(Debug, Catch) {\n  int line;\n\n  {\n    // Catch recoverable as kj::Exception.\n    Maybe<Exception> exception = kj::runCatchingExceptions([&](){\n      line = __LINE__; KJ_FAIL_ASSERT(\"foo\") { break; }\n    });\n\n    KJ_IF_MAYBE(e, exception) {\n      String what = str(*e);\n      KJ_IF_MAYBE(eol, what.findFirst('\\n')) {\n        what = kj::str(what.slice(0, *eol));\n      }\n      std::string text(what.cStr());\n      EXPECT_EQ(fileLine(__FILE__, line) + \": failed: foo\", text);\n    } else {\n      ADD_FAILURE() << \"Expected exception.\";\n    }\n  }"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
    "lines": "263-272",
    "snippet": "TEST(Debug, Exception) {\n  int i = 123;\n\n  int line = __LINE__; Exception exception = KJ_EXCEPTION(DISCONNECTED, \"foo\", i);\n\n  EXPECT_EQ(Exception::Type::DISCONNECTED, exception.getType());\n  EXPECT_STREQ(__FILE__, exception.getFile());\n  EXPECT_EQ(line, exception.getLine());\n  EXPECT_EQ(\"foo; i = 123\", exception.getDescription());\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include \"miniposix.h\"",
      "#include <exception>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdio.h>",
      "#include <string>",
      "#include <kj/compat/gtest.h>",
      "#include \"exception.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo; i = 123\"",
            "exception.getDescription()"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception.getDescription",
          "args": [],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "getDescription",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "81-81",
          "snippet": "StringPtr getDescription() const { return description; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  StringPtr getDescription() const { return description; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "line",
            "exception.getLine()"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception.getLine",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "getLine",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "79-79",
          "snippet": "int getLine() const { return line; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  int getLine() const { return line; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_STREQ",
          "args": [
            "__FILE__",
            "exception.getFile()"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception.getFile",
          "args": [],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "Exception::Type::DISCONNECTED",
            "exception.getType()"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception.getType",
          "args": [],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "80-80",
          "snippet": "Type getType() const { return type; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  Type getType() const { return type; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_EXCEPTION",
          "args": [
            "DISCONNECTED",
            "\"foo\"",
            "i"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nTEST(Debug, Exception) {\n  int i = 123;\n\n  int line = __LINE__; Exception exception = KJ_EXCEPTION(DISCONNECTED, \"foo\", i);\n\n  EXPECT_EQ(Exception::Type::DISCONNECTED, exception.getType());\n  EXPECT_STREQ(__FILE__, exception.getFile());\n  EXPECT_EQ(line, exception.getLine());\n  EXPECT_EQ(\"foo; i = 123\", exception.getDescription());\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
    "lines": "192-261",
    "snippet": "TEST(Debug, Log) {\n  MockExceptionCallback mockCallback;\n  int line;\n\n  KJ_LOG(WARNING, \"Hello world!\"); line = __LINE__;\n  EXPECT_EQ(\"log message: \" + fileLine(__FILE__, line) + \":+0: warning: Hello world!\\n\",\n            mockCallback.text);\n  mockCallback.text.clear();\n\n  int i = 123;\n  const char* str = \"foo\";\n\n  KJ_LOG(ERROR, i, str); line = __LINE__;\n  EXPECT_EQ(\"log message: \" + fileLine(__FILE__, line) + \":+0: error: i = 123; str = foo\\n\",\n            mockCallback.text);\n  mockCallback.text.clear();\n\n  KJ_DBG(\"Some debug text.\"); line = __LINE__;\n  EXPECT_EQ(\"log message: \" + fileLine(__FILE__, line) + \":+0: debug: Some debug text.\\n\",\n            mockCallback.text);\n  mockCallback.text.clear();\n\n  // INFO logging is disabled by default.\n  KJ_LOG(INFO, \"Info.\"); line = __LINE__;\n  EXPECT_EQ(\"\", mockCallback.text);\n  mockCallback.text.clear();\n\n  // Enable it.\n  Debug::setLogLevel(Debug::Severity::INFO);\n  KJ_LOG(INFO, \"Some text.\"); line = __LINE__;\n  EXPECT_EQ(\"log message: \" + fileLine(__FILE__, line) + \":+0: info: Some text.\\n\",\n            mockCallback.text);\n  mockCallback.text.clear();\n\n  // Back to default.\n  Debug::setLogLevel(Debug::Severity::WARNING);\n\n  KJ_ASSERT(1 == 1);\n  EXPECT_FATAL(KJ_ASSERT(1 == 2)); line = __LINE__;\n  EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, line) + \": failed: expected \"\n            \"1 == 2\\n\", mockCallback.text);\n  mockCallback.text.clear();\n\n  KJ_ASSERT(1 == 1) {\n    ADD_FAILURE() << \"Shouldn't call recovery code when check passes.\";\n    break;\n  };\n\n  bool recovered = false;\n  KJ_ASSERT(1 == 2, \"1 is not 2\") { recovered = true; break; } line = __LINE__;\n  EXPECT_EQ(\"recoverable exception: \" + fileLine(__FILE__, line) + \": failed: expected \"\n            \"1 == 2; 1 is not 2\\n\", mockCallback.text);\n  EXPECT_TRUE(recovered);\n  mockCallback.text.clear();\n\n  EXPECT_FATAL(KJ_ASSERT(1 == 2, i, \"hi\", str)); line = __LINE__;\n  EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, line) + \": failed: expected \"\n            \"1 == 2; i = 123; hi; str = foo\\n\", mockCallback.text);\n  mockCallback.text.clear();\n\n  EXPECT_FATAL(KJ_REQUIRE(1 == 2, i, \"hi\", str)); line = __LINE__;\n  EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, line) + \": failed: expected \"\n            \"1 == 2; i = 123; hi; str = foo\\n\", mockCallback.text);\n  mockCallback.text.clear();\n\n  EXPECT_FATAL(KJ_FAIL_ASSERT(\"foo\")); line = __LINE__;\n  EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, line) + \": failed: foo\\n\",\n            mockCallback.text);\n  mockCallback.text.clear();\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include \"miniposix.h\"",
      "#include <exception>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdio.h>",
      "#include <string>",
      "#include <kj/compat/gtest.h>",
      "#include \"exception.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mockCallback.text.clear",
          "args": [],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "TestPipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed-test.c++",
          "lines": "51-54",
          "snippet": "void clear(size_t preferredReadSize = kj::maxValue) {\n    resetRead(preferredReadSize);\n    data.clear();\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <stdlib.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"serialize-packed.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <stdlib.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nTestPipe {\n  void clear(size_t preferredReadSize = kj::maxValue) {\n      resetRead(preferredReadSize);\n      data.clear();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"fatal exception: \" + fileLine(__FILE__, line) + \": failed: foo\\n\"",
            "mockCallback.text"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileLine",
          "args": [
            "__FILE__",
            "line"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "fileLine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
          "lines": "184-190",
          "snippet": "std::string fileLine(std::string file, int line) {\n  file += ':';\n  char buffer[32];\n  sprintf(buffer, \"%d\", line);\n  file += buffer;\n  return file;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include \"miniposix.h\"",
            "#include <exception>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdio.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include \"exception.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nstd::string fileLine(std::string file, int line) {\n  file += ':';\n  char buffer[32];\n  sprintf(buffer, \"%d\", line);\n  file += buffer;\n  return file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_FATAL",
          "args": [
            "KJ_FAIL_ASSERT(\"foo\")"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"foo\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"fatal exception: \" + fileLine(__FILE__, line) + \": failed: expected \"\n            \"1 == 2; i = 123; hi; str = foo\\n\"",
            "mockCallback.text"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FATAL",
          "args": [
            "KJ_REQUIRE(1 == 2, i, \"hi\", str)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "1 == 2",
            "i",
            "\"hi\"",
            "str"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"fatal exception: \" + fileLine(__FILE__, line) + \": failed: expected \"\n            \"1 == 2; i = 123; hi; str = foo\\n\"",
            "mockCallback.text"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FATAL",
          "args": [
            "KJ_ASSERT(1 == 2, i, \"hi\", str)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "1 == 2",
            "i",
            "\"hi\"",
            "str"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "recovered"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"recoverable exception: \" + fileLine(__FILE__, line) + \": failed: expected \"\n            \"1 == 2; 1 is not 2\\n\"",
            "mockCallback.text"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "1 == 2",
            "\"1 is not 2\""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADD_FAILURE",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "1 == 1"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"fatal exception: \" + fileLine(__FILE__, line) + \": failed: expected \"\n            \"1 == 2\\n\"",
            "mockCallback.text"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FATAL",
          "args": [
            "KJ_ASSERT(1 == 2)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "1 == 2"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "1 == 1"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug::setLogLevel",
          "args": [
            "Debug::Severity::WARNING"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "setLogLevel",
          "container": "Debug",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.h",
          "lines": "281-281",
          "snippet": "static inline void setLogLevel(LogSeverity severity) { minSeverity = severity; }",
          "includes": [
            "#include \"exception.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exception.h\"\n#include \"string.h\"\n\nDebug {\n  static inline void setLogLevel(LogSeverity severity) { minSeverity = severity; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"log message: \" + fileLine(__FILE__, line) + \":+0: info: Some text.\\n\"",
            "mockCallback.text"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "INFO",
            "\"Some text.\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"\"",
            "mockCallback.text"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "INFO",
            "\"Info.\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"log message: \" + fileLine(__FILE__, line) + \":+0: debug: Some debug text.\\n\"",
            "mockCallback.text"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DBG",
          "args": [
            "\"Some debug text.\""
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"log message: \" + fileLine(__FILE__, line) + \":+0: error: i = 123; str = foo\\n\"",
            "mockCallback.text"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "ERROR",
            "i",
            "str"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"log message: \" + fileLine(__FILE__, line) + \":+0: warning: Hello world!\\n\"",
            "mockCallback.text"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "WARNING",
            "\"Hello world!\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nTEST(Debug, Log) {\n  MockExceptionCallback mockCallback;\n  int line;\n\n  KJ_LOG(WARNING, \"Hello world!\"); line = __LINE__;\n  EXPECT_EQ(\"log message: \" + fileLine(__FILE__, line) + \":+0: warning: Hello world!\\n\",\n            mockCallback.text);\n  mockCallback.text.clear();\n\n  int i = 123;\n  const char* str = \"foo\";\n\n  KJ_LOG(ERROR, i, str); line = __LINE__;\n  EXPECT_EQ(\"log message: \" + fileLine(__FILE__, line) + \":+0: error: i = 123; str = foo\\n\",\n            mockCallback.text);\n  mockCallback.text.clear();\n\n  KJ_DBG(\"Some debug text.\"); line = __LINE__;\n  EXPECT_EQ(\"log message: \" + fileLine(__FILE__, line) + \":+0: debug: Some debug text.\\n\",\n            mockCallback.text);\n  mockCallback.text.clear();\n\n  // INFO logging is disabled by default.\n  KJ_LOG(INFO, \"Info.\"); line = __LINE__;\n  EXPECT_EQ(\"\", mockCallback.text);\n  mockCallback.text.clear();\n\n  // Enable it.\n  Debug::setLogLevel(Debug::Severity::INFO);\n  KJ_LOG(INFO, \"Some text.\"); line = __LINE__;\n  EXPECT_EQ(\"log message: \" + fileLine(__FILE__, line) + \":+0: info: Some text.\\n\",\n            mockCallback.text);\n  mockCallback.text.clear();\n\n  // Back to default.\n  Debug::setLogLevel(Debug::Severity::WARNING);\n\n  KJ_ASSERT(1 == 1);\n  EXPECT_FATAL(KJ_ASSERT(1 == 2)); line = __LINE__;\n  EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, line) + \": failed: expected \"\n            \"1 == 2\\n\", mockCallback.text);\n  mockCallback.text.clear();\n\n  KJ_ASSERT(1 == 1) {\n    ADD_FAILURE() << \"Shouldn't call recovery code when check passes.\";\n    break;\n  };\n\n  bool recovered = false;\n  KJ_ASSERT(1 == 2, \"1 is not 2\") { recovered = true; break; } line = __LINE__;\n  EXPECT_EQ(\"recoverable exception: \" + fileLine(__FILE__, line) + \": failed: expected \"\n            \"1 == 2; 1 is not 2\\n\", mockCallback.text);\n  EXPECT_TRUE(recovered);\n  mockCallback.text.clear();\n\n  EXPECT_FATAL(KJ_ASSERT(1 == 2, i, \"hi\", str)); line = __LINE__;\n  EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, line) + \": failed: expected \"\n            \"1 == 2; i = 123; hi; str = foo\\n\", mockCallback.text);\n  mockCallback.text.clear();\n\n  EXPECT_FATAL(KJ_REQUIRE(1 == 2, i, \"hi\", str)); line = __LINE__;\n  EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, line) + \": failed: expected \"\n            \"1 == 2; i = 123; hi; str = foo\\n\", mockCallback.text);\n  mockCallback.text.clear();\n\n  EXPECT_FATAL(KJ_FAIL_ASSERT(\"foo\")); line = __LINE__;\n  EXPECT_EQ(\"fatal exception: \" + fileLine(__FILE__, line) + \": failed: foo\\n\",\n            mockCallback.text);\n  mockCallback.text.clear();\n}"
  },
  {
    "function_name": "fileLine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
    "lines": "184-190",
    "snippet": "std::string fileLine(std::string file, int line) {\n  file += ':';\n  char buffer[32];\n  sprintf(buffer, \"%d\", line);\n  file += buffer;\n  return file;\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include \"miniposix.h\"",
      "#include <exception>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdio.h>",
      "#include <string>",
      "#include <kj/compat/gtest.h>",
      "#include \"exception.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer",
            "\"%d\"",
            "line"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nstd::string fileLine(std::string file, int line) {\n  file += ':';\n  char buffer[32];\n  sprintf(buffer, \"%d\", line);\n  file += buffer;\n  return file;\n}"
  },
  {
    "function_name": "logMessage",
    "container": "MockExceptionCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
    "lines": "167-172",
    "snippet": "void logMessage(LogSeverity severity, const char* file, int line, int contextDepth,\n                  String&& text) override {\n    this->text += \"log message: \";\n    text = str(file, \":\", line, \":+\", contextDepth, \": \", severity, \": \", mv(text));\n    this->text.append(text.begin(), text.end());\n  }",
    "includes": [
      "#include <sys/wait.h>",
      "#include \"miniposix.h\"",
      "#include <exception>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdio.h>",
      "#include <string>",
      "#include <kj/compat/gtest.h>",
      "#include \"exception.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this->text.append",
          "args": [
            "text.begin()",
            "text.end()"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text.end",
          "args": [],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "693-693",
          "snippet": "inline Iterator end() const { return Iterator(value, count); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator end() const { return Iterator(value, count); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.begin",
          "args": [],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "file",
            "\":\"",
            "line",
            "\":+\"",
            "contextDepth",
            "\": \"",
            "severity",
            "\": \"",
            "mv(text)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "text"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nMockExceptionCallback {\n  void logMessage(LogSeverity severity, const char* file, int line, int contextDepth,\n                    String&& text) override {\n      this->text += \"log message: \";\n      text = str(file, \":\", line, \":+\", contextDepth, \": \", severity, \": \", mv(text));\n      this->text.append(text.begin(), text.end());\n    }\n}"
  },
  {
    "function_name": "onFatalException",
    "container": "MockExceptionCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
    "lines": "143-165",
    "snippet": "void onFatalException(Exception&& exception) override {\n    text += \"fatal exception: \";\n    auto what = str(exception);\n    // Discard the stack trace.\n    const char* end = strstr(what.cStr(), \"\\nstack: \");\n    if (end == nullptr) {\n      text += what.cStr();\n    } else {\n      text.append(what.cStr(), end);\n    }\n    text += '\\n';\n    flush();\n#if KJ_NO_EXCEPTIONS\n    if (outputPipe >= 0) {\n      // This is a child process.  We got what we want, now exit quickly without writing any\n      // additional messages, with a status code that the parent will interpret as \"exited in the\n      // way we expected\".\n      _exit(74);\n    }\n#else\n    throw MockException();\n#endif\n  }",
    "includes": [
      "#include <sys/wait.h>",
      "#include \"miniposix.h\"",
      "#include <exception>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdio.h>",
      "#include <string>",
      "#include <kj/compat/gtest.h>",
      "#include \"exception.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MockException",
          "args": [],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "flush",
          "container": "MockExceptionCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
          "lines": "108-127",
          "snippet": "void flush() {\n    if (outputPipe != -1) {\n      const char* pos = &*text.begin();\n      const char* end = pos + text.size();\n\n      while (pos < end) {\n        miniposix::ssize_t n = miniposix::write(outputPipe, pos, end - pos);\n        if (n < 0) {\n          if (errno == EINTR) {\n            continue;\n          } else {\n            break;  // Give up on error.\n          }\n        }\n        pos += n;\n      }\n\n      text.clear();\n    }\n  }",
          "includes": [
            "#include <sys/wait.h>",
            "#include \"miniposix.h\"",
            "#include <exception>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdio.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include \"exception.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nMockExceptionCallback {\n  void flush() {\n      if (outputPipe != -1) {\n        const char* pos = &*text.begin();\n        const char* end = pos + text.size();\n  \n        while (pos < end) {\n          miniposix::ssize_t n = miniposix::write(outputPipe, pos, end - pos);\n          if (n < 0) {\n            if (errno == EINTR) {\n              continue;\n            } else {\n              break;  // Give up on error.\n            }\n          }\n          pos += n;\n        }\n  \n        text.clear();\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "74"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text.append",
          "args": [
            "what.cStr()",
            "end"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "what.cStr",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "what.cStr",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "what.cStr()",
            "\"\\nstack: \""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "what.cStr",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "exception"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "destroyObject",
          "container": "Arena",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.h",
          "lines": "129-131",
          "snippet": "static void destroyObject(void* pointer) {\n    dtor(*reinterpret_cast<T*>(pointer));\n  }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nArena {\n  static void destroyObject(void* pointer) {\n      dtor(*reinterpret_cast<T*>(pointer));\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nMockExceptionCallback {\n  void onFatalException(Exception&& exception) override {\n      text += \"fatal exception: \";\n      auto what = str(exception);\n      // Discard the stack trace.\n      const char* end = strstr(what.cStr(), \"\\nstack: \");\n      if (end == nullptr) {\n        text += what.cStr();\n      } else {\n        text.append(what.cStr(), end);\n      }\n      text += '\\n';\n      flush();\n  #if KJ_NO_EXCEPTIONS\n      if (outputPipe >= 0) {\n        // This is a child process.  We got what we want, now exit quickly without writing any\n        // additional messages, with a status code that the parent will interpret as \"exited in the\n        // way we expected\".\n        _exit(74);\n      }\n  #else\n      throw MockException();\n  #endif\n    }\n}"
  },
  {
    "function_name": "onRecoverableException",
    "container": "MockExceptionCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
    "lines": "129-141",
    "snippet": "void onRecoverableException(Exception&& exception) override {\n    text += \"recoverable exception: \";\n    auto what = str(exception);\n    // Discard the stack trace.\n    const char* end = strstr(what.cStr(), \"\\nstack: \");\n    if (end == nullptr) {\n      text += what.cStr();\n    } else {\n      text.append(what.cStr(), end);\n    }\n    text += '\\n';\n    flush();\n  }",
    "includes": [
      "#include <sys/wait.h>",
      "#include \"miniposix.h\"",
      "#include <exception>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdio.h>",
      "#include <string>",
      "#include <kj/compat/gtest.h>",
      "#include \"exception.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush",
          "args": [],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "flush",
          "container": "MockExceptionCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
          "lines": "108-127",
          "snippet": "void flush() {\n    if (outputPipe != -1) {\n      const char* pos = &*text.begin();\n      const char* end = pos + text.size();\n\n      while (pos < end) {\n        miniposix::ssize_t n = miniposix::write(outputPipe, pos, end - pos);\n        if (n < 0) {\n          if (errno == EINTR) {\n            continue;\n          } else {\n            break;  // Give up on error.\n          }\n        }\n        pos += n;\n      }\n\n      text.clear();\n    }\n  }",
          "includes": [
            "#include <sys/wait.h>",
            "#include \"miniposix.h\"",
            "#include <exception>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdio.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include \"exception.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nMockExceptionCallback {\n  void flush() {\n      if (outputPipe != -1) {\n        const char* pos = &*text.begin();\n        const char* end = pos + text.size();\n  \n        while (pos < end) {\n          miniposix::ssize_t n = miniposix::write(outputPipe, pos, end - pos);\n          if (n < 0) {\n            if (errno == EINTR) {\n              continue;\n            } else {\n              break;  // Give up on error.\n            }\n          }\n          pos += n;\n        }\n  \n        text.clear();\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.append",
          "args": [
            "what.cStr()",
            "end"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "what.cStr",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "what.cStr",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "what.cStr()",
            "\"\\nstack: \""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "what.cStr",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "exception"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "destroyObject",
          "container": "Arena",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.h",
          "lines": "129-131",
          "snippet": "static void destroyObject(void* pointer) {\n    dtor(*reinterpret_cast<T*>(pointer));\n  }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nArena {\n  static void destroyObject(void* pointer) {\n      dtor(*reinterpret_cast<T*>(pointer));\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nMockExceptionCallback {\n  void onRecoverableException(Exception&& exception) override {\n      text += \"recoverable exception: \";\n      auto what = str(exception);\n      // Discard the stack trace.\n      const char* end = strstr(what.cStr(), \"\\nstack: \");\n      if (end == nullptr) {\n        text += what.cStr();\n      } else {\n        text.append(what.cStr(), end);\n      }\n      text += '\\n';\n      flush();\n    }\n}"
  },
  {
    "function_name": "flush",
    "container": "MockExceptionCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
    "lines": "108-127",
    "snippet": "void flush() {\n    if (outputPipe != -1) {\n      const char* pos = &*text.begin();\n      const char* end = pos + text.size();\n\n      while (pos < end) {\n        miniposix::ssize_t n = miniposix::write(outputPipe, pos, end - pos);\n        if (n < 0) {\n          if (errno == EINTR) {\n            continue;\n          } else {\n            break;  // Give up on error.\n          }\n        }\n        pos += n;\n      }\n\n      text.clear();\n    }\n  }",
    "includes": [
      "#include <sys/wait.h>",
      "#include \"miniposix.h\"",
      "#include <exception>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdio.h>",
      "#include <string>",
      "#include <kj/compat/gtest.h>",
      "#include \"exception.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "text.clear",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "TestPipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed-test.c++",
          "lines": "51-54",
          "snippet": "void clear(size_t preferredReadSize = kj::maxValue) {\n    resetRead(preferredReadSize);\n    data.clear();\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <stdlib.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"serialize-packed.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <stdlib.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nTestPipe {\n  void clear(size_t preferredReadSize = kj::maxValue) {\n      resetRead(preferredReadSize);\n      data.clear();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "miniposix::write",
          "args": [
            "outputPipe",
            "pos",
            "end - pos"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "TestRunner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "426-439",
          "snippet": "void write(Color color, StringPtr prefix, StringPtr message) {\n    StringPtr startColor, endColor;\n    if (useColor) {\n      switch (color) {\n        case RED:   startColor = \"\\033[0;1;31m\"; break;\n        case GREEN: startColor = \"\\033[0;1;32m\"; break;\n        case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n      }\n      endColor = \"\\033[0m\";\n    }\n\n    String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n    write(text);\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  void write(Color color, StringPtr prefix, StringPtr message) {\n      StringPtr startColor, endColor;\n      if (useColor) {\n        switch (color) {\n          case RED:   startColor = \"\\033[0;1;31m\"; break;\n          case GREEN: startColor = \"\\033[0;1;32m\"; break;\n          case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n        }\n        endColor = \"\\033[0m\";\n      }\n  \n      String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n      write(text);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.size",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.begin",
          "args": [],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nMockExceptionCallback {\n  void flush() {\n      if (outputPipe != -1) {\n        const char* pos = &*text.begin();\n        const char* end = pos + text.size();\n  \n        while (pos < end) {\n          miniposix::ssize_t n = miniposix::write(outputPipe, pos, end - pos);\n          if (n < 0) {\n            if (errno == EINTR) {\n              continue;\n            } else {\n              break;  // Give up on error.\n            }\n          }\n          pos += n;\n        }\n  \n        text.clear();\n      }\n    }\n}"
  },
  {
    "function_name": "forkForDeathTest",
    "container": "MockExceptionCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
    "lines": "57-106",
    "snippet": "bool forkForDeathTest() {\n    // This is called when exceptions are disabled.  We fork the process instead and then expect\n    // the child to die.\n\n#if _WIN32\n    // Windows doesn't support fork() or anything like it. Just skip the test.\n    return false;\n\n#else\n    int pipeFds[2];\n    KJ_SYSCALL(pipe(pipeFds));\n    pid_t child = fork();\n    if (child == 0) {\n      // This is the child!\n      close(pipeFds[0]);\n      outputPipe = pipeFds[1];\n      return true;\n    } else {\n      close(pipeFds[1]);\n\n      // Read child error messages into our local buffer.\n      char buf[1024];\n      for (;;) {\n        ssize_t n = read(pipeFds[0], buf, sizeof(buf));\n        if (n < 0) {\n          if (errno == EINTR) {\n            continue;\n          } else {\n            break;\n          }\n        } else if (n == 0) {\n          break;\n        } else {\n          text.append(buf, n);\n        }\n      }\n\n      close(pipeFds[0]);\n\n      // Get exit status.\n      int status;\n      KJ_SYSCALL(waitpid(child, &status, 0));\n\n      EXPECT_TRUE(WIFEXITED(status));\n      EXPECT_EQ(74, WEXITSTATUS(status));\n\n      return false;\n    }\n#endif  // _WIN32, else\n  }",
    "includes": [
      "#include <sys/wait.h>",
      "#include \"miniposix.h\"",
      "#include <exception>",
      "#include <string.h>",
      "#include <errno.h>",
      "#include <signal.h>",
      "#include <stdio.h>",
      "#include <string>",
      "#include <kj/compat/gtest.h>",
      "#include \"exception.h\"",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "74",
            "WEXITSTATUS(status)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "WIFEXITED(status)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "waitpid(child, &status, 0)"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "&status",
            "0"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pipeFds[0]"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "57-59",
          "snippet": "inline int close(int fd) {\n  return ::_close(fd);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int close(int fd) {\n  return ::_close(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.append",
          "args": [
            "buf",
            "n"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "pipeFds[0]",
            "buf",
            "sizeof(buf)"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "AsyncInputStream::read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1340-1342",
          "snippet": "Promise<void> AsyncInputStream::read(void* buffer, size_t bytes) {\n  return read(buffer, bytes, bytes).then([](size_t) {});\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nPromise<void> AsyncInputStream::read(void* buffer, size_t bytes) {\n  return read(buffer, bytes, bytes).then([](size_t) {});\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pipe(pipeFds)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pipeFds"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "84-86",
          "snippet": "inline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nMockExceptionCallback {\n  bool forkForDeathTest() {\n      // This is called when exceptions are disabled.  We fork the process instead and then expect\n      // the child to die.\n  \n  #if _WIN32\n      // Windows doesn't support fork() or anything like it. Just skip the test.\n      return false;\n  \n  #else\n      int pipeFds[2];\n      KJ_SYSCALL(pipe(pipeFds));\n      pid_t child = fork();\n      if (child == 0) {\n        // This is the child!\n        close(pipeFds[0]);\n        outputPipe = pipeFds[1];\n        return true;\n      } else {\n        close(pipeFds[1]);\n  \n        // Read child error messages into our local buffer.\n        char buf[1024];\n        for (;;) {\n          ssize_t n = read(pipeFds[0], buf, sizeof(buf));\n          if (n < 0) {\n            if (errno == EINTR) {\n              continue;\n            } else {\n              break;\n            }\n          } else if (n == 0) {\n            break;\n          } else {\n            text.append(buf, n);\n          }\n        }\n  \n        close(pipeFds[0]);\n  \n        // Get exit status.\n        int status;\n        KJ_SYSCALL(waitpid(child, &status, 0));\n  \n        EXPECT_TRUE(WIFEXITED(status));\n        EXPECT_EQ(74, WEXITSTATUS(status));\n  \n        return false;\n      }\n  #endif  // _WIN32, else\n    }\n}"
  }
]